"스프링 배치에서 배치 프로세스의 핵심 개념과 추상화는 무엇인가요?","스프링 배치의 핵심 개념과 추상화는 배치 도메인 언어의 핵심 개념과 추상화를 다루는 'The Domain Language of Batch(domain.html)' 섹션에서 찾을 수 있습니다. 이 섹션에서는 Job, Step, Tasklet, ItemReader, ItemWriter, ItemProcessor 등과 같은 주요 개념과 배치 데이터 처리에서 사용되는 용어에 대한 설명을 제공합니다. (출처: https://docs.spring.io/spring-batch/reference/index.html#domain)"
"스프링 배치에서 Job과 Step의 차이점은 무엇인가요?","Job은 일련의 Step으로 구성된 배치 프로세스를 의미하며, Step은 작업 단위로 수행되는 일련의 작업을 나타냅니다. Step은 ItemReader, ItemProcessor, ItemWriter 등의 구성 요소를 포함하여 데이터 처리의 주요 단위를 나타냅니다. Job은 여러 Step으로 구성될 수 있으며, Step은 Job 내에서 여러 번 실행될 수 있습니다. Job과 Step은 'Configuring and Running a Job(job.html)' 및 'Configuring a Step(step.html)' 섹션에서 자세히 설명되어 있습니다. (출처: https://docs.spring.io/spring-batch/reference/index.html#job, https://docs.spring.io/spring-batch/reference/index.html#step)"
"스프링 배치에서 배치 프로세스의 확장성과 병렬 처리를 어떻게 구현할 수 있나요?","스프링 배치는 멀티스레드 Step, 병렬 Step, 원격 청킹, 파티셔닝 등 다양한 확장성과 병렬 처리 기능을 제공합니다. 이러한 기능은 'Scaling and Parallel Processing(scalability.html#scalability)' 섹션에서 자세히 설명되어 있으며, 배치 프로세스의 확장성과 병렬 처리를 구현하는 방법에 대한 정보를 제공합니다. (출처: https://docs.spring.io/spring-batch/reference/index.html#scalability)"
"스프링 배치(Spring Batch)는 어떤 목적으로 설계된 프레임워크인가요?","스프링 배치는 기업 시스템의 일상적인 운영에 중요한 역할을 하는 강력한 배치 애플리케이션을 개발할 수 있도록 설계된 경량 종합 배치 프레임워크입니다. (출처: https://docs.spring.io/spring-batch/reference/spring-batch-intro.html)"
"스프링 배치 애플리케이션에서 스케줄러를 사용하는 목적은 무엇인가요?","스프링 배치는 스케줄러를 대체하는 것이 아니라 스케줄러와 함께 작동하도록 설계되었습니다. (출처: https://docs.spring.io/spring-batch/reference/spring-batch-intro.html)"
"스프링 배치는 어떤 비즈니스 시나리오를 지원하나요?","스프링 배치는 일괄 처리 프로세스 주기적 커밋, 동시 일괄 처리, 단계별 기업 메시지 기반 처리, 대량 병렬 일괄 처리, 실패 후 수동 또는 예약된 재시작, 종속 단계의 순차 처리, 부분 처리 등의 비즈니스 시나리오를 지원합니다. (출처: https://docs.spring.io/spring-batch/reference/spring-batch-intro.html)"
"스프링 배치 생태계의 계층적 아키텍처는 어떤 구성 요소로 이루어져 있나요?","스프링 배치 에코시스템의 계층적 아키텍처는 애플리케이션, 코어, 인프라스트럭처 구성 요소로 이루어져 있습니다. (출처: https://docs.spring.io/spring-batch/reference/spring-batch-architecture.html)"
"데이터베이스, 파일, 메시지 큐와 같은 다양한 입력 소스를 처리하는 데 사용되는 표준 유틸리티 단계는 무엇인가요?","데이터베이스, 파일, 메시지 큐와 같은 다양한 입력 소스를 처리하는 데 사용되는 표준 유틸리티 단계에는 정렬, 분할, 병합 등이 있습니다. (출처: https://docs.spring.io/spring-batch/reference/spring-batch-architecture.html)"
"배치 시스템에서 잠재적인 데드락 상황을 최소화하기 위해 어떤 설계 원칙을 따라야 하나요?","잠재적인 데드락 상황을 최소화하기 위해 데이터베이스 설계 팀은 가능한 한 경쟁 상황을 제거해야 하며, 개발자는 데드락 방지와 성능을 고려하여 데이터베이스 인덱스 테이블을 설계해야 합니다. (출처: https://docs.spring.io/spring-batch/reference/spring-batch-architecture.html)"
"Spring Batch 5.1에서 무엇이 변경되었나요?","Spring Batch 5.1에서는 Spring 의존성 업그레이드, 가상 스레드 지원, JpaItemWriter의 메모리 관리 개선, 항목 리더 및 라이터를 위한 새로운 동기화 데코레이터, MongoDB용 새로운 Cursor 기반 MongoItemReader, MongoDB용 MongoItemWriter의 대량 삽입 지원, Redis용 새로운 항목 리더 및 라이터, JobRegistryBeanPostProcessor의 자동 구성, 결정으로 작업 흐름을 시작할 수 있는 기능, 사용자 정의 JobKeyGenerator를 제공할 수 있는 기능, Antora 기반의 새로운 문서, 개선된 시작 경험 등이 포함되어 있습니다. 또한, MongoDB Job Repository, Composite Item Reader, 새로운 청크 지향 단계 구현 등의 실험적 기능도 포함되어 있습니다. (출처: https://docs.spring.io/spring-batch/reference/whatsnew.html)"
"Spring Batch 5.1에서 가상 스레드 지원은 어떤 역할을 하나요?","Spring Batch 5.1에서는 가상 스레드 지원이 추가되어 가상 스레드를 사용하여 프레임워크의 모든 영역에서 동시 단계를 실행하거나 가상 스레드를 사용하여 여러 단계를 병렬로 시작할 수 있습니다. 이는 Project Loom의 가상 스레드 지원을 포함하여 JDK 21 LTS를 수용하고 있습니다. (출처: https://docs.spring.io/spring-batch/reference/whatsnew.html)"
"Spring Batch 5.1에서 JpaItemWriter의 메모리 관리 개선은 어떤 내용을 포함하고 있나요?","Spring Batch 5.1에서는 JpaItemWriter에서 청크 크기가 충분히 큰 경우 JPA 지속성 컨텍스트가 빠르게 커질 수 있는 문제가 해결되었습니다. 이를 해결하기 위해 JpaItemWriter에 clearPersistenceContext라는 새로운 옵션이 도입되어 각 청크의 항목을 작성한 후 지속성 컨텍스트를 지울 수 있습니다. 이 옵션을 사용하면 대량의 데이터와 큰 청크 크기를 다루는 청크 지향 단계의 메모리 관리가 개선됩니다. (출처: https://docs.spring.io/spring-batch/reference/whatsnew.html)"
"스프링 배치의 Job과 JobInstance의 차이점은 무엇인가요?","Job은 배치 프로세스를 캡슐화하는 개체이며, JobInstance는 논리적인 Job 실행을 의미합니다. JobInstance는 Job과 식별 JobParameters로 정의됩니다. 이를 통해 개발자는 JobInstance가 어떻게 정의되는지 효과적으로 제어할 수 있습니다."
"스프링 배치의 Step과 StepExecution의 차이점은 무엇인가요?","Step은 배치 Job의 독립적이고 순차적인 단계를 캡슐화하는 도메인 개체이며, StepExecution은 Step을 실행하려는 단일 시도를 나타냅니다. StepExecution은 Step이 실제로 시작될 때만 생성됩니다."
"스프링 배치에서 ExecutionContext의 목적은 무엇인가요?","ExecutionContext는 개발자가 배치 실행 간에 지속해야 하는 사용자 데이터를 저장할 수 있는 키/값 쌍의 컬렉션을 나타냅니다. 이는 StepExecution 개체 또는 JobExecution 개체에 범위가 지정됩니다. (Quartz에 익숙한 사람들을 위해, 이는 JobDataMap과 매우 유사합니다.)"
"Spring Batch에서 Job을 어떻게 구성하나요?","Spring Batch에서 Job을 구성하기 위해서는 제공된 빌더 또는 XML 네임스페이스를 사용해야 합니다. Java에서는 @Bean 어노테이션을 사용하여 Job을 구성하고, XML에서는 job 요소를 사용하여 Job을 정의합니다. Job은 JobRepository를 필요로 하며, Java 구성을 통해 구성됩니다. Job은 Step 인스턴스로 구성되며, 병렬 처리, 선언적 흐름 제어 및 외부 흐름 정의를 위한 다른 요소도 포함할 수 있습니다. Job은 부모 빈 정의를 통해 단계를 만들거나, Step 구성을 인라인으로 선언할 수도 있습니다."
"Spring Batch에서 Job의 재실행 가능성은 어떻게 작동하나요?","Spring Batch에서 Job의 재실행 가능성은 Job의 재시작 동작을 제어하는 속성입니다. Job의 재실행 가능성은 기본적으로 true로 설정되어 있습니다. Job이 재실행 가능한지 여부를 결정하려면 JobExecution의 상태를 확인해야 합니다. Job을 재실행할 수 없도록 설정하려면 Java에서는 preventRestart 메서드를 사용하고, XML에서는 restartable 속성을 false로 설정하면 됩니다. Job이 재실행 불가능한 경우 기존 JobExecution에 대해 JobExecution을 만들려고 하면 JobRestartException이 발생합니다."
"Spring Batch에서 Job의 실행 중에 사용자 정의 코드를 실행하려면 어떻게 해야 하나요?","Spring Batch에서 Job의 실행 중에 사용자 정의 코드를 실행하려면 JobListener를 사용하여 Job의 수명 주기에 대한 이벤트를 수신할 수 있습니다. JobListener는 Job의 적절한 시간에 호출되며, Java에서는 @BeforeJob 및 @AfterJob 어노테이션을 사용하고, XML에서는 listener 요소를 사용합니다. JobListener의 afterJob 메서드는 Job의 성공 또는 실패에 관계없이 호출됩니다. JobListener를 Job에 추가하려면 Java에서는 listener 메서드를 사용하고, XML에서는 listeners 요소를 사용하면 됩니다."
"Spring Batch에서 Java 구성을 사용한 배치 작업을 어떻게 구성하나요?","Spring Batch 2.2.0부터는 Java 구성으로 배치 작업을 구성할 수 있습니다. 이를 위해 @EnableBatchProcessing 어노테이션과 두 개의 빌더를 사용합니다. @EnableBatchProcessing 어노테이션은 Spring 패밀리의 다른 @Enable* 어노테이션과 유사하게 작동합니다. 이 경우, @EnableBatchProcessing은 배치 작업을 빌드하기 위한 기본 구성을 제공합니다. 이 기본 구성 내에서 StepScope 및 JobScope의 인스턴스가 생성되며, JobRepository, JobLauncher, JobRegistry, JobExplorer 및 JobOperator와 같은 여러 빈이 autowire될 수 있습니다. 데이터 소스와 트랜잭션 매니저는 JobRepository 및 JobExplorer 인스턴스에서 사용됩니다. 기본적으로 dataSource 및 transactionManager라는 이름의 데이터 소스와 트랜잭션 매니저가 사용됩니다. @EnableBatchProcessing 어노테이션의 속성을 사용하여 이러한 빈 중 하나를 사용자 정의할 수 있습니다. 다음 예제는 사용자 정의 데이터 소스와 트랜잭션 매니저를 제공하는 방법을 보여줍니다."
"Spring Batch에서 DefaultBatchConfiguration 클래스를 사용하여 어떻게 기본 인프라 빈을 구성하나요?","v5.0부터 DefaultBatchConfiguration 클래스를 통해 기본 인프라 빈을 구성하는 대체적인 프로그래밍 방식이 제공됩니다. 이 클래스는 @EnableBatchProcessing에서 제공하는 것과 동일한 빈을 제공하며, 배치 작업을 구성하기 위한 기본 클래스로 사용할 수 있습니다. 다음 코드 조각은 이를 사용하는 일반적인 예입니다."
"Spring Batch에서 기본 인프라 빈을 선언적 방식과 프로그래밍 방식 중 어떤 방식을 사용해야 하나요?","참고로, @EnableBatchProcessing은 DefaultBatchConfiguration과 함께 사용해서는 안 됩니다. Spring Batch를 구성하는 선언적 방식( @EnableBatchProcessing을 통한 방식) 또는 프로그래밍 방식( DefaultBatchConfiguration을 확장하는 방식) 중 하나만 선택해야 합니다."
"스프링 배치에서 JobRepository를 구성하는 방법은 무엇인가요?","스프링 배치에서 JobRepository를 구성하는 방법은 Java와 XML 두 가지로 나뉩니다. Java에서는 @EnableBatchProcessing 어노테이션을 사용하여 JobRepository를 구성할 수 있으며, XML에서는 namespace를 사용하여 구성할 수 있습니다. 각각의 방법에서는 다양한 속성을 설정하여 JobRepository를 커스터마이징할 수 있습니다. 예를 들어, 데이터 소스, 트랜잭션 매니저, 테이블 접두사 등을 설정할 수 있습니다. 또한, 기본 격리 수준을 재정의하거나 테이블 접두사를 변경하는 등의 작업도 가능합니다. (출처: https://docs.spring.io/spring-batch/reference/job/configuring-repository.html)"
"스프링 배치에서 JobRepository의 테이블 접두사를 변경하는 방법은 무엇인가요?","스프링 배치에서 JobRepository의 테이블 접두사를 변경하는 방법은 Java와 XML 두 가지로 나뉩니다. Java에서는 @EnableBatchProcessing 어노테이션의 tablePrefix 속성을 사용하여 테이블 접두사를 변경할 수 있으며, XML에서는 job-repository 요소의 table-prefix 속성을 사용하여 테이블 접두사를 변경할 수 있습니다. 테이블 접두사를 변경하면 메타데이터 테이블의 모든 쿼리에 변경된 접두사가 추가됩니다. (출처: https://docs.spring.io/spring-batch/reference/job/configuring-repository.html)"
"스프링 배치에서 JobRepository의 트랜잭션 구성을 변경하는 방법은 무엇인가요?","스프링 배치에서 JobRepository의 트랜잭션 구성을 변경하는 방법은 namespace 또는 제공된 FactoryBean을 사용하는 것입니다. 이렇게 하면 트랜잭션 어드바이스가 자동으로 생성되어 리포지토리 주위에 적용됩니다. namespace를 사용하지 않는 경우, AOP를 사용하여 리포지토리의 트랜잭션 동작을 구성해야 합니다. Java에서는 TransactionProxyFactoryBean을 사용하여 트랜잭션 어드바이스를 구성할 수 있으며, XML에서는 aop:config와 tx:advice를 사용하여 트랜잭션 어드바이스를 구성할 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/job/configuring-repository.html)"
"JobLauncher 인터페이스를 구현하는 가장 기본적인 방법은 무엇인가요?","TaskExecutorJobLauncher 인터페이스를 구현하는 가장 기본적인 방법은 TaskExecutorJobLauncher입니다. (출처: https://docs.spring.io/spring-batch/reference/job/configuring-launcher.html)"
"TaskExecutorJobLauncher를 Java에서 구성하는 방법은 무엇인가요?","TaskExecutorJobLauncher를 Java에서 구성하려면 새로운 TaskExecutorJobLauncher 인스턴스를 생성하고 setJobRepository 메서드를 사용하여 JobRepository를 설정해야 합니다. (출처: https://docs.spring.io/spring-batch/reference/job/configuring-launcher.html)"
"TaskExecutorJobLauncher에서 작업을 비동기적으로 실행하려면 어떻게 해야 하나요?","TaskExecutor 인터페이스를 구현하는 클래스를 사용하여 작업을 비동기적으로 실행할 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/job/configuring-launcher.html)"
"커맨드라인에서 Spring Batch 작업을 실행하려면 어떤 정보가 필요한가요?","커맨드라인에서 Spring Batch 작업을 실행하려면 최소한 두 가지 정보가 필요합니다. 첫 번째는 실행할 Job이고, 두 번째는 JobLauncher입니다. 둘 다 동일한 컨텍스트 또는 다른 컨텍스트에 포함될 수 있습니다. 예를 들어, 명령줄에서 작업을 시작하는 경우 각 작업에 대해 새로운 JVM이 인스턴스화됩니다. 따라서 각 작업에는 자체 JobLauncher가 있습니다."
"Spring Batch에서 ExitStatus는 어떤 용도로 사용되나요?","Spring Batch에서 ExitStatus는 특정 배치 작업의 종료 코드를 숫자로 반환하는 방법을 제공합니다. 이는 엔터프라이즈 스케줄러와 같은 외부 시스템에서 작업의 성공 또는 실패를 나타내는 데 사용됩니다. ExitStatus는 5장에서 자세히 다룹니다."
"Spring Batch에서 커스텀 ExitCodeMapper를 구현해야 하는 경우는 어떤 경우인가요?","Spring Batch에서 커스텀 ExitCodeMapper를 구현해야 하는 경우는 기본 구현에서 제공하는 세 가지 값(완료, 일반 오류, Job 실행기 오류)보다 더 복잡한 시나리오가 필요한 경우입니다. 커스텀 ExitCodeMapper를 구현하려면 ExitCodeMapper 인터페이스를 구현하고, 문자열 종료 코드를 숫자로 변환하는 로직을 제공해야 합니다."
"JobRepository와 JobExplorer 인터페이스의 차이점은 무엇인가요?","JobRepository는 배치 도메인 객체의 CRUD 작업을 처리하고, JobExplorer는 메타데이터에 대한 쿼리 및 제어를 위한 추가 기능을 제공합니다. JobExplorer는 JobRepository의 읽기 전용 버전이며, 인터페이스 메서드 서명으로 알 수 있듯이 쿼리 전용입니다. JobExplorer는 팩토리 빈을 사용하여 쉽게 구성할 수 있습니다. JobExplorer의 테이블 접두사는 Java 및 XML 구성에서 설정할 수 있습니다."
"JobRegistry의 목적은 무엇인가요?","JobRegistry는 컨텍스트에서 사용 가능한 모든 작업을 추적하는 데 사용되며, 자식 컨텍스트에서 생성된 작업을 중앙에서 수집하는 데 유용합니다. JobRegistry는 Java 및 XML 구성에서 구성할 수 있으며, 빈 포스트 프로세서, 스마트 초기화 싱글톤 또는 등록기 라이프사이클 구성 요소를 사용하여 채울 수 있습니다. @EnableBatchProcessing을 사용할 때 JobRegistry가 자동으로 제공됩니다."
"JobOperator 인터페이스는 어떤 기능을 제공하나요?","JobOperator 인터페이스는 JobRepository 및 JobExplorer의 기능을 결합하여, 배치 작업자가 일반적으로 수행하는 작업 모니터링 작업(예: 작업 중지, 다시 시작, 요약)을 수행하는 데 가장 유용합니다. JobOperator의 제공 구현(SimpleJobOperator)은 JobExplorer, JobRepository, JobRegistry 및 JobLauncher를 포함한 많은 종속성이 있습니다. @EnableBatchProcessing 어노테이션은 버전 5.0부터 애플리케이션 컨텍스트에 작업 운영자 빈을 자동으로 등록합니다."
"배치 작업의 독립적이고 순차적인 단계를 캡슐화하는 도메인 객체는 무엇인가요?","Step은 배치 작업의 독립적이고 순차적인 단계를 캡슐화하는 도메인 객체입니다. (출처: https://docs.spring.io/spring-batch/reference/step.html)"
"Step은 개발자가 원하는 만큼 간단하거나 복잡할 수 있나요?","네, Step은 개발자가 원하는 만큼 간단하거나 복잡할 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/step.html)"
"Step의 내용은 누가 결정하나요?","Step의 내용은 Job을 작성하는 개발자가 결정합니다. (출처: https://docs.spring.io/spring-batch/reference/step.html)"
"스프링 배치에서 단계(Step)를 구성하는 데 필요한 필수 의존성은 무엇인가요?","스프링 배치에서 단계(Step)를 구성하는 데 필요한 필수 의존성은 reader, writer, transactionManager입니다. (출처: https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/configuring.html)"
"Java 구성을 사용하여 스프링 배치에서 단계(Step)를 구성하는 방법은 무엇인가요?","Java 구성을 사용하여 스프링 배치에서 단계(Step)를 구성하려면 StepBuilder를 사용하고 reader, writer, transactionManager를 설정해야 합니다. transactionManager는 처리 중에 트랜잭션을 시작하고 커밋하는 Spring의 PlatformTransactionManager입니다. repository는 처리 중에 StepExecution 및 ExecutionContext를 주기적으로 저장하는 Java 전용 이름의 JobRepository입니다. chunk는 트랜잭션이 커밋되기 전에 처리될 항목 수를 나타내는 Java 전용 이름의 의존성입니다. (출처: https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/configuring.html)"
"XML 구성을 사용하여 스프링 배치에서 단계(Step)를 구성하는 방법은 무엇인가요?","XML 구성을 사용하여 스프링 배치에서 단계(Step)를 구성하려면 tasklet 요소 내에서 chunk 요소를 사용하고 reader, writer, transaction-manager를 설정해야 합니다. transaction-manager는 처리 중에 트랜잭션을 시작하고 커밋하는 Spring의 PlatformTransactionManager입니다. job-repository는 처리 중에 StepExecution 및 ExecutionContext를 주기적으로 저장하는 XML 전용 이름의 JobRepository입니다. commit-interval은 트랜잭션이 커밋되기 전에 처리될 항목 수를 나타내는 XML 전용 이름의 의존성입니다. (출처: https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/configuring.html)"
"스프링 배치에서 부모 단계에서 상속을 하는 이유는 무엇인가요?","스프링 배치에서 부모 단계에서 상속을 하는 이유는 단계들의 구성이 중복되는 경우에 상속을 통해 코드를 재사용하고 효율적으로 관리할 수 있기 때문입니다. 이를 통해 공통된 속성을 부모 단계에서 정의하고, 이를 상속받는 자식 단계에서는 필요한 속성만 추가하거나 수정하여 사용할 수 있습니다. (출처: <https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/inheriting-from-parent.html>)"
"스프링 배치에서 'abstract' 속성을 사용하는 단계의 상속은 어떻게 이루어지나요?","스프링 배치에서 'abstract' 속성을 사용하는 단계의 상속은 완전한 단계 구성이 아닌 부모 단계를 정의할 때 사용됩니다. 이 경우, reader, writer, tasklet 등의 속성이 생략되어도 초기화가 실패하지 않습니다. 이러한 속성 중 하나 이상이 없는 경우에도 부모를 정의해야 할 때 'abstract' 속성을 사용하면 됩니다. 추상 단계는 확장만 가능하며, 인스턴스화되지 않습니다. (출처: <https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/inheriting-from-parent.html>)"
"스프링 배치에서 'merge' 속성을 사용하는 단계의 상속은 어떻게 이루어지나요?","스프링 배치에서 'merge' 속성을 사용하는 단계의 상속은 부모 단계와 자식 단계의 <listeners/> 요소와 같은 리스트 요소가 중복되는 경우에 사용됩니다. 이 때, 자식 단계의 <listeners/> 요소가 부모 단계의 <listeners/> 요소를 덮어쓰지 않고, 'merge' 속성을 사용하여 두 단계의 리스트를 결합할 수 있습니다. 이를 통해 자식 단계에서 부모 단계의 리스트에 추가적인 리스너를 추가할 수 있습니다. (출처: <https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/inheriting-from-parent.html>)"
"스프링 배치에서 커밋 간격이란 무엇인가요?","커밋 간격은 단계에서 트랜잭션이 커밋되기 전에 처리되는 항목 수를 나타냅니다. 기본값은 1이며, 항목당 트랜잭션을 시작하는 것은 트랜잭션 시작 및 커밋 비용이 비싸기 때문에 이상적이지 않습니다. 대신, 가능한 한 많은 항목을 트랜잭션에서 처리하는 것이 좋습니다. 이는 데이터 처리 유형 및 단계와 상호 작용하는 리소스에 따라 다릅니다. Java 및 XML 구성에서 commit-interval 속성을 사용하여 구성할 수 있습니다. {https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/commit-interval.html}"
"Java에서 spring batch의 commit-interval을 어떻게 설정하나요?","Java에서 spring batch의 commit-interval을 설정하려면 @Bean으로 주석이 달린 메서드에서 Chunk의 constructor를 사용하고 commit-interval 값을 지정하면 됩니다. 다음 예제는 commit-interval 값이 10인 Java에서 정의된 단계를 보여줍니다. {https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/commit-interval.html}"
"XML에서 spring batch의 commit-interval을 어떻게 설정하나요?","XML에서 spring batch의 commit-interval을 설정하려면 <chunk> 요소의 commit-interval 속성을 사용하면 됩니다. 다음 예제는 commit-interval 값이 10인 XML에서 정의된 단계를 보여줍니다. {https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/commit-interval.html}"
"스프링 배치에서 Step의 Start Limit을 설정하는 방법은 무엇인가요?","스프링 배치에서 Step의 Start Limit을 설정하는 방법은 Java와 XML 두 가지가 있습니다. Java에서는 StepBuilder의 startLimit() 메서드를 사용하여 제한을 설정하고, XML에서는 tasklet 태그에 start-limit 속성을 추가하여 제한을 설정합니다. 기본값은 Integer.MAX_VALUE로, 제한이 설정되지 않은 경우 Step은 무한히 실행될 수 있습니다."
"스프링 배치에서 완료된 Step을 다시 시작하는 방법은 무엇인가요?","스프링 배치에서 완료된 Step을 다시 시작하려면, Java에서는 StepBuilder의 allowStartIfComplete() 메서드를 사용하여 true로 설정하고, XML에서는 tasklet 태그에 allow-start-if-complete 속성을 추가하여 true로 설정합니다. 이렇게 설정하면 Step이 이미 완료된 경우에도 다시 실행됩니다. 기본값은 false로, 완료된 Step은 다시 실행되지 않습니다."
"스프링 배치에서 재시작 가능한 Job을 구성하는 방법은 무엇인가요?","스프링 배치에서 재시작 가능한 Job을 구성하려면, Java에서는 JobBuilder의 restartable() 메서드를 사용하여 true로 설정하고, XML에서는 job 태그에 restartable 속성을 추가하여 true로 설정합니다. 이렇게 설정하면 Job이 실패하거나 JobRepository에 저장된 후에도 다시 시작할 수 있습니다. 기본값은 false로, Job이 재시작 불가능합니다."
"스프링 배치에서 스킵 로직을 구성하는 이유는 무엇인가요?","스프링 배치에서 스킵 로직을 구성하는 이유는 처리 중에 발생한 오류가 Step 실패로 이어지지 않고 대신 건너뛰어져야 하는 다양한 시나리오가 있기 때문입니다. 이 결정은 데이터 자체와 그 의미를 이해하는 사람이 내려야 하는 결정입니다. 예를 들어, 금융 데이터는 완전히 정확해야 하기 때문에 스킵할 수 없을 수 있습니다. 반면에 공급 업체 목록을 로드하는 경우 스킵을 허용할 수 있습니다. 공급 업체가 잘못 포맷되었거나 필요한 정보가 누락되어 로드되지 않는 경우 문제가 없을 수 있습니다."
"스프링 배치에서 skipLimit 속성은 어떻게 사용되나요?","스키핑 로직을 구성하는 데 사용되는 skipLimit 속성은 Step에서 건너뛸 항목의 최대 수를 설정하는 데 사용됩니다. 이 값은 Java 및 XML 구성에서 chunk 처리에 대한 fault-tolerant 옵션을 사용할 때 설정할 수 있습니다. 10으로 설정된 경우, FlatFileParseException이 발생하면 항목이 건너뛰고 총 건너뛰기 제한인 10에 대해 카운트됩니다. chunk 처리 중에 발생할 수 있는 예외(및 해당 하위 클래스)의 스키핑은 읽기, 처리 또는 쓰기 단계에서 발생할 수 있습니다. Step 실행 내에서 읽기, 처리 및 쓰기에 대한 별도의 건너뛰기 카운트가 수행되지만 제한은 모든 건너뛰기에 적용됩니다. 건너뛰기 제한에 도달하면 다음 예외가 Step 실패를 유발합니다."
"스프링 배치에서 특정 예외를 건너뛰지 않도록 제외하는 방법은 무엇인가요?","스프링 배치에서 특정 예외를 건너뛰지 않도록 제외하려면 Java 및 XML 구성에서 noSkip() 메서드 또는 <exclude/> 요소를 사용할 수 있습니다. java.lang.Exception을 건너뛸 수 있는 예외 클래스로 식별하면 모든 Exception이 건너뛸 수 있음을 나타냅니다. 그러나 java.io.FileNotFoundException을 제외하면 FileNotFoundException을 제외한 모든 Exception을 건너뛸 수 있습니다. 제외된 예외 클래스는 만나면 치명적입니다(즉, 건너뛰지 않습니다). 모든 예외에 대해 분류되지 않은 예외는 '치명적'으로 처리됩니다."
"스프링 배치에서 트랜잭션 속성을 설정하는 방법은 무엇인가요?","스프링 배치에서 트랜잭션 속성을 설정하려면 Java나 XML을 사용할 수 있습니다. Java에서는 DefaultTransactionAttribute 객체를 생성하여 isolation, propagation, timeout 속성을 설정할 수 있습니다. XML에서는 <transaction-attributes> 요소를 사용하여 isolation, propagation, timeout 속성을 설정할 수 있습니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/transaction-attributes.html"
"Java에서 isolation level을 설정하는 방법은 무엇인가요?","Java에서 isolation level을 설정하려면 DefaultTransactionAttribute 객체를 생성하고 setIsolationLevel 메소드를 사용하면 됩니다. 이 메소드는 isolation level을 나타내는 int 값을 인자로 받습니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/transaction-attributes.html"
"XML에서 propagation behavior를 설정하는 방법은 무엇인가요?","XML에서 propagation behavior를 설정하려면 <transaction-attributes> 요소 내에 propagation 속성을 사용하면 됩니다. 이 속성은 Propagation 열거형의 값을 인자로 받습니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/transaction-attributes.html"
"스프링 배치에서 ItemStream을 Step에 등록하는 목적은 무엇인가요?","ItemStream을 Step에 등록하는 목적은 Step이 실행 중에 ItemStream 콜백을 처리할 수 있도록 하는 것입니다. 이는 Step이 실패하고 다시 시작되어야 할 때, ItemStream 인터페이스를 통해 Step이 실행 간에 지속되는 상태에 대한 정보를 얻을 수 있기 때문에 필수적입니다. (자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/registering-item-streams.html)"
"스프링 배치에서 ItemReader, ItemProcessor, ItemWriter가 ItemStream 인터페이스를 구현하는 경우는 어떻게 등록되나요?","ItemReader, ItemProcessor, ItemWriter가 ItemStream 인터페이스를 직접 구현하는 경우, 이들은 자동으로 등록됩니다. 그러나 대리자와 같은 간접적인 의존성이 리더와 라이터에 주입되는 경우와 같이 다른 스트림은 별도로 등록해야 합니다. (자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/registering-item-streams.html)"
"스프링 배치에서 Step에 스트림을 등록하는 방법은 무엇인가요?","스프링 배치에서 Step에 스트림을 등록하는 방법은 Java 구성과 XML 구성 두 가지가 있습니다. Java 구성에서는 `stream()` 메서드를 사용하여 Step에 스트림을 등록하고, XML 구성에서는 `<streams>` 요소를 사용하여 Step에 스트림을 등록합니다. (자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing/registering-item-streams.html)"
"스프링 배치에서 Step 실행 중 어떤 이벤트를 통해 기능을 수행할 수 있나요?","스프링 배치에서 Step 실행 중에는 StepExecutionListener, ChunkListener, ItemReadListener, ItemProcessListener, ItemWriteListener, SkipListener 등의 이벤트를 통해 기능을 수행할 수 있습니다. 이러한 이벤트는 Step, Chunk, Item 등의 실행 전, 후, 에러 발생 시 등을 포함합니다."
"스프링 배치에서 StepListener와 같은 인터페이스를 구현하는 ItemReader, ItemWriter, ItemProcessor를 Step에 등록하는 방법은 무엇인가요?","스프링 배치에서 StepListener와 같은 인터페이스를 구현하는 ItemReader, ItemWriter, ItemProcessor는 Step에 자동으로 등록됩니다. 이는 Step의 <step> 요소나 StepFactoryBean 팩토리 중 하나를 사용할 때만 적용됩니다. 직접 Step에 주입된 컴포넌트에만 적용되며, 다른 컴포넌트 안에 중첩된 경우 명시적으로 등록해야 합니다."
"스프링 배치에서 StepListener 인터페이스에 대응하는 어노테이션은 무엇인가요?","스프링 배치에서 StepListener 인터페이스에 대응하는 어노테이션은 StepExecutionListener의 경우 @BeforeStep, @AfterStep, ChunkListener의 경우 @BeforeChunk, @AfterChunk, @AfterChunkError, ItemReadListener의 경우 @BeforeRead, @AfterRead, @OnReadError, ItemProcessListener의 경우 @BeforeProcess, @AfterProcess, @OnProcessError, ItemWriteListener의 경우 @BeforeWrite, @AfterWrite, @OnWriteError, SkipListener의 경우 @OnSkipInRead, @OnSkipInProcess, @OnSkipInWrite 등이 있습니다."
"Spring Batch에서 TaskletStep은 어떤 경우에 사용되나요?","Spring Batch에서 TaskletStep은 Step이 저장 프로시저 호출로 구성되어야 하는 경우에 사용됩니다. TaskletStep은 execute 메서드를 반복적으로 호출하여 작업이 완료될 때까지 실행됩니다. TaskletStep은 Tasklet 인터페이스를 구현하며, TaskletAdapter를 사용하여 기존 클래스를 Tasklet으로 적응시킬 수 있습니다. TaskletStep은 StepListener 인터페이스를 구현하므로 자동으로 Tasklet을 StepListener로 등록합니다. TaskletStep은 chunk-oriented processing을 사용하지 않으며, chunk 요소를 사용하지 않습니다. TaskletStep은 Java와 XML 구성 모두에서 사용할 수 있습니다."
"TaskletAdapter는 Spring Batch에서 어떤 용도로 사용되나요?","TaskletAdapter는 Spring Batch에서 기존 클래스를 Tasklet으로 적응시키기 위해 사용됩니다. TaskletAdapter는 MethodInvokingTaskletAdapter를 사용하여 DAO와 같은 기존 클래스를 Tasklet으로 적응시킬 수 있습니다. TaskletAdapter는 Tasklet을 직접 구현하지 않고도 기존 클래스를 Tasklet으로 적응시킬 수 있는 편리한 방법입니다. TaskletAdapter는 Java와 XML 구성 모두에서 사용할 수 있습니다."
"Spring Batch에서 Tasklet의 예시는 무엇인가요?","Spring Batch에서 Tasklet의 예시로는 파일 삭제 Tasklet이 있습니다. 파일 삭제 Tasklet은 주어진 디렉토리 내의 모든 파일을 삭제합니다. 파일 삭제 Tasklet은 Java와 XML 구성 모두에서 사용할 수 있습니다. 파일 삭제 Tasklet은 Spring Batch samples 프로젝트에서 가져온 예시입니다."
"스프링 배치에서 Step의 실패가 Job의 실패를 의미하나요?","아니요, 스프링 배치에서 Step의 실패가 반드시 Job의 실패를 의미하지는 않습니다. Step의 실패가 발생하더라도 Job이 실패하지 않고 다른 Step을 실행하도록 구성할 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/step/controlling-flow.html)"
"스프링 배치에서 Step을 어떻게 순차적으로 실행할 수 있나요?","스프링 배치에서 Step을 순차적으로 실행하기 위해서는 Java에서는 next() 메서드를 사용하고, XML에서는 next 속성을 사용하여 Step 간의 의존성을 정의하면 됩니다. 첫 번째 Step이 정상적으로 완료되면 다음 Step이 실행되고, Step이 실패하면 Job이 실패하고 다음 Step은 실행되지 않습니다. (출처: https://docs.spring.io/spring-batch/reference/step/controlling-flow.html)"
"스프링 배치에서 Step의 ExitStatus와 BatchStatus의 차이점은 무엇인가요?","ExitStatus는 Step 실행 후의 상태를 나타내며, BatchStatus는 Job 또는 Step의 상태를 기록하는 데 사용되는 열거형입니다. 기본적으로 ExitStatus의 exit code는 Step의 BatchStatus와 동일하지만, StepExecutionListener를 사용하여 다른 exit code로 변경할 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/step/controlling-flow.html)"
"스프링 배치에서 Job 및 Step 속성의 지연 바인딩이란 무엇인가요?","스프링 배치에서 지연 바인딩은 Job 또는 Step이 실제로 실행될 때까지 여러 속성을 동적으로 설정할 수 있는 기능을 말합니다. 이를 통해 파일 이름, 데이터베이스 연결 등과 같은 런타임에 결정되는 값을 사용할 수 있습니다. 지연 바인딩은 일반적으로 시스템 속성이나 JobParameters를 사용하여 구현됩니다."
"지연 바인딩을 사용하여 파일 이름을 매개변수로 사용하는 방법은 무엇인가요?","JobParameters 또는 StepExecutionContext를 사용하여 파일 이름을 매개변수로 전달할 수 있습니다. Java에서는 @Value 어노테이션을 사용하여 JobParameters 또는 StepExecutionContext에서 값을 가져올 수 있습니다. XML 구성에서는 #{jobParameters['input.file.name']} 또는 #{stepExecutionContext['input.file.name']}와 같은 플레이스홀더를 사용하여 값을 참조할 수 있습니다."
"지연 바인딩을 사용하려면 어떤 스코프를 사용해야 하나요?","지연 바인딩을 사용하려면 Bean에 step 또는 job 스코프를 사용해야 합니다. step 스코프는 Step의 실행 범위 내에서 Bean을 생성하고, job 스코프는 Job의 실행 범위 내에서 Bean을 생성합니다. 스코프는 batch 네임스페이스, StepScope 또는 JobScope 빈 정의를 포함하거나 @EnableBatchProcessing 어노테이션을 사용하여 명시적으로 추가해야 합니다."
"Spring Batch에서 ItemReader, ItemProcessor, ItemWriter는 어떤 역할을 하나요?","Spring Batch에서 ItemReader는 데이터를 읽고, ItemProcessor는 데이터를 처리하며, ItemWriter는 처리된 데이터를 쓰는 역할을 합니다. (Source: <https://docs.spring.io/spring-batch/reference/readersAndWriters.html>)"
"Spring Batch에서 ItemReader와 ItemWriter를 커스터마이징하려면 어떻게 해야 하나요?","Spring Batch에서 ItemReader와 ItemWriter를 커스터마이징하려면 ItemReader와 ItemWriter 인터페이스를 구현하고, 커스텀 구현 클래스를 Step에 등록하면 됩니다. (Source: <https://docs.spring.io/spring-batch/reference/readersAndWriters.html>)"
"Spring Batch에서 ItemReader와 ItemWriter로 어떤 유형의 데이터를 처리할 수 있나요?","Spring Batch에서는 Flat Files, XML, JSON, Multi-File Input, Database 등 다양한 유형의 데이터를 처리할 수 있습니다. (Source: <https://docs.spring.io/spring-batch/reference/readersAndWriters.html>)"
"Spring Batch에서 ItemReader의 역할은 무엇인가요?","Spring Batch에서 ItemReader는 다양한 유형의 입력에서 데이터를 제공하는 수단입니다. 이는 간단한 개념이지만, 다양한 입력 소스에서 데이터를 처리하는 데 중요한 역할을 합니다. (출처: https://docs.spring.io/spring-batch/reference/readers-and-writers/item-reader.html)"
"Spring Batch에서 ItemReader의 가장 일반적인 예시는 무엇인가요?","Spring Batch에서 ItemReader의 가장 일반적인 예시는 Flat File, XML, Database입니다. Flat-file item readers는 파일에서 고정된 위치에 의해 정의된 필드 또는 특수 문자(쉼표 등)로 구분된 레코드를 설명하는 평면 파일에서 데이터 라인을 읽습니다. XML ItemReaders는 객체를 파싱, 매핑 및 검증하는 데 사용되는 기술과 독립적으로 XML을 처리합니다. 데이터베이스 리소스에 액세스하여 처리용 객체로 매핑할 수 있는 결과 집합을 반환합니다. (출처: https://docs.spring.io/spring-batch/reference/readers-and-writers/item-reader.html)"
"Spring Batch에서 ItemReader 인터페이스의 read 메소드는 어떤 역할을 하나요?","Spring Batch에서 ItemReader 인터페이스의 read 메소드는 ItemReader의 가장 필수적인 계약을 정의합니다. 이 메소드를 호출하면 하나의 항목이 반환되거나 더 이상 항목이 없으면 null이 반환됩니다. 항목은 일반적으로 파일에서 라인, 데이터베이스에서 행 또는 XML 파일에서 요소를 나타냅니다. 아이템 리더 인터페이스의 구현은 일반적으로 한 번만 호출되는 것이 기대됩니다. 그러나 기본 리소스가 트랜잭션(예: JMS 큐)인 경우 read를 호출하면 롤백 시나리오에서 후속 호출에서 동일한 논리적 항목이 반환될 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/readers-and-writers/item-reader.html)"
"ItemWriter의 주요 기능은 무엇인가요?","ItemWriter는 ItemReader와 유사한 기능을 가지지만, 역방향 작업을 수행합니다. 리소스를 찾고 열고 닫아야 하지만, ItemWriter는 입력하는 대신 출력합니다. 데이터베이스나 큐의 경우, 이러한 작업은 삽입, 업데이트 또는 전송일 수 있습니다. 출력의 직렬화 형식은 각 배치 작업에 특정합니다."
"ItemReader와 비교하여 ItemWriter의 주요 차이점은 무엇인가요?","ItemReader와 비교하여 ItemWriter의 주요 차이점은 ItemReader가 데이터를 읽는 반면, ItemWriter는 데이터를 쓴다는 것입니다. ItemWriter는 데이터를 쓰기 전에 리소스를 찾고 열고 닫아야 하지만, ItemReader는 데이터를 읽기 전에 리소스를 찾고 열고 닫아야 합니다."
"ItemWriter 인터페이스의 기본 계약은 무엇인가요?","ItemWriter 인터페이스의 기본 계약은 write 메서드입니다. 이 메서드는 열려 있는 한 전달된 항목 목록을 작성하려고 시도합니다. 항목이 청크로 '일괄 처리'되고 출력되는 것이 일반적이므로, 인터페이스는 항목 자체가 아닌 항목 목록을 허용합니다."
"ItemStream 인터페이스의 목적은 무엇인가요?","ItemStream 인터페이스는 ItemReader와 ItemWriter의 공통적인 관심사를 해결하기 위해 사용됩니다. 이 인터페이스는 리소스를 열고 닫고 상태를 지속시키는 메커니즘을 제공하여 배치 작업의 범위의 일부로 사용됩니다. ItemStream 인터페이스의 예시는 다음과 같습니다: public interface ItemStream { void open(ExecutionContext executionContext) throws ItemStreamException; void update(ExecutionContext executionContext) throws ItemStreamException; void close() throws ItemStreamException; }"
"ItemStream 인터페이스의 open 메서드의 목적은 무엇인가요?","ItemStream 인터페이스의 open 메서드는 파일 또는 연결과 같은 리소스를 열고 필요한 연결을 얻기 위해 사용됩니다. ItemReader의 클라이언트는 read에 대한 호출 전에 open을 호출하여 리소스를 열어야 합니다."
"ItemStream 인터페이스의 update 메서드의 목적은 무엇인가요?","ItemStream 인터페이스의 update 메서드는 현재 유지되는 모든 상태를 제공된 ExecutionContext에 로드하는 데 사용됩니다. 이 메서드는 커밋하기 전에 호출되어 현재 상태가 데이터베이스에 커밋되기 전에 지속되도록 합니다."
"Spring Batch에서 대량의 데이터를 교환하기 위해 일반적으로 사용되는 메커니즘은 무엇인가요?","Spring Batch에서 대량의 데이터를 교환하기 위해 일반적으로 사용되는 메커니즘은 평면 파일입니다. (출처: https://docs.spring.io/spring-batch/reference/readers-and-writers/flat-files.html)"
"평면 파일의 두 가지 유형은 무엇인가요?","평면 파일의 두 가지 유형은 구분된 파일과 고정 길이 파일입니다. (출처: https://docs.spring.io/spring-batch/reference/readers-and-writers/flat-files.html)"
"Spring Batch의 FlatFileItemReader와 FlatFileItemWriter의 역할은 무엇인가요?","Spring Batch의 FlatFileItemReader는 평면 파일에서 데이터를 읽고, FlatFileItemWriter는 데이터를 평면 파일에 씁니다. (출처: https://docs.spring.io/spring-batch/reference/readers-and-writers/flat-files.html)"
"FlatFileItemReader에서 Resource와 LineMapper의 역할은 무엇인가요?","Resource는 Spring Core Resource를 나타내며, 파일을 읽을 위치를 지정합니다. LineMapper는 문자열을 항목 객체로 변환하는 역할을 합니다."
"Spring Batch에서 복잡한 배치 환경에서 파일의 이동은 어떻게 이루어지나요?","복잡한 배치 환경에서는 EAI 인프라에서 파일 이동을 관리하며, FTP 위치에서 배치 처리 위치로 파일을 이동하거나 그 반대로 이동합니다."
"FlatFileItemReader에서 'strict' 속성은 어떤 역할을 하나요?","FlatFileItemReader의 'strict' 속성은 입력 리소스가 존재하지 않을 때 예외를 던질지 여부를 결정합니다. 'true'로 설정하면 예외를 던지고, 'false'로 설정하면 로그를 기록하고 계속 진행합니다."
"Spring Batch에서 flat file에 쓰기 위해 어떤 단계를 거쳐야 하나요?","Spring Batch에서 flat file에 쓰기 위해서는 LineAggregator를 사용하여 여러 필드를 하나의 문자열로 집계해야 하며, FlatFileItemWriter를 사용하여 파일에 작성할 수 있습니다. LineAggregator의 가장 기본적인 구현체는 PassThroughLineAggregator입니다. 또한, 객체를 배열로 변환하기 위해 FieldExtractor를 작성해야 합니다. BeanWrapperFieldExtractor는 객체를 배열로 변환하는 기능을 제공하며, 이를 사용하여 도메인 객체를 파일에 작성할 수 있습니다."
"Spring Batch에서 FlatFileItemWriter의 Names property는 무엇인가요?","Spring Batch에서 FlatFileItemWriter의 Names property는 객체에서 파일에 작성할 필드의 이름을 지정하는 데 사용됩니다. 이 필드는 BeanWrapperFieldExtractor와 BeanWrapperFieldSetMapper에서 필드를 매핑하는 데 사용됩니다. 이름은 배열로 지정되며, 배열의 순서는 필드의 순서를 결정합니다."
"Spring Batch에서 FlatFileItemWriter의 Format property는 무엇인가요?","Spring Batch에서 FlatFileItemWriter의 Format property는 각 필드 사이에 공백을 사용하여 고정 너비의 flat file 형식을 작성하는 데 사용됩니다. 이 속성은 Java 5의 일부로 추가된 Formatter를 사용하여 구현됩니다. Format 속성은 C 프로그래밍 언어의 printf 기능을 기반으로 합니다. 대부분의 형식 지정 세부 정보는 Formatter Javadoc에서 찾을 수 있습니다."
"Spring Batch에서 XML 레코드를 읽고 Java 객체로 매핑하는 데 사용되는 트랜잭션 인프라는 무엇인가요?","Spring Batch는 XML 레코드를 읽고 Java 객체로 매핑하는 데 사용되는 트랜잭션 인프라를 제공합니다. 이를 위해 StAX API를 사용하여 I/O를 처리합니다. StAX API는 배치 처리 요구 사항에 적합하며, DOM과 SAX와는 달리 전체 입력을 한 번에 메모리에 로드하지 않고, 파싱 프로세스를 제어할 수 있습니다."
"Spring Batch에서 XML 입력 및 출력은 어떻게 처리되나요?","Spring Batch에서 XML 입력 및 출력은 '프래그먼트'라는 개별 레코드에 해당하는 XML 리소스로 처리됩니다. XML 프래그먼트는 Object/XML Mapping (OXM)을 사용하여 Java 객체로 바인딩됩니다. Spring Batch는 특정 XML 바인딩 기술에 종속되지 않으며, 일반적으로 Spring OXM에 위임하여 가장 인기 있는 OXM 기술에 대한 일관된 추상화를 제공합니다."
"StaxEventItemReader는 Spring Batch에서 어떻게 구성되나요?","StaxEventItemReader는 루트 요소 이름, 리소스 및 언마샬러를 제공하여 구성됩니다. 루트 요소 이름은 매핑할 객체를 구성하는 프래그먼트의 루트 요소의 이름입니다. 리소스는 읽을 파일을 나타내는 Spring 리소스입니다. 언마샬러는 XML 프래그먼트를 객체로 매핑하는 데 사용되는 Spring OXM에서 제공하는 언마샬링 시설입니다. Spring OXM에 대한 의존성은 선택 사항이며, 원하는 경우 Spring Batch 특정 인터페이스를 구현할 수 있습니다."
"Spring Batch에서 MultiResourceItemReader를 사용하는 이유는 무엇인가요?","Spring Batch에서 MultiResourceItemReader를 사용하는 이유는 동일한 형식을 가진 여러 파일을 하나의 Step에서 처리하는 일반적인 요구사항을 지원하기 때문입니다. 이를 통해 여러 입력 파일을 동시에 처리하여 처리량과 효율성을 향상시킬 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/readers-and-writers/multi-file-input.html)"
"Java와 XML에서 Spring Batch의 MultiResourceItemReader를 사용하여 와일드카드로 파일을 읽는 방법은 무엇인가요?","Java에서는 MultiResourceItemReaderBuilder를 사용하여 delegate로 FlatFileItemReader를 지정하고 resources 메서드를 사용하여 와일드카드를 가진 파일을 지정할 수 있습니다. XML에서는 MultiResourceItemReader의 resources 속성을 사용하여 와일드카드를 가진 파일을 지정하고 delegate 속성을 사용하여 참조된 FlatFileItemReader를 지정할 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/readers-and-writers/multi-file-input.html)"
"Spring Batch에서 MultiResourceItemReader를 사용할 때 추가 입력 파일을 고려하는 방법은 무엇인가요?","Spring Batch에서 MultiResourceItemReader를 사용할 때 추가 입력 파일을 고려할 때, 롤백 및 재시작 시나리오를 처리하여 잠재적인 문제를 방지해야 합니다. 배치 작업은 성공적으로 완료될 때까지 자체 개별 디렉토리와 함께 작동하는 것이 좋습니다. 입력 리소스 순서는 MultiResourceItemReader#setComparator(Comparator)를 사용하여 재시작 시나리오에서 작업 실행 간에 리소스 순서를 보존할 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/readers-and-writers/multi-file-input.html)"
"Spring Batch에서 대용량 데이터셋을 처리할 때 데이터베이스의 기본 접근 방식은 무엇인가요?","Spring Batch에서 대용량 데이터셋을 처리할 때 데이터베이스의 기본 접근 방식은 커서 기반 ItemReader 구현체입니다. 데이터베이스 커서를 사용하는 것이 일반적으로 대부분의 배치 개발자들이 선호하는 방법입니다. ResultSet 클래스는 커서를 조작하기 위한 객체 지향 메커니즘입니다. ResultSet은 현재 데이터 행의 커서를 유지합니다. ResultSet에서 next를 호출하면 이 커서가 다음 행으로 이동합니다. Spring Batch 커서 기반 ItemReader 구현체는 초기화 시 커서를 열고 read를 호출할 때마다 커서를 한 행씩 앞으로 이동하여 처리에 사용할 수 있는 매핑된 객체를 반환합니다. 그런 다음 close 메서드가 호출되어 모든 리소스가 해제됩니다."
"Spring Batch의 JdbcCursorItemReader에 대해 설명해주세요.","JdbcCursorItemReader는 커서 기반 기술의 JDBC 구현체입니다. ResultSet과 직접 작동하며, DataSource에서 가져온 연결에 대해 실행할 SQL 문이 필요합니다. JdbcCursorItemReader에는 ResultSet의 시작 행(row 1)이 ID 2에 있는 FOO 테이블에서 ID가 1보다 크고 7보다 작은 모든 행을 선택하는 예제가 있습니다. read() 메서드를 다시 호출하면 커서가 다음 행으로 이동하며, read된 결과는 각 read 후에 작성되어 객체를 가비지 수집할 수 있습니다."
"Spring Batch의 HibernateCursorItemReader에 대해 설명해주세요.","HibernateCursorItemReader는 커서 기술의 Hibernate 구현체입니다. Hibernate는 원래 온라인 애플리케이션 스타일을 지원하기 위해 개발되었지만, Hibernate는 일괄 처리에도 사용될 수 있습니다. HibernateCursorItemReader는 JdbcCursorItemReader와 기본적으로 동일한 방식으로 작동하지만, 쿼리를 실행하여 커서를 가져오는 대신 커서를 반환하는 저장 프로시저를 실행합니다. HibernateCursorItemReader를 구성하려면 SQL 대신 HQL 문을 선언하고 SessionFactory를 전달해야 합니다. 'useStatelessSession' 속성은 기본적으로 true로 설정되어 있지만, 켜거나 끌 수 있습니다."
"스프링 배치에서 기존 DAO나 서비스를 배치 작업 내에서 재사용하는 방법은 무엇인가요?","스프링 컨테이너 자체는 필요한 모든 클래스를 주입할 수 있도록 하여 이를 상당히 쉽게 만듭니다. 그러나 기존 서비스가 ItemReader 또는 ItemWriter로 작동해야 하는 경우가 있을 수 있습니다. 이는 다른 스프링 배치 클래스의 종속성을 충족하거나 단계의 주요 ItemReader인 경우입니다. 각 서비스를 감싸야 하는 어댑터 클래스를 작성하는 것은 상당히 간단하지만, 이는 일반적인 문제이기 때문에 스프링 배치에는 ItemReaderAdapter 및 ItemWriterAdapter 구현이 제공됩니다. 두 클래스 모두 표준 스프링 메서드를 구현하여 delegate 패턴을 호출하며 설정이 매우 간단합니다."
"스프링 배치의 ItemReaderAdapter를 어떻게 사용하나요?","ItemReaderAdapter는 표준 스프링 메서드를 구현하여 delegate 패턴을 호출하며 설정이 매우 간단합니다. Java 예제에서는 ItemReaderAdapter를 사용합니다. XML 예제에서는 ItemReaderAdapter를 사용합니다. 대상 메서드의 계약은 read와 동일해야 합니다. 소진되면 null을 반환하고, 그렇지 않으면 객체를 반환합니다. 다른 것은 프레임워크가 처리 종료 시기를 알 수 없게 하여 무한 루프 또는 잘못된 실패를 유발할 수 있습니다. 이는 ItemWriter의 구현에 따라 다릅니다."
"스프링 배치의 ItemWriterAdapter를 어떻게 사용하나요?","ItemWriterAdapter는 표준 스프링 메서드를 구현하여 delegate 패턴을 호출하며 설정이 매우 간단합니다. Java 예제에서는 ItemWriterAdapter를 사용합니다. XML 예제에서는 ItemWriterAdapter를 사용합니다. 대상 메서드의 계약은 read와 동일해야 합니다. 소진되면 null을 반환하고, 그렇지 않으면 객체를 반환합니다. 다른 것은 프레임워크가 처리 종료 시기를 알 수 없게 하여 무한 루프 또는 잘못된 실패를 유발할 수 있습니다. 이는 ItemWriter의 구현에 따라 다릅니다."
"왜 개발자들은 데이터베이스 리더에 'rerunnable'을 적용하는 것을 선택하나요?","개발자들은 데이터베이스 리더에 'rerunnable'을 적용하여 재시작 시 처리되지 않은 레코드만 반환하도록 하여 처리되지 않은 레코드를 보장하고, 현재 상태(예: 현재 행 번호)를 저장할 필요가 없어지기 때문에 재시작 시 관련이 없어집니다. (출처: https://docs.spring.io/spring-batch/reference/readers-and-writers/process-indicator.html)"
"JdbcCursorItemReader에서 state persistence를 방지하려면 어떻게 해야 하나요?","JdbcCursorItemReader에서 state persistence를 방지하려면 'saveState' 속성을 false로 설정해야 합니다. Java에서는 JdbcCursorItemReaderBuilder의 'saveState' 메서드를 사용하여 이를 설정할 수 있고, XML 구성에서는 'saveState' 속성을 false로 설정하여 이를 달성할 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/readers-and-writers/process-indicator.html)"
"JdbcCursorItemReader에서 'saveState' 속성은 어떤 역할을 하나요?","JdbcCursorItemReader에서 'saveState' 속성은 현재 상태를 ExecutionContext에 저장할지 여부를 제어하는 역할을 합니다. false로 설정하면 현재 상태를 저장하지 않습니다. 이는 재시작 시 관련 없는 상태(예: 현재 행 번호)를 저장할 필요가 없는 경우 유용합니다. (출처: https://docs.spring.io/spring-batch/reference/readers-and-writers/process-indicator.html)"
"Spring Batch에서 커스텀 ItemReader와 ItemWriter를 만드는 방법은 무엇인가요?","커스텀 ItemReader를 만들기 위해서는 ItemReader 인터페이스를 구현하고, 읽어야 할 데이터를 반환하는 read() 메소드를 구현해야 합니다. 커스텀 ItemWriter를 만들기 위해서는 ItemWriter 인터페이스를 구현하고, 써야 할 데이터를 전달받는 write() 메소드를 구현해야 합니다. 커스텀 ItemReader와 ItemWriter를 만드는 방법은 주어진 정보에서 간단한 예제를 통해 설명되어 있습니다."
"Spring Batch에서 커스텀 ItemReader를 재시작 가능하게 만드는 방법은 무엇인가요?","커스텀 ItemReader를 재시작 가능하게 만들기 위해서는 ItemStream 인터페이스를 구현하고, open() 및 update() 메소드를 구현해야 합니다. open() 메소드에서는 ExecutionContext에 저장된 항목을 읽어와 ItemReader의 현재 위치를 재구축하고, update() 메소드에서는 현재 위치를 ExecutionContext에 저장해야 합니다. 이 예제에서는 현재 위치를 'current.index'라는 키로 ExecutionContext에 저장하고 있습니다."
"Spring Batch에서 커스텀 ItemWriter를 재시작 가능하게 만드는 방법은 무엇인가요?","커스텀 ItemWriter를 재시작 가능하게 만들기 위해서는 ItemStream 인터페이스를 구현하고, open() 및 update() 메소드를 구현해야 합니다. open() 메소드에서는 ExecutionContext에 저장된 항목을 읽어와 ItemWriter의 현재 위치를 재구축하고, update() 메소드에서는 현재 위치를 ExecutionContext에 저장해야 합니다. 이 예제에서는 카운터의 값을 'counter'라는 키로 ExecutionContext에 저장하고 있습니다."
"Spring Batch에서 제공하는 Decorators 중 어떤 것들이 있고, 어떤 역할을 하는가요?","Spring Batch는 SynchronizedItemStreamReader, SingleItemPeekableItemReader, SynchronizedItemStreamWriter, MultiResourceItemWriter, ClassifierCompositeItemWriter, ClassifierCompositeItemProcessor 등의 Decorators를 제공합니다. 이 중 SynchronizedItemStreamReader는 스레드 안전하지 않은 ItemReader를 스레드 안전하게 만들어주는 역할을 합니다. SingleItemPeekableItemReader는 ItemReader에 peek 메서드를 추가하여 다음 항목을 미리 볼 수 있게 해줍니다. SynchronizedItemStreamWriter는 스레드 안전하지 않은 ItemWriter를 스레드 안전하게 만들어주는 역할을 합니다. MultiResourceItemWriter는 출력 리소스를 생성하여 항목이 작성될 때 항목 제한 수를 초과하면 새로운 출력 리소스를 생성합니다. ClassifierCompositeItemWriter는 제공된 Classifier를 통해 라우터 패턴을 구현하여 각 항목에 대해 ItemWriter 구현체 컬렉션 중 하나를 호출합니다. ClassifierCompositeItemProcessor는 제공된 Classifier를 통해 라우터 패턴을 구현하여 각 항목에 대해 ItemProcessor 구현체 컬렉션 중 하나를 호출합니다."
"Spring Batch에서 제공하는 Messaging Readers 및 Writers는 어떤 것들이 있고, 어떤 역할을 하는가요?","Spring Batch는 AmqpItemReader, AmqpItemWriter, JmsItemReader, JmsItemWriter, KafkaItemReader, KafkaItemWriter 등의 Messaging Readers 및 Writers를 제공합니다. AmqpItemReader는 AmqpTemplate을 사용하여 교환소에서 메시지를 수신하거나 변환하는 ItemReader입니다. AmqpItemWriter는 AmqpTemplate을 사용하여 AMQP 교환소로 메시지를 보내는 ItemWriter입니다. JmsItemReader는 JmsTemplate을 사용하여 JMS ItemReader로, read() 메서드에 항목을 제공합니다. JmsItemWriter는 JmsTemplate을 사용하여 JMS ItemWriter로, write(List)에 항목을 보냅니다. KafkaItemReader는 Apache Kafka 토픽의 ItemReader로, 메시지를 여러 파티션에서 읽을 수 있습니다. KafkaItemWriter는 Apache Kafka에 이벤트를 보내기 위해 KafkaTemplate을 사용하는 ItemWriter입니다."
"Spring Batch에서 제공하는 Database Readers 및 Writers는 어떤 것들이 있고, 어떤 역할을 하는가요?","Spring Batch는 Neo4jItemReader, MongoItemReader, HibernateCursorItemReader, HibernatePagingItemReader, RepositoryItemReader, Neo4jItemWriter, MongoItemWriter, RepositoryItemWriter, HibernateItemWriter, JdbcBatchItemWriter, JpaItemWriter 등의 Database Readers 및 Writers를 제공합니다. Neo4jItemReader는 그래프 데이터베이스 Neo4j에서 페이징 기술을 사용하여 객체를 읽는 ItemReader입니다. MongoItemReader는 MongoDB에서 페이징 기술을 사용하여 문서를 읽는 ItemReader입니다. HibernateCursorItemReader는 Hibernate를 기반으로 한 데이터베이스 레코드를 읽기 위한 ItemStreamReader입니다. HibernatePagingItemReader는 Hibernate를 기반으로 한 데이터베이스 레코드를 읽기 위한 ItemReader로, 한 번에 고정된 수의 항목만 읽습니다. RepositoryItemReader는 PagingAndSortingRepository를 사용하여 레코드를 읽는 ItemReader입니다. Neo4jItemWriter는 Neo4j 데이터베이스에 쓰는 ItemWriter 구현체입니다. MongoItemWriter는 Spring Data의 MongoOperations 구현체를 사용하여 MongoDB 스토어에 쓰는 ItemWriter 구현체입니다. RepositoryItemWriter는 Spring Data의 CrudRepository를 위한 ItemWriter 래퍼입니다. HibernateItemWriter는 현재 Hibernate 세션에 속하지 않은 엔티티를 저장하거나 업데이트하기 위해 Hibernate 세션을 사용하는 ItemWriter입니다. JdbcBatchItemWriter는 NamedParameterJdbcTemplate의 일괄 처리 기능을 사용하여 제공된 모든 항목에 대해 일괄 처리 문을 실행하는 ItemWriter입니다. JpaItemWriter는 JPA EntityManagerFactory를 사용하여 지속성 컨텍스트에 속하지 않은 엔티티를 병합하는 ItemWriter입니다."
"스프링 배치에서 ItemProcessor를 사용하는 이유는 무엇인가요?","ItemProcessor 인터페이스는 Step에서 비즈니스 로직을 추가하는 데 사용됩니다. ItemProcessor는 한 개의 객체를 주어진 경우에 해당 객체를 변환하고 다른 객체를 반환하는 간단한 인터페이스입니다. 비즈니스 로직은 process 메서드 내에서 적용될 수 있으며, 해당 로직을 생성하는 것은 개발자에게 완전히 달려 있습니다."
"스프링 배치에서 ItemProcessor를 여러 개 연결하려면 어떻게 해야 하나요?","ItemProcessor를 여러 개 연결하려면 이전에 언급된 복합 패턴을 사용할 수 있습니다. Foo 프로세서와 Bar 프로세서를 '연결'하여 결과 Foobar를 얻을 수 있습니다. CompositeItemProcessor 객체를 만들고 delegates 속성에 ItemProcessor 인스턴스를 설정합니다."
"스프링 배치에서 ItemProcessor를 사용하여 레코드를 필터링하는 방법은 무엇인가요?","ItemProcessor를 사용하여 레코드를 필터링하려면 레코드를 ItemWriter에 전달하기 전에 레코드를 검사하는 ItemProcessor를 구현하면 됩니다. ItemProcessor에서 null을 반환하면 프레임워크가 해당 항목을 ItemWriter에 전달되는 레코드 목록에 추가하지 않습니다."
"Spring Batch에서 병렬 처리를 위한 두 가지 모드는 무엇인가요?","단일 프로세스 내 멀티스레드 및 멀티 프로세스입니다."
"Spring Batch에서 Step의 병렬 처리를 시작하는 방법은 무엇인가요?","Step 구성에 TaskExecutor를 추가하면 됩니다."
"Spring Batch에서 Step을 병렬로 실행하는 것을 구성하는 것은 얼마나 쉬운가요?","Java 구성에서 단계(step1, step2)를 step3과 병렬로 실행하는 것은 간단합니다."
"Spring Batch에서 반복 작업을 수행하는 데 사용되는 인터페이스는 무엇인가요?","Spring Batch에서 반복 작업을 수행하는 데 사용되는 인터페이스는 RepeatOperations입니다. RepeatOperations 인터페이스는 public interface RepeatOperations { RepeatStatus iterate(RepeatCallback callback) throws RepeatException; }로 정의됩니다."
"RepeatOperations 인터페이스에서 RepeatStatus 열거형은 어떤 역할을 하나요?","RepeatOperations 인터페이스에서 RepeatStatus 열거형은 호출자에게 어떤 작업이 남아 있는지 여부를 알려주는 역할을 합니다. RepeatStatus 열거형은 CONTINUABLE과 FINISHED 두 가지 값을 가질 수 있습니다. CONTINUABLE은 더 많은 작업이 남아 있음을 나타내고, FINISHED는 더 이상 반복이 일어나지 않아야 함을 나타냅니다."
"Spring Batch에서 반복 작업을 선언적으로 적용하는 방법은 무엇인가요?","Spring Batch에서 반복 작업을 선언적으로 적용하는 방법은 AOP 인터셉터를 사용하는 것입니다. RepeatOperationsInterceptor를 사용하면 인터셉트된 메서드를 반복하여 실행할 수 있습니다. 이 인터셉터를 구성하기 위해 Java 구성을 사용하거나 Spring AOP 네임스페이스를 사용할 수 있습니다. 이 인터셉터를 사용하면 제공된 RepeatTemplate의 CompletionPolicy에 따라 메서드 호출을 반복할 수 있습니다."
"Spring Batch에서 retry 기능은 언제부터 사용 가능해졌나요?","Spring Batch의 retry 기능은 2.2.0 버전부터 사용 가능해졌습니다. (출처: https://docs.spring.io/spring-batch/reference/retry.html)"
"Spring Retry는 Spring Batch와 어떤 관련이 있나요?","Spring Retry는 Spring Batch와 관련이 있으며, retry 기능을 담당합니다. Spring Batch는 프레임워크 내에서 retry 작업을 자동화하기 위해 Spring Retry에 의존합니다. (출처: https://docs.spring.io/spring-batch/reference/retry.html)"
"Spring Retry의 참조 문서는 어디에서 찾을 수 있나요?","Spring Retry의 참조 문서는 해당 라이브러리의 공식 문서에서 찾을 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/retry.html)"
"배치 작업의 단위 테스트를 만들기 위해 어떤 어노테이션을 사용해야 하나요?","@SpringJUnitConfig 및 @SpringBatchTest 어노테이션을 사용해야 합니다. (출처: https://docs.spring.io/spring-batch/reference/testing.html)"
"Spring Batch에서 배치 작업의 엔드 투 엔드 테스트란 무엇인가요?","엔드 투 엔드 테스트는 배치 작업의 전체 실행을 처음부터 끝까지 테스트하는 것입니다. (출처: https://docs.spring.io/spring-batch/reference/testing.html)"
"Spring Batch에서 배치 작업의 개별 단계를 테스트하는 방법은 무엇인가요?","JobLauncherTestUtils 클래스의 launchStep() 메서드를 사용하여 특정 Step만 실행하여 개별 단계를 테스트할 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/testing.html)"
"커스텀 ItemReader를 구현하는 방법은 무엇인가요?","커스텀 ItemReader를 구현하려면 FlatFileItemReader와 같이 기존 ItemReader 구현체를 확장하거나 ItemReader 인터페이스를 구현하는 새로운 클래스를 작성할 수 있습니다. 커스텀 ItemReader는 입력 데이터를 처리하는 로직을 추가하여 필요한 기능을 제공합니다. 예를 들어, 데이터베이스 쿼리를 실행하고 결과를 반환하는 ItemReader를 만들거나 파일에서 데이터를 읽어 반환하는 ItemReader를 만들 수 있습니다. 커스텀 ItemReader는 Spring Batch 구성에서 FlatFileItemReader나 JdbcCursorItemReader와 같은 다른 ItemReader 구현체와 마찬가지로 사용할 수 있습니다."
"커스텀 ItemWriter를 구현하는 방법은 무엇인가요?","커스텀 ItemWriter를 구현하려면 ItemWriter 인터페이스를 구현하는 새로운 클래스를 작성하거나 기존 ItemWriter 구현체를 확장할 수 있습니다. 커스텀 ItemWriter는 출력 데이터를 처리하는 로직을 추가하여 필요한 기능을 제공합니다. 예를 들어, 데이터를 데이터베이스에 삽입하는 ItemWriter를 만들거나 데이터를 파일에 쓰는 ItemWriter를 만들 수 있습니다. 커스텀 ItemWriter는 Spring Batch 구성에서 FlatFileItemWriter나 JdbcBatchItemWriter와 같은 다른 ItemWriter 구현체와 마찬가지로 사용할 수 있습니다."
"커스텀 ItemProcessor를 구현하는 방법은 무엇인가요?","커스텀 ItemProcessor를 구현하려면 ItemProcessor 인터페이스를 구현하는 새로운 클래스를 작성하거나 기존 ItemProcessor 구현체를 확장할 수 있습니다. 커스텀 ItemProcessor는 입력 데이터를 처리하고 출력 데이터를 생성하는 로직을 추가하여 필요한 기능을 제공합니다. 예를 들어, 데이터를 변환하거나 유효성을 검사하거나 데이터를 풍부하게 만드는 ItemProcessor를 만들 수 있습니다. 커스텀 ItemProcessor는 Spring Batch 구성에서 ItemReader와 ItemWriter 사이에 배치하여 사용할 수 있습니다."
"스프링 배치와 스프링 통합의 경계가 모호한 경우 어떻게 해야 할까요?","세부 사항에 대해 생각하고 일반적인 패턴을 적용하는 것이 좋습니다. 이 섹션에서는 일부 일반적인 패턴을 설명합니다. (출처: https://docs.spring.io/spring-batch/reference/spring-batch-integration.html)"
"메시징이 배치 프로세스에 어떤 이점을 제공하나요?","메시징을 배치 프로세스에 추가하면 작업 자동화 및 주요 관심사의 분리 및 전략화가 가능합니다. 예를 들어, 메시지가 작업을 실행하도록 트리거할 수 있으며, 메시지를 보내는 것은 다양한 방식으로 노출될 수 있습니다. 또는 작업이 완료되거나 실패하면 해당 이벤트가 메시지를 보내도록 트리거할 수 있으며, 해당 메시지의 소비자는 애플리케이션 자체와 관련이 없는 운영 관련 관심사를 가질 수 있습니다. 메시징은 또한 작업 내에 포함될 수 있습니다(예: 채널을 통해 처리를 위해 항목을 읽거나 씁니다). (출처: https://docs.spring.io/spring-batch/reference/spring-batch-integration.html)"
"리모트 파티셔닝과 리모트 청킹은 무엇인가요?","리모트 파티셔닝과 리모트 청킹은 여러 작업자 간에 작업 부하를 분산하는 방법을 제공합니다. (출처: https://docs.spring.io/spring-batch/reference/spring-batch-integration.html)"
"Spring Batch에서 배치 작업을 시작하는 방법은 무엇인가요?","Spring Batch의 핵심 API를 사용하여 배치 작업을 시작할 때, 기본적으로 두 가지 옵션이 있습니다: 명령줄에서 CommandLineJobRunner를 사용하거나, JobOperator.start() 또는 JobLauncher.run()을 사용하여 프로그래밍 방식으로 시작하는 것입니다. 예를 들어, 쉘 스크립트를 사용하여 배치 작업을 호출할 때 CommandLineJobRunner를 사용할 수 있습니다. 또는 웹 애플리케이션의 일부로 Spring Batch를 사용할 때와 같이 JobOperator를 직접 사용할 수도 있습니다. 그러나 더 복잡한 사용 사례의 경우 Spring Integration과 그 다양한 어댑터를 사용하여 배치 작업을 실행하는 것이 더 강력합니다. 예를 들어, File Inbound Channel Adapter를 사용하여 파일 시스템의 디렉토리를 모니터링하고 입력 파일이 도착하면 배치 작업을 시작할 수 있습니다. 또한, 구성만 사용하여 여러 소스에서 동시에 배치 작업에 대한 데이터를 쉽게 수집할 수 있도록 여러 가지 다른 어댑터를 사용하는 Spring Integration 플로우를 만들 수 있습니다. 이러한 모든 시나리오를 Spring Integration으로 구현하는 것은 간단합니다. JobLauncher의 분리된 이벤트 기반 실행을 허용하기 때문입니다. Spring Batch Integration은 배치 작업을 시작하는 데 사용할 수 있는 JobLaunchingMessageHandler 클래스를 제공합니다. JobLaunchingMessageHandler의 입력은 JobLaunchRequest 유형의 페이로드를 갖는 Spring Integration 메시지에 의해 제공됩니다. 다음 이미지는 배치 작업을 시작하는 데 필요한 일반적인 Spring Integration 메시지 흐름을 보여줍니다. EIP (Enterprise Integration Patterns) 웹사이트(https://www.enterpriseintegrationpatterns.com/toc.html)는 메시징 아이콘 및 해당 설명에 대한 전체 개요를 제공합니다."
"FileMessageToJobRequest 클래스는 어떤 역할을 하나요?","FileMessageToJobRequest 클래스는 파일을 JobLaunchRequest로 변환하는 역할을 합니다. 이 클래스는 Spring Integration transformer로 사용되어 파일 인바운드 채널 어댑터가 읽은 파일을 JobLaunchRequest로 변환합니다. JobLaunchRequest는 실행할 Job과 Batch 작업을 시작하는 데 필요한 JobParameters를 래핑하는 클래스입니다. FileMessageToJobRequest 클래스는 파일 매개변수 이름과 Job을 설정할 수 있습니다. toRequest 메서드는 FileMessageToJobRequest 클래스의 페이로드로 전달되며, JobParametersBuilder를 사용하여 파일 매개변수를 설정한 후 JobLaunchRequest를 반환합니다."
"JobExecution 응답은 어떻게 반환되나요?","배치 작업이 실행되면 JobExecution 인스턴스가 반환됩니다. 이 인스턴스를 사용하여 실행 상태를 확인할 수 있습니다. JobExecution이 성공적으로 생성되면 실제 실행이 성공했는지 여부와 관계없이 항상 반환됩니다. JobExecution 인스턴스가 반환되는 정확한 동작은 제공된 TaskExecutor에 따라 다릅니다. 동기식(단일 스레드) TaskExecutor 구현을 사용하는 경우 작업 완료 후에만 JobExecution 응답이 반환됩니다. 비동기식 TaskExecutor를 사용하는 경우 JobExecution 인스턴스가 즉시 반환됩니다. 그런 다음 JobExecution 인스턴스의 ID(JobExecution.getJobId()를 사용하여)를 가져와서 JobRepository에서 JobExplorer를 사용하여 작업의 업데이트된 상태를 쿼리할 수 있습니다. 자세한 내용은 Repository 쿼리(../job/advanced-meta-data.html#queryingRepository)를 참조하십시오."
"스프링 배치 통합의 job-launching gateway는 어떤 속성을 설정할 수 있나요?","스프링 배치 통합의 job-launching gateway는 id, auto-startup, request-channel, reply-channel, reply-timeout, job-launcher, order 등의 속성을 설정할 수 있습니다."
"job-launching gateway의 reply-channel 속성은 어떤 역할을 하나요?","reply-channel 속성은 결과 JobExecution 페이로드를 보내는 MessageChannel을 지정합니다."
"job-launching gateway의 auto-startup 속성은 어떤 역할을 하나요?","auto-startup 속성은 엔드포인트가 시작 시 자동으로 시작되어야 하는지 여부를 나타내는 부울 플래그입니다. 기본값은 true입니다."
"PollableChannel에서 메시지를 수신하는 Gateway의 경우, 어떻게 해야 하나요?","PollableChannel에서 메시지를 수신하는 Gateway의 경우, 전역 기본 poller를 제공하거나 Job Launching Gateway에 poller 하위 요소를 제공해야 합니다. Java에서는 @Poller 어노테이션을 사용하여 poller를 구성하고, XML에서는 poller 요소를 사용하여 poller를 구성할 수 있습니다."
"Spring Batch에서 진행 정보를 제공하는 방법은 무엇인가요?","Spring Batch에서는 진행 정보를 제공하기 위해 active polling, event-driven listeners 두 가지 접근 방식을 제공합니다. active polling은 JobExecution.getJobId()를 사용하여 JobRepository에서 업데이트된 JobExecution 인스턴스를 계속 가져오는 방식이며, event-driven approach는 StepListener, ChunkListener, JobExecutionListener와 같은 listeners를 사용하는 방식입니다."
"Spring Batch Integration에서 AsyncItemProcessor와 AsyncItemWriter를 사용하는 목적은 무엇인가요?","Spring Batch Integration에서 AsyncItemProcessor와 AsyncItemWriter를 사용하면 항목 처리의 확장성을 높일 수 있습니다. AsyncItemProcessor는 새로운 스레드에서 ItemProcessor의 로직을 실행하고, AsyncItemWriter는 모든 결과가 사용 가능해지면 일괄 처리 결과를 다시 작성합니다."
"스프링 배치에서 모니터링 및 메트릭을 지원하는 버전은 무엇인가요?","스프링 배치 4.2 버전부터 Micrometer를 기반으로 한 모니터링 및 메트릭을 지원합니다. (출처: https://docs.spring.io/spring-batch/reference/monitoring-and-metrics.html)"
"스프링 배치에서 기본적으로 제공되는 메트릭은 어떤 것들이 있나요?","스프링 배치에서는 job, step, item reading, item processing, chunk writing에 대한 메트릭을 기본적으로 제공합니다. (출처: https://docs.spring.io/spring-batch/reference/monitoring-and-metrics.html)"
"스프링 배치에서 커스텀 메트릭을 추가하려면 어떻게 해야 하나요?","커스텀 컴포넌트에서 자체 메트릭을 사용하려면 Micrometer API를 직접 사용하는 것이 좋습니다. Tasklet의 타이밍을 예시로 확인할 수 있습니다. (출처: https://docs.spring.io/spring-batch/reference/monitoring-and-metrics.html)"
"Spring Batch에서 트레이싱을 지원하는 버전은 무엇인가요?","Spring Batch는 5 버전부터 Micrometer의 Observation API를 통해 트레이싱을 지원합니다."
"Spring Batch에서 기본적으로 트레이싱이 활성화되는 경우는 언제인가요?","@EnableBatchProcessing을 사용할 때 트레이싱이 기본적으로 활성화됩니다."
"EnableBatchProcessing 어노테이션을 사용하지 않을 때 트레이싱을 설정하려면 어떻게 해야 하나요?","EnableBatchProcessing 어노테이션을 사용하지 않을 경우, BatchObservabilityBeanPostProcessor를 애플리케이션 컨텍스트에 등록하여 Micrometer의 관측 가능성을 자동으로 설정할 수 있습니다."
"Spring Batch에서 Hibernate 기반의 페이징 기능을 사용하여 대용량 데이터를 메모리 부족 없이 읽을 수 있는 ItemReader는 무엇인가요?","HibernatePagingItemReader는 Hibernate 기반의 페이징 기능을 사용하여 대용량 데이터를 메모리 부족 없이 읽을 수 있는 ItemReader입니다. 이 클래스는 JDBC 기반의 pagination을 활용하여 메모리 부족 문제를 해결합니다. (출처: https://docs.spring.io/spring-batch/reference/html/readersAndWriters.html#hibernatePagingItemReader)"
"Spring Batch에서 항목들을 Flat File에 쓰는 ItemWriter는 무엇인가요?","FlatFileItemWriter는 항목들을 Flat File에 쓰는 ItemWriter입니다. 이 클래스는 ItemStream과 Skippable 기능을 포함하고 있어, 오류가 발생했을 때 처리할 수 있는 기능을 제공합니다. (출처: https://docs.spring.io/spring-batch/reference/html/readersAndWriters.html#flatFileItemWriter)"
"Spring Batch에서 Apache Kafka 토픽에서 메시지를 읽어오는 ItemReader는 무엇인가요?","KafkaItemReader는 Apache Kafka 토픽에서 메시지를 읽어오는 ItemReader입니다. 이 클래스는 동일한 토픽의 여러 파티션에서 메시지를 읽어올 수 있도록 구성할 수 있으며, ItemReader에서 반환된 항목의 수를 세어 기본적인 재시작 기능을 제공합니다. (출처: https://docs.spring.io/spring-batch/reference/html/readersAndWriters.html#kafkaItemReader)"
"Spring Batch에서 메타데이터 테이블은 어떤 역할을 하나요?","Spring Batch 메타데이터 테이블은 Java에서 표현되는 도메인 객체와 밀접하게 일치합니다. 예를 들어, JobInstance, JobExecution, JobParameters 및 StepExecution은 각각 BATCH_JOB_INSTANCE, BATCH_JOB_EXECUTION, BATCH_JOB_EXECUTION_PARAMS 및 BATCH_STEP_EXECUTION에 매핑됩니다. JobRepository는 각 Java 객체를 올바른 테이블에 저장하고 저장하는 역할을 합니다."
"Spring Batch 메타데이터 테이블의 버전 열은 어떤 역할을 하나요?","버전 열은 Spring Batch가 데이터베이스 업데이트와 관련하여 낙관적 동시성 제어를 사용하기 때문에 중요합니다. 레코드가 '터치'될 때마다(업데이트될 때마다) 버전 열의 값이 1씩 증가합니다."
"Spring Batch 메타데이터 테이블의 Identity ID 열은 어떻게 작동하나요?","BATCH_JOB_INSTANCE, BATCH_JOB_EXECUTION 및 BATCH_STEP_EXECUTION에는 각각 _ID로 끝나는 열이 있습니다. 이러한 필드는 해당 테이블의 기본 키 역할을 합니다. 그러나 데이터베이스에서 생성된 키는 아닙니다. 대신 별도의 시퀀스에서 생성됩니다."
"비즈니스 트랜잭션이 일정 시간 동안 누적되는 것을 무엇이라고 합니까?","Batch (출처: https://docs.spring.io/spring-batch/reference/glossary.html)"
"Spring Batch에서 임시 데이터를 처리하는 동안 보관하는 테이블은 무엇인가요?","스테이징 테이블 (출처: https://docs.spring.io/spring-batch/reference/glossary.html)"
"Spring Batch에서 일시 중지된 작업을 다시 시작할 때 사용되는 전략은 무엇인가요?","재시작 가능 (출처: https://docs.spring.io/spring-batch/reference/glossary.html)"
"스프링 배치에서 태스크를 여러 스레드나 여러 프로세스에서 실행할 수 있나요?","스프링 배치에서는 태스크를 여러 스레드나 여러 프로세스에서 실행하는 것이 가능합니다. 이를 위해 Step에 TaskExecutor를 추가하거나, PartitionStep을 사용하여 태스크를 명시적으로 분할하거나, spring-batch-integration 모듈에서 제공하는 Remote Chunking 접근 방식을 사용할 수 있습니다. 이러한 접근 방식에 대해서는 요구사항을 신중하게 분석하고, 필요한 경우에만 사용해야 합니다. (출처: https://docs.spring.io/spring-batch/reference/faq.html)"
"스프링 배치에서 ItemReader를 스레드 안전하게 만드는 방법은 무엇인가요?","스프링 배치에서 ItemReader를 스레드 안전하게 만들기 위해서는 read() 메서드를 동기화하거나, read() 메서드를 동기화하는 대리자를 사용하여 호출하면 됩니다. 그러나 이렇게 하면 재시작 기능이 손실되므로, Step을 재시작할 수 없는 것으로 표시하고, 효율성과 안정성을 위해 read() 메서드에 saveState=false를 설정하는 것이 좋습니다. (출처: https://docs.spring.io/spring-batch/reference/faq.html)"
"스프링 배치에서 유연한 전략과 기본 구현을 사용하는 것에 대한 철학은 무엇인가요?","스프링 배치에서는 클라이언트가 Commit Interval(CompletionPolicy), Exception 처리 방법(ExceptionHandler), 그리고 다른 많은 기능과 같은 것들을 제어하기 위해 자체적인 전략을 생성하는 것을 기대합니다. 그러나 프레임워크 클래스를 확장하는 것은 권장하지 않습니다. Java 언어는 클래스와 인터페이스를 내부적으로 표시하는 데 충분한 유연성을 제공하지 않습니다. 일반적으로 org.springframework.batch.* 패키지의 소스 트리 최상위 수준의 모든 것은 공개되지만, 하위 클래스로 만들 수 있는 것은 아닙니다. (출처: https://docs.spring.io/spring-batch/reference/faq.html)"
