"스프링 부트는 무엇인가요? 어떤 목적으로 사용되나요?","스프링 부트는 독립적인 프로덕션 등급의 스프링 기반 애플리케이션을 만들고 실행할 수 있도록 도와주는 프레임워크입니다. 주로 Spring 플랫폼과 타사 라이브러리에 대한 의견을 가지고 있어 최소한의 번거로움으로 시작할 수 있습니다. 대부분의 Spring Boot 애플리케이션은 매우 적은 Spring 구성이 필요합니다. Java 애플리케이션을 만들기 위해 Spring Boot를 사용할 수 있으며, java -jar를 사용하여 시작하거나 더 전통적인 war 배포를 할 수 있습니다. 주요 목표는 모든 Spring 개발에 대해 근본적으로 더 빠르고 널리 접근 가능한 시작 경험을 제공하는 것입니다. 기본적으로 의견을 제시하지만 요구 사항이 기본값과 달라지기 시작하면 빠르게 벗어납니다. 임베디드 서버, 보안, 메트릭, 건강 점검 및 외부화된 구성과 같은 대규모 프로젝트 클래스에 공통적인 다양한 비기능적 기능을 제공합니다. 네이티브 이미지를 대상으로 하지 않을 때 코드 생성이 전혀 없으며 XML 구성에 대한 요구 사항이 없습니다. (출처: https://docs.spring.io/spring-boot/index.html)"
"스프링 부트를 사용하면 어떤 유형의 애플리케이션을 만들 수 있나요?","Java 애플리케이션을 만들기 위해 Spring Boot를 사용할 수 있으며, java -jar를 사용하여 시작하거나 더 전통적인 war 배포를 할 수 있습니다. (출처: https://docs.spring.io/spring-boot/index.html)"
"스프링 부트는 어떤 비기능적 기능을 제공하나요?","임베디드 서버, 보안, 메트릭, 건강 점검 및 외부화된 구성과 같은 대규모 프로젝트 클래스에 공통적인 다양한 비기능적 기능을 제공합니다. (출처: https://docs.spring.io/spring-boot/index.html)"
"스프링 부트를 처음 사용하는 경우 어떻게 시작해야 하나요?","스프링 부트를 처음 사용하는 경우, 'From scratch' 섹션에서 'Overview', 'Requirements', 'Installation' 주제를 읽어보세요. 또한 'Tutorial' 시리즈를 통해 예제를 따라해보고, 'Running your example' 섹션에서 예제를 실행하는 방법을 배울 수 있습니다. (출처: https://docs.spring.io/spring-boot/documentation.html#getting-started)"
"스프링 부트에서 SQL 데이터베이스를 구성하려면 어떻게 해야 하나요?","스프링 부트에서 SQL 데이터베이스를 구성하려면 'Data' 섹션에서 'SQL' 주제를 읽어보세요. 이 주제에서는 SQL 데이터베이스 구성, 임베디드 데이터베이스 지원, 연결 풀 등에 대한 정보를 제공합니다. (출처: https://docs.spring.io/spring-boot/documentation.html#data-sql)"
"스프링 부트에서 메시징 프로토콜을 사용하려면 어떻게 해야 하나요?","스프링 부트에서 메시징 프로토콜을 사용하려면 'Messaging' 섹션에서 'JMS', 'AMQP', 'Kafka', 'Pulsar', 'RSocket', 'Spring Integration' 등의 주제를 읽어보세요. 이 주제에서는 각 메시징 프로토콜에 대한 자동 구성 및 사용 방법에 대한 정보를 제공합니다. (출처: https://docs.spring.io/spring-boot/documentation.html#messaging)"
"스프링 부트를 처음 사용하는데 어떻게 시작할 수 있나요?","스프링 부트를 처음 사용하는 경우, spring.io 웹사이트에서 다양한 가이드 중 하나를 시도해 볼 수 있습니다. (출처: https://docs.spring.io/spring-boot/community.html)"
"스프링 부트 사용 중 문제가 발생했을 때 도움을 받을 수 있는 곳은 어디인가요?","스프링 부트 사용 중 문제가 발생하면 stackoverflow.com에서 spring-boot 태그로 질문하거나, github.com/spring-projects/spring-boot/issues에서 버그를 보고할 수 있습니다. (출처: https://docs.spring.io/spring-boot/community.html)"
"스프링 부트 관련 문서에서 오류를 발견하면 어떻게 수정할 수 있나요?","스프링 부트 관련 문서에서 오류를 발견하거나 수정하고 싶은 경우, github.com/spring-projects/spring-boot에서 참여하여 수정할 수 있습니다. (출처: https://docs.spring.io/spring-boot/community.html)"
"Spring Boot 3.3.4를 실행하기 위해 필요한 Java 버전은 무엇인가요?","Java 17(출처: <https://docs.spring.io/spring-boot/system-requirements.html>)"
"Spring Boot 3.3.4에서 명시적인 빌드 지원이 제공되는 Maven 버전은 무엇인가요?","Maven 3.6.3 이상(출처: <https://docs.spring.io/spring-boot/system-requirements.html>)"
"Spring Boot 3.3.4에서 어떤 내장된 서블릿 컨테이너를 지원하나요?","Tomcat 10.1, Jetty 12.0, Undertow 2.3(출처: <https://docs.spring.io/spring-boot/system-requirements.html>)"
"Spring Boot를 사용하기 위해 필요한 Java SDK 버전은 무엇인가요?","Java SDK v17 이상 (출처: https://docs.spring.io/spring-boot/installing.html)"
"Spring Boot를 사용하기 위해 어떤 빌드 도구를 사용하는 것이 좋을까요?","Maven 또는 Gradle과 같은 의존성 관리를 지원하는 빌드 도구를 사용하는 것이 좋습니다. (출처: https://docs.spring.io/spring-boot/installing.html)"
"Spring CLI를 수동으로 설치하려면 어떤 단계를 따라야 하나요?","Spring CLI 배포판을 다운로드하고, 압축을 해제하고, INSTALL.txt 지침에 따라 설치하면 됩니다. (출처: https://docs.spring.io/spring-boot/installing.html)"
"Spring Boot 업그레이드 가이드와 릴리스 노트는 어디에서 찾을 수 있나요?","Spring Boot 업그레이드 가이드와 릴리스 노트는 프로젝트 위키(https://github.com/spring-projects/spring-boot/wiki)에서 찾을 수 있습니다. 릴리스 노트 섹션의 링크를 따라 원하는 버전으로 업그레이드하는 지침을 찾을 수 있습니다. 업그레이드 지침은 항상 릴리스 노트의 첫 번째 항목입니다."
"1.x 버전에서 Spring Boot를 업그레이드하는 방법은 무엇인가요?","1.x 버전에서 Spring Boot를 업그레이드하려면 프로젝트 위키의 마이그레이션 가이드(https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide)를 확인하세요. 이 가이드는 자세한 업그레이드 지침을 제공합니다."
"새로운 기능 릴리스로 업그레이드할 때 속성 이름 변경 또는 제거를 처리하는 방법은 무엇인가요?","새로운 기능 릴리스로 업그레이드할 때 속성 이름 변경 또는 제거를 처리하려면 프로젝트에 spring-boot-properties-migrator 의존성을 추가하세요. 이 모듈은 애플리케이션 환경을 분석하고 시작 시 진단 정보를 출력하며 런타임에 속성을 일시적으로 마이그레이션할 수 있습니다. 마이그레이션이 완료되면 프로젝트의 의존성에서 이 모듈을 제거하는 것을 잊지 마세요."
"스프링 부트를 처음 사용하는데, 어떻게 시작하나요?","튜토리얼 섹션에서 스프링 부트를 시작하는 데 도움이 되는 튜토리얼을 제공합니다. (출처: https://docs.spring.io/spring-boot/tutorial/index.html)"
"스프링 부트를 사용하여 웹 애플리케이션을 만드는 방법에 대한 튜토리얼이 있나요?","네, 튜토리얼 섹션에서 스프링 부트를 사용하여 웹 애플리케이션을 만드는 방법에 대한 튜토리얼을 찾을 수 있습니다. (출처: https://docs.spring.io/spring-boot/tutorial/index.html)"
"스프링 부트를 사용하여 데이터베이스와 연동하는 방법을 배울 수 있는 튜토리얼이 있나요?","예, 튜토리얼 섹션에서 스프링 부트를 사용하여 데이터베이스와 연동하는 방법을 배울 수 있는 튜토리얼을 제공합니다. (출처: https://docs.spring.io/spring-boot/tutorial/index.html)"
"스프링 부트에서 첫 번째 웹 애플리케이션을 만들기 위해 어떤 스타터를 사용해야 하나요?","스프링 부트에서 첫 번째 웹 애플리케이션을 만들기 위해 spring-boot-starter-web 스타터를 사용해야 합니다. (출처: https://docs.spring.io/spring-boot/tutorial/first-application/index.html)"
"스프링 부트 애플리케이션을 개발할 때 빌드 시스템으로 Maven과 Gradle 중 어떤 것을 선택해야 하나요?","스프링 부트 애플리케이션을 개발할 때 빌드 시스템으로 Maven과 Gradle 중 선택할 수 있습니다. (출처: https://docs.spring.io/spring-boot/tutorial/first-application/index.html)"
"스프링 부트 애플리케이션의 종속성을 확인하기 위해 어떤 명령어를 사용할 수 있나요?","스프링 부트 애플리케이션의 종속성을 확인하기 위해 Gradle에서는 gradle dependencies 명령어를, Maven에서는 mvn dependency:tree 명령어를 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/tutorial/first-application/index.html)"
"스프링 부트의 기능과 기능을 사용하는 방법에 대한 정보를 어디에서 찾을 수 있나요?","스프링 부트 참조 문서에서 찾을 수 있습니다. (출처: {https://docs.spring.io/spring-boot/reference/index.html})"
"스프링 부트의 기능에 대해 자세히 설명하는 포괄적인 문서는 어디에서 찾을 수 있나요?","스프링 부트 참조 문서에서 찾을 수 있습니다. (출처: {https://docs.spring.io/spring-boot/reference/index.html})"
"스프링 부트 참조 문서는 어떤 내용을 다루나요?","스프링 부트 참조 문서는 스프링 부트의 기능과 기능을 사용하는 방법에 대한 정보를 제공합니다. (출처: {https://docs.spring.io/spring-boot/reference/index.html})"
"Spring Boot를 사용하여 애플리케이션을 개발하는 방법에 대해 자세히 설명하는 섹션은 어디인가요?","Spring Boot를 사용하여 애플리케이션을 개발하는 방법에 대한 자세한 내용은 'Developing with Spring Boot' 섹션을 참조하세요. 이 섹션에서는 빌드 시스템, 자동 구성, 애플리케이션 실행 방법 등에 대해 다룹니다. 또한 Spring Boot의 베스트 프랙티스도 다루고 있습니다. (출처: https://docs.spring.io/spring-boot/reference/using/index.html)"
"Spring Boot를 처음 사용하는 경우, 어떤 튜토리얼을 참고해야 할까요?","Spring Boot를 처음 사용하는 경우, 'Developing with Spring Boot' 섹션에 들어가기 전에 'Developing Your First Spring Boot Application' 튜토리얼을 읽어보시는 것이 좋습니다. 이 튜토리얼에서는 Spring Boot 애플리케이션의 기본 개념을 배울 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/using/index.html)"
"Spring Boot를 사용할 때 따라야 할 몇 가지 권장 사항은 무엇인가요?","Spring Boot를 사용할 때 권장하는 몇 가지 사항은 빌드 시스템, 자동 구성, 애플리케이션 실행 방법 등에 대한 것입니다. 이러한 권장 사항을 따르면 개발 프로세스를 조금 더 쉽게 만들 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/using/index.html)"
"스프링 부트에서 빌드 시스템으로 Maven 또는 Gradle을 사용하는 것이 권장되는 이유는 무엇인가요?","Maven과 Gradle은 의존성 관리와 Maven Central 저장소에 게시된 아티팩트를 처리할 수 있는 기능을 제공하기 때문에 스프링 부트와 함께 사용하기에 권장됩니다. 다른 빌드 시스템(예: Ant)도 사용할 수 있지만, 공식적으로 잘 지원되지 않습니다."
"스프링 부트의 스타터에 대해 설명하고, 어떻게 스타터를 찾을 수 있나요?","스타터는 애플리케이션에 포함할 수 있는 편리한 의존성 설명자입니다. 스타터를 사용하면 프로젝트의 일관된, 지원되는 의존성 집합을 빠르게 얻을 수 있습니다. 스타터는 일반적으로 spring-boot-starter-* 형식으로 명명되며, 여기서 *는 특정 유형의 애플리케이션입니다. Maven 통합 기능을 지원하는 많은 IDE에서 의존성을 이름으로 검색할 수 있습니다. 예를 들어, Eclipse 또는 Spring Tools 플러그인을 사용하면 POM 편집기에서 ctrl-space를 누르고 'spring-boot-starter'를 입력하면 완전한 목록이 표시됩니다. 공식 스타터는 spring-boot로 시작해야 하며, 타사 스타터는 일반적으로 타사 프로젝트의 이름으로 시작해야 합니다."
"스프링 부트에서 빌드 시스템과 스타터 외에도 어떤 기술적 구성 요소를 사용자 정의할 수 있나요?","스프링 부트에서는 웹 서버 또는 로깅 시스템과 같은 기술적 구성 요소를 사용자 정의할 수 있습니다. 예를 들어, 기본 임베디드 컨테이너인 Tomcat을 Jetty, Undertow 또는 Reactor Netty로 대체하거나, 기본 로깅 시스템인 Logback을 Log4j2로 대체할 수 있습니다. 커뮤니티에서 제공하는 추가 스타터 목록은 GitHub의 spring-boot-starters 모듈의 README 파일(https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-starters/README.adoc)에서 확인할 수 있습니다."
"스프링 부트에서 @Configuration 클래스는 어떤 역할을 하나요?","스프링 부트는 Java 기반의 구성을 선호하며, 일반적으로 주요 구성 소스는 단일 @Configuration 클래스여야 합니다. 주석 처리된 XML 구성 예제가 많이 있지만, 가능하면 Java 기반의 구성을 사용하는 것이 좋습니다. (출처: https://docs.spring.io/spring-boot/reference/using/configuration-classes.html)"
"스프링 부트에서 추가적인 @Configuration 클래스를 어떻게 가져올 수 있나요?","@Import 주석을 사용하여 추가적인 구성 클래스를 가져올 수 있습니다. 또는 @ComponentScan을 사용하여 @Configuration 클래스를 포함한 모든 Spring 컴포넌트를 자동으로 선택할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/using/configuration-classes.html)"
"스프링 부트에서 XML 기반 구성을 사용해야 하는 경우는 어떤 경우인가요?","스프링 부트는 Java 기반의 구성을 선호하지만, XML 기반 구성을 사용해야 하는 경우 @Configuration 클래스로 시작하고 @ImportResource 주석을 사용하여 XML 구성 파일을 로드할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/using/configuration-classes.html)"
"스프링 부트의 자동 구성이란 무엇인가요?","스프링 부트 자동 구성은 추가한 jar 의존성에 따라 스프링 애플리케이션을 자동으로 구성하려는 시도입니다. 예를 들어, HSQLDB가 클래스패스에 있고 수동으로 데이터베이스 연결 빈을 구성하지 않은 경우, 스프링 부트는 메모리 내 데이터베이스를 자동으로 구성합니다. 자동 구성에 참여하려면 @EnableAutoConfiguration 또는 @SpringBootApplication 어노테이션을 @Configuration 클래스 중 하나에 추가해야 합니다. @SpringBootApplication 또는 @EnableAutoConfiguration 어노테이션은 하나만 추가해야 합니다."
"스프링 부트 자동 구성에서 제외하는 방법은 무엇인가요?","자동 구성은 비침입적입니다. 언제든지 자동 구성의 특정 부분을 대체하기 위해 자체 구성을 정의할 수 있습니다. 예를 들어, 자체 DataSource 빈을 추가하면 기본 임베디드 데이터베이스 지원이 중단됩니다. 또한 @SpringBootApplication의 exclude 속성을 사용하여 원하지 않는 자동 구성 클래스를 비활성화할 수 있습니다. excludeName 속성을 사용하여 클래스가 클래스패스에 없는 경우 전체 클래스 이름을 지정할 수도 있습니다. 마지막으로, spring.autoconfigure.exclude 속성을 사용하여 제외할 자동 구성 클래스 목록을 제어할 수도 있습니다. 어노테이션 수준과 속성을 사용하여 제외 항목을 정의할 수 있습니다."
"스프링 부트에서 자동 구성 패키지를 사용하는 방법은 무엇인가요?","@EnableAutoConfiguration 어노테이션(직접 또는 @SpringBootApplication에 포함)은 기본 자동 구성 패키지를 결정합니다. 추가 패키지는 @AutoConfigurationPackage 어노테이션을 사용하여 구성할 수 있습니다. 이 어노테이션을 사용하여 엔티티 및 Spring Data 저장소와 같은 항목을 스캔할 때 기본적으로 다양한 자동 구성된 기능이 살펴보는 패키지를 지정할 수 있습니다."
"스프링 빈과 의존성 주입에서 권장되는 의존성 설정 방법은 무엇인가요?","스프링 빈과 의존성 주입에서 권장되는 의존성 설정 방법은 생성자 주입(Constructor Injection)입니다. (출처: {https://docs.spring.io/spring-boot/reference/using/spring-beans-and-dependency-injection.html})"
"@ComponentScan 어노테이션은 어떤 용도로 사용되나요?","@ComponentScan 어노테이션은 빈을 찾기 위해 사용됩니다. (출처: {https://docs.spring.io/spring-boot/reference/using/spring-beans-and-dependency-injection.html})"
"생성자가 여러 개인 경우, 어떤 어노테이션을 사용하여 스프링이 사용할 생성자를 지정할 수 있나요?","@Autowired 어노테이션을 사용하여 스프링이 사용할 생성자를 지정할 수 있습니다. (출처: {https://docs.spring.io/spring-boot/reference/using/spring-beans-and-dependency-injection.html})"
"Spring Boot의 @SpringBootApplication 어노테이션은 어떤 용도로 사용되나요?","Spring Boot의 @SpringBootApplication 어노테이션은 자동 구성, 컴포넌트 스캔, 추가 구성 정의 기능을 활성화하는 데 사용됩니다. 이는 @EnableAutoConfiguration, @ComponentScan, @SpringBootConfiguration 어노테이션을 하나의 어노테이션으로 결합한 것입니다. (출처: <https://docs.spring.io/spring-boot/reference/using/using-the-springbootapplication-annotation.html>)"
"Spring Boot의 @EnableAutoConfiguration 어노테이션은 어떤 역할을 하나요?","Spring Boot의 @EnableAutoConfiguration 어노테이션은 Spring Boot의 자동 구성 메커니즘을 활성화합니다. 이를 통해 애플리케이션의 런타임 환경에 기반하여 적절한 구성 및 라이브러리를 자동으로 구성할 수 있습니다. (출처: <https://docs.spring.io/spring-boot/reference/using/using-the-springbootapplication-annotation.html>)"
"Spring Boot의 @SpringBootConfiguration 어노테이션은 어떤 역할을 하나요?","Spring Boot의 @SpringBootConfiguration 어노테이션은 Spring Boot 구성을 활성화하고 추가 빈을 컨텍스트에 등록하거나 추가 구성 클래스를 가져올 수 있도록 합니다. 이는 통합 테스트에서 구성 감지를 지원하는 Spring의 표준 @Configuration 어노테이션의 대체품입니다. (출처: <https://docs.spring.io/spring-boot/reference/using/using-the-springbootapplication-annotation.html>)"
"스프링 부트 애플리케이션을 프로덕션에 배포하기 전에 어떤 단계를 거쳐야 하나요?","스프링 부트 애플리케이션을 프로덕션에 배포하기 전에 패키징과 최적화를 위한 많은 옵션이 있습니다. 이러한 기능에 대한 자세한 내용은 문서에서 'Packaging Spring Boot Applications(../packaging/index.html)' 섹션을 참조하십시오. 소스: {https://docs.spring.io/spring-boot/reference/using/packaging-for-production.html}"
"스프링 부트 애플리케이션에서 'production ready' 기능을 사용하려면 어떤 방법을 사용할 수 있나요?","health, auditing, metric REST 또는 JMX 엔드포인트와 같은 'production ready' 기능을 사용하려면 spring-boot-actuator를 추가하는 것이 좋습니다. 자세한 내용은 Actuator(../../how-to/actuator.html)를 참조하십시오. 소스: {https://docs.spring.io/spring-boot/reference/using/packaging-for-production.html}"
"스프링 부트 애플리케이션의 패키징 및 최적화에 대한 자세한 정보를 얻을 수 있는 곳은 어디인가요?","스프링 부트 애플리케이션의 패키징 및 최적화에 대한 자세한 내용은 문서에서 'Packaging Spring Boot Applications(../packaging/index.html)' 섹션을 참조하십시오. 소스: {https://docs.spring.io/spring-boot/reference/using/packaging-for-production.html}"
"스프링 부트(Spring Boot)의 핵심 기능 섹션은 어떤 내용을 다루나요?","스프링 부트의 핵심 기능 섹션은 스프링 부트에서 사용할 수 있는 주요 기능과 사용자 지정 가능한 기능에 대한 자세한 정보를 제공합니다. 이 섹션을 읽기 전에 튜토리얼과 스프링 부트 사용 섹션을 먼저 읽는 것이 좋습니다."
"스프링 부트의 핵심 기능을 사용하려면 어떤 섹션을 먼저 읽어야 하나요?","스프링 부트의 핵심 기능을 사용하기 전에 튜토리얼과 스프링 부트 사용 섹션을 먼저 읽는 것이 좋습니다."
"스프링 부트의 핵심 기능 섹션을 이해하기 위해 필요한 기본 지식은 무엇인가요?","스프링 부트의 핵심 기능 섹션을 이해하기 위해 필요한 기본 지식은 튜토리얼과 스프링 부트 사용 섹션을 읽는 것입니다."
"SpringApplication 클래스는 어떤 역할을 하나요?","SpringApplication 클래스는 메인() 메서드에서 시작되는 Spring 애플리케이션을 편리하게 부트스트랩할 수 있는 방법을 제공합니다. 많은 상황에서 static SpringApplication.run 메서드를 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/features/spring-application.html)"
"SpringApplication.run 메서드는 어떤 역할을 하나요?","SpringApplication.run 메서드는 Spring 애플리케이션을 시작하는 데 사용됩니다. 이 메서드는 main() 메서드에서 호출되며, 애플리케이션의 시작 로직을 처리합니다. (출처: https://docs.spring.io/spring-boot/reference/features/spring-application.html)"
"SpringApplication의 기본 로깅 레벨은 무엇인가요?","SpringApplication의 기본 로깅 레벨은 INFO입니다. 다른 로깅 레벨이 필요한 경우, Log Levels(logging.html#features.logging.log-levels)에서 설명된 대로 설정할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/features/spring-application.html)"
"Spring Boot에서 ConfigurationProperties를 사용하면 어떤 이점이 있나요?","ConfigurationProperties를 사용하면 Spring Application에서 외부화된 구성에 접근할 때, JavaBean Properties Binding, Constructor Binding, Relaxed Binding 등의 이점을 얻을 수 있습니다. 이를 통해 Spring Application의 외부화된 구성에 대한 접근이 용이해지며, 다양한 소스에서 구성을 로드할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/features/external-config.html)"
"Spring Boot에서 Type-Safe Configuration Properties를 사용하는 방법은 무엇인가요?","Spring Boot에서 Type-Safe Configuration Properties를 사용하려면 @ConfigurationProperties 어노테이션을 사용하여 POJO 클래스를 정의하고, 해당 클래스에 원하는 구성 속성을 정의하면 됩니다. 이렇게 정의된 클래스는 자동으로 Spring 환경에서 빈으로 등록되며, 해당 빈을 주입하여 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/features/external-config.html)"
"Spring Boot에서 Configuration Properties에 대한 Validation을 어떻게 수행하나요?","Spring Boot에서는 @Validated 어노테이션을 사용하여 Configuration Properties에 대한 Validation을 수행할 수 있습니다. 해당 어노테이션을 Configuration Properties 클래스에 적용하면, 해당 클래스에 정의된 필드에 대한 Validation이 자동으로 수행됩니다. (출처: https://docs.spring.io/spring-boot/reference/features/external-config.html)"
"스프링 프로파일을 사용하는 목적은 무엇인가요?","스프링 프로파일은 애플리케이션 구성의 일부를 분리하고 특정 환경에서만 사용할 수 있도록 하는 방법을 제공합니다. 이는 다양한 환경(개발, 테스트, 스테이징, 프로덕션)에서 다른 구성을 사용할 수 있도록 도와줍니다. (출처: https://docs.spring.io/spring-boot/reference/features/profiles.html)"
"스프링에서 @Profile 어노테이션을 사용하는 방법은 무엇인가요?","@Profile 어노테이션은 @Component, @Configuration 또는 @ConfigurationProperties에 표시하여 로드될 때를 제한할 수 있습니다. 예를 들어, @Configuration(proxyBeanMethods = false) @Profile('production') public class ProductionConfiguration { // ... }. (출처: https://docs.spring.io/spring-boot/reference/features/profiles.html)"
"스프링에서 프로파일을 활성화하는 방법은 무엇인가요?","스프링에서 프로파일을 활성화하는 방법으로는 애플리케이션 속성에서 spring.profiles.active 속성을 사용하거나 명령줄 스위치를 사용하여 프로파일을 지정할 수 있습니다. 예를 들어, --spring.profiles.active=dev,hsqldb. 또한, 설정에서 기본 프로파일을 설정하고, 프로파일 그룹을 정의할 수도 있습니다. (출처: https://docs.spring.io/spring-boot/reference/features/profiles.html)"
"스프링 부트가 내부 로깅에 사용하는 로깅 프레임워크는 무엇인가요?","스프링 부트는 내부 로깅에 Commons Logging을 사용합니다. (출처: https://docs.spring.io/spring-boot/reference/features/logging.html)"
"스프링 부트가 제공하는 기본 로깅 구현체는 무엇인가요?","스프링 부트는 Java Util Logging, Log4j2, Logback에 대한 기본 구성을 제공합니다. (출처: https://docs.spring.io/spring-boot/reference/features/logging.html)"
"스프링 부트에서 디버그 모드를 활성화하는 방법은 무엇인가요?","스프링 부트에서 디버그 모드를 활성화하려면 애플리케이션 시작 시 --debug 플래그를 사용하거나 application.properties에서 debug=true를 지정하면 됩니다. (출처: https://docs.spring.io/spring-boot/reference/features/logging.html)"
"Spring Boot에서 국제화를 지원하는 방법은 무엇인가요?","Spring Boot는 로컬라이즈된 메시지를 지원하여 다양한 언어 환경을 사용하는 사용자에게 대응할 수 있습니다. 기본적으로 Spring Boot는 classpath 루트에 messages resource bundle이 있는지 확인합니다. 자동 구성은 구성된 resource bundle의 기본 properties 파일(기본값: messages.properties)이 있는 경우에 적용됩니다. (출처: https://docs.spring.io/spring-boot/reference/features/internationalization.html)"
"Spring Boot에서 MessageSource의 basename을 구성하는 방법은 무엇인가요?","MessageSource의 basename은 spring.messages 네임스페이스를 사용하여 구성할 수 있습니다. basename은 패키지 한정자 또는 classpath 루트에서 해결된 리소스 중 하나일 수 있습니다. 또한, basename은 쉼표로 구분된 위치 목록을 지원합니다. (출처: https://docs.spring.io/spring-boot/reference/features/internationalization.html)"
"Spring Boot에서 MessageSource의 fallback-to-system-locale 속성은 어떤 역할을 하나요?","MessageSource의 fallback-to-system-locale 속성은 지정된 속성 파일이 없는 경우, 로컬 시스템 로케일에 따라 메시지를 반환할지 여부를 제어합니다. 이 속성은 기본적으로 true로 설정되어 있습니다. (출처: https://docs.spring.io/spring-boot/reference/features/internationalization.html)"
"스프링 부트에서 AOP를 자동 구성하는 방법은 무엇인가요?","스프링 부트는 기본적으로 Spring AOP를 구성하여 CGLib 프록시를 사용합니다. 그러나 JDK 프록시를 사용하려면 spring.aop.proxy-target-class 속성을 false로 설정하면 됩니다. AspectJ가 클래스패스에 있으면 spring.aop.auto 속성이 자동으로 활성화되어 @EnableAspectJAutoProxy 어노테이션이 필요하지 않습니다. (출처: <https://docs.spring.io/spring-boot/reference/features/aop.html>)"
"스프링에서 AOP에 대해 자세히 알 수 있는 참고 자료는 무엇인가요?","스프링 프레임워크 참조 문서의 AOP 섹션에서 스프링에서 AOP에 대해 자세히 알 수 있습니다. (출처: <https://docs.spring.io/spring-framework/reference/6.1/core/aop-api.html>)"
"스프링 부트에서 AspectJ를 사용하여 AOP를 활성화하는 방법은 무엇인가요?","AspectJ가 클래스패스에 있으면 스프링 부트의 자동 구성에서 spring.aop.auto 속성이 자동으로 활성화되어 @EnableAspectJAutoProxy 어노테이션을 사용하지 않아도 됩니다. (출처: <https://docs.spring.io/spring-boot/reference/features/aop.html>)"
"스프링 부트에서 JSON 매핑 라이브러리로 Jackson을 사용하는 경우 어떤 이점이 있나요?","스프링 부트에서 Jackson을 사용하면 자동 구성이 제공되며, Jackson은 spring-boot-starter-json의 일부로 포함되어 있습니다. Jackson이 클래스패스에 있으면 ObjectMapper 빈이 자동으로 구성되며, 여러 구성 속성을 사용하여 ObjectMapper의 구성을 사용자 정의할 수 있습니다."
"스프링 부트에서 Jackson의 @JsonComponent 어노테이션은 어떻게 작동하나요?","@JsonComponent 어노테이션은 Jackson을 위한 사용자 정의 직렬화기 및 역직렬화기를 등록하기 쉽게 만들어줍니다. 이 어노테이션은 Jackson에서 직렬화기/역직렬화기를 등록하는 일반적인 방법인 모듈 대신 사용할 수 있습니다. 이 어노테이션은 JsonSerializer, JsonDeserializer 또는 KeyDeserializer 구현에 직접 적용할 수 있습니다. 또한 직렬화기/역직렬화기를 내부 클래스로 포함하는 클래스에도 적용할 수 있습니다."
"스프링 부트에서 JsonObjectSerializer 및 JsonObjectDeserializer 기본 클래스는 어떤 역할을 하나요?","JsonObjectSerializer 및 JsonObjectDeserializer 기본 클래스는 직렬화 시 표준 Jackson 버전에 대한 유용한 대안을 제공합니다. 이들은 직렬화 시 객체를 직렬화할 때 유용하며, API 문서의 세부 정보를 참조할 수 있습니다. 이러한 기본 클래스를 사용하여 사용자 정의 직렬화기 및 역직렬화기를 작성할 수 있습니다."
"스프링 부트에서 컨텍스트에 Executor 빈이 없을 때, 어떤 종류의 AsyncTaskExecutor가 자동 구성되나요?","스프링 부트에서 컨텍스트에 Executor 빈이 없을 경우, AsyncTaskExecutor가 자동 구성됩니다. Java 21+를 사용하고 spring.threads.virtual.enabled가 true로 설정된 경우, 가상 스레드를 사용하는 SimpleAsyncTaskExecutor가 사용됩니다. 그렇지 않은 경우, 합리적인 기본 설정을 가진 ThreadPoolTaskExecutor가 사용됩니다. (출처: https://docs.spring.io/spring-boot/reference/features/task-execution-and-scheduling.html)"
"스프링 부트에서 쿼리에 대한 비동기 처리를 위해 Spring MVC를 사용할 때 어떤 종류의 AsyncTaskExecutor를 사용해야 하나요?","Spring MVC의 비동기 요청 처리를 위해 사용자 정의 Executor를 정의한 경우, AsyncTaskExecutor 구현체인 SimpleAsyncTaskExecutor 또는 ThreadPoolTaskExecutor를 사용해야 합니다. 이 경우, 사용자 정의 Executor는 applicationTaskExecutor로 명명되어야 합니다. (출처: https://docs.spring.io/spring-boot/reference/features/task-execution-and-scheduling.html)"
"스프링 부트에서 ThreadPoolTaskExecutor의 스레드 풀 크기와 큐 용량을 어떻게 설정할 수 있나요?","ThreadPoolTaskExecutor의 스레드 풀 크기와 큐 용량은 spring.task.execution 네임스페이스를 사용하여 설정할 수 있습니다. 예를 들어, spring.task.execution.pool.max-size=16, spring.task.execution.pool.queue-capacity=100와 같이 설정하면 스레드 풀 크기와 큐 용량을 각각 16개와 100개로 설정할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/features/task-execution-and-scheduling.html)"
"Spring Boot의 개발 시간 서비스 중 어떤 것이 지원되나요?","Spring Boot는 Docker Compose와 Testcontainers라는 두 가지 개발 시간 서비스를 지원합니다. (출처: https://docs.spring.io/spring-boot/reference/features/dev-services.html)"
"Docker Compose를 사용하여 애플리케이션에 필요한 서비스를 정의하고 관리하는 방법은 무엇인가요?","Docker Compose는 애플리케이션에 필요한 여러 컨테이너를 정의하고 관리할 수 있는 인기있는 기술입니다. 일반적으로 애플리케이션 옆에 compose.yml 파일을 생성하여 서비스 컨테이너를 정의하고 구성합니다. 일반적인 워크플로우는 docker compose up을 실행하여 시작한 서비스에 연결하여 애플리케이션을 작업하고, 작업이 완료되면 docker compose down을 실행하는 것입니다. (출처: https://docs.spring.io/spring-boot/reference/features/dev-services.html)"
"Spring Boot의 Docker Compose 지원을 사용하여 서비스에 연결하려면 어떻게 해야 하나요?","Docker Compose 서비스는 컨테이너에 의해 매핑된 포트에 대한 연결을 설정하여 연결됩니다. 일반적으로 docker compose는 컨테이너 내부의 포트를 컴퓨터의 일시적인 포트에 매핑하는 방식으로 사용됩니다. 서비스 연결은 컨테이너의 이미지 이름을 사용하여 설정됩니다. Spring Boot의 Docker Compose 지원을 사용할 때 다음과 같은 서비스 연결이 지원됩니다: ActiveMQ, Artemis, Cassandra, Elasticsearch, Jdbc, Ldap, Mongo, Neo4j, OtlpMetrics, OtlpTracing, Pulsar, R2dbc, Rabbit, Redis, Zipkin. (출처: https://docs.spring.io/spring-boot/reference/features/dev-services.html)"
"스프링 부트에서 커스텀 스타터를 만들기 위해 어떤 모듈이 필요한가요?","스프링 부트에서 커스텀 스타터를 만들기 위해서는 'acme'에 대한 자동 구성 코드가 포함된 autoconfigure 모듈과, autoconfigure 모듈과 'acme' 및 일반적으로 유용한 추가 종속성을 제공하는 starter 모듈이 필요합니다. 두 모듈을 하나의 모듈로 결합하는 것도 가능합니다."
"스프링 부트에서 커스텀 스타터에 대한 적절한 네임스페이스를 제공하는 방법은 무엇인가요?","스프링 부트에서 커스텀 스타터에 대한 적절한 네임스페이스를 제공하기 위해서는 다른 Maven groupId를 사용하더라도 모듈 이름을 spring-boot로 시작하지 않아야 합니다. 또한, 모든 키에 대해 소유한 네임스페이스로 접두사를 붙여야 하며, Spring Boot에서 사용하는 네임스페이스와 겹치지 않아야 합니다."
"스프링 부트에서 커스텀 스타터의 autoconfigure 모듈에 대한 의존성을 선택적으로 만드는 방법은 무엇인가요?","스프링 부트에서 커스텀 스타터의 autoconfigure 모듈에 대한 의존성을 선택적으로 만들기 위해서는 Maven에서 <optional>true</optional>를 추가하거나, Gradle에서 annotationProcessor 구성에서 의존성을 선언해야 합니다."
"스프링 부트에서 코틀린 지원은 어떤 방식으로 제공되나요?","스프링 부트는 스프링 프레임워크, 스프링 데이터, 리액터 등 다른 스프링 프로젝트의 코틀린 지원을 활용하여 코틀린을 지원합니다. 자세한 내용은 Spring Framework Kotlin support documentation(https://docs.spring.io/spring-framework/reference/6.1/languages/kotlin.html)을 참조하세요."
"스프링 부트와 코틀린을 사용하여 새로운 프로젝트를 어떻게 시작하나요?","start.spring.io(https://start.spring.io/#!language=kotlin)를 사용하여 새로운 코틀린 프로젝트를 생성할 수 있습니다. Spring Boot and Kotlin Comprehensive Tutorial(https://spring.io/guides/tutorials/spring-boot-kotlin/)을 따라하는 것도 쉬운 방법입니다."
"코틀린의 클래스는 기본적으로 final로 설정되어 있는데, 어떻게 하면 프록시할 수 있나요?","스프링 부트는 코틀린-스프링 플러그인(https://kotlinlang.org/docs/reference/compiler-plugins.html#spring-support)을 구성하여 스프링 어노테이션이 지정된 클래스를 자동으로 오픈하여 프록시할 수 있도록 설정해야 합니다. 이렇게 하면 코틀린 클래스를 스프링 프록시를 통해 프록시할 수 있습니다."
"스프링 부트에서 SSL 보안 통신을 구성하는 방법과 지원하는 키스토어 파일 형식은 무엇인가요?","스프링 부트에서는 spring.ssl.bundle 접두사를 가진 구성 속성을 사용하여 SSL 신뢰 자료를 구성할 수 있습니다. spring.ssl.bundle.jks 접두사를 가진 구성 속성을 사용하여 Java keytool 유틸리티로 생성된 신뢰 자료 번들을 JKS 또는 PKCS12 형식의 Java Keystore 파일에 저장할 수 있습니다. 일반적으로 Java Keystore에는 인증서와 개인 키가 포함됩니다. 지원되는 키스토어 파일 형식은 JKS와 PKCS12입니다. (출처: <https://docs.spring.io/spring-boot/reference/features/ssl.html>)"
"스프링 부트에서 PEM 인코딩된 인증서로 SSL 번들을 구성하는 방법은 무엇인가요?","스프링 부트에서는 spring.ssl.bundle.pem 접두사를 가진 구성 속성을 사용하여 PEM 인코딩된 텍스트 형태의 신뢰 자료 번들을 구성할 수 있습니다. 일반적으로 인증서와 개인 키가 포함됩니다. PEM 콘텐츠는 인증서 및 개인 키 속성에 직접 사용할 수 있습니다. 속성 값에 BEGIN 및 END 마커가 포함되어 있으면 리소스 위치가 아닌 PEM 콘텐츠로 처리됩니다. (출처: <https://docs.spring.io/spring-boot/reference/features/ssl.html>)"
"스프링 부트에서 SSL 번들을 적용하는 방법과 호환되는 구성 요소는 무엇인가요?","스프링 부트에서는 SSL 번들을 구성 속성을 사용하여 구성한 후, Spring Boot에서 자동 구성하는 다양한 유형의 연결에 대한 구성 속성에서 이름으로 참조할 수 있습니다. 호환되는 구성 요소에는 내장 웹 서버, 데이터 기술 및 REST 클라이언트가 포함됩니다. SSL 번들은 spring.ssl.bundle 속성을 사용하여 구성한 각 이름 있는 번들에 대한 액세스를 제공하는 SslBundles 유형의 빈을 자동으로 구성합니다. SslBundle는 SSL 개체를 얻는 계층적 접근 방식을 제공합니다. (출처: <https://docs.spring.io/spring-boot/reference/features/ssl.html>)"
"스프링 웹플럭스의 주요 장점은 무엇인가요?","스프링 웹플럭스는 서블릿 API를 필요로 하지 않으며, 완전히 비동기적이고 블로킹이 없으며, Reactor 프로젝트를 통해 Reactive Streams(https://www.reactive-streams.org/) 사양을 구현합니다. 이를 통해 반응형 웹 애플리케이션을 개발할 수 있으며, 비동기적인 애플리케이션에서 더 나은 성능과 확장성을 제공합니다. (출처: https://docs.spring.io/spring-boot/reference/web/reactive.html)"
"스프링 웹플럭스의 기능적 변형과 어노테이션 기반 변형의 차이점은 무엇인가요?","스프링 웹플럭스의 기능적 변형인 WebFlux.fn은 라우팅 구성과 실제 요청 처리를 분리하여 처리합니다. 반면, 어노테이션 기반 변형은 Spring MVC 모델과 매우 유사하며, @GetMapping, @PostMapping 등과 같은 어노테이션을 사용하여 HTTP 엔드포인트를 정의합니다. (출처: https://docs.spring.io/spring-boot/reference/web/reactive.html)"
"스프링 웹플럭스에서 정적 리소스를 어떻게 제공하나요?","스프링 웹플럭스는 기본적으로 클래스패스에서 /static, /public, /resources, /META-INF/resources 디렉토리에서 정적 리소스를 제공합니다. 기본 위치는 spring.webflux.static-path-pattern 속성을 사용하여 사용자 정의할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/web/reactive.html)"
"Spring Boot에서 우아한 종료란 무엇이며 어떤 웹 서버에서 지원되나요?","우아한 종료는 Spring Boot에서 애플리케이션을 종료할 때 기존 요청이 완료될 수 있도록 하는 기능입니다. Jetty, Reactor Netty, Tomcat, Undertow 웹 서버에서 지원되며, 반응형 및 서블릿 기반 웹 애플리케이션 모두에서 작동합니다. (출처: https://docs.spring.io/spring-boot/reference/web/graceful-shutdown.html)"
"우아한 종료는 어떻게 동작하며 어떤 웹 서버에서 새로운 요청을 받지 않게 되나요?","우아한 종료는 애플리케이션 컨텍스트를 닫는 과정의 일부로 발생하며, SmartLifecycle 빈을 중지하는 가장 초기 단계에서 수행됩니다. 이 중지 처리는 타임아웃을 사용하여 기존 요청이 완료될 수 있는 기간을 제공하지만 새로운 요청은 허용되지 않습니다. 새로운 요청을 받지 않게 되는 정확한 방법은 사용되는 웹 서버에 따라 다릅니다. Jetty, Reactor Netty, Tomcat은 네트워크 레이어에서 요청 수신을 중지하지만, Undertow는 새로운 연결을 수락하지만 즉시 서비스 불가(503) 응답을 반환합니다. (출처: https://docs.spring.io/spring-boot/reference/web/graceful-shutdown.html)"
"Tomcat에서 우아한 종료를 사용하려면 어떤 버전이 필요한가요?","Tomcat에서 우아한 종료를 사용하려면 Tomcat 9.0.33 이상이 필요합니다. 우아한 종료를 활성화하려면 다음 예제와 같이 server.shutdown 속성을 구성하십시오: Properties YAML server.shutdown=graceful server: shutdown: 'graceful' 타임아웃 기간을 구성하려면 다음 예제와 같이 spring.lifecycle.timeout-per-shutdown-phase 속성을 구성하십시오: Properties YAML spring.lifecycle.timeout-per-shutdown-phase=20s spring: lifecycle: timeout-per-shutdown-phase: '20s' IDE에서 우아한 종료를 사용하면 적절한 SIGTERM 신호를 보내지 않으면 제대로 작동하지 않을 수 있습니다. 자세한 내용은 IDE 문서를 참조하십시오. (출처: https://docs.spring.io/spring-boot/reference/web/graceful-shutdown.html)"
"스프링 시큐리티가 클래스패스에 있으면 웹 애플리케이션은 기본적으로 어떻게 보안되나요?","스프링 시큐리티가 클래스패스에 있으면 웹 애플리케이션은 기본적으로 보안됩니다. 스프링 부트는 httpBasic 또는 formLogin을 사용할지 여부를 결정하기 위해 스프링 시큐리티의 콘텐츠 협상 전략에 의존합니다. 웹 애플리케이션에 메서드 수준 보안을 추가하려면 @EnableGlobalMethodSecurity를 원하는 설정과 함께 추가할 수도 있습니다."
"기본 UserDetailsService에는 어떤 사용자가 포함되어 있나요?","기본 UserDetailsService에는 단일 사용자가 있습니다. 사용자 이름은 user이고, 비밀번호는 무작위로 생성되며, 애플리케이션 시작 시 WARN 레벨로 출력됩니다. 이 생성된 비밀번호는 개발용으로만 사용됩니다. 프로덕션 환경에서 애플리케이션을 실행하기 전에 보안 구성을 업데이트해야 합니다."
"웹 애플리케이션에서 기본적으로 제공되는 기능은 무엇인가요?","웹 애플리케이션에서 기본적으로 제공되는 기능은 UserDetailsService(또는 WebFlux 애플리케이션의 경우 ReactiveUserDetailsService) 빈과 메모리에 저장된 단일 사용자, 애플리케이션(액추에이터가 클래스패스에 있는 경우 액추에이터 엔드포인트 포함) 전체에 대한 폼 기반 로그인 또는 HTTP 기본 보안(요청의 Accept 헤더에 따라 다름), 인증 이벤트를 게시하기 위한 DefaultAuthenticationEventPublisher입니다. 다른 인증 이벤트 게시자를 제공하기 위해 해당 빈을 추가할 수 있습니다."
"스프링 부트에서 서블릿 웹 애플리케이션을 구축할 때, 어떤 스토어 구현이 자동 구성되나요?","스프링 부트에서 서블릿 웹 애플리케이션을 구축할 때, Redis, JDBC, Hazelcast, MongoDB 스토어 구현이 자동 구성됩니다. (출처: https://docs.spring.io/spring-boot/reference/web/spring-session.html)"
"반응형 웹 애플리케이션을 구축할 때, 스프링 부트에서 어떤 스토어 구현이 자동 구성되나요?","반응형 웹 애플리케이션을 구축할 때, 스프링 부트에서 Redis와 MongoDB 스토어 구현이 자동 구성됩니다. (출처: https://docs.spring.io/spring-boot/reference/web/spring-session.html)"
"JDBC 스토어의 테이블 이름을 커스터마이징하는 방법은 무엇인가요?","JDBC 스토어의 테이블 이름을 커스터마이징하려면, spring.session.jdbc.table-name 속성을 설정하면 됩니다. 예를 들어, spring.session.jdbc.table-name=SESSIONS와 같이 설정할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/web/spring-session.html)"
"스프링 부트에서 스프링 HATEOAS를 자동으로 구성하려면 어떤 설정이 필요한가요?","스프링 부트는 대부분의 애플리케이션과 잘 작동하는 스프링 HATEOAS에 대한 자동 구성을 제공합니다. 이 자동 구성은 @EnableHypermediaSupport 사용을 대체하고, LinkDiscoverers (클라이언트 측 지원용) 및 원하는 표현으로 응답을 올바르게 마샬링하도록 구성된 ObjectMapper를 포함하여 하이퍼미디어 기반 애플리케이션을 쉽게 구축할 수 있도록 여러 빈을 등록합니다. ObjectMapper는 spring.jackson.* 속성을 설정하거나 Jackson2ObjectMapperBuilder 빈이 있는 경우 이를 사용합니다. {https://docs.spring.io/spring-boot/reference/web/spring-hateoas.html}에서 확인하세요."
"스프링 HATEOAS의 구성을 직접 제어하려면 어떻게 해야 하나요?","스프링 HATEOAS의 구성을 직접 제어하려면 @EnableHypermediaSupport를 사용하면 됩니다. 그러나 이렇게 하면 앞서 설명한 ObjectMapper 사용자 지정이 비활성화됩니다. {https://docs.spring.io/spring-boot/reference/web/spring-hateoas.html}에서 확인하세요."
"스프링 WebFlux와 함께 스프링 HATEOAS를 사용하려면 어떻게 해야 하나요?","스프링 WebFlux와 함께 스프링 HATEOAS를 사용하려면 spring-boot-starter-hateoas 대신 org.springframework.hateoas:spring-hateoas에 대한 직접적인 종속성을 추가하고 spring-boot-starter-webflux와 함께 사용해야 합니다. {https://docs.spring.io/spring-boot/reference/web/spring-hateoas.html}에서 확인하세요."
"Spring Boot는 어떤 데이터 기술과 통합되나요?","Spring Boot는 SQL 및 NoSQL을 포함한 여러 데이터 기술과 통합됩니다. (출처: https://docs.spring.io/spring-boot/reference/data/index.html)"
"Spring Boot에서 어떤 NoSQL 데이터베이스를 사용할 수 있나요?","Spring Boot는 MongoDB, Cassandra, Redis 등 다양한 NoSQL 데이터베이스와 통합됩니다. (출처: https://docs.spring.io/spring-boot/reference/data/index.html)"
"Spring Boot에서 데이터 접근과 관련된 기능은 무엇인가요?","Spring Boot는 데이터 접근과 관련하여 JPA, MyBatis, RESTful 웹 서비스 등을 지원합니다. (출처: https://docs.spring.io/spring-boot/reference/data/index.html)"
"스프링 부트에서 JPA를 사용하여 데이터베이스와 연동하려면 어떤 단계를 거쳐야 하나요?","먼저, 스프링 부트 프로젝트에 JPA와 Spring Data JPA에 필요한 의존성을 추가합니다. 그리고 필요한 엔티티 클래스를 생성하고, Spring Data JPA 리포지토리를 정의하여 데이터베이스에 접근합니다. 마지막으로, application.properties 파일에 JPA 설정을 추가하여 데이터베이스와 연결합니다. (출처: https://docs.spring.io/spring-boot/reference/data/sql.html)"
"스프링 부트에서 H2 데이터베이스의 웹 콘솔을 사용하려면 어떤 조건을 충족해야 하나요?","스프링 부트에서 H2 데이터베이스의 웹 콘솔을 사용하려면, 프로젝트가 서블릿 기반 웹 애플리케이션이어야 하고, com.h2database:h2 의존성이 클래스패스에 있어야 합니다. 또한, Spring Boot의 개발 도구를 사용하거나, spring.h2.console.enabled 속성을 true로 설정해야 합니다. (출처: https://docs.spring.io/spring-boot/reference/data/sql.html)"
"스프링 부트에서 Spring Data R2DBC 리포지토리를 구성하려면 어떤 단계를 거쳐야 하나요?","스프링 부트에서 Spring Data R2DBC 리포지토리를 구성하려면, 프로젝트에 spring-boot-starter-data-r2dbc 의존성을 추가하고, 필요한 엔티티 클래스를 생성합니다. 그리고 Spring Data R2DBC 리포지토리 인터페이스를 정의하여 데이터베이스에 접근합니다. 마지막으로, application.properties 파일에 R2DBC 설정을 추가하여 데이터베이스와 연결합니다. (출처: https://docs.spring.io/spring-boot/reference/data/sql.html)"
"스프링 데이터에서 어떤 NoSQL 기술에 대한 프로젝트를 제공하나요?","스프링 데이터는 Cassandra, Couchbase, Elasticsearch, GemFire 또는 Geode, LDAP, MongoDB, Neo4j, Redis와 같은 다양한 NoSQL 기술에 대한 액세스를 돕는 추가 프로젝트를 제공합니다. 이 중에서 Cassandra, Couchbase, Elasticsearch, LDAP, MongoDB, Neo4J 및 Redis에 대한 자동 구성을 제공합니다. 또한, Apache Geode에 대한 자동 구성을 제공하는 Spring Boot for Apache Geode도 제공합니다."
"스프링 데이터에서 Redis를 사용하는 방법은 무엇인가요?","Redis를 사용하려면, auto-configured RedisConnectionFactory, StringRedisTemplate 또는 vanilla RedisTemplate 인스턴스를 다른 스프링 빈과 마찬가지로 주입할 수 있습니다. 기본적으로는 localhost:6379의 Redis 서버에 연결을 시도합니다. spring.data.redis.* 속성을 사용하여 사용자 정의 연결 세부 정보를 지정할 수 있습니다."
"스프링 데이터에서 MongoDB를 사용하는 방법은 무엇인가요?","MongoDB 데이터베이스에 액세스하려면, auto-configured org.springframework.data.mongodb.MongoDatabaseFactory를 주입할 수 있습니다. 기본적으로, 인스턴스는 mongodb://localhost/test의 MongoDB 서버에 연결을 시도합니다. MongoClient 를 직접 정의한 경우, 적절한 MongoDatabaseFactory 를 auto-configure하는 데 사용됩니다. auto-configured MongoClient는 MongoClientSettings 빈을 사용하여 생성됩니다. MongoClientSettingsBuilderCustomizer 빈을 하나 이상 선언하여 MongoClientSettings 구성을 세부적으로 조정할 수 있습니다."
"Spring Boot에서 애플리케이션에서 입출력 기능을 처리하는 데 도움이 되는 유틸리티와 통합을 제공하는 것은 무엇인가요?","Spring Boot는 입출력(IO) 기능을 처리하는 데 도움이 되는 유틸리티와 통합을 제공합니다. (출처: {https://docs.spring.io/spring-boot/reference/io/index.html})"
"Spring Boot의 표준 IO 기능에는 어떤 것들이 포함되나요?","Spring Boot의 표준 IO 기능에는 캐싱 및 유효성 검사와 같은 기능이 포함됩니다. (출처: {https://docs.spring.io/spring-boot/reference/io/index.html})"
"Spring Boot의 고급 IO 기능에는 어떤 것들이 포함되나요?","Spring Boot의 고급 IO 기능에는 예약 및 분산 트랜잭션과 같은 더 고급 주제가 포함됩니다. (출처: {https://docs.spring.io/spring-boot/reference/io/index.html})"
"스프링에서 캐싱을 투명하게 추가하는 방법은 무엇인가요?","스프링에서 캐싱을 투명하게 추가하려면, @EnableCaching 어노테이션을 사용하여 캐싱을 활성화하고, 캐시할 메서드에 @Cacheable 어노테이션을 추가하면 됩니다. 이렇게 하면 캐시가 활성화되고, 메서드의 실행 횟수를 줄일 수 있습니다. 자세한 내용은 https://docs.spring.io/spring-framework/reference/6.1/integration/cache.html을 참조하세요."
"스프링에서 캐시를 투명하게 업데이트하거나 삭제하는 방법은 무엇인가요?","스프링에서 캐시를 투명하게 업데이트하거나 삭제하려면, @CachePut 및 @CacheEvict 어노테이션을 사용하면 됩니다. @CachePut 어노테이션은 메서드가 실행되고, 캐시에 업데이트된 값을 저장하기 전에 호출됩니다. @CacheEvict 어노테이션은 메서드가 실행되기 전에 호출되어, 캐시에서 값을 삭제합니다. 자세한 내용은 https://docs.spring.io/spring-framework/reference/6.1/integration/cache/annotations.html을 참조하세요."
"스프링에서 캐시를 사용할 때, 사용되는 캐시 제공자는 무엇인가요?","스프링에서 캐시를 사용할 때, 사용되는 캐시 제공자는 CacheManager 빈이나 cacheResolver라는 이름의 CacheResolver 빈이 정의되어 있지 않으면, 다음과 같은 순서로 결정됩니다: Generic, JCache (JSR-107), Hazelcast, Infinispan, Couchbase, Redis, Caffeine, Cache2k, Simple. 특정 캐시 제공자를 강제로 사용하려면, spring.cache.type 속성을 설정하여 사용할 수 있습니다. 자세한 내용은 https://docs.spring.io/spring-boot/reference/io.html#boot-features-caching을 참조하세요."
"Spring Boot에서 Hazelcast를 자동으로 구성하는 방법은 무엇인가요?","Hazelcast가 클래스패스에 있고 적합한 구성이 발견되면 Spring Boot는 애플리케이션에 주입할 수 있는 HazelcastInstance를 자동 구성합니다. Spring Boot는 먼저 다음 구성 옵션을 확인하여 클라이언트를 만들려고 시도합니다. com.hazelcast.client.config.ClientConfig 빈의 존재 여부, spring.hazelcast.config 속성으로 정의된 구성 파일, hazelcast.client.config 시스템 속성의 존재 여부, 작업 디렉토리 또는 클래스 경로 루트의 hazelcast-client.xml, 작업 디렉토리 또는 클래스 경로 루트의 hazelcast-client.yaml(또는 hazelcast-client.yml), Hazelcast 문서(https://docs.hazelcast.org/docs/latest/manual/html-single/)를 참조하십시오."
"Spring Boot에서 Hazelcast 클라이언트를 생성할 수 없는 경우 어떻게 처리하나요?","Spring Boot는 임베디드 서버를 구성하려고 시도합니다. com.hazelcast.config.Config 빈을 정의하는 경우 Spring Boot는 해당 빈을 사용합니다. 구성이 인스턴스 이름을 정의하는 경우 Spring Boot는 새 인스턴스를 만드는 대신 기존 인스턴스를 찾으려고 시도합니다."
"Spring Boot에서 Hazelcast 구성 파일을 지정하려면 어떻게 해야 하나요?","다음 예제와 같이 구성을 통해 사용할 Hazelcast 구성 파일을 지정할 수 있습니다. Properties: spring.hazelcast.config=classpath:config/my-hazelcast.xml, YAML: spring: hazelcast: config: classpath:config/my-hazelcast.xml"
"스프링 부트에서 JDBC 기반 Quartz 스케줄러를 구성하는 방법은 무엇인가요?","스프링 부트에서는 `spring.quartz.job-store-type=jdbc` 속성을 설정하여 JDBC 기반 Quartz 스케줄러를 구성할 수 있습니다. 또한, `spring.quartz.jdbc.initialize-schema=always` 속성을 설정하여 JDBC 기반 스케줄러를 사용할 때 스키마를 초기화할 수 있습니다. 기본적으로, Quartz 라이브러리에서 제공하는 표준 스크립트를 사용하여 데이터베이스를 감지하고 초기화합니다. 이 스크립트는 기존 테이블을 삭제하고, 모든 재시작 시 모든 트리거를 삭제합니다. `spring.quartz.jdbc.schema` 속성을 설정하여 사용자 정의 스크립트를 제공할 수도 있습니다. (출처: https://docs.spring.io/spring-boot/reference/html/io.quartz.html)"
"Quartz 스케줄러에서 기존 작업 정의를 덮어쓰려면 어떻게 해야 하나요?","Quartz 스케줄러에서 기존 작업 정의를 덮어쓰려면 `spring.quartz.overwrite-existing-jobs` 속성을 설정해야 합니다. 이 속성을 설정하면, 지속성 있는 작업 저장소에서 읽은 이미 등록된 작업을 새로운 작업 정의로 덮어쓸 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/html/io.quartz.html)"
"Quartz 스케줄러에서 작업의 데이터 맵 속성과 빈을 주입하려면 어떻게 해야 하나요?","Quartz 스케줄러에서 작업의 데이터 맵 속성과 빈을 주입하려면 작업에서 설정자를 정의하고, 해당 설정자에 데이터 맵 속성 또는 빈을 주입하면 됩니다. 예를 들어, 다음과 같이 작업에서 설정자를 정의할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/html/io.quartz.html)

Java
```java
public class MySampleJob extends QuartzJobBean {
    // 필드...
    private MyService myService;
    private String name;

    // `MyService` 빈 주입
    public void setMyService(MyService myService) {
        this.myService = myService;
    }

    // `name` 작업 데이터 맵 속성 주입
    public void setName(String name) {
        this.name = name;
    }
}
```

Kotlin
```kotlin
class MySampleJob : QuartzJobBean() {
    // 필드...
    private var myService: MyService? = null
    private var name: String? = null

    // `MyService` 빈 주입
    fun setMyService(myService: MyService?) {
        this.myService = myService
    }

    // `name` 작업 데이터 맵 속성 주입
    fun setName(name: String?) {
        this.name = name
    }
}
```"
"Spring Boot에서 이메일 전송을 위한 기본 JavaMailSender를 생성하는 방법은 무엇인가요?","spring.mail.host와 관련된 라이브러리(spring-boot-starter-mail)가 사용 가능한 경우, 기본 JavaMailSender가 생성됩니다. MailProperties 클래스의 구성 항목을 사용하여 설정을 추가로 사용자 정의할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/io/email.html)"
"Spring Boot에서 JavaMailSender의 타임아웃 값을 변경하는 방법은 무엇인가요?","spring.mail.properties 네임스페이스의 구성 항목을 사용하여 타임아웃 값을 변경할 수 있습니다. 예를 들어, mail.smtp.connectiontimeout, mail.smtp.timeout, mail.smtp.writetimeout 속성을 각각 5000, 3000, 5000으로 설정할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/io/email.html)"
"Spring Boot에서 JNDI의 기존 Session을 사용하여 JavaMailSender를 구성하는 방법은 무엇인가요?","spring.mail.jndi-name 속성을 사용하여 JNDI의 기존 Session을 참조할 수 있습니다. jndi-name이 설정되면 다른 모든 Session 관련 설정이 우선됩니다. (출처: https://docs.spring.io/spring-boot/reference/io/email.html)"
"스프링에서 JSR-303 구현체가 클래스패스에 있으면 어떤 검증 기능이 자동으로 활성화되나요?","메소드 검증 기능입니다. (출처: https://docs.spring.io/spring-boot/reference/io/validation.html)"
"JSR-303 제약 조건을 가진 메소드를 가진 타겟 클래스는 어떤 타입 레벨에서 @Validated 어노테이션을 사용해야 하나요?","@Validated 어노테이션을 사용해야 합니다. (출처: https://docs.spring.io/spring-boot/reference/io/validation.html)"
"스프링에서 제약 조건 메시지의 {parameters}를 해결할 때 어떤 MessageSource를 사용하나요?","애플리케이션의 MessageSource를 사용합니다. (출처: https://docs.spring.io/spring-boot/reference/io/validation.html)"
"Spring Boot에서 RestClient를 사용하는 것이 권장되는 경우는 어떤 경우인가요?","Spring Boot에서 RestClient를 사용하는 것이 권장되는 경우는 애플리케이션에서 Spring WebFlux 또는 Project Reactor를 사용하지 않는 경우입니다. RestClient 인터페이스는 기능적인 스타일의 블로킹 API를 제공합니다. Spring Boot는 프로토타입 RestClient.Builder 빈을 생성하고 사전 구성합니다. 이를 주입하여 RestClient 인스턴스를 생성하는 것이 좋습니다. Spring Boot는 해당 빌더에 HttpMessageConverters와 적절한 ClientHttpRequestFactory를 구성합니다. (출처: https://docs.spring.io/spring-boot/reference/io/rest-client.html)"
"Spring Boot에서 RestClient를 사용하여 SSL을 사용하는 방법은 무엇인가요?","Spring Boot에서 RestClient를 사용하여 SSL을 사용하려면 RestClientSsl 인스턴스를 주입하여 builder의 apply 메서드와 함께 사용할 수 있습니다. RestClientSsl 인터페이스는 애플리케이션.properties 또는 application.yaml 파일에 정의한 SSL 번들에 대한 액세스를 제공합니다. (출처: https://docs.spring.io/spring-boot/reference/io/rest-client.html)"
"Spring Boot에서 RestClient를 사용자 정의하는 다른 접근 방식은 무엇인가요?","Spring Boot에서 RestClient를 사용자 정의하는 다른 접근 방식은 사용자 정의 범위를 얼마나 넓게 적용할지 결정하는 것입니다. 사용자 정의 범위를 가능한 한 좁게 만들려면 자동 구성된 RestClient.Builder를 주입하고 필요한 경우 해당 메서드를 호출합니다. RestClient.Builder 인스턴스는 상태 유지형이므로 빌더에 대한 모든 변경 사항은 해당 빌더로 생성된 모든 클라이언트에 반영됩니다. 여러 클라이언트에서 동일한 빌더를 사용하려면 RestClient.Builder other = builder.clone();을 사용하여 빌더를 복제하는 것도 고려할 수 있습니다. 마지막으로 RestClient.create()를 사용하여 원래 API로 되돌릴 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/io/rest-client.html)"
"스프링 부트에서 웹 서비스를 사용하기 위해 어떤 모듈을 사용해야 하나요?","스프링 부트에서 웹 서비스를 사용하기 위해 spring-boot-starter-webservices 모듈을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/io/webservices.html)"
"스프링 부트에서 SimpleWsdl11Definition과 SimpleXsdSchema 빈을 생성하려면 어떻게 설정해야 하나요?","스프링 부트에서 SimpleWsdl11Definition과 SimpleXsdSchema 빈을 생성하려면, WSDL과 XSD의 위치를 다음과 같이 설정해야 합니다: spring.webservices.wsdl-locations=classpath:/wsdl. (출처: https://docs.spring.io/spring-boot/reference/io/webservices.html)"
"스프링 부트에서 WebServiceTemplate을 사용자 정의하려면 어떻게 해야 하나요?","스프링 부트에서 WebServiceTemplate을 사용자 정의하려면, WebServiceTemplateBuilder를 사용하여 WebServiceTemplate 인스턴스를 생성할 수 있습니다. 기본적으로 WebServiceTemplateBuilder는 클래스패스에서 사용 가능한 HTTP 클라이언트 라이브러리를 사용하여 적합한 HTTP 기반 WebServiceMessageSender를 감지합니다. (출처: https://docs.spring.io/spring-boot/reference/io/webservices.html)"
"Spring Boot에서 JTA를 사용한 분산 트랜잭션이란 무엇이며 어떻게 지원되나요?","Spring Boot는 JNDI에서 가져온 트랜잭션 매니저를 사용하여 여러 XA 리소스 간에 분산 JTA 트랜잭션을 지원합니다. JTA 환경이 감지되면 Spring의 JtaTransactionManager가 트랜잭션을 관리하는 데 사용됩니다. 자동 구성된 JMS, DataSource 및 JPA 빈은 XA 트랜잭션을 지원하기 위해 업그레이드됩니다. @Transactional과 같은 표준 Spring 관용구를 사용하여 분산 트랜잭션에 참여할 수 있습니다. JTA 환경 내에서 로컬 트랜잭션을 사용하려면 spring.jta.enabled 속성을 false로 설정하여 JTA 자동 구성을 비활성화할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/io/jta.html)"
"Spring Boot에서 Jakarta EE 관리 트랜잭션 매니저를 사용하는 방법은 무엇인가요?","Spring Boot 애플리케이션을 war 또는 ear 파일로 패키징하고 Jakarta EE 애플리케이션 서버에 배포하면 애플리케이션 서버의 내장 트랜잭션 매니저를 사용할 수 있습니다. Spring Boot는 일반적인 JNDI 위치(java:comp/UserTransaction, java:comp/TransactionManager 등)를 확인하여 트랜잭션 매니저를 자동 구성하려고 시도합니다. 애플리케이션 서버에서 제공하는 트랜잭션 서비스를 사용할 때는 일반적으로 모든 리소스가 서버에서 관리되고 JNDI를 통해 노출되도록 해야 합니다. (출처: https://docs.spring.io/spring-boot/reference/io/jta.html)"
"Spring Boot에서 XA 및 비-XA JMS 연결을 혼합하여 사용하는 방법은 무엇인가요?","JTA를 사용할 때 기본 JMS ConnectionFactory 빈은 XA 인식이며 분산 트랜잭션에 참여합니다. @Qualifier를 사용할 필요 없이 빈에 주입할 수 있습니다. 특정 JMS 메시지를 비-XA ConnectionFactory를 사용하여 처리하려는 경우 nonXaJmsConnectionFactory 빈을 사용할 수 있습니다. 일관성을 위해 jmsConnectionFactory 빈은 xaJmsConnectionFactory 빈 별칭을 사용하여도 제공됩니다. XAConnectionFactoryWrapper 및 XADataSourceWrapper 인터페이스를 사용하여 임베디드 트랜잭션 매니저를 지원할 수 있습니다. 이러한 인터페이스는 XAConnectionFactory 및 XADataSource 빈을 래핑하고 일반 ConnectionFactory 및 DataSource 빈으로 노출하여 분산 트랜잭션에 투명하게 등록합니다. DataSource 및 JMS 자동 구성은 JTA 변형을 사용하며, JtaTransactionManager 빈과 적절한 XA 래퍼 빈이 ApplicationContext 내에 등록되어 있는 경우입니다. (출처: https://docs.spring.io/spring-boot/reference/io/jta.html)"
"Spring Framework는 어떤 메세징 시스템과 통합하기 위한 지원을 제공하나요?","JMS API, Advanced Message Queuing Protocol (AMQP), RabbitMQ, Apache Kafka, Apache Pulsar (출처: https://docs.spring.io/spring-boot/reference/messaging/index.html)"
"Spring Framework는 JMS API를 어떻게 단순화하나요?","JmsTemplate을 사용하여 JMS API를 단순화합니다. (출처: https://docs.spring.io/spring-boot/reference/messaging/index.html)"
"Spring WebSocket은 어떤 메시징 프로토콜을 네이티브로 지원하나요?","STOMP 메시징을 네이티브로 지원합니다. (출처: https://docs.spring.io/spring-boot/reference/messaging/index.html)"
"Application에서 org.apache.activemq:artemis-jakarta-server를 추가하면 어떤 모드를 사용할 수 있나요?","임베디드 모드(embedded mode)를 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/messaging/jms.html)"
"JmsMessagingTemplate을 어떻게 주입할 수 있나요?","JmsMessagingTemplate을 스프링 빈으로 주입할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/messaging/jms.html)"
"JmsListenerContainerFactory를 설정하는 방법은 무엇인가요?","DefaultJmsListenerContainerFactoryConfigurer를 사용하여 DefaultJmsListenerContainerFactory를 초기화하고 설정할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/messaging/jms.html)"
"스프링 부트에서 Pulsar 클라이언트를 구성하는 방법은 무엇인가요?","Pulsar 클라이언트는 spring.pulsar.client.* 접두사로 시작되는 애플리케이션 속성을 지정하여 구성할 수 있습니다. 더 많은 제어가 필요한 경우 PulsarClientBuilderCustomizer 빈을 하나 이상 등록하는 것을 고려하세요. (출처: https://docs.spring.io/spring-boot/reference/messaging/pulsar.html)"
"Pulsar 클러스터에 인증이 필요한 경우 어떻게 연결하나요?","Pulsar 클러스터에 인증이 필요한 경우 pluginClassName 및 플러그인에 필요한 모든 매개 변수를 설정하여 사용할 인증 플러그인을 지정해야 합니다. 매개 변수는 매개 변수 이름에서 매개 변수 값으로 된 맵으로 설정할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/messaging/pulsar.html)"
"Pulsar 클라이언트와 PulsarAdministration 클라이언트의 차이점은 무엇인가요?","Pulsar 클라이언트는 메시지를 보내고 받는 데 사용되는 반면, PulsarAdministration 클라이언트는 Pulsar 클러스터를 관리하고 구성하는 데 사용됩니다. PulsarAdministration 클라이언트는 auto-configuration을 통해 자동으로 구성되며, 기본적으로 http://localhost:8080의 로컬 Pulsar 인스턴스에 연결하려고 시도합니다. (출처: https://docs.spring.io/spring-boot/reference/messaging/pulsar.html)"
"Spring Boot에서 RSocket 서버를 자동으로 구성하는 방법은 무엇인가요?","Spring Boot는 RSocket 서버 자동 구성을 제공합니다. 필요한 종속성은 spring-boot-starter-rsocket에서 제공됩니다. RSocket 서버는 WebFlux 서버의 Web Server에 플러그인되거나 독립적인 RSocket 서버로 시작될 수 있습니다. 이를 위해서는 애플리케이션 유형과 구성에 따라 다릅니다. WebFlux 애플리케이션(WebApplicationType.REACTIVE 유형)의 경우, RSocket 서버는 다음 속성이 일치하는 경우에만 Web Server에 플러그인됩니다: spring.rsocket.server.mapping-path=/rsocket 및 spring.rsocket.server.transport=websocket. Web Server에 RSocket을 플러그인하는 것은 RSocket 자체가 해당 라이브러리로 구축되었기 때문에 Reactor Netty에서만 지원됩니다. 또는 RSocket TCP 또는 WebSocket 서버가 독립형 임베디드 서버로 시작됩니다. 종속성 요구 사항 외에도 해당 서버에 대한 포트를 정의하는 것만으로 충분한 구성입니다: spring.rsocket.server.port=9898."
"RSocket 서버가 WebFlux 서버의 Web Server에 플러그인되는 경우는 언제인가요?","WebFlux 애플리케이션(WebApplicationType.REACTIVE 유형)의 경우, RSocket 서버는 다음 속성이 일치하는 경우에만 Web Server에 플러그인됩니다: spring.rsocket.server.mapping-path=/rsocket 및 spring.rsocket.server.transport=websocket. 이러한 속성은 YAML에서 다음과 같이 정의할 수 있습니다: spring: rsocket: server: mapping-path: /rsocket transport: websocket."
"RSocketRequester.Builder는 어떻게 인스턴스화되나요?","RSocketRequester.Builder 인스턴스는 프로토타입 빈이며, 각 주입 지점에서 새로운 인스턴스를 제공합니다. 이는 이 빌더가 상태 비저장형이며, 동일한 인스턴스를 사용하여 다른 설정으로 리퀘스터를 생성해서는 안 되기 때문입니다. 이 빌더는 Spring Boot에서 예상되는 코덱과 함께 RSocketRequester.Builder를 자동으로 구성하고, RSocketConnectorConfigurer 빈을 적용합니다."
"스프링 부트에서 스프링 통합을 사용하기 위해 어떤 스타터를 사용해야 하나요?","스프링 부트에서 스프링 통합을 사용하기 위해 spring-boot-starter-integration 스타터를 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/messaging/spring-integration.html)"
"스프링 부트에서 스프링 통합의 폴링 로직은 어떻게 구현되나요?","스프링 부트에서 스프링 통합의 폴링 로직은 auto-configured TaskScheduler를 통해 구현됩니다. 기본 PollerMetadata(1초마다 무제한 메시지 폴링)은 spring.integration.poller.* 구성 속성을 통해 사용자 정의할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/messaging/spring-integration.html)"
"스프링 부트에서 RSocket 서버를 구성하는 방법은 무엇인가요?","스프링 부트에서 RSocket 서버를 구성하려면 spring.rsocket.server.* 속성을 사용하여 RSocket 서버를 구성하고 IntegrationRSocketEndpoint 또는 RSocketOutboundGateway 구성 요소를 사용하여 들어오는 RSocket 메시지를 처리할 수 있습니다. 이 인프라는 Spring Integration RSocket 채널 어댑터 및 @MessageMapping 핸들러를 처리할 수 있습니다. (spring.integration.rsocket.server.message-mapping-enabled가 구성되어 있다고 가정합니다.) (출처: https://docs.spring.io/spring-boot/reference/messaging/spring-integration.html)"
"스프링 부트에서 WebSocket을 자동 구성하는 데 사용되는 컨테이너는 무엇인가요?","스프링 부트는 내장 Tomcat, Jetty 및 Undertow에서 WebSocket 자동 구성을 제공합니다. (출처: https://docs.spring.io/spring-boot/reference/messaging/websockets.html)"
"MVC 웹 애플리케이션에서 WebSocket 지원을 추가하려면 어떻게 해야 하나요?","MVC 웹 애플리케이션에서 풍부한 WebSocket 지원을 추가하려면 spring-boot-starter-websocket 모듈을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-framework/reference/6.1/web/websocket.html)"
"리액티브 웹 애플리케이션에서 WebSocket 지원을 추가하려면 어떤 모듈을 포함해야 하나요?","리액티브 웹 애플리케이션에서 WebSocket 지원을 추가하려면 spring-boot-starter-webflux와 함께 WebSocket API를 포함해야 합니다. (출처: https://docs.spring.io/spring-framework/reference/6.1/web/webflux-websocket.html)"
"Spring Boot에서 테스트를 지원하는 모듈은 어떤 것들이 있나요?","spring-boot-test와 spring-boot-test-autoconfigure 모듈이 Spring Boot에서 테스트를 지원합니다. (출처: https://docs.spring.io/spring-boot/reference/testing/index.html)"
"JUnit 4 테스트를 Spring Boot에서 어떻게 실행할 수 있나요?","JUnit 5의 빈티지 엔진과 junit-vintage-engine 의존성을 사용하여 JUnit 4 테스트를 Spring Boot에서 실행할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/testing/index.html)"
"JUnit 4와 JUnit 5 간의 Hamcrest 의존성 충돌을 어떻게 해결할 수 있나요?","junit-vintage-engine 의존성에서 hamcrest-core를 제외하여 JUnit 4와 JUnit 5 간의 Hamcrest 의존성 충돌을 해결할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/testing/index.html)"
"Spring Boot Test에서 Test Scope에 어떤 라이브러리가 포함되어 있나요?","Spring Boot Test의 test scope에 포함된 라이브러리로는 JUnit 5, Spring Test, AssertJ, Hamcrest, Mockito, JSONassert, JsonPath, Awaitility 등이 있습니다. (출처: https://docs.spring.io/spring-boot/reference/testing/test-scope-dependencies.html)"
"Spring Boot Test에서 제공하는 Spring Test는 어떤 용도로 사용되나요?","Spring Test는 Spring Framework에서 제공하는 테스트 유틸리티 및 통합 테스트 지원 라이브러리입니다. Spring Boot Test에서도 Spring Test를 활용하여 테스트를 수행할 수 있습니다. (출처: https://docs.spring.io/spring-framework/reference/6.1/testing/integration.html)"
"Spring Boot Test에서 제공되는 Mockito를 사용하는 목적은 무엇인가요?","Mockito는 Java mocking 프레임워크로, 모의 객체를 생성하여 테스트에서 실제 객체와의 상호작용을 모의로 대체할 수 있도록 도와줍니다. 이를 통해 단위 테스트의 독립성과 코드 커버리지를 향상시킬 수 있습니다. (출처: https://site.mockito.org/)"
"Spring 애플리케이션을 테스트하는 주요 이점 중 하나는 무엇인가요?","의존성 주입의 주요 이점 중 하나는 코드를 단위 테스트하기 쉽게 만들어준다는 것입니다. Spring을 사용하지 않고도 new 연산자를 사용하여 객체를 인스턴스화할 수 있으며, 실제 의존성 대신 모의 객체를 사용할 수도 있습니다. (출처: https://docs.spring.io/spring-boot/reference/testing/spring-applications.html)"
"Spring 애플리케이션을 통합 테스트하기 위해 사용할 수 있는 방법은 무엇인가요?","Spring 애플리케이션을 통합 테스트하기 위해 Spring ApplicationContext를 사용하여 통합 테스트를 수행할 수 있습니다. spring-test 모듈을 사용하여 Spring 프레임워크를 테스트할 수 있으며, org.springframework:spring-test에 대한 종속성을 직접 선언하거나 spring-boot-starter-test 스타터를 사용하여 이를 가져올 수 있습니다. spring-test 모듈을 사용해 본 적이 없다면 Spring 프레임워크 참조 문서의 관련 섹션을 읽어보십시오. (출처: https://docs.spring.io/spring-boot/reference/testing/spring-applications.html)"
"Spring 애플리케이션을 통합 테스트하기 위해 테스트 모듈을 사용하는 방법은 무엇인가요?","Spring 애플리케이션을 통합 테스트하기 위해 org.springframework:spring-test에 대한 종속성을 직접 선언하거나 spring-boot-starter-test 스타터를 사용하여 이를 가져올 수 있습니다. Spring 프레임워크 참조 문서의 관련 섹션을 읽어보면 spring-test 모듈을 사용하는 방법에 대해 자세히 알 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/testing/spring-applications.html)"
"스프링 부트 애플리케이션은 어떻게 테스트하나요?","스프링 부트 애플리케이션은 일반적인 스프링 컨텍스트와 별반 다를 것이 없기 때문에, @SpringBootTest 어노테이션을 사용하여 애플리케이션 컨텍스트를 로드하고, @MockBean 어노테이션을 사용하여 모의 구현을 제공할 수 있습니다. 테스트는 SpringBootTest.WebEnvironment 속성을 사용하여 웹 환경을 추가로 세분화할 수 있습니다. 또한, Spring Boot는 MockMvc 및 WebTestClient와 같은 여러 테스트 관련 라이브러리를 제공하여 웹 애플리케이션의 테스트를 돕습니다."
"스프링 부트 애플리케이션에서 사용자 구성 및 슬라이싱이란 무엇인가요?","사용자 구성 및 슬라이싱은 테스트에서 사용자 구성 클래스를 메인 @SpringBootApplication과 분리하여 사용하는 것을 의미합니다. 이는 테스트에서 메인 애플리케이션 클래스에 영역별 구성을 추가하지 않도록 하는 것이 중요합니다. 이를 위해 사용자 구성 클래스를 메인 애플리케이션과 동일한 레벨에 별도의 @Configuration 클래스로 이동하고, 필요한 경우 @Import 어노테이션을 사용하여 해당 구성을 테스트에 포함시킬 수 있습니다."
"Spring Boot 애플리케이션은 어떤 기술을 사용하여 배포를 최적화할 수 있나요?","Spring Boot는 GraalVM 네이티브 이미지, 클래스 데이터 공유, 체크포인트 및 복원을 사용하여 배포를 최적화할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/index.html)"
"Spring Boot 애플리케이션은 Docker 컨테이너로 패키징하는 방법은 무엇인가요?","Spring Boot 애플리케이션은 Container Images 문서에 설명된 기술을 사용하여 Docker 컨테이너로 패키징할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/index.html)"
"Spring Boot 애플리케이션이 배포 시 최적화를 위해 사용하는 기술은 어떤 것이 있나요?","Spring Boot 애플리케이션은 GraalVM 네이티브 이미지, 클래스 데이터 공유, 체크포인트 및 복원 등의 기술을 사용하여 배포 시 최적화를 수행할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/index.html)"
"Spring Boot에서 실행 가능한 jar를 추출하면 어떤 장점이 있고, 어떤 경우에 추천되나요?","Spring Boot에서 실행 가능한 jar를 추출하면 작은 시작 비용이 드는 중첩된 jar에서 클래스를 로드하는 것보다 더 빠르고 효율적인 실행이 가능합니다. 특히, PaaS 구현체 중 일부는 아카이브를 실행하기 전에 추출하는 것을 선택할 수 있습니다. 예를 들어, Cloud Foundry는 이러한 방식으로 작동합니다. 또한, CDS(class-data-sharing)에 최적화된 레이아웃을 사용할 수 있습니다. 이 레이아웃은 라이브러리가 lib/ 폴더에 추출되고, 애플리케이션 jar에는 애플리케이션 클래스와 manifest가 포함되어 있어 라이브러리를 참조합니다. 실행 가능한 jar를 추출하려면 다음 명령어를 실행하세요: $ java -Djarmode=tools -jar my-app.jar extract. 그런 다음, 추출된 jar를 실행할 수 있습니다: $ java -jar my-app/my-app.jar. 실행 후, 실행 가능한 jar를 실행하는 것과 추출된 jar를 실행하는 것 사이에는 실행 시간의 차이가 없을 것으로 예상됩니다. 사용 가능한 모든 옵션을 보려면 다음 명령어를 실행하세요: $ java -Djarmode=tools -jar my-app.jar help extract. (출처: https://docs.spring.io/spring-boot/reference/packaging/efficient.html)"
"Spring Boot에서 실행 가능한 jar를 추출하는 데 권장되는 레이아웃은 무엇이며, 어떤 이점이 있나요?","Spring Boot에서 실행 가능한 jar를 추출하는 데 권장되는 레이아웃은 가장 효율적이며, CDS(class-data-sharing)에 최적화되어 있습니다. 이 레이아웃은 라이브러리가 lib/ 폴더에 추출되고, 애플리케이션 jar에는 애플리케이션 클래스와 manifest가 포함되어 있어 라이브러리를 참조합니다. 이 레이아웃은 효율적인 실행을 위해 라이브러리를 공유하고, 배포 시간을 단축시킵니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/efficient.html)"
"Spring Boot에서 실행 가능한 jar를 추출하는 방법은 무엇이며, 추출 후 실행하려면 어떤 단계를 거쳐야 하나요?","Spring Boot에서 실행 가능한 jar를 추출하려면 다음 명령어를 실행하세요: $ java -Djarmode=tools -jar my-app.jar extract. 그런 다음, 추출된 jar를 실행할 수 있습니다: $ java -jar my-app/my-app.jar. 실행 후, 실행 가능한 jar를 실행하는 것과 추출된 jar를 실행하는 것 사이에는 실행 시간의 차이가 없을 것으로 예상됩니다. 사용 가능한 모든 옵션을 보려면 다음 명령어를 실행하세요: $ java -Djarmode=tools -jar my-app.jar help extract. (출처: https://docs.spring.io/spring-boot/reference/packaging/efficient.html)"
"Class Data Sharing(CDS)란 무엇인가요?","Class Data Sharing(CDS)는 Java 어플리케이션의 시작 시간과 메모리 사용량을 줄일 수 있는 JVM 기능입니다. (출처: https://docs.oracle.com/en/java/javase/17/vm/class-data-sharing.html)"
"CDS를 사용하기 위해 훈련 실행을 어떻게 수행하나요?","CDS를 사용하기 위해 먼저 추출된 형태로 어플리케이션에 대한 훈련 실행을 수행해야 합니다. 다음 명령어를 사용하여 수행할 수 있습니다: $ java -Djarmode=tools -jar my-app.jar extract --destination application $ cd application $ java -XX:ArchiveClassesAtExit=application.jsa -Dspring.context.exit=onRefresh -jar my-app.jar. (출처: https://docs.spring.io/spring-boot/reference/packaging/class-data-sharing.html)"
"CDS를 사용하기 위해 어떻게 캐시를 사용하나요?","CDS를 사용하기 위해 어플리케이션을 시작할 때 추가 매개변수를 지정해야 합니다. 다음 명령어를 사용하여 지정할 수 있습니다: $ java -XX:SharedArchiveFile=application.jsa -jar my-app.jar. (출처: https://docs.spring.io/spring-boot/reference/packaging/class-data-sharing.html)"
"네이티브 이미지는 무엇인가요?","네이티브 이미지는 GraalVM Native Images(https://www.graalvm.org/native-image/)에서 생성되는 독립 실행 파일로, 컴파일된 Java 애플리케이션을 미리 처리하여 생성됩니다. 네이티브 이미지는 일반적으로 JVM 기반 애플리케이션보다 더 작은 메모리 풋프린트와 더 빠른 시작 시간을 가집니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/native-image/index.html)"
"네이티브 이미지가 JVM 기반 애플리케이션과 비교하여 어떤 이점이 있나요?","네이티브 이미지는 일반적으로 JVM 기반 애플리케이션보다 더 작은 메모리 풋프린트와 더 빠른 시작 시간을 가집니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/native-image/index.html)"
"스프링 부트에서 네이티브 이미지 생성을 위한 문서를 어디에서 찾을 수 있나요?","스프링 부트에서 네이티브 이미지 생성에 대한 문서는 https://docs.spring.io/spring-boot/reference/packaging/native-image/index.html에서 찾을 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/native-image/index.html)"
"Spring Boot 애플리케이션에서 중첩된 구성 속성을 어떻게 처리해야 하나요?","Spring Boot 애플리케이션에서 중첩된 구성 속성을 처리하려면 중첩된 클래스에 @NestedConfigurationProperty 어노테이션을 사용해야 합니다. 이 어노테이션을 사용하면 Spring AOT 엔진이 중첩된 속성에 대한 힌트를 자동으로 생성합니다. 또한 생성자 바인딩을 사용하거나 Kotlin의 데이터 클래스를 사용하는 경우에도 해당 필드 또는 파라미터에 @NestedConfigurationProperty 어노테이션을 사용해야 합니다. 항상 공개 getter와 setter를 사용하여 속성을 바인딩할 수 있도록 해야 합니다."
"Spring Boot 실행 가능한 JAR를 네이티브 이미지로 변환하는 방법은 무엇인가요?","Spring Boot 실행 가능한 JAR를 네이티브 이미지로 변환하려면 Cloud Native Buildpacks 또는 GraalVM의 native-image 도구를 사용할 수 있습니다. 빌드팩을 사용하려면 Maven 또는 Gradle을 통해 Cloud Native Buildpacks를 구성하고 Docker와 pack 도구가 설치되어 있어야 합니다. GraalVM을 사용하려면 GraalVM 배포판을 설치하고 JAR 파일을 압축 해제하고 GraalVM의 native-image 도구와 함께 실행해야 합니다."
"GraalVM 네이티브 이미지 추적 에이전트는 어떤 용도로 사용되나요?","GraalVM 네이티브 이미지 추적 에이전트는 JVM에서 리플렉션, 리소스 또는 프록시 사용을 가로채서 관련 힌트를 생성하는 데 사용됩니다. Spring은 대부분의 힌트를 자동으로 생성하지만 추적 에이전트를 사용하여 누락된 항목을 빠르게 식별할 수 있습니다. 이 에이전트를 사용하여 네이티브 이미지에 대한 힌트를 생성하려면 애플리케이션을 직접 실행하거나 애플리케이션 테스트를 실행하여 누락된 힌트를 식별할 수 있습니다. 추적 에이전트에는 기록된 힌트를 호출자 클래스에 따라 필터링하는 등 다양한 고급 옵션이 있습니다."
"Spring Boot에서 JVM의 체크포인트 및 복원에 대한 지원을 제공하는 OpenJDK 프로젝트는 무엇인가요?","Coordinated Restore at Checkpoint(CRaC)는 OpenJDK 프로젝트로, Spring Boot에서 JVM의 체크포인트 및 복원에 대한 지원을 제공합니다. (출처: https://docs.spring.io/spring-framework/reference/6.1/integration/checkpoint-restore.html)"
"CRaC를 사용하여 JVM의 체크포인트를 생성하는 방법은 무엇인가요?","CRaC를 사용하여 JVM의 체크포인트를 생성하려면, API 호출, jcmd 명령, HTTP 엔드포인트 또는 다른 메커니즘을 사용하여 체크포인트를 트리거해야 합니다. (출처: https://docs.spring.io/spring-framework/reference/6.1/integration/checkpoint-restore.html)"
"Spring Boot에서 체크포인트 및 복원 지원을 활성화하는 방법은 무엇인가요?","Spring Boot에서 체크포인트 및 복원 지원을 활성화하려면, Spring Boot 애플리케이션에 종속성으로 추가하고, 속성을 구성하고, 애플리케이션을 실행해야 합니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/checkpoint-restore.html)"
"Spring Boot 애플리케이션은 컨테이너 이미지를 어떻게 생성할 수 있나요?","Dockerfile을 사용하거나 Cloud Native Buildpacks를 사용하여 최적화된 Docker 호환 컨테이너 이미지를 생성할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/container-images/index.html)"
"Spring Boot 애플리케이션의 컨테이너 이미지는 어디에서 실행할 수 있나요?","어디서든 실행할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/container-images/index.html)"
"Spring Boot 애플리케이션의 컨테이너 이미지 생성에 대한 자세한 정보는 어디에서 찾을 수 있나요?","Spring Boot 참조 문서의 Container Images 섹션에서 확인할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/container-images/index.html)"
"스프링 부트 uber jar를 도커 이미지로 패키징하는 것의 단점은 무엇인가요?","스프링 부트 uber jar를 도커 이미지로 패키징하는 것의 단점으로는, uber jar를 압축 해제하지 않고 실행할 때 항상 일정한 오버헤드가 발생하며, 이는 컨테이너화된 환경에서 눈에 띄게 될 수 있습니다. 또한, 애플리케이션 코드와 모든 종속성을 도커 이미지의 한 레이어에 넣는 것은 최적이 아닙니다. Docker는 종종 레이어의 맨 아래쪽만 변경하고 다른 레이어는 캐시에서 가져올 수 있기 때문에, jar 파일을 애플리케이션 클래스 앞의 레이어에 넣는 것이 좋습니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/container-images/efficient-images.html)"
"레이어 인덱스 파일은 무엇이며, 어떻게 사용되나요?","레이어 인덱스 파일은 jar에 추가되어 최적화된 도커 이미지를 쉽게 만들 수 있도록 합니다. 이 파일은 레이어 목록과 그 안에 포함되어야 하는 jar의 부분을 제공합니다. 인덱스의 레이어 목록은 Docker/OCI 이미지에 추가되어야 하는 레이어의 순서에 따라 정렬됩니다. 기본적으로, 의존성, spring-boot-loader, snapshot-dependencies, application과 같은 레이어가 지원됩니다. 레이어 인덱스 파일은 애플리케이션 빌드 간에 변경될 가능성에 따라 코드를 분리하도록 설계되었습니다. 라이브러리 코드는 빌드 간에 변경될 가능성이 적으므로, 툴링이 레이어를 캐시에서 재사용할 수 있도록 자체 레이어에 배치됩니다. 애플리케이션 코드는 빌드 간에 변경될 가능성이 높으므로 별도의 레이어에 격리됩니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/container-images/efficient-images.html)"
"Maven과 Gradle에서 레이어 인덱스 파일을 아카이브에 추가하는 방법은 무엇인가요?","Maven의 경우, packaging layered jar 또는 war 섹션(https://docs.spring.io/spring-boot/reference/html/maven-plugin.html#packaging.layers)을 참조하여 아카이브에 레이어 인덱스 파일을 추가하는 방법에 대한 자세한 내용을 확인할 수 있습니다. Gradle의 경우, packaging layered jar 또는 war 섹션(https://docs.spring.io/spring-boot/reference/html/gradle-plugin.html#packaging-executable.configuring.layered-archives)을 참조하여 레이어 인덱스 파일을 아카이브에 추가하는 방법에 대한 자세한 내용을 확인할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/container-images/efficient-images.html)"
"Dockerfile에서 레이어링 기능을 사용하면 어떤 장점이 있나요?","Dockerfile에서 레이어링 기능을 사용하면 최적화된 이미지를 생성할 수 있습니다. 이는 Docker 이미지의 크기를 줄이고, 빌드 및 실행 속도를 향상시킵니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/container-images/dockerfiles.html)"
"Dockerfile에서 `jarmode`를 사용하면 어떤 이점이 있나요?","Dockerfile에서 `jarmode`를 사용하면 jar 파일을 효율적으로 분할하여 각 레이어에 필요한 파일을 추출할 수 있습니다. 또한, `jarmode`를 사용하면 CDS(Class Data Sharing)를 활성화할 수 있으며, 이는 애플리케이션의 시작 속도를 향상시킵니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/container-images/dockerfiles.html)"
"Dockerfile에서 `jarmode`를 사용하여 CDS를 활성화하는 방법은 무엇인가요?","Dockerfile에서 `jarmode`를 사용하여 CDS를 활성화하려면, 빌드 단계에서 jar 파일을 추출하고, 실행 단계에서 CDS 아카이브를 생성하는 훈련 실행을 수행해야 합니다. 마지막으로, `java -jar`에 CDS 매개변수를 전달하여 CDS를 활성화합니다. (출처: https://docs.spring.io/spring-boot/reference/packaging/container-images/dockerfiles.html)"
"Spring Boot 애플리케이션에서 Cloud Native Buildpacks를 사용하여 Docker 이미지를 빌드하는 방법은 무엇인가요?","Spring Boot는 Maven 및 Gradle 플러그인을 통해 Cloud Native Buildpacks를 직접 지원합니다. 이를 통해 Maven(../../../maven-plugin/build-image.html#build-image) 및 Gradle(../../../gradle-plugin/packaging-oci-image.html)을 사용하여 Docker 호환 이미지를 만들 수 있습니다. Paketo Spring Boot 빌드팩(https://github.com/paketo-buildpacks/spring-boot)은 layers.idx 파일을 지원하므로 빌드팩으로 생성된 이미지에 적용된 레이어 커스터마이징이 반영됩니다. spring.web.resources.cache.use-last-modified를 사용하여 재사용 가능한 빌드 및 컨테이너 이미지 캐싱을 달성할 수 있습니다."
"Spring Boot 애플리케이션에서 Cloud Native Buildpacks를 사용하여 Docker 이미지를 빌드할 때 어떤 이점이 있나요?","Cloud Native Buildpacks를 사용하면 Spring Boot 애플리케이션을 Docker 이미지로 빌드할 수 있으며, 이를 어디에서나 실행할 수 있습니다. 또한, Paketo Spring Boot 빌드팩은 layers.idx 파일을 지원하므로 빌드팩으로 생성된 이미지에 적용된 레이어 커스터마이징이 반영됩니다. 이를 통해 재사용 가능한 빌드 및 컨테이너 이미지 캐싱을 달성할 수 있습니다."
"Spring Boot 애플리케이션에서 Cloud Native Buildpacks를 사용하여 Docker 이미지를 빌드할 때 애플리케이션이 런타임에 레이어 사용자 지정에 의존하는 경우 어떻게 해야 하나요?","애플리케이션이 런타임에 레이어 사용자 지정에 의존하는 경우, 빌드팩이 애플리케이션 리소스 메타데이터를 수정할 수 있으므로 문제가 발생할 수 있습니다. spring.web.resources.cache.use-last-modified 속성을 사용하여 정적 리소스를 제공할 때 Spring Boot가 해당 정보를 사용하지 않도록 설정할 수 있습니다."
"스프링 부트에서 프로덕션 환경에서 애플리케이션을 모니터링하고 관리하는 방법은 무엇인가요?","HTTP 엔드포인트 또는 JMX를 사용하여 스프링 부트에서 프로덕션 환경에서 애플리케이션을 모니터링하고 관리할 수 있습니다. 또한, 감사, 건강 상태 및 메트릭 수집을 통해 애플리케이션에 자동으로 적용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/index.html)"
"스프링 부트에서 프로덕션 환경에서 애플리케이션을 관리하는 데 사용할 수 있는 추가 기능은 무엇인가요?","스프링 부트에서는 프로덕션 환경에서 애플리케이션을 모니터링하고 관리하는 데 도움이 되는 여러 추가 기능을 제공합니다. 이에는 HTTP 엔드포인트 또는 JMX를 사용한 애플리케이션 관리 및 모니터링, 감사, 건강 상태 및 메트릭 수집이 포함됩니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/index.html)"
"스프링 부트에서 프로덕션 환경에서 애플리케이션의 건강 상태를 확인하는 방법은 무엇인가요?","스프링 부트에서는 프로덕션 환경에서 애플리케이션의 건강 상태를 확인할 수 있는 기능을 제공합니다. 이를 통해 애플리케이션의 건강 상태를 실시간으로 모니터링하고 문제를 신속하게 해결할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/health.html)"
"How can I enable production-ready features in my Spring Boot application?","To enable Spring Boot's production-ready features, add a dependency on the spring-boot-starter-actuator starter. This can be done in a Maven-based project by adding the following starter dependency: <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> </dependencies> For Gradle, use the following declaration: dependencies { implementation 'org.springframework.boot:spring-boot-starter-actuator' } (Source: https://docs.spring.io/spring-boot/reference/actuator/enabling.html)"
"What is the definition of an actuator in the context of Spring Boot?","An actuator in the Spring Boot context refers to a manufacturing term that describes a mechanical device for moving or controlling something. Actuators can generate a large amount of motion from a small change. (Source: https://docs.spring.io/spring-boot/reference/actuator/enabling.html)"
"How can I add the actuator to my Spring Boot project using Maven?","To add the actuator to a Maven-based Spring Boot project, add the following starter dependency: <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> </dependencies> (Source: https://docs.spring.io/spring-boot/reference/actuator/enabling.html)"
"스프링 부트의 액추에이터 엔드포인트란 무엇이며, 어떤 목적으로 사용되나요?","스프링 부트의 액추에이터 엔드포인트는 애플리케이션의 모니터링과 상호작용을 가능하게 하는 기능을 제공합니다. 이를 통해 애플리케이션의 상태를 확인하고, 필요한 작업을 수행할 수 있습니다. 예를 들어, health 엔드포인트는 기본 애플리케이션 건강 정보를 제공하고, beans 엔드포인트는 애플리케이션의 모든 스프링 빈 목록을 표시합니다. 엔드포인트는 활성화 및 비활성화, 노출 여부를 설정할 수 있으며, HTTP 또는 JMX를 통해 원격으로 접근할 수 있습니다. 또한, 사용자 정의 엔드포인트를 추가할 수도 있습니다. (출처: <https://docs.spring.io/spring-boot/reference/actuator/endpoints.html>)"
"스프링 부트의 액추에이터 엔드포인트를 보안하려면 어떻게 해야 하나요?","스프링 부트의 액추에이터 엔드포인트를 보안하려면, 엔드포인트의 노출 여부를 구성하고, 사용자 정의 보안 구성을 추가해야 합니다. 기본적으로 /health 엔드포인트만 HTTP로 노출되며, management.endpoints.web.exposure.include 속성을 사용하여 노출되는 엔드포인트를 구성할 수 있습니다. 엔드포인트에 대한 사용자 정의 보안 구성을 추가하려면, EndpointRequest 클래스를 사용하여 사용자 정의 RequestMatcher 객체를 만들어 Spring Security와 함께 사용할 수 있습니다. 또한, management.endpoints.web.exposure.include 속성을 설정하기 전에 노출된 액추에이터에 민감한 정보가 포함되어 있지 않거나, 방화벽 뒤에 배치되어 있거나, Spring Security와 같은 보안 메커니즘으로 보호되고 있는지 확인해야 합니다. (출처: <https://docs.spring.io/spring-boot/reference/actuator/endpoints.html>)"
"스프링 부트의 액추에이터 엔드포인트에서 건강 정보를 구성하려면 어떻게 해야 하나요?","스프링 부트의 액추에이터 엔드포인트에서 건강 정보를 구성하려면, management.endpoint.health.show-details 및 management.endpoint.health.show-components 속성을 각각 never, when-authorized 또는 always 값으로 설정할 수 있습니다. 건강 정보는 HealthContributorRegistry의 내용을 기반으로 수집되며, Spring Boot는 여러 자동 구성된 HealthContributors를 제공합니다. 또한, 사용자 정의 HealthIndicators 및 ReactiveHealthIndicators를 작성하여 애플리케이션의 특정 부분에 대한 건강 정보를 제공할 수 있습니다. 건강 상태 및 매핑된 HTTP 상태 코드는 필요에 따라 사용자 정의할 수 있습니다. (출처: <https://docs.spring.io/spring-boot/reference/actuator/endpoints.html>)"
"스프링 부트 액츄에이터에서 관리 엔드포인트의 기본 접두사는 무엇인가요?","/actuator (출처: https://docs.spring.io/spring-boot/reference/actuator/monitoring.html)"
"스프링 부트 액츄에이터에서 관리 엔드포인트의 경로를 사용자 정의하려면 어떻게 해야 하나요?","management.endpoints.web.base-path 속성을 사용하여 관리 엔드포인트의 접두사를 변경할 수 있습니다. 예를 들어, management.endpoints.web.base-path=/manage로 설정하면 엔드포인트가 /actuator/{id}에서 /manage/{id}로 변경됩니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/monitoring.html)"
"스프링 부트 액츄에이터에서 관리 엔드포인트의 SSL 구성을 어떻게 할 수 있나요?","management.server.ssl.* 속성을 사용하여 관리 서버에 대한 SSL을 구성할 수 있습니다. 예를 들어, management.server.ssl.enabled=true로 설정하면 관리 서버가 SSL을 사용하게 됩니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/monitoring.html)"
"스프링 부트에서 JMX 모니터링 및 관리를 활성화하려면 어떻게 해야 하나요?","spring.jmx.enabled 구성 속성을 true로 설정하여 JMX 모니터링 및 관리를 활성화할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/jmx.html)"
"스프링 부트에서 JMX를 통해 관리 엔드포인트를 노출하는 기본 도메인은 무엇인가요?","스프링 부트에서 JMX를 통해 관리 엔드포인트를 노출하는 기본 도메인은 org.springframework.boot입니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/jmx.html)"
"스프링 부트에서 JMX 엔드포인트를 통해 엔드포인트를 등록하는 방식을 완전히 제어하려면 어떻게 해야 하나요?","자체 EndpointObjectNameFactory 구현을 등록하여 JMX 도메인에서 엔드포인트 등록을 완전히 제어할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/jmx.html)"
"스프링 부트 액추에이터에서 Micrometer를 사용하여 어떤 모니터링 시스템을 지원하나요?","스프링 부트 액추에이터는 AppOptics, Atlas, Datadog, Dynatrace, Elastic, Ganglia, Graphite, Humio, Influx, JMX, KairosDB, New Relic, OpenTelemetry, Prometheus, SignalFx, Simple, Stackdriver, StatsD, Wavefront 등의 모니터링 시스템을 지원합니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/metrics.html)"
"스프링 부트에서 Micrometer를 사용하여 JVM 메트릭을 어떻게 활성화할 수 있나요?","스프링 부트에서는 Micrometer를 사용하여 자동 구성으로 JVM 메트릭을 활성화할 수 있습니다. JVM 메트릭은 jvm. 미터 이름으로 게시됩니다. 메모리 및 버퍼 풀 세부 정보, 가비지 컬렉션과 관련된 통계, 스레드 사용량, 로드된 및 언로드된 클래스 수 등의 메트릭이 제공됩니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/metrics.html)"
"스프링 부트에서 Micrometer를 사용하여 사용자 정의 메트릭을 등록하려면 어떻게 해야 하나요?","스프링 부트에서 Micrometer를 사용하여 사용자 정의 메트릭을 등록하려면 컴포넌트에서 MeterRegistry를 주입하고 MeterRegistry를 사용하여 게이지, 타이머 또는 카운터와 같은 메트릭을 등록하면 됩니다. 또한 MeterBinder를 사용하여 메트릭을 등록할 수도 있습니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/metrics.html)"
"Spring Boot Actuator에서 Tracing을 위한 의존성 관리와 자동 설정을 제공하는 트레이서 라이브러리는 무엇인가요?","Micrometer Tracing (https://docs.micrometer.io/tracing/reference/1.3)입니다."
"Spring Boot에서 Tracing을 위해 사용되는 주요 트레이서 라이브러리는 무엇인가요?","OpenTelemetry(https://opentelemetry.io/) with Zipkin(https://zipkin.io/), Wavefront(https://docs.wavefront.com/), or OTLP(https://opentelemetry.io/docs/reference/specification/protocol/), OpenZipkin Brave(https://github.com/openzipkin/brave) with Zipkin(https://zipkin.io/) or Wavefront(https://docs.wavefront.com/) 등이 있습니다."
"Spring Boot에서 Tracing을 시작하려면 어떻게 해야 하나요?","Developing Your First Spring Boot Application(../../tutorial/first-application/index.html) 섹션에서 다루는 간단한 'Hello World!' 웹 애플리케이션을 사용하면 됩니다. OpenTelemetry tracer와 Zipkin을 trace backend로 사용하는 것이 좋습니다. 관리.추적.샘플링.확률 속성을 100%로 설정하여 모든 요청이 추적 백엔드로 전송되도록 해야 합니다. 추적을 수집하고 시각화하려면 실행 중인 추적 백엔드가 필요합니다. 여기서는 Zipkin을 추적 백엔드로 사용합니다. Zipkin 퀵 스타트 가이드(https://zipkin.io/pages/quickstart)를 참조하세요."
"Spring Security와 Actuator에서 사용되는 감사 프레임워크는 어떤 이벤트 유형을 지원하나요?","Spring Security와 Actuator에서 사용되는 감사 프레임워크는 기본적으로 'authentication success', 'failure', 'access denied' 예외와 같은 이벤트 유형을 지원합니다. (출처: <https://docs.spring.io/spring-boot/reference/actuator/auditing.html>)"
"Spring Boot에서 감사 기능을 활성화하는 방법은 무엇인가요?","Spring Boot에서 감사 기능을 활성화하려면 애플리케이션 구성에서 AuditEventRepository 유형의 빈을 제공하면 됩니다. Spring Boot는 InMemoryAuditEventRepository를 제공하며, 개발 환경에서만 사용하는 것이 좋습니다. 프로덕션 환경에서는 자체적인 AuditEventRepository 구현체를 생성하는 것이 좋습니다. (출처: <https://docs.spring.io/spring-boot/reference/actuator/auditing.html>)"
"Spring Security의 감사 기능을 사용자 정의하려면 어떻게 해야 하나요?","Spring Security의 감사 기능을 사용자 정의하려면 AbstractAuthenticationAuditListener와 AbstractAuthorizationAuditListener의 자체 구현체를 제공하면 됩니다. 또한, 감사 서비스를 자체 비즈니스 이벤트에 사용할 수도 있습니다. 이를 위해 AuditEventRepository 빈을 자체 컴포넌트에 주입하고 직접 사용하거나, AuditApplicationEvent를 Spring ApplicationEventPublisher를 사용하여 게시하면 됩니다. (출처: <https://docs.spring.io/spring-boot/reference/actuator/auditing.html>)"
"HTTP 교환을 기록하는 방법은 무엇인가요?","Spring Boot에서 HttpExchangeRepository 인터페이스를 구현하는 빈을 애플리케이션의 구성에 제공하여 HTTP 교환을 기록할 수 있습니다. InMemoryHttpExchangeRepository는 기본적으로 마지막 100개의 요청-응답 교환을 저장합니다. 출처: https://docs.spring.io/spring-boot/reference/actuator/http-exchanges.html"
"InMemoryHttpExchangeRepository의 한계는 무엇인가요?","InMemoryHttpExchangeRepository는 추적 솔루션에 비해 제한적이며, 개발 환경에서만 사용하는 것이 좋습니다. 프로덕션 환경에서는 Zipkin 또는 OpenTelemetry와 같은 프로덕션 준비 완료된 추적 또는 관찰 가능성 솔루션을 사용하는 것이 좋습니다. 출처: https://docs.spring.io/spring-boot/reference/actuator/http-exchanges.html"
"기록된 교환에 포함되는 항목을 사용자 정의하려면 어떻게 해야 하나요?","management.httpexchanges.recording.include 구성 속성을 사용하여 각 기록된 교환에 포함되는 항목을 사용자 정의할 수 있습니다. 출처: https://docs.spring.io/spring-boot/reference/actuator/http-exchanges.html"
"스프링 부트에서 PID 파일이 생성되는 위치와 파일 이름은 무엇인가요?","스프링 부트에서 PID 파일은 기본적으로 애플리케이션 디렉토리에 application.pid라는 파일 이름으로 생성됩니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/process-monitoring.html)"
"스프링 부트에서 실행 중인 웹 서버의 포트 파일을 생성하는 방법을 알려주세요.","스프링 부트에서 웹 서버의 포트 파일을 생성하려면, ApplicationPidFileWriter와 WebServerPortFileWriter 클래스를 사용할 수 있습니다. 이 클래스들은 기본적으로 활성화되지 않으며, META-INF/spring.factories 파일에서 리스너를 활성화하거나, SpringApplication.addListeners(…) 메서드를 사용하여 적절한 Writer 객체를 전달하여 프로그래밍 방식으로 활성화할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/process-monitoring.html)"
"스프링 부트에서 프로세스 모니터링을 위한 리스너를 사용자 정의하는 방법은 무엇인가요?","스프링 부트에서 프로세스 모니터링을 위한 리스너를 사용자 정의하려면, ApplicationPidFileWriter와 WebServerPortFileWriter 클래스를 사용하는 경우, SpringApplication.addListeners(…) 메서드를 사용하여 적절한 Writer 객체를 전달하고, Writer 생성자에서 파일 이름과 경로를 사용자 정의할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/process-monitoring.html)"
"스프링 부트의 액추에이터 모듈에서 Cloud Foundry 인스턴스에 배포 시 활성화되는 추가 지원은 무엇인가요?","Cloud Foundry 인스턴스에 배포 시 활성화되는 추가 지원은 /cloudfoundryapplication 경로를 통해 @Endpoint 빈에 대한 대체 보안 경로를 제공하는 것입니다. 이를 통해 Cloud Foundry 관리 UI에서 Spring Boot 액추에이터 정보를 보강할 수 있으며, 애플리케이션 상태 페이지에 일반적인 'running' 또는 'stopped' 상태 대신 전체 건강 정보를 포함할 수 있습니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/cloud-foundry.html)"
"Cloud Foundry 인스턴스에서 Spring Boot의 액추에이터 모듈을 사용하여 애플리케이션의 건강 정보를 확인하는 방법은 무엇인가요?","Cloud Foundry 인스턴스에서 Spring Boot의 액추에이터 모듈을 사용하여 애플리케이션의 건강 정보를 확인하려면 /cloudfoundryapplication 경로를 사용해야 합니다. 이 경로는 활성화되어 있어야 하며, 일반적인 사용자에게는 직접 액세스할 수 없습니다. 이 엔드포인트를 사용하려면 요청과 함께 유효한 UAA 토큰을 전달해야 합니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/cloud-foundry.html)"
"Cloud Foundry 인스턴스에서 Spring Boot의 액추에이터 모듈을 비활성화하는 방법은 무엇인가요?","Cloud Foundry 인스턴스에서 Spring Boot의 액추에이터 모듈을 비활성화하려면 application.properties 파일에 management.cloudfoundry.enabled=false 설정을 추가하면 됩니다. 이 설정은 Cloud Foundry 인스턴스에서 액추에이터 모듈을 완전히 비활성화합니다. (출처: https://docs.spring.io/spring-boot/reference/actuator/cloud-foundry.html)"
"스프링 부트를 사용할 때 'how do I do that...'에 대한 답변을 어디에서 찾을 수 있나요?","스프링 부트 공식 문서의 'How-to Guides' 섹션에서 일반적인 질문에 대한 답변을 찾을 수 있습니다. 또한, stackoverflow.com에서 'spring-boot' 태그를 사용하여 검색하고 질문을 할 수 있습니다. (출처: https://docs.spring.io/spring-boot/how-to/index.html)"
"스프링 부트에서 특정 문제를 해결하는 방법을 추가하려면 어떻게 해야 하나요?","스프링 부트 공식 문서에서 다루지 않는 특정 문제를 해결하려면 stackoverflow.com에서 'spring-boot' 태그를 사용하여 검색하고 질문을 할 수 있습니다. 또한, 스프링 부트 Github 저장소에서 pull request를 보내 'How-to Guides' 섹션을 확장할 수 있습니다. (출처: https://docs.spring.io/spring-boot/how-to/index.html)"
"스프링 부트에서 특정 문제를 해결하는 방법을 어떻게 찾을 수 있나요?","스프링 부트 공식 문서의 'How-to Guides' 섹션에서 일반적인 질문에 대한 답변을 찾을 수 있습니다. 만약 해당 섹션에서 원하는 답변을 찾지 못했다면, stackoverflow.com에서 'spring-boot' 태그를 사용하여 검색하고 질문을 할 수 있습니다. (출처: https://docs.spring.io/spring-boot/how-to/index.html)"
"스프링 액추에이터를 사용하여 자동 구성을 디버깅하는 방법은 무엇인가요?","스프링 액추에이터를 사용하여 자동 구성을 디버깅하려면 조건 엔드포인트(/actuator/conditions)를 사용하여 스프링 부트 애플리케이션 컨텍스트에서 사용 가능한 유용한 ConditionEvaluationReport를 확인할 수 있습니다. 이 보고서는 런타임에 스프링 부트에 의해 추가된 기능과 추가되지 않은 기능을 보여줍니다."
"스프링 부트 애플리케이션에서 FailureAnalyzer를 등록하는 방법은 무엇인가요?","스프링 부트 애플리케이션에서 FailureAnalyzer를 등록하려면 META-INF/spring.factories 파일에 FailureAnalyzer 클래스의 완전 자격 이름을 등록해야 합니다. 예를 들어, 다음 예제는 ProjectConstraintViolationFailureAnalyzer를 등록합니다: `org.springframework.boot.diagnostics.FailureAnalyzer=com.example.ProjectConstraintViolationFailureAnalyzer`."
"스프링 애플리케이션 실행 전에 Environment 또는 ApplicationContext를 사용자 정의하는 방법은 무엇인가요?","스프링 애플리케이션 실행 전에 Environment 또는 ApplicationContext를 사용자 정의하려면 ApplicationListener 또는 ApplicationContextInitializer를 구현하고 SpringApplication 인스턴스에 추가할 수 있습니다. 또는 META-INF/spring.factories 파일에 등록하여 모든 애플리케이션에 대한 선언적 사용자 정의를 사용할 수 있습니다. SpringApplication은 또한 ApplicationEvents를 듣고 ApplicationContext에서 게시된 이벤트에 대한 리스너를 등록합니다."
"스프링 부트 웹 애플리케이션에서 임베디드 웹 서버를 변경하는 방법은 무엇인가요?","스프링 부트 스타터에 따라 다른 의존성을 추가하여 임베디드 웹 서버를 변경할 수 있습니다. 예를 들어, Tomcat 대신 Jetty를 사용하려면 spring-boot-starter-web에 의존성을 추가한 다음 spring-boot-starter-tomcat 대신 spring-boot-starter-jetty를 추가하면 됩니다. 재활성 스택 애플리케이션의 경우 spring-boot-starter-webflux에 의존성을 추가한 다음 spring-boot-starter-reactor-netty 대신 spring-boot-starter-tomcat, spring-boot-starter-jetty 또는 spring-boot-starter-undertow를 추가하면 됩니다. 임베디드 서버를 구성하려면 spring.main.web-application-type 속성을 none으로 설정하면 됩니다."
"스프링 부트에서 HTTPS를 구성하는 방법은 무엇인가요?","HTTPS를 구성하려면 server.ssl.* 속성을 설정하여 다양한 SSL 설정을 선언적으로 구성할 수 있습니다. 예를 들어, Java KeyStore 파일을 사용하여 SSL 속성을 설정하는 경우 server.ssl.key-store, server.ssl.key-store-password 및 server.ssl.key-password 속성을 설정해야 합니다. SSL 번들을 사용하여 SSL 트러스트 자료를 구성하고 웹 서버에 적용할 수도 있습니다."
"스프링 부트 애플리케이션에서 HTTP/2를 활성화하려면 어떻게 해야 하나요?","server.http2.enabled 구성 속성을 사용하여 스프링 부트 애플리케이션에서 HTTP/2 지원을 활성화할 수 있습니다. h2(TLS를 통한 HTTP/2)와 h2c(TCP를 통한 HTTP/2) 모두 지원됩니다. h2를 사용하려면 SSL도 활성화해야 합니다. SSL이 활성화되지 않은 경우 h2c가 사용됩니다."
"Spring Boot에서 Jackson2를 사용하여 기본 REST 서비스에서 JSON 응답을 렌더링하는 방법은 무엇인가요?","MyThing 클래스가 Jackson2에 의해 직렬화될 수 있는 한 (일반 POJO 또는 Groovy 객체의 경우 참), localhost:8080/thing은 기본적으로 그것의 JSON 표현을 제공합니다. "
"Spring Boot에서 Jackson XML 확장을 사용하여 REST 서비스에서 XML 응답을 렌더링하는 방법은 무엇인가요?","Jackson의 XML 확장이 사용 불가능한 경우 JAXB를 사용하여 MyThing 클래스에 @XmlRootElement를 주석 처리해야 합니다. "
"Spring Boot에서 Jackson ObjectMapper를 사용자 정의하는 방법은 무엇인가요?","Spring Boot는 이 동작을 사용자 정의하기 쉽게 만드는 몇 가지 기능을 제공합니다. 환경 기반 구성을 사용하여 ObjectMapper 및 XmlMapper 인스턴스를 구성할 수 있습니다. "
"Jersey 기반 웹 애플리케이션을 Spring Security로 보호하는 방법은 어떻게 되나요?","Spring Security는 Spring MVC 기반 웹 애플리케이션과 마찬가지로 Jersey 기반 웹 애플리케이션을 보호하는 데 사용할 수 있습니다. 그러나 Jersey와 함께 Spring Security의 메서드 수준 보안을 사용하려면 Jersey를 구성하여 sendError(int) 대신 setStatus(int)를 사용해야 합니다. 이렇게 하면 Spring Security가 인증 또는 권한 부여 실패를 클라이언트에 보고하기 전에 Jersey가 응답을 커밋하지 않도록 할 수 있습니다. jersey.config.server.response.setStatusOverSendError 속성을 true로 설정해야 합니다."
"Jersey를 Spring MVC와 같은 다른 웹 프레임워크와 함께 사용하려면 어떻게 구성해야 하나요?","Jersey를 다른 웹 프레임워크와 함께 사용하려면 Jersey가 처리할 수 없는 요청을 다른 프레임워크가 처리할 수 있도록 구성해야 합니다. 먼저, spring.jersey.type 애플리케이션 속성을 filter 값으로 구성하여 Jersey를 서블릿이 아닌 필터로 사용하도록 설정합니다. 그런 다음, ResourceConfig를 구성하여 404를 발생시켰을 요청을 전달하도록 설정합니다. 이를 통해 다른 웹 프레임워크가 해당 요청을 처리할 수 있습니다."
"Spring Security의 메서드 수준 보안을 Jersey에서 사용하려면 어떤 Jersey 속성을 구성해야 하나요?","Spring Security의 메서드 수준 보안을 Jersey에서 사용하려면 jersey.config.server.response.setStatusOverSendError 속성을 true로 설정해야 합니다. 이 속성은 해당 애플리케이션의 ResourceConfig 빈에 설정되어야 합니다."
"Spring Boot에서 RestTemplate을 프록시를 사용하도록 구성하려면 어떻게 해야 하나요?","RestTemplateCustomizer를 RestTemplateBuilder와 함께 사용하여 커스텀 RestTemplate을 빌드하는 것이 권장되는 방법입니다. 프록시 구성을 위해 RestTemplate을 커스터마이징하는 방법은 RestTemplateCustomization 문서를 참조하세요. 프록시 구성의 정확한 세부 사항은 사용되는 기본 클라이언트 요청 팩토리에 따라 다릅니다. (출처: https://docs.spring.io/spring-boot/how-to/http-clients.html)"
"Spring Boot에서 Reactor Netty 기반 WebClient를 구성하려면 어떻게 해야 하나요?","네트워크 연결에 대한 클라이언트의 처리를 커스터마이징하려면 ClientHttpConnector 빈을 제공하세요. 다음 예제는 60초의 연결 타임아웃을 구성하고 ReadTimeoutHandler를 추가하여 Reactor Netty 기반 WebClient를 구성하는 방법을 보여줍니다. (출처: https://docs.spring.io/spring-boot/how-to/http-clients.html)"
"Reactor Netty 기반 WebClient에서 네트워크 연결 타임아웃을 어떻게 구성하나요?","HttpClient의 option 메서드를 사용하여 연결 타임아웃을 구성하고, doOnConnected 메서드를 사용하여 ReadTimeoutHandler를 추가하세요. ReactorResourceFactory를 사용하여 연결 제공자와 이벤트 루프 리소스를 효율적으로 공유하세요. (출처: https://docs.spring.io/spring-boot/how-to/http-clients.html)"
"Spring Boot에서 커스텀 DataSource를 구성하려면 어떻게 해야 하나요?","커스텀 DataSource를 구성하려면, 해당 유형의 @Bean을 설정 클래스에서 정의해야 합니다. Spring Boot는 데이터베이스 초기화를 포함하여 DataSource가 필요한 모든 곳에서 커스텀 DataSource를 재사용합니다. 설정을 외부화하려면 DataSource를 환경과 바인딩할 수 있습니다."
"Spring Boot에서 여러 데이터 소스를 구성하려면 어떻게 해야 하나요?","여러 데이터 소스를 구성하려면, 이전 섹션에서 설명한 트릭을 적용할 수 있습니다. 그러나 DataSource 인스턴스 중 하나는 @Primary로 표시해야 합니다. 왜냐하면 여러 자동 구성에서 유형에 따라 하나를 가져올 수 있다고 예상하기 때문입니다. 커스텀 DataSource를 만들면 자동 구성이 중지됩니다."
"Spring Boot에서 JPA 속성을 구성하려면 어떻게 해야 하나요?","Spring Data JPA는 이미 몇 가지 벤더 독립적인 구성 옵션(예: SQL 로깅에 대한 옵션)을 제공하며, Spring Boot는 이러한 옵션과 Hibernate에 대한 몇 가지 옵션을 외부 구성 속성으로 노출합니다. 가장 일반적인 설정 옵션은 다음 예제에 나와 있습니다."
"Hibernate를 사용하여 데이터베이스를 초기화하는 방법은 무엇인가요?","spring.jpa.hibernate.ddl-auto를 설정하여 Hibernate의 데이터베이스 초기화를 제어할 수 있습니다. 지원되는 값은 none, validate, update, create, create-drop입니다. Spring Boot는 임베디드 데이터베이스를 사용하는지 여부에 따라 기본값을 선택합니다. 임베디드 데이터베이스에는 hsqldb, h2, derby가 포함됩니다. 임베디드 데이터베이스가 감지되고 스키마 관리자(Flyway 또는 Liquibase)가 감지되지 않으면 ddl-auto는 create-drop으로 기본 설정됩니다. 다른 모든 경우에는 none으로 기본 설정됩니다. 메모리 내 데이터베이스에서 '실제' 데이터베이스로 전환할 때 새로운 플랫폼에서 테이블 및 데이터의 존재에 대한 가정을 하지 않도록 주의하세요. ddl-auto를 명시적으로 설정하거나 다른 메커니즘 중 하나를 사용하여 데이터베이스를 초기화해야 합니다. org.hibernate.SQL 로그를 활성화하여 스키마 생성을 출력할 수 있습니다. 이는 디버그 모드를 활성화하면 자동으로 수행됩니다. 또한, Hibernate가 스키마를 처음부터 생성하는 경우(즉, ddl-auto 속성이 create 또는 create-drop으로 설정된 경우) classpath 루트에 import.sql이라는 파일이 실행됩니다."
"기본 SQL 스크립트를 사용하여 데이터베이스를 초기화하는 방법은 무엇인가요?","Spring Boot는 JDBC DataSource 또는 R2DBC ConnectionFactory의 스키마(DDL 스크립트)를 자동으로 생성하고 데이터를 초기화할 수 있습니다. 기본적으로 선택적:classpath*:schema.sql에서 스키마 스크립트를 로드하고 선택적:classpath*:data.sql에서 데이터 스크립트를 로드합니다. 이러한 스키마 및 데이터 스크립트의 위치는 각각 spring.sql.init.schema-locations 및 spring.sql.init.data-locations를 사용하여 사용자 지정할 수 있습니다. 선택적: 접두사는 파일이 없을 때도 애플리케이션이 시작되도록 합니다. 파일이 없을 때 애플리케이션 시작이 실패하도록 하려면 선택적: 접두사를 제거하세요. 또한, Spring Boot는 선택적:classpath*:schema-${platform}.sql 및 선택적:classpath*:data-${platform}.sql 파일(있는 경우)을 처리합니다. 여기서 ${platform}은 spring.sql.init.platform의 값입니다. 이를 통해 필요한 경우 데이터베이스별 스크립트로 전환할 수 있습니다. 예를 들어, 데이터베이스의 공급업체 이름(hsqldb, h2, oracle, mysql, postgresql 등)으로 설정할 수 있습니다. 기본적으로 SQL 데이터베이스 초기화는 임베디드 메모리 내 데이터베이스를 사용할 때만 수행됩니다. 데이터베이스 유형에 관계없이 항상 SQL 데이터베이스를 초기화하려면 spring.sql.init.mode를 always로 설정하세요. 마찬가지로, 초기화를 비활성화하려면 spring.sql.init.mode를 never로 설정하세요. 기본적으로 Spring Boot는 스크립트 기반 데이터베이스 초기화기의 fail-fast 기능을 활성화합니다. 즉, 스크립트가 예외를 발생시키면 애플리케이션 시작이 실패합니다. spring.sql.init.continue-on-error를 설정하여 해당 동작을 조정할 수 있습니다. 스크립트 기반 DataSource 초기화는 기본적으로 JPA EntityManagerFactory 빈이 생성되기 전에 수행됩니다. schema.sql은 JPA 관리 엔티티의 스키마를 생성하는 데 사용할 수 있고 data.sql은 이를 채우는 데 사용할 수 있습니다. 여러 데이터 소스 초기화 기술을 사용하는 것은 권장하지 않지만, Hibernate에서 수행한 스키마 생성을 기반으로 스크립트 기반 DataSource 초기화를 사용하려면 spring.jpa.defer-datasource-initialization을 true로 설정하세요. 이렇게 하면 EntityManagerFactory 빈이 생성되고 초기화된 후에 데이터 소스 초기화가 지연됩니다. schema.sql은 Hibernate에서 수행한 스키마 생성에 추가할 수 있고 data.sql은 이를 채우는 데 사용할 수 있습니다. 초기화 스크립트는 단일 줄 주석에 --을 지원하고 블록 주석에 /* */를 지원합니다. 다른 주석 형식은 지원되지 않습니다. Flyway 또는 Liquibase와 같은 상위 레벨 데이터베이스 마이그레이션 도구(#howto.data-initialization.migration-tool)를 사용하는 경우 스키마를 만들고 초기화하는 데 해당 도구만 사용해야 합니다. Flyway 또는 Liquibase와 함께 기본 schema.sql 및 data.sql 스크립트를 사용하는 것은 권장하지 않으며 향후 릴리스에서 지원이 제거됩니다. 상위 레벨 데이터베이스 마이그레이션 도구를 사용하여 테스트 데이터를 초기화해야 하는 경우 Flyway(#howto.data-initialization.migration-tool.flyway-tests) 및 Liquibase(#howto.data-initialization.migration-tool.liquibase-tests)에 대한 섹션을 참조하세요."
"임베디드 데이터베이스와 비임베디드 데이터베이스란 무엇인가요?","임베디드 데이터베이스는 Spring Boot 애플리케이션에 내장되어 실행되는 경량 데이터베이스입니다. 임베디드 데이터베이스는 개발 및 테스트 환경에서 유용하며 별도의 데이터베이스 서버를 설정할 필요가 없습니다. 임베디드 데이터베이스로는 HSQLDB, H2, Derby 등이 있습니다. 비임베디드 데이터베이스는 애플리케이션과 분리된 독립적인 데이터베이스 서버입니다. 비임베디드 데이터베이스 서버로는 MySQL, PostgreSQL, Oracle 등이 있습니다. Spring Boot는 임베디드 데이터베이스와 비임베디드 데이터베이스를 모두 지원하며, 사용 사례에 따라 적절한 데이터베이스를 선택할 수 있습니다."
"스프링 부트에서 NoSQL을 사용하는 방법은 무엇인가요?","스프링 부트는 NoSQL 기술을 지원하는 여러 스타터를 제공합니다. 이 섹션에서는 NoSQL을 스프링 부트와 함께 사용할 때 발생하는 질문에 대한 답변을 제공합니다. (출처: https://docs.spring.io/spring-boot/how-to/nosql.html)"
"스프링 부트에서 Lettuce 대신 Jedis를 사용하려면 어떻게 해야 하나요?","기본적으로 스프링 부트 스타터(spring-boot-starter-data-redis)는 Lettuce(https://github.com/lettuce-io/lettuce-core/)를 사용합니다. 해당 종속성을 제외하고 Jedis(https://github.com/xetorthio/jedis/)를 포함해야 합니다. 스프링 부트는 이 두 종속성을 모두 관리하므로 버전을 지정하지 않고도 Jedis로 전환할 수 있습니다. 다음은 Maven에서 이를 수행하는 방법을 보여주는 예시입니다: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> <exclusions> <exclusion> <groupId>io.lettuce</groupId> <artifactId>lettuce-core</artifactId> </exclusion> </exclusions> </dependency> <dependency> <groupId>redis.clients</groupId> <artifactId>jedis</artifactId> </dependency> 다음은 Gradle에서 이를 수행하는 방법을 보여주는 예시입니다: dependencies { implementation('org.springframework.boot:spring-boot-starter-data-redis') { exclude group: 'io.lettuce', module: 'lettuce-core' } implementation 'redis.clients:jedis' // ... }"
"스프링 부트에서 Lettuce 대신 Jedis를 사용하는 방법은 무엇인가요?","기본적으로 스프링 부트 스타터(spring-boot-starter-data-redis)는 Lettuce(https://github.com/lettuce-io/lettuce-core/)를 사용합니다. 해당 종속성을 제외하고 Jedis(https://github.com/xetorthio/jedis/)를 포함해야 합니다. 스프링 부트는 이 두 종속성을 모두 관리하므로 버전을 지정하지 않고도 Jedis로 전환할 수 있습니다. 다음은 Maven에서 이를 수행하는 방법을 보여주는 예시입니다: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> <exclusions> <exclusion> <groupId>io.lettuce</groupId> <artifactId>lettuce-core</artifactId> </exclusion> </exclusions> </dependency> <dependency> <groupId>redis.clients</groupId> <artifactId>jedis</artifactId> </dependency> 다음은 Gradle에서 이를 수행하는 방법을 보여주는 예시입니다: dependencies { implementation('org.springframework.boot:spring-boot-starter-data-redis') { exclude group: 'io.lettuce', module: 'lettuce-core' } implementation 'redis.clients:jedis' // ... }"
"Spring Boot에서 메시징을 지원하기 위해 어떤 스타터를 제공하나요?","Spring Boot는 메시징을 지원하기 위해 다양한 스타터를 제공합니다. 이 섹션에서는 Spring Boot에서 메시징을 사용할 때 발생하는 질문에 대한 답변을 제공합니다. (출처: https://docs.spring.io/spring-boot/how-to/messaging.html)"
"JMS 브로커가 트랜잭션 세션을 지원하지 않을 때 어떻게 해야 하나요?","JMS 브로커가 트랜잭션 세션을 지원하지 않을 경우, 트랜잭션 지원을 완전히 비활성화해야 합니다. DefaultJmsListenerContainerFactory를 사용하려면 Spring Boot의 기본 설정을 재사용하기 위해 DefaultJmsListenerContainerFactoryConfigurer를 사용할 수 있습니다. 트랜잭션 관리자를 null로 설정하고 세션 트랜잭션을 false로 설정하여 트랜잭션 세션을 비활성화할 수 있습니다. (출처: https://docs.spring.io/spring-boot/how-to/messaging.html)"
"JMS 브로커가 트랜잭션 세션을 지원하지 않을 때 DefaultJmsListenerContainerFactoryConfigurer를 사용하여 트랜잭션 세션을 비활성화하는 방법은 무엇인가요?","JMS 브로커가 트랜잭션 세션을 지원하지 않을 때 DefaultJmsListenerContainerFactoryConfigurer를 사용하여 트랜잭션 세션을 비활성화하려면, DefaultJmsListenerContainerFactoryConfigurer를 가져오고, DefaultJmsListenerContainerFactory를 빈으로 생성한 후, 구성 객체를 사용하여 DefaultJmsListenerContainerFactory를 구성하고, 트랜잭션 관리자를 null로 설정하고 세션 트랜잭션을 false로 설정하면 됩니다. (출처: https://docs.spring.io/spring-boot/how-to/messaging.html)"
"스프링 배치에서 배치 애플리케이션은 기본적으로 어떤 데이터 소스를 사용하나요?","기본적으로 배치 애플리케이션은 작업 세부 정보를 저장하기 위해 DataSource를 필요로 합니다. 스프링 배치는 기본적으로 단일 DataSource를 기대합니다."
"스프링 배치에서 배치 전용 PlatformTransactionManager를 지정하는 방법은 무엇인가요?","배치 처리에서 사용할 PlatformTransactionManager를 지정하려면 @BatchTransactionManager로 표시하면 됩니다."
"스프링 배치에서 중지되거나 실패한 작업을 다시 시작하려면 어떻게 해야 하나요?","실패한 작업을 다시 시작하려면 모든 매개변수(식별 및 비식별)를 명령줄에 다시 지정해야 합니다."
"스프링 부트 액추어의 디폴트 HTTP 포트는 무엇인가요?","스프링 부트 액추어의 디폴트 HTTP 포트는 메인 HTTP 포트와 동일합니다. (출처: https://docs.spring.io/spring-boot/how-to/actuator.html)"
"액추어 엔드포인트의 HTTP 포트 또는 주소를 변경하려면 어떻게 해야 하나요?","액추어 HTTP 포트를 변경하려면 management.server.port 외부 속성을 설정하십시오. 완전히 다른 네트워크 주소에서 수신 대기하려면 management.server.address를 유효한 IP 주소로 설정할 수 있습니다. (출처: https://docs.spring.io/spring-boot/how-to/actuator.html)"
"스프링 부트 액추어의 화이트레이블 오류 페이지를 사용자 지정하는 방법은 무엇인가요?","스프링 부트에서 제공하는 화이트레이블 오류 페이지를 사용자 지정하려면 server.error.whitelabel.enabled=false를 설정하고 자체 오류 페이지를 추가해야 합니다. 오류 페이지를 사용자 지정하는 방법은 사용하는 템플릿 기술에 따라 다릅니다. (출처: https://docs.spring.io/spring-boot/how-to/actuator.html)"
"스프링 부트에서 스프링 시큐리티를 사용할 때 어떤 보안 관련 질문들을 다루나요?","스프링 부트에서 스프링 시큐리티를 사용할 때 보안 관련 질문들은 스프링 부트에서 제공하는 보안 구성, 사용자 세부 정보 서비스 변경, HTTPS 활성화 등과 같은 내용들을 다룹니다. (출처: https://docs.spring.io/spring-boot/how-to/security.html)"
"스프링 부트에서 기본 웹앱 보안 설정을 비활성화하는 방법은 무엇인가요?","스프링 부트에서 기본 웹앱 보안 설정을 비활성화하려면 애플리케이션에서 SecurityFilterChain 빈을 가진 @Configuration을 정의하면 됩니다. 이렇게 하면 기본 보안 설정이 꺼집니다. (출처: https://docs.spring.io/spring-boot/how-to/security.html)"
"스프링 시큐리티의 다양한 인증 옵션에는 어떤 것들이 있나요?","스프링 시큐리티의 다양한 인증 옵션에는 인증 매니저 빈, 인증 공급자 빈, 사용자 세부 정보 서비스 빈 등이 있습니다. (출처: https://docs.spring.io/spring-boot/how-to/security.html)"
"Spring Boot에서 핫 스왑을 지원하는지 여부","Spring Boot는 핫 스왑을 지원합니다. (출처: https://docs.spring.io/spring-boot/how-to/hotswapping.html)"
"Spring Boot에서 정적 콘텐츠를 핫 리로딩하는 방법","정적 콘텐츠를 핫 리로딩하는 가장 권장되는 방법은 spring-boot-devtools를 사용하는 것이며, 이는 빠른 애플리케이션 재시작 및 LiveReload를 지원하며, 템플릿 캐싱과 같은 일부 개발 시간 구성을 비활성화합니다. (출처: https://docs.spring.io/spring-boot/how-to/hotswapping.html)"
"Spring Boot에서 컨테이너를 다시 시작하지 않고 템플릿을 다시 로드하는 방법","Spring Boot에서 지원하는 대부분의 템플릿 기술에는 이 문서의 후반부에서 설명하는 캐싱을 비활성화하는 구성 옵션이 포함되어 있습니다. spring-boot-devtools 모듈을 사용하는 경우, 이러한 속성은 개발 시간에 자동으로 구성됩니다. (출처: https://docs.spring.io/spring-boot/how-to/hotswapping.html)"
"스프링 부트에서 테스트를 위해 어떤 지원 클래스와 유틸리티를 제공하나요?","스프링 부트는 여러 테스트 유틸리티와 지원 클래스, 그리고 일반적인 테스트 의존성을 제공하는 전용 스타터를 제공합니다. (출처: https://docs.spring.io/spring-boot/how-to/testing.html)"
"스프링 시큐리티는 테스트 중 특정 사용자로 실행하기 위해 어떤 지원을 제공하나요?","스프링 시큐리티는 테스트 중 특정 사용자로 실행하기 위한 지원을 제공합니다. 예를 들어, 아래 스니펫의 테스트는 ADMIN 역할을 가진 인증된 사용자로 실행됩니다. (출처: https://docs.spring.io/spring-boot/how-to/testing.html)"
"여러 개의 @Configuration 클래스를 가지는 경우, 슬라이스 테스트에서 특정 구성만 포함하려면 어떻게 해야 하나요?","여러 개의 @Configuration 클래스를 가지는 경우, 특정 구성만 포함하려면 테스트 클래스에 @Import(MyConfiguration.class) 어노테이션을 추가하여 구성을 명시적으로 포함할 수 있습니다. 이렇게 하면 웹 계층을 테스트할 때 필요하지 않은 BasicDataSource 빈을 포함하여 MyConfiguration의 모든 빈이 로드됩니다. 구성을 여러 개로 분할하면 특정 보안 구성만 가져올 수 있습니다. (출처: https://docs.spring.io/spring-boot/how-to/testing.html)"
"Spring Boot의 빌드 플러그인은 Maven과 Gradle에서 어떻게 사용되나요?","Spring Boot는 Maven과 Gradle에서 빌드 플러그인을 포함하고 있습니다. 이 섹션에서는 이러한 플러그인에 대한 일반적인 질문에 대한 답변을 제공합니다. 빌드 정보는 Maven 플러그인과 Gradle 플러그인 모두에서 프로젝트의 조정, 이름 및 버전을 포함하는 빌드 정보를 생성할 수 있습니다. 플러그인은 또한 구성을 통해 추가 속성을 추가하도록 구성할 수 있습니다. 이러한 파일이 있으면 Spring Boot는 BuildProperties 빈을 자동으로 구성합니다. Maven으로 빌드 정보를 생성하려면 다음 예제와 같이 build-info 목표에 대한 실행을 추가하십시오."
"Maven과 Gradle에서 git.properties 파일을 생성하는 방법은 무엇인가요?","Maven과 Gradle 모두 프로젝트가 빌드될 때 git 소스 코드 저장소의 상태에 대한 정보를 포함하는 git.properties 파일을 생성할 수 있습니다. Maven 사용자의 경우 spring-boot-starter-parent POM에는 git.properties 파일을 생성하기 위한 사전 구성된 플러그인이 포함되어 있습니다. 이를 사용하려면 POM에 Git Commit Id Plugin(https://github.com/git-commit-id/git-commit-id-maven-plugin)에 대한 다음 선언을 추가하십시오. Gradle 사용자는 다음 예제와 같이 gradle-git-properties(https://plugins.gradle.org/plugin/com.gorylenko.gradle-git-properties) 플러그인을 사용하여 동일한 결과를 얻을 수 있습니다. Maven 및 Gradle 플러그인 모두에서 git.properties에 포함되는 속성을 구성할 수 있습니다. git.properties의 커밋 시간은 다음 형식과 일치해야 합니다: yyyy-MM-dd’T’HH:mm:ssZ. 이것은 위에 나열된 두 플러그인의 기본 형식입니다."
"Spring Boot의 Maven 및 Gradle 플러그인을 사용하여 관리되는 종속성 버전을 사용자 지정하는 방법은 무엇인가요?","spring-boot-dependencies POM은 일반적인 종속성의 버전을 관리합니다. Maven 및 Gradle용 Spring Boot 플러그인을 사용하면 이러한 관리되는 종속성 버전을 빌드 속성을 사용하여 사용자 지정할 수 있습니다. 각 Spring Boot 릴리스는 이 특정 타사 종속성 집합에 대해 설계되고 테스트됩니다. 버전을 재정의하면 호환성 문제가 발생할 수 있습니다. Maven에서 종속성 버전을 재정의하려면 Maven 플러그인 문서의 플러그인 사용(../maven-plugin/using.html)을 참조하십시오. Gradle에서 종속성 버전을 재정의하려면 Gradle 플러그인 문서의 관리되는 버전 사용자 지정(../gradle-plugin/managing-dependencies.html#managing-dependencies.dependency-management-plugin.customizing)을 참조하십시오."
"Spring Boot 애플리케이션의 Ahead-of-Time 처리란 무엇이며, 어떤 상황에서 사용되나요?","Spring Boot 애플리케이션의 Ahead-of-Time 처리는 애플리케이션의 빌드 시간에 조건(@Conditional) 어노테이션을 평가하여 애플리케이션을 최적화하는 방법입니다. 이는 프로파일(https://docs.spring.io/spring-boot/how-to/profiles)에도 영향을 미치며, 빌드 시간에 설정된 프로파일은 Ahead-of-Time 최적화된 애플리케이션에서 사용할 수 있습니다. Spring Boot 애플리케이션의 Ahead-of-Time 처리를 위해 Maven에서는 `spring-boot-maven-plugin`의 `process-aot` 실행에 대한 프로파일을 설정하고, Gradle에서는 `ProcessAot` 작업을 구성합니다. 조건(@Conditional)에 영향을 주지 않는 구성 속성만 변경하는 프로파일은 Ahead-of-Time 처리된 애플리케이션을 실행할 때 제한 없이 지원됩니다. 출처: https://docs.spring.io/spring-boot/how-to/aot.html"
"Spring Boot 애플리케이션의 Ahead-of-Time 처리에서 조건이 어떻게 활용되나요?","Spring Boot 애플리케이션의 Ahead-of-Time 처리에서 @Conditional 어노테이션은 빌드 시간에 환경에 따라 평가되어 애플리케이션이 최적화됩니다. 프로파일은 조건을 통해 구현되므로, 빌드 시간에 설정된 프로파일은 Ahead-of-Time 최적화된 애플리케이션에서 사용할 수 있습니다. 출처: https://docs.spring.io/spring-boot/how-to/aot.html"
"Spring Boot 애플리케이션의 Ahead-of-Time 처리에서 조건에 따라 생성된 빈은 어떻게 동작하나요?","Spring Boot 애플리케이션의 Ahead-of-Time 처리에서 빌드 시간에 Ahead-of-Time 처리로 생성된 빈은 애플리케이션을 실행할 때 항상 생성되며, 끌 수 없습니다. 출처: https://docs.spring.io/spring-boot/how-to/aot.html"
"Spring Boot 애플리케이션을 GraalVM 네이티브 이미지로 테스트하는 방법은 무엇인가요?","GraalVM 네이티브 이미지 개발에 대한 자세한 내용은 GraalVM 네이티브 이미지 세부 정보 섹션을 참조하십시오. GraalVM 네이티브 이미지 개념에 대한 개요는 GraalVM 네이티브 이미지 소개 섹션을 참조하십시오. (출처: https://docs.spring.io/spring-boot/how-to/native-image/index.html)"
"Spring Boot 애플리케이션의 네이티브 이미지에 대한 개요를 어디에서 찾을 수 있나요?","Spring Boot 애플리케이션의 네이티브 이미지에 대한 개요를 찾으시려면 GraalVM 네이티브 이미지 소개 섹션을 참조하십시오. (출처: https://docs.spring.io/spring-boot/how-to/native-image/index.html)"
"Spring Boot 네이티브 이미지 개발에 대한 문서를 어디에서 찾을 수 있나요?","Spring Boot 네이티브 이미지 개발에 대한 자세한 내용은 GraalVM 네이티브 애플리케이션 섹션을 참조하십시오. (출처: https://docs.spring.io/spring-boot/how-to/native-image/index.html)"
"스프링 부트 네이티브 이미지 애플리케이션을 빌드하는 두 가지 주요 방법은 무엇인가요?","스프링 부트 네이티브 이미지 애플리케이션을 빌드하는 두 가지 주요 방법은 Cloud Native Buildpacks를 사용하는 Spring Boot 지원을 통한 Paketo Java Native Image 빌드팩을 사용하여 경량 컨테이너를 생성하는 것과 GraalVM Native Build Tools를 사용하여 네이티브 실행 파일을 생성하는 것입니다."
"새로운 네이티브 스프링 부트 프로젝트를 시작하는 가장 쉬운 방법은 무엇인가요?","새로운 네이티브 스프링 부트 프로젝트를 시작하는 가장 쉬운 방법은 start.spring.io로 이동하여 GraalVM Native Support 종속성을 추가하고 프로젝트를 생성하는 것입니다. 포함된 HELP.md 파일에는 시작 힌트가 제공됩니다."
"네이티브 이미지를 만들기 위해 샘플 애플리케이션으로 사용할 수 있는 간단한 'Hello World!' 웹 애플리케이션의 코드는 무엇인가요?","네이티브 이미지를 만들기 위해 샘플 애플리케이션으로 사용할 수 있는 간단한 'Hello World!' 웹 애플리케이션의 코드는 다음과 같습니다: import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @SpringBootApplication public class MyApplication { @RequestMapping('/') String home() { return 'Hello World!'; } public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } }"
"Spring Boot 애플리케이션에서 AOT 생성 코드를 JVM에서 실행하는 방법은 무엇인가요?","Spring Boot 애플리케이션을 JVM에서 실행하고 AOT 생성 코드를 사용하려면 spring.aot.enabled 시스템 속성을 true로 설정해야 합니다. 예를 들어: $ java -Dspring.aot.enabled=true -jar myapplication.jar 테스트하는 jar에는 AOT 생성 코드가 포함되어 있어야 합니다. Maven의 경우, -Pnative로 빌드하여 native 프로필을 활성화해야 합니다. Gradle의 경우, 빌드에 org.graalvm.buildtools.native 플러그인이 포함되어 있는지 확인해야 합니다. spring.aot.enabled 속성으로 애플리케이션을 시작하면 네이티브 이미지로 변환될 때 작동할 가능성이 높아집니다. 실행 중인 애플리케이션에 대해 통합 테스트를 실행하는 것도 고려해 볼 수 있습니다. 예를 들어, Spring WebClient를 사용하여 애플리케이션 REST 엔드포인트를 호출하거나 Selenium과 같은 프로젝트를 사용하여 애플리케이션의 HTML 응답을 확인할 수 있습니다. (출처: https://docs.spring.io/spring-boot/how-to/native-image/testing-native-applications.html)"
"GraalVM Native Build Tools를 사용하여 네이티브 이미지에서 테스트를 실행하는 방법은 무엇인가요?","GraalVM Native Build Tools는 네이티브 이미지 내에서 테스트를 실행하는 기능을 포함하고 있습니다. 네이티브 이미지에서 애플리케이션의 내부 작동 방식을 깊이 테스트하려는 경우 도움이 될 수 있습니다. 실행할 테스트를 포함하는 네이티브 이미지를 생성하는 것은 시간이 많이 소요될 수 있으므로 대부분의 개발자는 로컬에서 JVM을 사용하는 것을 선호할 것입니다. 그러나 CI 파이프라인의 일부로 매우 유용할 수 있습니다. 예를 들어, 하루에 한 번 네이티브 테스트를 실행하도록 선택할 수 있습니다. Spring Framework는 테스트를 실행하기 위한 ahead-of-time 지원을 포함합니다. 일반적인 Spring 테스트 기능은 네이티브 이미지 테스트와 함께 작동합니다. 예를 들어, @SpringBootTest 어노테이션을 계속 사용할 수 있습니다. 또한 Spring Boot 테스트 슬라이스를 사용하여 애플리케이션의 특정 부분만 테스트할 수 있습니다. Spring Framework의 네이티브 테스트 지원은 다음과 같이 작동합니다. 테스트는 필요한 모든 ApplicationContext 인스턴스를 발견하기 위해 분석됩니다. 각 애플리케이션 컨텍스트에 대해 ahead-of-time 처리가 적용되고 자산이 생성됩니다. GraalVM에서 생성된 자산을 처리하여 네이티브 이미지가 생성됩니다. 네이티브 이미지에는 발견된 테스트 목록으로 구성된 JUnit TestEngine도 포함됩니다. 네이티브 이미지가 시작되고 엔진이 트리거되어 각 테스트를 실행하고 결과를 보고합니다. (출처: https://docs.spring.io/spring-boot/how-to/native-image/testing-native-applications.html)"
"네이티브 이미지 테스트를 실행하기 위해 Maven 구성 파일에 필요한 최소 요소는 무엇인가요?","네이티브 이미지 테스트를 실행하기 위해 Maven 구성 파일(pom.xml)에는 spring-boot-starter-parent가 선언되어야 합니다. <parent> 섹션에는 다음과 같은 내용이 포함되어야 합니다. <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>3.3.4</version> </parent> spring-boot-starter-parent는 네이티브 테스트를 실행하는 데 필요한 실행을 구성하는 nativeTest 프로필을 선언합니다. 명령줄에서 -P 플래그를 사용하여 프로필을 활성화할 수 있습니다. spring-boot-starter-parent를 사용하지 않으려면 Spring Boot 플러그인의 process-test-aot 목표와 Native Build Tools 플러그인의 test 목표에 대한 실행을 구성해야 합니다. 이미지를 빌드하고 테스트를 실행하려면 nativeTest 프로필이 활성화된 test 목표를 사용하세요. $ mvn -PnativeTest test (출처: https://docs.spring.io/spring-boot/how-to/native-image/testing-native-applications.html)"
"Spring Boot 애플리케이션에서 Class Data Sharing(CDS)를 사용하는 방법은 무엇인가요?","Spring Boot의 Class Data Sharing(CDS)에 대한 개요는 https://docs.spring.io/spring-boot/how-to/class-data-sharing.html에서 확인할 수 있습니다."
"Cloud Native Buildpacks와 Paketo Java buildpack을 사용하여 CDS 최적화된 Spring Boot 애플리케이션을 Docker 이미지로 패키징하는 방법은 무엇인가요?","Spring Boot 애플리케이션에 대한 Paketo Buildpacks 지원은 https://docs.spring.io/spring-boot/how-to/class-data-sharing.html에서 확인할 수 있습니다."
"Dockerfile을 사용하여 CDS를 사용하여 Spring Boot 애플리케이션을 패키징하는 방법은 무엇인가요?","Dockerfile을 사용하여 CDS를 사용하여 Spring Boot 애플리케이션을 패키징하는 방법에 대한 자세한 내용은 https://docs.spring.io/spring-boot/how-to/class-data-sharing.html에서 확인할 수 있습니다."
"스프링 부트 애플리케이션은 어떤 종류의 배포 옵션을 가지고 있나요?","스프링 부트 애플리케이션은 다양한 배포 옵션을 가지고 있습니다. 이는 클라우드 플랫폼, 가상/실제 머신 또는 유닉스 시스템에서 완전히 실행 가능한 애플리케이션으로 배포할 수 있습니다. (출처: https://docs.spring.io/spring-boot/how-to/deployment/index.html)"
"스프링 부트 애플리케이션의 일반적인 배포 시나리오는 어떤 것이 있나요?","스프링 부트 애플리케이션의 일반적인 배포 시나리오에는 클라우드 플랫폼, 가상/실제 머신 또는 유닉스 시스템에서 완전히 실행 가능한 애플리케이션으로 배포하는 것이 포함됩니다. (출처: https://docs.spring.io/spring-boot/how-to/deployment/index.html)"
"스프링 부트에서 제공하는 유연한 패키징 옵션은 어떤 상황에서 유용할까요?","스프링 부트에서 제공하는 유연한 패키징 옵션은 애플리케이션을 배포할 때 많은 선택지를 제공합니다. 이를 통해 다양한 클라우드 플랫폼, 가상/실제 머신 또는 유닉스 시스템에서 애플리케이션을 배포할 수 있습니다. (출처: https://docs.spring.io/spring-boot/how-to/deployment/index.html)"
"Spring Boot의 실행 가능한 jar를 클라우드에 배포하려면 어떤 클라우드 PaaS 제공업체를 사용할 수 있나요?","대부분의 인기 있는 클라우드 PaaS(Platform-as-a-Service) 제공업체를 사용할 수 있습니다. (출처: <https://docs.spring.io/spring-boot/how-to/deployment/cloud.html>)"
"Heroku에서 Spring Boot 애플리케이션을 배포하려면 어떤 구성이 필요한가요?","Procfile을 제공하여 애플리케이션 배포에 필요한 주문을 제공해야 합니다. 또한, 애플리케이션이 올바른 포트에서 수신하도록 구성해야 합니다. (출처: <https://docs.spring.io/spring-boot/how-to/deployment/cloud.html>)"
"Spring Cloud Foundry에서 VCAP 환경 변수에 어떻게 액세스할 수 있나요?","Spring Cloud Foundry는 VCAP 환경 변수를 애플리케이션 정보와 서비스 정보를 액세스하기 위한 속성으로 자동으로 추출하고 평탄화합니다. (출처: <https://docs.spring.io/spring-boot/how-to/deployment/cloud.html>)"
"Spring Boot 애플리케이션을 systemd 서비스로 설치하는 방법은 무엇인가요?","systemd 서비스 스크립트(예: myapp.service)를 생성하여 /etc/systemd/system 디렉토리에 배치하고, Description, User, Group, Environment 및 ExecStart 필드를 애플리케이션에 맞게 변경해야 합니다. systemctl enable myapp.service 명령어를 사용하여 시스템 부팅 시 자동으로 시작하도록 표시할 수 있습니다."
"Spring Boot 애플리케이션을 fully executable jar로 패키징하는 방법은 무엇인가요?","Maven을 사용하여 'spring-boot-maven-plugin'의 'executable' 옵션을 true로 설정하거나, Gradle을 사용하여 'launchScript()' 메서드를 사용하면 됩니다. 이렇게 패키징된 jar 파일은 init.d로 심볼릭 링크하여 표준 start, stop, restart 및 status 명령을 지원합니다."
"init.d 서비스로 실행되는 Spring Boot 애플리케이션을 안전하게 보호하기 위한 방법은 무엇인가요?","애플리케이션을 root로 실행하지 않고, 애플리케이션을 실행할 특정 사용자를 생성하고, jar 파일의 소유자를 해당 사용자로 변경하고, jar 파일의 권한을 설정하여 쓰기 권한을 제거하고, jar 파일의 수정을 방지하기 위해 jar 파일을 불변으로 만드는 등의 방법을 사용할 수 있습니다."
"스프링 부트에서 메이븐과 그라들 빌드 도구에 대한 플러그인을 제공하는 이유는 무엇인가요?","스프링 부트는 메이븐과 그라들 빌드 도구에 대한 플러그인을 제공하여 실행 가능한 jar 패키징을 비롯한 다양한 기능을 제공합니다. 이는 빌드 프로세스를 간소화하고 개발자가 빠르고 쉽게 애플리케이션을 패키징하고 배포할 수 있도록 도와줍니다. (출처: https://docs.spring.io/spring-boot/build-tool-plugin/index.html)"
"스프링 부트의 빌드 도구 플러그인을 사용하면 어떤 기능을 사용할 수 있나요?","스프링 부트의 빌드 도구 플러그인을 사용하면 실행 가능한 jar 패키징, 애플리케이션의 실행 및 빌드 프로세스의 자동화 등 다양한 기능을 사용할 수 있습니다. 이를 통해 개발자는 번거로운 빌드 프로세스를 간소화하고 빠르게 애플리케이션을 구축할 수 있습니다. (출처: https://docs.spring.io/spring-boot/build-tool-plugin/index.html)"
"스프링 부트에서 지원되지 않는 빌드 시스템을 확장하려면 어떻게 해야 하나요?","스프링 부트에서 지원되지 않는 빌드 시스템을 확장하려면 해당 문서의 도움을 참조할 수 있습니다. 해당 문서는 지원되지 않는 빌드 시스템을 확장하는 데 필요한 지침을 제공합니다. (출처: https://docs.spring.io/spring-boot/build-tool-plugin/index.html)"
"Spring Boot Maven Plugin은 어떤 기능을 제공하나요?","Spring Boot Maven Plugin은 Apache Maven에서 Spring Boot 지원을 제공하며, 실행 가능한 jar 또는 war 아카이브를 패키징하고, Spring Boot 애플리케이션을 실행하며, 빌드 정보를 생성하고, 통합 테스트를 실행하기 전에 Spring Boot 애플리케이션을 시작할 수 있습니다. (출처: https://docs.spring.io/spring-boot/maven-plugin/index.html)"
"Spring Boot Maven Plugin을 사용하려면 어떤 버전의 Maven이 필요한가요?","Maven 3.6.3 이상이 필요합니다. (출처: https://docs.spring.io/spring-boot/maven-plugin/index.html)"
"Spring Boot Maven Plugin에 대한 추가 문서를 어디에서 찾을 수 있나요?","API 문서(api/java/index.html)를 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/maven-plugin/index.html)"
"Maven에서 spring-boot-starter-parent 프로젝트에서 상속을 받으면 어떤 기능을 얻을 수 있나요?","Java 17을 기본 컴파일러 레벨로 설정하고, UTF-8 소스 인코딩, -parameters로 컴파일, spring-boot-dependencies POM에서 상속받은 의존성 관리 섹션, repackage 목표의 실행, Native 이미지 생성을 위한 빌드 구성을 위한 native 프로필, sensible resource filtering, sensible plugin configuration, application.properties 및 application.yml에 대한 sensible resource filtering, maven.compiler.release 및 maven.compiler.source 및 maven.compiler.target 속성, Maven에서 상속을 구성하는 방법, parent POM을 상속받지 않고 Spring Boot를 사용하는 방법, 명령줄에서 설정을 재정의하는 방법 등의 기능을 얻을 수 있습니다."
"Spring Boot의 어떤 버전에서 resource filtering이 변경되어 application.properties 및 application.yml 파일에 @..@ 플레이스홀더를 사용하게 되었나요?","Spring Boot 2.0 버전부터 resource filtering이 변경되어 application.properties 및 application.yml 파일에 @..@ 플레이스홀더를 사용하게 되었습니다.(원본 출처: https://docs.spring.io/spring-boot/maven-plugin/using.html)"
"Maven에서 spring-boot-starter-parent POM을 상속받지 않고 Spring Boot의 의존성 관리를 사용하려면 어떻게 해야 하나요?","Maven에서 spring-boot-starter-parent POM을 상속받지 않고 Spring Boot의 의존성 관리를 사용하려면 다음과 같이 import scope의 의존성을 사용하면 됩니다:<dependencyManagement><dependencies><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-dependencies</artifactId><version>3.3.4</version><type>pom</type><scope>import</scope></dependency></dependencies></dependencyManagement> 단, 이 경우 속성을 사용하여 개별 의존성을 재정의할 수는 없습니다. 동일한 결과를 얻으려면 spring-boot-dependencies 항목 이전에 프로젝트의 dependencyManagement 섹션에 항목을 추가해야 합니다. 예를 들어, 다음과 같이 pom.xml에 다음 요소를 추가하여 SLF4J 라이브러리의 다른 버전과 Spring Data 릴리스 트레인을 사용할 수 있습니다. <dependencyManagement><dependencies><!-- Spring Boot에서 제공하는 SLF4J를 재정의합니다. --> <dependency><groupId>org.slf4j</groupId><artifactId>slf4j-api</artifactId><version>1.7.30</version></dependency><!-- Spring Boot에서 제공하는 Spring Data 릴리스 트레인을 재정의합니다. --> <dependency><groupId>org.springframework.data</groupId><artifactId>spring-data-releasetrain</artifactId><version>2020.0.0-SR1</version><type>pom</type><scope>import</scope></dependency><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-dependencies</artifactId><version>3.3.4</version><type>pom</type><scope>import</scope></dependency></dependencies></dependencyManagement> 동일한 결과를 얻으려면 spring-boot-dependencies 항목 이전에 프로젝트의 dependencyManagement 섹션에 항목을 추가해야 합니다. 예를 들어, 다음과 같이 pom.xml에 다음 요소를 추가하여 SLF4J 라이브러리의 다른 버전과 Spring Data 릴리스 트레인을 사용할 수 있습니다. <dependencyManagement><dependencies><!-- Spring Boot에서 제공하는 SLF4J를 재정의합니다. --> <dependency><groupId>org.slf4j</groupId><artifactId>slf4j-api</artifactId><version>1.7.30</version></dependency><!-- Spring Boot에서 제공하는 Spring Data 릴리스 트레인을 재정의합니다. --> <dependency><groupId>org.springframework.data</groupId><artifactId>spring-data-releasetrain</artifactId><version>2020.0.0-SR1</version><type>pom</type><scope>import</scope></dependency><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-dependencies</artifactId><version>3.3.4</version><type>pom</type><scope>import</scope></dependency></dependencies></dependencyManagement>"
"스프링 부트 플러그인의 목표 중 하나인 'spring-boot:build-image'는 어떤 역할을 하나요?","이 목표는 빌드팩을 사용하여 애플리케이션을 OCI 이미지로 패키징하고, 패키지가 실행되도록 라이프사이클을 포크합니다. (출처: https://docs.spring.io/spring-boot/maven-plugin/goals.html)"
"스프링 부트 플러그인의 목표 중 하나인 'spring-boot:repackage'는 어떤 역할을 하나요?","이 목표는 기존 JAR 및 WAR 아카이브를 다시 패키징하여 java -jar를 사용하여 명령줄에서 실행할 수 있도록 합니다. (출처: https://docs.spring.io/spring-boot/maven-plugin/goals.html)"
"스프링 부트 플러그인의 목표 중 하나인 'spring-boot:test-run'은 어떤 역할을 하나요?","이 목표는 테스트 런타임 클래스패스를 사용하여 애플리케이션을 인플레이스로 실행합니다. (출처: https://docs.spring.io/spring-boot/maven-plugin/goals.html)"
"스프링 부트 Maven 플러그인을 사용하여 OCI 이미지를 패키징하는 방법은 무엇인가요?","스프링 부트 Maven 플러그인은 Cloud Native Buildpacks(CNB)를 사용하여 jar 또는 war 파일에서 OCI 이미지를 생성할 수 있습니다. 이미지는 명령줄에서 build-image 목표를 사용하여 빌드할 수 있습니다. 이 과정은 패키지 수명주기가 실행된 후 이미지를 생성합니다. 보안상의 이유로, 이미지는 비루트 사용자로 빌드되고 실행됩니다. 자세한 내용은 CNB 스펙(https://buildpacks.io/docs/reference/spec/platform-api/#users)을 참조하십시오. 시작하기 가장 쉬운 방법은 프로젝트에서 mvn spring-boot:build-image를 호출하는 것입니다. 패키지 단계가 호출될 때마다 이미지를 자동으로 생성하도록 구성할 수 있습니다. 이 경우 build-image-no-fork 목표를 사용하세요. 이 목표는 build-image와 유사하지만 package가 실행되도록 라이프사이클을 분리하지 않습니다. 나머지 섹션에서는 build-image가 build-image 또는 build-image-no-fork 목표를 가리키는 데 사용됩니다."
"스프링 부트 Maven 플러그인이 빌드팩을 실행하는 데 사용하는 기본 빌더 이미지는 무엇인가요?","스프링 부트 Maven 플러그인은 기본적으로 paketobuildpacks/builder-jammy-base:latest라는 빌더 이미지를 선택합니다. 이 이미지는 빌드팩을 실행하는 데 사용됩니다. 빌더 이미지를 사용자 지정하려면 build-image 목표에서 builder 매개변수를 설정할 수 있습니다."
"스프링 부트 Maven 플러그인을 사용하여 OCI 이미지를 생성할 때 빌드팩을 사용자 지정하는 방법은 무엇인가요?","스프링 부트 Maven 플러그인을 사용하여 OCI 이미지를 생성할 때 빌드팩을 사용자 지정하려면 플러그인의 image 매개변수를 구성하여 builder 및 runImage 매개변수를 설정하고, 빌드팩을 지정하고, 빌드팩에 환경 변수를 적용할 수 있습니다. 기본적으로 플러그인은 빌더 이미지에 포함된 빌드팩을 사용합니다. 빌더 및 빌드팩에 대한 자세한 내용은 해당 문서를 참조하십시오."
"Spring AOT란 무엇이며, Spring ApplicationContext를 네이티브 이미지에서 실행하기 위해 어떻게 사용되나요?","Spring AOT(Ahead-of-Time)는 빌드 시간에 애플리케이션을 분석하고 최적화된 버전을 생성하는 프로세스입니다. 이는 Spring ApplicationContext를 네이티브 이미지에서 실행하기 위한 필수 단계입니다. Spring Boot의 GraalVM Native Images 지원에 대한 개요는 참조 문서(<https://docs.spring.io/spring-boot/maven-plugin/reference/htmlsingle/#packaging.native-image>)를 참조하십시오. Spring Boot Maven 플러그인은 애플리케이션 및 테스트 코드 모두에 대해 AOT 처리를 수행할 수 있는 목표를 제공합니다."
"Spring Boot에서 애플리케이션 및 테스트 코드에 대해 AOT 처리를 구성하는 방법은 무엇인가요?","Spring Boot에서 애플리케이션에 대해 AOT 처리를 사용하도록 구성하려면, 다음 예제와 같이 process-aot 목표에 대한 실행을 플러그인 구성에 추가하십시오. 테스트에 대해 AOT 처리를 사용하도록 구성하려면, 다음 예제와 같이 process-test-aot 목표에 대한 실행을 플러그인 구성에 추가하십시오."
"Spring Boot에서 멀티모듈 프로젝트에서 native 프로필을 사용하는 방법은 무엇인가요?","Spring Boot에서 멀티모듈 프로젝트에서 native 프로필을 사용하려면, 다음 예제와 같이 프로젝트의 루트 POM에 Cloud Native Buildpacks를 package 단계에서 바인딩하는 다음 줄을 추가하거나, Native Build Tools에 대한 예제와 같이 Native Build Tools를 사용하십시오."
"Spring Boot 애플리케이션의 통합 테스트 중 생명주기를 어떻게 관리하나요?","Spring Boot 애플리케이션의 통합 테스트 중 생명주기를 관리하려면, 시작 및 중지 목표를 사용하여 빌드 자체에서 처리할 수 있습니다. 예를 들어, <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>pre-integration-test</id> <goals> <goal>start</goal> </goals> </execution> <execution> <id>post-integration-test</id> <goals> <goal>stop</goal> </goals> </execution> </executions> </plugin> </plugins> </build>와 같이 설정하면, failsafe-plugin(https://maven.apache.org/surefire/maven-failsafe-plugin)을 사용하여 통합 테스트를 실행할 수 있습니다. 애플리케이션은 별도의 프로세스에서 시작되며, JMX를 사용하여 애플리케이션과 통신합니다. 기본적으로 플러그인은 포트 9001을 사용합니다. JMX 포트를 구성해야 하는 경우, 전용 예제(#integration-tests.examples.jmx-port)를 참조하십시오. 특정 속성이 설정되었을 때 통합 테스트를 건너뛰도록 더 고급 설정을 구성할 수도 있습니다. 전용 예제(#integration-tests.examples.skip)를 참조하십시오."
"Spring Boot의 Parent POM 없이 Failsafe를 구성하려면 어떻게 해야 하나요?","Spring Boot의 Parent POM, spring-boot-starter-parent,는 Failsafe의 <classesDirectory>를 ${project.build.outputDirectory}로 구성합니다. 이 구성이 없으면 Failsafe는 컴파일된 클래스가 아닌 다시 패키징된 JAR을 사용하기 때문에 애플리케이션의 클래스를 로드할 수 없습니다. Parent POM을 사용하지 않는 경우, 다음 예제와 같이 동일한 방식으로 Failsafe를 구성해야 합니다. <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-failsafe-plugin</artifactId> <configuration> <classesDirectory>${project.build.outputDirectory}</classesDirectory> </configuration> </plugin>."
"Spring Boot 애플리케이션의 통합 테스트에서 JMX 포트를 사용자 지정하려면 어떻게 해야 하나요?","Spring Boot 애플리케이션의 통합 테스트에서 JMX 포트를 사용자 지정하려면 jmxPort 속성을 사용하면 됩니다. 이 예제는 9001 포트가 이미 사용 중인 경우 포트를 사용자 지정하는 방법을 보여줍니다. <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <jmxPort>9009</jmxPort> </configuration> <executions> <execution> <id>pre-integration-test</id> <goals> <goal>start</goal> </goals> </execution> <execution> <id>post-integration-test</id> <goals> <goal>stop</goal> </goals> </execution> </executions> </plugin> </plugins> </build>. JMX 포트를 구성해야 하는 경우, 위 예제와 같이 전역 구성에서 구성하여 두 목표에서 공유되도록 해야 합니다."
"Spring Boot Actuator에서 META-INF/build-info.properties 파일이란 무엇인가요?","Spring Boot Actuator에서 META-INF/build-info.properties 파일은 빌드 관련 정보를 표시하기 위해 사용되는 파일입니다. 이 파일은 spring-boot-maven-plugin의 'build-info' goals를 사용하여 생성되며, 프로젝트의 좌표와 빌드 시간 등의 정보를 포함합니다. 사용자는 추가적인 속성을 추가하여 이 파일에 저장할 수 있습니다. 이 파일은 Actuator 엔드포인트에서 빌드 정보를 표시하는 데 사용됩니다. (출처: https://docs.spring.io/spring-boot/maven-plugin/build-info.html)"
"META-INF/build-info.properties 파일에 추가 속성을 어떻게 추가할 수 있나요?","META-INF/build-info.properties 파일에 추가 속성을 추가하려면, spring-boot-maven-plugin의 'build-info' goals의 configuration 섹션에서 'additionalProperties' 요소를 사용하면 됩니다. 이 요소는 추가할 속성을 key-value 쌍으로 포함하는 Map 객체를 나타냅니다. 각 키는 생성된 build-info.properties 파일에서 'build.' 접두사가 붙습니다. 추가 속성은 사용자의 필요에 따라 빌드 시간에 사용되는 정보, 예를 들어 소스 및 보고서의 인코딩 또는 Java 버전 등을 포함할 수 있습니다. (출처: https://docs.spring.io/spring-boot/maven-plugin/build-info.html)"
"spring-boot-maven-plugin의 'build-info' goals에서 'skip' 매개변수는 어떤 역할을 하나요?","spring-boot-maven-plugin의 'build-info' goals에서 'skip' 매개변수는 빌드-info.properties 파일 생성을 건너뛸지 여부를 제어하는 데 사용됩니다. 이 매개변수가 true로 설정되면, build-info.properties 파일이 생성되지 않습니다. 기본적으로 'skip' 매개변수는 false로 설정되어 있으며, 사용자가 필요에 따라 true로 설정하여 파일 생성을 건너뛸 수 있습니다. 이는 빌드 프로세스를 사용자 정의하고, 특정 빌드 단계에서 build-info.properties 파일이 필요하지 않을 때 유용합니다. (출처: https://docs.spring.io/spring-boot/maven-plugin/build-info.html)"
"spring-boot-maven-plugin의 도움말 정보를 어떻게 표시하나요?","mvn spring-boot:help 명령어를 사용하여 spring-boot-maven-plugin의 도움말 정보를 표시할 수 있습니다. -Ddetail=true -Dgoal=<goal-name> 옵션을 사용하여 매개변수 세부 정보를 표시할 수 있습니다. (출처: https://docs.spring.io/spring-boot/maven-plugin/help.html)"
"spring-boot-maven-plugin에서 매개변수 세부 정보를 표시하려면 어떤 옵션을 사용해야 하나요?","spring-boot-maven-plugin에서 매개변수 세부 정보를 표시하려면 -Ddetail=true 옵션을 사용해야 합니다. 이 옵션은 각 목표에 대해 설정 가능한 모든 속성을 표시합니다. (출처: https://docs.spring.io/spring-boot/maven-plugin/help.html)"
"spring-boot-maven-plugin에서 도움말 정보를 표시할 때 들여쓰기 간격과 줄 길이를 어떻게 변경하나요?","spring-boot-maven-plugin에서 도움말 정보를 표시할 때 들여쓰기 간격과 줄 길이를 변경하려면 각각 indentSize와 lineLength 옵션을 사용해야 합니다. indentSize 옵션은 들여쓰기 간격을 설정하고, lineLength 옵션은 표시 줄의 최대 길이를 설정합니다. (출처: https://docs.spring.io/spring-boot/maven-plugin/help.html)"
"Spring Boot의 Gradle 플러그인은 무엇인가요?","Spring Boot의 Gradle 플러그인은 Gradle에서 Spring Boot 지원을 제공합니다. 이 플러그인을 사용하면 실행 가능한 jar 또는 war 아카이브를 패키징하고, Spring Boot 애플리케이션을 실행하며, spring-boot-dependencies에서 제공하는 의존성 관리를 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/gradle-plugin/index.html)"
"Spring Boot의 Gradle 플러그인은 어떤 버전의 Gradle을 요구하나요?","Spring Boot의 Gradle 플러그인은 Gradle 7.x (7.5 이상) 또는 8.x를 요구합니다. (출처: https://docs.spring.io/spring-boot/gradle-plugin/index.html)"
"Spring Boot의 Gradle 플러그인은 Gradle의 구성 캐시와 함께 사용할 수 있나요?","네, Spring Boot의 Gradle 플러그인은 Gradle의 구성 캐시와 함께 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/gradle-plugin/index.html)"
"Gradle Spring Boot 플러그인을 프로젝트에 적용하려면 어떻게 해야 하나요?","플러그인은 Gradle의 플러그인 포털(https://plugins.gradle.org/plugin/org.springframework.boot)에 게시되어 있으며, plugins 블록을 사용하여 적용할 수 있습니다: Groovy Kotlin plugins { id 'org.springframework.boot' version '3.3.4' } plugins { id('org.springframework.boot') version '3.3.4' }"
"Spring Boot 플러그인이 프로젝트에 적용되면 어떤 변화가 발생하나요?","플러그인은 다른 플러그인이 적용될 때 감지하고 그에 따라 동작합니다. 예를 들어, java 플러그인이 적용되면 실행 가능한 jar를 빌드하는 작업이 자동으로 구성됩니다. 일반적인 Spring Boot 프로젝트는 최소로 groovy, java 또는 org.jetbrains.kotlin.jvm 플러그인을 적용하고 의존성 관리를 위해 io.spring.dependency-management 플러그인 또는 Gradle의 기본 bom 지원을 사용합니다. 예를 들어: Groovy Kotlin plugins { id 'java' id 'org.springframework.boot' version '3.3.4' } apply plugin: 'io.spring.dependency-management' plugins { java id('org.springframework.boot') version '3.3.4' } apply(plugin = 'io.spring.dependency-management')"
"Spring Boot 플러그인이 다른 플러그인이 적용될 때 어떻게 동작하는지 자세히 알아보려면 어디로 가야 하나요?","다른 플러그인에 대한 반응 섹션(reacting.html)을 참조하십시오."
"Spring Boot 애플리케이션에서 의존성을 관리하기 위해 Gradle의 기본 bom 지원을 사용하는 것과 io.spring.dependency-management 플러그인을 적용하는 것의 주요 차이점은 무엇인가요?","Gradle의 기본 bom 지원을 사용하는 것과 io.spring.dependency-management 플러그인을 적용하는 것의 주요 차이점은 io.spring.dependency-management 플러그인을 사용하면 관리되는 버전의 속성 기반 사용자 지정이 가능하지만, Gradle의 기본 bom 지원을 사용하면 빌드 속도가 더 빠를 것으로 예상됩니다. (출처: https://docs.spring.io/spring-boot/gradle-plugin/managing-dependencies.html)"
"Gradle 프로젝트에서 Spring Boot의 bom을 사용하여 프로젝트의 버전을 관리하는 방법은 무엇인가요?","Gradle 프로젝트에서 Spring Boot의 bom을 사용하여 프로젝트의 버전을 관리하려면, bom을 platform 또는 enforcedPlatform 종속성으로 선언해야 합니다. platform 종속성은 bom 내의 버전을 권장 사항으로 취급하고, dependency graph의 다른 버전 및 제약 조건에 따라 bom에 선언된 것과 다른 버전의 종속성이 사용될 수 있습니다. enforcedPlatform 종속성은 bom 내의 버전을 요구 사항으로 취급하고, dependency graph에서 발견된 다른 버전을 무시합니다. SpringBootPlugin 클래스는 bom을 선언할 때 group ID, artifact ID 또는 버전을 알 필요 없이 Spring Boot의 bom에 대한 종속성을 선언하는 데 사용할 수 있는 BOM_COORDINATES 상수를 제공합니다. (출처: https://docs.spring.io/spring-boot/gradle-plugin/managing-dependencies.html)"
"io.spring.dependency-management 플러그인을 적용할 때, bom에 선언된 버전을 재정의할 수 있나요?","네, io.spring.dependency-management 플러그인을 적용할 때, 해당 플러그인에 해당하는 속성을 설정하여 관리되는 버전을 사용자 지정할 수 있습니다. 예를 들어, slf4j.version 속성을 사용하여 SLF4J 버전의 버전을 사용자 지정할 수 있습니다. (출처: https://docs.spring.io/spring-boot/gradle-plugin/managing-dependencies.html)"
"Gradle Spring Boot 플러그인을 사용하여 실행 가능한 JAR 또는 WAR 아카이브를 패키징하는 방법은 무엇인가요?","Gradle Spring Boot 플러그인을 사용하여 실행 가능한 JAR 또는 WAR 아카이브를 패키징하려면, 'bootJar' 또는 'bootWar' 작업을 사용하면 됩니다. 이 작업들은 자동으로 생성되며, 'assemble' 작업에 의존하도록 구성되어 있습니다. 실행 가능한 JAR 또는 WAR 아카이브는 'java -jar' 명령어로 실행할 수 있습니다."
"Gradle Spring Boot 플러그인을 사용하여 실행 가능한 JAR 또는 WAR 아카이브에서 메인 클래스를 명시적으로 구성하는 방법은 무엇인가요?","Gradle Spring Boot 플러그인을 사용하여 실행 가능한 JAR 또는 WAR 아카이브에서 메인 클래스를 명시적으로 구성하려면, 작업의 'mainClass' 속성을 사용하면 됩니다. 또한, Spring Boot DSL의 'mainClass' 속성을 사용하여 프로젝트 전체에서 메인 클래스를 구성할 수도 있습니다. 마지막으로, 작업의 매니페스트에서 'Start-Class' 속성을 구성하여 메인 클래스를 지정할 수도 있습니다."
"Gradle Spring Boot 플러그인을 사용하여 실행 가능한 JAR 또는 WAR 아카이브에 개발 전용 종속성을 포함하려면 어떻게 해야 하나요?","Gradle Spring Boot 플러그인을 사용하여 실행 가능한 JAR 또는 WAR 아카이브에 개발 전용 종속성을 포함하려면, 해당 작업의 클래스패스에 'developmentOnly' 구성을 포함하도록 구성해야 합니다. 이 예제에서는 'bootWar' 작업을 사용하여 개발 전용 종속성을 실행 가능한 WAR 아카이브에 포함시키는 방법을 보여줍니다."
"Gradle에서 Spring Boot 애플리케이션을 빌드하지 않고 실행하는 방법은 무엇인가요?","Gradle에서 Spring Boot 애플리케이션을 빌드하지 않고 실행하려면 bootRun 작업을 사용합니다. $ ./gradlew bootRun 명령어를 사용하면 됩니다. bootRun 작업은 JavaExec 하위 클래스인 BootRun의 인스턴스입니다. 따라서 Gradle에서 Java 프로세스를 실행하는 데 사용되는 일반적인 구성 옵션을 모두 사용할 수 있습니다."
"Gradle에서 bootRun 작업의 main 클래스를 설정하는 방법은 무엇인가요?","Gradle에서 bootRun 작업의 main 클래스를 설정하는 방법은 여러 가지가 있습니다. 빌드 스크립트에서 main 클래스를 명시적으로 구성하거나 Spring Boot DSL의 mainClass 속성을 사용하여 프로젝트 전체에 대해 main 클래스를 구성할 수 있습니다. 기본적으로 bootRun은 devtools가 프로젝트에 추가된 경우 애플리케이션의 클래스패스를 자동으로 모니터링하여 변경 사항을 감지합니다. 수정된 파일이 devtools로 다시 로드되도록 트리거하려면 다시 컴파일해야 합니다."
"Gradle에서 bootRun 작업에 시스템 속성을 전달하는 방법은 무엇인가요?","Gradle에서 bootRun 작업에 시스템 속성을 전달하려면 빌드 스크립트에서 시스템 속성을 지정하면 됩니다. 시스템 속성의 값을 구성 가능하게 만들려면 프로젝트 속성(https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#N14FE1)을 사용하여 값을 설정하십시오. 프로젝트 속성이 선택 사항으로 설정되도록 하려면 findProperty를 사용하여 참조하십시오. 이 작업을 수행하면 다음 예제와 같이 ?: Elvis 연산자를 사용하여 기본값을 제공할 수도 있습니다."
"Spring AOT는 어떤 용도로 사용되며, 어떻게 GraalVM 네이티브 이미지를 생성하는 데 도움을 주나요?","Spring AOT는 빌드 시간에 코드를 분석하여 최적화된 버전을 생성하는 프로세스입니다. 주로 GraalVM 네이티브 이미지를 생성하는 데 사용됩니다. Spring Boot Gradle 플러그인은 애플리케이션 및 테스트 코드 모두에 대해 AOT 처리를 수행하는 데 사용할 수 있는 작업을 제공합니다. 이러한 작업은 GraalVM Native Image 플러그인이 적용될 때 자동으로 구성됩니다: Groovy Kotlin plugins { id 'org.springframework.boot' version '3.3.4' id 'org.graalvm.buildtools.native' version '0.10.3' id 'java' } plugins { id('org.springframework.boot') version '3.3.4' id('org.graalvm.buildtools.native') version '0.10.3' id('java') }"
"AOT 엔진을 사용하여 Spring의 테스트 컨텍스트 프레임워크를 사용하는 JUnit 5 테스트를 처리하는 방법은 무엇인가요?","Spring의 테스트 컨텍스트 프레임워크를 사용하는 JUnit 5 테스트는 processTestAot 작업에 의해 처리되어 ApplicationContextInitializer 코드를 생성합니다. 애플리케이션 AOT 처리와 마찬가지로 BeanFactory는 빌드 시간에 완전히 준비됩니다. processTestAot 작업은 JavaExec 하위 클래스이며 필요에 따라 이 처리에 영향을 주도록 구성할 수 있습니다. GraalVM Native Image 플러그인의 nativeTest 작업은 processAot 및 processTestAot 작업의 출력을 사용하도록 자동으로 구성됩니다."
"Spring AOT를 사용할 때 Spring Boot 애플리케이션에서 런타임에 수행하는 것과 비교하여 조건 평가는 어떻게 변경되나요?","AOT 엔진을 사용하여 빌드 시간에 BeanFactory를 완전히 준비하므로 조건은 빌드 시간에 평가됩니다. 이는 Spring Boot 애플리케이션에서 런타임에 수행하는 것과 중요한 차이점이 있습니다. 특정 기능에 대해 옵트인 또는 옵트아웃하려면 빌드 시간에 사용되는 환경을 구성해야 합니다. 이를 위해 processAot 작업은 JavaExec 작업이며 필요에 따라 환경 변수, 시스템 속성 및 인수로 구성할 수 있습니다. GraalVM Native Image 플러그인의 nativeCompile 작업은 processAot 작업의 출력을 사용하도록 자동으로 구성됩니다."
"Spring Boot 플러그인이 Kotlin 플러그인에 적용될 때 어떤 작업을 수행하나요?","Kotlin 버전을 Spring Boot의 의존성 관리에서 사용하는 버전과 일치시키고, Kotlin 컴파일 작업에서 -java-parameters 컴파일러 인수를 사용하도록 구성합니다. (출처: https://docs.spring.io/spring-boot/gradle-plugin/reacting.html)"
"Spring Boot 플러그인이 war 플러그인에 적용될 때 부트워(bootWar) 작업의 역할은 무엇인가요?","프로젝트에 대한 실행 가능한 팻 워(fat war)를 생성하고, 제공된 런타임 구성의 모든 것을 WEB-INF/lib-provided에 패키징합니다. (출처: https://docs.spring.io/spring-boot/gradle-plugin/reacting.html)"
"Spring Boot 플러그인이 애플리케이션 플러그인에 적용될 때 어떤 작업을 수행하나요?","부트 아카이브 구성을 포함하고, 부트 아카이브의 아티팩트를 lib 디렉토리에, 시작 스크립트를 bin 디렉토리에 포함하는 새로운 배포판을 구성합니다. (출처: https://docs.spring.io/spring-boot/gradle-plugin/reacting.html)"
"스프링 부트 AntLib 모듈은 무엇인가요?","Apache Ant에 대한 기본적인 스프링 부트 지원을 제공합니다. 이 모듈을 사용하여 실행 가능한 jar 파일을 만들 수 있습니다. 빌드.xml에 추가적인 spring-boot 네임스페이스를 선언해야 사용할 수 있으며, Ant를 실행할 때 -lib 옵션을 사용하여 spring-boot-antlib-3.3.4.jar를 포함하는 디렉토리를 지정해야 합니다. (출처: https://docs.spring.io/spring-boot/build-tool-plugin/antlib.html)"
"스프링 부트 Ant Tasks에서 'exejar' 작업은 어떤 역할을 하며, 어떤 속성을 사용할 수 있나요?","exejar 작업은 스프링 부트 실행 가능한 jar 파일을 만들기 위한 작업입니다. 이 작업은 destfile, classes, start-class 속성을 지원합니다. 또한 resources, lib 요소를 사용하여 jar 파일에 추가할 리소스 및 라이브러리를 지정할 수 있습니다. (출처: https://docs.spring.io/spring-boot/build-tool-plugin/antlib.html)"
"스프링 부트 Ant Tasks에서 'findmainclass' 작업은 어떤 역할을 하며, 어떤 속성을 사용할 수 있나요?","findmainclass 작업은 실행 가능한 jar 파일을 만들기 위해 필요한 main 클래스를 찾는 데 사용되는 내부 작업입니다. 이 작업은 classesroot 및 mainclass 속성을 지원하며, findmainclass 작업을 사용하여 main 클래스를 직접 찾고 설정할 수 있습니다. (출처: https://docs.spring.io/spring-boot/build-tool-plugin/antlib.html)"
"스프링 부트에서 메이븐, 그레들, 앤트 이외의 빌드 도구를 사용하려면 어떻게 해야 하나요?","다른 빌드 도구를 사용하려면 자체 플러그인을 개발해야 할 가능성이 높습니다. 실행 가능한 JAR는 특정 형식을 따르고 특정 항목은 압축되지 않은 형태로 작성되어야 합니다. 스프링 부트 메이븐 및 그레들 플러그인은 모두 spring-boot-loader-tools를 사용하여 실제로 JAR를 생성합니다. 이 라이브러리를 직접 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/build-tool-plugin/other-build-systems.html)"
"스프링 부트에서 기존 아카이브를 자체 포함 실행 가능한 아카이브로 다시 패키징하려면 어떻게 해야 하나요?","기존 아카이브를 자체 포함 실행 가능한 아카이브로 다시 패키징하려면 org.springframework.boot.loader.tools.Repackager를 사용하세요. Repackager 클래스는 기존 JAR 또는 WAR 아카이브를 참조하는 단일 생성자 인수를 사용합니다. 두 가지 사용 가능한 repackage() 메서드 중 하나를 사용하여 원본 파일을 대체하거나 새 대상에 쓸 수 있습니다. 실행하기 전에 리패키저에 다양한 설정을 구성할 수도 있습니다. (출처: https://docs.spring.io/spring-boot/build-tool-plugin/other-build-systems.html)"
"스프링 부트에서 빌드 시스템별 구현을 사용하여 리패키저에 종속성 파일을 포함하려면 어떻게 해야 하나요?","아카이브를 다시 패키징할 때 org.springframework.boot.loader.tools.Libraries 인터페이스를 사용하여 종속성 파일에 대한 참조를 포함할 수 있습니다. 우리는 일반적으로 빌드 시스템별 구현을 제공하지 않습니다. 아카이브에 이미 라이브러리가 포함되어 있는 경우 Libraries.NONE을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/build-tool-plugin/other-build-systems.html)"
"Spring Boot CLI는 무엇인가요?","Spring Boot CLI는 명령 줄 도구로, start.spring.io에서 새로운 프로젝트를 시작하거나 비밀번호를 인코딩하는 데 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/cli/index.html)"
"Spring Boot CLI를 사용하여 새로운 프로젝트를 시작하는 방법은 무엇인가요?","Spring Boot CLI를 사용하여 start.spring.io에서 새로운 프로젝트를 시작할 수 있습니다. (출처: https://docs.spring.io/spring-boot/cli/index.html)"
"Spring Boot CLI를 사용하여 비밀번호를 인코딩하는 방법은 무엇인가요?","Spring Boot CLI를 사용하여 비밀번호를 인코딩할 수 있습니다. (출처: https://docs.spring.io/spring-boot/cli/index.html)"
"Spring CLI를 사용하여 새로운 프로젝트를 생성하는 방법은 무엇인가요?","Spring CLI를 사용하여 새로운 프로젝트를 생성하려면, 명령줄에서 'spring init' 명령어를 사용하면 됩니다. 이 명령어를 사용하면 Spring Initializr (start.spring.io)를 사용하여 새로운 프로젝트를 생성할 수 있습니다. 사용 가능한 옵션과 명령어에 대한 자세한 정보는 'spring help'를 사용하십시오."
"Spring CLI를 사용하여 비밀번호를 인코딩하는 방법은 무엇인가요?","Spring CLI를 사용하여 비밀번호를 인코딩하려면, 명령줄에서 'spring encodepassword' 명령어를 사용하면 됩니다. 이 명령어를 사용하면 Spring Security와 함께 사용할 수 있는 인코딩된 비밀번호를 생성할 수 있습니다. 사용 가능한 옵션에 대한 자세한 정보는 'spring help encodepassword'를 사용하십시오."
"Spring CLI에서 내장된 셸을 실행하는 방법은 무엇인가요?","Spring CLI에서 내장된 셸을 실행하려면, 명령줄에서 'spring shell' 명령어를 사용하면 됩니다. 이 명령어를 사용하면 ANSI 색상 출력과 탭 완성 기능을 지원하는 통합 셸이 실행됩니다. 내장된 셸에서 나오려면 ctrl-c를 누르세요."
"Spring Boot에서 Audit Events 엔드포인트를 사용하여 애플리케이션의 감사 이벤트를 검색하려면 어떻게 해야 하나요?","Spring Boot에서 Audit Events 엔드포인트를 사용하여 애플리케이션의 감사 이벤트를 검색하려면 /actuator/auditevents로 GET 요청을 보내면 됩니다. 이때, after, principal, type 매개변수를 사용하여 결과를 필터링할 수 있습니다. 응답은 vnd.spring-boot.actuator.v3+json 콘텐츠 유형으로 반환되며, 이벤트 세부 정보를 포함한 이벤트 배열이 포함됩니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/auditevents.html)"
"Spring Boot에서 Audit Events 엔드포인트를 사용하여 이벤트를 검색할 때 사용할 수 있는 매개변수는 무엇인가요?","Spring Boot에서 Audit Events 엔드포인트를 사용하여 이벤트를 검색할 때 사용할 수 있는 매개변수는 after, principal, type입니다. after 매개변수는 지정된 시간 이후에 발생한 이벤트로 결과를 제한합니다. principal 매개변수는 지정된 주체로 이벤트를 제한합니다. type 매개변수는 지정된 유형의 이벤트로 결과를 제한합니다. 이러한 매개변수는 선택 사항입니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/auditevents.html)"
"Spring Boot에서 Audit Events 엔드포인트를 사용하여 반환되는 응답의 구조는 어떻게 되나요?","Spring Boot에서 Audit Events 엔드포인트를 사용하여 반환되는 응답은 이벤트 세부 정보를 포함한 이벤트 배열을 포함합니다. 이벤트 배열의 각 요소는 timestamp, principal, type 속성을 포함합니다. timestamp 속성은 이벤트가 발생한 시간을 나타내며, principal 속성은 이벤트를 트리거한 주체를 나타냅니다. type 속성은 이벤트 유형을 나타냅니다. 응답 콘텐츠 유형은 vnd.spring-boot.actuator.v3+json입니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/auditevents.html)"
"Spring Boot에서 Actuator를 통해 애플리케이션의 빈에 대한 정보를 얻기 위해 어떤 엔드포인트를 사용해야 하나요?","beans 엔드포인트를 사용해야 합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/beans.html)"
"beans 엔드포인트를 통해 어떤 정보를 얻을 수 있나요?","애플리케이션의 빈에 대한 세부 정보를 얻을 수 있습니다. 이 정보에는 빈의 별칭, 범위, 타입, 정의된 리소스, 의존성 등이 포함됩니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/beans.html)"
"beans 엔드포인트의 응답 구조는 어떻게 되나요?","응답은 애플리케이션의 빈에 대한 세부 정보를 포함하는 객체를 반환합니다. 응답 구조에는 ID로 키된 애플리케이션 컨텍스트, 이름으로 키된 애플리케이션 컨텍스트의 빈, 빈의 별칭, 범위, 타입, 정의된 리소스, 의존성 등이 포함됩니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/beans.html)"
"스프링 부트의 액추에이터에서 캐시 엔드포인트를 사용하여 애플리케이션의 캐시를 검색하는 방법은 무엇인가요?","스프링 부트의 액추에이터에서 캐시 엔드포인트를 사용하여 애플리케이션의 캐시를 검색하려면 /actuator/caches로 GET 요청을 보내면 됩니다. 응답에는 애플리케이션의 캐시에 대한 세부 정보가 포함됩니다. 응답 구조는 캐시를 이름으로 키가 지정된 애플리케이션 컨텍스트의 캐시를 설명하는 테이블을 포함합니다. 또한, 응답에는 id로 키가 지정된 캐시 관리자가 포함됩니다. 응답의 구조는 캐시 관리자, 캐시 및 네이티브 캐시의 완전 자격 이름을 설명하는 테이블을 포함합니다."
"스프링 부트의 액추에이터에서 캐시 엔드포인트를 사용하여 특정 캐시를 검색하는 방법은 무엇인가요?","스프링 부트의 액추에이터에서 캐시 엔드포인트를 사용하여 특정 캐시를 검색하려면 /actuator/caches/{name}로 GET 요청을 보내면 됩니다. 응답에는 요청된 캐시에 대한 세부 정보가 포함됩니다. 응답 구조는 캐시 이름, 캐시 관리자 이름 및 네이티브 캐시의 완전 자격 이름을 설명하는 테이블을 포함합니다. 요청된 이름이 단일 캐시를 식별하기에 충분히 구체적인 경우 추가 매개 변수가 필요하지 않습니다. 그렇지 않으면 캐시 관리자를 지정해야 합니다."
"스프링 부트의 액추에이터에서 캐시 엔드포인트를 사용하여 사용 가능한 모든 캐시를 지우는 방법은 무엇인가요?","스프링 부트의 액추에이터에서 캐시 엔드포인트를 사용하여 사용 가능한 모든 캐시를 지우려면 /actuator/caches로 DELETE 요청을 보내면 됩니다. 요청된 이름이 단일 캐시를 식별하기에 충분히 구체적인 경우 추가 매개 변수가 필요하지 않습니다. 그렇지 않으면 캐시 관리자를 지정해야 합니다. 지원되는 쿼리 매개 변수에는 캐시 관리자의 이름을 지정하는 cacheManager 매개 변수가 포함됩니다."
"스프링 부트의 actuator/conditions 엔드포인트를 통해 어떤 정보를 얻을 수 있나요?","스프링 부트의 actuator/conditions 엔드포인트를 통해 구성 및 자동 구성 클래스의 조건 평가에 대한 정보를 얻을 수 있습니다. 이 엔드포인트에 GET 요청을 보내면 애플리케이션의 조건 평가에 대한 세부 정보를 포함한 응답을 받을 수 있습니다. 응답 구조에는 애플리케이션 컨텍스트, 일치하는 조건, 일치하지 않는 조건, 무조건적인 자동 구성 클래스 등이 포함됩니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/conditions.html)"
"actuator/conditions 응답의 contexts 객체는 어떤 정보를 포함하고 있나요?","actuator/conditions 응답의 contexts 객체는 애플리케이션 컨텍스트를 식별자로 그룹화하여 포함합니다. 각 컨텍스트에는 일치하는 조건, 일치하지 않는 조건, 무조건적인 자동 구성 클래스 등의 세부 정보가 포함됩니다. 이를 통해 애플리케이션의 조건 평가에 대한 자세한 정보를 확인할 수 있습니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/conditions.html)"
"actuator/conditions 응답의 contexts.*.positiveMatches 및 contexts.*.negativeMatches 객체는 어떤 정보를 포함하고 있나요?","contexts.*.positiveMatches 및 contexts.*.negativeMatches 객체에는 각각 일치하는 조건과 일치하지 않는 조건에 대한 세부 정보가 포함됩니다. 각 객체에는 조건의 이름과 조건이 일치하거나 일치하지 않은 이유에 대한 메시지가 포함됩니다. 이를 통해 애플리케이션의 조건 평가 결과를 정확하게 파악할 수 있습니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/conditions.html)"
"Spring Boot에서 모든 @ConfigurationProperties 빈을 검색하려면 어떤 엔드포인트에 어떤 유형의 요청을 보내야 하나요?","모든 @ConfigurationProperties 빈을 검색하려면 /actuator/configprops에 GET 요청을 보냅니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/configprops.html)"
"Spring Boot에서 특정 접두사 아래에 매핑된 @ConfigurationProperties 빈을 검색하려면 어떤 엔드포인트에 어떤 유형의 요청을 보내야 하나요?","특정 접두사 아래에 매핑된 @ConfigurationProperties 빈을 검색하려면 /actuator/configprops/{prefix}에 GET 요청을 보냅니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/configprops.html)"
"Spring Boot의 Configuration Properties 엔드포인트의 응답 구조는 어떻게 되나요?","응답은 애플리케이션의 @ConfigurationProperties 빈에 대한 세부 정보를 포함합니다. 응답의 구조는 다음과 같은 테이블로 설명됩니다: Path Type Description (출처: https://docs.spring.io/spring-boot/api/rest/actuator/configprops.html)"
"Flyway 엔드포인트는 어떤 정보를 제공하나요?","Flyway 엔드포인트는 Flyway에 의해 수행된 데이터베이스 마이그레이션에 대한 정보를 제공합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/flyway.html)"
"Flyway 마이그레이션을 검색하려면 어떻게 해야 하나요?","Flyway 마이그레이션을 검색하려면 /actuator/flyway로 GET 요청을 보내면 됩니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/flyway.html)"
"Flyway 마이그레이션 응답의 구조는 어떻게 되나요?","Flyway 마이그레이션 응답은 애플리케이션의 Flyway 마이그레이션에 대한 세부 정보를 포함합니다. 응답의 구조는 문서에 설명되어 있으며, 마이그레이션에 대한 다양한 정보와 Flyway 인스턴스에 의해 수행된 마이그레이션에 대한 정보를 포함합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/flyway.html)"
"Spring Boot 애플리케이션의 건강 상태를 검색하려면 어떤 엔드포인트를 사용해야 하나요?","/actuator/health 엔드포인트를 사용합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/health.html)"
"Spring Boot 애플리케이션의 건강 정보를 검색할 때 V2 JSON 응답을 반환하려면 어떻게 해야 하나요?","Accept 헤더를 사용하거나 application/vnd.spring-boot.actuator.v2+json을 사용합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/health.html)"
"Spring Boot 애플리케이션의 계층적인 건강 정보를 검색하려면 어떻게 해야 하나요?","계층적인 건강 정보를 검색하려는 구성 요소의 중첩된 식별자를 포함하는 URL을 사용하여 GET 요청을 보냅니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/health.html)"
"Heap Dump 엔드포인트는 무엇인가요?","Heap Dump 엔드포인트는 애플리케이션의 JVM에서 힙 덤프를 제공합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/heapdump.html)"
"Heap Dump를 검색하는 방법은 무엇인가요?","Heap Dump를 검색하려면 /actuator/heapdump로 GET 요청을 보내면 됩니다. 응답은 이진 데이터이며 크기가 클 수 있습니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/heapdump.html)"
"HotSpot JVM과 OpenJ9에서 힙 덤프 형식은 어떻게 되나요?","HotSpot JVM에서는 힙 덤프 형식이 HPROF이고 OpenJ9에서는 PHD 형식입니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/heapdump.html)"
"HTTP Exchanges 엔드포인트는 어떤 정보를 제공하나요?","HTTP Exchanges 엔드포인트는 HTTP 요청-응답 교환에 대한 정보를 제공합니다. (출처: <https://docs.spring.io/spring-boot/api/rest/actuator/httpexchanges.html>)"
"HTTP Exchanges를 검색하기 위한 GET 요청의 엔드포인트는 무엇인가요?","/actuator/httpexchanges입니다. (출처: <https://docs.spring.io/spring-boot/api/rest/actuator/httpexchanges.html>)"
"HTTP 요청-응답 교환의 응답 구조는 어떻게 되나요?","응답에는 추적된 HTTP 요청-응답 교환의 세부 정보가 포함됩니다. ... (출처: <https://docs.spring.io/spring-boot/api/rest/actuator/httpexchanges.html>)"
"Spring Boot 애플리케이션의 Info 엔드포인트는 어떤 정보를 제공하나요?","Spring Boot 애플리케이션의 Info 엔드포인트는 애플리케이션에 대한 일반적인 정보를 제공합니다. 이 정보에는 빌드 및 Git 정보가 포함될 수 있습니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/info.html)"
"Spring Boot의 Info 엔드포인트를 어떻게 액세스할 수 있나요?","Spring Boot의 Info 엔드포인트를 액세스하려면 GET 요청을 /actuator/info로 보내면 됩니다. 예를 들어, 'http://localhost:8080/actuator/info'로 요청을 보내면 됩니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/info.html)"
"Spring Boot의 Info 엔드포인트 응답 구조는 어떻게 되나요?","Spring Boot의 Info 엔드포인트 응답은 InfoContributor에 의해 기여된 애플리케이션의 일반적인 정보를 포함합니다. 응답은 빌드 및 Git 섹션을 포함할 수 있습니다. 빌드 섹션의 구조는 경로에 따라 다르며, Git 섹션은 브랜치, 커밋 시간 및 커밋 ID 정보를 포함할 수 있습니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/info.html)"
"Spring Integration Graph (integrationgraph) 엔드포인트는 무엇인가요?","Spring Integration Graph (integrationgraph) 엔드포인트는 모든 Spring Integration 컴포넌트를 포함하는 그래프를 노출하는 엔드포인트입니다."
"Spring Integration Graph를 검색하는 방법은 무엇인가요?","Spring Integration Graph를 검색하려면 /actuator/integrationgraph에 GET 요청을 보내면 됩니다. 응답에는 애플리케이션 내에서 사용되는 모든 Spring Integration 컴포넌트와 그들 간의 링크가 포함됩니다."
"Spring Integration Graph를 다시 빌드하는 방법은 무엇인가요?","Spring Integration Graph를 다시 빌드하려면 /actuator/integrationgraph에 POST 요청을 보내면 됩니다. 이 작업은 204 - No Content 응답을 반환합니다."
"Liquibase 엔드포인트는 어떤 정보를 제공하나요?","Liquibase 엔드포인트는 Liquibase에 의해 적용된 데이터베이스 변경 세트에 대한 정보를 제공합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/liquibase.html)"
"변경 세트를 검색하기 위해 어떤 API를 사용하나요?","변경 세트를 검색하기 위해 /actuator/liquibase 에 GET 요청을 사용합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/liquibase.html)"
"응답 구조에서 contexts.*.liquibaseBeans.*.changeSets[].execType은 무엇을 나타내나요?","응답 구조에서 contexts.*.liquibaseBeans.*.changeSets[].execType은 변경 세트의 실행 유형(EXECUTED, FAILED, SKIPPED, RERAN, MARK_RAN)을 나타냅니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/liquibase.html)"
"Spring Boot 애플리케이션의 로그 파일에 접근하기 위해 어떤 액추에이터 엔드포인트를 사용하나요?","logfile 엔드포인트를 사용하여 Spring Boot 애플리케이션의 로그 파일에 접근할 수 있습니다."
"로그 파일을 전체로 검색하기 위해 어떤 HTTP 메서드를 사용해야 하나요?","로그 파일을 전체로 검색하기 위해 GET 요청을 /actuator/logfile 엔드포인트로 보내면 됩니다."
"로그 파일의 일부분을 검색하려면 어떤 헤더를 사용해야 하나요?","로그 파일의 일부분을 검색하려면 GET 요청에 Range 헤더를 사용하여 검색할 바이트 범위를 지정해야 합니다."
"스프링 부트 액추에이터의 매핑 엔드포인트는 어떤 기능을 제공하나요?","스프링 부트 액추에이터의 매핑 엔드포인트는 애플리케이션의 요청 매핑에 대한 정보를 제공합니다."
"스프링 부트 액추에이터의 매핑 엔드포인트에 접근하기 위한 URL은 무엇인가요?","스프링 부트 액추에이터의 매핑 엔드포인트에 접근하기 위한 URL은 /actuator/mappings입니다."
"스프링 부트 액추에이터의 매핑 엔드포인트의 응답 구조는 어떻게 되나요?","스프링 부트 액추에이터의 매핑 엔드포인트의 응답은 애플리케이션의 매핑에 대한 세부 정보를 포함하고 있습니다. 응답에서 찾을 수 있는 항목은 웹 애플리케이션의 유형(리액티브 또는 서블릿 기반)에 따라 다릅니다. 응답의 공통 요소는 컨텍스트, 매핑 및 매핑 유형을 포함합니다."
"Spring Boot의 actuator 엔드포인트에서 /metrics 엔드포인트의 목적은 무엇인가요?","Spring Boot의 actuator 엔드포인트에서 /metrics 엔드포인트는 애플리케이션 메트릭에 대한 액세스를 제공합니다. 메트릭 이름을 검색하려면 /actuator/metrics로 GET 요청을 보내야 합니다. 메트릭을 검색하려면 /actuator/metrics/{metric.name}으로 GET 요청을 보내야 합니다. 응답 구조에는 메트릭 이름, 설명, 기본 단위, 측정값 및 드릴 다운에 사용할 수 있는 태그가 포함됩니다. 쿼리 매개 변수를 사용하여 메트릭의 태그를 기반으로 드릴 다운할 수 있습니다. (출처: {https://docs.spring.io/spring-boot/api/rest/actuator/metrics.html})"
"Spring Boot의 actuator 엔드포인트에서 /metrics 엔드포인트에서 메트릭 이름을 검색하는 방법은 무엇인가요?","Spring Boot의 actuator 엔드포인트에서 /metrics 엔드포인트에서 메트릭 이름을 검색하려면 /actuator/metrics로 GET 요청을 보내야 합니다. 응답에는 알려진 메트릭의 이름이 배열로 포함됩니다. (출처: {https://docs.spring.io/spring-boot/api/rest/actuator/metrics.html})"
"Spring Boot의 actuator 엔드포인트에서 /metrics 엔드포인트에서 메트릭을 검색하는 방법은 무엇인가요?","Spring Boot의 actuator 엔드포인트에서 /metrics 엔드포인트에서 메트릭을 검색하려면 /actuator/metrics/{metric.name}으로 GET 요청을 보내야 합니다. 응답에는 메트릭 이름, 설명, 기본 단위, 측정값 및 드릴 다운에 사용할 수 있는 태그가 포함됩니다. 쿼리 매개 변수를 사용하여 메트릭의 태그를 기반으로 드릴 다운할 수 있습니다. (출처: {https://docs.spring.io/spring-boot/api/rest/actuator/metrics.html})"
"Prometheus 엔드포인트는 어떤 형식으로 Spring Boot 애플리케이션의 메트릭을 제공하나요?","Prometheus 엔드포인트는 /actuator/prometheus에 GET 요청을 보내면 Spring Boot 애플리케이션의 메트릭을 Prometheus 서버에서 스크래핑하는 데 필요한 형식으로 제공합니다. 기본적으로 응답 콘텐츠 유형은 text/plain;version=0.0.4입니다."
"Prometheus 엔드포인트에서 메트릭을 필터링하려면 어떻게 해야 하나요?","Prometheus 엔드포인트에서 메트릭을 필터링하려면 /actuator/prometheus에 GET 요청을 보낼 때 includedNames 쿼리 매개변수를 사용하여 일치하는 이름만 반환하도록 제한할 수 있습니다."
"Prometheus 엔드포인트에서 애플리케이션/openmetrics-text 형식의 응답을 받으려면 어떻게 해야 하나요?","Prometheus 엔드포인트에서 애플리케이션/openmetrics-text 형식의 응답을 받으려면 적절한 Accept 헤더를 사용하여 /actuator/prometheus에 GET 요청을 보내면 됩니다. 예를 들어, Accept: application/openmetrics-text; version=1.0.0; charset=utf-8 헤더를 사용하면 됩니다."
"Quartz 스케줄러에서 관리되는 그룹은 무엇인가요?","Quartz 스케줄러에서 관리되는 그룹은 job과 trigger입니다. (출처: <https://docs.spring.io/spring-boot/api/rest/actuator/quartz.html>)"
"Quartz 스케줄러에서 관리되는 job과 trigger 그룹의 등록 목록을 검색하는 방법은 무엇인가요?","/actuator/quartz 엔드포인트에 GET 요청을 보내면 등록된 job과 trigger 그룹의 목록을 검색할 수 있습니다. (출처: <https://docs.spring.io/spring-boot/api/rest/actuator/quartz.html>)"
"Quartz 스케줄러에서 특정 그룹의 job에 대한 세부 정보를 검색하는 방법은 무엇인가요?","/actuator/quartz/jobs/{groupName}/{jobName} 엔드포인트에 GET 요청을 보내면 특정 그룹의 job에 대한 세부 정보를 검색할 수 있습니다. (출처: <https://docs.spring.io/spring-boot/api/rest/actuator/quartz.html>)"
"스프링 부트에서 sbom 엔드포인트의 목적은 무엇인가요?","스프링 부트에서 sbom 엔드포인트는 소프트웨어 구성 요소 목록(SBOM)에 대한 정보를 제공합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/sbom.html)"
"스프링 부트에서 사용 가능한 SBOM을 검색하는 방법은 무엇인가요?","스프링 부트에서 사용 가능한 SBOM을 검색하려면 /actuator/sbom으로 GET 요청을 보내면 됩니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/sbom.html)"
"스프링 부트에서 단일 SBOM을 검색하는 방법은 무엇인가요?","스프링 부트에서 단일 SBOM을 검색하려면 /actuator/sbom/{id}로 GET 요청을 보내면 됩니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/sbom.html)"
"스프링 부트 애플리케이션에서 /actuator/scheduledtasks 엔드포인트에서 어떤 유형의 스케줄된 작업이 반환됩니까?","스프링 부트 애플리케이션에서 /actuator/scheduledtasks 엔드포인트에서 반환되는 작업의 유형에는 cron, fixedDelay, fixedRate 및 custom이 포함됩니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/scheduledtasks.html)"
"스프링 부트 애플리케이션에서 스케줄된 작업의 응답 구조는 어떻게 되나요?","스프링 부트 애플리케이션에서 스케줄된 작업의 응답 구조에는 cron, fixedDelay, fixedRate 및 custom과 같은 배열이 포함됩니다. 이러한 배열에는 runnable 및 expression과 같은 작업이 포함됩니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/scheduledtasks.html)"
"스프링 부트 애플리케이션에서 스케줄된 작업에 대한 응답에서 runnable 객체는 무엇을 나타내나요?","스프링 부트 애플리케이션에서 스케줄된 작업에 대한 응답에서 runnable 객체는 실행될 대상 메서드 또는 객체를 나타냅니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/scheduledtasks.html)"
"Spring Session에서 HTTP 세션에 대한 정보를 검색하려면 어떤 엔드포인트를 사용하나요?","/actuator/sessions 엔드포인트를 사용합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/sessions.html)"
"Spring Session의 세션 엔드포인트에서 세션의 일치를 제한하는 데 사용되는 쿼리 매개변수는 무엇인가요?","엔드포인트는 반환되는 세션을 제한하기 위해 쿼리 매개변수를 사용하며, 단일 필수 쿼리 매개변수는 'username'입니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/sessions.html)"
"Spring Session의 세션 엔드포인트에서 단일 세션을 검색하려면 어떤 엔드포인트를 사용하나요?","/actuator/sessions/{id} 엔드포인트를 사용합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/sessions.html)"
"애플리케이션의 시작 단계에서 기록된 단계를 스냅샷으로 검색하려면 어떤 HTTP 메서드를 사용해야 하나요?","애플리케이션의 시작 단계에서 기록된 단계를 스냅샷으로 검색하려면 GET 메서드를 사용해야 합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/startup.html)"
"애플리케이션의 시작 단계에서 기록된 단계를 반환하려면 어떤 HTTP 메서드를 사용해야 하나요?","애플리케이션의 시작 단계에서 기록된 단계를 반환하려면 POST 메서드를 사용해야 합니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/startup.html)"
"응답에서 timeline.events.[].startupStep.name 필드의 의미는 무엇인가요?","응답에서 timeline.events.[].startupStep.name 필드는 StartupStep의 이름을 나타냅니다. (출처: https://docs.spring.io/spring-boot/api/rest/actuator/startup.html)"
"스프링 부트에서 Kotlin 언어를 지원하는 이유는 무엇인가요?","스프링 부트는 Kotlin 언어를 지원하여 개발자들이 Kotlin의 기능과 이점을 활용하여 애플리케이션을 개발할 수 있도록 합니다. 이를 통해 코드의 간결성, null 안전성, 표현력 향상 등의 이점을 얻을 수 있습니다. (출처: https://docs.spring.io/spring-boot/api/kotlin/index.html)"
"스프링 부트 Kotlin 프로젝트에서 Gradle을 사용하는 방법은 무엇인가요?","스프링 부트 Kotlin 프로젝트에서 Gradle을 사용하려면 build.gradle.kts 파일을 생성하고 적절한 의존성과 플러그인을 구성해야 합니다. 그런 다음 Gradle을 사용하여 빌드, 실행 및 테스트를 수행할 수 있습니다. (출처: https://docs.spring.io/spring-boot/api/kotlin/index.html)"
"스프링 부트 Kotlin에서 함수형 프로그래밍을 어떻게 활용할 수 있나요?","스프링 부트 Kotlin에서는 함수형 프로그래밍을 활용하여 코드를 더 간결하고 가독성 있게 작성할 수 있습니다. Kotlin은 함수형 프로그래밍 기능을 지원하며, 스프링 부트는 함수형 프로그래밍 패러다임을 적용할 수 있는 다양한 기능을 제공합니다. (출처: https://docs.spring.io/spring-boot/api/kotlin/index.html)"
"스프링 부트에서 구성 메타데이터 파일은 어떤 용도로 사용되나요?","스프링 부트 jar에는 모든 지원되는 구성 속성에 대한 세부 정보를 제공하는 메타데이터 파일이 포함되어 있습니다. 이 파일은 IDE 개발자가 사용자가 application.properties 또는 application.yaml 파일을 작업할 때 컨텍스트 도움말 및 '코드 완성'을 제공할 수 있도록 설계되었습니다. (출처: https://docs.spring.io/spring-boot/specification/configuration-metadata/index.html)"
"스프링 부트에서 구성 메타데이터 파일의 대부분을 생성하는 방법은 무엇인가요?","구성 메타데이터 파일의 대부분은 컴파일 시간에 @ConfigurationProperties로 주석이 지정된 모든 항목을 처리하여 자동으로 생성됩니다. (출처: https://docs.spring.io/spring-boot/specification/configuration-metadata/index.html)"
"스프링 부트에서 구성 메타데이터 파일의 일부를 수동으로 작성하는 방법은 무엇인가요?","스프링 부트에서는 코너 케이스 또는 더 고급 사용 사례를 위해 메타데이터의 일부를 수동으로 작성할 수 있습니다. (출처: https://docs.spring.io/spring-boot/specification/configuration-metadata/index.html)"
"What is the purpose of providing manual hints in Spring Boot?","The purpose of providing manual hints in Spring Boot is to improve the user experience and further assist the user in configuring a given property. This can be done by providing additional metadata that describes the list of potential values for a property and associates a provider to attach a well-defined semantic to a property, so that a tool can discover the list of potential values based on the project’s context. (Source: <https://docs.spring.io/spring-boot/specification/configuration-metadata/manual-hints.html>)"
"How can you offer additional content assistance for the keys of a Map property in Spring Boot?","To offer additional content assistance for the keys of a Map property in Spring Boot, you can add JSON to the manual metadata of the module. The special .keys and .values suffixes must refer to the keys and the values respectively. (Source: <https://docs.spring.io/spring-boot/specification/configuration-metadata/manual-hints.html>)"
"What is the purpose of value providers in Spring Boot?","Value providers in Spring Boot are a powerful way to attach semantics to a property. They can be used to auto-complete classes available in the project, handle the property as if it were defined by the type defined by the mandatory target parameter, auto-complete valid logger names and logger groups, and auto-complete the available bean names in the current project. (Source: <https://docs.spring.io/spring-boot/specification/configuration-metadata/manual-hints.html>)"
"스프링 부트에서 @ConfigurationProperties를 사용하여 메타데이터를 생성하려면 어떻게 해야 하나요?","spring-boot-configuration-processor jar를 사용하여 @ConfigurationProperties로 주석이 달린 항목에서 자체 구성 메타데이터 파일을 쉽게 생성할 수 있습니다. 이 jar에는 프로젝트가 컴파일될 때 호출되는 Java 어노테이션 프로세서가 포함되어 있습니다. 프로세서를 사용하려면 spring-boot-configuration-processor에 대한 종속성을 포함해야 합니다. Maven에서는 다음 예제와 같이 의존성을 선택적으로 선언해야 합니다. Gradle에서는 다음 예제와 같이 annotationProcessor 구성에서 의존성을 선언해야 합니다."
"스프링 부트에서 어노테이션 프로세서를 구성하려면 어떻게 해야 하나요?","Maven에서는 maven-apt-plugin을 명시적으로 구성하고 어노테이션 프로세서에 대한 종속성을 거기에만 추가할 수 있습니다. 또는 AspectJ 플러그인이 모든 처리를 수행하고 maven-compiler-plugin 구성에서 어노테이션 처리를 비활성화할 수도 있습니다. Lombok을 사용하는 경우 lombok 어노테이션 프로세서가 spring-boot-configuration-processor보다 먼저 실행되도록 해야 합니다. 이를 위해 Maven에서는 Maven 컴파일러 플러그인의 annotationProcessors 속성을 사용하여 어노테이션 프로세서를 올바른 순서로 나열할 수 있습니다."
"스프링 부트에서 추가 메타데이터를 포함하려면 어떻게 해야 하나요?","스프링 부트의 구성 파일 처리는 매우 유연하며, @ConfigurationProperties 빈에 바인딩되지 않은 속성이 존재할 수 있습니다. 기존 키의 일부 속성을 조정해야 할 수도 있습니다. 이러한 경우를 지원하고 사용자 지정 '힌트'를 제공할 수 있도록 어노테이션 프로세서는 META-INF/additional-spring-configuration-metadata.json의 항목을 자동으로 기본 메타데이터 파일에 병합합니다. 자동으로 감지된 속성을 참조하는 경우 설명, 기본값 및 사용 중지 정보가 지정된 경우 해당 정보가 덮어쓰여집니다."
"Spring Boot에서 실행 가능한 JAR 파일을 만드는 데 사용되는 모듈은 무엇인가요?","spring-boot-loader 모듈이 사용됩니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/index.html)"
"Maven 또는 Gradle 플러그인을 사용하여 Spring Boot에서 실행 가능한 JAR 파일을 만드는 방법은 무엇인가요?","Maven 또는 Gradle 플러그인을 사용하면 자동으로 실행 가능한 JAR 파일이 생성되므로 일반적으로 작동 방식을 알 필요가 없습니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/index.html)"
"다른 빌드 시스템에서 Spring Boot 실행 가능한 JAR 파일을 만들려면 어떻게 해야 하나요?","이 부록에서는 다른 빌드 시스템에서 실행 가능한 JAR 파일을 만들거나 기본 기술에 대해 자세히 알고 싶은 경우 배경 정보를 제공합니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/index.html)"
"스프링 부트에서 중첩된 JAR 파일을 로드하는 방법은 무엇인가요?","스프링 부트는 중첩된 JAR 파일을 직접 로드할 수 있는 다른 접근 방식을 사용합니다. 이를 위해 실행 가능한 JAR 파일 구조는 example.jar | +-META-INF | +-MANIFEST.MF +-org | +-springframework | +-boot | +-loader | +-<spring boot loader classes> +-BOOT-INF +-classes | +-mycompany | +-project | +-YourClasses.class +-lib +-dependency1.jar +-dependency2.jar 애플리케이션 클래스는 중첩된 BOOT-INF/classes 디렉토리에 위치해야 하며, 의존성은 중첩된 BOOT-INF/lib 디렉토리에 위치해야 합니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/nested-jars.html)"
"스프링 부트 실행 가능한 WAR 파일의 구조는 어떻게 되나요?","스프링 부트 로더 호환 WAR 파일은 example.war | +-META-INF | +-MANIFEST.MF +-org | +-springframework | +-boot | +-loader | +-<spring boot loader classes> +-WEB-INF +-classes | +-com | +-mycompany | +-project | +-YourClasses.class +-lib | +-dependency1.jar | +-dependency2.jar +-lib-provided +-servlet-api.jar +-dependency3.jar와 같이 구성되어야 합니다. 의존성은 중첩된 WEB-INF/lib 디렉토리에 위치해야 하며, 임베디드 실행 시 필요하지만 전통적인 웹 컨테이너에 배포할 때는 필요하지 않은 의존성은 WEB-INF/lib-provided에 위치해야 합니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/nested-jars.html)"
"스프링 부트 실행 가능한 JAR 및 WAR 아카이브에서 인덱스 파일은 어떤 역할을 하나요?","스프링 부트 로더 호환 JAR 및 WAR 아카이브에는 BOOT-INF/ 디렉토리 아래에 추가적인 인덱스 파일을 포함할 수 있습니다. JAR 및 WAR 모두에 대해 classpath.idx 파일을 제공할 수 있으며, 이 파일은 클래스패스에 추가되어야 하는 JAR의 순서를 제공합니다. layers.idx 파일은 JAR에만 사용할 수 있으며, Docker/OCI 이미지 생성을 위해 JAR을 논리적인 레이어로 분할할 수 있습니다. 인덱스 파일은 YAML 호환 구문을 따르므로 타사 도구에서 쉽게 구문 분석할 수 있습니다. 그러나 이 파일들은 내부적으로 YAML로 구문 분석되지 않으며, 정확히 아래에 설명된 형식으로 작성되어야 합니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/nested-jars.html)"
"Spring Boot에서 중첩된 JAR 파일을 로드하는 데 사용되는 핵심 클래스는 무엇인가요?","Spring Boot에서 중첩된 JAR 파일을 로드하는 데 사용되는 핵심 클래스는 org.springframework.boot.loader.jar.NestedJarFile입니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/jarfile-class.html)"
"NestedJarFile 클래스는 어떤 클래스를 확장하며, 어떤 목적으로 사용되나요?","NestedJarFile 클래스는 java.util.jar.JarFile을 확장하며, 기존 코드 및 라이브러리와 호환되도록 설계되었습니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/jarfile-class.html)"
"Spring Boot Loader는 표준 Java 'JarFile'과 어떻게 호환성을 유지하나요?","Spring Boot Loader는 java.net.JarURLConnection과 호환되는 연결을 지원하는 jar:nested:/ 경로 형식을 사용하여 표준 Java 'JarFile'과 호환성을 유지합니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/jarfile-class.html)"
"PropertiesLauncher란 무엇인가요?","PropertiesLauncher는 몇 가지 특별한 기능을 가진 로더로, 외부 속성(시스템 속성, 환경 변수, 매니페스트 항목 또는 loader.properties)으로 활성화할 수 있습니다. 이 로더는 클래스패스에 있는 실행 가능한 jar, war 또는 ear 파일을 실행하는 데 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/property-launcher.html)"
"PropertiesLauncher에서 `loader.path`와 `loader.home` 속성의 목적은 무엇인가요?","`loader.path` 속성은 컴마로 구분된 클래스패스를 지정하는 데 사용되며, `loader.home` 속성은 `loader.path`의 상대 경로를 해결하는 데 사용됩니다. 예를 들어, `loader.path=lib`인 경우, `${loader.home}/lib`은 클래스패스 위치입니다(해당 디렉토리의 모든 jar 파일과 함께). (출처: https://docs.spring.io/spring-boot/specification/executable-jar/property-launcher.html)"
"PropertiesLauncher에서 `loader.path`와 `loader.home` 속성의 기본값은 무엇인가요?","`loader.path` 속성은 빈 값으로 설정되면 BOOT-INF/lib로 기본 설정되며, `loader.home` 속성은 ${user.dir}로 기본 설정됩니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/property-launcher.html)"
"Spring Boot Loader로 패키징된 애플리케이션에서 ZipEntry 압축에 대한 요구사항은 무엇인가요?","ZipEntry for a nested jar must be saved by using the ZipEntry.STORED method. This is required so that we can seek directly to individual content within the nested jar. (Source: https://docs.spring.io/spring-boot/specification/executable-jar/restrictions.html)"
"Spring Boot Loader로 패키징된 애플리케이션에서 System classLoader를 사용하는 방법에는 어떤 제한이 있나요?","Trying to load nested jar classes with ClassLoader.getSystemClassLoader() fails. Launched applications should use Thread.getContextClassLoader() when loading classes. (Source: https://docs.spring.io/spring-boot/specification/executable-jar/restrictions.html)"
"Spring Boot Loader로 패키징된 애플리케이션에서 java.util.Logging을 사용할 때 어떤 제한이 있나요?","java.util.Logging always uses the system classloader. For this reason, you should consider a different logging implementation. (Source: https://docs.spring.io/spring-boot/specification/executable-jar/restrictions.html)"
"Spring Boot Loader를 사용할 수 없을 때, 어떤 대안적인 방법을 사용할 수 있나요?","Maven Shade Plugin, JarClassLoader, OneJar, Gradle Shadow Plugin을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/alternatives.html)"
"Maven Shade Plugin은 어떤 용도로 사용되나요?","Maven Shade Plugin은 종속성을 포함하는 단일 JAR 파일을 생성하는 데 사용됩니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/alternatives.html)"
"Gradle Shadow Plugin은 어떤 용도로 사용되나요?","Gradle Shadow Plugin은 Gradle 프로젝트에서 종속성을 포함하는 단일 실행 가능한 JAR 파일을 생성하는 데 사용됩니다. (출처: https://docs.spring.io/spring-boot/specification/executable-jar/alternatives.html)"
"spring-boot-actuator-autoconfigure 모듈에서 AppOpticsMetricsExportAutoConfiguration의 구현 위치는 어디인가요?","AppOpticsMetricsExportAutoConfiguration은 https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/appoptics/AppOpticsMetricsExportAutoConfiguration.java에서 찾을 수 있습니다. (Source: https://docs.spring.io/spring-boot/appendix/auto-configuration-classes/actuator.html)"
"spring-boot-actuator-autoconfigure 모듈에서 CassandraReactiveHealthContributorAutoConfiguration의 소스 코드는 어디에서 찾을 수 있나요?","CassandraReactiveHealthContributorAutoConfiguration의 소스 코드는 https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cassandra/CassandraReactiveHealthContributorAutoConfiguration.java에서 찾을 수 있습니다. (Source: https://docs.spring.io/spring-boot/appendix/auto-configuration-classes/actuator.html)"
"spring-boot-actuator-autoconfigure 모듈에서 CloudFoundryActuatorAutoConfiguration의 javadoc은 어디에서 찾을 수 있나요?","CloudFoundryActuatorAutoConfiguration의 javadoc은 https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/actuate/autoconfigure/cloudfoundry/servlet/CloudFoundryActuatorAutoConfiguration.html에서 찾을 수 있습니다. (Source: https://docs.spring.io/spring-boot/appendix/auto-configuration-classes/actuator.html)"
"Spring Boot에서 @…​Test auto-configuration annotations의 용도는 무엇인가요?","Spring Boot에서 @…​Test auto-configuration annotations는 애플리케이션의 테스트 슬라이스를 위해 제공됩니다. (출처: https://docs.spring.io/spring-boot/appendix/test-auto-configuration/index.html)"
"Spring Boot에서 @…​Test auto-configuration annotations를 사용하는 방법은 무엇인가요?","Spring Boot에서 @…​Test auto-configuration annotations를 사용하려면 해당 어노테이션을 테스트 클래스에 추가하면 됩니다. (출처: https://docs.spring.io/spring-boot/appendix/test-auto-configuration/index.html)"
"Spring Boot에서 @…​Test auto-configuration annotations를 사용하면 어떤 이점이 있나요?","Spring Boot에서 @…​Test auto-configuration annotations를 사용하면 애플리케이션의 테스트 슬라이스를 쉽게 구성할 수 있고, 테스트 실행 시 필요한 구성 요소들을 자동으로 설정할 수 있습니다. (출처: https://docs.spring.io/spring-boot/appendix/test-auto-configuration/index.html)"
"Spring Boot에서 Data Cassandra 테스트를 위해 기본적으로 어떤 자동 구성이 가져와지나요?","Data Cassandra 테스트의 경우 기본적으로 org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration, org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration, org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration, org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration, org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration, org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration, org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration, org.springframework.boot.autoconfigure.ssl.SslAutoConfiguration이 가져와집니다. (출처: https://docs.spring.io/spring-boot/appendix/test-auto-configuration/slices.html)"
"Spring Boot에서 GraphQL 테스트를 위해 어떤 자동 구성이 기본적으로 가져와지나요?","GraphQL 테스트의 경우 기본적으로 org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration, org.springframework.boot.autoconfigure.graphql.GraphQlAutoConfiguration, org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration, org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration, org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration, org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration, org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration, org.springframework.boot.test.autoconfigure.graphql.tester.GraphQlTesterAutoConfiguration이 가져와집니다. (출처: https://docs.spring.io/spring-boot/appendix/test-auto-configuration/slices.html)"
"Spring Boot에서 Data Redis 테스트를 위한 테스트 슬라이스에 어떤 자동 구성이 기본적으로 가져와지나요?","Data Redis 테스트의 경우 기본적으로 org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration, org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration, org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration, org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration, org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration, org.springframework.boot.autoconfigure.ssl.SslAutoConfiguration이 가져와집니다. (출처: https://docs.spring.io/spring-boot/appendix/test-auto-configuration/slices.html)"
"Spring Boot에서 관리하는 의존성 버전에 대한 정보를 어디에서 찾을 수 있나요?","Spring Boot에서 관리하는 의존성 버전에 대한 정보는 부록 섹션에서 확인할 수 있습니다. (출처: <https://docs.spring.io/spring-boot/appendix/dependency-versions/index.html>)"
"Spring Boot의 의존성 버전에 대한 정보를 제공하는 문서의 정확한 URL은 무엇인가요?","Spring Boot의 의존성 버전에 대한 정보를 제공하는 문서의 정확한 URL은 <https://docs.spring.io/spring-boot/appendix/dependency-versions/index.html>입니다. (출처: <https://docs.spring.io/spring-boot/appendix/dependency-versions/index.html>)"
"Spring Boot의 의존성 버전에 대한 정보를 제공하는 문서의 섹션 이름은 무엇인가요?","Spring Boot의 의존성 버전에 대한 정보를 제공하는 문서의 섹션 이름은 'Dependency Versions'입니다. (출처: <https://docs.spring.io/spring-boot/appendix/dependency-versions/index.html>)"
"스프링 부트에서 logback-classic의 버전은 무엇인가요?","logback-classic의 버전은 1.5.8입니다. (출처: https://docs.spring.io/spring-boot/appendix/dependency-versions/coordinates.html)"
"스프링 부트에서 Elasticsearch Java 클라이언트의 버전은 무엇인가요?","Elasticsearch Java 클라이언트의 버전은 8.13.4입니다. (출처: https://docs.spring.io/spring-boot/appendix/dependency-versions/coordinates.html)"
"스프링 부트에서 Couchbase Java 클라이언트의 버전은 무엇인가요?","Couchbase Java 클라이언트의 버전은 3.6.3입니다. (출처: https://docs.spring.io/spring-boot/appendix/dependency-versions/coordinates.html)"
"Spring Boot에서 관리하는 라이브러리 버전을 재정의하기 위해 사용할 수 있는 속성은 무엇인가요?","Spring Boot에서 관리하는 라이브러리 버전을 재정의하기 위해 사용할 수 있는 속성은 https://docs.spring.io/spring-boot/appendix/dependency-versions/properties.html에서 확인할 수 있습니다."
"Spring Boot에서 관리하는 버전을 사용자 애플리케이션에서 커스터마이징하는 방법은 무엇인가요?","Spring Boot에서 관리하는 버전을 사용자 애플리케이션에서 커스터마이징하려면, https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins.html에서 Build Tool Plugins 문서를 참조하세요."
"Spring Boot의 라이브러리 버전 속성 중 일부는 무엇인가요?","Spring Boot의 라이브러리 버전 속성 중 일부는 activemq.version, angus-mail.version, artemis.version, aspectj.version, assertj.version, awaitility.version 등이 있습니다. 자세한 내용은 https://docs.spring.io/spring-boot/appendix/dependency-versions/properties.html에서 확인할 수 있습니다."
