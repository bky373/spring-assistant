"Spring AMQP 프로젝트가 무엇인가요?","Spring AMQP 프로젝트는 핵심 Spring 개념을 사용하여 AMQP 기반 메시징 솔루션을 개발하는 데 적용됩니다. 메시지 전송 및 수신을 위한 고수준 추상화인 '템플릿'을 제공하며, 메시지 기반 POJO를 지원합니다. 이러한 라이브러리는 AMQP 리소스의 관리를 용이하게 하고 의존성 주입 및 선언적 구성의 사용을 촉진합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/index.html)"
"Spring AMQP에서 메시지 기반 POJO란 무엇인가요?","메시지 기반 POJO는 메시지 기반 객체를 나타내는 일반적인 Java 객체입니다. Spring AMQP는 이러한 POJO를 지원하여 메시지 처리를 용이하게 합니다. (출처: https://docs.spring.io/spring-amqp/reference/html/amqp-basics.html#amqp-pojo-support)"
"Spring AMQP에서 AMQP 리소스 관리가 왜 중요한가요?","AMQP 리소스 관리는 Spring AMQP에서 중요한 역할을 합니다. 이는 메시징 시스템의 효율적이고 안정적인 운영을 보장하기 위해 필요합니다. Spring AMQP는 AMQP 리소스의 관리를 용이하게 하고, 의존성 주입 및 선언적 구성의 사용을 촉진하여 개발자가 리소스를 효율적으로 관리할 수 있도록 도와줍니다. (출처: https://docs.spring.io/spring-amqp/reference/html/amqp-basics.html#amqp-resource-management)"
"Spring AMQP 3.1 버전에서 변경된 내용은 무엇인가요?","Spring AMQP 3.1 버전은 Spring Framework 6.1과 Java 17을 필요로 하며, 독점 소비자와 관련된 로깅 변경 사항과 연결 공장을 사용하여 연결 채널을 생성할 때 백오프 정책을 지원하는 Connection Factory 개선 사항이 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/whats-new.html)"
"독점 소비자와 관련된 로깅 변경 사항은 어떤 것이 있나요?","독점 소비자와 관련된 액세스 거부로 인한 로그 메시지는 기본적으로 DEBUG 레벨로 기록됩니다. 소비자 재시작은 기본적으로 DEBUG 레벨로 기록됩니다. ConditionalExceptionLogger에 logRestart() 메서드가 추가되어 이를 변경할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/whats-new.html)"
"연결 공장을 사용하여 연결 채널을 생성할 때 백오프 정책을 지원하는 Connection Factory 개선 사항은 어떤 것이 있나요?","연결 공장은 연결 채널을 생성할 때 백오프 정책을 지원합니다. 자세한 내용은 Connection Factory 선택(amqp/connections.html)을 참조하세요. (출처: https://docs.spring.io/spring-amqp/reference/3.1/whats-new.html)"
"Spring AMQP란 무엇인가요?","Spring AMQP는 RabbitMQ와 같은 메시지 브로커와 상호 작용하기 위한 Java 라이브러리입니다. 이 라이브러리는 Spring 프레임워크와 함께 작동하며, 메시지 기반 비동기 통신을 구축하기 위한 높은 수준의 추상화를 제공합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/introduction/index.html)"
"Spring AMQP를 사용하는 이유는 무엇인가요?","Spring AMQP는 메시지 기반 비동기 통신을 구축하기 위한 간결하고 강력하며 유연한 API를 제공합니다. 이 라이브러리는 RabbitMQ의 주요 기능을 모두 지원하며, 기존 Spring 애플리케이션에 쉽게 통합할 수 있습니다. 또한, Spring AMQP는 트랜잭션, 재시도 및 고급 라우팅 시나리오를 처리하는 데 도움이 되는 다양한 기능을 제공합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/introduction/index.html)"
"Spring AMQP로 메시지를 보내는 방법은 무엇인가요?","Spring AMQP를 사용하여 메시지를 보내려면 RabbitTemplate 객체를 사용해야 합니다. RabbitTemplate은 RabbitMQ 브로커와 상호 작용하는 데 사용되는 고수준 추상화입니다. RabbitTemplate을 설정하고 send() 메서드를 사용하여 메시지를 보낼 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/htmlsingle/#amqp-rabbit-template)"
"Spring AMQP를 사용하기 위한 사전 요구사항은 무엇인가요?","RabbitMQ 브로커를 설치하고 실행한 후, spring-rabbit JAR와 해당 의존성을 추가해야 합니다. Maven의 경우, <dependency> <groupId>org.springframework.amqp</groupId> <artifactId>spring-rabbit</artifactId> <version>3.1.6</version> </dependency>와 같이 의존성을 선언할 수 있습니다. Gradle의 경우, compile 'org.springframework.amqp:spring-rabbit:3.1.6'와 같이 의존성을 선언할 수 있습니다."
"Spring AMQP를 사용하여 메시지를 보내고 받는 데 필요한 최소 버전은 무엇인가요?","Spring AMQP에서 메시지를 보내고 받는 데 필요한 최소 버전은 Spring Framework 6.1.0, amqp-client 5.18.0, stream-client 0.12.0입니다."
"Spring AMQP에서 XML 구성을 사용하여 메시지를 보내고 받는 방법은 무엇인가요?","Spring AMQP에서 XML 구성을 사용하여 메시지를 보내고 받으려면, RabbitAdmin, AmqpTemplate, Queue 등의 빈을 정의하는 XML 파일을 만들어야 합니다. 그런 다음, XML 파일을 참조하여 GenericXmlApplicationContext를 생성하고, 빈을 주입받아 메시지를 보내고 받을 수 있습니다."
"Spring AMQP 참조 문서에서 어떤 부분에서 AMQP 애플리케이션을 개발하기 위한 핵심 클래스를 다루나요?","메인 챕터(amqp.html)에서 AMQP 애플리케이션을 개발하기 위한 핵심 클래스를 다룹니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/reference.html)"
"Spring AMQP 참조 문서에서 샘플 애플리케이션에 대한 챕터는 어떤 부분에서 찾을 수 있나요?","샘플 애플리케이션에 대한 챕터는 sample-apps.html에서 찾을 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/reference.html)"
"Spring AMQP 참조 문서에서 Spring AMQP를 구성하는 다양한 구성 요소에 대한 자세한 정보를 어디에서 확인할 수 있나요?","Spring AMQP를 구성하는 다양한 구성 요소에 대한 자세한 정보는 참조 문서의 해당 부분에서 확인할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/reference.html)"
"Spring AMQP를 사용하여 RabbitMQ REST API에 액세스하는 방법은 무엇인가요?","Spring AMQP를 사용하여 RabbitMQ REST API에 액세스하려면, 먼저 RabbitMQ 관리 플러그인을 활성화하고 구성해야 합니다. 그런 다음, Spring AMQP의 RabbitAdmin 인스턴스를 사용하여 RabbitMQ 서버에 연결하고, RabbitMQ REST API를 사용하여 서버의 다양한 측면을 관리할 수 있습니다. RabbitMQ REST API에 대한 자세한 내용은 https://docs.spring.io/spring-amqp/reference/html/#amqp-management-rest-api를 참조하십시오."
"Spring AMQP에서 메시지 리스너 컨테이너를 구성하려면 어떻게 해야 하나요?","Spring AMQP에서 메시지 리스너 컨테이너를 구성하려면, @RabbitListener 어노테이션을 사용하여 리스너 메서드를 지정하고, 해당 메서드가 어떤 큐에 수신 대기할지를 지정해야 합니다. 또한, 메시지를 처리하는 데 사용되는 메시지 리스너 컨테이너의 속성을 구성하여, 동시성, 트랜잭션, 오류 처리 등의 다양한 측면을 제어할 수 있습니다. 메시지 리스너 컨테이너 구성에 대한 자세한 내용은 https://docs.spring.io/spring-amqp/reference/html/#amqp-container-attributes를 참조하십시오."
"Spring AMQP에서 RabbitMQ 클러스터를 구성하려면 어떻게 해야 하나요?","Spring AMQP에서 RabbitMQ 클러스터를 구성하려면, RabbitMQ 클러스터의 노드를 지정하는 URL을 사용하여 RabbitTemplate 또는 SimpleRabbitListenerContainerFactory를 구성해야 합니다. 또한, 클러스터 내의 노드가 장애 발생 시 자동으로 대체할 수 있도록 설정하고, 클러스터 내에서 큐와 교환기를 구성해야 합니다. RabbitMQ 클러스터 구성에 대한 자세한 내용은 https://docs.spring.io/spring-amqp/reference/html/#amqp-multi-rabbit를 참조하십시오."
"Spring AMQP의 두 가지 모듈은 무엇인가요?","Spring AMQP는 spring-amqp와 spring-rabbit 두 가지 모듈로 구성되어 있습니다."
"org.springframework.amqp.core 패키지는 어떤 내용을 포함하고 있나요?","org.springframework.amqp.core 패키지는 핵심 AMQP '모델'을 나타내는 클래스들을 포함하고 있습니다."
"Spring AMQP의 Message 클래스는 어떤 역할을 하나요?","Spring AMQP의 Message 클래스는 본문과 속성을 하나의 인스턴스 안에 캡슐화하여 API를 간소화하는 역할을 합니다."
"RabbitMQ 브로커에 대한 연결을 관리하는 중앙 구성 요소는 무엇인가요?","RabbitMQ 브로커에 대한 연결을 관리하는 중앙 구성 요소는 ConnectionFactory 인터페이스입니다. ConnectionFactory 구현체의 역할은 com.rabbitmq.client.Connection의 래퍼인 org.springframework.amqp.rabbit.connection.Connection의 인스턴스를 제공하는 것입니다."
"ConnectionFactory를 선택할 때 사용할 수 있는 팩토리 유형은 무엇인가요?","ConnectionFactory를 선택할 때 사용할 수 있는 세 가지 팩토리 유형은 다음과 같습니다: PooledChannelConnectionFactory, ThreadChannelConnectionFactory, CachingConnectionFactory. 대부분의 경우 CachingConnectionFactory를 사용해야 합니다."
"CachingConnectionFactory에서 채널 캐시 크기를 구성하는 방법은 무엇인가요?","CachingConnectionFactory에서 채널 캐시 크기를 구성하려면 setChannelCacheSize() 메서드를 호출하면 됩니다. 예를 들어 다음과 같이 설정할 수 있습니다: connectionFactory.setChannelCacheSize(50);"
"CachingConnectionFactory에서 커스텀 클라이언트 연결 속성을 어떻게 사용할 수 있나요?","CachingConnectionFactory는 이제 기본 연결 팩토리에 액세스하여, 예를 들어 커스텀 클라이언트 속성을 설정할 수 있습니다. 다음 예제는 이를 보여주는 방법입니다: connectionFactory.getRabbitConnectionFactory().getClientProperties().put('thing1', 'thing2'); 이러한 속성은 RabbitMQ 관리자 UI에서 연결을 볼 때 나타납니다. (출처: {https://docs.spring.io/spring-amqp/reference/3.1/amqp/custom-client-props.html})"
"Spring에서 커스텀 클라이언트 연결 속성을 사용하는 방법은 무엇인가요?","Spring에서는 CachingConnectionFactory.getRabbitConnectionFactory().getClientProperties().put() 메서드를 사용하여 커스텀 클라이언트 연결 속성을 설정할 수 있습니다. 이를 통해 RabbitMQ 관리자 UI에서 연결을 볼 때 커스텀 속성이 나타납니다. (출처: {https://docs.spring.io/spring-amqp/reference/3.1/amqp/custom-client-props.html})"
"커스텀 클라이언트 연결 속성을 설정하면 RabbitMQ 관리자 UI에 어떻게 표시되나요?","커스텀 클라이언트 연결 속성을 설정하면 RabbitMQ 관리자 UI에서 연결을 볼 때 해당 속성이 나타납니다. 이를 위해 CachingConnectionFactory.getRabbitConnectionFactory().getClientProperties().put() 메서드를 사용하여 속성을 설정해야 합니다. (출처: {https://docs.spring.io/spring-amqp/reference/3.1/amqp/custom-client-props.html})"
"Spring AMQP에서 'template'이란 무엇인가요?","Spring AMQP에서 'template'은 메시지를 보내고 받는 데 사용되는 중앙 역할을 하는 고수준 추상화입니다."
"Spring AMQP에서 RabbitTemplate을 사용하는 방법은 무엇인가요?","Spring AMQP에서 RabbitTemplate을 사용하려면 먼저 CachingConnectionFactory를 구성한 다음 RabbitTemplate을 만들고 connectionFactory 속성을 CachingConnectionFactory의 ID로 설정해야 합니다. 그런 다음 RabbitTemplate을 사용하여 메시지를 보내고 받을 수 있습니다."
"Spring AMQP에서 RetryTemplate을 RabbitTemplate에 추가하는 방법은 무엇인가요?","Spring AMQP에서 RetryTemplate을 RabbitTemplate에 추가하려면 RabbitTemplate에 retryTemplate 속성을 설정하고 retryTemplate 속성을 RetryTemplate의 ID로 설정해야 합니다. 그런 다음 RabbitTemplate을 사용하여 메시지를 보내고 받을 때 RetryTemplate을 사용할 수 있습니다."
"스프링 AMQP에서 메시지 전송 시 어떤 방법을 사용할 수 있나요?","스프링 AMQP에서 메시지 전송 시 void send(Message message) throws AmqpException, void send(String routingKey, Message message) throws AmqpException, void send(String exchange, String routingKey, Message message) throws AmqpException 세 가지 방법을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/htmlsingle/#sending-messages)"
"스프링 AMQP에서 RabbitTemplate을 사용하여 단일 큐로 주로 또는 전적으로 게시할 수 있는 템플릿을 만드는 방법은 무엇인가요?","스프링 AMQP에서 RabbitTemplate을 사용하여 단일 큐로 주로 또는 전적으로 게시할 수 있는 템플릿을 만들려면 RabbitTemplate 객체를 생성하고 setRoutingKey 메서드를 사용하여 템플릿의 기본 라우팅 키를 설정하면 됩니다. 그런 다음 send 메서드를 사용하여 새로운 Message 객체를 전달하여 해당 큐로 메시지를 보낼 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/htmlsingle/#sending-messages)"
"스프링 AMQP에서 MessageBuilder API를 사용하는 방법은 무엇인가요?","스프링 AMQP에서 MessageBuilder API를 사용하려면 MessageBuilder 및 MessagePropertiesBuilder를 사용하여 메시지 또는 메시지 속성을 편리하게 만들 수 있습니다. 각 속성 설정 메서드에는 set*IfAbsent() 변형이 있으며, 기본 초기 값이 있는 경우 set*IfAbsentOrDefault()로 명명됩니다. MessageBuilder에는 초기 메시지 빌더를 만들기 위해 제공되는 5가지 정적 메서드가 있으며, MessagePropertiesBuilder에는 초기 메시지 속성 빌더를 만들기 위해 제공되는 3가지 정적 메서드가 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/htmlsingle/#sending-messages)"
"Spring AMQP에서 메시지를 수신하는 방법은 무엇인가요?","Spring AMQP에서 메시지를 수신하는 방법은 두 가지가 있습니다. 첫 번째는 폴링 방식이며, 두 번째는 비동기식 리스너를 사용하는 방식입니다. 폴링 방식은 한 번에 하나의 메시지를 가져오는 간단한 방법이지만, 비동기식 리스너를 사용하는 방식이 더 복잡하지만 더 일반적으로 사용됩니다. 자세한 내용은 다음 링크를 참조하십시오: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages.html"
"Spring AMQP에서 비동기식 리스너를 설정하는 방법은 무엇인가요?","Spring AMQP에서 비동기식 리스너를 설정하는 방법은 여러 가지가 있습니다. 예를 들어, @RabbitListener 어노테이션을 사용하여 리스너 엔드포인트를 구성할 수 있습니다. 또한, 배치 처리를 사용하여 메시지를 처리할 수도 있습니다. 자세한 내용은 다음 링크를 참조하십시오: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages.html"
"Spring AMQP에서 메시지 처리를 위한 컨테이너 팩토리를 사용하는 방법은 무엇인가요?","Spring AMQP에서 메시지 처리를 위한 컨테이너 팩토리를 사용하는 방법은 @RabbitListener 어노테이션을 사용하여 리스너 엔드포인트를 구성할 때, 컨테이너 팩토리 빈을 참조하는 것입니다. 이를 통해 메시지 처리를 위한 컨테이너를 생성하고 관리할 수 있습니다. 자세한 내용은 다음 링크를 참조하십시오: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages.html"
"Spring AMQP에서 비동기 소비자를 설정하는 가장 편리한 방법은 무엇인가요?","Spring AMQP에서 @RabbitListener 어노테이션을 사용하여 비동기 소비자를 설정하는 것이 가장 편리한 방법입니다. 자세한 내용은 Annotation-driven Listener Endpoints(async-annotation-driven.html) 문서를 참조하십시오. (출처: <https://docs.spring.io/spring-amqp/reference/html/#receiving-messages-async-consumer>)"
"Spring AMQP에서 prefetch 값의 기본값은 얼마인가요?","Spring AMQP에서 prefetch 값의 기본값은 250입니다. 이는 버전 2.0부터 적용되었으며, 이전에는 1이었습니다. prefetch 값은 효율적인 소비자 활용을 위해 1로 설정해야 하는 경우도 있습니다. (출처: <https://docs.spring.io/spring-amqp/reference/html/#receiving-messages-async-consumer>)"
"Spring AMQP에서 MessageListenerAdapter의 용도는 무엇인가요?","MessageListenerAdapter는 애플리케이션 코드를 메시징 시스템과 통합하는 데 사용됩니다. 애플리케이션 로직과 메시징 API 간의 분리를 유지하면서 더 유연한 POJO 메시징 메커니즘을 제공합니다. 이 어댑터는 프레임워크에서 제공되며, 인스턴스에 대한 참조만 제공하면 됩니다. (출처: <https://docs.spring.io/spring-amqp/reference/html/#receiving-messages-message-listener>)"
"Spring RabbitMQ에서 배치 메시지는 어떻게 생성되나요?","Spring RabbitMQ에서 배치 메시지는 프로듀서에 의해 생성됩니다. 배치 메시지는 여러 개의 개별 메시지를 하나의 단위로 묶어서 전송하는 것을 의미합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/de-batching.html)"
"Spring RabbitMQ에서 리스너 컨테이너는 어떻게 배치 메시지를 처리하나요?","Spring RabbitMQ에서 리스너 컨테이너는 자동으로 배치 메시지를 해체합니다. 이를 위해 springBatchFormat 메시지 헤더를 사용합니다. 배치의 어떤 메시지가 거부되면 전체 배치가 거부됩니다. 배치에 대한 자세한 내용은 Batching(../sending-messages.html#template-batching)을 참조하십시오. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/de-batching.html)"
"Spring RabbitMQ에서 소비자는 어떻게 배치 메시지를 생성할 수 있나요?","Spring RabbitMQ에서 SimpleMessageListenerContainer를 사용하여 소비자 측에서 배치를 생성할 수 있습니다. 이 기능을 사용하려면 container 속성 consumerBatchEnabled를 활성화해야 합니다. deBatchingEnabled도 true로 설정해야 합니다. 이렇게 하면 컨테이너가 두 종류의 배치 처리를 담당하게 됩니다. consumerBatchEnabled가 true인 경우 BatchMessageListener 또는 ChannelAwareBatchMessageListener를 구현하십시오. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/de-batching.html)"
"Spring AMQP에서 리스너 컨테이너 소비자 실패 이벤트는 어떤 경우에 발생하나요?","Spring AMQP에서 리스너 컨테이너 소비자 실패 이벤트는 리스너(소비자)가 어떤 종류의 실패를 경험할 때마다 발생합니다. 이러한 이벤트는 ListenerContainerConsumerFailedEvent 클래스로 표현되며, container, reason, fatal, throwable 등의 속성을 가지고 있습니다. 이러한 이벤트는 ApplicationListener<ListenerContainerConsumerFailedEvent>를 구현하여 처리할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/consumer-events.html)"
"Spring AMQP에서 리스너 컨테이너 소비자 실패 이벤트는 어떤 경우에 치명적인(fatal) 것으로 간주되나요?","Spring AMQP에서 리스너 컨테이너 소비자 실패 이벤트는 fatal 속성이 true로 설정된 경우에 치명적인(fatal) 것으로 간주됩니다. 이러한 경우 이벤트는 ERROR 레벨로 로그되며, 로그 레벨을 변경할 수 없습니다. 비 치명적인 예외의 경우 컨테이너는 restart 메커니즘을 따라 소비자를 다시 시작하려고 시도합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/consumer-events.html)"
"Spring AMQP에서 리스너 컨테이너 소비자 실패 이벤트는 어떤 경우에 디버그(DEBUG) 레벨로 로그되나요?","Spring AMQP에서 리스너 컨테이너 소비자 실패 이벤트는 소비자가 독점적으로 사용하는 큐 중 하나 때문에 실패한 경우, 기본적으로 DEBUG 레벨로 로그됩니다. 이러한 로그 레벨은 3.1 버전부터 적용되었으며, 이전에는 WARN 레벨로 로그되었습니다. 로그 동작을 변경하려면 AbstractMessageListenerContainer 인스턴스의 exclusiveConsumerExceptionLogger 속성에 사용자 지정 ConditionalExceptionLogger를 제공하면 됩니다. 또한, SimpleMessageListenerContainer에서 이러한 예외 후 소비자 재시작은 기본적으로 DEBUG 레벨로 로그됩니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/consumer-events.html)"
"소비자 태그는 어떻게 생성되나요?","소비자 태그는 기본적으로 브로커에 의해 생성됩니다. 그러나 소비자 태그 전략을 제공하여 소비자 태그를 생성할 수 있습니다. ConsumerTagStrategy 인터페이스는 String createConsumerTag(String queue) 메서드를 포함합니다. 큐는 (선택적으로) 태그에 사용될 수 있도록 제공됩니다. 자세한 내용은 Message Listener Container Configuration을 참조하세요."
"ConsumerTagStrategy 인터페이스의 정의는 무엇인가요?","ConsumerTagStrategy 인터페이스는 public interface ConsumerTagStrategy { String createConsumerTag(String queue); }로 정의됩니다. 이 인터페이스는 queue 매개변수를 사용하여 소비자 태그를 생성하는 createConsumerTag 메서드를 포함합니다. 이 메서드는 소비자 태그를 나타내는 String을 반환합니다."
"ConsumerTagStrategy 인터페이스는 어떤 용도로 사용되나요?","ConsumerTagStrategy 인터페이스는 소비자 태그를 생성하는 전략을 제공하는 데 사용됩니다. 이 인터페이스는 기본적으로 브로커에 의해 생성되는 소비자 태그를 사용자 정의할 수 있습니다. 이 인터페이스는 사용자 정의 태그를 생성하기 위한 구체적인 구현을 제공하는 데 사용될 수 있습니다."
"Spring에서 @RabbitListener 어노테이션을 사용하려면 어떻게 해야 하나요?","Spring에서 @RabbitListener 어노테이션을 사용하려면 @EnableRabbit 어노테이션을 @Configuration 클래스 중 하나에 추가해야 합니다. 다음은 이를 수행하는 예시입니다: @Configuration 및 @EnableRabbit을 public class AppConfig {...}에 추가하면 됩니다. (출처: https://docs.spring.io/spring-amqp/reference/htmlsingle/)"
"SimpleRabbitListenerContainerFactory와 DirectRabbitListenerContainerFactory 중 어떤 것을 선택해야 하나요?","SimpleRabbitListenerContainerFactory와 DirectRabbitListenerContainerFactory 중 어떤 것을 선택해야 하는지는 사용 사례에 따라 다릅니다. Spring의 AMQP 문서의 'Choosing a Container' 섹션에서 자세한 정보를 찾을 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/htmlsingle/)"
"Spring에서 RabbitMQ 리스너 컨테이너 팩토리를 사용자 정의하려면 어떻게 해야 하나요?","Spring에서 RabbitMQ 리스너 컨테이너 팩토리를 사용자 정의하려면 RabbitListenerConfigurer 인터페이스를 구현하면 됩니다. 이를 통해 각 어노테이션에 대해 사용할 수 있는 리스너 컨테이너 팩토리를 사용자 정의하거나 명시적인 기본 설정을 구성할 수 있습니다. 자세한 내용과 예시는 JavaDoc를 참조하십시오. (출처: https://docs.spring.io/spring-amqp/reference/htmlsingle/)"
"Spring AMQP의 메시지 변환 파이프라인에서 리스너를 호출하기 전에 어떤 단계가 포함되나요?","Spring AMQP의 메시지 변환 파이프라인에는 리스너를 호출하기 전에 두 가지 변환 단계가 포함됩니다. 첫 번째 단계는 MessageConverter를 사용하여 들어오는 Spring AMQP 메시지를 Spring-messaging Message로 변환합니다. 두 번째 단계는 필요한 경우 메시지 페이로드를 메서드 매개변수 유형으로 변환합니다."
"Spring AMQP의 메시지 변환 파이프라인에서 첫 번째 단계의 기본 MessageConverter는 무엇인가요?","Spring AMQP의 메시지 변환 파이프라인에서 첫 번째 단계의 기본 MessageConverter는 Spring AMQP SimpleMessageConverter입니다. 이 변환기는 String 및 java.io.Serializable 객체로 변환을 처리하며, 다른 모든 객체는 byte[]로 유지됩니다."
"Spring AMQP에서 메시지 변환기를 사용자 정의하려면 어떻게 해야 하나요?","Spring AMQP에서 메시지 변환기를 사용자 정의하려면 컨테이너 팩토리 빈에 속성으로 추가할 수 있습니다. 다음 예제에서는 SimpleRabbitListenerContainerFactory 빈에 Jackson2JsonMessageConverter를 설정하는 방법을 보여줍니다: @Bean public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); ... factory.setMessageConverter(new Jackson2JsonMessageConverter()); ... return factory; }"
"Spring AMQP(RabbitMQ)에서 @RabbitListener에 사용자 정의 HandlerMethodArgumentResolver를 추가하는 방법은 무엇인가요?","RabbitListenerConfigurer를 구현하고 RabbitListenerEndpointRegistrar의 setCustomMethodArgumentResolvers() 메서드를 사용하여 사용자 정의 HandlerMethodArgumentResolver를 추가할 수 있습니다. RabbitListenerConfigurer 인터페이스를 구현하고 configureRabbitListeners() 메서드를 재정의하는 CustomRabbitConfig 클래스를 생성합니다. 이 메서드 내에서 registrar.setCustomMethodArgumentResolvers()를 호출하고 사용자 정의 HandlerMethodArgumentResolver 인스턴스를 전달합니다. 이 해결자는 RabbitListener 메서드의 사용자 정의 매개변수를 해결할 수 있습니다. (출처: <https://docs.spring.io/spring-amqp/reference/html/#amqp-receiving-messages-async-annotation-driven-custom-argument-resolver>)"
"Spring AMQP(RabbitMQ)에서 사용자 정의 HandlerMethodArgumentResolver를 구현하는 방법은 무엇인가요?","HandlerMethodArgumentResolver 인터페이스를 구현하고 supportsParameter() 및 resolveArgument() 메서드를 재정의합니다. supportsParameter() 메서드에서는 해결자가 해결할 수 있는 매개변수 유형을 반환합니다. resolveArgument() 메서드에서는 전달된 매개변수와 메시지를 기반으로 실제 해결된 값을 반환합니다. (출처: <https://docs.spring.io/spring-amqp/reference/html/#amqp-receiving-messages-async-annotation-driven-custom-argument-resolver>)"
"Spring AMQP(RabbitMQ)에서 사용자 정의 HandlerMethodArgumentResolver를 구성하는 방법은 무엇인가요?","RabbitListenerConfigurer를 구현하는 클래스를 생성하고 configureRabbitListeners() 메서드를 재정의합니다. 이 메서드 내에서 registrar.setCustomMethodArgumentResolvers()를 호출하고 사용자 정의 HandlerMethodArgumentResolver 인스턴스를 전달합니다. 이렇게 하면 사용자 정의 HandlerMethodArgumentResolver가 RabbitListener 메서드 매개변수를 해결하는 데 사용됩니다. (출처: <https://docs.spring.io/spring-amqp/reference/html/#amqp-receiving-messages-async-annotation-driven-custom-argument-resolver>)"
"RabbitListenerEndpoint는 무엇이며 어떤 역할을 하나요?","RabbitListenerEndpoint는 RabbitMQ 엔드포인트의 모델을 제공하고 해당 모델에 대한 컨테이너를 구성하는 역할을 합니다. 또한, RabbitListener 어노테이션에 의해 감지되는 엔드포인트 외에도 프로그래밍 방식으로 엔드포인트를 구성할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/async-annotation-driven/registration.html)"
"RabbitMQ에서 프로그래밍 방식으로 엔드포인트를 구성하는 방법은 무엇인가요?","RabbitMQ에서 프로그래밍 방식으로 엔드포인트를 구성하려면 RabbitListenerConfigurer를 구현하고 configureRabbitListeners 메서드를 사용하여 SimpleRabbitListenerEndpoint 인스턴스를 생성하고 queueNames 및 messageListener를 설정한 다음 registrar.registerEndpoint 메서드를 사용하여 엔드포인트를 등록해야 합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/async-annotation-driven/registration.html)"
"RabbitMQ에서 사용자 정의 호출 메커니즘을 설명하는 방법은 무엇인가요?","RabbitMQ에서 사용자 정의 호출 메커니즘을 설명하려면 SimpleRabbitListenerEndpoint를 사용하는 대신 사용자 정의 엔드포인트 변형을 빌드하여 사용자 정의 호출 메커니즘을 설명할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/async-annotation-driven/registration.html)"
"RabbitMQ에서 @RabbitListener에 대한 주석된 엔드포인트 메소드 시그니처는 어떻게 사용할 수 있나요?","주석된 엔드포인트 메소드 시그니처는 메시지 속성, 헤더 및 페이로드를 포함하여 다양한 인자를 주입할 수 있습니다. 또한 @Header 및 @Headers 주석을 사용하여 특정 헤더 값 및 모든 헤더에 액세스할 수 있습니다. DefaultMessageHandlerMethodFactory를 사용자 정의하여 추가 매개 변수를 지원할 수도 있습니다."
"Spring RabbitMQ에서 주석된 엔드포인트 메소드 시그니처에 변환 및 유효성 검사 지원을 추가하는 방법은 무엇인가요?","DefaultMessageHandlerMethodFactory를 사용하여 변환 및 유효성 검사 지원을 사용자 정의할 수 있으며, 이를 통해 메시지와 페이로드를 특정 객체로 변환하고 유효성을 검사할 수 있습니다. 예를 들어, @Valid를 사용하여 페이로드가 처리되기 전에 유효한지 확인할 수 있습니다."
"Spring RabbitMQ에서 @RabbitListener에 대한 메소드 인자 처리는 어떻게 이루어지나요?","메소드 인자 처리는 DefaultMessageHandlerMethodFactory에 의해 제공되며, Message, MessageProperties, Message<?>, Channel, Header, Headers 및 페이로드와 같은 다양한 인자를 매개 변수와 일치시킬 수 있습니다. 또한 @Payload 및 @Valid와 같은 주석을 사용하여 페이로드를 명시적으로 일치시키고 유효성 검사를 활성화할 수 있습니다."
"Spring에서 여러 개의 큐를 수신하는 방법은 무엇인가요?","Spring에서는 queues 속성을 사용하여 연관된 컨테이너가 여러 개의 큐를 수신할 수 있도록 지정할 수 있습니다. @Header 어노테이션을 사용하여 메시지가 수신된 큐 이름을 POJO 메서드에서 사용할 수 있습니다."
"Spring에서 버전 1.5부터 큐 이름을 외부화하는 방법은 무엇인가요?","Spring에서는 버전 1.5부터 property placeholders와 SpEL을 사용하여 큐 이름을 외부화할 수 있습니다. queues 속성에 property placeholders를 사용하여 쉼표로 구분된 큐 이름을 지정할 수 있습니다."
"Spring에서 버전 1.5 이전에는 여러 개의 큐를 지정하는 방법이 어떻게 되었나요?","Spring에서 버전 1.5 이전에는 이 방법으로 단일 큐만 지정할 수 있었습니다. 각 큐마다 별도의 속성이 필요했습니다."
"Spring에서 MessageListenerAdapter가 메소드의 반환 타입이 void가 아닌 경우 어떻게 동작하나요?","메소드의 반환 타입이 void가 아닌 경우, 호출 결과는 원래 메시지의 ReplyToAddress 헤더에 지정된 주소 또는 리스너에 구성된 기본 주소로 전송됩니다. 이 기본 주소는 messaging abstraction의 @SendTo 어노테이션을 사용하여 설정할 수 있습니다. 예를 들어, processOrder 메소드가 OrderStatus를 반환하도록 변경하려면 다음과 같이 작성할 수 있습니다: @RabbitListener(destination = 'myQueue') @SendTo('status') public OrderStatus processOrder(Order order) { // order processing return status; }"
"Spring에서 추가 헤더를 transport-independent한 방식으로 설정하는 방법은 무엇인가요?","MessagePostProcessor를 사용하여 추가 헤더를 설정할 수 있습니다. 예를 들어, 다음과 같이 작성할 수 있습니다: @RabbitListener(destination = 'myQueue') @SendTo('status') public Message<OrderStatus> processOrder(Order order) { // order processing return MessageBuilder .withPayload(status) .setHeader('code', 1234) .build(); } 또는 MessagePostProcessor를 사용하여 더 많은 헤더를 추가할 수 있습니다. factory.setBeforeSendReplyPostProcessors(msg -> { msg.getMessageProperties().setHeader('calledBean', msg.getMessageProperties().getTargetBean().getClass().getSimpleName()); msg.getMessageProperties().setHeader('calledMethod', msg.getMessageProperties().getTargetMethod().getName()); return m; });"
"Spring에서 reply 메시지 패턴을 설정하는 방법은 무엇인가요?","@SendTo 값은 reply exchange와 routingKey 쌍으로 가정됩니다. 이 부분 중 하나는 생략할 수 있습니다. 유효한 값은 다음과 같습니다: thing1/thing2 : replyTo exchange와 routingKey. thing1/ : replyTo exchange와 default (빈 문자열) routingKey. thing2 또는 /thing2 : replyTo routingKey와 default (빈 문자열) exchange. / 또는 빈 문자열: replyTo default exchange와 default routingKey. 또한, @SendTo는 value 속성을 사용하지 않고 사용할 수 있습니다. 이 경우, 빈 sendTo 패턴과 동일합니다. @SendTo는 inbound 메시지에 replyToAddress 속성이 없는 경우에만 사용됩니다."
"리플라이 컨텐트 타입과 converterWinsContentType의 목적은 무엇인가요?","리플라이 컨텐트 타입과 converterWinsContentType은 Spring AMQP에서 리플라이 메시지의 컨텐트 타입을 제어하는 데 사용됩니다. 리플라이 컨텐트 타입은 리스너의 replyContentType 속성을 통해 지정되며, converterWinsContentType은 변환기가 설정한 컨텐트 타입이 우세한지 여부를 결정합니다."
"SimpleMessageConverter는 리플라이 유형을 어떻게 결정하나요?","SimpleMessageConverter는 리플라이 유형을 결정하기 위해 리플라이 메시지의 컨텐트 타입을 사용합니다. 변환기가 설정한 컨텐트 타입이 우세한지 여부는 converterWinsContentType 속성에 따라 결정됩니다."
"Spring AMQP Message 또는 Spring Messaging Message를 반환할 때 어떤 속성이 적용되지 않나요?","@RabbitListener 어노테이션의 replyContentType 및 converterWinsContentType 속성은 Spring AMQP Message 또는 Spring Messaging Message<?>를 반환할 때 적용되지 않습니다. 이 경우 메시지 헤더를 사용하여 동작을 제어합니다."
"Spring AMQP에서 클래스 수준의 @RabbitListener와 @RabbitHandler 어노테이션을 사용하면 어떤 이점이 있나요?","Spring AMQP에서 클래스 수준의 @RabbitListener와 @RabbitHandler 어노테이션을 사용하면 들어오는 메시지의 페이로드 타입에 따라 단일 리스너가 다른 메서드를 호출할 수 있습니다. 이는 Thing2, Cat 또는 Hat과 같은 변환된 페이로드와 일치하는 개별 @RabbitHandler 메서드가 호출됩니다. (출처: <https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/async-annotation-driven/method-selection.html>)"
"Spring AMQP에서 @RabbitHandler 어노테이션이 있는 메서드의 메서드 시그니처는 어떻게 되나요?","Spring AMQP에서 @RabbitHandler 어노테이션이 있는 메서드의 메서드 시그니처는 클래스 수준의 @RabbitListener가 있는 메서드와 동일합니다. (출처: <https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/async-annotation-driven/method-selection.html>)"
"Spring AMQP에서 @RabbitHandler 어노테이션의 isDefault 속성은 어떤 역할을 하나요?","Spring AMQP에서 @RabbitHandler 어노테이션의 isDefault 속성은 다른 메서드와의 일치가 없을 경우 호출되는 기본 메서드로 지정된 메서드를 나타냅니다. 한 번에 하나의 메서드만 지정할 수 있습니다. (출처: <https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/async-annotation-driven/method-selection.html>)"
"Spring AMQP에서 @RabbitListener 어노테이션은 언제부터 반복 가능한 어노테이션으로 표시되었나요?","Spring AMQP에서 @RabbitListener 어노테이션은 버전 1.6부터 반복 가능한 어노테이션으로 표시되었습니다. (출처: https://docs.spring.io/spring-amqp/reference/html/#receiving-messages-async-annotation-driven-repeatable-rabbit-listener)"
"반복 가능한 @RabbitListener 어노테이션을 사용하면 어떤 이점이 있나요?","반복 가능한 @RabbitListener 어노테이션을 사용하면 동일한 어노테이션된 요소(메소드 또는 클래스)에 여러 개의 @RabbitListener 어노테이션을 적용할 수 있습니다. 이 경우, 각 어노테이션마다 별도의 리스너 컨테이너가 생성되며, 각각은 동일한 리스너 @Bean을 호출합니다. 이를 통해 더 유연하고 세밀한 메시지 리스닝 구성이 가능해집니다. (출처: https://docs.spring.io/spring-amqp/reference/html/#receiving-messages-async-annotation-driven-repeatable-rabbit-listener)"
"반복 가능한 @RabbitListener 어노테이션을 사용하려면 어떤 버전의 Java가 필요한가요?","반복 가능한 @RabbitListener 어노테이션은 Java 8 이상을 사용하여 사용할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/html/#receiving-messages-async-annotation-driven-repeatable-rabbit-listener)"
"Spring에서 @RabbitListener와 제네릭을 사용하는 프록시 서비스에 대해 어떤 고려사항이 필요한가요?","인자가 있는 제네릭 매개변수를 사용하는 인터페이스를 가진 프록시 서비스의 경우, CGLIB 대상 클래스 프록시로 전환해야 합니다. 이 경우 @EnableTransactionManagement(proxyTargetClass = true)로 구성됩니다. 또한, 모든 어노테이션은 구현 클래스의 대상 메서드에 선언되어야 합니다."
"CGLIB 대상 클래스 프록시는 Spring에서 어떤 상황에서 사용되나요?","CGLIB 대상 클래스 프록시는 @RabbitListener와 같은 어노테이션을 인터페이스의 구현 클래스에서 사용하는 경우 사용됩니다. 이 경우, 구현 클래스의 실제 메서드 구현은 브리지 메서드입니다."
"Spring에서 CGLIB 프록시를 사용할 때, 어떤 어노테이션을 구현 클래스의 대상 메서드에 선언해야 하나요?","Spring에서 CGLIB 프록시를 사용할 때, 모든 어노테이션을 구현 클래스의 대상 메서드에 선언해야 합니다. 이는 @RabbitListener 어노테이션의 경우이며, 다른 어노테이션도 해당될 수 있습니다."
"Spring의 RabbitMQ에서 RabbitListenerErrorHandler를 구현하는 방법은 무엇인가요?","RabbitListenerErrorHandler를 구현하려면 해당 인터페이스의 handleError 메서드를 구현해야 합니다. 이 메서드는 받은 메시지, Spring 메시징 메시지 객체, 그리고 발생한 예외를 매개변수로 받습니다. 이 메서드에서는 예외 처리를 수행하고, 결과를 반환하거나 예외를 다시 던질 수 있습니다. 결과는 리플라이로 보내지고, 예외는 컨테이너에 던져지거나, returnExceptions 설정에 따라 발신자에게 반환됩니다. RabbitListenerErrorHandler 인터페이스는 o.s.amqp.rabbit.listener.api 패키지에 위치해 있습니다."
"Spring의 RabbitMQ에서 메시지에 대한 예외 처리를 하지 않으면 어떤 일이 발생하나요?","Spring의 RabbitMQ에서 메시지에 대한 예외 처리를 하지 않으면, 예외는 컨테이너에 던져집니다. 그리고 메시지는 재등록되어 다시 전달되거나, 삭제되거나, 데드 레터 교환으로 라우팅됩니다. 이는 컨테이너와 브로커 구성에 따라 달라집니다. 예외 처리 없이 메시지를 처리하면, 발신자에게는 아무런 결과도 반환되지 않습니다."
"Spring의 RabbitMQ에서 returnExceptions 설정은 어떤 역할을 하나요?","Spring의 RabbitMQ에서 returnExceptions 설정은 예외를 발신자에게 반환할지 여부를 결정합니다. 이 설정이 true로 설정되면, 예외는 발신자에게 RemoteInvocationResult 객체로 반환됩니다. 발신자 측에서는 RabbitTemplate에 RemoteInvocationAwareMessageConverterAdapter를 구성하여, 서버 측 예외를 AmqpRemoteException으로 다시 던질 수 있습니다. 서버 측 예외의 스택 트레이스는 서버 측과 클라이언트 측의 스택 트레이스를 병합하여 합성됩니다."
"Spring의 @RabbitListener에서 어떤 비동기 반환 유형이 지원되나요?","Spring의 @RabbitListener에서는 CompletableFuture<?>와 Mono<?>를 비동기 반환 유형으로 사용할 수 있습니다. (출처: <https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/async-returns.html>)"
"Spring에서 ListenableFuture<?>는 여전히 지원되나요?","Spring에서는 ListenableFuture<?>가 더 이상 지원되지 않으며, Spring Framework에서 사용되지 않습니다. (출처: <https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/async-returns.html>)"
"Spring의 @RabbitListener에서 비동기 처리를 위해 리스너 컨테이너 팩토리를 어떻게 구성해야 하나요?","Spring의 @RabbitListener에서 비동기 처리를 위해 리스너 컨테이너 팩토리를 AcknowledgeMode.MANUAL로 구성해야 합니다. (출처: <https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/async-returns.html>)"
"DirectMessageListenerContainer(DMLC)가 SimpleMessageListenerContainer(SMLC)와 비교했을 때 어떤 장점을 가지고 있나요?","DMLC는 런타임 시 큐를 추가하고 제거하는 것이 더 효율적이며, 영향을 받지 않는 소비자를 취소하지 않습니다. 또한, RabbitMQ 클라이언트 스레드와 소비자 스레드 간의 컨텍스트 스위치가 발생하지 않으며, 스레드를 공유하여 사용합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/choose-container.html)"
"SimpleMessageListenerContainer(SMLC)에서 batchSize 속성은 어떤 용도로 사용되나요?","batchSize 속성은 SMLC에서 트랜잭션으로 전달되는 메시지 수를 제어하거나, 확인 응답 수를 줄이는 데 사용할 수 있습니다. 그러나 실패 후 중복 전달 수가 증가할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/choose-container.html)"
"DirectMessageListenerContainer(DMLC)에서 어떤 기능을 사용할 수 없나요?","DMLC에서는 최대 동시 소비자, 소비자 스케일링 간격 또는 트리거와 같은 기능을 사용할 수 없습니다. 또한, batchSize 및 consumerBatchEnabled와 같은 SMLC의 일부 기능도 사용할 수 없습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/choose-container.html)"
"Spring의 ListenerContainerIdleEvent 기능은 어떤 용도로 사용되며, 언제 발생하나요?","Spring의 ListenerContainerIdleEvent 기능은 비동기 소비자를 모니터링하고, 메시지 전달이 없는 경우 일정 시간이 지나면 ListenerContainerIdleEvent를 게시합니다. 이 기능은 1.6 버전부터 사용할 수 있으며, idleEventInterval을 설정하여 일정 시간 동안 메시지가 전달되지 않을 때 이벤트를 발생시킬 수 있습니다."
"Spring에서 ListenerContainerIdleEvent를 수신하기 위해 어떻게 ApplicationListener를 구현할 수 있나요?","Spring에서 ListenerContainerIdleEvent를 수신하기 위해 ApplicationListener를 구현하거나, Spring Framework 4.2에서 도입된 @EventListener를 사용할 수 있습니다. @RabbitListener와 @EventListener 어노테이션을 하나의 클래스에 결합하여 사용할 수도 있습니다. 이벤트 리스너는 모든 컨테이너에 대한 이벤트를 수신하므로, 특정 컨테이너에 대한 작업을 수행하려면 리스너 ID를 확인해야 할 수 있습니다."
"ListenerContainerIdleEvent를 사용하여 리스너 컨테이너를 중지하는 경우 어떤 주의사항이 있나요?","ListenerContainerIdleEvent를 사용하여 리스너 컨테이너를 중지할 때는 리스너를 호출하는 스레드에서 container.stop()을 호출하지 않아야 합니다. 대신, 이벤트를 다른 스레드로 전달하여 컨테이너를 중지해야 합니다. 이렇게 하면 지연 및 불필요한 로그 메시지를 방지할 수 있습니다."
"Spring Amqp에서 Micrometer를 통합하려면 어떤 버전에서부터 지원되나요?","2.2 버전부터 지원됩니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/micrometer.html)"
"Micrometer Timer를 생성하고 업데이트하기 위해 어떤 조건이 충족되어야 하나요?","Micrometer가 클래스패스에 감지되고, 애플리케이션 컨텍스트에 단일 MeterRegistry가 존재해야 합니다. (또는 Spring Boot를 사용할 때와 같이 정확히 하나가 @Primary로 주석 처리되어야 합니다.) (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/micrometer.html)"
"Micrometer Timer를 비활성화하려면 어떤 컨테이너 속성을 설정해야 하나요?","micrometerEnabled 컨테이너 속성을 false로 설정해야 합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/micrometer.html)"
"Spring RabbitMQ에서 Micrometer 관찰을 지원하는 버전은 무엇인가요?","Spring RabbitMQ는 3.0 버전부터 Micrometer 관찰을 지원합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/micrometer-observation.html)"
"RabbitTemplate 및 리스너 컨테이너에서 관찰을 활성화하려면 어떻게 해야 하나요?","각 컴포넌트에서 observationEnabled를 설정하여 관찰을 활성화할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/micrometer-observation.html)"
"RabbitMQ와 함께 Micrometer 관찰을 사용할 때 Timers를 비활성화하는 방법은 무엇인가요?","observationEnabled를 설정하면 Micrometer Timers가 비활성화되고 각 관찰로 타이머가 관리됩니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/receiving-messages/micrometer-observation.html)"
"Spring의 RabbitTemplate에서 MessageConverter는 어떤 역할을 하나요?","MessageConverter는 RabbitTemplate에서 메시지를 변환하는 역할을 합니다. 메시지 변환은 메시지를 Message로 변환하고, Message로부터 객체를 변환하는 기능을 제공합니다. 이를 통해 다양한 데이터 형식을 지원하며, RabbitMQ와의 통신을 용이하게 만들어줍니다."
"Spring의 RabbitTemplate에서 메시지를 보낼 때 MessageConverter를 사용하는 이유는 무엇인가요?","메시지를 보낼 때 MessageConverter를 사용하는 이유는 메시지를 RabbitMQ와의 통신에 적합한 형식으로 변환하기 위해서입니다. 이를 통해 다양한 데이터 형식을 지원하며, RabbitMQ와의 통신을 용이하게 만들어줍니다."
"Spring의 RabbitTemplate에서 SimpleMessageConverter는 어떤 역할을 하나요?","SimpleMessageConverter는 RabbitTemplate에서 메시지를 변환하는 데 사용되는 기본 구현체입니다. 텍스트 기반 콘텐츠, 직렬화된 Java 객체 및 바이트 배열을 처리합니다. 이를 통해 다양한 데이터 형식을 지원하며, RabbitMQ와의 통신을 용이하게 만들어줍니다."
"RabbitMQ에서 메시지를 압축하기 위해 사용할 수 있는 Spring 통합 구성 요소는 무엇인가요?","GZipPostProcessor, ZipPostProcessor 및 DeflaterPostProcessor는 메시지를 보내기 전에 압축하고, GUnzipPostProcessor, UnzipPostProcessor 및 InflaterPostProcessor는 수신된 메시지를 압축 해제합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/post-processing.html)"
"RabbitTemplate에서 압축 전 및 후 처리기를 추가하는 방법은 무엇인가요?","RabbitTemplate의 addBeforePublishPostProcessors() 및 addAfterReceivePostProcessors() 메서드를 사용하여 각각 전송 전 및 수신 후 처리기 목록에 새 처리기를 추가할 수 있습니다. 또한 처리기를 제거하는 메서드도 제공됩니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/post-processing.html)"
"RabbitMQ에서 압축된 메시지의 원본 메시지 속성을 유지하려면 어떻게 해야 하나요?","GZipPostProcessor의 copyProperties = true 옵션을 구성하여 원본 메시지 속성의 복사본을 만들 수 있습니다. 기본적으로 이러한 속성은 성능상의 이유로 재사용되며 압축 콘텐츠 인코딩 및 선택적 MessageProperties.SPRING_AUTO_DECOMPRESS 헤더로 수정됩니다. 원본 아웃바운드 메시지에 대한 참조를 유지하는 경우 속성도 변경됩니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/post-processing.html)"
"Spring의 RabbitMQ에서 Request/Reply Messaging을 구현하기 위해 어떤 클래스를 사용해야 하나요?","AmqpTemplate을 사용해야 합니다."
"Spring의 RabbitMQ에서 Request/Reply Messaging에서 reply-to 속성을 구성하는 방법은 무엇인가요?","AmqpTemplate의 sendAndReceive 메서드를 사용하여 필요한 reply-to 속성을 구성할 수 있습니다."
"Spring의 RabbitMQ에서 Request/Reply Messaging의 reply timeout을 설정하는 방법은 무엇인가요?","RabbitTemplate의 replyTimeout 속성을 설정하여 reply timeout을 수정할 수 있습니다."
"Spring AMQP의 RabbitAdmin은 무엇인가요?","RabbitAdmin은 RabbitMQ에서 큐, 익스체인지 및 바인딩을 구성하는 데 사용되는 AmqpAdmin 인터페이스의 RabbitMQ 구현입니다. 이는 org.springframework.amqp.rabbit.core 패키지에 위치합니다."
"Spring AMQP에서 익명 큐란 무엇인가요?","익명 큐는 Spring AMQP에서 고유한 (UUID) 이름을 생성하고 durable를 false로 설정하고 exclusive 및 autoDelete를 true로 설정하는 큐입니다. Queue 선언 시 빈 (또는 누락된) 이름 속성을 가진 <rabbit:queue/>는 항상 익명 큐를 생성합니다."
"Spring AMQP에서 RabbitAdmin의 ignoreDeclarationExceptions 속성은 어떤 역할을 하나요?","ignoreDeclarationExceptions 속성은 RabbitAdmin이 예외가 발생했을 때 선언을 계속할지 여부를 제어합니다. 기본적으로 RabbitAdmin은 예외가 발생하면 모든 선언 처리를 즉시 중지합니다. 이 속성이 true로 설정되면 RabbitAdmin은 예외를 기록하고 다른 요소를 계속 선언합니다."
"Spring의 Event Exchange Plugin은 어떤 역할을 하나요?","Spring의 Event Exchange Plugin은 RabbitMQ 브로커에서 발생하는 이벤트를 Spring ApplicationListener 또는 @EventListener 메서드로 소비할 수 있도록 BrokerEventListener를 추가하면, 선택한 브로커 이벤트를 BrokerEvent 인스턴스로 게시합니다. 이벤트는 브로커에 의해 amq.rabbitmq.event라는 토픽 교환에 게시되며, 각 이벤트 유형에 대해 다른 라우팅 키를 사용합니다. 리스너는 선택된 이벤트만 수신하도록 AnonymousQueue를 교환에 바인딩하는 데 사용되는 이벤트 키를 사용합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/broker-events.html)"
"BrokerEventListener를 사용하여 이벤트 유형을 필터링하는 방법은 무엇인가요?","BrokerEventListener를 사용하여 이벤트 유형을 필터링하려면, 이벤트 키를 사용하여 AnonymousQueue를 교환에 바인딩하고, 특정 이벤트를 명시적으로 요청하거나 와일드카드를 사용하여 선택된 이벤트만 수신하도록 합니다. 개별 이벤트 리스너에서 수신된 이벤트를 더 좁히기 위해 일반적인 Spring 기술을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/broker-events.html)"
"BrokerEventListener를 사용하여 RabbitMQ 브로커에서 발생하는 이벤트를 어떻게 수신할 수 있나요?","BrokerEventListener를 사용하여 RabbitMQ 브로커에서 발생하는 이벤트를 수신하려면, 애플리케이션 컨텍스트에 BrokerEventListener의 빈을 추가하고, 이벤트 리스너가 관심 있는 이벤트만 수신하도록 이벤트 키를 구성해야 합니다. 개별 이벤트 리스너에서 수신된 이벤트를 더 좁히기 위해 일반적인 Spring 기술을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/broker-events.html)"
"Spring AMQP에서 지연된 메시지 교환을 지원하는 버전은 무엇인가요?","Spring AMQP 1.6 버전부터 지연된 메시지 교환 플러그인을 지원합니다."
"지연된 메시지 교환 플러그인은 RabbitMQ의 어떤 버전에서 사용 가능한가요?","지연된 메시지 교환 플러그인은 RabbitMQ 3.6.0 버전에서 사용 가능합니다."
"Spring AMQP에서 교환을 지연된 교환으로 선언하려면 RabbitAdmin을 어떻게 구성해야 하나요?","exchange 빈에서 delayed 속성을 true로 설정하여 RabbitAdmin을 통해 교환을 지연된 교환으로 선언할 수 있습니다."
"RabbitMQ에서 REST API를 사용하려면 어떤 플러그인을 활성화해야 하나요?","RabbitMQ에서 REST API를 사용하려면 관리 플러그인을 활성화해야 합니다. (출처: https://docs.spring.io/spring-amqp/reference/htmlsingle/)"
"RabbitMQ REST API에 대한 Java 바인딩을 제공하는 프로젝트는 무엇인가요?","RabbitMQ REST API에 대한 Java 바인딩을 제공하는 프로젝트는 Hop입니다. (출처: https://docs.spring.io/spring-amqp/reference/htmlsingle/)"
"RabbitMQ REST API의 표준, 즉시 및 블로킹 구현은 무엇인가요?","RabbitMQ REST API의 표준, 즉시 및 블로킹 구현은 com.rabbitmq.http.client.Client입니다. (출처: https://docs.spring.io/spring-amqp/reference/htmlsingle/)"
"Spring AMQP에서 RabbitMQ Java 클라이언트의 어떤 작업이 체크된 예외를 발생시킬 수 있나요?","RabbitMQ Java 클라이언트의 많은 작업이 체크된 예외를 발생시킬 수 있습니다. 예를 들어, IOException 인스턴스가 발생할 수 있는 경우가 많습니다. (출처: <https://docs.spring.io/spring-amqp/reference/html/#exception-handling>)"
"Spring AMQP에서 RabbitTemplate 및 SimpleMessageListenerContainer와 같은 구성 요소는 어떤 예외를 AmqpException 계층 구조 내의 예외로 변환하나요?","RabbitTemplate, SimpleMessageListenerContainer 및 기타 Spring AMQP 구성 요소는 이러한 예외를 발생시키고 'org.springframework.amqp' 패키지에서 정의된 AmqpException 계층 구조 내의 예외로 변환합니다. (출처: <https://docs.spring.io/spring-amqp/reference/html/#exception-handling>)"
"Spring AMQP에서 리스너가 예외를 throw할 때, 메시지 처리의 기본 동작은 무엇인가요?","일반적으로 메시지는 브로커에 의해 거부되고 재큐됩니다. defaultRequeueRejected를 false로 설정하면 메시지가 폐기되거나 데드 레터 교환으로 라우팅됩니다. (출처: <https://docs.spring.io/spring-amqp/reference/html/#exception-handling>)"
"스프링 AMQP에서 트랜잭션의 두 가지 방식은 무엇인가요?","스프링 AMQP에서 트랜잭션의 두 가지 방식은 channelTransacted 플래그를 사용하는 방식과 PlatformTransactionManager를 구현하여 외부 트랜잭션을 제공하는 방식입니다."
"channelTransacted 플래그가 true인 경우, 메시징 트랜잭션의 커밋 또는 롤백은 언제 이루어지나요?","channelTransacted 플래그가 true인 경우, 메시징 트랜잭션의 커밋 또는 롤백은 현재 트랜잭션이 끝날 때까지 연기됩니다."
"외부 트랜잭션이 필요한 경우, SimpleMessageListenerContainer는 어떻게 처리해야 하나요?","외부 트랜잭션이 필요한 경우, SimpleMessageListenerContainer는 PlatformTransactionManager의 구현을 제공하여 현재 스레드의 상태에 따라 응답합니다. 이는 종종 애플리케이션에 선언적으로 레이어링되는 구성 설정이기도 합니다."
"SimpleMessageListenerContainer에서 기본적으로 큐에서 메시지를 수신하는 소비자는 몇 개인가요?","SimpleMessageListenerContainer에서 기본적으로 큐에서 메시지를 수신하는 소비자는 1개입니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/listener-concurrency.html)"
"maxConcurrentConsumers 속성이란 무엇이며, 어떻게 동작하나요?","maxConcurrentConsumers 속성은 SimpleMessageListenerContainer에서 최대 동시 소비자 수를 동적으로 조정할 수 있는 속성입니다. maxConcurrentConsumers 속성이 변경되면, 필요한 만큼 소비자가 추가되거나 제거되어 새로운 설정에 맞게 조정됩니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/listener-concurrency.html)"
"DirectMessageListenerContainer에서 기본적으로 사용되는 스레드 수는 몇 개인가요?","DirectMessageListenerContainer에서 기본적으로 사용되는 스레드 수는 DEFAULT_NUM_THREADS = Runtime.getRuntime().availableProcessors() * 2 개입니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/amqp/listener-concurrency.html)"
"Spring AMQP에서 독점적인 소비자란 무엇인가요?","Spring AMQP에서 독점적인 소비자는 버전이 1.3부터 지원되며, 리스너 컨테이너를 단일 독점적인 소비자로 구성할 수 있습니다. 이렇게 설정하면 현재 소비자가 취소될 때까지 다른 컨테이너가 큐에서 소비하는 것을 방지합니다. 이러한 컨테이너의 동시성 수준은 1이어야 합니다. 독점적인 소비자를 사용하는 경우, 다른 컨테이너는 복구Interval 속성에 따라 큐에서 소비하려고 시도하며, 시도가 실패하면 WARN 메시지를 기록합니다. (출처: <https://docs.spring.io/spring-amqp/reference/3.1/amqp/exclusive-consumer.html>)"
"Spring AMQP에서 독점적인 소비자의 동시성 수준은 어떻게 되나요?","Spring AMQP에서 독점적인 소비자의 동시성 수준은 1이어야 합니다. 이는 현재 소비자가 취소될 때까지 다른 컨테이너가 큐에서 소비하는 것을 방지하기 때문입니다. (출처: <https://docs.spring.io/spring-amqp/reference/3.1/amqp/exclusive-consumer.html>)"
"Spring AMQP에서 독점적인 소비자를 사용할 때 다른 컨테이너의 동작은 어떻게 되나요?","Spring AMQP에서 독점적인 소비자를 사용하는 경우, 다른 컨테이너는 복구Interval 속성에 따라 큐에서 소비하려고 시도하며, 시도가 실패하면 WARN 메시지를 기록합니다. (출처: <https://docs.spring.io/spring-amqp/reference/3.1/amqp/exclusive-consumer.html>)"
"스프링 AMQP에서 RabbitAdmin 구성 요소를 사용하는 것의 이점은 무엇인가요?","RabbitAdmin 구성 요소는 시작 시 교환, 큐 및 바인딩을 선언할 수 있습니다. 이는 연결이 (예: 브로커 사망, 네트워크 결함 등) 어떤 이유로든 끊어진 경우 연결이 다시 설정될 때 다시 적용됩니다. 이를 통해 브로커가 시작 시 존재하지 않아도 되며, 연결이 끊어져도 선언이 다시 적용됩니다."
"스프링 AMQP에서 자동 선언이 CHANNEL 캐시 모드에서만 작동하는 이유는 무엇인가요?","자동 선언은 CHANNEL 캐시 모드에서만 작동합니다. 이는 독점 및 자동 삭제 큐가 연결에 바인딩되기 때문입니다. CHANNEL 캐시 모드는 연결이 끊어져도 선언을 자동으로 다시 적용할 수 있도록 합니다."
"스프링 AMQP의 RabbitMQ 자동 연결/토폴로지 복구 기능은 어떻게 작동하나요?","RabbitMQ 자동 연결/토폴로지 복구 기능은 연결이 끊어질 때마다 연결과 토폴로지를 자동으로 복구합니다. 이 기능은 CachingConnectionFactory 자체에 의해 활성화되며, RabbitAdmin 자동 선언 기능과 함께 사용하는 것이 좋습니다. 자동 선언은 CHANNEL 캐시 모드에서 CachingConnectionFactory를 사용하여 연결이 끊어져도 선언을 자동으로 다시 적용할 수 있도록 합니다."
"Spring의 RabbitMQ 통합을 사용하여 단일 애플리케이션과 여러 개의 브로커 또는 클러스터를 지원하는 가장 큰 장점은 무엇인가요?","소비자 측에서 가장 큰 장점은 인프라가 자동으로 선언된 큐를 적절한 브로커와 연결할 수 있다는 것입니다. 이렇게 하면 애플리케이션이 여러 개의 RabbitMQ 클러스터를 처리할 수 있습니다."
"SimpleRoutingConnectionFactory를 사용하는 것이 어떤 상황에서 편리한가요?","SimpleRoutingConnectionFactory는 단일 애플리케이션과 여러 개의 RabbitMQ 클러스터를 연결해야 할 때 편리합니다. 이를 통해 애플리케이션은 여러 개의 RabbitMQ 클러스터를 처리할 수 있으며, 큐를 적절한 브로커와 연결할 수 있습니다."
"RabbitMQ 통합에서 ConnectionFactoryContextWrapper 클래스를 사용하는 방법은 무엇인가요?","ConnectionFactoryContextWrapper 클래스를 사용하여 RoutingConnectionFactory를 사용하는 것이 더 간단해집니다. 이 클래스를 사용하면 RabbitMQ 클러스터로 라우팅할 때 더 쉽게 템플릿을 사용할 수 있습니다."
"Spring AMQP에서 디버깅을 위해 어떤 로깅 레벨을 사용해야 하나요?","DEBUG 레벨"
"Spring AMQP와 RabbitMQ 간의 AMQP 프로토콜을 모니터링하려면 어떤 도구를 사용할 수 있나요?","WireShark와 RabbitMQ Java 클라이언트의 Tracer 클래스"
"RabbitMQ의 Tracer 클래스를 사용하여 프로토콜을 모니터링하는 방법은 무엇인가요?","메인 클래스로 실행하고 ConnectionFactory 설정을 수정하여 로컬호스트의 5673 포트에 연결하면 콘솔에 디코딩된 프로토콜이 표시됩니다."
"Spring Ecosystem에서 RabbitMQ Stream Plugin을 사용하기 위해 필요한 버전은 무엇인가요?","Spring Ecosystem에서 RabbitMQ Stream Plugin을 사용하기 위해 필요한 버전은 2.4 이상입니다. (Source: <https://docs.spring.io/spring-amqp/reference/3.1/stream.html>)"
"Spring Ecosystem에서 RabbitMQ Stream Plugin을 사용하기 위해 필요한 의존성은 무엇인가요?","Spring Ecosystem에서 RabbitMQ Stream Plugin을 사용하기 위해 필요한 의존성은 spring-rabbit-stream입니다. (Source: <https://docs.spring.io/spring-amqp/reference/3.1/stream.html>)"
"Spring Ecosystem에서 RabbitMQ Stream Plugin을 사용하여 메시지를 수신하는 방법은 무엇인가요?","Spring Ecosystem에서 RabbitMQ Stream Plugin을 사용하여 메시지를 수신하는 방법은 StreamListenerContainer와 StreamRabbitListenerContainerFactory를 사용하는 것입니다. (Source: <https://docs.spring.io/spring-amqp/reference/3.1/stream.html>)"
"스프링 AMQP가 제공하는 로깅 서브시스템은 무엇인가요?","Spring AMQP는 logback (Spring AMQP 버전 1.4 이상) 및 log4j2 (Spring AMQP 버전 1.6 이상)와 같은 일부 인기있는 로깅 서브시스템에 대한 로깅 어펜더를 제공합니다."
"AMQP 어펜더에 사용 가능한 일반적인 속성은 무엇인가요?","모든 AMQP 어펜더에서 사용 가능한 일반적인 속성에는 exchangeName, exchangeType, routingKeyPattern, applicationId, senderPoolSize, maxSenderRetries, addresses, host, port, virtualHost, username, password, useSsl, verifyHostname, sslAlgorithm, sslPropertiesLocation, keyStore, keyStorePassphrase, keyStoreType, trustStore, trustStorePassphrase, trustStoreType, saslConfig, contentType, contentEncoding, declareExchange, durable, autoDelete, charset, deliveryMode, generateId, clientConnectionProperties 및 addMdcAsHeaders가 포함됩니다."
"AMQP 어펜더의 공통 속성인 exchangeName은 무엇인가요?","exchangeName 속성은 로깅 이벤트를 게시할 교환의 이름을 지정합니다."
"Spring AMQP 샘플 프로젝트에는 어떤 샘플 애플리케이션이 포함되어 있나요?","Spring AMQP 샘플 프로젝트에는 동기 및 비동기 메시지 수신을 보여주는 간단한 'Hello World' 예제와 실제 응용 프로그램에서 일반적인 상호 작용 유형을 보여주기 위해 주식 거래 사용 사례를 기반으로 하는 두 번째 샘플 애플리케이션이 포함되어 있습니다."
"Maven 기반 'Hello World' 샘플을 어떻게 IDE에 가져올 수 있나요?","Maven 기반 'Hello World' 샘플은 SpringSource Tool Suite와 같은 모든 Maven 인식 IDE에 직접 가져올 수 있습니다."
"Maven 기반 'Hello World' 샘플에서 연결 공장은 어떻게 생성되나요?","Maven 기반 'Hello World' 샘플에서 연결 공장은 @Bean 주석이 달린 connectionFactory() 메서드를 사용하여 생성됩니다. 이 메서드는 'localhost'로 인스턴스를 생성하고 사용자 이름과 암호를 설정합니다."
"Spring AMQP를 사용하여 비동기 애플리케이션의 통합 테스트를 어떻게 작성해야 하나요?","Spring AMQP 1.6 버전에서는 spring-rabbit-test jar를 사용하여 이러한 복잡한 시나리오를 테스트하는 데 필요한 지원을 제공합니다. 또한, JIRA(https://jira.spring.io/browse/AMQP) 또는 GitHub 이슈(https://github.com/spring-projects/spring-amqp/issues)를 사용하여 테스트에 필요한 기능에 대한 피드백을 제공할 수 있습니다."
"Spring AMQP에서 @SpringRabbitTest 어노테이션의 사용 목적은 무엇인가요?","@SpringRabbitTest 어노테이션은 Spring 테스트 ApplicationContext에 인프라 빈을 추가하는 데 사용됩니다. 예를 들어 @SpringBootTest를 사용할 때는 Spring Boot의 자동 구성이 빈을 추가하므로 이 어노테이션은 필요하지 않습니다. 등록된 빈에는 CachingConnectionFactory (autoConnectionFactory), RabbitTemplate (autoRabbitTemplate), RabbitAdmin (autoRabbitAdmin), RabbitListenerContainerFactory (autoContainerFactory)가 포함됩니다."
"Spring AMQP에서 Mockito Answer<?> 구현을 사용하여 어떻게 테스트를 지원할 수 있나요?","Spring AMQP는 현재 테스트를 지원하기 위해 두 가지 Answer<?> 구현을 제공합니다. LatchCountDownAndCallRealMethodAnswer는 null을 반환하고 래치를 카운트다운하는 Answer<Void>를 제공합니다. LambdaAnswer<T>는 선택적으로 실제 메서드를 호출하고 InvocationOnMock 및 결과를 기반으로 사용자 정의 결과를 반환할 수 있는 메커니즘을 제공합니다."
"Spring Integration에서 AMQP Channel Adapters 및 Gateways는 어떤 프로젝트에서 사용되나요?","Spring AMQP 프로젝트(Source: <https://docs.spring.io/spring-amqp/reference/3.1/integration-reference.html>)"
"Spring Integration에서 'Channel Adapters'와 'Gateways'의 차이점은 무엇인가요?","Channel Adapters는 단방향(one-way)이며, Gateways는 양방향(request-reply)입니다.(Source: <https://docs.spring.io/spring-amqp/reference/3.1/integration-reference.html>)"
"AMQP Messages를 교환(exchange)에 보내기 위해 Spring Integration에서 어떤 요소를 사용하나요?","<outbound-channel-adapter>를 구성하여 AMQP Messages를 교환에 보낼 수 있습니다.(Source: <https://docs.spring.io/spring-amqp/reference/3.1/integration-reference.html>)"
"AMQP에 대해 더 자세히 알 수 있는 다른 자료는 무엇인가요?","Spring AMQP 참조 문서 외에도 다른 자료들이 있습니다. 예를 들어, Spring AMQP 공식 웹사이트(https://docs.spring.io/spring-amqp/reference/3.1/resources.html)에서 추가적인 자료와 가이드를 찾을 수 있습니다."
"AMQP에 대한 온라인 포럼이나 커뮤니티가 있나요?","네, AMQP에 대한 온라인 포럼이나 커뮤니티가 있을 수 있습니다. 해당 자료에서는 구체적인 커뮤니티나 포럼에 대한 정보를 제공하지 않지만, Spring AMQP 공식 웹사이트(https://docs.spring.io/spring-amqp/reference/3.1/resources.html)에서 해당 정보를 찾을 수 있을 것입니다."
"AMQP에 대한 교육 자료나 강의가 있나요?","네, AMQP에 대한 교육 자료나 강의가 있을 수 있습니다. 해당 자료에서는 구체적인 교육 자료나 강의에 대한 정보를 제공하지 않지만, Spring AMQP 공식 웹사이트(https://docs.spring.io/spring-amqp/reference/3.1/resources.html)에서 해당 정보를 찾을 수 있을 것입니다."
"AMQP 스펙을 이해하기 위한 가장 좋은 자료는 무엇인가요?","AMQP 스펙을 이해하기 위한 가장 좋은 자료는 공식 스펙 문서(https://www.amqp.org/resources/download)입니다. 이 문서는 Spring AMQP 코드에서 쉽게 이해할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/further-reading.html)"
"현재 Spring AMQP의 RabbitMQ 지원 버전은 어느 버전인가요?","현재 Spring AMQP의 RabbitMQ 지원 버전은 2.8.x 버전입니다. 이 버전은 AMQP 0.8 및 0.9.1을 공식적으로 지원합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/further-reading.html)"
"RabbitMQ와 관련된 모든 사항에 대한 일반적인 시작점을 추천해 주실 수 있나요?","RabbitMQ와 관련된 모든 사항에 대한 일반적인 시작점으로 RabbitMQ Getting Started 페이지(https://www.rabbitmq.com/how.html)를 추천합니다. 이 페이지에는 많은 훌륭한 기사, 프레젠테이션 및 블로그가 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/further-reading.html)"
"스프링 어댑터에서 RabbitMQ에 대한 메트릭과 스팬을 생성하는 데 사용되는 프레임워크는 무엇인가요?","Micrometer (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/micrometer.html)"
"RabbitMQ에서 `spring.rabbit.template.name` 태그 키의 목적은 무엇인가요?","템플릿의 빈 이름을 설명합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/micrometer.html)"
"Micrometer의 타이머와 롱 태스크 타이머의 차이점은 무엇인가요?","타이머는 지정된 기간 동안 경과된 시간을 측정하고, 롱 태스크 타이머는 지정된 기간 동안 경과된 시간을 측정하며, 추가 키값을 포함할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/micrometer.html)"
"Spring AMQP를 사용하는 Spring 애플리케이션의 네이티브 이미지를 개발하는 데 도움이 되는 것은 무엇인가요?","Spring AOT(https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aot) 네이티브 힌트가 Spring AMQP를 사용하는 Spring 애플리케이션의 네이티브 이미지를 개발하는 데 도움이 됩니다. spring-aot-smoke-tests GitHub 저장소(https://github.com/spring-projects/spring-aot-smoke-tests/tree/main/integration)에서 몇 가지 예제를 볼 수 있습니다."
"Spring AOT 네이티브 힌트에 대한 자세한 정보가 있는 곳은 어디인가요?","Spring AOT 네이티브 힌트에 대한 자세한 정보는 Spring AMQP 참조 가이드(https://docs.spring.io/spring-amqp/reference/3.1/appendix/native.html)에서 확인할 수 있습니다."
"Spring AOT 네이티브 힌트를 사용하는 예제를 어디에서 볼 수 있나요?","Spring AOT 네이티브 힌트를 사용하는 예제는 spring-aot-smoke-tests GitHub 저장소(https://github.com/spring-projects/spring-aot-smoke-tests/tree/main/integration)에서 볼 수 있습니다."
"현재 릴리스 문서의 'What's New' 섹션은 어디에서 찾을 수 있나요?","현재 릴리스 문서의 'What's New' 섹션은 다음 링크에서 찾을 수 있습니다: {<https://docs.spring.io/spring-amqp/reference/3.1/appendix/current-release.html>}"
"현재 릴리스에서 어떤 새로운 기능이 추가되었나요?","현재 릴리스에서 추가된 새로운 기능에 대한 정보는 다음 링크에서 확인할 수 있습니다: {<https://docs.spring.io/spring-amqp/reference/3.1/appendix/current-release.html>}"
"현재 릴리스에 대한 자세한 정보를 얻을 수 있는 방법은 무엇인가요?","현재 릴리스에 대한 자세한 정보는 다음 링크에서 확인할 수 있습니다: {<https://docs.spring.io/spring-amqp/reference/3.1/appendix/current-release.html>}"
"Spring 3.0에서 2.4와 비교하여 가장 중요한 변경 사항은 무엇인가요?","Spring 3.0에서 2.4와 비교하여 가장 중요한 변경 사항은 메시지 컨버터 변경 사항, 스트림 지원 변경 사항, 그리고 HttpMessageConverter의 추가입니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new.html)"
"Spring 2.3에서 2.2와 비교하여 어떤 변경 사항이 있었나요?","Spring 2.3에서 2.2와 비교하여 변경 사항은 공식 문서에 명시되어 있지 않습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new.html)"
"Spring 1.2에서 1.1과 비교하여 어떤 변경 사항이 있었나요?","Spring 1.2에서 1.1과 비교하여 변경 사항은 공식 문서에 명시되어 있지 않습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new.html)"
"Spring Framework 3.0에서 RMI를 사용한 remoting 기능은 어떤 변화가 있나요?","Spring Framework 3.0에서는 RMI를 사용한 remoting 기능이 더 이상 지원되지 않습니다. (출처: <https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-3-0-since-2-4.html>)"
"Spring Framework 3.0에서 @RabbitListener 또는 @RabbitHandler 메서드에 어떤 변경 사항이 있나요?","Spring Framework 3.0에서는 @RabbitListener (및 @RabbitHandler) 메서드가 Kotlin suspend 함수로 선언될 수 있습니다. (출처: <https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-3-0-since-2-4.html>)"
"Spring Framework 3.0에서 AsyncRabbitTemplate에 어떤 변경 사항이 있나요?","Spring Framework 3.0에서는 AsyncRabbitTemplate이 ListenableFuture 대신 CompletableFuture를 반환합니다. (출처: <https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-3-0-since-2-4.html>)"
"Spring AMQP 2.4에서 2.3 버전과의 차이점은 무엇인가요?","Spring AMQP 2.4에서는 @RabbitListener에서 MessageProperties가 인자 매칭에 사용 가능하며, RabbitAdmin에서 recoverManualDeclarations 속성을 추가하여 수동으로 선언된 큐/교환/바인딩을 복구할 수 있습니다. 또한, Spring Framework의 RMI 지원을 사용한 리모팅은 3.0에서 제거될 예정입니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-2-4-since-2-3.html."
"Spring AMQP 2.4에서 @RabbitListener의 변경 사항은 무엇인가요?","Spring AMQP 2.4에서는 @RabbitListener에서 MessageProperties가 인자 매칭에 사용 가능하게 변경되었습니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-2-4-since-2-3.html."
"Spring AMQP 2.4에서 RabbitAdmin의 변경 사항은 무엇인가요?","Spring AMQP 2.4에서는 RabbitAdmin에서 recoverManualDeclarations 속성을 추가하여 수동으로 선언된 큐/교환/바인딩을 복구할 수 있습니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-2-4-since-2-3.html."
"Jackson2JsonMessageConverter가 메시지 변환기 변경 사항에서 어떤 부분을 개선했나요?","Jackson2JsonMessageConverter는 이제 contentEncoding 헤더에서 문자 집합을 결정할 수 있습니다. 자세한 내용은 [json-message-converter](#json-message-converter)를 참조하세요."
"Spring의 Message Converter Changes에 대한 자세한 정보를 어디에서 찾을 수 있나요?","자세한 정보는 다음 링크를 참조하세요: <https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/message-converter-changes.html>"
"Jackson2JsonMessageConverter의 개선된 기능은 무엇인가요?","Jackson2JsonMessageConverter는 이제 contentEncoding 헤더에서 문자 집합을 결정할 수 있습니다. 자세한 내용은 [json-message-converter](#json-message-converter)를 참조하세요."
"Jackson2JsonMessageConverter가 charset을 어디에서 결정할 수 있나요?","contentEncoding 헤더에서 결정할 수 있습니다. (Source: {https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/message-converter-changes-1.html})"
"Jackson2JsonMessageConverter의 변경 사항에 대한 자세한 정보를 어디에서 확인할 수 있나요?","json-message-converter 섹션에서 확인할 수 있습니다. (Source: {https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/message-converter-changes-1.html})"
"Spring AMQP의 다른 이전 버전에서의 변경 사항에 대한 정보를 어디에서 찾을 수 있나요?","Spring AMQP 참조 문서의 이전 버전에서의 변경 사항 섹션에서 확인할 수 있습니다. (Source: {https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/message-converter-changes-1.html})"
"Spring AMQP 2.3 버전에서 어떤 새로운 연결 팩토리가 제공되었나요?","Spring AMQP 2.3 버전에서 두 가지 새로운 연결 팩토리인 CachingConnectionFactory와 CachingClientConnectionFactory가 추가되었습니다. 이 두 가지 연결 팩토리는 연결 풀링을 지원하며, 성능과 확장성을 향상시킵니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-2-3-since-2-2.html)"
"Spring AMQP 2.3 버전에서 @RabbitListener의 어떤 기능이 추가되었나요?","@RabbitListener에서 reply content type을 지정할 수 있는 기능이 추가되었습니다. 이를 통해 응답 메시지의 콘텐츠 타입을 제어할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-2-3-since-2-2.html)"
"Spring AMQP 2.3 버전에서 MessageConverter의 어떤 변경 사항이 있었나요?","Spring AMQP 2.3 버전에서 Jackson2JMessageConverter가 추상 클래스(인터페이스 포함)를 역직렬화할 수 있도록 변경되었습니다. 이를 통해 다양한 메시지 타입을 처리할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-2-3-since-2-2.html)"
"Spring AMQP 2.2 버전에서 2.1 버전과 비교하여 어떤 변경 사항이 있었나요?","Spring AMQP 2.2 버전에서 2.1 버전과 비교하여 패키지 변경, 의존성 변경, API 변경, 리스너 컨테이너 변경, @RabbitListener 변경, Spring Data Projection 인터페이스 지원, 메시지 리스너 어댑터 제공 변경 등이 있었습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-2-2-since-2-1.html)"
"Spring AMQP 2.2 버전에서 JUnit (4)와 JUnit (5)에 어떤 변경 사항이 있었나요?","Spring AMQP 2.2 버전에서 JUnit (4)는 선택적 의존성으로 변경되었고, 더 이상 트랜지티브 의존성으로 나타나지 않습니다. JUnit (5) RabbitAvailableCondition.getBrokerRunning()은 이제 BrokerRunning 인스턴스 대신 BrokerRunningSupport 인스턴스를 반환하며, 이는 JUnit 4에 의존합니다. 동일한 API를 가지고 있으므로 참조의 클래스 이름만 변경하면 됩니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-2-2-since-2-1.html)"
"Spring AMQP 2.2 버전에서 메시지 리스너 어댑터에 어떤 변경 사항이 있었나요?","Spring AMQP 2.2 버전에서 메시지 리스너 어댑터는 이제 대상 리스너에 전달될 인수의 배열을 빌드하는 새로운 buildListenerArguments(Object, Channel, Message) 메서드를 제공하며, 이전 메서드는 사용되지 않습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-2-2-since-2-1.html)"
"Spring AMQP는 어떤 버전의 RabbitMQ 클라이언트 라이브러리를 사용하나요?","Spring AMQP는 RabbitMQ 팀에서 제공하는 amqp-client 라이브러리의 5.4.x 버전을 사용합니다."
"Spring AMQP는 RabbitMQ의 자동 연결/토폴로지 복구 기능을 사용하나요?","아니요, Spring AMQP는 자체 복구 메커니즘을 가지고 있으며, 클라이언트 복구 기능은 일반적으로 필요하지 않습니다. 자동 복구를 비활성화하는 것이 좋습니다."
"Publisher Confirms 변경 사항으로 인해 어떤 영향이 있나요?","Publisher confirmations이 활성화된 채널은 미처리된 확인이 있는 동안 캐시로 반환되지 않습니다. Correlated Publisher Confirms and Returns를 참조하세요."
"스프링 AMQP 2.0에서 RabbitMQ 팀에서 제공하는 amqp-client 라이브러리의 버전은 무엇인가요?","RabbitMQ 팀에서 제공하는 amqp-client 라이브러리의 버전은 5.0.x입니다."
"스프링 AMQP의 RabbitTemplate은 2.0부터 어떤 변경 사항이 있나요?","RabbitTemplate은 리스너 컨테이너에서 사용되는 것과 다른 연결을 사용하도록 구성할 수 있습니다."
"스프링 AMQP의 @Queue 어노테이션은 2.0부터 어떤 변경 사항이 있나요?","@Queue 어노테이션은 기본적으로 내구성 있는 큐를 선언합니다."
"Spring AMQP 1.7 버전에서 RabbitMQ 연결 라이브러리에서 어떤 변경 사항이 있었나요?","Spring AMQP 1.7 버전에서 RabbitMQ 팀에서 제공하는 amqp-client 라이브러리의 4.0.x 버전을 사용하며, 이 클라이언트는 기본적으로 자동 복구를 구성합니다. 그러나 Spring AMQP는 자체 복구 메커니즘을 가지고 있으므로, 기본적으로 amqp-client 자동 복구를 비활성화하는 것이 권장됩니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-1-7-since-1-6.html)"
"Spring AMQP 1.7 버전에서 Log4j 2 버전과 호환되는 최소 버전은 무엇인가요?","Spring AMQP 1.7 버전에서 Log4j 2 버전과 호환되는 최소 버전은 2.7입니다. 이전 버전과 호환되지 않습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-1-7-since-1-6.html)"
"Spring AMQP 1.7 버전에서 Shutdown Behavior에 어떤 변경 사항이 있었나요?","Spring AMQP 1.7 버전에서 forceCloseChannel 옵션을 true로 설정하여, 컨테이너 스레드가 종료 시간 내에 응답하지 않을 경우 채널을 강제로 닫아 미처리된 메시지를 다시 대기열에 넣을 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-1-7-since-1-6.html)"
"이전 릴리스에서 변경된 내용을 어디에서 확인할 수 있나요?","이전 버전의 변경 내용은 해당 문서의 '이전 릴리스(../previous-whats-new.html)' 섹션에서 확인할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/earlier-releases.html)"
"이전 릴리스에서 변경된 내용에 대한 더 자세한 정보를 찾을 수 있는 곳은 어디인가요?","이전 릴리스에서 변경된 내용에 대한 더 자세한 정보는 '이전 릴리스(../previous-whats-new.html)' 섹션에서 확인할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/earlier-releases.html)"
"Spring AMQP의 이전 버전에서 어떤 변경 사항이 있었나요?","이전 버전의 변경 내용은 '이전 릴리스(../previous-whats-new.html)' 섹션에서 확인할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/earlier-releases.html)"
"Spring AMQP 1.6에서 새로운 테스트 지원 라이브러리는 어떤 기능을 제공하나요?","Spring AMQP 1.6에서는 새로운 테스트 지원 라이브러리가 제공되어, Spring AMQP 기반의 애플리케이션을 테스트할 때 유용한 기능을 제공합니다. 이 라이브러리는 RabbitMQ 서버를 설정하고, 메시지를 보내고 받는 등의 테스트를 쉽게 작성할 수 있도록 도와줍니다. 자세한 내용은 Testing Support(https://docs.spring.io/spring-amqp/reference/htmlsingle/#test-support)를 참조하세요."
"Spring AMQP 1.6에서 Queue와 Exchange 객체를 구성하는 데 사용되는 Builder API는 어떤 기능을 제공하나요?","Spring AMQP 1.6에서는 Queue와 Exchange 객체를 구성하는 데 사용되는 Builder API가 제공됩니다. 이 API는 플루언트(fluent) API를 제공하여, Queue와 Exchange 객체를 쉽게 구성할 수 있도록 도와줍니다. 자세한 내용은 Builder API for Queues and Exchanges(https://docs.spring.io/spring-amqp/reference/htmlsingle/#amqp-broker-configuration-builder-api)를 참조하세요."
"Spring AMQP 1.6에서 Connection Factory의 스레드 팩토리를 사용자 정의하는 방법은 무엇인가요?","Spring AMQP 1.6에서는 Connection Factory에 스레드 팩토리를 추가할 수 있습니다. 이를 통해 amqp-client 라이브러리에서 생성되는 스레드의 이름을 지정할 수 있습니다. 스레드 팩토리를 사용자 정의하려면, ConnectionFactory 빈 선언에 threadFactory 속성을 추가하면 됩니다. 자세한 내용은 Connection and Resource Management(https://docs.spring.io/spring-amqp/reference/htmlsingle/#amqp-connections)를 참조하세요."
"1.4 버전에서 1.5 버전으로 업그레이드 시, CachingConnectionFactory의 변경된 동작 중 어떤 것이 있나요?","CachingConnectionFactory의 변경된 동작 중 하나는 빈 주소 문자열이 더 이상 무시되지 않고, 호스트 및 포트를 사용한다는 것입니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-1-5-since-1-4.html)"
"1.5 버전에서 어떤 새로운 메서드가 추가되었나요?","1.5 버전에서는 CachingConnectionFactory에 resetConnection() 메서드가 추가되어 연결을 재설정할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-1-5-since-1-4.html)"
"1.5 버전에서 어떤 새로운 속성이 추가되었나요?","1.5 버전에서는 CachingConnectionFactory에 missingQueuesFatal, declarationRetries, failedDeclarationRetryInterval, retryDeclarationInterval 등의 새로운 속성이 추가되었습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-1-5-since-1-4.html)"
"Spring AMQP 1.4에서 어떤 새로운 RabbitMQ 템플릿이 추가되었나요?","RabbitMessagingTemplate이 추가되어 spring-messaging Message 인스턴스를 사용하여 RabbitMQ와 상호 작용할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-1-4-since-1-3.html)"
"Spring AMQP 1.4에서 SimpleMessageListenerContainer의 missingQueuesFatal 속성이 어디에 추가되었나요?","listener container namespace 요소에 추가되었습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-1-4-since-1-3.html)"
"Spring AMQP 1.4에서 RabbitTemplate의 confirm 메서드에 어떤 추가 매개변수가 추가되었나요?","cause라는 추가 매개변수가 추가되었습니다. 이 매개변수는 부정적인 확인(nack)의 이유를 포함합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-1-4-since-1-3.html)"
"1.2 버전 대비 1.3 버전에서 리스너 컨테이너의 동시성 변경 사항은 무엇인가요?","1.3 버전에서는 리스너 컨테이너에서 동시성을 동적으로 조정할 수 있으며, 프로그래밍 방식으로 컨테이너를 중지하지 않고도 동시성을 변경할 수 있습니다. 또한, 리스너 컨테이너에서 듣는 큐를 런타임에 수정할 수 있습니다. 또한, 리스너 컨테이너에서는 자동 삭제 큐를 시작 시 다시 선언합니다. 또한, 리스너 컨테이너에서는 소비자 인수를 지원하여 x-priority 인수를 설정할 수 있습니다. 또한, 리스너 컨테이너에서는 독점적인 소비자를 구성하여 다른 소비자가 큐를 듣지 못하도록 할 수 있습니다. 또한, Rabbit Admin에서는 내구성, 자동 삭제 및 독점 설정에 관계없이 브로커가 큐 이름을 생성하도록 할 수 있습니다. 또한, Direct Exchange Binding에서는 바인딩 요소에서 키 속성을 생략하면 제공된 Queue 또는 Exchange의 이름으로 바인딩됩니다. 또한, AmqpTemplate에서는 동기식 receiveAndReply 메서드를 제공합니다. 또한, RabbitTemplate에서는 RetryTemplate을 구성하여 재시도(선택적 백오프 정책 포함)를 시도할 수 있습니다. 또한, Caching Connection Factory에서는 Connection 인스턴스와 해당 Channel 인스턴스를 캐시할 수 있습니다. 또한, Binding Arguments에서는 <binding>의 <binding-arguments> 하위 요소를 파싱할 수 있습니다. 또한, Routing Connection Factory에서는 런타임에 사용할 대상 ConnectionFactory를 결정하기 위해 ConnectionFactory 매핑을 구성할 수 있습니다. 또한, MessageBuilder 및 MessagePropertiesBuilder에서는 메시지 또는 메시지 속성을 구축하기 위한 'Fluent API'를 제공합니다. 또한, RetryInterceptorBuilder에서는 리스너 컨테이너 재시도 인터셉터를 구축하기 위한 'Fluent API'를 제공합니다. 또한, RepublishMessageRecoverer에서는 재시도 횟수가 소진되면 실패한 메시지를 다른 큐에 게시할 수 있습니다. 또한, Default Error Handler에서는 치명적인 메시지 변환 문제를 감지하고, 변환할 수 없는 메시지를 계속해서 다시 전달하지 않도록 컨테이너에 메시지를 거부하도록 지시하는 오류 처리기가 추가되었습니다. 또한, 리스너 컨테이너에서는 'missingQueuesFatal' 속성을 설정하여 누락된 큐가 치명적인지 여부를 결정할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-1-3-since-1-2.html)"
"1.3.2 버전부터 Default Error Handler가 추가된 내용","Default Error Handler는 SimpleMessageListenerContainer에 추가되었으며, 치명적인 메시지 변환 문제를 감지하고, 변환할 수 없는 메시지를 계속해서 다시 전달하지 않도록 컨테이너에 메시지를 거부하도록 지시합니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-1-3-since-1-2.html)"
"Rabbit Admin의 변경 사항","1.3 버전부터 Rabbit Admin에서는 내구성, 자동 삭제 및 독점 설정에 관계없이 브로커가 큐 이름을 생성하도록 할 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-in-1-3-since-1-2.html)"
"Spring AMQP의 RabbitMQ 버전 기본값은 무엇인가요?","RabbitMQ 3.1.x입니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-to-1-2-since-1-1.html)"
"Spring AMQP에서 RabbitAdmin의 새로운 기능은 무엇인가요?","ignore-declaration-exceptions 옵션을 추가하여 교환, 큐, 바인딩 선언이 실패했을 때 계속 진행할 수 있도록 했습니다. 또한 getQueueProperties() 메서드를 추가하여 큐 속성을 가져올 수 있습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-to-1-2-since-1-1.html)"
"Spring AMQP에서 replyTo 정보와 상관 관계를 위해 어떤 메시지 속성이 사용되나요?","correlationId가 사용됩니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-to-1-2-since-1-1.html)"
"Spring-AMQP는 어떤 빌드 도구를 사용하여 개발되었나요?","Spring-AMQP는 Gradle을 사용하여 개발되었습니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-to-1-1-since-1-0.html)"
"Spring-AMQP 1.1에서 추가된 기능 중 publisher confirms와 returns는 무엇인가요?","Spring-AMQP 1.1에서는 publisher confirms와 returns에 대한 지원이 추가되었습니다. 이는 메시지가 성공적으로 전달되었는지 확인하고, 전달에 실패한 경우 적절한 처리를 할 수 있도록 도와줍니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-to-1-1-since-1-0.html)"
"Spring-AMQP 1.1에서 추가된 HA queues와 broker failover 기능은 어떤 역할을 하나요?","HA queues와 broker failover 기능은 장애 발생 시 메시지 전달의 안정성과 신뢰성을 향상시키기 위해 추가되었습니다. 이를 통해 메시지가 손실되지 않고, 장애 복구 후에도 정상적인 메시지 처리가 가능해집니다. (출처: https://docs.spring.io/spring-amqp/reference/3.1/appendix/previous-whats-new/changes-to-1-1-since-1-0.html)"
