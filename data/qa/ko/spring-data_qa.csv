"Spring Data Commons 프로젝트는 무엇을 하는 프로젝트인가요?","Spring Data Commons 프로젝트는 핵심 Spring 개념을 적용하여 많은 관계형 및 비관계형 데이터 저장소를 사용하는 솔루션 개발에 적용됩니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/index.html)"
"Spring Data Commons의 버전은 어떻게 확인할 수 있나요?","Spring Data Commons의 버전은 GitHub 저장소(https://github.com/spring-projects/spring-data-commons)에서 확인할 수 있습니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/index.html)"
"Spring Data Commons의 스냅샷 저장소는 어디인가요?","Spring Data Commons의 스냅샷 저장소는 repo.spring.io/snapshot/입니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/index.html)"
"스프링 데이터 모듈의 호환 가능한 버전을 어떻게 찾을 수 있나요?","스프링 데이터 릴리스 트레인 BOM을 사용하여 호환 가능한 버전을 찾을 수 있습니다. 이 BOM은 호환 가능한 버전이 정의되어 있으며, Maven 프로젝트에서는 POM의 <dependencyManagement /> 섹션에 다음과 같이 이 종속성을 선언합니다. <dependency> <groupId>org.springframework.data</groupId> <artifactId>spring-data-bom</artifactId> <version>2024.0.4</version> <scope>import</scope> <type>pom</type> </dependency> 현재 릴리스 트레인 버전은 2024.0.4입니다. train 버전은 calver(https://calver.org/)를 사용하며, 패턴은 YYYY.MINOR.MICRO입니다. 자세한 내용은 <https://docs.spring.io/spring-data/commons/reference/3.3/dependencies.html>을(를) 참조하십시오."
"Maven 프로젝트에서 Spring Data 릴리스 트레인 BOM을 어떻게 사용하나요?","Maven 프로젝트에서 Spring Data 릴리스 트레인 BOM을 사용하려면, POM의 <dependencyManagement /> 섹션에 이 종속성을 선언합니다. <dependency> <groupId>org.springframework.data</groupId> <artifactId>spring-data-bom</artifactId> <version>2024.0.4</version> <scope>import</scope> <type>pom</type> </dependency> 그런 다음, <dependencies /> 블록에서 버전 없이 사용하려는 Spring Data 모듈을 선언할 수 있습니다. 자세한 내용은 <https://docs.spring.io/spring-data/commons/reference/3.3/dependencies.html>을(를) 참조하십시오."
"Maven 프로젝트에서 Spring Data 릴리스 트레인 BOM을 사용하는 예제를 어디에서 찾을 수 있나요?","Maven 프로젝트에서 Spring Data 릴리스 트레인 BOM을 사용하는 예제는 Spring Data examples 저장소의 bom 디렉토리에서 찾을 수 있습니다. 자세한 내용은 <https://github.com/spring-projects/spring-data-examples/tree/main/bom>을(를) 참조하십시오."
"Spring Data를 업그레이드하는 방법은 무엇인가요?","Spring Data를 업그레이드하는 방법은 Spring Data Commons 프로젝트의 위키(https://github.com/spring-projects/spring-data-commons/wiki)에서 확인할 수 있습니다. 릴리스 노트 섹션(https://github.com/spring-projects/spring-data-commons/wiki#release-notes)에서 원하는 버전으로 업그레이드하는 방법을 찾을 수 있습니다. 업그레이드 지침은 항상 릴리스 노트의 첫 번째 항목입니다. 한 개 이상의 릴리스를 건너뛴 경우, 건너뛴 버전의 릴리스 노트도 검토해야 합니다."
"Spring Data를 업그레이드하기 위한 구체적인 지침은 어디에 있나요?","Spring Data를 업그레이드하기 위한 구체적인 지침은 Spring Data Commons 프로젝트의 위키(https://github.com/spring-projects/spring-data-commons/wiki)에서 확인할 수 있습니다. 릴리스 노트 섹션(https://github.com/spring-projects/spring-data-commons/wiki#release-notes)에서 원하는 버전으로 업그레이드하는 방법을 찾을 수 있습니다."
"Spring Data를 업그레이드할 때 이전 버전의 릴리스 노트를 검토해야 하나요?","네, Spring Data를 업그레이드할 때 한 개 이상의 릴리스를 건너뛴 경우, 건너뛴 버전의 릴리스 노트도 검토해야 합니다. 이는 업그레이드 과정에서 발생할 수 있는 문제를 방지하기 위해 도움이 됩니다."
"스프링 데이터에서 객체 매핑의 핵심 책임은 무엇인가요?","스프링 데이터에서 객체 매핑의 핵심 책임은 도메인 객체의 인스턴스를 생성하고, 스토어 네이티브 데이터 구조를 해당 객체에 매핑하는 것입니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/object-mapping.html)"
"스프링 데이터에서 도메인 클래스를 생성자 최적화를 위해 어떤 제약 조건을 따라야 하나요?","스프링 데이터에서 도메인 클래스를 생성자 최적화를 위해 다음과 같은 제약 조건을 따라야 합니다: private 클래스가 아니어야 하며, static이 아닌 내부 클래스가 아니어야 하고, CGLib 프록시 클래스가 아니어야 합니다. 또한, 스프링 데이터에서 사용할 생성자는 private이 아니어야 합니다. 이러한 조건 중 하나라도 일치하면 스프링 데이터는 리플렉션을 통해 엔티티 인스턴스를 생성합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/object-mapping.html)"
"스프링 데이터에서 엔티티의 인스턴스가 생성된 후, 어떤 알고리즘을 사용하여 나머지 영구적 속성을 설정하나요?","스프링 데이터에서 엔티티의 인스턴스가 생성된 후, 엔티티 클래스의 나머지 영구적 속성을 설정하기 위해 다음과 같은 알고리즘을 사용합니다: 속성이 불변이지만 with... 메서드를 노출하는 경우, with... 메서드를 사용하여 새로운 엔티티 인스턴스를 생성하고 새로운 속성 값을 설정합니다. 속성 접근(즉, getter 및 setter를 통한 접근)이 정의된 경우, setter 메서드를 호출합니다. 속성이 가변적인 경우, 필드를 직접 설정합니다. 속성이 불변인 경우, 지속성 작업에 사용되는 생성자를 사용하여 인스턴스의 복사본을 만듭니다. 기본적으로 필드 값을 직접 설정합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/object-mapping.html)"
"스프링 데이터 레파지토리 추상화의 목표는 무엇인가요?","다양한 지속성 저장소에 대한 데이터 액세스 레이어를 구현하는 데 필요한 보일러플레이트 코드의 양을 크게 줄이는 것입니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories.html)"
"스프링 데이터 레파지토리 개념과 인터페이스에 대한 자세한 정보를 얻을 수 있는 곳은 어디인가요?","스프링 데이터 레파지토리 문서와 모듈에서 확인할 수 있습니다. 이 장에서는 핵심 개념과 인터페이스에 대한 설명을 제공하며, 정보는 스프링 데이터 공용 모듈에서 가져옵니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories.html)"
"스프링 데이터 레파지토리의 XML 구성에 대한 정보는 어디에서 찾을 수 있나요?","네임스페이스 참조(repositories/namespace-reference.html#repositories.namespace-reference)에서 확인할 수 있습니다. 이는 레파지토리 API를 지원하는 모든 스프링 데이터 모듈에서 지원되는 XML 구성을 다룹니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories.html)"
"Spring Data에서 Repository 인터페이스는 어떤 역할을 하나요?","Spring Data에서 Repository 인터페이스는 관리할 도메인 클래스와 도메인 클래스의 식별자 유형을 타입 인자로 받는 중앙 인터페이스입니다. 이 인터페이스는 주로 작업할 유형을 캡처하고 이 인터페이스를 확장하는 인터페이스를 발견하는 데 도움이 되는 마커 인터페이스로 작동합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/core-concepts.html)"
"CrudRepository와 ListCrudRepository 인터페이스는 어떤 기능을 제공하나요?","CrudRepository와 ListCrudRepository 인터페이스는 관리 중인 엔티티 클래스에 대한 정교한 CRUD 기능을 제공합니다. CrudRepository 인터페이스의 메서드는 Iterable을 반환하고, ListCrudRepository는 List를 반환합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/core-concepts.html)"
"PagingAndSortingRepository와 ListPagingAndSortingRepository 인터페이스는 어떤 기능을 제공하나요?","PagingAndSortingRepository와 ListPagingAndSortingRepository 인터페이스는 엔티티에 대한 페이지화된 액세스를 용이하게 하는 추가 메서드를 제공합니다. 이러한 메서드는 도메인 클래스의 식별자 유형을 타입 인자로 받는 Iterable<T> findAll(Sort sort) 및 Page<T> findAll(Pageable pageable)입니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/core-concepts.html)"
"스프링 데이터 리포지토리를 정의하는 방법은 무엇인가요?","리포지토리 인터페이스를 정의하려면 먼저 도메인 클래스별 리포지토리 인터페이스를 정의해야 합니다. 인터페이스는 Repository를 상속하고 도메인 클래스 및 ID 유형에 대해 타입이 지정되어야 합니다. 해당 도메인 유형에 대한 CRUD 메서드를 노출하려면 Repository 대신 CrudRepository 또는 해당 변형 중 하나를 상속할 수 있습니다."
"스프링 데이터에서 리포지토리 유형을 세분화하는 방법은 무엇인가요?","CRUD 리포지토리 인터페이스 중 하나를 상속하면 엔티티를 조작하는 완전한 세트 메서드가 노출됩니다. 노출되는 메서드를 선택적으로 지정하려면 CRUD 리포지토리에서 노출하려는 메서드를 도메인 리포지토리로 복사하면 됩니다. 이렇게 하면 가능한 경우 Spring Data가 반환 유형을 준수합니다."
"스프링 데이터에서 여러 모듈을 사용할 때 리포지토리를 사용하는 방법은 무엇인가요?","스프링 데이터는 리포지토리 또는 도메인 클래스의 세부 정보를 사용하여 리포지토리 정의에 대한 스프링 데이터 모듈 바인딩을 결정합니다. 리포지토리 정의가 모듈별 리포지토리 인터페이스를 상속하는 경우 해당 특정 스프링 데이터 모듈의 유효한 후보입니다. 도메인 클래스가 모듈별 유형 어노테이션으로 어노테이션 처리된 경우 해당 특정 스프링 데이터 모듈의 유효한 후보입니다."
"스프링 데이터에서 쿼리 메소드를 정의하는 방법은 무엇인가요?","스프링 데이터에서 쿼리 메소드를 정의하는 두 가지 방법이 있습니다. 첫 번째는 쿼리 메소드 이름에서 직접 쿼리를 파생하는 것입니다. 두 번째는 수동으로 정의된 쿼리를 사용하는 것입니다. 사용 가능한 옵션은 실제 저장소에 따라 다릅니다. 그러나 어떤 실제 쿼리가 생성되는지 결정하는 전략이 있어야 합니다. 다음 섹션에서는 사용 가능한 옵션에 대해 설명합니다. (Source: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/query-methods-details.html)"
"리포지토리 인프라에서 쿼리를 해결하기 위해 사용 가능한 전략은 무엇인가요?","리포지토리 인프라에서 쿼리를 해결하기 위해 사용 가능한 전략은 XML 구성에서 query-lookup-strategy 속성을 통해 네임스페이스에서 전략을 구성할 수 있습니다. 자바 구성에서는 EnableJpaRepositories 어노테이션의 queryLookupStrategy 속성을 사용할 수 있습니다. 일부 전략은 특정 데이터 저장소에 대해 지원되지 않을 수 있습니다. CREATE는 쿼리 메소드 이름에서 저장소별 쿼리를 구성하려고 시도합니다. 쿼리 메소드 이름에서 주어진 일련의 잘 알려진 접두사를 제거하고 메소드의 나머지 부분을 파싱하는 것이 일반적인 접근 방식입니다. 쿼리 생성에 대한 자세한 내용은 'Query Creation(#repositories.query-methods.query-creation)'에서 확인할 수 있습니다. USE_DECLARED_QUERY는 선언된 쿼리를 찾으려고 시도하고 찾지 못하면 예외를 throw합니다. 쿼리는 어딘가에 어노테이션으로 정의되거나 다른 방법으로 선언될 수 있습니다. 해당 저장소에 대한 사용 가능한 옵션을 찾으려면 특정 저장소의 문서를 참조하십시오. 리포지토리 인프라가 부트스트랩 시간에 메소드에 대한 선언된 쿼리를 찾지 못하면 실패합니다. CREATE_IF_NOT_FOUND(기본값)는 CREATE와 USE_DECLARED_QUERY를 결합합니다. 먼저 선언된 쿼리를 찾고, 선언된 쿼리를 찾지 못하면 사용자 지정 메소드 이름 기반 쿼리를 생성합니다. 이것은 기본 조회 전략이며, 명시적으로 아무것도 구성하지 않은 경우 사용됩니다. 메소드 이름으로 빠른 쿼리 정의가 가능하지만 필요에 따라 선언된 쿼리를 도입하여 이러한 쿼리를 사용자 지정할 수 있습니다. (Source: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/query-methods-details.html)"
"스프링 데이터 리포지토리 인프라에 내장된 쿼리 빌더 메커니즘은 어떤 용도로 사용되나요?","스프링 데이터 리포지토리 인프라에 내장된 쿼리 빌더 메커니즘은 리포지토리의 엔티티에 대한 제약 쿼리를 구축하는 데 유용합니다. 다음 예제는 여러 쿼리를 만드는 방법을 보여줍니다. 메소드 이름에서 쿼리를 생성하는 것은 리포지토리의 엔티티에 대한 제약 쿼리를 구축하는 데 유용합니다. (Source: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/query-methods-details.html)"
"스프링 데이터 커스텀 리포지토리 구현을 어떻게 생성하나요?","커스텀 리포지토리 기능을 위한 인터페이스를 정의하고, 커스텀 리포지토리 기능을 위한 구현 클래스를 만든 다음, 리포지토리 인터페이스를 해당 인터페이스로 확장하면 됩니다. 인터페이스와 구현 클래스의 이름은 해당 인터페이스에 대응하는 클래스 이름의 가장 중요한 부분은 Impl 접미사입니다. 구현 자체는 Spring Data에 의존하지 않으며, 일반적인 Spring 빈이 될 수 있습니다. 그런 다음, 해당 정보를 포함한 구성 파일을 사용하여 커스텀 리포지토리 구현을 구성할 수 있습니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/custom-implementations.html)"
"Spring Data에서 리포지토리의 커스텀 기능을 어떻게 추가할 수 있나요?","먼저 커스텀 기능을 위한 파편 인터페이스와 구현을 정의해야 합니다. 그런 다음, 리포지토리 인터페이스를 해당 인터페이스로 확장할 수 있습니다. 파편 인터페이스를 리포지토리 인터페이스로 확장하면 CRUD 및 커스텀 기능이 결합되어 클라이언트에서 사용할 수 있습니다. 리포지토리는 선언된 순서대로 가져온 여러 커스텀 구현으로 구성될 수 있으며, 커스텀 구현은 기본 구현 및 리포지토리 측면보다 우선순위가 높습니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/custom-implementations.html)"
"Spring Data에서 커스텀 리포지토리 기본 클래스를 어떻게 구성하나요?","기본 리포지토리 클래스를 확장하는 구현 클래스를 만들어야 합니다. 이 클래스는 새로운 도입된 메서드에서 사용하기 위해 EntityManager를 유지해야 합니다. Spring Data 인프라가 커스텀 리포지토리 기본 클래스를 인식하도록 하려면, 구성을 사용하여 repositoryBaseClass를 사용하면 됩니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/custom-implementations.html)"
"스프링 데이터에서 @DomainEvents 어노테이션을 사용하는 목적은 무엇인가요?","스프링 데이터에서 @DomainEvents 어노테이션을 사용하는 목적은 애그리게이트 루트에서 도메인 이벤트를 쉽게 게시하기 위함입니다. 이 어노테이션은 애그리게이트 루트의 메서드에 적용할 수 있으며, 단일 이벤트 인스턴스 또는 이벤트 컬렉션을 반환할 수 있습니다. (출처: <https://docs.spring.io/spring-data/commons/reference/3.3/repositories/core-domain-events.html>)"
"스프링 데이터에서 @AfterDomainEventPublication 어노테이션을 사용하는 목적은 무엇인가요?","스프링 데이터에서 @AfterDomainEventPublication 어노테이션을 사용하는 목적은 모든 이벤트가 게시된 후, 게시될 이벤트 목록을 정리하는 등 잠재적으로 정리 작업을 수행할 수 있는 메서드를 지정하는 것입니다. (출처: <https://docs.spring.io/spring-data/commons/reference/3.3/repositories/core-domain-events.html>)"
"스프링 데이터에서 @DomainEvents와 @AfterDomainEventPublication 메서드가 호출되는 경우는 언제인가요?","스프링 데이터에서 @DomainEvents와 @AfterDomainEventPublication 메서드는 Spring Data 리포지토리 메서드 중 save(...), saveAll(...), delete(...), deleteAll(...), deleteAllInBatch(...), deleteInBatch(...) 중 하나가 호출될 때 호출됩니다. 이 메서드들은 애그리게이트 루트 인스턴스를 인자로 받습니다. deleteById(...)는 구현에 따라 쿼리를 발행하여 인스턴스를 삭제할 수 있으므로 애그리게이트 인스턴스에 대한 액세스 권한이 없습니다. (출처: <https://docs.spring.io/spring-data/commons/reference/3.3/repositories/core-domain-events.html>)"
"Spring Data는 어떤 Spring Data 모듈과 통합되어 Spring Data를 다양한 컨텍스트에서 사용할 수 있게 하는가요?","Querydsl(http://www.querydsl.com/)"
"QuerydslPredicateExecutor 인터페이스를 사용하여 Querydsl과 통합하는 방법은 무엇인가요?","QuerydslPredicateExecutor를 리포지토리 인터페이스에 확장합니다."
"Spring Data의 웹 지원은 어떤 Spring Data 모듈과 함께 제공되나요?","Spring Data의 리포지토리 프로그래밍 모델을 지원하는 모듈은 다양한 웹 지원을 제공합니다."
"스프링 데이터의 스크롤링은 어떤 상황에서 사용되나요?","스프링 데이터의 스크롤링은 큰 결과 집합을 처리할 때 사용되며, 페이지네이션에 비해 더 세밀한 접근 방식으로 결과를 가져올 수 있습니다. 스크롤링은 안정적인 정렬, 스크롤 유형(오프셋 또는 키셋 기반 스크롤링) 및 결과 제한을 포함합니다. Querydsl을 사용하여 표현식을 연결하여 여러 기준을 하나의 표현식으로 수집할 수 있습니다. ScrollPosition은 전체 쿼리 결과에서 요소의 정확한 위치를 식별합니다. 스크롤 위치는 독점적으로 처리되므로 결과는 주어진 위치 이후에 시작됩니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/scrolling.html)"
"오프셋 스크롤링과 키셋 필터링의 차이점은 무엇인가요?","오프셋 스크롤링은 페이지네이션과 유사하게 오프셋 카운터를 사용하여 결과 수를 건너뛰고 데이터 소스에서 주어진 오프셋부터 결과를 반환하도록 합니다. 그러나 대부분의 데이터베이스는 서버가 결과를 반환하기 전에 전체 쿼리 결과를 구체화해야 합니다. 반면, 키셋 필터링은 데이터베이스의 내장 기능을 활용하여 결과 하위 집합을 검색하는 접근 방식으로, 개별 쿼리에 대한 계산 및 I/O 요구 사항을 줄이는 것을 목표로 합니다. 이 접근 방식은 쿼리에 키를 전달하여 스크롤링을 재개하기 위해 키 집합을 유지하며, 필터 기준을 수정합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/scrolling.html)"
"키셋 기반 스크롤링의 제한 사항은 무엇인가요?","키셋 기반 스크롤링의 주요 제한 사항은 키셋 속성(정렬에 사용되는 속성)이 null이 아니어야 한다는 것입니다. 이 제한은 비교 연산자의 저장소별 null 값 처리와 인덱싱된 소스에 대해 쿼리를 실행해야 하는 필요성 때문에 적용됩니다. 널 가능한 속성에 대해 키셋 필터링을 사용하면 예기치 않은 결과가 발생할 수 있습니다. 키셋 기반 스크롤링을 적용하는 쿼리에는 정렬에 사용되는 속성이 반환되어야 하며, 이러한 속성은 반환된 엔티티에 매핑되어야 합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/scrolling.html)"
"스프링 데이터에서 리포지토리 메서드의 반환값이 없을 때 어떻게 처리하나요?","스프링 데이터 2.0부터는 리포지토리 CRUD 메서드에서 개별 집합 인스턴스를 반환하는 경우 Java 8의 Optional을 사용하여 값의 부재 가능성을 나타냅니다. 또한, Spring Data는 쿼리 메서드에서 다음과 같은 래퍼 유형을 반환하는 것을 지원합니다: com.google.common.base.Optional, scala.Option, io.vavr.control.Option. 또는 쿼리 메서드는 래퍼 유형을 전혀 사용하지 않을 수도 있습니다. 이 경우 쿼리 결과의 부재는 null을 반환하여 나타냅니다. 컬렉션, 컬렉션 대안, 래퍼 및 스트림을 반환하는 리포지토리 메서드는 null을 반환하지 않고 해당 빈 표현을 반환합니다. 자세한 내용은 '리포지토리 쿼리 반환 유형(query-return-types-reference.html)'을 참조하십시오. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/null-handling.html)"
"스프링 데이터에서 리포지토리 메서드의 파라미터와 반환값에 대한 nullability 제약 조건을 어떻게 표현할 수 있나요?","스프링 프레임워크의 nullability 어노테이션을 사용하여 리포지토리 메서드의 nullability 제약 조건을 표현할 수 있습니다. @NonNullApi 어노테이션은 패키지 수준에서 사용되어 파라미터와 반환값에 대한 기본 동작을 각각 null 값을 허용하거나 생성하지 않는 것으로 선언합니다. @NonNull 어노테이션은 null이 아니어야 하는 파라미터 또는 반환값에 사용됩니다. @Nullable 어노테이션은 null이 될 수 있는 파라미터 또는 반환값에 사용됩니다. JSR 305 메타 어노테이션은 도구 공급업체가 스프링 어노테이션에 대한 지원을 하드 코딩하지 않고도 일반적인 방식으로 null-safety 지원을 제공할 수 있도록 합니다. 쿼리 메서드에 대한 nullability 제약 조건을 런타임에서 확인하려면 package-info.java에서 Spring의 @NonNullApi를 사용하여 패키지 수준에서 null이 아님을 활성화해야 합니다. 이 경우 쿼리 메서드 호출은 nullability 제약 조건에 대해 런타임에서 유효성을 검사합니다. 정의된 제약 조건을 위반하는 쿼리 결과가 있는 경우 예외가 발생합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/null-handling.html)"
"코틀린 기반 리포지토리에서 nullability 제약 조건을 어떻게 처리하나요?","코틀린은 언어에 nullability 제약 조건의 정의를 내장하고 있습니다. 코틀린 코드는 메서드 시그니처를 통해 nullability 제약 조건을 표현하지 않고 컴파일된 메타데이터를 통해 표현됩니다. 코틀린의 nullability 제약 조건을 검사하려면 프로젝트에 kotlin-reflect JAR를 포함해야 합니다. Spring Data 리포지토리는 언어 메커니즘을 사용하여 이러한 제약 조건을 정의하고 동일한 런타임 검사를 적용합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/null-handling.html)"
"Spring Data에서 프로젝션이란 무엇인가요?","Spring Data에서 프로젝션은 관리되는 집합체의 일부 속성을 기반으로 선언적으로 모델링하는 유형입니다. 프로젝션은 프로그래밍 방식으로 생성되지 않고 유형 계층 외부에 존재합니다. 프로젝션에는 인터페이스 기반 프로젝션과 클래스 기반 프로젝션(DTO)이 있습니다. 프로젝션은 부분 뷰를 검색하기 위해 사용되며, 쿼리 메서드의 반환 유형으로 사용할 수 있습니다. Spring Data는 쿼리 메서드의 반환 유형을 사용하여 프로젝션 프록시를 생성하여 프로젝션을 지원합니다. 프로젝션은 재귀적으로 사용할 수 있습니다."
"인터페이스 기반 프로젝션과 클래스 기반 프로젝션(DTO)의 차이점은 무엇인가요?","인터페이스 기반 프로젝션은 관리되는 집합체의 일부 속성을 기반으로 선언적으로 모델링하는 유형입니다. 인터페이스 기반 프로젝션은 쿼리 메서드의 반환 유형으로 사용할 수 있으며, Spring Data는 쿼리 메서드의 반환 유형을 사용하여 프로젝션 프록시를 생성합니다. 클래스 기반 프로젝션(DTO)은 값 유형 DTO(데이터 전송 객체)를 사용하여 검색하려는 필드에 대한 속성을 보유합니다. DTO 유형은 프로젝션 인터페이스와 동일한 방식으로 사용할 수 있지만, 프록시 생성이 발생하지 않으며 중첩 프로젝션을 적용할 수 없습니다. DTO는 값 의미론을 준수하며 equals(...), hashCode() 및 toString() 메서드가 자동으로 생성됩니다."
"Spring Data에서 닫힌 프로젝션과 열린 프로젝션의 차이점은 무엇인가요?","닫힌 프로젝션은 프로젝션 인터페이스의 접근자 메서드가 모두 대상 집합체의 속성과 일치하는 프로젝션입니다. 닫힌 프로젝션은 쿼리 실행 최적화를 가능하게 합니다. 열린 프로젝션은 @Value 어노테이션을 사용하여 새로운 값을 계산하는 프로젝션 인터페이스의 접근자 메서드입니다. 열린 프로젝션은 Spring Data가 쿼리 실행 최적화를 적용할 수 없으며, SpEL 표현이 집합체의 모든 속성을 사용할 수 있습니다. 열린 프로젝션은 간단한 표현식에 대해 기본 메서드를 사용하거나, 더 유연한 옵션을 위해 Spring 빈에서 사용자 정의 로직을 구현할 수 있습니다."
"Query by Example(QBE)란 무엇인가요?","Query by Example(QBE)는 간단한 인터페이스를 가진 사용자 친화적인 쿼리 기술입니다. 동적 쿼리 생성을 허용하며 필드 이름을 포함하는 쿼리를 작성할 필요가 없습니다. 실제로 Query by Example은 스토어별 쿼리 언어를 사용하여 쿼리를 작성할 필요가 없습니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/query-by-example.html)"
"Query by Example API의 네 가지 부분은 무엇인가요?","Query by Example API는 Probe, ExampleMatcher, Example, FetchableFluentQuery의 네 가지 부분으로 구성됩니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/query-by-example.html)"
"Query by Example의 제한 사항은 무엇인가요?","Query by Example은 중첩 또는 그룹화된 속성 제약 조건(예: firstname = ?0 또는 (firstname = ?1 and lastname = ?2))에 대한 지원, 문자열 일치에 대한 스토어별 지원 등의 제한 사항이 있습니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/query-by-example.html)"
"스프링 데이터에서 Value Expressions는 어떤 역할을 하나요?","Value Expressions는 Spring Expression Language (SpEL)과 Property Placeholder Resolution의 조합으로, 프로그램적인 표현식의 강력한 평가와 Environment(구성 속성 등)의 값을 가져오기 위한 property-placeholder resolution의 간결함을 결합합니다. 이는 주석이 달린 값과 같은 신뢰할 수 있는 입력에 의해 정의되어야 하며, 사용자 입력에서 결정되어서는 안 됩니다. Value Expression API를 사용하여 파싱 및 평가는 ValueExpressionParser API에 의해 처리되며, SpEL 표현식은 #{…} 형식으로 둘러싸인 Template 스타일을 따릅니다. 평가 컨텍스트는 EvaluationContextProvider에 의해 제공되며, ExtensionAwareEvaluationContextProvider와 같은 구현체는 애플리케이션 컨텍스트에서 컨텍스트 확장을 결정합니다. 컨텍스트 확장은 루트 객체, 속성 및 함수를 제공하여 EvaluationContext를 채우는 데 사용됩니다. 또한, ${…} 형식의 속성 플레이스홀더는 Environment를 통해 제공되는 속성을 참조하며, 시스템 속성, 애플리케이션 구성 파일, 환경 구성 또는 비밀 관리 시스템에 의해 기여된 속성 소스와 같은 값을 해결하는 데 유용합니다."
"Value Expressions에서 Property Placeholder Resolution은 어떤 역할을 하나요?","Value Expressions에서 Property Placeholder Resolution은 ${...} 형식으로 표시되는 플레이스홀더를 통해 Environment(구성 속성 등)의 값을 가져오는 데 사용됩니다. 이러한 플레이스홀더는 시스템 속성, 애플리케이션 구성 파일, 환경 구성 또는 비밀 관리 시스템과 같은 다양한 소스에서 값을 해결하는 데 유용합니다. 스프링 프레임워크의 @Value 사용에 대한 문서에서 속성 플레이스홀더에 대한 자세한 내용을 확인할 수 있습니다."
"Value Expressions의 성능 고려 사항은 무엇인가요?","Value Expressions는 코드에 많은 유연성을 제공하지만, 각 사용 시 표현식을 평가해야 하므로 성능에 영향을 줄 수 있습니다. 따라서, 신뢰할 수 있는 소스(예: 주석)에서만 표현식을 파싱하고 평가하며, 사용자 제공 표현식을 받아들이면 보안 취약점이 발생할 수 있으므로 주의해야 합니다. 또한, 파싱 및 평가를 피하기 위해 ValueExpression을 캐시하여 나중에 사용할 수 있습니다."
"스프링 데이터에서 리액티브 인프라를 사용할 때, @CreatedBy 또는 @LastModifiedBy 정보를 어떻게 프로바이더 할 수 있나요?","스프링 데이터에서 리액티브 인프라를 사용할 때, ReactiveAuditorAware<T> SPI 인터페이스를 구현하여 애플리케이션과 상호 작용하는 현재 사용자 또는 시스템을 인프라에 알려야 합니다. 제네릭 타입 T는 @CreatedBy 또는 @LastModifiedBy로 주석이 달린 속성의 타입을 정의합니다. 다음 예제는 리액티브 스프링 시큐리티의 Authentication 객체를 사용하는 인터페이스의 구현을 보여줍니다: Implementation of ReactiveAuditorAware based on Spring Security class SpringSecurityAuditorAware implements ReactiveAuditorAware<User> { @Override public Mono<User> getCurrentAuditor() { return ReactiveSecurityContextHolder.getContext() .map(SecurityContext::getAuthentication) .filter(Authentication::isAuthenticated) .map(Authentication::getPrincipal) .map(User.class::cast); } } 구현은 스프링 시큐리티에서 제공하는 Authentication 객체에 액세스하고, UserDetails 구현에서 생성한 사용자 정의 UserDetails 인스턴스를 찾습니다. 여기서 가정하는 것은 UserDetails 구현을 통해 도메인 사용자를 노출하지만, 찾은 Authentication을 기반으로 어디에서든 찾아볼 수 있다는 것입니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/auditing.html)"
"스프링 데이터에서 감사 메타데이터를 정의하는 데 어노테이션 대신 인터페이스를 사용하는 방법은 무엇인가요?","스프링 데이터에서 감사 메타데이터를 정의하는 데 어노테이션 대신 인터페이스를 사용하려면 도메인 클래스가 Auditable 인터페이스를 구현하도록 해야 합니다. 이 인터페이스는 모든 감사 속성에 대한 setter 메서드를 노출합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/auditing.html)"
"스프링 데이터에서 감사 메타데이터는 반드시 루트 레벨 엔티티에 있어야 하나요?","스프링 데이터에서 감사 메타데이터는 반드시 루트 레벨 엔티티에 있을 필요는 없습니다. 실제 사용 중인 저장소에 따라 감사 메타데이터를 임베디드 엔티티에 추가할 수 있습니다. 예시: Audit metadata in embedded entity class Customer { private AuditMetadata auditingMetadata; // … further properties omitted } class AuditMetadata { @CreatedBy private User user; @CreatedDate private Instant createdDate; } (출처: https://docs.spring.io/spring-data/commons/reference/3.3/auditing.html)"
"스프링에서 커스텀 컨버전(Conversion)을 어떻게 구현하나요?","스프링에서 커스텀 컨버전을 구현하려면, `Converter` 인터페이스를 구현하는 클래스를 작성하면 됩니다. 이 클래스에서는 `convert` 메소드를 오버라이드하여 소스 타입을 대상 타입으로 변환하는 로직을 구현합니다. 예를 들어, `String`을 `Email` 객체로 변환하는 `Converter` 구현 예시는 다음과 같습니다: `@ReadingConverter public class EmailReadConverter implements Converter<String, Email> { public Email convert(String source) { return Email.valueOf(source); } }` 또한, 컨버터는 소스 및 대상 타입에 따라 읽기 또는 쓰기 컨버터로 등록할 수 있습니다. 이를 위해 `@ReadingConverter` 및 `@WritingConverter` 어노테이션을 사용할 수 있습니다. 컨버터는 `CustomConversions`에 등록되어 소스 및 대상 타입에 따라 등록된 컨버터를 등록하고 조회할 수 있습니다. 내장된 컨버터 세트에는 JSR-310 컨버터가 포함되어 있으며, 이는 `java.time`, `java.util.Date` 및 `String` 타입 간의 변환을 처리합니다. 또한, 로컬 시간형(예: `LocalDateTime`에서 `java.util.Date`로)에 대한 기본 컨버터는 시스템 기본 시간대 설정을 사용하여 해당 타입 간의 변환을 수행합니다. 기본 컨버터를 재정의하여 사용자 정의 컨버터를 등록할 수 있습니다."
"스프링 컨버터에서 `@ReadingConverter`와 `@WritingConverter` 어노테이션은 어떻게 사용되나요?","`@ReadingConverter`와 `@WritingConverter` 어노테이션은 컨버터의 등록 방향을 지정하는 데 사용됩니다. `@ReadingConverter`는 소스 타입을 대상 타입으로 변환하는 읽기 컨버터를 나타내며, `@WritingConverter`는 대상 타입을 소스 타입으로 변환하는 쓰기 컨버터를 나타냅니다. 컨버터의 소스 및 대상 타입을 검사하여 기본 데이터 액세스 API에서 기본적으로 처리할 수 있는 타입인지 여부에 따라 컨버터 인스턴스를 읽기 또는 쓰기 컨버터로 등록합니다. 예를 들어, `String`을 `Long`으로 변환하는 `Converter<String, Long>`는 쓰기 시 모든 `String` 인스턴스를 `Long` 인스턴스로 변환하려고 시도하는 것이 의미가 없을 수 있으므로 모호합니다. 따라서, 컨버터 구현에서 `@ReadingConverter` 또는 `@WritingConverter` 어노테이션을 사용하여 컨버터를 한 방향으로만 등록하도록 강제할 수 있습니다."
"스프링에서 내장된 JSR-310 컨버터에 대해 알려주세요.","스프링은 JSR-310 컨버터 세트를 내장하고 있습니다. 이 컨버터는 `java.time`, `java.util.Date` 및 `String` 타입 간의 변환을 처리합니다. 로컬 시간형(예: `LocalDateTime`에서 `java.util.Date`로)에 대한 기본 컨버터는 시스템 기본 시간대 설정을 사용하여 해당 타입 간의 변환을 수행합니다. 기본 컨버터를 재정의하여 사용자 정의 컨버터를 등록할 수 있습니다. 내장된 JSR-310 컨버터는 `CustomConversions`에 등록되어 있으며, 소스 및 대상 타입에 따라 등록된 컨버터를 등록하고 조회할 수 있습니다. 내장된 JSR-310 컨버터를 사용하여 Java 8에서 도입된 새로운 `java.time` API와 이전 `java.util.Date` API 간의 변환을 쉽게 수행할 수 있습니다."
"스프링 데이터에서 Entity Callback은 어떤 역할을 하나요?","스프링 데이터에서 Entity Callback은 특정 메서드가 호출되기 전과 후에 엔티티를 수정하기 위한 훅을 제공합니다. 이는 엔티티를 콜백 스타일로 확인하고 수정할 수 있는 편리한 방법을 제공합니다. EntityCallback은 전문화된 ApplicationListener와 매우 유사합니다. 일부 스프링 데이터 모듈은 주어진 엔티티를 수정할 수 있는 BeforeSaveEvent와 같은 스토어별 이벤트를 게시합니다. 불변형 타입과 작업할 때와 같은 경우, 이러한 이벤트는 문제를 일으킬 수 있습니다. Entity callback은 동기 및 비동기 API와의 통합 지점을 제공하여 처리 체인 내에서 잘 정의된 체크포인트에서 순차 실행을 보장하고, 잠재적으로 수정된 엔티티 또는 비동기 래퍼 타입을 반환합니다. (출처: <https://docs.spring.io/spring-data/commons/reference/3.3/entity-callbacks.html>)"
"스프링 데이터에서 Entity Callback을 구현하는 방법은 무엇인가요?","EntityCallback은 그 도메인 타입과 직접적으로 연관되어 있으며, 이는 그 제네릭 타입 인자를 통해 이루어집니다. 각 스프링 데이터 모듈은 일반적으로 엔티티 라이프사이클을 커버하는 미리 정의된 EntityCallback 인터페이스의 집합을 제공합니다. EntityCallback의 해부학은 BeforeSaveCallback 인터페이스가 BeforeSaveCallback<T> extends EntityCallback<T>와 같이 보이며, 지정되지 않은 엔티티 콜백 인자에 대한 선택적 매개변수는 구현하는 스프링 데이터 모듈에 의해 정의되고, EntityCallback.callback()의 호출 지점에서 추론됩니다. 예를 들어, BeforeSaveCallback 인터페이스를 구현하여 애플리케이션 요구에 맞게 인터페이스를 구현할 수 있습니다. (출처: <https://docs.spring.io/spring-data/commons/reference/3.3/entity-callbacks.html>)"
"스프링 데이터에서 Entity Callback을 등록하는 방법은 무엇인가요?","EntityCallback 빈은 ApplicationContext에 등록되어 있는 경우 스토어별 구현에서 선택됩니다. 대부분의 템플릿 API는 이미 ApplicationContextAware를 구현하고 있으며, 따라서 ApplicationContext에 액세스할 수 있습니다. EntityCallbackConfiguration 클래스를 사용하여 다양한 유효한 엔티티 콜백 등록 컬렉션을 구성할 수 있습니다. 예를 들어, BeforeSaveCallback을 구현하는 클래스를 만들고 @Component 어노테이션을 추가하여 등록할 수 있습니다. 또한, BeforeSaveCallback을 람다 표현식으로 구현하고 @Bean 어노테이션을 사용하여 등록할 수도 있습니다. (출처: <https://docs.spring.io/spring-data/commons/reference/3.3/entity-callbacks.html>)"
"스프링 데이터에서 엔티티가 새로운지 감지하기 위한 기본 전략은 무엇인가요?","@Id -Property inspection (the default)입니다. 스프링 데이터는 주어진 엔티티의 식별자 속성을 검사합니다. 식별자 속성이 null 또는 원시형인 경우 0이면 엔티티가 새로운 것으로 간주됩니다. 그렇지 않으면 새로운 것이 아닌 것으로 간주됩니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/is-new-state-detection.html)"
"스프링 데이터에서 @Version -Property inspection 전략을 사용하여 새로운 엔티티를 감지하는 방법은 무엇인가요?","@Version으로 주석이 지정된 속성이 있고 null인 경우 또는 원시형 버전 속성의 값이 0인 경우 엔티티는 새로운 것으로 간주됩니다. 버전 속성이 있지만 다른 값을 가지는 경우 엔티티는 새로운 것이 아닌 것으로 간주됩니다. 버전 속성이 없는 경우 스프링 데이터는 식별자 속성을 검사합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/is-new-state-detection.html)"
"스프링 데이터에서 Persistable 인터페이스를 구현하여 새로운 엔티티를 감지하는 방법은 무엇인가요?","엔티티가 Persistable을 구현하는 경우 스프링 데이터는 새로운 감지를 엔티티의 isNew(…) 메서드에 위임합니다. 자세한 내용은 Javadoc (https://docs.spring.io/spring-data/data-commons/docs/3.3.4/api//index.html?org/springframework/data/domain/Persistable.html)을 참조하십시오. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/is-new-state-detection.html)"
"스프링 부트를 사용하여 코틀린으로 스프링 애플리케이션을 만드는 방법은 무엇인가요?","스프링 부트와 전용 코틀린 지원을 활용하여 코틀린으로 스프링 애플리케이션을 만들 수 있습니다. 자세한 자습서는 다음 링크에서 확인할 수 있습니다: https://spring.io/guides/tutorials/spring-boot-kotlin/."
"코틀린과 자바 간의 상호 운용성은 어떤가요?","코틀린은 자바와 우수한 상호 운용성을 제공하여 자바로 작성된 기존 라이브러리와 함께 사용할 수 있습니다. 자세한 내용은 다음 링크를 참조하세요: https://kotlinlang.org/docs/reference/java-interop.html."
"스프링 데이터 코틀린 지원에서 어떤 기능을 활용할 수 있나요?","스프링 데이터 코틀린 지원은 요구사항, 널 안전성, 객체 매핑, 확장, 코루틴 등의 기능을 제공합니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-data/commons/reference/3.3/kotlin.html."
"Spring Data는 Kotlin과 어떤 요구사항이 필요한가요?","Spring Data는 Kotlin 1.3을 지원하며, kotlin-stdlib (또는 kotlin-stdlib-jdk8과 같은 변형) 및 kotlin-reflect가 클래스패스에 있어야 합니다. 이 요구사항은 start.spring.io를 통해 Kotlin 프로젝트를 부트스트랩하면 기본적으로 제공됩니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/kotlin/requirements.html)"
"start.spring.io를 통해 Kotlin 프로젝트를 부트스트랩하면 어떤 이점이 있나요?","start.spring.io를 통해 Kotlin 프로젝트를 부트스트랩하면 기본적으로 kotlin-stdlib와 kotlin-reflect가 제공되어 Spring Data를 Kotlin과 함께 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/kotlin/requirements.html)"
"Spring Data를 Kotlin과 함께 사용하기 위해 필요한 종속성은 무엇인가요?","Spring Data를 Kotlin과 함께 사용하기 위해서는 kotlin-stdlib (또는 kotlin-stdlib-jdk8과 같은 변형) 및 kotlin-reflect가 필요합니다. 이 종속성들은 start.spring.io를 통해 Kotlin 프로젝트를 부트스트랩하면 기본적으로 제공됩니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/kotlin/requirements.html)"
"Kotlin에서 null 안전성을 어떻게 처리하며, 이는 Java의 선택적 래퍼와 어떻게 다른가요?","Kotlin은 null 안전성을 컴파일 시간에 깔끔하게 처리하여, 선택적 래퍼와 같은 비용을 지불하지 않고도 nullability 선언과 '값 또는 값 없음' 의미론을 표현함으로써 애플리케이션을 더 안전하게 만듭니다. Kotlin은 널 가능한 값으로 함수적 구조를 사용할 수 있습니다. Kotlin null 안전성에 대한 포괄적인 가이드는 다음을 참조하십시오: https://www.baeldung.com/kotlin/null-safety."
"Kotlin은 Java API의 nullability를 어떻게 처리하며, JSR-305는 어떻게 사용되나요?","Kotlin은 Java API의 유형을 플랫폼 유형으로 인식하여 널 체크가 완화됩니다. Kotlin의 JSR-305 및 Spring nullability 주석 지원은 Kotlin 개발자에게 전체 Spring Data API에 대한 null 안전성을 제공하며, null 관련 문제를 컴파일 시간에 처리할 수 있는 장점이 있습니다. JSR-305 체크를 구성하려면 다음 옵션으로 -Xjsr305 컴파일러 플래그를 추가하십시오: -Xjsr305={strict|warn|ignore}."
"Spring Data Repositories에서 null safety가 어떻게 적용되며, 어떤 유형의 nullability는 아직 지원되지 않나요?","Spring Data Repositories에서 null safety는 Null Handling of Repository Methods(../repositories/null-handling.html) 문서에 설명되어 있습니다. 그러나 제네릭 유형 인자, varargs 및 배열 요소의 nullability는 아직 지원되지 않지만, 향후 릴리스에서 지원될 예정입니다."
"스프링 데이터에서 코틀린 객체가 어떻게 구체화되는지 설명해주세요.","스프링 데이터에서 코틀린 객체가 어떻게 구체화되는지에 대한 자세한 내용은 Kotlin 지원(https://docs.spring.io/spring-data/commons/reference/3.3/kotlin/object-mapping.html)을 참조하세요."
"코틀린 객체의 구체화와 관련된 스프링 데이터의 설정이나 구성 요소를 알려주세요.","코틀린 객체의 구체화와 관련된 스프링 데이터의 설정이나 구성 요소에 대한 정보는 Kotlin 지원(https://docs.spring.io/spring-data/commons/reference/3.3/kotlin/object-mapping.html)에서 확인할 수 있습니다."
"스프링 데이터와 코틀린을 함께 사용할 때, 객체 구체화 과정에서 주의해야 할 사항이 있나요?","스프링 데이터와 코틀린을 함께 사용할 때, 객체 구체화 과정에서 주의해야 할 사항에 대한 정보는 Kotlin 지원(https://docs.spring.io/spring-data/commons/reference/3.3/kotlin/object-mapping.html)에서 확인할 수 있습니다."
"Kotlin extensions는 Spring Data Kotlin API에서 어떤 역할을 하나요?","Kotlin extensions는 Spring Data Kotlin API에서 기존 Spring API에 새로운 Kotlin 전용 편의 기능을 추가합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/kotlin/extensions.html)"
"Kotlin extensions를 사용하려면 어떻게 해야 하나요?","Kotlin extensions를 사용하려면 해당 확장 함수를 import해야 합니다. 대부분의 경우 IDE에서 자동으로 import를 제안합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/kotlin/extensions.html)"
"Kotlin의 reified type parameters는 무엇인가요?","Kotlin의 reified type parameters는 JVM generics type erasure를 해결하기 위한 방법입니다. Spring Data는 이 기능을 활용하기 위해 몇 가지 확장 기능을 제공합니다. 이를 통해 Kotlin API를 더욱 개선할 수 있습니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/kotlin/extensions.html)"
"코루틴이란 무엇이며, 어떻게 비동기 코드를 작성하는 데 사용되나요?","코루틴은 중단 가능한 계산의 인스턴스로, 비동기 코드를 작성하는 데 사용됩니다. 언어 수준에서는, suspend 함수는 비동기 작업을 위한 추상화를 제공하고, 라이브러리 수준에서는 kotlinx.coroutines 라이브러리가 async { } 함수와 Flow와 같은 유형을 제공합니다. 코루틴은 중단 가능한 작업을 가능하게 하여, 비동기 작업을 쉽게 작성할 수 있도록 도와줍니다."
"Spring Data에서 코루틴을 지원하는 방법은 무엇인가요?","Spring Data의 코루틴 지원은 Kotlin 확장에서 Deferred 및 Flow 반환 값 지원을 통해 이루어집니다. 코루틴 지원은 kotlinx-coroutines-core, kotlinx-coroutines-reactive 및 kotlinx-coroutines-reactor 종속성이 클래스패스에 있을 때 활성화됩니다. 지원되는 버전은 1.3.0 이상입니다."
"Reactive와 Coroutines 간의 반환 값에 대한 번역은 어떻게 이루어지나요?","반환 값의 경우, Reactive에서 Coroutines API로의 번역은 다음과 같습니다: fun handler(): Mono<Void>는 suspend fun handler()로, fun handler(): Mono<T>는 suspend fun handler(): T 또는 suspend fun handler(): T?로 변환됩니다. (Mono가 비어 있을 수 있는지 여부에 따라) 더 정적으로 유형이 지정되는 장점이 있습니다. fun handler(): Flux<T>는 fun handler(): Flow<T>로 변환됩니다. Flow는 Coroutines 세계에서 Flux와 동등한 것으로, 핫 또는 콜드 스트림, 유한 또는 무한한 스트림에 적합하며, 다음과 같은 주요 차이점이 있습니다: Flow는 푸시 기반이며, Flux는 푸시-풀 하이브리드입니다. 백프레셔는 중단 가능한 함수를 통해 구현됩니다. Flow에는 단일 중단 가능한 collect 메서드(https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/collect.html)만 있으며, 연산자는 확장 함수(https://kotlinlang.org/docs/reference/extensions.html)로 구현됩니다. 연산자는 Coroutines 덕분에 쉽게 구현할 수 있습니다. 확장 함수를 사용하면 Flow에 사용자 정의 연산자를 추가할 수 있습니다. collect 작업은 중단 가능한 함수이며, map 연산자(https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html)는 비동기 작업을 지원합니다(flatMap이 필요하지 않음). suspend 함수 매개변수를 사용하기 때문입니다."
"Spring Data의 <repositories /> 요소는 언제 사용되나요?","Spring Data의 <repositories /> 요소는 Spring Data 리포지토리 인프라의 설정을 트리거합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/namespace-reference.html)"
"Spring Data의 <repositories /> 요소의 base-package 속성의 목적은 무엇인가요?","base-package 속성은 자동 감지 모드에서 *Repository를 확장하는 리포지토리 인터페이스를 스캔할 패키지를 정의합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/namespace-reference.html)"
"Spring Data의 <repositories /> 요소의 query-lookup-strategy 속성은 어떤 역할을 하나요?","query-lookup-strategy 속성은 finder 쿼리를 생성하는 데 사용되는 전략을 결정합니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/namespace-reference.html)"
"Spring Data repository 인프라를 통해 데이터 저장소를 채우기 위해 <populator /> 요소를 사용하는 목적은 무엇인가요?","Spring Data repository 인프라를 통해 데이터 저장소를 채우기 위해 <populator /> 요소를 사용하는 목적은 Spring Data repository 인프라를 통해 데이터 저장소를 채우는 것입니다. (출처: <https://docs.spring.io/spring-data/commons/reference/3.3/repositories/populator-namespace-reference.html>)"
"populator 요소의 locations 속성은 어떤 역할을 하나요?","populator 요소의 locations 속성은 저장소에서 객체를 읽을 파일을 찾을 위치를 지정합니다. (출처: <https://docs.spring.io/spring-data/commons/reference/3.3/repositories/populator-namespace-reference.html>)"
"populator 요소를 사용하는 방법에 대해 자세히 알아볼 수 있는 문서는 어디에서 확인할 수 있나요?","populator 요소를 사용하는 방법에 대해 자세히 알아볼 수 있는 문서는 XML Configuration(create-instances.html#repositories.create-instances.xml)에서 확인할 수 있습니다. (출처: <https://docs.spring.io/spring-data/commons/reference/3.3/repositories/populator-namespace-reference.html>)"
"스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 기본적으로 지원되는 쿼리 대상 키워드는 무엇인가요?","find...By, read...By, get...By, query...By, search...By, stream...By, exists...By, count...By, delete...By, remove...By, ...First<number>..., ...Top<number>..., ...Distinct이 기본적으로 지원되는 쿼리 대상 키워드입니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 기본적으로 지원되는 쿼리 필드 키워드는 무엇인가요?","AND, OR, AFTER, IsAfter, BEFORE, IsBefore, CONTAINING, IsContaining, Contains, BETWEEN, IsBetween, ENDING_WITH, IsEndingWith, EndsWith, EXISTS, FALSE, IsFalse, GREATER_THAN, IsGreaterThan, GREATER_THAN_EQUALS, IsGreaterThanEqual, IN, IsIn, IS, Equals, IS_EMPTY, IsNotEmpty, IS_NOT_EMPTY, IsNull, LESS_THAN, IsLessThan, LESS_THAN_EQUAL, IsLessThanEqual, LIKE, IsLike, NEAR, IsNear, NOT, IsNot, NOT_IN, IsNotIn, NOT_LIKE, IsNotLike, REGEX, MatchesRegex, Matches, STARTING_WITH, IsStartingWith, StartsWith, TRUE, IsTrue, WITHIN, IsWithin이 기본적으로 지원되는 쿼리 필드 키워드입니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 기본적으로 지원되는 쿼리 필드 수정자는 무엇인가요?","IgnoreCase, IgnoringCase, AllIgnoreCase, AllIgnoringCase, OrderBy...이 기본적으로 지원되는 쿼리 필드 수정자입니다. (출처: https://docs.spring.io/spring-data/commons/reference/3.3/repositories/query-keywords-reference.html)"
"Spring Data JDBC와 R2DBC는 어떤 공통점이 있나요?","Spring Data JDBC와 R2DBC는 모두 Java Database Connectivity (JDBC) 및 Reactive Relational Database Connectivity (R2DBC) API에 대한 리포지토리 지원을 제공합니다. (출처: <https://docs.spring.io/spring-data/relational/reference/3.3/index.html>)"
"Spring Data JDBC와 R2DBC를 사용하면 어떤 이점이 있나요?","Spring Data JDBC와 R2DBC는 SQL 데이터 소스에 액세스해야 하는 일관된 프로그래밍 모델을 제공하여 애플리케이션 개발을 용이하게 합니다. (출처: <https://docs.spring.io/spring-data/relational/reference/3.3/index.html>)"
"Spring Data JDBC와 R2DBC를 사용하여 Kotlin으로 코드를 작성할 수 있나요?","네, Spring Data JDBC와 R2DBC는 Kotlin을 지원합니다. (출처: <https://docs.spring.io/spring-data/relational/reference/3.3/index.html>)"
"Spring Data 업그레이드 지침은 어디에서 찾을 수 있나요?","Spring Data 업그레이드 지침은 프로젝트 위키(<https://github.com/spring-projects/spring-data-commons/wiki>)에서 찾을 수 있습니다."
"특정 버전으로 업그레이드하려면 어떻게 해야 하나요?","특정 버전으로 업그레이드하려면 릴리스 노트 섹션(<https://github.com/spring-projects/spring-data-commons/wiki#release-notes>)에서 원하는 버전으로 연결되는 링크를 따라가세요."
"여러 버전을 건너뛰고 업그레이드할 때 고려해야 할 사항은 무엇인가요?","여러 버전을 건너뛰고 업그레이드할 경우, 건너뛴 버전의 릴리스 노트도 검토해야 합니다."
"Spring Data repositories 소개의 주요 목표는 무엇인가요?","Spring Data repository 추상화의 목표는 다양한 지속성 저장소에 대한 데이터 액세스 레이어를 구현하는 데 필요한 보일러플레이트 코드의 양을 크게 줄이는 것입니다. 출처: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/introduction.html"
"Spring Data repositories의 핵심 개념에는 어떤 것들이 있나요?","Spring Data repositories의 핵심 개념에는 Repository 인터페이스 정의, Repository 인스턴스 생성, 쿼리 메서드 정의, 프로젝션, 객체 매핑 기본 사항, 사용자 정의 변환, 사용자 정의 리포지토리 구현, Spring Data 확장, 값 표현식 기본 사항, 예제에 따른 쿼리, 집계 루트에서 이벤트 게시, 엔티티 콜백, 리포지토리 메서드의 널 처리 등이 포함됩니다. 출처: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/introduction.html"
"Spring Data repositories에서 사용되는 객체 매핑 기본 사항과 사용자 정의 변환에 대한 문서를 어디에서 찾을 수 있나요?","Spring Data repositories에서 사용되는 객체 매핑 기본 사항과 사용자 정의 변환에 대한 문서는 다음 위치에서 찾을 수 있습니다: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/introduction.html. 객체 매핑 기본 사항은 <object-mapping.html> 섹션에서 다루고 있으며, 사용자 정의 변환은 <custom-conversions.html> 섹션에서 다루고 있습니다. 출처: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/introduction.html"
"스프링 데이터에서 리포지토리 추상화의 중심 인터페이스는 무엇인가요?","스프링 데이터에서 리포지토리 추상화의 중심 인터페이스는 Repository입니다. (출처: <https://docs.spring.io/spring-data/relational/reference/3.3/repositories/core-concepts.html>)"
"스프링 데이터에서 CrudRepository 인터페이스는 어떤 기능을 제공하나요?","스프링 데이터에서 CrudRepository 인터페이스는 관리되는 엔티티 클래스에 대한 정교한 CRUD 기능을 제공합니다. (출처: <https://docs.spring.io/spring-data/relational/reference/3.3/repositories/core-concepts.html>)"
"스프링 데이터에서 PagingAndSortingRepository 인터페이스는 어떤 기능을 제공하나요?","스프링 데이터에서 PagingAndSortingRepository 인터페이스는 엔티티에 대한 페이지화된 액세스를 용이하게 하는 추가 메서드를 제공합니다. (출처: <https://docs.spring.io/spring-data/relational/reference/3.3/repositories/core-concepts.html>)"
"스프링 데이터에서 리포지토리 인터페이스를 정의하려면 어떻게 해야 하나요?","도메인 클래스별 리포지토리 인터페이스를 정의하고, 인터페이스는 Repository를 상속받고 도메인 클래스와 ID 타입으로 타입이 지정되어야 합니다. CrudRepository를 상속받으면 해당 도메인 타입에 대한 CRUD 메서드를 노출할 수 있습니다. CRUD는 Create, Read, Update, Delete의 약자입니다."
"스프링 데이터에서 여러 개의 리포지토리 인터페이스를 사용하는 방법은 무엇인가요?","리포지토리 정의는 지속성 기술을 구분해야 합니다. Spring Data는 클래스패스에 여러 리포지토리 팩토리가 감지되면 엄격한 리포지토리 구성 모드로 전환됩니다. 엄격한 구성은 리포지토리 또는 도메인 클래스에 대한 세부 정보를 사용하여 특정 Spring Data 모듈 바인딩에 대한 결정을 내립니다. 도메인 클래스가 모듈별 타입 주석으로 주석 처리된 경우 해당 Spring Data 모듈의 유효한 후보입니다. Spring Data는 리포지토리를 식별하기 위해 엄격한 리포지토리 구성에 사용되는 리포지토리 유형 세부 정보 및 도메인 클래스 주석을 구분합니다."
"스프링 데이터에서 리포지토리 인터페이스를 선택적으로 노출하는 방법은 무엇인가요?","CRUD 리포지토리 인터페이스 중 하나를 상속받으면 엔티티를 조작하는 완전한 메서드 세트가 노출됩니다. 노출되는 메서드를 선택적으로 사용하려면 CRUD 리포지토리에서 노출할 메서드를 도메인 리포지토리로 복사하면 됩니다. 이때 메서드의 반환 유형을 변경할 수 있습니다. Spring Data는 가능한 경우 반환 유형을 존중합니다. 리포지토리 인터페이스에 @RepositoryDefinition 어노테이션을 지정할 수도 있습니다."
"Java 구성에서 JPA 저장소를 사용하도록 Spring Data 저장소를 활성화하는 방법은 무엇인가요?","Java 구성 클래스에 @EnableJpaRepositories 어노테이션을 사용하여 JPA 저장소를 사용하도록 Spring Data 저장소를 활성화할 수 있습니다. base-package 속성을 사용하여 Spring이 인터페이스를 스캔할 기본 패키지를 정의할 수 있습니다. 예를 들어, @EnableJpaRepositories('com.acme.repositories') 어노테이션을 사용하여 'com.acme.repositories' 패키지에서 JPA 저장소를 활성화할 수 있습니다."
"XML 구성에서 Spring Data 저장소를 활성화하는 방법은 무엇인가요?","XML 구성에서 repositories 요소를 사용하여 Spring이 인터페이스를 스캔할 기본 패키지를 정의할 수 있습니다. base-package 속성을 사용하여 Spring이 인터페이스를 스캔할 기본 패키지를 정의할 수 있습니다. 예를 들어, <jpa:repositories base-package='com.acme.repositories' /> 요소를 사용하여 'com.acme.repositories' 패키지에서 JPA 저장소를 활성화할 수 있습니다."
"Spring Data 저장소 인스턴스 생성 시 인터페이스 포함 및 제외를 제어하는 방법은 무엇인가요?","include-filter 및 exclude-filter 요소를 사용하여 인터페이스 포함 및 제외를 제어할 수 있습니다. 이러한 요소는 Spring의 component filters와 동일한 의미를 갖습니다. 예를 들어, <context:include-filter type='regex' expression='.*SomeRepository' /> 및 <context:exclude-filter type='regex' expression='.*SomeOtherRepository' /> 요소를 사용하여 'SomeRepository'로 끝나는 인터페이스를 포함하고 'SomeOtherRepository'로 끝나는 인터페이스를 제외할 수 있습니다."
"스프링 데이터 리포지토리에서 쿼리 방법을 정의하는 방법은 무엇인가요?","스프링 데이터 리포지토리에서 쿼리 방법은 쿼리 메소드 이름에서 직접 쿼리를 유도하거나, 명시적으로 정의된 쿼리를 사용하여 정의할 수 있습니다. 쿼리 방법 이름은 메소드 이름에서 특정 접두사를 제거하고 나머지를 파싱하여 쿼리를 생성합니다. 또한, 리포지토리 인프라에서 쿼리를 해결하기 위해 사용할 수 있는 여러 전략이 있습니다. CREATE, USE_DECLARED_QUERY, CREATE_IF_NOT_FOUND입니다. 쿼리 생성은 엔티티에 대한 제약 조건을 구축하는 데 유용하며, 메소드 이름에서 쿼리 생성을 포함합니다. 메소드 이름에서 쿼리 파싱은 주체와 술어로 나뉩니다. 첫 번째 부분 (find…By, exists…By)은 쿼리의 주체를 정의하고, 두 번째 부분은 술어를 형성합니다."
"스프링 데이터 리포지토리에서 쿼리 룩업 전략은 무엇인가요?","스프링 데이터 리포지토리의 쿼리 룩업 전략은 쿼리를 해결하기 위해 리포지토리 인프라에서 사용할 수 있는 여러 전략을 말합니다. 이러한 전략에는 CREATE, USE_DECLARED_QUERY, CREATE_IF_NOT_FOUND가 있습니다. CREATE는 쿼리 메소드 이름에서 저장소별 쿼리를 구성하려고 시도합니다. USE_DECLARED_QUERY는 선언된 쿼리를 찾아보려고 시도하고, 찾을 수 없으면 예외를 던집니다. CREATE_IF_NOT_FOUND (기본값)는 CREATE와 USE_DECLARED_QUERY를 결합합니다. 먼저 선언된 쿼리를 찾고, 선언된 쿼리가 없으면 사용자 정의 메소드 이름 기반 쿼리를 생성합니다."
"스프링 데이터 리포지토리에서 쿼리 생성은 어떻게 이루어지나요?","스프링 데이터 리포지토리 인프라에 내장된 쿼리 빌더 메커니즘은 리포지토리의 엔티티에 대한 제약 조건을 구축하는 데 유용합니다. 쿼리 생성은 메소드 이름에서 쿼리 생성을 포함합니다. 메소드 이름에서 쿼리 파싱은 주체와 술어로 나뉩니다. 첫 번째 부분 (find…By, exists…By)은 쿼리의 주체를 정의하고, 두 번째 부분은 술어를 형성합니다. 표현식은 일반적으로 연산자와 결합된 속성 탐색입니다. 속성 표현식은 AND 및 OR로 결합할 수 있습니다. 또한, 속성 표현식에 대한 Between, LessThan, GreaterThan 및 Like와 같은 연산자 지원을 제공합니다. 메소드 파서는 개별 속성에 대한 IgnoreCase 플래그를 설정하거나, 대문자를 무시할 수 있는 유형의 모든 속성에 대해 설정할 수 있습니다. 정적 순서를 적용하려면 쿼리 메소드에 속성을 참조하고 정렬 방향 (Asc 또는 Desc)을 제공하는 OrderBy 절을 추가할 수 있습니다."
"스프링 데이터에서 프로젝션이란 무엇이며, 어떻게 사용되는 건가요?","스프링 데이터에서 프로젝션은 리포지토리가 관리하는 어그리게이트 루트의 특정 속성을 기반으로 프로젝션을 생성하는 것을 말합니다. 이를 위해 전용 반환 유형을 모델링하여 관리되는 어그리게이트의 부분 뷰를 더 선택적으로 검색할 수 있습니다. 가장 쉬운 방법은 인터페이스를 선언하여 읽을 속성에 대한 접근자 메서드를 노출하는 것입니다. 프로젝션 인터페이스의 속성은 어그리게이트 루트의 속성과 정확히 일치해야 합니다. 이렇게 하면 쿼리 메서드가 추가될 수 있으며, 쿼리 실행 엔진은 반환된 각 요소에 대해 런타임에 해당 인터페이스의 프록시 인스턴스를 생성하고 노출된 메서드에 대한 호출을 대상 객체로 전달합니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/projections.html)"
"스프링 데이터에서 클로즈드 프로젝션과 오픈 프로젝션의 차이점은 무엇인가요?","클로즈드 프로젝션은 접근자 메서드가 모두 대상 어그리게이트의 속성과 일치하는 프로젝션 인터페이스를 말합니다. 오픈 프로젝션은 @Value 어노테이션을 사용하여 새로운 값을 계산하기 위해 프로젝션 인터페이스의 접근자 메서드를 사용할 수 있습니다. 클로즈드 프로젝션을 사용하면 스프링 데이터가 쿼리 실행을 최적화할 수 있지만, 오픈 프로젝션의 경우 SpEL 표현이 어그리게이트 루트의 모든 속성을 사용할 수 있으므로 쿼리 실행 최적화를 적용할 수 없습니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/projections.html)"
"스프링 데이터에서 DTO를 사용하여 프로젝션을 정의하는 방법은 무엇인가요?","스프링 데이터에서 DTO를 사용하여 프로젝션을 정의하려면, 검색할 필드에 대한 속성을 보유하는 값 유형 DTO(데이터 전송 객체)를 사용하면 됩니다. 이러한 DTO 유형은 프로젝션 인터페이스와 정확히 동일한 방식으로 사용할 수 있습니다. DTO의 필드는 노출된 생성자의 매개변수 이름에서 로드할 필드가 결정됩니다. DTO를 사용하는 가장 좋은 방법은 자바 레코드를 사용하는 것입니다. 자바 레코드는 값 의미론을 준수하기 때문에 모든 필드가 private final이며 equals(...) / hashCode() / toString() 메서드가 자동으로 생성됩니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/projections.html)"
"Spring Data에서 @PersistenceCreator 어노테이션은 어떤 역할을 하나요?","Spring Data에서 @PersistenceCreator 어노테이션은 생성자 또는 팩토리 메서드를 지정하여 도메인 객체의 인스턴스를 생성하는 데 사용됩니다."
"Spring Data에서 생성된 인스턴스 생성기와 프로퍼티 엑세서 클래스는 어떤 용도로 사용되나요?","Spring Data에서 생성된 인스턴스 생성기와 프로퍼티 엑세서 클래스는 도메인 객체의 인스턴스를 생성하고 프로퍼티 값을 설정하는 데 사용됩니다."
"Spring Data에서 객체 매핑에서 오버라이딩된 프로퍼티를 처리하는 방법은 무엇인가요?","Spring Data는 오버라이딩된 프로퍼티를 처리하기 위해 프로퍼티의 유형이 할당 가능한 경우 기본 프로퍼티를 고려하고, 그렇지 않은 경우 하위 유형의 프로퍼티를 기본값으로 사용합니다."
"스프링 컨버터 구현의 예시는 어떤 것이 있나요?","스프링 컨버터 구현의 예시로는 다음 예시가 있습니다: @ReadingConverter public class EmailReadConverter implements Converter<String, Email> { public Email convert(String source) { return Email.valueOf(source); } }"
"스프링에서 기본 타입의 소스와 타겟 타입을 가진 컨버터를 작성하면 어떻게 되나요?","스프링에서 기본 타입의 소스와 타겟 타입을 가진 컨버터를 작성하면, 이를 리딩 컨버터로 처리해야 할지 라이팅 컨버터로 처리해야 할지 알 수 없습니다. 컨버터 인스턴스를 둘 다 등록하면 원하지 않는 결과가 발생할 수 있습니다."
"스프링에서 커스텀 컨버터를 등록하는 방법은 무엇인가요?","스프링에서 커스텀 컨버터를 등록하는 방법은 CustomConversions를 통해 소스 및 대상 타입을 기반으로 등록된 컨버터를 등록하고 조회할 수 있는 중앙 시설을 사용하는 것입니다. CustomConversions는 미리 정의된 컨버터 등록 세트를 제공합니다: JSR-310 컨버터는 java.time, java.util.Date 및 String 타입 간의 변환을 위한 것입니다."
"Spring Data Extensions에서 어떤 프레임워크를 사용하여 정적 타입의 SQL과 유사한 쿼리를 생성할 수 있나요?","Querydsl"
"Querydsl을 Spring Data와 통합하는 방법은 무엇인가요?","QuerydslPredicateExecutor 인터페이스를 통해 가능합니다."
"Spring Data의 웹 지원에서 @EnableSpringDataWebSupport 어노테이션은 어떤 역할을 하나요?","몇 가지 컴포넌트를 등록하고 Spring MVC JARs가 클래스패스에 있는지 확인합니다."
"Value Expressions Fundamentals에서 Value Expressions는 무엇인가요?","Value Expressions는 Spring Expression Language (SpEL)과 Property Placeholder Resolution의 조합입니다. 이는 프로그래밍 방식의 표현식 평가와 Property Placeholder Resolution을 통해 환경(예: 구성 속성)에서 값을 가져오는 기능을 결합합니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/value-expressions.html)"
"Value Expressions를 사용하는 것의 단점은 무엇인가요?","Value Expressions를 사용하면 코드의 유연성이 높아지지만, 각 사용 시 표현식을 평가해야 하므로 성능 프로필에 영향을 줄 수 있습니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/value-expressions.html)"
"Value Expressions는 어떻게 구문 분석되고 평가되나요?","Value Expressions는 ValueExpressionParser API에 의해 구문 분석되고, ValueExpression의 인스턴스는 스레드 안전하며 나중에 사용하기 위해 캐시될 수 있습니다. SpEL Expressions는 #{...} 형식으로 둘러싸인 템플릿 스타일을 따르며, Expression은 EvaluationContextProvider에서 제공하는 EvaluationContext를 사용하여 평가됩니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/value-expressions.html)"
"Query by Example (QBE)란 무엇이며, 어떻게 사용되나요?","Query by Example (QBE)는 간단한 인터페이스를 가진 사용자 친화적인 쿼리 기술입니다. 동적 쿼리 생성을 허용하며 필드 이름을 포함하는 쿼리를 작성할 필요가 없습니다. 실제로 Query by Example은 스토어별 쿼리 언어를 사용하여 쿼리를 작성할 필요가 없습니다. 이 장에서는 Query by Example의 핵심 개념을 설명하며, Spring Data Commons 모듈에서 정보를 가져옵니다. 데이터베이스에 따라 문자열 일치 지원이 제한될 수 있습니다. Query by Example API는 Probe, ExampleMatcher, Example, FetchableFluentQuery의 네 가지 부분으로 구성됩니다. Query by Example은 정적 또는 동적 제약 조건을 사용하여 데이터 저장소를 쿼리하는 데 적합합니다. 도메인 객체를 자주 리팩토링할 때 기존 쿼리를 깨뜨릴 걱정 없이 작업할 수 있습니다. Query by Example을 사용하여 쿼리를 시작하기 전에 도메인 객체가 있어야 합니다. QueryByExampleExecutor 인터페이스를 사용하여 리포지토리에서 예제 쿼리를 실행할 수 있습니다. QueryByExampleExecutor 인터페이스를 사용하여 리포지토리에서 예제 쿼리를 실행할 수 있습니다. FetchableFluentQuery는 쿼리 파생에 대한 추가 사용자 지정을 허용하는 유창한 API를 제공합니다. Query by Example은 중첩되거나 그룹화된 속성 제약 조건, 문자열 일치에 대한 스토어별 지원 등 여러 가지 제한 사항이 있습니다. 기본적으로 ExampleMatcher는 프로브에 설정된 모든 값이 일치해야 합니다. 예제 매치어를 사용자 정의하여 문자열 일치, 널 처리 및 속성별 설정에 대한 기본값을 지정할 수 있습니다. ExampleMatcher의 기본 매칭 설정을 설정하고 개별 속성에 대한 설정을 적용할 수 있습니다. 유창한 API를 사용하여 쿼리를 정의하고 결과를 처리할 수 있습니다. Query by Example은 QueryByExampleExecutor 인터페이스를 사용하여 예제에서 파생된 쿼리를 실행하는 findBy라는 추가 메서드를 제공합니다."
"Query by Example에서 Probe, ExampleMatcher, Example, FetchableFluentQuery는 어떤 역할을 하나요?","Probe는 채워진 필드를 가진 도메인 객체의 실제 예제입니다. ExampleMatcher는 특정 필드를 일치시키는 방법에 대한 세부 정보를 전달합니다. 여러 예제에서 재사용할 수 있습니다. Example은 프로브와 ExampleMatcher로 구성됩니다. 쿼리를 만드는 데 사용됩니다. FetchableFluentQuery는 쿼리 파생에 대한 추가 사용자 지정을 허용하는 유창한 API를 제공합니다. 유창한 API를 사용하면 쿼리에 대한 정렬, 프로젝션 및 결과 처리를 지정할 수 있습니다."
"Query by Example을 사용할 때 어떤 제한 사항이 있나요?","Query by Example은 중첩되거나 그룹화된 속성 제약 조건, 문자열 일치에 대한 스토어별 지원 등 여러 가지 제한 사항이 있습니다. 중첩되거나 그룹화된 속성 제약 조건, 문자열 일치에 대한 스토어별 지원 등 여러 가지 제한 사항이 있습니다. 자식 쿼리를 사용하여 중첩된 속성을 처리할 수 있습니다. 데이터베이스에 따라 문자열 일치 지원이 제한될 수 있습니다. 다른 속성 유형에 대해서는 정확한 일치가 지원됩니다."
"Spring Data에서 도메인 이벤트를 어떻게 게시할 수 있나요?","Spring Data의 @DomainEvents 어노테이션을 사용하여 집계 루트 클래스의 메서드에 적용하여 단일 이벤트 인스턴스 또는 이벤트 컬렉션을 반환할 수 있습니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/core-domain-events.html)"
"Spring Data에서 도메인 이벤트 발행 후 호출되는 메서드는 어떤 것이 있나요?","@AfterDomainEventPublication 어노테이션을 사용하여 모든 이벤트가 발행된 후에 호출될 수 있으며, 발행될 이벤트 목록을 정리하는 등의 용도로 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/core-domain-events.html)"
"Spring Data에서 도메인 이벤트를 어떻게 트리거할 수 있나요?","Spring Data 리포지토리 메서드인 save(...), saveAll(...), delete(...), deleteAll(...), deleteAllInBatch(...), deleteInBatch(...)를 호출할 때마다 도메인 이벤트가 트리거됩니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/core-domain-events.html)"
"엔티티 콜백이란 무엇이며 어떤 경우에 사용되나요?","엔티티 콜백은 Spring Data 인프라에서 제공하는 훅으로, 특정 메서드가 호출되기 전과 후에 엔티티를 수정할 수 있는 기능을 제공합니다. 이러한 엔티티 콜백은 콜백 방식으로 엔티티를 확인하고 수정할 수 있는 편리한 방법을 제공합니다. 일부 Spring Data 모듈은 스토어 특정 이벤트(예: BeforeSaveEvent)를 게시하여 주어진 엔티티를 수정할 수 있도록 합니다. 엔티티 콜백은 동기 및 비동기 API 모두와 통합 지점을 제공하여 처리 체인 내의 잘 정의된 체크포인트에서 순서대로 실행을 보장하고, 잠재적으로 수정된 엔티티 또는 비동기 래퍼 유형을 반환합니다. 엔티티 콜백은 일반적으로 API 유형별로 분리됩니다. 이러한 분리는 동기 API가 동기 엔티티 콜백만 고려하고 비동기 구현이 비동기 엔티티 콜백만 고려한다는 것을 의미합니다. 엔티티 콜백 API는 Spring Data Commons 2.2에서 도입되었으며, 엔티티 수정을 적용하는 권장되는 방법입니다. 기존 스토어 특정 ApplicationEvents는 여전히 호출될 수 있는 등록된 엔티티 콜백 인스턴스 이전에 게시됩니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/commons/entity-callbacks.html)"
"엔티티 콜백의 구조는 어떻게 되며, 어떻게 구현할 수 있나요?","엔티티 콜백은 그 도메인 유형과 직접적으로 연관되어 있으며, 이는 제네릭 타입 인자를 통해 이루어집니다. 각 Spring Data 모듈은 일반적으로 엔티티 라이프사이클을 다루는 미리 정의된 엔티티 콜백 인터페이스 세트를 제공합니다. 엔티티 콜백의 구조는 BeforeSaveCallback<T>와 같은 함수 인터페이스로, 도메인 객체가 저장되기 전에 호출되는 엔티티 콜백 메서드를 포함하고 있습니다. 반환 값은 동일한 인스턴스 또는 수정된 인스턴스를 반환할 수 있습니다. 엔티티 콜백은 BeforeSaveCallback<Person>와 같이 애플리케이션 요구 사항에 맞는 인터페이스를 구현하여 구현할 수 있습니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/commons/entity-callbacks.html)"
"엔티티 콜백은 어떻게 등록되나요?","엔티티 콜백 빈은 ApplicationContext에 등록된 경우 스토어 특정 구현에서 선택됩니다. 대부분의 템플릿 API는 이미 ApplicationContextAware를 구현하고 있으므로 ApplicationContext에 액세스할 수 있습니다. 엔티티 콜백 등록은 @Order, @Component, @Bean, @Configuration 어노테이션을 사용하여 수행할 수 있습니다. 콜백은 동일한 도메인 유형에 대해 여러 개의 콜백이 존재하는 경우 순서를 결정할 수도 있습니다. 콜백 구현에 의해 주문이 결정되거나 Ordered 인터페이스 구현을 통해 주문이 결정될 수 있습니다. 람다 표현식으로 구현된 콜백은 기본적으로 순서가 없으며 마지막으로 호출됩니다. 비할당 가능한 엔티티로 이러한 콜백을 호출하면 콜백 처리량에 영향을 미칩니다. 콜백 빈에 대한 유형 필터링을 활성화하려면 클래스 또는 열거형을 사용하세요. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/commons/entity-callbacks.html)"
"스프링 데이터에서 리포지토리 메서드의 널 핸들링은 어떻게 처리되나요?","스프링 데이터 2.0부터는 개별 어그리게이트 인스턴스를 반환하는 리포지토리 CRUD 메서드가 값의 부재 가능성을 나타내기 위해 Java 8의 Optional을 사용합니다. 또한, Spring Data는 쿼리 메서드에서 다음과 같은 래퍼 유형을 반환하는 것을 지원합니다: com.google.common.base.Optional, scala.Option, io.vavr.control.Option. 쿼리 메서드는 래퍼 유형을 전혀 사용하지 않을 수도 있습니다. 이 경우 쿼리 결과의 부재는 null을 반환하여 표시됩니다. 컬렉션, 컬렉션 대안, 래퍼 및 스트림을 반환하는 리포지토리 메서드는 null을 반환하지 않고 해당 빈 표현을 반환합니다. 자세한 내용은 'Repository query return types(query-return-types-reference.html)'를 참조하십시오. (Source: {https://docs.spring.io/spring-data/relational/reference/3.3/repositories/null-handling.html})"
"스프링의 널 안전성 어노테이션을 사용하여 리포지토리 메서드의 널 가능성을 어떻게 표현할 수 있나요?","스프링 프레임워크의 널 안전성 어노테이션을 사용하여 리포지토리 메서드의 널 가능성 제약을 표현할 수 있습니다. 이 어노테이션은 도구 친화적인 접근 방식과 런타임 중 옵트인 널 체크를 제공합니다. @NonNullApi는 패키지 수준에서 사용되어 매개변수 및 반환 값의 기본 동작이 각각 널 값을 허용하지 않거나 생성하지 않음을 선언합니다. @NonNull은 널이 될 수 없는 매개변수 또는 반환 값에 사용됩니다. @Nullable은 널이 될 수 있는 매개변수 또는 반환 값에 사용됩니다. Spring 어노테이션은 JSR 305(https://jcp.org/en/jsr/detail?id=305) 어노테이션(휴면 상태이지만 널리 사용되는 JSR)으로 메타 어노테이션됩니다. JSR 305 메타 어노테이션은 도구 공급업체(예: IDEA, Eclipse, Kotlin)가 Spring 어노테이션에 대한 지원을 하드 코딩하지 않고도 일반적인 방식으로 널 안전성 지원을 제공할 수 있도록 합니다. 쿼리 메서드의 널 가능성 제약 조건에 대한 런타임 검사를 활성화하려면 다음 예제와 같이 package-info.java에서 Spring의 @NonNullApi를 사용하여 패키지 수준에서 널이 아닌 기본값을 활성화해야 합니다. Kotlin은 널 가능성 제약 조건의 정의를 언어에 내장하고 있습니다. Kotlin 코드는 메서드 시그니처를 통해 널 가능성 제약 조건을 표현하는 대신 컴파일된 메타데이터를 통해 널 가능성 제약 조건을 표현하는 바이트 코드로 컴파일됩니다. Kotlin의 널 가능성 제약 조건을 검사하려면 프로젝트에 kotlin-reflect JAR를 포함해야 합니다."
"Kotlin 기반 리포지토리에서 널 가능성을 처리하는 방법은 무엇인가요?","Kotlin은 널 가능성 제약 조건의 정의(https://kotlinlang.org/docs/reference/null-safety.html)를 언어에 내장하고 있습니다. Kotlin 코드는 메서드 시그니처를 통해 널 가능성 제약 조건을 표현하는 대신 컴파일된 메타데이터를 통해 널 가능성 제약 조건을 표현하는 바이트 코드로 컴파일됩니다. Kotlin의 널 가능성 제약 조건을 검사하려면 프로젝트에 kotlin-reflect JAR를 포함해야 합니다. Spring Data 리포지토리는 언어 메커니즘을 사용하여 이러한 제약 조건을 정의하여 동일한 런타임 검사를 적용합니다. (Source: {https://docs.spring.io/spring-data/relational/reference/3.3/repositories/null-handling.html})"
"스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 일반적으로 지원되는 쿼리 메서드 서브젝트 키워드는 어떤 것들이 있나요?","스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 일반적으로 지원되는 쿼리 메서드 서브젝트 키워드는 다음과 같습니다: find…By, read…By, get…By, query…By, search…By, stream…By, exists…By, count…By, delete…By, remove…By, ...First<number>..., ...Top<number>..., ...Distinct... (출처: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 일반적으로 지원되는 쿼리 메서드 프레디킷 키워드는 어떤 것들이 있나요?","스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 일반적으로 지원되는 쿼리 메서드 프레디킷 키워드는 다음과 같습니다: AND, OR, AFTER, BEFORE, CONTAINING, BETWEEN, ENDING_WITH, EXISTS, FALSE, GREATER_THAN, GREATER_THAN_EQUALS, IN, IS, IS_EMPTY, IS_NOT_EMPTY, IS_NOT_NULL, IS_NULL, LESS_THAN, LESS_THAN_EQUAL, LIKE, NEAR, NOT, NOT_IN, NOT_LIKE, REGEX, STARTING_WITH, TRUE, WITHIN (출처: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 지원되는 쿼리 메서드 프레디킷 수정자는 어떤 것들이 있나요?","스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 지원되는 쿼리 메서드 프레디킷 수정자는 다음과 같습니다: IgnoreCase, AllIgnoreCase, OrderBy... (출처: https://docs.spring.io/spring-data/relational/reference/3.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리에서 일반적으로 지원되는 쿼리 반환 유형은 무엇인가요?","스프링 데이터 리포지토리에서 일반적으로 지원되는 쿼리 반환 유형은 void, Java 프리미티브, Java 래퍼 유형, T, Iterator<T>, Collection<T>, List<T>, Optional<T>, Option<T>, Stream<T>, Streamable<T>, Vavr Seq, List, Map, Set, Future<T>, CompletableFuture<T>, Slice<T>, Page<T>, Window<T>, GeoResult<T>, GeoResults<T>, GeoPage<T>, Mono<T>, Flux<T>, Single<T>, Maybe<T>, Flowable<T>입니다. (출처: {https://docs.spring.io/spring-data/relational/reference/3.3/repositories/query-return-types-reference.html})"
"스프링 데이터 리포지토리에서 Geospatial 유형을 사용하려면 어떤 데이터 스토어가 필요한가요?","스프링 데이터 리포지토리에서 Geospatial 유형을 사용하려면 GeoResult, GeoResults, GeoPage와 같은 데이터 스토어가 필요합니다. (출처: {https://docs.spring.io/spring-data/relational/reference/3.3/repositories/query-return-types-reference.html})"
"스프링 데이터 리포지토리에서 Future<T>를 반환 유형으로 사용하려면 어떤 어노테이션이 필요한가요?","스프링 데이터 리포지토리에서 Future<T>를 반환 유형으로 사용하려면 메소드에 @Async 어노테이션이 필요합니다. 또한, 스프링의 비동기 메소드 실행 기능이 활성화되어 있어야 합니다. (출처: {https://docs.spring.io/spring-data/relational/reference/3.3/repositories/query-return-types-reference.html})"
"스프링 데이터 JDBC 모듈은 어떤 원칙에 따라 JDBC 데이터베이스 드라이버를 사용하여 솔루션을 개발하는 데 핵심 스프링 개념을 적용하나요?","스프링 데이터 JDBC 모듈은 도메인 주도 설계 원칙에 따라 JDBC 데이터베이스 드라이버를 사용하여 솔루션을 개발하는 데 핵심 스프링 개념을 적용합니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/jdbc.html) "
"Spring Data JDBC에서 집합체를 저장하고 쿼리하는 데 사용되는 고수준 추상화는 무엇인가요?","Spring Data JDBC에서 집합체를 저장하고 쿼리하는 데 사용되는 고수준 추상화는 'template'입니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/jdbc.html) "
"Spring Data JDBC에서 리포지토리 지원에 대한 특정 기능은 어디에서 강조되나요?","Spring Data JDBC에서 리포지토리 지원에 대한 특정 기능은 'Repository Support for JDBC' 섹션에서 강조됩니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/jdbc.html) "
"Java 세계에서 관계형 데이터베이스의 주요 지속성 API는 무엇이며, Spring Data와 어떤 관련이 있나요?","Java 세계에서 관계형 데이터베이스의 주요 지속성 API는 JPA(Java Persistence API)입니다. Spring Data는 JPA를 위한 모듈을 포함하여 다양한 데이터 저장소를 위한 모듈을 제공합니다. JPA는 개발자를 돕기 위해 많은 기능을 제공하지만, 때로는 이해하기 어려울 수 있고 간단한 개념에 대한 복잡성을 증가시킬 수 있습니다. 이에 비해 Spring Data JDBC는 더 간단한 개념을 가지고 있으며, 엔티티를 테이블에 매핑하는 데 제한된 사용자 정의 전략을 제공합니다."
"Spring Data JDBC의 주요 설계 결정은 무엇이며, JPA와 어떻게 다른가요?","Spring Data JDBC의 주요 설계 결정은 개념을 더 간단하게 만들기 위해 이루어졌습니다. 엔티티를 로드하면 SQL 문이 실행되고, 엔티티가 완전히 로드된 후에는 지연 로딩이나 캐싱이 이루어지지 않습니다. 엔티티를 저장하면 변경 사항이 저장되고, 더티 추적이나 세션이 없습니다. 엔티티를 테이블에 매핑하는 간단한 모델을 가지고 있으며, 제한된 사용자 정의 전략을 제공하여 일부 경우에는 작동하지 않을 수 있습니다. 이러한 설계 결정은 JPA와 대조적으로, 변경 사항을 추적하고 지연 로딩을 수행하며 다양한 객체 구조를 데이터베이스 설계에 매핑할 수 있는 기능을 제공하는 것과 다릅니다."
"Spring Data JDBC는 JPA와 비교하여 어떤 장단점이 있나요?","Spring Data JDBC는 JPA와 비교하여 더 간단한 개념과 제한된 사용자 정의 전략을 제공하여 개발자가 엔티티와 테이블 간의 매핑을 직접 구현해야 합니다. 이로 인해 학습 곡선이 더 낮고 코드가 더 간단해질 수 있습니다. 그러나 JPA와 같은 고급 기능을 제공하지 않으며, 복잡한 데이터베이스 설계나 객체 구조에 대한 매핑에는 적합하지 않을 수 있습니다. 따라서 간단한 경우에는 Spring Data JDBC가 더 적합할 수 있지만, 복잡한 경우에는 JPA가 더 적합할 수 있습니다."
"스프링 데이터 JDBC에서 도메인 주도 설계 개념이 왜 중요한가요?","스프링 데이터 JDBC에서 도메인 주도 설계 개념이 중요한 이유는 '리포지토리', '어그리게이트', '어그리게이트 루트' 등의 개념이 관계형 데이터베이스와의 작업에서 일반적인 관행과는 다소 상반되기 때문입니다. 이는 어그리게이트가 원자적인 변경 사이에 일관성을 보장하는 엔티티 그룹으로 정의되고, 어그리게이트 루트가 각 어그리게이트에 하나의 엔티티로 존재하며, 어그리게이트는 해당 어그리게이트 루트의 메서드를 통해서만 조작될 수 있기 때문입니다."
"어그리게이트란 무엇이며, 어그리게이트 루트와 어떻게 다른가요?","어그리게이트는 원자적인 변경 사이에 일관성을 보장하는 엔티티 그룹입니다. 어그리게이트 루트는 각 어그리게이트에 하나의 엔티티로 존재하며, 어그리게이트는 해당 어그리게이트 루트의 메서드를 통해서만 조작될 수 있습니다. 어그리게이트 루트는 어그리게이트의 엔티티 중 하나입니다."
"스프링 데이터 JDBC에서 리포지토리는 어떻게 정의되나요?","스프링 데이터 JDBC에서 리포지토리는 특정 유형의 모든 어그리게이트의 컬렉션처럼 보이는 지속적인 저장소에 대한 추상화입니다. 이는 어그리게이트 루트 당 하나의 리포지토리를 가져야 함을 의미하며, 어그리게이트 루트에서 접근 가능한 모든 엔티티는 해당 어그리게이트 루트의 일부로 간주됩니다."
"Spring Data JDBC를 사용하기 위해 필요한 Spring Framework 버전은 무엇인가요?","Spring Data JDBC를 사용하기 위해서는 Spring Framework 6.1.13 이상이 필요합니다. (출처: <https://docs.spring.io/spring-data/relational/reference/3.3/jdbc/getting-started.html>)"
"Spring Data JDBC는 어떤 데이터베이스에 대한 직접적인 지원을 제공하나요?","Spring Data JDBC는 DB2, H2, HSQLDB, MariaDB, Microsoft SQL Server, MySQL, Oracle, Postgres에 대한 직접적인 지원을 제공합니다. (출처: <https://docs.spring.io/spring-data/relational/reference/3.3/jdbc/getting-started.html>)"
"Spring Data JDBC를 Java 구성을 통해 활성화하는 방법은 무엇인가요?","Spring Data JDBC는 Java 구성을 통해 @EnableJdbcRepositories 어노테이션을 사용하여 활성화할 수 있으며, AbstractJdbcConfiguration을 확장하여 필요한 DataSource, NamedParameterJdbcOperations, TransactionManager을 설정할 수 있습니다. (출처: <https://docs.spring.io/spring-data/relational/reference/3.3/jdbc/getting-started.html>)"
"Spring Data JDBC에서 엔티티를 지속시키는 방법은 무엇인가요?","Spring Data JDBC에서 엔티티를 지속시키는 방법은 CrudRepository.save(...) 메서드를 사용하는 것입니다. 엔티티가 새로운 경우, 집계 루트에 대한 삽입이 발생하고, 직접 또는 간접적으로 참조된 모든 엔티티에 대한 삽입 문이 이어집니다."
"Spring Data JDBC에서 집계를 로드하는 방법은 무엇인가요?","Spring Data JDBC에서 집계를 로드하는 방법은 두 가지가 있습니다. 전통적인 방법은 각 쿼리가 집계 루트를 로드하는 방식으로, 쿼리가 CrudRepository 메서드, 파생 쿼리 또는 주석 쿼리를 기반으로 하는지 여부에 관계없이 작동합니다. Spring Data JDBC 3.2는 단일 쿼리 로딩을 사용할 수 있도록 허용하며, 이를 통해 단일 SQL 쿼리로 임의의 수의 집계를 완전히 로드할 수 있습니다."
"Spring Data JDBC에서 ID 생성은 어떻게 이루어지나요?","Spring Data는 엔티티를 식별하기 위해 식별자 속성을 사용합니다. 엔티티의 ID는 Spring Data의 @Id( https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/annotation/Id.html ) 어노테이션으로 주석 처리되어야 합니다. 데이터베이스에 ID 열에 대한 자동 증가 열이 있는 경우, 생성된 값은 엔티티를 데이터베이스에 삽입한 후 엔티티에 설정됩니다."
"Spring Data JDBC에서 객체를 행으로 매핑하는 데 사용되는 기본 메타데이터 모델은 무엇인가요?","Spring Data JDBC의 BasicJdbcConverter는 객체를 행으로 매핑하는 데 사용되는 풍부한 메타데이터 모델을 가지고 있습니다. 이 모델은 도메인 객체를 데이터 행에 매핑할 수 있도록 합니다."
"Spring Data JDBC에서 추가 메타데이터 정보의 유일한 소스로 주석을 사용하는 데 제한이 있나요?","아니요, Spring Data JDBC의 BasicJdbcConverter는 추가 메타데이터 정보의 유일한 소스로 주석을 사용하는 데 제한이 없습니다. 주석을 사용하지 않고도 객체를 행에 매핑할 수 있습니다."
"Spring Data JDBC에서 테이블 이름을 재정의하는 방법은 무엇인가요?","Spring Data JDBC에서 테이블 이름을 재정의하려면 해당 클래스에 @Table 어노테이션을 사용하고 요소의 값으로 사용자 정의 테이블 이름을 제공하면 됩니다. 또한 Spring Data의 SpEL 지원을 사용하여 동적으로 테이블 이름을 만들 수 있습니다."
"쿼리 메소드란 무엇인가요?","쿼리 메소드는 리포지토리에서 데이터베이스에 대한 쿼리를 실행하는 메소드입니다. 쿼리 메소드는 리포지토리 인터페이스에서 메소드를 선언하여 정의할 수 있습니다. 예를 들어, 'PersonRepository' 인터페이스의 'findByFirstname' 메소드는 주어진 이름에 대한 모든 사람을 검색하는 쿼리입니다."
"쿼리 메소드에서 'Pageable' 매개변수를 사용하는 목적은 무엇인가요?","쿼리 메소드에서 'Pageable' 매개변수를 사용하면 데이터베이스에 오프셋 및 정렬 매개변수를 전달할 수 있습니다. 이를 통해 결과를 페이지로 나누어 검색할 수 있습니다."
"쿼리 메소드에서 '@Query' 어노테이션을 사용하는 목적은 무엇인가요?","@Query 어노테이션은 쿼리 메소드에서 쿼리를 수동으로 문자열로 선언하는 데 사용됩니다. 이를 통해 SQL 쿼리를 사용하여 데이터베이스에서 데이터를 검색할 수 있습니다. Query 어노테이션은 또한 사용자 정의 RowMapper 또는 ResultSetExtractor를 지정할 수 있습니다."
"Spring Data JDBC에서 MyBatis를 통합하는 가장 쉬운 방법은 무엇인가요?","MyBatisJdbcConfiguration을 애플리케이션 구성에 import하는 것입니다. 다음은 예시입니다: @Configuration @EnableJdbcRepositories @Import(MyBatisJdbcConfiguration.class) class Application { @Bean SqlSessionFactoryBean sqlSessionFactoryBean() { // Configure MyBatis here } }"
"Spring Data JDBC에서 MyBatis를 사용할 때 사용 가능한 MyBatis 문은 어떤 것이 있나요?","Spring Data JDBC에서 MyBatis를 사용할 때 사용 가능한 MyBatis 문은 insert, update, delete, deleteAll-<propertyPath>, deleteAll, delete-<propertyPath>, findById, findAll, findAllById, findAllByProperty-<propertyName>, findAllByPath-<propertyPath>, findAllSorted, findAllPaged, count 등입니다."
"Spring Data JDBC에서 MyBatis를 사용할 때 MyBatisContext에서 사용 가능한 속성은 무엇인가요?","Spring Data JDBC에서 MyBatis를 사용할 때 MyBatisContext에서 사용 가능한 속성은 getInstance, getDomainType, getId, getSort, getPageable 등이 있습니다. 사용 가능한 속성은 실행되는 문과 문명의 종류에 따라 다릅니다."
"Spring Data JDBC에서 라이프사이클 이벤트는 어떻게 발생하나요?","Spring Data JDBC는 ApplicationListener 객체에 라이프사이클 이벤트를 게시하며, 일반적으로 애플리케이션 컨텍스트의 빈입니다. 이러한 이벤트는 특정 라이프사이클 단계에 대한 알림입니다. 엔티티 콜백과 달리 이벤트는 알림을 위해 사용됩니다. 트랜잭션 리스너는 트랜잭션이 완료될 때 이벤트를 받습니다. 이벤트와 콜백은 집합 루트에만 트리거됩니다. 비루트 엔티티를 처리하려면 해당 엔티티를 포함하는 집합 루트의 리스너를 통해 수행해야 합니다. 엔티티 라이프사이클 이벤트는 비용이 많이 들 수 있으며, 큰 결과 집합을 로드할 때 성능 프로필의 변경 사항을 알 수 있습니다. 이벤트는 Template API에서 비활성화할 수 있습니다. (예: jdbcAggregateTemplate.setEntityLifecycleEventsEnabled(false)). (출처: https://docs.spring.io/spring-data/relational/reference/html/#jdbc.events)"
"Spring Data JDBC에서 라이프사이클 이벤트와 엔티티 콜백의 차이점은 무엇인가요?","라이프사이클 이벤트와 엔티티 콜백은 Spring Data JDBC에서 엔티티의 수명 주기를 관리하는 데 사용됩니다. 라이프사이클 이벤트는 특정 라이프사이클 단계에 대한 알림이며, 엔티티 콜백은 엔티티가 저장되거나 로드되는 등의 작업 중에 적용됩니다. 이벤트는 알림을 위해 사용되고, 콜백은 실제 작업을 수행합니다. 콜백은 불변 클래스를 사용하는 데 더 강력하고 다재다능하며, 이벤트보다 더 많은 유형의 작업을 지원합니다. (출처: https://docs.spring.io/spring-data/relational/reference/html/#jdbc.events)"
"Spring Data JDBC에서 라이프사이클 이벤트의 성능 영향은 어떻게 되나요?","엔티티 라이프사이클 이벤트는 비용이 많이 들 수 있으며, 특히 큰 결과 집합을 로드할 때 성능 프로필의 변경 사항을 알 수 있습니다. Template API에서 라이프사이클 이벤트를 비활성화하여 성능을 향상시킬 수 있습니다. (예: jdbcAggregateTemplate.setEntityLifecycleEventsEnabled(false)). (출처: https://docs.spring.io/spring-data/relational/reference/html/#jdbc.events)"
"JDBC 기반 Spring Data 애플리케이션에서 감사 기능을 활성화하려면 어떻게 해야 하나요?","감사 기능을 활성화하려면 @EnableJdbcAuditing을 구성에 추가해야 합니다. 다음과 같은 예시 구성 클래스를 참고하세요: @Configuration @EnableJdbcAuditing class Config { @Bean AuditorAware<AuditableUser> auditorProvider() { return new AuditorAwareImpl(); } } (출처: https://docs.spring.io/spring-data/relational/reference/3.3/jdbc/auditing.html)"
"Spring Data JDBC에서 감사 기능을 사용할 때 현재 사용자를 어떻게 설정하나요?","AuditorAware 인터페이스를 구현하여 현재 사용자를 결정하고 ApplicationContext에 빈으로 노출시키면 감사 인프라가 자동으로 이를 감지하여 도메인 유형에 설정할 수 있습니다. ApplicationContext에 여러 구현체가 등록되어 있는 경우 @EnableJdbcAuditing의 auditorAwareRef 속성을 명시적으로 설정하여 사용할 구현체를 선택할 수 있습니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/jdbc/auditing.html)"
"Spring Data JDBC에서 감사 기능을 사용할 때 사용할 AuditorAware 구현체를 어떻게 선택하나요?","여러 개의 AuditorAware 구현체가 등록되어 있는 경우 @EnableJdbcAuditing의 auditorAwareRef 속성을 명시적으로 설정하여 사용할 구현체를 선택할 수 있습니다. 이 속성을 사용하여 ApplicationContext에서 특정 구현체를 참조할 수 있습니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/jdbc/auditing.html)"
"Spring Data Jdbc에서 CrudRepository 인스턴스 메서드의 기본 트랜잭션 설정은 어떻게 되나요?","CrudRepository 인스턴스의 메서드는 기본적으로 트랜잭션입니다. 읽기 작업의 경우, 트랜잭션 구성 readOnly 플래그가 true로 설정됩니다. 다른 모든 메서드는 기본 트랜잭션 구성이 적용되도록 일반적인 @Transactional 어노테이션으로 구성됩니다. 자세한 내용은 SimpleJdbcRepository의 Javadoc(../api/java/org/springframework/data/jdbc/repository/support/SimpleJdbcRepository.html)을 참조하십시오. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/jdbc/transactions.html)"
"Spring Data Jdbc에서 레포지토리 인터페이스에 대한 사용자 정의 트랜잭션 구성을 어떻게 구현할 수 있나요?","레포지토리 인터페이스에 선언된 메서드 중 하나에 대해 트랜잭션 구성을 조정해야 하는 경우, 레포지토리 인터페이스에서 메서드를 다시 선언하면 됩니다. 다음은 예시입니다: Custom transaction configuration for CRUD interface UserRepository extends CrudRepository<User, Long> { @Override @Transactional(timeout = 10) List<User> findAll(); // Further query method declarations } 이렇게 하면 findAll() 메서드가 타임아웃 10초로 실행되고 readOnly 플래그가 설정되지 않습니다. 트랜잭션 동작을 변경하는 또 다른 방법은 일반적으로 하나 이상의 레포지토리를 커버하는 패사드 또는 서비스 구현을 사용하는 것입니다. 그 목적은 비-CRUD 작업에 대한 트랜잭션 경계를 정의하는 것입니다. 다음은 이러한 패사드를 만드는 방법을 보여주는 예시입니다: Using a facade to define transactions for multiple repository calls @Service public class UserManagementImpl implements UserManagement { private final UserRepository userRepository; private final RoleRepository roleRepository; UserManagementImpl(UserRepository userRepository, RoleRepository roleRepository) { this.userRepository = userRepository; this.roleRepository = roleRepository; } @Transactional public void addRoleToAllUsers(String roleName) { Role role = roleRepository.findByName(roleName); for (User user : userRepository.findAll()) { user.addRole(role); userRepository.save(user); } } 이렇게 하면 addRoleToAllUsers(…) 호출이 트랜잭션 내에서 실행됩니다(기존 트랜잭션에 참여하거나 이미 실행 중인 트랜잭션이 없는 경우 새 트랜잭션을 만듭니다). 레포지토리의 트랜잭션 구성은 무시되며, 외부 트랜잭션 구성이 사용할 실제 레포지토리를 결정합니다. 패사드에 대한 어노테이션 기반 구성을 사용하려면 명시적으로 <tx:annotation-driven />을 활성화하거나 @EnableTransactionManagement를 사용해야 합니다. 이 예시는 컴포넌트 스캐닝을 사용하는 것으로 가정합니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/jdbc/transactions.html)"
"스프링 데이터 JDBC에서 코드를 먼저 작성하는 방식을 사용하여 데이터베이스 스키마를 생성하는 방법은 무엇인가요?","Liquibase를 사용하여 데이터베이스 변경 세트를 생성합니다. 먼저, Person 엔티티와 같은 도메인 엔티티와 RelationalMappingContext가 필요합니다. 그런 다음 LiquibaseChangeSetWriter를 사용하여 주어진 파일에 변경 세트를 작성합니다. 열 유형은 SqlTypeMapping 전략을 구현하는 객체에서 계산되며, null 가능성은 유형에서 추론되며 속성 유형이 원시 Java 유형을 사용하는 경우 false로 설정됩니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/jdbc/schema-support.html)"
"기존의 Liquibase 데이터베이스를 사용하여 스프링 데이터 JDBC에서 테이블 및 열을 추가하거나 제거하는 방법은 무엇인가요?","차이 모드에서 스키마 작성기 인스턴스에 기존의 Liquibase 데이터베이스를 제공하고 스키마 작성기는 매핑된 엔티티와 기존 테이블을 비교하고 차이에서 어떤 테이블과 열을 생성/제거할지 유도합니다. 기본적으로 dropTableFilter 및 dropColumnFilter를 구성하지 않는 한 테이블 및 열이 제거되지 않습니다. 두 필터 예측자는 테이블 이름 및 열 이름을 제공하므로 코드가 어떤 테이블과 열을 제거할 수 있는지 계산할 수 있습니다. writer.setDropTableFilter(tableName -> …); writer.setDropColumnFilter((tableName, columnName) -> …); (출처: https://docs.spring.io/spring-data/relational/reference/3.3/jdbc/schema-support.html)"
"스프링 데이터 JDBC에서 테이블/열 제거, 열 이름 변경 및 데이터 마이그레이션을 포함하는 스키마 진화를 수행하는 방법은 무엇인가요?","엔티티 매핑은 스키마가 어떻게 진화했는지에 대한 세부 정보를 제공하지 않으므로 열을 이름 바꾸거나 데이터를 마이그레이션할 수 없습니다. 스키마 지원은 매핑되지 않은 테이블/열을 제거하고 데이터베이스에 존재하지 않는 열을 추가하는 의미에서만 추가 및 제거를 식별할 수 있습니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/jdbc/schema-support.html)"
"Spring Data R2DBC 모듈은 어떤 원칙을 기반으로 하나요?","Spring Data R2DBC 모듈은 R2DBC 데이터베이스 드라이버를 사용하는 솔루션 개발에 핵심적인 Spring 개념을 적용하고 도메인 주도 설계 원칙을 준수합니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/r2dbc.html)"
"Spring Data R2DBC에서 R2dbcEntityTemplate의 목적은 무엇인가요?","R2dbcEntityTemplate은 일반적인 R2DBC 작업을 수행할 때 생산성을 높이고 행과 POJO 간의 통합 객체 매핑을 제공하는 엔티티 바운드 작업을 위한 중앙 클래스로 사용됩니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/r2dbc.html)"
"Spring Data R2DBC에서 어떻게 리포지토리 인터페이스를 자동으로 구현할 수 있나요?","Spring Data R2DBC는 사용자 정의 쿼리 메서드를 포함하여 리포지토리 인터페이스를 자동으로 구현할 수 있으며, 이는 R2DBC 리포지토리, 쿼리 메서드 및 엔티티 콜백 문서에 자세히 설명되어 있습니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/r2dbc.html)"
"Spring Data R2DBC를 사용하기 위해 필요한 최소 Spring Framework 버전은 무엇인가요?","Spring Data R2DBC는 Spring Framework 6.1.13 이상을 필요로 합니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/r2dbc/getting-started.html)"
"Spring Data R2DBC가 직접 지원하는 데이터베이스는 무엇인가요?","Spring Data R2DBC는 H2, MariaDB, Microsoft SQL Server, MySQL, Postgres, Oracle 데이터베이스를 직접 지원합니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/r2dbc/getting-started.html)"
"Spring Data R2DBC에서 ConnectionFactory는 무엇이며, 어떻게 등록할 수 있나요?","ConnectionFactory는 R2DBC 데이터베이스 연결을 나타내는 인터페이스입니다. ConnectionFactory를 등록하기 위해 Java 구성을 사용하여 @Configuraion 어노테이션을 가진 클래스를 만들고, @Bean으로 표시된 connectionFactory() 메서드를 구현하여 ConnectionFactory 인스턴스를 반환해야 합니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/r2dbc/getting-started.html)"
"Spring Data R2DBC에서 엔티티 지속성을 위한 중심 진입점은 무엇인가요?","Spring Data R2DBC에서 엔티티 지속성을 위한 중심 진입점은 R2dbcEntityTemplate입니다. 이는 직접적인 엔티티 지향 메서드와 쿼리, 삽입, 업데이트, 삭제 등의 일반적인 ad-hoc 사용 사례에 대한 더 좁은 플루언트 인터페이스를 제공합니다."
"Spring Data R2DBC에서 R2dbcDialect 추상화는 어떤 역할을 하나요?","Spring Data R2DBC에서 R2dbcDialect 추상화는 바인드 마커, 페이지 지원 및 기본 드라이버에서 기본적으로 지원되는 데이터 유형을 결정하는 데 사용됩니다."
"Spring Data R2DBC에서 모든 터미널 메서드는 어떤 유형의 Publisher를 반환하나요?","Spring Data R2DBC에서 모든 터미널 메서드는 원하는 작업을 나타내는 Publisher 유형을 반환합니다."
"Spring Data R2DBC의 MappingR2dbcConverter는 어떤 기능을 제공하나요?","Spring Data R2DBC의 MappingR2dbcConverter는 객체를 행으로 매핑하고, 테이블과 열 이름을 생성하며, 사용자 정의 변환기를 등록하여 특정 클래스를 데이터베이스에 매핑할 수 있습니다. 이 변환기는 도메인 객체를 데이터 행에 매핑하기 위한 풍부한 메타데이터 모델을 가지고 있으며, 사용자 정의 메타데이터를 제공하지 않고도 객체를 행에 매핑하기 위한 규칙을 따를 수 있습니다. 또한, 테이블과 열 이름을 제어하고, SQL 문에서 따옴표 없이 사용되는 테이블과 열 이름을 구성할 수 있습니다."
"Spring Data R2DBC에서 객체 매핑을 위한 기본 규칙은 무엇인가요?","Spring Data R2DBC에서 객체 매핑을 위한 기본 규칙은 추가 매핑 메타데이터가 제공되지 않을 때 객체를 행으로 매핑하기 위한 몇 가지 규칙이 있습니다. 이 규칙에는 짧은 Java 클래스 이름을 테이블 이름으로 매핑하고, 필드를 열 이름으로 매핑하며, 기본 케이스로 테이블과 열 이름을 사용하고, 중첩된 객체를 지원하지 않으며, 생성자를 사용하여 객체를 행으로 변환하는 것이 포함됩니다. 이러한 규칙은 사용자 정의 네이밍 전략과 사용자 정의 변환기를 등록하여 재정의할 수 있습니다."
"Spring Data R2DBC에서 사용자 정의 변환기를 등록하는 방법은 무엇인가요?","Spring Data R2DBC에서 사용자 정의 변환기를 등록하려면 AbstractR2dbcConfiguration 클래스에서 r2dbcCustomConversions 메서드를 재정의하고, 사용자 정의 변환기를 List에 추가하여 반환하면 됩니다. 이렇게 등록된 사용자 정의 변환기는 특정 클래스를 데이터베이스에 매핑하는 데 사용되며, 객체를 행으로 매핑하고, 테이블과 열 이름을 생성하며, 객체를 생성하는 데 사용됩니다. 사용자 정의 변환기는 Java 또는 XML 구성을 사용하여 등록할 수 있습니다."
"Spring Data R2DBC에서 리포지토리란 무엇이고, 어떻게 사용하나요?","Spring Data R2DBC에서 리포지토리는 관계형 데이터베이스에 저장된 도메인 엔티티에 접근하기 위한 편리한 인터페이스를 제공합니다. 리포지토리를 사용하려면, 도메인 엔티티에 대한 인터페이스를 만들고, 해당 인터페이스에 리포지토리 메서드와 쿼리를 정의하면 됩니다. 리포지토리를 구성하려면, @EnableR2dbcRepositories 어노테이션을 사용하여 리포지토리 인터페이스가 위치한 패키지를 지정하면 됩니다. 이렇게 하면 자동으로 인프라가 해당 패키지를 스캔하여 리포지토리 인스턴스를 생성하고, 이를 클라이언트에 의존성 주입하여 사용할 수 있습니다. 또한, 리포지토리 인스턴스를 사용하여 데이터베이스에 대한 CRUD 작업 및 쿼리를 수행할 수 있습니다."
"Spring Data R2DBC에서 리포지토리에서 프로젝션을 사용하려면 어떻게 해야 하나요?","Spring Data R2DBC에서 리포지토리에서 프로젝션을 사용하려면, 쿼리 메서드에서 반환 값으로 인터페이스 또는 DTO 프로젝션을 지정하면 됩니다. 인터페이스 프로젝션은 결과를 도메인 유형에 매핑한 다음, 실제 프로젝션 프록시가 부분적으로 구체화된 엔티티를 사용하여 프로젝션 데이터를 노출합니다. DTO 프로젝션의 결과 매핑은 실제 쿼리 유형에 따라 다릅니다. 파생 쿼리는 결과를 매핑하기 위해 도메인 유형을 사용하며, Spring Data는 도메인 유형에서 사용 가능한 속성만으로 DTO 인스턴스를 생성합니다. DTO 유형에서 사용 가능한 속성이 아닌 속성을 선언하는 것은 지원되지 않습니다. 문자열 기반 쿼리는 실제 쿼리, 특히 필드 프로젝션 및 결과 유형 선언이 서로 밀접하게 관련되어 있기 때문에 다른 접근 방식을 사용합니다. @Query 어노테이션으로 주석이 달린 쿼리 메서드와 함께 사용되는 DTO 프로젝션은 쿼리 결과를 DTO 유형으로 직접 매핑합니다. 도메인 유형의 필드 매핑은 고려되지 않습니다. DTO 유형을 직접 사용하여 쿼리 메서드를 사용하면 도메인 모델에 제한되지 않는 더 동적인 프로젝션을 활용할 수 있습니다."
"Spring Data R2DBC에서 EntityCallbacks는 어떤 목적으로 사용되나요?","Spring Data R2DBC는 EntityCallback API를 사용하여 감사 기능을 지원하며, 다양한 콜백을 처리합니다. 이 API는 도메인 객체를 OutboundRow로 변환하기 전에 Invoked되는 onBeforeConvert() 콜백과 도메인 객체를 로드한 후에 Invoked되는 onAfterConvert() 콜백을 포함합니다. 또한, EntityCallbacks는 도메인 객체를 저장하기 전에 Invoked되는 onBeforeSave() 콜백과 도메인 객체를 저장한 후에 Invoked되는 onAfterSave() 콜백도 제공합니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/r2dbc/entity-callbacks.html)"
"Spring Data R2DBC에서 호출되는 콜백 중 어떤 순서로 호출되나요?","Spring Data R2DBC에서 호출되는 콜백은 onBeforeConvertCallback, onAfterConvertCallback, AuditingEntityCallback, BeforeSaveCallback, AfterSaveCallback 등이 있습니다. 이 중 onBeforeConvertCallback과 AuditingEntityCallback은 도메인 객체를 OutboundRow로 변환하기 전에 호출되며, onAfterConvertCallback, BeforeSaveCallback, AfterSaveCallback은 도메인 객체를 로드한 후에 호출됩니다. 이 콜백들은 Ordered.LOWEST_PRECEDENCE로 지정되어 있어, 다른 콜백들보다 우선순위가 낮습니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/r2dbc/entity-callbacks.html)"
"Spring Data R2DBC의 EntityCallbacks에서 onBeforeSave() 콜백의 용도는 무엇인가요?","Spring Data R2DBC의 EntityCallbacks에서 onBeforeSave() 콜백은 도메인 객체를 저장하기 전에 호출됩니다. 이 콜백을 통해 매핑된 엔티티 정보를 모두 포함하는 대상 저장용 OutboundRow를 수정할 수 있습니다. 도메인 객체를 저장하기 전에 필요한 추가 작업을 수행하고자 할 때 이 콜백을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/r2dbc/entity-callbacks.html)"
"Spring Data R2DBC에서 감사 기능을 활성화하려면 어떻게 해야 하나요?","Spring Data R2DBC 1.2 이상에서 @EnableR2dbcAuditing 어노테이션을 사용하여 감사 기능을 활성화할 수 있습니다. 다음 예제와 같이 구성 클래스에 @EnableR2dbcAuditing을 어노테이션으로 지정하면 됩니다: @Configuration @EnableR2dbcAuditing class Config { @Bean public ReactiveAuditorAware<AuditableUser> myAuditorProvider() { return new AuditorAwareImpl(); } } (출처: <https://docs.spring.io/spring-data/relational/reference/3.3/r2dbc/auditing.html>)"
"Spring Data R2DBC에서 현재 사용자를 설정하려면 어떻게 해야 하나요?","ReactiveAuditorAware 유형의 빈을 ApplicationContext에 노출시키면 감사 인프라가 자동으로 이를 선택하고 도메인 유형에 설정할 현재 사용자를 결정하는 데 사용합니다. ApplicationContext에 여러 구현체가 등록되어 있는 경우 @EnableR2dbcAuditing의 auditorAwareRef 속성을 명시적으로 설정하여 사용할 구현체를 선택할 수 있습니다. (출처: <https://docs.spring.io/spring-data/relational/reference/3.3/r2dbc/auditing.html>)"
"Spring Data R2DBC에서 감사 기능을 활성화하는 데 필요한 최소 버전은 무엇인가요?","Spring Data R2DBC 1.2 이상에서 감사 기능을 활성화할 수 있습니다. (출처: <https://docs.spring.io/spring-data/relational/reference/3.3/r2dbc/auditing.html>)"
"Kotlin에서 Spring Data R2DBC의 reified generics support와 coroutines extensions의 이점은 무엇인가요?","Spring Data R2DBC의 reified generics support와 coroutines extensions는 Kotlin에서 DatabaseClient를 사용할 때 더 간결하고 강력한 타입 추론을 제공하여 코드의 가독성과 유지 보수성을 향상시킵니다. 이를 통해 SWCharacter와 같은 객체의 목록을 검색하는 등의 작업을 더 짧고 효율적으로 수행할 수 있습니다."
"Java에서 Kotlin으로 전환하여 Spring Data R2DBC를 사용할 때, 타입 추론의 이점은 무엇인가요?","Java에서 Kotlin으로 전환하여 Spring Data R2DBC를 사용할 때, Kotlin의 스마트한 타입 추론을 통해 코드의 가독성과 효율성이 향상됩니다. 이를 통해 SWCharacter와 같은 객체의 목록을 검색하는 등의 작업을 더 짧고 효율적으로 수행할 수 있습니다."
"Kotlin에서 Spring Data R2DBC를 사용하여 SWCharacter의 목록을 가져오는 방법은 무엇인가요?","Kotlin에서 Spring Data R2DBC를 사용하여 SWCharacter의 목록을 가져오려면, client.select().from<SWCharacter>().fetch().all() 함수를 사용할 수 있습니다. 이를 통해 SWCharacter 객체의 Flux를 검색하고, 필요한 경우 characters : Flux<SWCharacter> = client.select().from().fetch().all()와 같이 명시적으로 타입을 지정할 수도 있습니다."
"Spring Data R2DBC를 1.1.x에서 1.2.x로 업그레이드하는 방법은 무엇인가요?","Spring Data R2DBC의 1.2.0 버전은 Spring R2DBC에서 제공하는 기능과 일치하도록 여러 가지 변경 사항이 이루어졌습니다. SQL 문 실행 방법은 DatabaseClient.execute(...)에서 DatabaseClient.sql(...)로 변경되었습니다. CRUD 작업을 위한 유창한 API는 R2dbcEntityTemplate로 이동되었습니다. SQL 문 로깅을 위해 logger prefix org.springframework.data.r2dbc를 사용하는 경우, Spring R2DBC 구성 요소를 가리키도록 org.springframework.r2dbc(즉, .data 제거)로 업데이트해야 합니다. 여러 유형이 Spring R2DBC에서 제공하는 대체 유형으로 사용되지 않습니다. Spring R2DBC에서 제공하는 대체 유형을 사용하십시오. 특정 클래스는 Spring R2DBC 유형을 수락하도록 변경되거나 새로운 메서드가 도입되었습니다. R2dbcEntityTemplate 및 R2dbcDialect와 같은 클래스를 검토하고 업데이트해야 합니다. OutboundRow 및 statement mappers는 SettableValue에서 Parameter로 전환되었습니다. Repository factory support는 o.s.data.r2dbc.core.DatabaseClient 대신 o.s.r2dbc.core.DatabaseClient를 필요로 합니다. Spring R2DBC를 사용하려면 org.springframework:spring-r2dbc 종속성을 포함해야 합니다."
"Spring Data R2DBC에서 Spring R2DBC로 전환할 때 어떤 유형이 사용되지 않게 되나요?","o.s.d.r2dbc.core.DatabaseClient 및 그 지원 클래스인 ConnectionAccessor, FetchSpec, SqlProvider 등이 사용되지 않게 됩니다. 명명된 매개변수 지원 클래스인 NamedParameterExpander는 Spring R2DBC의 DatabaseClient 구현에 캡슐화되어 있으므로 대체 유형을 제공하지 않습니다. Spring R2DBC에서 제공하는 o.s.r2dbc.core.DatabaseClient 및 해당 대체 유형을 사용하십시오. o.s.d.r2dbc.connectionfactory, o.s.d.r2dbc.connectionfactory.init, o.s.d.r2dbc.connectionfactory.lookup 패키지가 사용되지 않게 됩니다. o.s.r2dbc.connection에서 찾을 수 있는 Spring R2DBC 변형을 사용하십시오. o.s.d.r2dbc.convert.ColumnMapRowMapper가 사용되지 않게 됩니다. 대신 o.s.r2dbc.core.ColumnMapRowMapper를 사용하십시오. Bindings, BindMarker, BindMarkers, BindMarkersFactory 및 관련 유형과 같은 바인딩 지원 클래스가 사용되지 않게 됩니다. org.springframework.r2dbc.core.binding에서 대체 유형을 사용하십시오. BadSqlGrammarException, UncategorizedR2dbcException 및 o.s.d.r2dbc.support에서의 예외 번역이 사용되지 않게 됩니다. Spring R2DBC는 현재 o.s.r2dbc.connection.ConnectionFactoryUtils#convertR2dbcException을 통해 사용되지 않는 SPI를 사용할 수 있는 슬림한 예외 번역 변형을 제공합니다."
"Spring Data R2DBC에서 Spring R2DBC로 전환할 때 어떤 변경 사항이 발생했나요?","Spring Data R2DBC는 R2DBC가 Spring 애플리케이션과 얼마나 잘 통합될 수 있는지 평가하기 위해 개발되었습니다. R2DBC 지원이 유용하다는 것이 입증되면 핵심 지원을 Spring Framework로 이동시키는 것이 주요 측면 중 하나였습니다. Spring Framework 5.3은 Spring R2DBC(spring-r2dbc)라는 새로운 모듈을 제공합니다. Spring R2DBC는 Spring Data R2DBC에서 처음에 제공되었던 핵심 R2DBC 기능(DatabaseClient, Transaction Manager, Connection Factory 초기화, Exception 번역의 슬림한 변형)을 제공합니다. SQL 문 실행 방법은 DatabaseClient.execute(...)에서 DatabaseClient.sql(...)로 변경되었습니다. CRUD 작업을 위한 유창한 API는 R2dbcEntityTemplate로 이동되었습니다. SQL 문 로깅을 위해 logger prefix org.springframework.data.r2dbc를 사용하는 경우, Spring R2DBC 구성 요소를 가리키도록 org.springframework.r2dbc(즉, .data 제거)로 업데이트해야 합니다. OutboundRow 및 statement mappers는 SettableValue에서 Parameter로 전환되었습니다. Repository factory support는 o.s.data.r2dbc.core.DatabaseClient 대신 o.s.r2dbc.core.DatabaseClient를 필요로 합니다."
"스프링 부트 애플리케이션에서 코틀린을 사용하는 가장 쉬운 방법은 무엇인가요?","스프링 부트와 코틀린을 지원하는 스프링 부트 전용 기능을 활용하는 것이 가장 쉬운 방법입니다. (출처: https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-kotlin.html)"
"코틀린은 어떤 장점을 가지고 있나요?","코틀린은 자바로 작성된 기존 라이브러리와의 상호 운용성이 뛰어나며, 간결하고 우아한 코드를 작성할 수 있습니다. (출처: https://kotlinlang.org/docs/reference/java-interop.html)"
"코틀린을 사용하는 스프링 애플리케이션은 어떤 유형의 언어로 작성된 프레임워크처럼 느껴질까요?","코틀린을 사용하는 스프링 애플리케이션은 코틀린 네이티브 프레임워크처럼 느껴질 것입니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/kotlin.html)"
"Spring Data는 어떤 Kotlin 버전을 지원하나요?","Spring Data는 Kotlin 1.3을 지원합니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/kotlin/requirements.html)"
"Spring Data에서 Kotlin을 사용하기 위해 필요한 라이브러리는 무엇인가요?","kotlin-stdlib와 kotlin-reflect가 필요합니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/kotlin/requirements.html)"
"kotlin-stdlib와 kotlin-reflect는 어떻게 자동으로 포함시킬 수 있나요?","start.spring.io를 통해 Kotlin 프로젝트를 부트스트랩하면 자동으로 포함됩니다. (출처: https://docs.spring.io/spring-data/relational/reference/3.3/kotlin/requirements.html)"
"Kotlin에서 Spring Data REST가 Kotlin 객체를 어떻게 구체화하는지 알려주세요.","Spring Data REST의 Kotlin 지원에서 Kotlin 객체를 구체화하는 방법에 대한 자세한 내용은 다음 문서를 참조하세요: https://docs.spring.io/spring-data/relational/reference/3.3/kotlin/object-mapping.html"
"Spring Data REST에서 Kotlin 객체의 객체 매핑을 어떻게 처리하나요?","Spring Data REST가 Kotlin 객체를 매핑하고 구체화하는 방법에 대한 정보는 다음 문서를 참조하세요: https://docs.spring.io/spring-data/relational/reference/3.3/kotlin/object-mapping.html"
"Spring Data REST에서 Kotlin 객체의 객체 매핑에 대해 자세히 알고 싶습니다. 어떤 문서를 참고해야 하나요?","Spring Data REST의 Kotlin 지원에서 Kotlin 객체를 매핑하고 구체화하는 방법에 대한 자세한 내용은 다음 문서를 참조하세요: https://docs.spring.io/spring-data/relational/reference/3.3/kotlin/object-mapping.html"
"스프링 데이터 코틀린 API에서 확장 기능을 사용하기 위해 어떤 단계를 거쳐야 하나요?","코틀린 확장 기능을 사용하기 위해서는 해당 기능을 추가하려는 기존 클래스에 대한 Kotlin 확장을 제공하고, 필요에 따라 가져와야 합니다. 대부분의 경우 IDE에서 자동으로 가져오기를 제안해야 합니다. (출처: https://kotlinlang.org/docs/reference/extensions.html)"
"리파인드 타입 매개변수는 무엇이며, 어떻게 코틀린 API를 개선하나요?","리파인드 타입 매개변수는 JVM 제네릭 타입 지우기를 해결하기 위한 방법으로, 코틀린 API를 개선합니다. 이를 통해 기존 Spring API에 새로운 Kotlin 전용 기능을 추가할 수 있으며, 더 나은 코틀린 API를 제공할 수 있습니다. (출처: https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters)"
"코틀린 확장과 정적 가져오기의 차이점은 무엇인가요?","코틀린 확장과 정적 가져오기의 차이점은, 코틀린 확장은 기존 클래스에 새로운 기능을 추가하는 반면, 정적 가져오기는 특정 클래스의 정적 멤버에 대한 액세스를 단순화합니다. 두 가지 방법 모두 해당 기능을 사용하기 위해 가져와야 합니다. (출처: https://kotlinlang.org/docs/reference/extensions.html)"
"코루틴이란 무엇인가요?","코루틴은 Kotlin Coroutines(https://kotlinlang.org/docs/reference/coroutines-overview.html)에서 제공하는 중단 가능한 계산의 인스턴스로, 비차단 코드를 명령적으로 작성할 수 있도록 해줍니다. 언어 수준에서는 suspend 함수가 비동기 작업에 대한 추상화를 제공하며, 라이브러리 수준에서는 kotlinx.coroutines(https://github.com/Kotlin/kotlinx.coroutines) 라이브러리가 async { }(https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html) 함수와 Flow(https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html)와 같은 유형을 제공합니다."
"Spring Data 모듈은 코루틴을 어떤 범위에서 지원하나요?","Spring Data 모듈은 Kotlin 확장에서 Deferred(https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html) 및 Flow(https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html) 반환 값을 지원합니다."
"Flow와 Flux의 차이점은 무엇인가요?","Flow는 코루틴 세계에서 Flux와 유사한 개념으로, 핫 또는 콜드 스트림, 유한 또는 무한 스트림에 적합합니다. 주요 차이점은 다음과 같습니다: Flow는 푸시 기반이며 Flux는 푸시-풀 하이브리드입니다. 백프레셔는 일시 중지 함수를 통해 구현됩니다. Flow는 단일 일시 중지 collect 메서드(https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/collect.html)와 연산자는 확장 함수(https://kotlinlang.org/docs/reference/extensions.html)로 구현됩니다. 코루틴 덕분에 연산자를 쉽게 구현할 수 있습니다(https://github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-core/common/src/flow/operators). 확장 함수를 사용하면 Flow에 사용자 지정 연산자를 추가할 수 있습니다. collect 작업은 일시 중지 함수입니다. map 연산자(https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html)는 일시 중지 함수 매개 변수를 사용하므로 비동기 작업을 지원합니다(flatMap이 필요하지 않음)."
"Spring Data JPA는 어떤 목적으로 사용되나요?","Spring Data JPA는 Jakarta Persistence API (JPA)에 대한 리포지토리 지원을 제공하여 JPA 데이터 소스에 액세스해야하는 응용 프로그램 개발을 용이하게합니다. (출처: <https://docs.spring.io/spring-data/jpa/reference/3.3/index.html>)"
"Spring Data JPA에서 Envers에 대한 지원을 제공하나요?","네, Spring Data JPA는 Envers Revision Repositories를 지원합니다. (출처: <https://docs.spring.io/spring-data/jpa/reference/3.3/index.html>)"
"Spring Data JPA의 최신 버전은 무엇인가요?","Spring Data JPA의 최신 버전은 3.3입니다. (출처: <https://docs.spring.io/spring-data/jpa/reference/3.3/index.html>)"
"스프링 데이터 업그레이드 방법은 무엇인가요?","스프링 데이터 업그레이드 방법은 프로젝트 위키(https://github.com/spring-projects/spring-data-commons/wiki)에서 제공됩니다. 릴리스 노트 섹션(https://github.com/spring-projects/spring-data-commons/wiki#release-notes)의 링크를 따라가서 업그레이드하려는 버전을 찾으세요. 업그레이드 지침은 항상 릴리스 노트의 첫 번째 항목입니다. 한 개 이상의 릴리스를 건너뛰는 경우, 건너뛴 버전의 릴리스 노트도 검토해야 합니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/commons/upgrade.html)"
"스프링 데이터 업그레이드 시 주의해야 할 점은 무엇인가요?","스프링 데이터 업그레이드 시 주의해야 할 점은 한 개 이상의 릴리스를 건너뛰는 경우, 건너뛴 버전의 릴리스 노트도 검토해야 합니다. 이는 업그레이드 과정에서 발생할 수 있는 문제를 방지하기 위해 중요합니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/commons/upgrade.html)"
"스프링 데이터 릴리스 노트는 어디에서 찾을 수 있나요?","스프링 데이터 릴리스 노트는 프로젝트 위키(https://github.com/spring-projects/spring-data-commons/wiki)의 릴리스 노트 섹션(https://github.com/spring-projects/spring-data-commons/wiki#release-notes)에서 찾을 수 있습니다. 업그레이드하려는 버전의 링크를 따라가서 해당 버전의 릴리스 노트를 확인하세요. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/commons/upgrade.html)"
"스프링 데이터 JPA에서 JPA를 위한 저장소 지원에 대한 특수성은 무엇인가요?","스프링 데이터 JPA에서 JPA를 위한 저장소 지원에 대한 특수성은 JPA를 위한 저장소 지원에 대한 장에서 설명되어 있습니다. 이 장은 Working with Spring Data Repositories (repositories.html)에서 설명된 핵심 저장소 지원을 기반으로 합니다. 핵심 개념, 저장소 인터페이스 정의, 구성, 엔티티 지속성, 쿼리 메서드 정의, 프로젝션, 저장 프로시저, 스펙, 쿼리 바이 예제, 트랜잭션, 잠금, 감사, 페르시스턴스 유닛 병합, CDI 통합, 사용자 정의 저장소 구현, 집계 루트에서 이벤트 게시, 저장소 메서드의 널 처리, 스프링 데이터 확장, 저장소 쿼리 키워드 및 유형, 자주 묻는 질문 등에 대한 정보가 포함되어 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa.html)"
"스프링 데이터 JPA에서 엔티티 지속성이란 무엇인가요?","스프링 데이터 JPA에서 엔티티 지속성은 엔티티를 데이터베이스에 저장하고 검색하는 프로세스를 말합니다. 이는 JPA를 사용하여 수행되며, 엔티티 지속성에 대한 자세한 내용은 Persisting Entities (jpa/entity-persistence.html) 섹션에서 확인할 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa.html)"
"스프링 데이터 JPA에서 쿼리 메서드 정의는 어떻게 이루어지나요?","스프링 데이터 JPA에서 쿼리 메서드 정의는 쿼리 메서드 세부 정보 (repositories/query-methods-details.html) 섹션에서 설명되어 있습니다. 이 섹션에서는 JPA 쿼리 메서드, 프로젝션 등에 대한 정보를 제공합니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa.html)"
"스프링 데이터 JPA 프로젝트를 부트스트랩하는 가장 쉬운 방법은 무엇인가요?","start.spring.io를 통해 스프링 기반의 프로젝트를 생성하거나 Spring Tools에서 스프링 프로젝트를 생성하는 것이 가장 쉬운 방법입니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/getting-started.html)"
"스프링 데이터 JPA 라이브러리를 사용하는 방법을 배울 수 있는 예제들이 있는 곳은 어디인가요?","GitHub의 spring-data-examples 저장소에서 여러 예제들을 다운로드하고 실행하여 라이브러리를 익힐 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/getting-started.html)"
"스프링 데이터 JPA를 사용하여 간단한 엔티티와 해당 리포지토리를 생성하는 방법은 무엇인가요?","@Entity 어노테이션을 사용하여 Person 엔티티를 생성하고, PersonRepository 인터페이스를 생성하여 리포지토리를 구현할 수 있습니다. 그리고 @SpringBootApplication을 사용하여 메인 애플리케이션을 실행할 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/getting-started.html)"
"스프링 데이터에서 리포지토리 추상화의 중심 인터페이스는 무엇인가요?","스프링 데이터에서 리포지토리 추상화의 중심 인터페이스는 'Repository'입니다. 이 인터페이스는 주로 작업할 타입을 캡처하고 이 인터페이스를 확장하는 인터페이스를 발견하는 데 도움이 되는 마커 인터페이스로 작동합니다. (출처: https://docs.spring.io/spring-data/commons/docs/3.3.4/api//org/springframework/data/repository/Repository.html)"
"스프링 데이터의 CrudRepository 인터페이스는 어떤 기능을 제공하나요?","CrudRepository 인터페이스는 관리하는 엔티티 클래스에 대한 정교한 CRUD 기능을 제공합니다. 이 인터페이스에서 선언된 메서드는 일반적으로 CRUD 메서드로 알려져 있습니다. 이 인터페이스의 메서드는 Iterable을 반환하는 반면, ListCrudRepository는 List를 반환합니다. (출처: https://docs.spring.io/spring-data/commons/docs/3.3.4/api//org/springframework/data/repository/CrudRepository.html)"
"스프링 데이터의 PagingAndSortingRepository 인터페이스는 어떤 기능을 제공하나요?","PagingAndSortingRepository 인터페이스는 엔티티에 대한 페이지화된 액세스를 용이하게 하는 추가 메서드를 제공합니다. 이 인터페이스는 ListPagingAndSortingRepository를 제공하며, 이 인터페이스의 메서드는 Iterable을 반환하는 반면, List를 반환합니다. (출처: https://docs.spring.io/spring-data/commons/docs/3.3.4/api//org/springframework/data/repository/PagingAndSortingRepository.html)"
"스프링 데이터 JPA에서 리포지토리 인터페이스를 정의하는 방법은 무엇인가요?","스프링 데이터 JPA에서 리포지토리 인터페이스를 정의하려면 먼저 도메인 클래스별 리포지토리 인터페이스를 정의해야 합니다. 이 인터페이스는 Repository를 확장하고 도메인 클래스와 ID 타입에 대해 타입이 지정되어야 합니다. 해당 도메인 유형에 대한 CRUD 메서드를 노출하려면 Repository 대신 CrudRepository 또는 그 변형 중 하나를 확장할 수 있습니다. (출처: <https://docs.spring.io/spring-data/jpa/reference/3.3/repositories/definition.html>)"
"스프링 데이터 JPA에서 리포지토리 정의를 세밀하게 조정하는 방법은 무엇인가요?","스프링 데이터 JPA에서 리포지토리 정의를 세밀하게 조정하려면 리포지토리 인터페이스를 시작하는 몇 가지 변형이 있습니다. 일반적인 접근 방식은 CrudRepository를 확장하는 것이며, 이는 CRUD 기능에 대한 메서드를 제공합니다. CRUD는 Create, Read, Update, Delete의 약자입니다. 버전 3.0부터는 ListCrudRepository도 도입되었으며, 이는 CrudRepository와 매우 유사하지만 여러 엔티티를 반환하는 메서드의 경우 Iterable 대신 List를 반환하므로 사용하기가 더 쉬울 수 있습니다. 반응형 스토어를 사용하는 경우 ReactiveCrudRepository 또는 RxJava3CrudRepository를 선택할 수 있습니다. Kotlin을 사용하는 경우 Kotlin의 코루틴을 활용하는 CoroutineCrudRepository를 선택할 수 있습니다. 또한 PagingAndSortingRepository, ReactiveSortingRepository, RxJava3SortingRepository 또는 CoroutineSortingRepository를 확장할 수도 있습니다. 이러한 리포지토리는 Sort 추상화 또는 첫 번째 경우 Pageable 추상화를 지정할 수 있는 메서드가 필요한 경우입니다. 다양한 정렬 리포지토리는 더 이상 Spring Data 버전 3.0 이전의 CRUD 리포지토리를 확장하지 않습니다. 따라서 두 인터페이스의 기능을 모두 사용하려면 두 인터페이스를 모두 확장해야 합니다. 스프링 데이터 인터페이스를 확장하지 않으려면 리포지토리 인터페이스에 @RepositoryDefinition 어노테이션을 지정할 수도 있습니다. CRUD 리포지토리 인터페이스 중 하나를 확장하면 엔티티를 조작하는 데 필요한 완전한 메서드 세트가 노출됩니다. 노출되는 메서드를 선택적으로 지정하려면 CRUD 리포지토리에서 노출하려는 메서드를 도메인 리포지토리로 복사하면 됩니다. 이 때 메서드의 반환 유형을 변경할 수 있습니다. 스프링 데이터는 가능한 경우 반환 유형을 존중합니다. 예를 들어, 여러 엔티티를 반환하는 메서드의 경우 Iterable<T>, List<T>, Collection<T> 또는 VAVR 목록을 선택할 수 있습니다. 애플리케이션의 많은 리포지토리가 동일한 메서드 세트를 가져야 하는 경우 상속할 자체 기본 인터페이스를 정의할 수 있습니다. 이러한 인터페이스는 @NoRepositoryBean 어노테이션으로 어노테이션 처리되어야 합니다. 이렇게 하면 스프링 데이터가 직접 인스턴스를 만들려고 시도하고 실패하는 것을 방지할 수 있습니다. 왜냐하면 여전히 일반적인 유형 변수를 포함하는 엔티티를 결정할 수 없기 때문입니다. 다음 예제는 CRUD 메서드(이 경우 findById 및 save)를 선택적으로 노출하는 방법을 보여줍니다. CRUD 메서드를 선택적으로 노출하는 방법 @NoRepositoryBean 인터페이스 MyBaseRepository<T, ID> extends Repository<T, ID> { Optional<T> findById(ID id); <S extends T> S save(S entity); } 인터페이스 UserRepository extends MyBaseRepository<User, Long> { User findByEmailAddress(EmailAddress emailAddress); } 이전 예제에서는 모든 도메인 리포지토리에 대한 공통 기본 인터페이스를 정의하고 findById(…) 및 save(…)를 노출했습니다. 이러한 메서드는 CrudRepository의 메서드 시그니처와 일치하므로 Spring Data에서 제공하는 선택한 스토어의 기본 리포지토리 구현(예: JPA를 사용하는 경우 구현은 SimpleJpaRepository)으로 라우팅됩니다. 따라서 UserRepository는 이제 사용자를 저장하고 ID로 개별 사용자를 찾고 이메일 주소로 사용자를 찾는 쿼리를 트리거할 수 있습니다. 중간 리포지토리 인터페이스는 @NoRepositoryBean으로 어노테이션 처리됩니다. 스프링 데이터가 런타임에 인스턴스를 만들지 않아야 하는 모든 리포지토리 인터페이스에 해당 어노테이션을 추가해야 합니다."
"스프링 데이터 JPA를 구성하는 방법은 무엇인가요?","@EnableJpaRepositories 어노테이션을 사용한 Java 구성 또는 spring-jpa 스키마를 사용한 XML 구성을 통해 스프링 데이터 JPA를 구성할 수 있습니다. (출처: <https://docs.spring.io/spring-data/jpa/reference/3.3/repositories/create-instances.html>)"
"스프링 데이터 JPA에서 repository 요소의 커스텀 네임스페이스 속성은 무엇인가요?","repository 요소의 커스텀 네임스페이스 속성에는 entity-manager-factory-ref와 transaction-manager-ref가 있습니다. (출처: <https://docs.spring.io/spring-data/jpa/reference/3.3/repositories/create-instances.html>)"
"스프링 데이터 JPA에서 BootstrapMode는 무엇이며, 어떤 값을 가질 수 있나요?","BootstrapMode는 스프링 데이터 JPA 리포지토리의 초기화 방법을 제어하는 속성입니다. 가능한 값은 DEFAULT, LAZY, DEFERRED입니다. (출처: <https://docs.spring.io/spring-data/jpa/reference/3.3/repositories/create-instances.html>)"
"스프링 데이터 JPA에서 엔티티를 지속시키는 방법은 무엇인가요?","스프링 데이터 JPA에서 엔티티를 지속시키는 방법은 CrudRepository.save(…) 메서드를 사용하는 것입니다. 이 메서드는 기본 JPA EntityManager를 사용하여 주어진 엔티티를 지속시키거나 병합합니다. 엔티티가 아직 지속되지 않은 경우, 스프링 데이터 JPA는 entityManager.persist(…) 메서드를 호출하여 엔티티를 저장합니다. 그렇지 않으면, entityManager.merge(…) 메서드를 호출합니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/entity-persistence.html)"
"스프링 데이터 JPA에서 엔티티의 상태를 감지하는 전략은 무엇인가요?","스프링 데이터 JPA에서 엔티티의 상태를 감지하는 전략은 버전 속성 및 ID 속성 검사(기본값)입니다. 기본적으로 스프링 데이터 JPA는 비원시 유형의 버전 속성이 있는지 먼저 확인합니다. 버전 속성이 있는 경우 해당 속성의 값이 null이면 엔티티는 새로 간주됩니다. 버전 속성이 없으면 스프링 데이터 JPA는 주어진 엔티티의 식별자 속성을 확인합니다. 식별자 속성이 null이면 엔티티는 새로운 것으로 가정됩니다. 그렇지 않으면 새로운 것이 아닌 것으로 가정됩니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/entity-persistence.html)"
"스프링 데이터 JPA에서 Persistable 인터페이스를 구현하는 방법은 무엇인가요?","Persistable을 구현하는 엔티티의 경우, 스프링 데이터 JPA는 엔티티의 isNew(…) 메서드로 새로운 감지를 위임합니다. Persistable.isNew() 메서드의 구현에서 플래그를 반환하여 스프링 데이터 저장소가 EntityManager.persist() 또는 ….merge()를 호출해야 하는지 여부를 알 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/entity-persistence.html)"
"스프링 데이터 JPA에서 쿼리 메소드 이름에서 어떻게 저장소별 쿼리를 도출하나요?","스프링 데이터 JPA에서 쿼리 메소드 이름에서 저장소별 쿼리를 도출하는 방법은 두 가지가 있습니다. 1) 쿼리 메소드 이름에서 직접 쿼리를 도출하는 방법, 2) 수동으로 정의한 쿼리를 사용하는 방법입니다. 사용 가능한 옵션은 실제 저장소에 따라 다릅니다. 그러나 어떤 실제 쿼리가 생성되는지를 결정하는 전략이 있어야 합니다. 다음 섹션에서는 사용 가능한 옵션에 대해 설명합니다."
"스프링 데이터 JPA에서 쿼리 룩업 전략은 무엇인가요?","스프링 데이터 JPA에서 레파지토리 인프라가 쿼리를 해결하기 위해 사용할 수 있는 전략은 다음과 같습니다. 1) XML 구성에서 네임스페이스를 통해 query-lookup-strategy 속성을 사용하여 전략을 구성할 수 있습니다. 2) Java 구성에서 EnableJpaRepositories 어노테이션의 queryLookupStrategy 속성을 사용할 수 있습니다. 일부 전략은 특정 데이터 저장소에 대해 지원되지 않을 수 있습니다."
"스프링 데이터 JPA에서 쿼리 메소드 이름에서 쿼리를 생성하는 방법은 무엇인가요?","스프링 데이터 JPA에서 쿼리 메소드 이름에서 쿼리를 생성하는 방법은 다음과 같습니다. 1) 메소드 이름에서 주어진 잘 알려진 접두사 집합을 제거하고 나머지 메소드를 파싱하는 것이 일반적인 접근 방식입니다. 2) 쿼리 생성에 대한 자세한 내용은 'Query Creation(#repositories.query-methods.query-creation)'을 참조하십시오."
"Spring Data JPA에서 수동으로 쿼리를 정의하는 방법은 무엇인가요?","Spring Data JPA에서 수동으로 쿼리를 정의하는 것은 @Query 어노테이션을 사용하는 것입니다. @Query 어노테이션을 사용하면 JPQL 쿼리나 네이티브 SQL 쿼리를 정의할 수 있습니다. 또한, @NamedQuery 어노테이션이나 orm.xml 파일의 <named-query> 요소를 사용하여 JPA 명명 쿼리를 정의할 수도 있습니다."
"Spring Data JPA에서 파생 쿼리는 어떻게 작동하나요?","Spring Data JPA에서 파생 쿼리는 리포지토리 인터페이스에서 쿼리 메서드의 이름에서 유도됩니다. 메서드 이름에서 키워드를 사용하여 쿼리에 대한 조건을 지정할 수 있습니다. 파생 쿼리는 메서드 이름에서 키워드를 지원하는 제한이 있으므로, 이 제한을 극복하기 위해 @Query 어노테이션을 사용하여 쿼리를 정의할 수 있습니다."
"Spring Data JPA에서 Like 표현식을 사용할 때 어떻게 와일드카드를 처리해야 하나요?","Spring Data JPA에서 Like 표현식을 사용할 때, 와일드카드를 처리하기 위해 @Query 어노테이션에서 % 문자를 사용할 수 있습니다. Spring Data JPA는 쿼리를 실행할 때 와일드카드 문자를 인식하고 쿼리를 수정합니다. 또한, JPQL에서 제공되는 escape() 메소드를 사용하여 와일드카드 문자를 이스케이프할 수도 있습니다."
"스프링 데이터에서 프로젝션이란 무엇이며, 어떻게 사용하는 것인가요?","스프링 데이터에서 프로젝션은 리포지토리에서 관리하는 애그리게이트 루트의 특정 속성을 기반으로 프로젝션을 생성하는 것입니다. 프로젝션은 엔티티의 타입 계층 구조 외부에 있는 타입으로, 인터페이스나 DTO 클래스를 사용하여 구현할 수 있습니다. 인터페이스 기반 프로젝션은 속성에 대한 접근자 메서드를 선언하여 프로젝션 인터페이스로 사용할 수 있으며, 클래스 기반 프로젝션은 JPQL SELECT 문에서 DTO 클래스 참조를 사용하여 사용할 수 있습니다. 프로젝션은 쿼리 메서드의 반환 유형으로 사용하거나 쿼리 메서드에서 동적 프로젝션 매개변수를 사용하여 동적으로 사용할 수 있습니다. 스프링 데이터는 프로젝션 인터페이스를 사용하여 프록시 인스턴스를 생성하고, 쿼리 메서드의 반환 유형으로 사용되는 경우 프로젝션 프록시 백킹에 필요한 모든 속성에 대해 알고 있기 때문에 쿼리 실행을 최적화할 수 있습니다. 프로젝션 인터페이스에서 @Value 어노테이션을 사용하여 새로운 값을 계산할 수 있으며, 복잡한 표현식의 경우 스프링 빈을 사용하여 표현식에서 메서드를 호출하는 것이 좋습니다. 프로젝션 인터페이스에서는 nullable wrapper를 사용하여 null-safety를 개선할 수 있으며, 현재 지원되는 wrapper 유형은 Optional, Optional, Option, Option입니다."
"스프링 데이터 JPA에서 DTO 기반 프로젝션을 어떻게 사용하나요?","스프링 데이터 JPA에서 DTO 기반 프로젝션을 사용하려면, 프로젝션할 필드에 대한 속성을 보유하는 값 유형 DTO(Data Transfer Object)를 생성해야 합니다. DTO 유형은 프로젝션 인터페이스와 동일한 방식으로 사용할 수 있지만, 프록시링이 발생하지 않고 중첩된 프로젝션을 적용할 수 없습니다. 매핑 엔진이 로드할 필드를 제한하여 쿼리 실행을 최적화하는 경우, 로드할 필드는 노출된 생성자의 매개변수 이름에서 결정됩니다. 다음은 프로젝션 DTO의 예시입니다: record NamesOnly(String firstname, String lastname) { }"
"스프링 데이터에서 인터페이스 기반 프로젝션과 클래스 기반 프로젝션의 차이점은 무엇인가요?","인터페이스 기반 프로젝션은 속성에 대한 접근자 메서드를 선언하여 프로젝션 인터페이스로 사용할 수 있으며, 클래스 기반 프로젝션은 JPQL SELECT 문에서 DTO 클래스 참조를 사용하여 사용할 수 있습니다. 인터페이스 기반 프로젝션에서는 쿼리 메서드의 반환 유형으로 사용되는 경우 스프링 데이터가 프록시 인스턴스를 생성하고, 쿼리 메서드의 반환 유형으로 사용되는 경우 프록시 인스턴스를 생성하지 않습니다. 인터페이스 기반 프로젝션에서는 중첩된 프로젝션을 적용할 수 있지만, 클래스 기반 프로젝션에서는 적용할 수 없습니다. 또한, 클래스 기반 프로젝션은 JPQL 표현식에서 생성자 표현식에 제한되며, 네이티브 쿼리에서는 전혀 작동하지 않습니다."
"Spring Data JPA에서 저장 프로시저를 호출하는 방법은 무엇인가요?","Spring Data JPA 2.1 스펙에서는 JPA criteria query API를 사용하여 저장 프로시저를 호출하는 기능을 도입했습니다. Repository 메서드에 @Procedure 어노테이션을 사용하여 저장 프로시저 메타를 선언할 수 있습니다. 데이터베이스에서 저장 프로시저를 참조하는 방법은 여러 가지가 있습니다. @Procedure 어노테이션의 value, procedureName 또는 name 속성을 사용하여 저장 프로시저를 직접 정의할 수 있습니다. 또는 @NamedStoredProcedureQuery.name 속성을 @Procedure.name 속성으로 지정할 수도 있습니다. JPA는 @NamedStoredProcedureQuery 어노테이션을 사용하여 저장 프로시저 메타를 구성할 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/stored-procedures.html)"
"Spring Data JPA에서 @NamedStoredProcedureQuery 어노테이션은 어떻게 사용되나요?","@NamedStoredProcedureQuery 어노테이션은 엔티티 유형에 저장 프로시저 메타를 구성하는 데 사용됩니다. 이 어노테이션은 JPA가 사용하는 이름(name)과 데이터베이스에서 저장 프로시저의 이름(procedureName) 두 가지 다른 저장 프로시저 이름을 가지고 있습니다. parameters 속성을 사용하여 인/아웃 매개변수 이름을 매핑할 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/stored-procedures.html)"
"Spring Data JPA에서 저장 프로시저를 참조하는 방법은 무엇인가요?","Spring Data JPA에서는 @Procedure 어노테이션의 value, procedureName 또는 name 속성을 사용하여 저장 프로시저를 참조할 수 있습니다. 또한, 저장 프로시저의 이름을 Repository 메서드 이름으로 사용할 수도 있습니다. 호출되는 저장 프로시저에 단일 아웃 매개변수가 있는 경우, 해당 매개변수는 메서드의 반환 값으로 반환될 수 있습니다. 여러 아웃 매개변수가 지정되어 있는 경우, 해당 매개변수는 @NamedStoredProcedureQuery 어노테이션에서 지정된 매개변수 이름을 키로 하는 Map으로 반환될 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/stored-procedures.html)"
"스프링 데이터 JPA에서 Specification을 사용하는 목적은 무엇인가요?","스프링 데이터 JPA에서 Specification은 Eric Evans의 'Domain Driven Design'에서 제시한 개념을 따라 JPA Criteria API 제약 조건을 사용하여 도메인 클래스에 대한 쿼리의 where 절을 정의하는 데 사용됩니다. Specification을 사용하면 다양한 방법으로 Specification을 실행할 수 있으며, 필요에 따라 새로운 Specification을 만들고 기존 구현과 결합하여 데이터 액세스 계층을 확장할 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/specifications.html)"
"스프링 데이터 JPA에서 JpaSpecificationExecutor 인터페이스를 사용하는 방법은 무엇인가요?","스프링 데이터 JPA에서 JpaSpecificationExecutor 인터페이스는 JpaRepository를 확장하여 Specification을 사용하는 기능을 제공합니다. JpaSpecificationExecutor 인터페이스를 사용하면 findAll, findOne, delete와 같은 메서드를 사용하여 Specification을 실행할 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/specifications.html)"
"스프링 데이터 JPA에서 Specification을 사용하는 이점은 무엇인가요?","스프링 데이터 JPA에서 Specification을 사용하면 필요한 모든 조합에 대한 쿼리를 선언할 필요 없이, 엔티티 위에 확장 가능한 예측자 집합을 만들고 JpaRepository와 결합하여 사용할 수 있습니다. Specification은 실행 가능한 쿼리를 생성하며, Specification 객체를 결합하여 새로운 Specification 객체를 만들 수 있습니다. 이러한 조합을 통해 데이터 액세스 계층을 확장할 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/specifications.html)"
"Query by Example (QBE)란 무엇이며 어떤 장점이 있나요?","Query by Example (QBE)는 간단한 인터페이스를 가진 사용자 친화적인 쿼리 기술입니다. 동적 쿼리 생성을 허용하며 필드 이름을 포함하는 쿼리를 작성할 필요가 없습니다. 실제로 Query by Example은 저장소별 쿼리 언어를 사용하여 쿼리를 작성할 필요가 없습니다. 이 기술은 정적 또는 동적 제약 조건 집합으로 데이터 저장소를 쿼리하는 데 적합합니다. 또한 기존 쿼리를 깨뜨리지 않고 도메인 객체를 자주 리팩토링할 수 있으며 기본 데이터 저장소 API와 독립적으로 작동합니다."
"Query by Example에서 Probe, ExampleMatcher, Example 및 FetchableFluentQuery의 역할은 무엇인가요?","Probe는 채워진 필드가 있는 도메인 객체의 실제 예입니다. ExampleMatcher는 특정 필드를 일치시키는 방법에 대한 세부 정보를 운반하며 여러 예제에서 재사용할 수 있습니다. Example은 Probe와 ExampleMatcher로 구성되며 쿼리를 만드는 데 사용됩니다. FetchableFluentQuery는 예제에서 파생된 쿼리의 추가 사용자 지정을 허용하는 유창한 API를 제공합니다. 이 API를 사용하면 쿼리에 대한 정렬, 투영 및 결과 처리를 지정할 수 있습니다."
"Query by Example에서 매치 옵션을 구성하는 방법은 무엇인가요?","매치 옵션을 구성하려면 ExampleMatcher를 사용하여 문자열 일치, 널 처리 및 속성별 설정에 대한 자체 기본값을 지정할 수 있습니다. 개별 속성에 대한 동작을 지정할 수 있으며 매치 옵션 및 대/소문자 구별을 조정할 수 있습니다. 매치 옵션을 구성하는 또 다른 방법은 Java 8에서 도입된 람다를 사용하는 것입니다. 이 접근 방식은 구현자에게 매치러를 수정하도록 요청하는 콜백을 만듭니다."
"Spring Data JPA에서 SimpleJpaRepository에서 상속받은 메서드의 기본 트랜잭션 구성은 어떻게 되나요?","Spring Data JPA에서 SimpleJpaRepository에서 상속받은 메서드의 기본 트랜잭션 구성은 SimpleJpaRepository에서 상속받은 transactional configuration입니다. 읽기 전용 작업의 경우, transaction configuration의 readOnly 플래그가 true로 설정됩니다. 다른 모든 메서드는 기본 transaction configuration이 적용되도록 plain @Transactional로 구성됩니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/transactions.html)"
"Spring Data JPA에서 트랜잭션 구성을 변경하려면 어떻게 해야 하나요?","Spring Data JPA에서 트랜잭션 구성을 변경하려면, 리포지토리 인터페이스에서 메서드를 다시 선언하면 됩니다. 이렇게 하면 메서드가 설정한 시간 제한과 readOnly 플래그 없이 실행됩니다. 또는 여러 리포지토리를 포괄하는 패사드 또는 서비스 구현을 사용하여 트랜잭션 동작을 변경할 수도 있습니다. 이렇게 하면 패사드에서 트랜잭션 경계가 정의되어 비-CRUD 작업에 대한 트랜잭션이 정의됩니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/transactions.html)"
"Spring Data JPA에서 @Transactional을 쿼리 메서드에 사용하는 방법은 무엇인가요?","Spring Data JPA에서 @Transactional을 쿼리 메서드에 사용하려면, 정의한 리포지토리 인터페이스에서 @Transactional을 사용하면 됩니다. 이렇게 하면 메서드가 트랜잭션으로 실행됩니다. 대부분의 쿼리 메서드는 데이터를 읽기만 하므로 readOnly 플래그를 true로 설정하는 것이 좋습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/transactions.html)"
"Spring Data에서 제공하는 감사 기능은 무엇인가요?","Spring Data는 엔티티를 생성하거나 수정한 사람과 변경 일시를 투명하게 추적할 수 있는 기능을 제공합니다. 이 기능을 사용하려면, 엔티티 클래스에 애노테이션 또는 인터페이스를 사용하여 감사 메타데이터를 추가해야 합니다. 그리고 감사 기능을 활성화하려면, 애노테이션 구성 또는 XML 구성을 통해 필요한 인프라 구성 요소를 등록해야 합니다. 구체적인 구성 방법은 스토어별 섹션을 참조하시기 바랍니다."
"Spring Data에서 감사 메타데이터를 정의하는 방법은 무엇인가요?","감사 메타데이터를 정의하는 방법은 애노테이션을 사용하거나 인터페이스를 구현하는 방법입니다. 애노테이션을 사용하여 @CreatedBy, @LastModifiedBy, @CreatedDate, @LastModifiedDate를 사용하여 감사 정보를 캡처할 수 있습니다. 또는 Auditable 인터페이스를 구현하여 감사 속성에 대한 setter 메서드를 사용할 수도 있습니다."
"Spring Data에서 @CreatedBy 또는 @LastModifiedBy 애노테이션을 사용하려면 어떻게 해야 하나요?","@CreatedBy 또는 @LastModifiedBy 애노테이션을 사용하려면, AuditorAware<T> SPI 인터페이스를 구현하여 현재 주체 또는 시스템과 상호 작용하는 현재 사용자를 인프라에 알려야 합니다. 구현은 Spring Security에서 제공하는 Authentication 객체를 사용하여 애플리케이션과 상호 작용하는 현재 사용자 또는 시스템을 알려줍니다. reactive 인프라를 사용하는 경우, ReactiveAuditorAware<T> SPI 인터페이스를 구현하여 컨텍스트 정보를 사용하고 @CreatedBy 또는 @LastModifiedBy 정보를 제공할 수 있습니다."
"Spring에서 여러 개의 persistence unit을 하나의 persistence unit으로 병합하려면 어떻게 해야 하나요?","Spring Data JPA의 PersistenceUnitManager 구현인 MergingPersistenceUnitManager를 사용하여 persistence unit을 자동으로 병합할 수 있습니다. 다음 예제와 같이 persistence unit의 이름을 기반으로 병합할 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/misc-merging-persistence-units.html)"
"Spring Data JPA에서 @Entity 클래스와 JPA 매핑 파일을 스캔하려면 어떻게 해야 하나요?","ClasspathScanningPersistenceUnitPostProcessor를 사용하여 @Entity 또는 @MappedSuperclass로 주석이 달린 클래스를 스캔하고, 파일명 패턴과 일치하는 구성 파일을 로드하고, JPA 구성에 전달할 수 있습니다. 다음 예제와 같이 LocalContainerEntityManagerFactoryBean에 post-processor를 구성해야 합니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/misc-merging-persistence-units.html)"
"Spring 3.1 이상에서 LocalContainerEntityManagerFactoryBean에서 엔티티 클래스를 스캔하려면 어떻게 해야 하나요?","LocalContainerEntityManagerFactoryBean에서 직접 스캔할 패키지를 구성하여 엔티티 클래스에 대한 클래스패스 스캔을 활성화할 수 있습니다. 자세한 내용은 JavaDoc(https://docs.spring.io/spring-framework/docs/6.1.13/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html#setPackagesToScan(java.lang.String…​)$$)을 참조하세요. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/misc-merging-persistence-units.html)"
"스프링 데이터 JPA와 CDI 통합을 위해 필요한 설정은 무엇인가요?","스프링 데이터 JPA와 CDI 통합을 위해 EntityManagerFactory와 EntityManager에 대한 CDI Producer를 구현해야 합니다. 필요한 설정은 JavaEE 환경에 따라 다를 수 있으며, EntityManager를 CDI 빈으로 재선언하는 것만으로도 충분할 수 있습니다. 스프링 데이터 JPA CDI 확장은 CDI 빈으로 사용 가능한 모든 EntityManager 인스턴스를 가져와 컨테이너에서 리포지토리 유형의 빈을 요청할 때마다 스프링 데이터 리포지토리의 프록시를 생성합니다."
"스프링 데이터 JPA CDI 확장이 컨테이너에서 리포지토리 인스턴스를 요청하면 어떻게 동작하나요?","스프링 데이터 JPA CDI 확장은 컨테이너에서 리포지토리 유형의 빈을 요청할 때마다 스프링 데이터 리포지토리의 프록시를 생성합니다."
"스프링 데이터 JPA CDI 확장에서 리포지토리 클라이언트를 설정하는 방법은 무엇인가요?","스프링 데이터 JPA CDI 확장에서 리포지토리 클라이언트를 설정하려면 @Inject 속성을 선언하여 리포지토리 인스턴스를 가져오면 됩니다. 비즈니스 메서드 내에서 리포지토리 메서드를 호출할 수 있습니다."
"스프링 데이터에서 커스텀 리포지토리 구현을 위해 어떤 단계를 따라야 하나요?","스프링 데이터에서 커스텀 리포지토리 구현을 하려면, 먼저 커스텀 리포지토리 기능을 위한 프래그먼트 인터페이스와 구현체를 정의해야 합니다. 그런 다음, 리포지토리 인터페이스를 해당 프래그먼트 인터페이스로 확장합니다. 구현 자체는 스프링 데이터에 의존하지 않으며, 일반적인 스프링 빈이 될 수 있습니다. 이후, 다른 빈에 대한 참조를 주입하기 위해 표준 의존성 주입 동작을 사용하고, 어스펙트에 참여할 수 있습니다. 마지막으로, 리포지토리 인터페이스를 커스텀 기능을 위한 프래그먼트 인터페이스로 확장하여 CRUD와 커스텀 기능을 결합하고 클라이언트에게 제공합니다."
"스프링 데이터에서 커스텀 구현의 우선순위는 어떻게 결정되나요?","스프링 데이터에서 커스텀 구현의 우선순위는 선언 순서에 따라 결정됩니다. 커스텀 구현은 기본 구현 및 리포지토리 어스펙트보다 우선순위가 높습니다. 이러한 순서는 기본 리포지토리 및 어스펙트 메서드를 오버라이드하고, 두 개의 프래그먼트가 동일한 메서드 시그니처를 제공하는 경우 모호성을 해결합니다."
"스프링 데이터에서 커스텀 리포지토리 구현을 수동으로 배선하는 방법은 무엇인가요?","스프링 데이터에서 커스텀 리포지토리 구현을 수동으로 배선하려면, 메서드 시그니처가 일치하는 여러 구현체가 발견되는 경우, Spring Data는 어떤 것을 사용할지 식별하기 위해 빈 이름을 사용합니다. 구현체를 수동으로 선언하고, 이전 섹션에서 설명한 규칙에 따라 이름을 지정할 수 있습니다. 그러면 인프라는 직접 빈 정의를 생성하는 대신, 수동으로 정의된 빈 정의를 이름으로 참조합니다."
"도메인 이벤트란 무엇인가요?","도메인 이벤트는 도메인 모델에서 발생한 중요한 이벤트를 나타내는 것입니다. 이는 애플리케이션의 핵심 비즈니스 로직에서 발생한 중요한 변화를 나타냅니다. 도메인 이벤트는 일반적으로 이벤트 소싱과 CQRS(Command Query Responsibility Segregation) 패턴에서 사용됩니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/repositories/core-domain-events.html)"
"Spring Data의 @DomainEvents 어노테이션은 무엇인가요?","@DomainEvents 어노테이션은 Spring Data에서 제공하는 어노테이션으로, 애그리게이트 루트의 메서드에 사용하여 도메인 이벤트의 게재를 쉽게 할 수 있습니다. 이 어노테이션을 사용하면, 지정된 메서드가 호출될 때 도메인 이벤트가 자동으로 게재됩니다. 이 메서드는 단일 이벤트 인스턴스 또는 이벤트 컬렉션을 반환할 수 있으며, 인수를 받지 않아야 합니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/repositories/core-domain-events.html)"
"@AfterDomainEventPublication 어노테이션은 무엇인가요?","@AfterDomainEventPublication 어노테이션은 Spring Data에서 제공하는 어노테이션으로, 모든 이벤트가 게재된 후에 호출되는 메서드에 사용됩니다. 이 어노테이션을 사용하면, 이벤트 게재 후 이벤트 목록을 정리하거나 다른 작업을 수행할 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/repositories/core-domain-events.html)"
"스프링 데이터에서 리포지토리 메소드의 널 처리는 어떻게 이루어지나요?","스프링 데이터 2.0 이상에서는 리포지토리 CRUD 메소드가 값의 부재를 나타내기 위해 Java 8의 Optional을 사용합니다. 또한, Spring Data는 쿼리 메소드에서 com.google.common.base.Optional, scala.Option, io.vavr.control.Option과 같은 래퍼 유형을 반환하는 것을 지원합니다. 또는 쿼리 메소드는 래퍼 유형을 전혀 사용하지 않을 수도 있습니다. 이 경우 쿼리 결과의 부재는 null을 반환하여 표시됩니다. 컬렉션, 컬렉션 대안, 래퍼 및 스트림을 반환하는 리포지토리 메소드는 null을 반환하지 않고 해당 빈 표현을 반환합니다. 자세한 내용은 https://docs.spring.io/spring-data/jpa/reference/3.3/repositories/null-handling.html을 참조하십시오."
"스프링에서 리포지토리 메소드의 널 가능성에 대한 제약 조건을 표현하는 방법은 무엇인가요?","Spring Framework의 널 가능성 주석(https://docs.spring.io/spring-framework/reference/6.1/core/null-safety.html)을 사용하여 리포지토리 메소드의 널 가능성에 대한 제약 조건을 표현할 수 있습니다. 예를 들어, @NonNullApi, @NonNull, @Nullable 주석을 사용하여 널 가능성에 대한 제약 조건을 표현할 수 있습니다. Spring 주석은 JSR 305(https://jcp.org/en/jsr/detail?id=305) 주석으로 메타 주석이 지정되어 있으며, 이는 널리 사용되는 휴면 상태의 JSR입니다. 이를 통해 IDEA(https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html), Eclipse(https://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm) 및 Kotlin(https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types)과 같은 도구가 Spring 주석에 대한 지원을 하드 코딩하지 않고도 일반적인 방식으로 null 안전 지원을 제공할 수 있습니다."
"Kotlin 기반 리포지토리에서 널 가능성은 어떻게 처리되나요?","Kotlin은 언어에 널 가능성 제약 조건의 정의를 내장하고 있습니다. Kotlin 코드는 메소드 시그니처를 통해 널 가능성 제약 조건을 표현하는 대신 컴파일된 메타데이터를 통해 널 가능성 제약 조건을 표현하는 바이트 코드로 컴파일됩니다. Kotlin의 널 가능성 제약 조건을 검사하려면 프로젝트에 kotlin-reflect JAR를 포함해야 합니다. Spring Data 리포지토리는 언어 메커니즘을 사용하여 이러한 제약 조건을 정의하여 동일한 런타임 검사를 적용합니다. 예를 들어, 매개 변수와 결과를 모두 널이 아닌 것으로 정의하는 경우 Kotlin 컴파일러는 메소드 호출이 메소드에 널을 전달하는 것을 거부합니다. 쿼리가 빈 결과를 반환하면 EmptyResultDataAccessException이 발생합니다."
"QuerydslPredicateExecutor 인터페이스는 어떤 기능을 제공하나요?","QuerydslPredicateExecutor 인터페이스는 Predicate 인스턴스를 사용하여 타입 안전한 쿼리를 작성할 수 있게 해주는 기능을 제공합니다. 이 인터페이스를 사용하면 Predicate와 함께 findAll(), count(), exists() 등의 메서드를 사용하여 데이터를 검색하고 개수를 얻을 수 있습니다. Repository 인터페이스에 QuerydslPredicateExecutor를 확장하여 Querydsl 지원을 사용할 수 있습니다."
"Spring MVC에서 DomainClassConverter 클래스는 어떤 역할을 하나요?","Spring MVC에서 DomainClassConverter 클래스는 Spring MVC가 request parameter나 path variable에서 repository-managed domain classes의 인스턴스를 해결할 수 있게 해주는 역할을 합니다. 이를 통해 Spring MVC controller method signature에서 domain types를 직접 사용할 수 있게 되며, 수동으로 repository를 통해 인스턴스를 조회할 필요가 없어집니다."
"Spring Data의 PagedModel은 어떤 용도로 사용되나요?","Spring Data의 PagedModel은 Page나 Slice 인스턴스의 내용을 PagedModel 인스턴스로 감싸서, Spring HATEOAS에서 정한 구조를 반영하면서도 navigation links를 생략한 간소화된 표현을 반환하는 데 사용됩니다. 이를 통해 Page나 Slice 인스턴스를 클라이언트에게 쉽게 탐색할 수 있는 JSON 표현으로 변환할 수 있습니다."
"스프링 데이터 저장소 쿼리 파생 메커니즘에서 일반적으로 지원되는 쿼리 주제 키워드는 무엇인가요?","find…By, read…By, get…By, query…By, search…By, stream…By, exists…By, count…By, delete…By, remove…By, …First<number>…, …Top<number>…, …Distinct, 이러한 키워드는 저장소 특정 문서를 참조하여 정확한 지원 키워드 목록을 확인하세요. (출처: https://docs.spring.io/spring-data/jpa/reference/html/#repositories.query-methods.query-creation)"
"스프링 데이터 저장소 쿼리 파생 메커니즘에서 일반적으로 지원되는 쿼리 예측 키워드는 무엇인가요?","AND, OR, AFTER, Before, CONTAINING, BETWEEN, ENDING_WITH, EXISTS, FALSE, GREATER_THAN, GREATER_THAN_EQUALS, IN, IS, IS_EMPTY, IS_NOT_EMPTY, IS_NOT_NULL, IS_NULL, LESS_THAN, LESS_THAN_EQUAL, LIKE, NEAR, NOT, NOT_IN, NOT_LIKE, REGEX, STARTING_WITH, TRUE, WITHIN입니다. 이러한 키워드는 저장소 특정 문서를 참조하여 정확한 지원 키워드 목록을 확인하세요. (출처: https://docs.spring.io/spring-data/jpa/reference/html/#repositories.query-methods.query-creation)"
"스프링 데이터 저장소 쿼리 파생 메커니즘에서 일반적으로 지원되는 쿼리 예측 수정자는 무엇인가요?","IgnoreCase, IgnoringCase, AllIgnoreCase, OrderBy…, 이러한 키워드는 저장소 특정 문서를 참조하여 정확한 지원 키워드 목록을 확인하세요. (출처: https://docs.spring.io/spring-data/jpa/reference/html/#repositories.query-methods.query-creation)"
"스프링 데이터 저장소에서 일반적으로 지원되는 쿼리 반환 유형은 무엇인가요?","스프링 데이터 저장소에서 일반적으로 지원되는 쿼리 반환 유형은 void, Java 기본형, Java 래퍼형, T (고유한 엔티티), Iterator<T>, Collection<T>, List<T>, Optional<T>, Option<T>, Stream<T>, Streamable<T>, Vavr 컬렉션 유형, Future<T>, CompletableFuture<T>, Slice<T>, Page<T>, Window<T>, GeoResult<T>, GeoResults<T>, GeoPage<T>, Mono<T>, Flux<T>, Single<T>, Maybe<T>, Flowable<T>입니다. (출처: <https://docs.spring.io/spring-data/jpa/reference/3.3/repositories/query-return-types-reference.html>)"
"Spring Data 저장소에서 Future를 반환 유형으로 사용하려면 어떤 요구 사항이 있나요?","Spring Data 저장소에서 Future를 반환 유형으로 사용하려면 메서드가 @Async 어노테이션으로 주석 처리되어야 하고 Spring의 비동기 메서드 실행 기능이 활성화되어야 합니다. (출처: <https://docs.spring.io/spring-data/jpa/reference/3.3/repositories/query-return-types-reference.html>)"
"Spring Data 저장소에서 Slice가 반환 유형으로 사용되는 경우는 언제인가요?","Spring Data 저장소에서 Slice는 Pageable 메서드 매개변수가 필요한 쿼리에 대해 반환 유형으로 사용됩니다. 이는 더 많은 데이터가 있는지 여부를 나타내는 크기가 지정된 데이터 청크를 제공합니다. (출처: <https://docs.spring.io/spring-data/jpa/reference/3.3/repositories/query-return-types-reference.html>)"
"AOP란 무엇인가요?","Aspect-oriented programming (AOP)은 소프트웨어 개발 기법 중 하나로, 애플리케이션의 핵심 비즈니스 로직과 교차 관심사(cross-cutting concerns)를 분리하는 기술입니다. 교차 관심사는 로깅, 보안, 트랜잭션 처리 등과 같은 기능으로, 여러 부분에서 반복적으로 사용되는 코드입니다. AOP는 이러한 교차 관심사를 분리하여 모듈화하고, 이를 핵심 비즈니스 로직과 결합하여 애플리케이션의 구조와 유지 보수성을 향상시킵니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/glossary.html)"
"Spring에서 DAO 패턴이란 무엇인가요?","DAO(Data Access Object) 패턴은 객체 지향 프로그래밍에서 사용되는 디자인 패턴으로, 데이터 액세스 로직을 객체와 분리하는 패턴입니다. DAO는 데이터베이스와 같은 데이터 소스에 대한 데이터를 생성, 읽기, 업데이트, 삭제하는 메서드를 제공합니다. 이를 통해 애플리케이션의 비즈니스 로직과 데이터 액세스 로직을 분리하여 코드의 유지 보수성과 확장성을 향상시킵니다. Spring에서는 JPA, Hibernate 등과 같은 데이터 액세스 라이브러리를 사용하여 DAO를 구현할 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/glossary.html)"
"Spring 프레임워크에서 의존성 주입이란 무엇인가요?","Spring 프레임워크에서 의존성 주입(Dependency Injection)은 객체 간의 의존성을 외부에서 설정하여 주입하는 디자인 패턴입니다. 일반적으로 객체는 자신이 사용할 다른 객체에 대한 의존성을 직접 생성하고 참조합니다. 하지만 의존성 주입을 사용하면 외부에서 객체를 생성하고 주입해주므로 객체 간의 결합도를 낮출 수 있습니다. 이를 통해 코드의 유연성과 유지 보수성을 향상시킬 수 있습니다. Spring 프레임워크에서는 의존성 주입을 위해 setter 메서드, constructor 주입, Java 6의 @Resource 어노테이션 등을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/jpa/glossary.html)"
"Envers의 Repository 지원에서 어떤 특별한 기능이 제공되나요?","Envers의 Repository 지원은 이전에 설명된 핵심 Repository 지원을 기반으로 구축됩니다. 이에 대한 자세한 내용은 https://docs.spring.io/spring-data/jpa/reference/3.3/envers.html#envers-introduction을 참조하세요."
"Envers를 구성하는 방법은 무엇인가요?","Envers를 구성하는 방법은 https://docs.spring.io/spring-data/jpa/reference/3.3/envers.html#envers-configuration에서 확인할 수 있습니다."
"Envers를 사용하는 방법은 무엇인가요?","Envers를 사용하는 방법은 https://docs.spring.io/spring-data/jpa/reference/3.3/envers.html#envers-usage에서 설명되어 있습니다."
"Spring Data Envers는 어떤 Spring Data 모듈과 함께 사용되나요?","Spring Data Envers는 항상 다른 Spring Data 모듈인 Spring Data JPA와 함께 사용됩니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/envers/introduction.html)"
"Envers는 어떤 기능을 제공하는 Hibernate 모듈인가요?","Envers는 JPA 엔티티에 대한 감사 기능을 추가하는 Hibernate 모듈입니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/envers/introduction.html)"
"Spring Data Envers의 이 문서는 어떤 가정을 하고 작성되었나요?","이 문서는 Envers에 익숙하다고 가정하고 작성되었습니다. Spring Data Envers는 Envers가 올바르게 구성되어 있다고 가정합니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/envers/introduction.html)"
"스프링 데이터 엔버스를 사용하려면 어떤 의존성을 추가해야 하나요?","프로젝트에 스프링 데이터 JPA가 클래스패스에 있어야 하며, 추가로 spring-data-envers 의존성을 추가해야 합니다. <dependencies> 내에 <dependency> <groupId>org.springframework.data</groupId> <artifactId>spring-data-envers</artifactId> <version>3.3.4</version> </dependency> </dependencies>를 추가하면 됩니다. 이를 통해 hibernate-envers도 프로젝트에 일시적인 의존성으로 추가됩니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/envers/configuration.html)"
"스프링 데이터 엔버스와 스프링 데이터 JPA를 구성하려면 어떤 빈과 팩토리를 설정해야 하나요?","스프링 데이터 엔버스와 스프링 데이터 JPA를 구성하려면 두 개의 빈과 특별한 리포지토리FactoryBeanClass를 설정해야 합니다. @Configuration, @EnableEnversRepositories, @EnableTransactionManagement 어노테이션을 사용하여 EnversDemoConfiguration 클래스를 설정하고, dataSource(), entityManagerFactory(), transactionManager() 메소드를 생성하여 빈을 구성합니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/envers/configuration.html)"
"엔버스와 함께 사용할 리포지토리를 설정하려면 어떤 단계를 따라야 하나요?","엔버스와 함께 사용할 리포지토리를 설정하려면 RevisionRepository 인터페이스를 확장하여 PersonRepository와 같이 엔버스 리포지토리로 만들어야 합니다. PersonRepository에는 CrudRepository와 RevisionRepository 인터페이스를 모두 확장하고, 타입 매개변수로 Person, Long, Long을 지정해야 합니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/envers/configuration.html)"
"EnversIntegrationTests 클래스에서 RevisionRepository의 메서드를 사용하여 엔티티의 수정 사항을 쿼리하는 방법은 무엇인가요?","EnversIntegrationTests 클래스에서는 RevisionRepository의 메서드를 사용하여 엔티티의 수정 사항을 쿼리합니다. PersonRepository를 통해 RevisionRepository를 주입받고, findRevisions() 메서드를 사용하여 수정 사항의 리스트를 가져옵니다. 그리고 iterator를 사용하여 수정 사항을 순회하며, 각 수정 사항의 엔티티와 수정 유형을 확인합니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/envers/usage.html#envers.querying)"
"Spring Data Envers 예제를 다운로드하고 직접 실행해보려면 어떻게 해야 하나요?","Spring Data Envers 예제는 Spring Data Examples 저장소에서 다운로드할 수 있습니다. 해당 저장소는 https://github.com/spring-projects/spring-data-examples 에 있으며, 해당 저장소에서 예제를 다운로드하고 실행하여 라이브러리를 직접 사용해볼 수 있습니다. (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/envers/usage.html#envers.further-resources)"
"Spring Data Envers의 RevisionRepository와 관련 클래스에 대한 Javadoc은 어디에서 확인할 수 있나요?","Spring Data Envers의 RevisionRepository와 관련 클래스에 대한 Javadoc은 다음 링크에서 확인할 수 있습니다: https://docs.spring.io/spring-data/commons/docs/3.3.4/api/org/springframework/data/repository/history/RevisionRepository.html (출처: https://docs.spring.io/spring-data/jpa/reference/3.3/envers/usage.html#envers.further-resources)"
"Spring Data LDAP란 무엇인가요?","Spring Data LDAP는 Lightweight Directory Access Protocol (LDAP)을 위한 리포지토리 지원을 제공합니다. 이는 LDAP 데이터 소스에 액세스해야 하는 일관된 프로그래밍 모델을 가진 애플리케이션의 개발을 용이하게 합니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/index.html)"
"Spring Data LDAP의 이점은 무엇인가요?","Spring Data LDAP는 일관된 프로그래밍 모델을 통해 애플리케이션 개발을 용이하게 하며, LDAP 데이터 소스에 액세스해야 하는 개발을 간소화합니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/index.html)"
"Spring Data LDAP에서 리포지토리란 무엇인가요?","Spring Data 리포지토리는 LDAP 및 LDAP 리포지토리에 대한 소개를 제공합니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/index.html)"
"Spring Data를 업그레이드하는 방법은 무엇인가요?","Spring Data를 업그레이드하는 방법은 Spring Data Commons 프로젝트의 위키(https://github.com/spring-projects/spring-data-commons/wiki)에 문서화되어 있습니다. 원하는 버전으로 업그레이드하기 위해 릴리스 노트 섹션(https://github.com/spring-projects/spring-data-commons/wiki#release-notes)의 링크를 따라가서 업그레이드 지침을 확인하세요. 업그레이드 지침은 항상 릴리스 노트의 첫 번째 항목입니다. 한 개 이상의 릴리스를 건너뛰었다면, 건너뛴 버전의 릴리스 노트도 검토해야 합니다."
"Spring Data를 특정 버전으로 업그레이드하는 지침은 어디에서 찾을 수 있나요?","Spring Data를 특정 버전으로 업그레이드하는 지침은 Spring Data Commons 프로젝트의 위키(https://github.com/spring-projects/spring-data-commons/wiki)에서 찾을 수 있습니다. 릴리스 노트 섹션(https://github.com/spring-projects/spring-data-commons/wiki#release-notes)의 링크를 따라가서 원하는 버전으로 이동하면 됩니다. 업그레이드 지침은 항상 릴리스 노트의 첫 번째 항목입니다."
"Spring Data를 업그레이드할 때 여러 버전을 건너뛰면 어떤 조치를 취해야 하나요?","Spring Data를 업그레이드할 때 여러 버전을 건너뛰면, 건너뛴 버전의 릴리스 노트도 검토해야 합니다. 업그레이드 지침은 Spring Data Commons 프로젝트의 위키(https://github.com/spring-projects/spring-data-commons/wiki)에서 찾을 수 있습니다. 릴리스 노트 섹션(https://github.com/spring-projects/spring-data-commons/wiki#release-notes)의 링크를 따라가서 원하는 버전으로 이동하면 됩니다. 업그레이드 지침은 항상 릴리스 노트의 첫 번째 항목입니다."
"Spring Data repositories의 목표는 무엇인가요?","다양한 지속성 저장소에 대한 데이터 액세스 계층을 구현하는 데 필요한 반복 코드의 양을 크게 줄이는 것입니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/introduction.html)"
"Spring Data repositories의 기본 개념과 인터페이스에 대한 정보를 찾을 수 있는 곳은 어디인가요?","이 장에서 설명하는 내용은 Spring Data Commons 모듈에서 가져온 것이며, Spring Data repositories의 핵심 개념과 인터페이스에 대한 정보를 제공합니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/introduction.html)"
"Spring Data repositories의 특정 모듈에 대한 자세한 정보를 얻을 수 있는 곳은 어디인가요?","이 문서의 해당 모듈에 대한 장을 참조하십시오. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/introduction.html)"
"스프링 데이터에서 Repository 인터페이스의 역할은 무엇인가요?","스프링 데이터에서 Repository 인터페이스는 도메인 클래스를 관리하고 도메인 클래스의 식별자 유형을 타입 인자로 받는 중앙 인터페이스입니다. 이 인터페이스는 주로 작업할 유형을 캡처하고 이 인터페이스를 확장하는 인터페이스를 발견하는 데 도움이 되는 마커 인터페이스로 작동합니다. (출처: https://docs.spring.io/spring-data/commons/docs/3.3.4/api//org/springframework/data/repository/Repository.html)"
"CrudRepository 인터페이스는 어떤 기능을 제공하나요?","CrudRepository 인터페이스는 관리되는 엔티티 클래스에 대한 정교한 CRUD 기능을 제공합니다. 이 인터페이스에서 선언된 메서드는 일반적으로 CRUD 메서드로 알려져 있습니다. (출처: https://docs.spring.io/spring-data/commons/docs/3.3.4/api//org/springframework/data/repository/CrudRepository.html)"
"ListCrudRepository 인터페이스는 어떤 기능을 제공하나요?","ListCrudRepository는 CrudRepository와 유사한 메서드를 제공하지만, Iterable 대신 List를 반환합니다. (출처: https://docs.spring.io/spring-data/commons/docs/3.3.4/api//org/springframework/data/repository/ListCrudRepository.html)"
"스프링 데이터에서 리포지토리 인터페이스를 정의하는 방법은 무엇인가요?","리포지토리 인터페이스를 정의하려면 먼저 도메인 클래스별 리포지토리 인터페이스를 정의해야 합니다. 이 인터페이스는 Repository를 확장하고 도메인 클래스 및 ID 유형에 대해 타입이 지정되어야 합니다. 해당 도메인 유형에 대한 CRUD 메서드를 노출하려면 Repository 대신 CrudRepository 또는 해당 변형 중 하나를 확장할 수 있습니다. 리스트CrudRepository는 Iterable 대신 List를 반환하는 CrudRepository와 매우 유사합니다. 리액티브 저장소를 사용하는 경우 ReactiveCrudRepository, RxJava3CrudRepository 또는 CoroutineCrudRepository를 선택할 수 있습니다. Spring Data 인터페이스를 확장하지 않으려면 @RepositoryDefinition으로 리포지토리 인터페이스를 주석 처리할 수 있습니다. CRUD 리포지토리 인터페이스 중 하나를 확장하면 엔티티를 조작하는 완전한 메서드 세트가 노출됩니다. 노출되는 메서드에 대해 선택적으로 지정하려면 CRUD 리포지토리에서 노출하려는 메서드를 도메인 리포지토리로 복사하면 됩니다. 이 메서드들은 선택한 저장소의 기본 리포지토리 구현(예: JPA를 사용하는 경우 SimpleJpaRepository)으로 라우팅됩니다. @NoRepositoryBean은 런타임에 Spring Data가 인스턴스를 만들지 않도록 하려면 모든 리포지토리 인터페이스에 추가해야 합니다. 리포지토리 인터페이스에 Spring Data 인터페이스를 모두 확장하려면 PagingAndSortingRepository, ReactiveSortingRepository, RxJava3SortingRepository 또는 CoroutineSortingRepository를 확장할 수도 있습니다."
"스프링 데이터에서 여러 개의 Spring Data 모듈을 사용하여 리포지토리를 사용하는 방법은 무엇인가요?","하나의 고유한 Spring Data 모듈을 사용하면 지정된 범위의 모든 리포지토리 인터페이스가 Spring Data 모듈에 바인딩되므로 간단합니다. 여러 모듈을 사용해야 하는 경우 리포지토리 정의는 지속성 기술을 구분해야 합니다. 여러 리포지토리 팩토리를 감지하면 Spring Data는 엄격한 리포지토리 구성 모드로 전환됩니다. 엄격한 구성은 리포지토리 또는 도메인 클래스에 대한 세부 정보를 사용하여 리포지토리 정의에 대한 Spring Data 모듈 바인딩을 결정합니다. 리포지토리 정의가 모듈별 리포지토리를 확장하는 경우 해당 Spring Data 모듈의 유효한 후보입니다. 도메인 클래스가 모듈별 유형 주석으로 주석 처리된 경우 해당 Spring Data 모듈의 유효한 후보입니다. Spring Data는 제3자 주석(예: JPA의 @Entity) 또는 자체 주석(예: Spring Data MongoDB 및 Spring Data Elasticsearch의 @Document)을 허용합니다. 리포지토리 유형 세부 정보 및 구별되는 도메인 클래스 주석은 엄격한 리포지토리 구성에 사용되어 특정 Spring Data 모듈의 리포지토리 후보자를 식별합니다. 동일한 도메인 유형에 여러 지속성 기술별 주석을 사용하면 Spring Data는 리포지토리를 바인딩할 고유한 모듈을 결정할 수 없습니다. 리포지토리를 구분하는 마지막 방법은 리포지토리 기본 패키지를 범위 지정하는 것입니다. 기본 패키지는 리포지토리 인터페이스 정의를 스캔하기 위한 시작점을 정의하며, 이는 적절한 패키지에 리포지토리 정의가 위치해야 함을 의미합니다. 기본적으로 어노테이션 기반 구성은 구성 클래스의 패키지를 사용합니다. XML 기반 구성의 기본 패키지(create-instances.html#repositories.create-instances.xml)는 필수입니다."
"CRUD 메서드를 선택적으로 노출하고 도메인 리포지토리에 필요한 메서드만 노출하는 방법은 무엇인가요?","CRUD 메서드를 선택적으로 노출하려면 CRUD 리포지토리에서 노출하려는 메서드를 도메인 리포지토리로 복사하면 됩니다. 이때 메서드의 반환 유형을 변경할 수 있습니다. Spring Data는 가능한 경우 반환 유형을 존중합니다. 또한, 애플리케이션의 많은 리포지토리가 동일한 메서드 집합을 가져야 하는 경우 자체 기본 인터페이스를 정의할 수 있습니다. 이러한 인터페이스는 @NoRepositoryBean으로 주석 처리되어야 합니다. 이렇게 하면 Spring Data가 직접 인스턴스를 만들려고 시도하고 실패하는 것을 방지할 수 있습니다. 왜냐하면 여전히 일반적인 유형 변수를 포함하고 있기 때문입니다. 아래는 CRUD 메서드를 선택적으로 노출하는 예입니다 (이 경우 findById 및 save):"
"스프링 데이터 리포지토리에서 쿼리 메소드를 정의하는 방법은 무엇인가요?","스프링 데이터 리포지토리에서 쿼리 메소드를 정의하는 방법은 메소드 이름에서 쿼리를 직접 파생하거나, 수동으로 정의된 쿼리를 사용하는 것입니다. 실제 저장소에 따라 사용 가능한 옵션이 달라집니다. 생성된 쿼리는 데이터 저장소에 따라 다르지만, 일반적으로 엔티티 속성에 대한 조건을 정의하고 And 및 Or 연산자로 연결할 수 있습니다. 지원되는 연산자는 데이터 저장소에 따라 다를 수 있으므로 해당 저장소의 참조 문서를 참조해야 합니다. 또한, 개별 속성에 대해 IgnoreCase 플래그를 설정하거나, 대소문자를 구분하지 않는 유형의 모든 속성에 대해 IgnoreCase 플래그를 설정할 수 있습니다. 정적 정렬을 적용하려면 쿼리 메소드에 속성을 참조하고 정렬 방향(Asc 또는 Desc)을 지정하는 OrderBy 절을 추가하면 됩니다. 쿼리 메소드에서 동적 정렬을 지원하는 쿼리 메소드를 만들려면 'Paging, Iterating Large Results, Sorting & Limiting'을 참조하십시오."
"쿼리 조회가란 무엇이며, 스프링 데이터 리포지토리에서 사용 가능한 전략은 무엇인가요?","쿼리 조회는 리포지토리 프록시에서 스토어별 쿼리를 파생하는 데 사용되는 전략입니다. XML 구성 파일에서 query-lookup-strategy 속성을 통해 네임스페이스 수준에서 전략을 구성하거나, Java 구성에서 EnableLdapRepositories 어노테이션의 queryLookupStrategy 속성을 사용할 수 있습니다. 사용 가능한 전략은 다음과 같습니다. CREATE는 쿼리 메소드 이름에서 스토어별 쿼리를 구성하려고 시도합니다. USE_DECLARED_QUERY는 선언된 쿼리를 찾으려고 시도하며, 선언된 쿼리를 찾을 수 없으면 예외를 던집니다. CREATE_IF_NOT_FOUND(기본값)는 CREATE와 USE_DECLARED_QUERY를 결합합니다. 먼저 선언된 쿼리를 찾고, 선언된 쿼리를 찾을 수 없으면 사용자 정의 메소드 이름 기반 쿼리를 만듭니다. 이 전략은 메소드 이름으로 빠른 쿼리 정의를 허용하지만 필요에 따라 선언된 쿼리를 도입하여 이러한 쿼리를 사용자 정의할 수 있습니다."
"스프링 데이터 리포지토리 인프라에 내장된 쿼리 빌더 메커니즘은 무엇을 하는 것인가요?","스프링 데이터 리포지토리 인프라에 내장된 쿼리 빌더 메커니즘은 리포지토리의 엔티티에 대한 제약 쿼리를 구축하는 데 유용합니다. 쿼리 메소드 이름에서 쿼리를 생성하고, 메소드 매개변수를 사용하여 쿼리 크리테리아를 정의하고, And 및 Or 연산자로 연결할 수 있습니다. 또한, 개별 속성에 대해 IgnoreCase 플래그를 설정하거나, 대소문자를 구분하지 않는 유형의 모든 속성에 대해 IgnoreCase 플래그를 설정할 수 있습니다. 또한, 속성을 참조하고 정렬 방향(Asc 또는 Desc)을 지정하는 OrderBy 절을 추가하여 정적 정렬을 적용할 수 있습니다. 동적 정렬을 지원하는 쿼리 메소드를 만들려면 'Paging, Iterating Large Results, Sorting & Limiting'을 참조하십시오. 속성 표현은 관리되는 엔티티의 직접 속성 또는 중첩된 속성을 통해 참조할 수 있습니다. 구분 기호(_)를 사용하여 중첩된 경로를 수동으로 정의할 수 있습니다."
"스프링 데이터에서 사용자 정의 저장소 구현을 어떻게 생성하나요?","스프링 데이터에서 사용자 정의 저장소 구현을 생성하려면, 사용자 정의 기능을 위한 단편 인터페이스와 구현을 정의해야 합니다. 단편 인터페이스 이름은 `CustomizedUserRepository`와 같이 지정하고, 구현 클래스에는 `Impl` 접미사를 붙입니다. 그런 다음 저장소 인터페이스를 단편 인터페이스를 확장하도록 수정합니다. 사용자 정의 구현 클래스는 스프링 데이터에 의존하지 않으며, 일반적인 스프링 빈일 수 있습니다. 또한, 표준 의존성 주입 동작을 사용하여 다른 빈(예: JdbcTemplate)에 대한 참조를 주입하고, 측면에 참여할 수 있습니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/custom-implementations.html)"
"스프링 데이터 저장소 인터페이스에서 여러 단편 인터페이스를 어떻게 사용하나요?","스프링 데이터 저장소 인터페이스에서 여러 단편 인터페이스를 사용하려면, 저장소 인터페이스에서 차례로 단편 인터페이스를 확장하면 됩니다. 이렇게 하면 CRUD 및 사용자 정의 기능이 결합되어 클라이언트에서 사용할 수 있습니다. 저장소는 선언된 순서대로 여러 사용자 정의 구현으로 구성될 수 있습니다. 사용자 정의 구현은 기본 구현 및 저장소 측면보다 우선순위가 높습니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/custom-implementations.html)"
"스프링 데이터 저장소에서 단편 인터페이스를 어떻게 재사용할 수 있나요?","단편 인터페이스를 여러 저장소에서 사용하여 사용자 정의를 여러 저장소에 걸쳐 재사용할 수 있습니다. 먼저 단편 인터페이스와 구현을 정의한 다음, 저장소 인터페이스에서 단편 인터페이스를 확장하면 됩니다. 이렇게 하면 단편 인터페이스와 구현이 여러 저장소에서 재사용될 수 있습니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/custom-implementations.html)"
"스프링 데이터 2.0에서 개별 애그리게이트 인스턴스를 반환하는 리포지토리 CRUD 메서드는 어떤 방식으로 값의 부재 가능성을 나타내나요?","자바 8의 Optional을 사용합니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/null-handling.html)"
"스프링 데이터는 어떤 상황에서 쿼리 메서드에서 null을 반환하나요?","쿼리 결과가 없을 때입니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/null-handling.html)"
"리포지토리 메서드에서 nullability 제약을 표현하기 위해 어떤 스프링 프레임워크의 어노테이션을 사용할 수 있나요?","@NonNullApi, @NonNull, @Nullable 어노테이션을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/null-handling.html)"
"Spring Data의 <repositories /> 요소에서 base-package 속성은 어떤 역할을 하나요?","Spring Data의 <repositories /> 요소에서 base-package 속성은 auto-detection 모드에서 *Repository를 확장하는 리포지토리 인터페이스를 스캔할 패키지를 정의하는 역할을 합니다. 이 속성은 <repositories /> 요소의 가장 중요한 속성입니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/namespace-reference.html) "
"Spring Data의 <repositories /> 요소에서 named-queries-location 속성은 어떤 역할을 하나요?","Spring Data의 <repositories /> 요소에서 named-queries-location 속성은 외부에서 정의된 쿼리를 포함하는 Properties 파일의 위치를 정의하는 역할을 합니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/namespace-reference.html) "
"Spring Data의 <repositories /> 요소에서 query-lookup-strategy 속성은 어떤 역할을 하나요?","Spring Data의 <repositories /> 요소에서 query-lookup-strategy 속성은 파인더 쿼리를 생성하는 데 사용되는 전략을 결정하는 역할을 합니다. 자세한 내용은 'Query Lookup Strategies' 문서를 참조하십시오. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/namespace-reference.html) "
"스프링 데이터 리포지토리에서 쿼리를 표현하는 데 사용되는 일반적 쿼리 메소드 주어 키워드는 무엇인가요?","찾아보세요...By, 읽어보세요...By, 가져보세요...By, 쿼리하세요...By, 검색하세요...By, 스트리밍하세요...By는 일반적으로 리포지토리 타입, 컬렉션 또는 스트림 가능한 하위 타입 또는 Page, GeoResults 또는 기타 저장소별 결과 래퍼와 같은 결과 래퍼를 반환하는 일반적인 쿼리 메소드입니다. findBy... , findMyDomainTypeBy... 또는 추가 키워드와 함께 사용할 수 있습니다. (출처: <https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/query-keywords-reference.html>)"
"스프링 데이터 리포지토리에서 지원되는 쿼리 메소드 술어 키워드는 무엇인가요?","AND, OR, AFTER, BEFORE, CONTAINING, BETWEEN, ENDING_WITH, EXISTS, FALSE, GREATER_THAN, GREATER_THAN_EQUAL, IN, IS, IS_EMPTY, IS_NOT_EMPTY, IS_NOT_NULL, IS_NULL, LESS_THAN, LESS_THAN_EQUAL, LIKE, NEAR, NOT, NOT_IN, NOT_LIKE, REGEX, STARTING_WITH, TRUE, WITHIN은 일반적으로 스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 지원되는 술어 키워드입니다. 그러나 일부 키워드는 특정 저장소에서 지원되지 않을 수 있으므로 지원되는 키워드의 정확한 목록은 저장소별 문서를 참조하십시오. (출처: <https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/query-keywords-reference.html>)"
"스프링 데이터 리포지토리에서 지원되는 쿼리 메소드 술어 수정자는 무엇인가요?","IgnoreCase, IgnoringCase, AllIgnoreCase, AllIgnoringCase, OrderBy...은 일반적으로 스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 지원되는 수정자입니다. IgnoreCase 및 IgnoringCase는 대소문자를 구분하지 않는 비교에 사용되며, AllIgnoreCase 및 AllIgnoringCase는 모든 적합한 속성에 대해 대소문자를 무시합니다. OrderBy...는 정적 정렬 순서를 지정합니다. (출처: <https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/query-keywords-reference.html>)"
"스프링 데이터 리포지토리에서 쿼리 메서드의 결과 타입으로 지원되지 않는 것은 무엇인가요?","일부 스프링 데이터 리포지토리에서 쿼리 메서드의 결과 타입으로 지원되지 않는 타입이 있을 수 있습니다. 정확한 지원되는 결과 타입 목록은 특정 스프링 데이터 모듈의 문서를 참조해야 합니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/query-return-types-reference.html)"
"스프링 데이터 리포지토리에서 @Async 어노테이션과 함께 사용 가능한 Future 타입의 쿼리 메서드 결과 타입은 무엇인가요?","스프링 데이터 리포지토리에서 @Async 어노테이션과 함께 사용 가능한 Future 타입의 쿼리 메서드 결과 타입으로는 Future<T>와 CompletableFuture<T>가 있습니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/query-return-types-reference.html)"
"스프링 데이터 리포지토리에서 쿼리 메서드의 결과 타입으로 List<T>와 유사한 타입이지만, 더 많은 기능을 제공하는 타입은 무엇인가요?","스프링 데이터 리포지토리에서 쿼리 메서드의 결과 타입으로 List<T>와 유사한 타입이지만, 더 많은 기능을 제공하는 타입으로는 Streamable<T>가 있습니다. Streamable<T>는 결과를 스트리밍, 맵핑, 필터링하고, 결과를 연결할 수 있는 메서드를 직접 노출하여 더 유연한 작업을 가능하게 합니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/repositories/query-return-types-reference.html)"
"Ldap Repositories 챕터에서 spring data repositories의 핵심 리포지토리 지원은 어디에서 설명되나요?","Working with Spring Data Repositories(repositories/introduction.html)에서 설명됩니다. (출처: <https://docs.spring.io/spring-data/ldap/reference/3.3/ldap.html>)"
"Ldap repositories를 사용하기 위해 알아야 할 기본 개념은 무엇인가요?","기본 개념에 대한 이해는 Ldap Repositories 챕터의 핵심 리포지토리 지원에서 설명됩니다. (출처: <https://docs.spring.io/spring-data/ldap/reference/3.3/ldap.html>)"
"Ldap repositories에서 Querydsl 지원을 사용하려면 어떻게 구성해야 하나요?","Querydsl 지원은 Ldap Repositories 챕터의 Querydsl 지원 섹션에서 설명됩니다. (출처: <https://docs.spring.io/spring-data/ldap/reference/3.3/ldap.html>)"
"Spring Data LDAP을 구성하는 방법은 무엇인가요?","Spring Data LDAP을 구성하는 방법은 XML 구성에서 <data-ldap:repositories> 태그를 사용하거나, Java 구성에서 @EnableLdapRepositories 어노테이션을 사용하는 것입니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-data/ldap/reference/3.3/ldap/configuration.html"
"Spring Data LDAP에서 자동 생성된 리포지토리에서 LdapQuery 매개변수를 사용하려면 어떻게 해야 하나요?","자동 생성된 리포지토리에서 LdapQuery 매개변수를 사용하려면 인터페이스가 CrudRepository 대신 LdapRepository를 확장해야 합니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-data/ldap/reference/3.3/ldap/configuration.html"
"Spring LDAP 리포지토리에서 ODM 어노테이션을 사용해야 하는 이유는 무엇인가요?","Spring LDAP 리포지토리에서 ODM 어노테이션을 사용해야 하는 이유는 모든 ODM 관리 클래스가 ID로 Distinguished Name을 가져야 하기 때문입니다. Spring LDAP 리포지토리에서 사용되는 ID 타입 매개변수는 javax.naming.Name이어야 합니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-data/ldap/reference/3.3/ldap/configuration.html"
"Spring Data LDAP에서 도메인 엔티티에 접근하는 방법은 무엇인가요?","Spring Data LDAP에서 도메인 엔티티에 접근하려면, LDAP 호환 디렉토리에 저장된 도메인 엔티티에 액세스하기 위해 정교한 리포지토리 지원을 사용할 수 있습니다. 이를 위해 리포지토리에 대한 인터페이스를 생성하고, CrudRepository 인터페이스를 확장하여 CRUD 작업 및 엔티티에 대한 액세스 방법을 제공합니다. 그런 다음, 리포지토리 인스턴스를 클라이언트에 의존성 주입하여 사용할 수 있습니다."
"Spring Data LDAP에서 리포지토리 인터페이스를 생성하는 방법은 무엇인가요?","Spring Data LDAP에서 리포지토리 인터페이스를 생성하려면, CrudRepository 인터페이스를 확장하고, 해당 리포지토리가 관리하는 도메인 유형을 제네릭 매개변수로 지정하면 됩니다. 이렇게 생성된 인터페이스는 CRUD 작업 및 엔티티에 대한 액세스 방법을 제공합니다. 또한, 추가적으로 사용자 정의 쿼리를 정의할 수 있습니다."
"Spring Data LDAP에서 테스트 케이스에서 리포지토리 인스턴스를 액세스하는 방법은 무엇인가요?","Spring Data LDAP에서 테스트 케이스에서 리포지토리 인스턴스를 액세스하려면, 리포지토리 인터페이스를 CrudRepository 인터페이스를 확장하고, @Autowired 어노테이션을 사용하여 리포지토리 인스턴스를 테스트 케이스에 의존성 주입하면 됩니다. 이렇게 생성된 리포지토리 인스턴스를 사용하여 테스트 케이스에서 데이터 저장소에 액세스하고 쿼리를 실행할 수 있습니다."
"Query methods란 무엇이며, 어떻게 정의되나요?","Query methods는 리포지토리 인터페이스에서 메소드를 선언하여 정의됩니다. 메소드 이름은 쿼리 표현을 파싱하여 제약 조건을 연결할 수 있는 키워드로 파싱됩니다. 이를 통해 LDAP 디렉토리에 대한 데이터 액세스 작업을 트리거합니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/ldap/query-methods.html)"
"Query methods에서 사용할 수 있는 키워드는 어떤 것들이 있나요?","Query methods에서 사용할 수 있는 키워드로는 LessThanEqual, GreaterThanEqual, IsNotNull, NotNull, IsNull, Null, Like, NotLike, StartingWith, EndingWith, Containing 등이 있습니다. 이러한 키워드는 쿼리 표현을 파싱하여 LDAP 디렉토리에서 데이터를 검색하는 데 사용됩니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/ldap/query-methods.html)"
"메소드 이름에서 파싱된 쿼리 표현은 어떻게 쿼리 표현으로 변환되나요?","메소드 이름에서 파싱된 쿼리 표현은 LDAP 디렉토리에서 검색할 데이터를 정의하는 제약 조건으로 변환됩니다. 쿼리 표현은 (&(objectclass=person)(lastname=lastname)) 또는 (&(objectclass=person)(lastname=lastname)(firstname=firstname))와 같은 형식으로 변환됩니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/ldap/query-methods.html)"
"Querydsl Support는 무엇인가요?","Spring LDAP ODM 어노테이션을 기반으로 Querydsl 클래스를 생성하는 Annotation Processor인 LdapAnnotationProcessor와 Querydsl 쿼리를 코드에서 빌드하고 실행하는 Query 구현체인 QueryDslLdapQuery, 그리고 Querydsl predicates를 위한 Spring Data repository 지원이 포함되어 있습니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/ldap/querydsl.html)"
"LdapAnnotationProcessor는 어떤 역할을 하나요?","Spring LDAP ODM 어노테이션을 기반으로 Querydsl 클래스를 생성하는 Annotation Processor입니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/ldap/querydsl.html)"
"Querydsl predicates를 위한 Spring Data repository 지원에는 어떤 내용이 포함되나요?","QueryDslPredicateExecutor에는 적절한 매개변수를 가진 여러 추가 메서드가 포함되어 있습니다. 이 인터페이스를 확장하여(LdapRepository와 함께) 리포지토리에 이 지원을 포함시킬 수 있습니다. (출처: https://docs.spring.io/spring-data/ldap/reference/3.3/ldap/querydsl.html)"
"CDI 환경에서 Spring Data LDAP을 사용하려면 어떻게 해야 하나요?","Spring Data LDAP은 CDI 확장 기능을 포함하고 있으며, 이 기능을 사용하면 CDI 환경에서 저장소 추상화를 사용할 수 있습니다. 이 확장 기능은 JAR 파일의 일부이며, Spring Data LDAP JAR를 클래스패스에 드롭하여 활성화할 수 있습니다. 그런 다음 LdapTemplateProducer 클래스를 사용하여 CDI Producer를 구현하여 인프라를 설정할 수 있습니다. Spring Data LDAP CDI 확장 기능은 LdapTemplate을 CDI 빈으로 가져와 컨테이너에서 저장소 유형의 빈을 요청할 때마다 Spring Data 저장소의 프록시를 생성합니다. 따라서 Spring Data 저장소의 인스턴스를 가져오는 것은 주입된 속성을 선언하는 문제입니다."
"CDI 환경에서의 Spring Data LDAP JAR의 역할은 무엇인가요?","Spring Data LDAP JAR는 CDI 확장 기능을 포함하고 있으며, 이 기능을 사용하면 CDI 환경에서 저장소 추상화를 사용할 수 있습니다. 이 JAR를 클래스패스에 드롭하여 확장 기능을 활성화할 수 있습니다. JAR는 또한 LdapTemplateProducer 클래스를 사용하여 CDI Producer를 구현하여 인프라를 설정하는 데 사용됩니다. Spring Data LDAP CDI 확장 기능은 LdapTemplate을 CDI 빈으로 가져와 컨테이너에서 저장소 유형의 빈을 요청할 때마다 Spring Data 저장소의 프록시를 생성합니다."
"CDI 환경에서의 LdapTemplateProducer 클래스의 역할은 무엇인가요?","LdapTemplateProducer 클래스는 CDI 환경에서의 Spring Data LDAP 인프라를 설정하는 데 사용됩니다. 이 클래스는 @Produces 및 @ApplicationScoped 어노테이션을 사용하여 LdapOperations 클래스의 인스턴스를 반환하는 메소드를 생성합니다. 이 인스턴스는 컨텍스트 소스를 사용하여 LdapTemplate을 생성하는 데 사용됩니다. CDI 환경에서의 Spring Data LDAP CDI 확장 기능은 LdapTemplate을 CDI 빈으로 가져와 컨테이너에서 저장소 유형의 빈을 요청할 때마다 Spring Data 저장소의 프록시를 생성합니다."
"Spring Data MongoDB는 어떤 데이터베이스에 대한 지원을 제공하나요?","Spring Data MongoDB는 MongoDB 데이터베이스에 대한 지원을 제공합니다. (출처: <https://docs.spring.io/spring-data/mongodb/reference/4.3/index.html>)"
"Spring Data MongoDB에서 개발자들이 익숙한 개념 중 일부는 무엇인가요?","Spring Data MongoDB는 템플릿 클래스를 사용한 핵심 API 사용 및 경량 리포지토리 스타일의 데이터 액세스와 같은 익숙한 Spring 개념을 활용하여 개발자들이 일관된 프로그래밍 모델로 애플리케이션을 쉽게 개발할 수 있도록 도와줍니다. (출처: <https://docs.spring.io/spring-data/mongodb/reference/4.3/index.html>)"
"Spring Data MongoDB의 문서는 어디에서 찾을 수 있나요?","Spring Data MongoDB의 문서는 공식 웹사이트에서 확인할 수 있으며, 추가 정보로는 Github의 Spring Data Commons Wiki에서 새로운 기능, 업그레이드 노트, 지원되는 버전 및 크로스 버전 정보를 확인할 수 있습니다. (출처: <https://docs.spring.io/spring-data/mongodb/reference/4.3/index.html> 및 <https://github.com/spring-projects/spring-data-commons/wiki>)"
"스프링 데이터 업그레이드 가이드는 어디서 찾을 수 있나요?","스프링 데이터 업그레이드 가이드는 프로젝트 위키(https://github.com/spring-projects/spring-data-commons/wiki)에서 찾을 수 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/commons/upgrade.html)"
"스프링 데이터 업그레이드 중 건너뛴 버전에 대한 정보를 어떻게 확인할 수 있나요?","여러 버전을 건너뛰고 업그레이드하는 경우, 건너뛴 버전의 릴리스 노트를 검토하는 것이 좋습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/commons/upgrade.html)"
"스프링 데이터의 특정 버전으로 업그레이드하기 위한 구체적인 단계를 어떻게 찾을 수 있나요?","특정 버전으로 업그레이드하기 위한 단계는 릴리스 노트 섹션(https://github.com/spring-projects/spring-data-commons/wiki#release-notes)의 링크를 따라가서 해당 버전으로 업그레이드하는 업그레이드를 위한 지침을 찾을 수 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/commons/upgrade.html)"
"Spring Data MongoDB 2.x에서 3.x로 업그레이드하는 방법은 무엇인가요?","Spring Data MongoDB 2.x에서 3.x로 업그레이드하려면 Migration Guide from 2.x to 3.x(migration-guide/migration-guide-2.x-to-3.x.html) 문서를 참조하세요. 이 문서는 업그레이드에 필요한 자세한 정보를 제공합니다. (Source: <https://docs.spring.io/spring-data/mongodb/reference/4.3/migration-guides.html>)"
"Spring Data MongoDB 3.x에서 4.x로 업그레이드하는 방법은 무엇인가요?","Spring Data MongoDB 3.x에서 4.x로 업그레이드하려면 Migration Guide from 3.x to 4.x(migration-guide/migration-guide-3.x-to-4.x.html) 문서를 참조하세요. 이 문서는 업그레이드에 필요한 자세한 정보를 제공합니다. (Source: <https://docs.spring.io/spring-data/mongodb/reference/4.3/migration-guides.html>)"
"Spring Data MongoDB의 버전에 따른 업그레이드 가이드를 어디에서 찾을 수 있나요?","Spring Data MongoDB의 버전에 따른 업그레이드 가이드는 Migration Guides 섹션에서 찾을 수 있습니다. 이 섹션에는 2.x에서 3.x로의 업그레이드 가이드(migration-guide/migration-guide-2.x-to-3.x.html)와 3.x에서 4.x로의 업그레이드 가이드(migration-guide/migration-guide-3.x-to-4.x.html)가 포함되어 있습니다. (Source: <https://docs.spring.io/spring-data/mongodb/reference/4.3/migration-guides.html>)"
"Spring Data MongoDB 3.x에서 Spring Data MongoDB 2.x로 마이그레이션하는 방법은 무엇인가요?","공식 마이그레이션 가이드(https://docs.spring.io/spring-data/mongodb/reference/4.3/migration-guide/migration-guide-2.x-to-3.x.html)에 따르면, MongoDB Java Driver 4.x를 사용해야 하며, 일부 의존성 및 시그니처 변경 사항이 있습니다. 또한, AbstractMongoConfiguration 대신 AbstractMongoClientConfiguration을 사용해야 하며, configuration XML에서 MongoClient에 대한 연결 문자열을 업데이트해야 할 수도 있습니다."
"Spring Data MongoDB 3.x에서 com.mongodb.DBObject 대신 어떤 클래스를 사용해야 하나요?","Spring Data MongoDB 3.x에서 com.mongodb.DBObject는 더 이상 지원되지 않습니다. 대신 org.bson.Document를 사용해야 합니다."
"Spring Data MongoDB 3.x에서 MongoTemplate에서 어떤 시그니처 변경 사항이 있나요?","Spring Data MongoDB 3.x에서 MongoTemplate은 더 이상 com.mongodb.MongoClient 및 com.mongodb.MongoClientOptions를 지원하지 않습니다. 대신 com.mongodb.client.MongoClient 및 com.mongodb.MongoClientSettings를 사용해야 합니다."
"Spring Data MongoDB의 3.x에서 4.x로의 마이그레이션에 필요한 MongoDB Java Driver 버전은 무엇인가요?","Spring Data MongoDB 4.x는 MongoDB Java Driver 4.8.x를 필요로 합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/migration-guide/migration-guide-3.x-to-4.x.html)"
"Spring Data MongoDB의 3.x에서 4.x로의 마이그레이션 시, MongoDB Java Driver 버전에 대한 자세한 정보는 어디에서 확인할 수 있나요?","MongoDB Documentation(https://www.mongodb.com/docs/drivers/java/sync/current/upgrade/)에서 자세한 정보를 확인할 수 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/migration-guide/migration-guide-3.x-to-4.x.html)"
"Spring Data MongoDB의 4.x 버전에서 필요한 MongoDB Java Driver 버전에 대한 문서 링크는 무엇인가요?","MongoDB Documentation(https://www.mongodb.com/docs/drivers/java/sync/current/upgrade/)에서 확인할 수 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/migration-guide/migration-guide-3.x-to-4.x.html)"
"Spring Data의 MongoDB 지원에서 어떤 기능을 제공하나요?","Spring Data의 MongoDB 지원은 Spring 구성 지원, MongoTemplate 도우미 클래스, 통합 객체 매핑, 예외 번역, 풍부한 객체 매핑, 주석 기반 매핑 메타데이터, 지속성 및 매핑 라이프사이클 이벤트, Java 기반 쿼리, 기준 및 업데이트 DSL, 리포지토리 인터페이스의 자동 구현, 쿼리DSL 통합, 다중 문서 트랜잭션, 지리 공간 통합 등을 제공합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb.html)"
"Spring Data의 MongoDB 지원을 사용하여 MongoDB에 연결하는 방법은 무엇인가요?","Spring Data의 MongoDB 지원을 사용하여 MongoDB에 연결하려면 Java 기반 @Configuration 클래스 또는 Mongo 드라이버 인스턴스 및 리플리카 세트를 위한 XML 네임스페이스를 사용하여 Spring 구성을 설정할 수 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb.html)"
"Spring Data의 MongoDB 지원에서 MongoTemplate 클래스를 사용하는 이유는 무엇인가요?","Spring Data의 MongoDB 지원에서 MongoTemplate 클래스를 사용하는 이유는 카운터를 증가시키거나 임시 CRUD 작업과 같은 기능에 액세스하고 저수준 API 아티팩트, 예를 들어 com.mongodb.client.MongoDatabase와 직접 통신하는 콜백 메서드를 제공하기 때문입니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb.html)"
"Spring Data MongoDB 4.x 바이너리를 사용하려면 어떤 JDK 버전이 필요한가요?","JDK level 17 이상이 필요합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/preface.html)"
"Spring Data MongoDB 4.x와 호환되는 MongoDB 버전은 무엇인가요?","MongoDB 4.x 이상이 필요합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/preface.html)"
"Spring Data MongoDB 4.x와 호환되는 MongoDB Java Driver 버전은 무엇인가요?","4.x 또는 5.x 버전이 필요합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/preface.html)"
"스프링 데이터 몽고디비를 시작하기 위해 권장되는 방법은 무엇인가요?","start.spring.io(https://start.spring.io/#!type=maven-project&dependencies=data-mongodb)를 통해 스프링 기반 프로젝트를 생성하거나 Spring Tools(https://spring.io/tools)에서 스프링 프로젝트를 생성하는 것이 권장됩니다. (출처: {https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/getting-started.html})"
"라이브러리의 동작 방식을 이해하기 위해 사용할 수 있는 예제 코드는 어디에 있나요?","GitHub spring-data-examples 저장소(https://github.com/spring-projects/spring-data-examples)에는 다운로드하여 사용할 수 있는 여러 예제가 있습니다. (출처: {https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/getting-started.html})"
"몽고디비를 실행하기 위해 필요한 단계는 무엇인가요?","먼저, MongoDB 서버를 실행해야 합니다. MongoDB Quick Start 가이드(https://docs.mongodb.org/manual/core/introduction/)를 참조하여 MongoDB 인스턴스를 시작하는 방법에 대한 설명을 확인할 수 있습니다. 설치 후, MongoDB를 시작하는 것은 일반적으로 다음 명령어를 실행하는 것입니다: /bin/mongod. (출처: {https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/getting-started.html})"
"MongoDB를 Spring과 연동할 때, IoC 컨테이너를 사용하여 MongoClient 객체를 생성하는 방법은 무엇인가요?","MongoDB와 Spring을 연동할 때, IoC 컨테이너를 사용하여 MongoClient 객체를 생성하는 방법은 Java 기반 빈 메타데이터 또는 XML 기반 빈 메타데이터를 사용하는 것입니다."
"MongoClient를 Bean으로 등록하는 방법은 무엇인가요?","MongoClient를 Bean으로 등록하는 방법은 Java 기반 빈 메타데이터 또는 XML 기반 빈 메타데이터를 사용하는 것입니다. Java 기반 빈 메타데이터를 사용하는 방법을 모르는 경우, Spring 컨테이너를 구성하는 방법에 대한 자세한 내용은 다음 참조 문서를 참조하십시오: https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html#new-java-configuration 및 https://docs.spring.io/spring-framework/docs/6.1.13/reference/html/core.html#beans-java-instantiating-container."
"MongoDatabaseFactory 인터페이스를 사용하여 MongoDB 데이터베이스 인스턴스에 연결하는 방법은 무엇인가요?","MongoDatabaseFactory 인터페이스를 사용하여 MongoDB 데이터베이스 인스턴스에 연결하려면 MongoDatabaseFactory 인터페이스를 구현하는 클래스를 작성해야 합니다. 이 인터페이스는 데이터베이스의 MongoDatabase 객체에 액세스하는 데 필요한 기능을 제공합니다. MongoDatabaseFactory 인터페이스를 사용하여 데이터베이스에 연결하려면 MongoClient 객체를 사용하여 SimpleMongoClientDatabaseFactory 또는 SimpleReactiveMongoDatabaseFactory 클래스를 인스턴스화해야 합니다. 그런 다음 MongoDatabaseFactory 인터페이스의 getDatabase() 메서드를 사용하여 MongoDatabase 객체에 액세스할 수 있습니다."
"MongoTemplate과 ReactiveMongoTemplate은 어디에서 찾을 수 있나요?","org.springframework.data.mongodb.core 패키지에서 찾을 수 있습니다."
"MongoTemplate은 어떻게 데이터베이스와 상호작용하는 풍부한 기능을 제공하나요?","MongoOperations 인터페이스를 구현하여 가능한 한 MongoDB 드라이버 Collection 객체의 메서드와 동일한 이름을 가진 메서드를 제공합니다. 이를 통해 개발자는 기본 MongoDB 드라이버와 MongoOperations 간의 전환을 쉽게 할 수 있습니다."
"MongoTemplate의 Execute 콜백 메서드는 어떤 용도로 사용되나요?","MongoTemplate의 Execute 콜백 메서드는 MongoDB 드라이버 API에 직접 액세스해야 할 때 사용됩니다. 이 메서드는 MongoCollection 또는 MongoDatabase 객체에 대한 참조를 제공합니다."
"MongoTemplate 또는 ReactiveMongoTemplate을 생성할 때, 어떤 오버로드된 생성자를 사용할 수 있나요?","MongoTemplate(MongoClient mongo, String databaseName) : MongoClient 객체와 기본 데이터베이스 이름을 전달하여 작동합니다. MongoTemplate(MongoDatabaseFactory mongoDbFactory) : MongoDbFactory 객체를 전달하여 MongoClient 객체, 데이터베이스 이름 및 사용자 이름과 암호를 캡슐화합니다. MongoTemplate(MongoDatabaseFactory mongoDbFactory, MongoConverter mongoConverter) : 매핑에 사용할 MongoConverter를 추가로 전달합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/template-config.html)"
"MongoTemplate 또는 ReactiveMongoTemplate을 생성할 때, 어떤 추가 속성을 설정할 수 있나요?","MongoTemplate / ReactiveMongoTemplate을 생성할 때 설정할 수 있는 추가 속성에는 기본 Read Preference, WriteResultChecking Policy, WriteConcern, ReadPreference 등이 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/template-config.html)"
"Spring Data MongoDB에서 EntityCallbacks를 구성하려면 어떻게 해야 하나요?","EntityCallbacks는 템플릿 API를 통해 (자동 구성되지 않은 경우) 설정할 수 있습니다. Imperative 스타일에서는 MongoOperations 빈에 setEntityCallbacks 메서드를 사용하고, Reactive 스타일에서는 ReactiveMongoOperations 빈에 setEntityCallbacks 메서드를 사용합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/template-config.html)"
"MongoTemplate과 ReactiveMongoTemplate을 사용하여 문서를 저장, 업데이트 및 삭제하는 방법은 무엇인가요?","MongoTemplate과 ReactiveMongoTemplate을 사용하여 도메인 객체를 저장, 업데이트 및 삭제하고 해당 객체를 MongoDB에 저장된 문서로 매핑할 수 있습니다. 명령형 API와 반응형 API의 API 시그니처는 주로 반환 유형만 다릅니다. 동기 API는 void, 단일 개체 및 목록을 사용하는 반면, 반응형 API는 Mono<Void>, Mono<Object> 및 Flux로 구성됩니다. Person 클래스를 사용하여 객체를 저장, 업데이트 및 삭제할 수 있습니다. 예를 들어, insert 메서드를 사용하여 객체를 데이터베이스에 처음 저장하고, update 메서드를 사용하여 객체를 업데이트하고, remove 메서드를 사용하여 객체를 삭제할 수 있습니다. MongoTemplate의 로그 출력을 확인하려면 샘플 코드를 참조하십시오."
"MongoDB에서 _id 필드는 어떻게 처리되나요?","MongoDB는 모든 문서에 대해 _id 필드를 필요로 합니다. MappingMongoConverter를 사용하면 특정 규칙이 적용되어 Java 클래스의 속성이 _id 필드로 매핑됩니다. @Id로 주석이 달린 속성 또는 필드는 _id 필드로 매핑됩니다. 주석이 없는 id라는 이름의 속성 또는 필드는 _id 필드로 매핑됩니다. MappingMongoConverter를 사용할 때 _id 문서 필드로 매핑되는 속성에 대해 어떤 유형 변환이 수행되는지 알아보고, _id 필드의 유형 변환 규칙 및 _id 필드 매핑을 더 잘 제어하기 위해 @MongoId를 사용하는 방법을 확인하려면 문서를 참조하십시오."
"MongoTemplate을 사용하여 여러 개의 객체를 일괄 삽입하는 방법은 무엇인가요?","MongoTemplate은 여러 개의 객체를 삽입하기 위한 여러 메서드를 제공합니다. insertAll 메서드는 첫 번째 매개변수로 객체 컬렉션을 사용합니다. insertBatch 메서드는 MongoCollection의 BulkWriteResult 및 Mono<BulkWriteResult> 메서드를 사용하여 일괄 삽입 작업을 수행합니다. 문서를 업데이트하기 위해 updateFirst 메서드를 사용하여 쿼리 문서에 일치하는 첫 번째 문서를 업데이트하거나 updateMulti 메서드를 사용하여 쿼리 문서에 일치하는 모든 문서를 업데이트할 수 있습니다."
"Criteria 클래스의 andOperator 메서드는 어떤 역할을 하나요?","Criteria 클래스의 andOperator 메서드는 $and 연산자를 사용하여 제공된 모든 Criteria에 대한 and 쿼리를 생성합니다. MongoDB 2.0 이상 버전에서 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/template-query-operations.html)"
"MongoTemplate을 사용하여 컬렉션의 모든 문서를 쿼리하려면 어떻게 해야 하나요?","MongoTemplate을 사용하여 컬렉션의 모든 문서를 쿼리하려면 query 메서드를 사용하여 Query 객체를 생성하고, 일치하는 문서를 반환하는 Flux 또는 List를 사용할 수 있습니다. Criteria 및 Query 클래스를 사용하여 쿼리를 표현하고, Query 및 Criteria 클래스는 네이티브 MongoDB 연산자 이름과 일치하는 메서드 이름을 가지고 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/template-query-operations.html)"
"Query 클래스의 cursorBatchSize 메서드는 어떤 역할을 하나요?","Query 클래스의 cursorBatchSize 메서드는 각 응답 배치에 반환할 문서 수를 정의합니다. 이 메서드를 사용하여 쿼리 성능을 향상시키고 메모리 소비를 줄일 수 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/template-query-operations.html)"
"Spring Data MongoDB에서 집계 프레임워크란 무엇인가요?","Spring Data MongoDB는 MongoDB 버전 2.2부터 도입된 집계 프레임워크를 지원합니다. 집계 프레임워크는 복잡한 쿼리 및 데이터 변환을 수행하기 위한 강력한 도구입니다. Spring Data MongoDB는 Aggregation과 AggregationResults를 주요 추상화로 사용하여 집계 프레임워크를 구현합니다. Aggregation은 집계 파이프라인 지침을 설명하고, AggregationResults는 집계 작업의 결과를 저장합니다."
"Spring Data MongoDB에서 프로젝션 표현식이란 무엇인가요?","프로젝션 표현식은 특정 집계 단계의 결과인 필드를 정의하는 데 사용됩니다. 프로젝션 표현식은 Aggregation 클래스의 project 메서드를 통해 정의할 수 있으며, 문자열 목록이나 집계 프레임워크 Fields 객체를 전달하여 정의할 수 있습니다. 프로젝션은 fluent API를 사용하여 추가 필드로 확장할 수 있으며, 필드 별칭은 as 메서드를 사용하여 할당할 수 있습니다. 추가 프로젝션 필드는 이전에 포함된 필드 또는 별칭(새로운 필드 및 별칭 포함)의 필드 이름에만 유효합니다."
"Spring Data MongoDB에서 Faceted Classification이란 무엇인가요?","Faceted Classification은 MongoDB의 집계 프레임워크를 사용하여 문서를 버킷으로 분류하는 것입니다. Faceted Classification은 문서를 여러 차원(또는 패싯)으로 특성화할 수 있는 다중 집계 파이프라인을 생성하여 데이터를 탐색하고 분석하는 데 도움이 됩니다. Faceted Classification의 일반적인 구현은 온라인 판매업체에서 제품 가격, 제조사, 크기 등의 필터를 적용하여 검색 결과를 좁히는 방법입니다."
"Spring Data MongoDB에서 GridFS를 지원하는 방법은 무엇인가요?","Spring Data MongoDB는 GridFsOperations와 ReactiveGridFsOperations 인터페이스와 GridFsTemplate 및 ReactiveGridFsTemplate 클래스를 제공하여 MongoDB의 GridFS 파일 시스템과 상호 작용할 수 있습니다. 이러한 클래스는 MongoDatabaseFactory 및 MongoConverter를 사용하여 설정할 수 있습니다."
"GridFsTemplate 또는 ReactiveGridFsTemplate을 사용하여 GridFS에 파일을 저장하는 방법은 무엇인가요?","GridFsTemplate 또는 ReactiveGridFsTemplate을 사용하여 GridFS에 파일을 저장하려면 store(…) 메서드를 호출하고 InputStream 또는 Publisher<DataBuffer>, 파일 이름 및 (선택적으로) 파일 메타데이터를 전달하면 됩니다. 메타데이터는 GridFsTemplate 또는 ReactiveGridFsTemplate에 구성된 MongoConverter에 의해 직렬화됩니다. MongoDB의 드라이버는 이진 스트림을 교환하기 위해 AsyncInputStream 및 AsyncOutputStream 인터페이스를 사용하며, Spring Data MongoDB는 이러한 인터페이스를 Publisher<DataBuffer>로 변환합니다."
"GridFsTemplate 또는 ReactiveGridFsTemplate을 사용하여 GridFS에서 파일을 쿼리하는 방법은 무엇인가요?","GridFsTemplate 또는 ReactiveGridFsTemplate을 사용하여 GridFS에서 파일을 쿼리하려면 find(…) 메서드를 호출하고 Query를 전달하면 됩니다. GridFsCriteria 도우미 클래스를 사용하여 쿼리를 정의할 수 있으며, 이는 파일 이름을 기준으로 하는 기본 메타데이터 필드 또는 사용자 지정 필드를 캡슐화하는 정적 팩토리 메서드를 제공합니다. MongoDB는 GridFS에서 파일을 검색할 때 정렬 기준을 정의하는 것을 지원하지 않으므로 쿼리에 정의된 정렬 기준은 무시됩니다. 또는 ResourcePatternResolver 인터페이스에 의해 도입된 메서드를 사용하여 Ant 경로를 전달하여 해당 패턴과 일치하는 파일을 검색할 수 있습니다."
"Spring Data MongoDB에서 객체 매핑을 위한 기본 제공되는 변환기는 무엇인가요?","MappingMongoConverter는 객체 매핑을 위한 풍부한 변환 지원을 제공합니다. 이 변환기는 도메인 객체를 MongoDB 문서로 매핑하기 위한 전체 기능 세트를 제공하는 메타데이터 모델을 보유합니다."
"Spring Data MongoDB에서 객체 매핑에 대한 기본 원리는 무엇인가요?","Spring Data 객체 매핑의 핵심 책임은 도메인 객체의 인스턴스를 생성하고 저장소 네이티브 데이터 구조를 해당 객체에 매핑하는 것입니다. 이를 위해 인스턴스 생성 및 필드 및 속성 액세스와 같은 두 가지 기본 단계가 필요합니다."
"Spring Data MongoDB에서 객체 생성은 어떻게 이루어지나요?","Spring Data는 지속성 있는 엔티티의 생성자를 자동으로 감지하여 해당 유형의 객체를 구체화합니다. 해결 알고리즘은 @PersistenceCreator로 주석이 달린 정적 팩토리 메서드가 하나 있는 경우 해당 메서드를 사용하고, 생성자가 하나 있는 경우 해당 생성자를 사용하며, @PersistenceCreator로 주석이 달린 생성자가 하나 있는 경우 해당 생성자를 사용합니다. Java Record인 경우 기본 생성자가 사용됩니다. 인수가 없는 생성자가 있는 경우 해당 생성자가 사용됩니다. 다른 생성자는 무시됩니다."
"MongoDB의 JSON Schema 유효성 검사는 언제부터 지원되나요?","MongoDB의 JSON Schema 유효성 검사는 3.6 버전부터 지원됩니다. (출처: https://docs.mongodb.com/manual/core/schema-validation/#json-schema)"
"컬렉션을 생성할 때 JSON 스키마를 정의하는 것은 어떤 방식으로 이루어지나요?","컬렉션을 생성할 때 JSON 스키마를 정의하는 것은 스키마 자체와 유효성 검사 작업 및 수준을 지정하여 이루어집니다. (출처: https://docs.mongodb.com/manual/core/schema-validation/#json-schema)"
"JSON 스키마 문서에서 'required' 속성은 어떤 역할을 하나요?","JSON 스키마 문서에서 'required' 속성은 문서에서 필수적으로 포함되어야 하는 속성을 설명하는 속성입니다. (출처: https://docs.mongodb.com/manual/reference/operator/query/jsonSchema/#available-keywords)"
"스프링 컨버터를 사용하여 String을 Email 객체로 변환하는 방법은 무엇인가요?","스프링 컨버터를 사용하여 String을 Email 객체로 변환하려면, Converter<String, Email> 인터페이스를 구현하고, @ReadingConverter 어노테이션을 사용하여 변환기를 등록하면 됩니다. 예를 들어, 다음과 같이 구현할 수 있습니다:

```java
@ReadingConverter
public class EmailReadConverter implements Converter<String, Email> {
    public Email convert(String source) {
        return Email.valueOf(source);
    }
}
```"
"스프링 컨버터를 사용하여 Person 객체를 Document로 변환하는 방법은 무엇인가요?","스프링 컨버터를 사용하여 Person 객체를 Document로 변환하려면, Converter<Person, Document> 인터페이스를 구현하고, @WritingConverter 어노테이션을 사용하여 변환기를 등록하면 됩니다. 예를 들어, 다음과 같이 구현할 수 있습니다:

```java
import org.springframework.core.convert.converter.Converter;
import org.bson.Document;

public class PersonWriteConverter implements Converter<Person, Document> {
    public Document convert(Person source) {
        Document document = new Document();
        document.put('_id', source.getId());
        document.put('name', source.getFirstName());
        document.put('age', source.getAge());
        return document;
    }
}
```"
"스프링 컨버터를 사용하여 Document를 Person 객체로 변환하는 방법은 무엇인가요?","스프링 컨버터를 사용하여 Document를 Person 객체로 변환하려면, Converter<Document, Person> 인터페이스를 구현하고, @ReadingConverter 어노테이션을 사용하여 변환기를 등록하면 됩니다. 예를 들어, 다음과 같이 구현할 수 있습니다:

```java
public class PersonReadConverter implements Converter<Document, Person> {
    public Person convert(Document source) {
        Person p = new Person((ObjectId) source.get('_id'), (String) source.get('name'));
        p.setAge((Integer) source.get('age'));
        return p;
    }
}
```"
"스프링 데이터 몽고DB에서 속성 기반 변환기를 사용하는 목적은 무엇인가요?","스프링 데이터 몽고DB에서 속성 기반 변환기를 사용하는 목적은 특정 유형의 변환 및 표현에 영향을 미치는 type-based conversion의 한계를 극복하기 위함입니다. 속성 기반 변환기를 사용하면 특정 유형의 특정 값 또는 속성만 변환을 고려해야 할 때 유용합니다. 속성 기반 변환기는 @ValueConverter 어노테이션을 통해 선언적으로 또는 PropertyValueConverter를 등록하여 프로그래밍 방식으로 속성별로 변환 규칙을 구성할 수 있습니다."
"스프링 데이터 몽고DB에서 PropertyValueConverter를 사용하는 방법은 무엇인가요?","스프링 데이터 몽고DB에서 PropertyValueConverter를 사용하는 방법은 @ValueConverter 어노테이션을 사용하여 속성에 변환기 유형을 정의하는 것입니다. 또는 PropertyValueConverterRegistrar를 사용하여 엔티티 모델 내의 속성에 대한 PropertyValueConverter 인스턴스를 프로그래밍 방식으로 등록할 수 있습니다. PropertyValueConverterRegistrar를 사용하면 엔티티 모델을 주석 처리하지 않고도 속성별로 변환기를 등록할 수 있습니다."
"스프링 데이터 몽고DB에서 PropertyValueConverter를 사용하는 장점은 무엇인가요?","스프링 데이터 몽고DB에서 PropertyValueConverter를 사용하는 장점은 특정 유형의 특정 값 또는 속성에 대한 변환 규칙을 구성할 수 있다는 것입니다. 이를 통해 대상 저장소 내에서 특정 값 또는 속성에 대한 변환 및 표현을 제어할 수 있습니다. 또한, PropertyValueConverter를 사용하면 읽기 및 쓰기 메서드를 제공하고 추가 정보를 제공하는 ValueConversionContext를 사용할 수 있습니다. PropertyValueConverter를 사용하면 필요한 경우 여러 인스턴스를 연결하거나 장식할 수도 있습니다."
"스프링 데이터 몽고DB에서 Unwrapped 엔티티란 무엇이고, 어떻게 사용하는 건가요?","Unwrapped 엔티티는 Java 도메인 모델에서 속성이 부모 MongoDB 문서에 펼쳐진 value 객체를 설계하는 데 사용됩니다. 이를 위해 @Unwrapped 어노테이션을 사용하여 매핑할 수 있습니다. 예를 들어, User.name이 @Unwrapped로 어노테이션된 다음 도메인 모델을 고려해보세요. @Unwrapped 어노테이션은 UserName의 모든 속성이 name 속성을 소유하는 사용자 문서로 펼쳐져야 함을 나타냅니다."
"스프링 데이터 몽고DB에서 unwrapped 객체의 필드 이름은 어떻게 지정되나요?","unwrapped 객체의 필드 이름은 @Unwrapped 어노테이션의 선택적 prefix 속성을 사용하여 지정할 수 있습니다. 이렇게 하면 선택된 접두사가 unwrapped 객체의 각 속성 또는 @Field('…') 이름 앞에 추가됩니다. 여러 속성이 동일한 필드 이름으로 렌더링되는 경우 값이 서로 덮어쓰여집니다."
"스프링 데이터 몽고DB에서 unwrapped 객체를 사용하여 쿼리, 정렬 및 프로젝션을 어떻게 수행하나요?","unwrapped 속성에 대한 쿼리 정의는 도메인 유형에 대해 제공된 Criteria가 일치하므로 유형 및 필드 수준에서 가능합니다. 접두사 및 사용자 지정 필드 이름은 실제 쿼리를 렌더링할 때 고려됩니다. unwrapped 객체 자체를 정렬 기준으로 사용하는 것은 예측할 수 없는 순서로 모든 필드를 포함하며 부정확한 순서를 초래할 수 있습니다. unwrapped 객체의 필드는 전체 또는 단일 필드를 통해 프로젝션의 대상이 될 수 있습니다. unwrapped 객체는 Example probe 내에서 다른 유형과 마찬가지로 사용할 수 있습니다. unwrapped 객체의 필드는 Repository 추상화를 통해 전체 객체 및 필드에 대한 쿼리를 유도할 수도 있습니다."
"스프링 데이터 몽고DB에서 DBRef와 @DocumentReference의 차이점은 무엇인가요?","스프링 데이터 몽고DB에서 DBRef와 @DocumentReference는 모두 엔티티 간의 참조를 가능하게 하지만, 저장소 표현은 다릅니다. DBRef는 MongoDB 참조 문서(https://docs.mongodb.com/manual/reference/database-references/)에 명시된 고정된 구조의 문서로 해결됩니다. 반면, 문서 참조는 고정된 형식을 따르지 않습니다. MongoDB에 저장할 수 있는 모든 것, 즉 단일 값, 전체 문서 등이 될 수 있습니다. 기본적으로 매핑 계층은 저장 및 검색에 참조된 엔티티의 id 값을 사용합니다."
"스프링 데이터 몽고DB에서 DBRef를 사용할 때 참조된 엔티티를 일괄 로드하려면 어떻게 해야 하나요?","스프링 데이터 몽고DB에서 DBRef를 사용할 때 참조된 엔티티를 일괄 로드하려면 컬렉션 유형에 보유된 참조를 특정 MongoDB 컬렉션으로 제한하는 것이 좋습니다. 이렇게 하면 모든 참조를 일괄 로드할 수 있지만, 다른 MongoDB 컬렉션을 가리키는 참조는 하나씩 해결해야 합니다."
"스프링 데이터 몽고DB에서 DBRef를 사용할 때 지연 로딩을 어떻게 구현할 수 있나요?","스프링 데이터 몽고DB에서 DBRef를 사용할 때 지연 로딩을 구현하려면 @DBRef의 lazy 속성을 사용하여 실제 객체 또는 참조 컬렉션을 속성의 첫 번째 액세스 시 해결하도록 지정할 수 있습니다. 그러나 지연 로딩은 디버깅하기 어려울 수 있으며, 도구가 toString()을 호출하거나 속성 가져오기를 호출하는 등의 동작으로 프록시 해결을 실수로 트리거하지 않도록 주의해야 합니다. DBRef 해결에 대한 통찰력을 얻기 위해 org.springframework.data.mongodb.core.convert.DefaultDbRefResolver에 대한 추적 로깅을 활성화하는 것이 좋습니다."
"스프링 데이터 몽고DB에서 인덱스 생성을 명시적으로 활성화해야 하는 이유는 무엇인가요?","인덱스 생성을 명시적으로 활성화해야 하는 이유는 버전 3.0부터 컬렉션 라이프사이클과 성능 영향에 대한 원치 않는 효과를 방지하기 위함입니다. 컬렉션이 애플리케이션 실행 중에 재생성된 경우, 스프링 데이터는 자동으로 인덱스를 생성할 수 없으므로 인덱스 생성을 명시적으로 활성화하는 것이 좋습니다. IndexResolver를 사용하여 @Indexed, @GeoSpatialIndexed, @TextIndexed, @CompoundIndex 및 @WildcardIndexed와 같은 어노테이션을 사용할 수 있습니다."
"스프링 데이터 몽고DB에서 복합 인덱스를 사용하는 이유는 무엇인가요?","복합 인덱스는 여러 필드에 대한 기준을 포함하는 쿼리의 성능을 향상시키기 위해 사용됩니다. 복합 인덱스는 개별 속성이 아닌 클래스 수준에서 정의되며, 여러 필드에 대한 기준을 포함하는 쿼리의 성능을 크게 향상시킬 수 있습니다."
"스프링 데이터 몽고DB에서 해시 인덱스를 사용해야 하는 이유는 무엇인가요?","해시 인덱스는 샤딩된 클러스터 내에서 해시 기반 샤딩을 허용합니다. 해시 인덱스를 사용하면 컬렉션을 더 무작위로 분산시킬 수 있으며, 이는 성능에 큰 영향을 줄 수 있습니다. 해시 인덱스는 컬렉션의 필드 값을 해시 함수에 통과시켜 작동합니다."
"Value Expressions와 Spring Expression Language(SpEL)의 차이점은 무엇인가요?","Value Expressions는 Spring Expression Language(SpEL)과 Property Placeholder Resolution의 조합으로, 프로그래밍 방식의 식을 강력하게 평가하고 환경으로부터 값을 가져오기 위해 property-placeholder resolution을 사용할 수 있습니다. 반면에 SpEL은 #{...} 형식으로 둘러싸인 표현을 사용하는 Template 스타일을 따르는 언어입니다. SpEL은 EvaluationContext를 사용하여 평가되며, EvaluationContext는 다양한 작업, 정적 유형에 대한 액세스 및 컨텍스트 확장을 허용하는 강력한 StandardEvaluationContext입니다. SpEL은 평가 컨텍스트에 대한 루트 객체, 속성 및 함수(최상위 메서드)를 제공하는 컨텍스트 확장을 확장할 수 있습니다. SpEL은 EvaluationContextProvider와 ReactiveEvaluationContextProvider를 통해 액세스할 수 있습니다."
"Value Expressions를 사용하는 것의 장단점은 무엇인가요?","Value Expressions를 사용하면 코드에 많은 유연성을 도입할 수 있습니다. 그러나 Value Expressions는 각 사용 시 표현식을 평가해야 하므로 성능 프로필에 영향을 미칩니다. 또한, 사용자 제공 표현식을 허용하면 애플리케이션 컨텍스트와 시스템을 악용하여 잠재적인 보안 취약점을 초래할 수 있습니다."
"Value Expression API를 사용하는 방법은 무엇인가요?","Value Expression API는 ValueExpressionParser API를 사용하여 파싱하는 방식으로 작동합니다. ValueExpression 인스턴스는 스레드 안전하며, 반복적인 파싱을 피하기 위해 나중에 사용하기 위해 캐시할 수 있습니다. Java에서는 ValueParserConfiguration, ValueEvaluationContext 및 ValueExpressionParser를 사용하여 API를 사용할 수 있습니다. Kotlin에서는 각각 SpelExpressionParser, ValueEvaluationContext.of 및 ValueExpressionParser.create를 사용합니다."
"스프링 데이터 몽고DB에서 Entity Callbacks는 어떤 역할을 하나요?","Entity Callbacks는 특정 메서드가 호출되기 전과 후에 엔티티를 수정하기 위한 훅을 제공합니다. 이는 콜백 방식으로 엔티티를 확인하고 수정할 수 있는 편리한 방법을 제공합니다. 일부 스프링 데이터 모듈은 주어진 엔티티를 수정할 수 있는 BeforeSaveEvent와 같은 스토어별 이벤트를 게시합니다. Entity Callbacks는 동기 및 비동기 API 모두와 통합 지점을 제공하여 처리 체인 내의 잘 정의된 체크포인트에서 순서대로 실행되며, 잠재적으로 수정된 엔티티 또는 비동기 래퍼 유형을 반환합니다. Entity Callbacks는 일반적으로 API 유형별로 분리됩니다. 이는 동기 API가 동기 Entity Callbacks만 고려하고 비동기 구현이 비동기 Entity Callbacks만 고려한다는 것을 의미합니다. Entity Callback API는 스프링 데이터 커먼즈 2.2에서 도입되었습니다. 이는 엔티티 수정을 적용하는 권장 방법입니다. 기존 스토어별 ApplicationEvents는 여전히 호출될 수 있는 잠재적으로 등록된 EntityCallback 인스턴스 전에 게시됩니다."
"스프링 데이터 몽고DB에서 MongoTemplate의 Lifecycle events를 어떻게 비활성화할 수 있나요?","MongoTemplate의 Lifecycle events를 비활성화하려면 Template API의 setEntityLifecycleEventsEnabled 메서드를 사용하여 false를 전달하면 됩니다. 이 메서드를 호출하면 Entity lifecycle events가 비활성화되어 큰 결과 집합을 로드할 때 성능 프로필에 변화가 있을 수 있습니다."
"스프링 데이터 몽고DB에서 BeforeConvertCallback을 어떻게 구현할 수 있나요?","BeforeConvertCallback을 구현하려면 BeforeConvertCallback 인터페이스를 구현하는 클래스를 만들어야 합니다. 이 인터페이스에는 onBeforeConvert 메서드가 있으며, 이 메서드는 도메인 객체와 컬렉션 이름을 매개변수로 사용합니다. 이 메서드에서 필요한 작업을 수행할 수 있습니다. BeforeConvertCallback을 구현한 후에는 애플리케이션 컨텍스트에 빈으로 등록해야 합니다. 이렇게 하면 BeforeConvertCallback이 MongoDB 매핑 프레임워크에서 생성될 때마다 호출됩니다."
"Spring Data MongoDB에서 auditing을 활성화하는 방법은 무엇인가요?","Spring Data MongoDB 1.4 버전부터 @EnableMongoAuditing 어노테이션을 사용하여 auditing을 활성화할 수 있습니다. Configuration 클래스에 이 어노테이션을 적용하면 됩니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/auditing.html)"
"Spring Data MongoDB에서 auditing을 위해 여러 개의 AuditorAware/ReactiveAuditorAware를 등록하는 방법은 무엇인가요?","ApplicationContext에 여러 개의 AuditorAware / ReactiveAuditorAware 구현체를 등록할 수 있습니다. @EnableMongoAuditing의 auditorAwareRef 속성을 명시적으로 설정하여 사용할 구현체를 선택할 수 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/auditing.html)"
"Spring Data MongoDB의 auditing과 관련하여 reactive와 imperative 스타일은 어떻게 다른가요?","Reactive 스타일은 비동기 및 비차단 처리를 위해 ReactiveStreams를 사용하는 반면, imperative 스타일은 전통적인 동기식 처리를 사용합니다. @EnableReactiveMongoAuditing을 사용하여 reactive auditing을 활성화할 수 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/auditing.html)"
"MongoDB에서 세션이란 무엇인가요?","MongoDB 세션은 트랜잭션과 일관성 있는 읽기 기능을 사용할 때 서버와 클라이언트 간의 통신을 나타냅니다. 세션은 트랜잭션의 지속 시간 동안 유지되며, 트랜잭션이 커밋되거나 롤백될 때 종료됩니다."
"Spring Data MongoDB에서 MongoTemplate을 사용하여 어떻게 세션을 사용할 수 있나요?","Spring Data MongoDB에서 MongoTemplate을 사용하여 withSession 메서드를 사용하여 세션을 얻을 수 있습니다. 이 메서드는 세션을 인수로 받는 콜백 메서드를 실행하고, 세션이 자동으로 적용됩니다. 세션을 사용한 후에는 close 메서드를 사용하여 수동으로 세션을 종료해야 합니다."
"Spring Data MongoDB에서 ReactiveMongoTemplate을 사용하여 어떻게 세션을 사용할 수 있나요?","Spring Data MongoDB에서 ReactiveMongoTemplate을 사용하여 withSession 메서드를 사용하여 세션을 얻을 수 있습니다. 이 메서드는 세션을 Publisher로 반환하며, 세션이 자동으로 적용됩니다. ReactiveMongoTemplate을 사용할 때는 세션을 사용한 후에 close 메서드를 사용하여 수동으로 세션을 종료해야 합니다."
"스프링 데이터 몽고DB에서 체인지 스트림을 어떻게 사용할 수 있나요?","스프링 데이터 몽고DB에서 체인지 스트림을 사용하려면, 먼저 MongoTemplate을 사용하여 MessageListenerContainer를 생성한 다음, 컨테이너를 시작해야 합니다. 그런 다음, ChangeStreamRequestOptions를 사용하여 모니터링할 컬렉션을 설정하고, ChangeStreamRequest를 사용하여 리스너를 등록할 수 있습니다. 리스너는 MessageListener로 정의되며, 도메인 유형으로 변환된 ChangeStreamDocument를 수신할 때 호출됩니다. 또한, 쿼리 필터나 집계 파이프라인을 사용하여 이벤트를 필터링할 수도 있습니다. 마지막으로, 컨테이너를 중지하여 리소스를 해제해야 합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/change-streams.html)"
"스프링 데이터 몽고DB에서 체인지 스트림을 사용할 때, 반응형 접근 방식은 무엇인가요?","스프링 데이터 몽고DB에서 체인지 스트림을 사용할 때, 반응형 접근 방식은 반응형 API를 사용하여 스트림을 처리하는 것입니다. ChangeStreamOptions와 같은 기본 구성 요소는 동일하지만, ReactiveMongoTemplate을 사용하여 ChangeStreamEvent를 방출하는 Flux를 얻을 수 있습니다. 또한, 집계 파이프라인이나 쿼리 기준을 사용하여 이벤트를 필터링할 수도 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/change-streams.html)"
"스프링 데이터 몽고DB에서 체인지 스트림을 일시 중지하고 재개하는 방법은 무엇인가요?","스프링 데이터 몽고DB에서 체인지 스트림을 일시 중지하고 재개하려면, ChangeStreamOptions를 사용하여 일시 중지 토큰 또는 마지막 알려진 서버 시간을 지정할 수 있습니다. 일시 중지된 스트림을 재개하려면, 서버 시간을 사용하여 ChangeStreamRequestOptions의 resumeAt 메서드를 사용하면 됩니다. 또한, BsonTimestamp를 사용하여 ChangeStreamEvent의 타임스탬프를 사용할 수도 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/change-streams.html)"
"MongoDB에서 꼬리 커서를 사용하는 이유는 무엇인가요?","MongoDB에서 꼬리 커서를 사용하는 이유는 클라이언트가 처음에 반환된 모든 데이터를 소비한 후에도 열려 있는 커서를 만들기 위해서입니다. 이를 통해 캐프드 컬렉션에서 새로운 문서가 도착할 때마다 데이터를 실시간으로 처리할 수 있습니다. 꼬리 커서는 ReactiveMongoOperations 및 ReactiveMongoRepository를 사용하여 무한한 스트림을 생성할 수 있으며, 이는 리소스 소모가 적습니다. 꼬리 커서를 사용하려면 컬렉션 이름, 선택적 필터 및 메시지 리스너를 지정하여 TailableCursorRequest를 구성해야 합니다. 그런 다음 MessageListenerContainer를 사용하여 커서를 소비하고 리스너를 등록할 수 있습니다."
"Spring Data MongoDB에서 꼬리 커서를 사용하는 방법은 무엇인가요?","Spring Data MongoDB에서 꼬리 커서를 사용하려면 MongoOperations.createCollection()을 사용하여 캐프드 컬렉션을 만들어야 합니다. 그런 다음 TailableCursorRequest.builder()를 사용하여 컬렉션 이름, 선택적 필터 및 메시지 리스너를 지정하여 TailableCursorRequest를 구성해야 합니다. 마지막으로, MessageListenerContainer를 사용하여 커서를 소비하고 리스너를 등록할 수 있습니다. 또는 ReactiveMongoOperations 또는 ReactiveMongoRepository를 사용하여 꼬리 커서를 사용할 수도 있습니다."
"Spring Data MongoDB에서 꼬리 커서를 사용하면 어떤 이점이 있나요?","Spring Data MongoDB에서 꼬리 커서를 사용하면 캐프드 컬렉션에서 새로운 문서가 도착할 때마다 데이터를 실시간으로 처리할 수 있습니다. 또한 꼬리 커서는 무한한 스트림을 생성할 수 있으며, 이는 ReactiveMongoOperations 및 ReactiveMongoRepository를 사용하여 리소스 소모가 적습니다. 또한, 꼬리 커서를 사용하면 메시지 리스너를 사용하여 커서를 소비할 수 있으며, 이는 이미 Spring 생태계에 존재하는 메시징 개념을 사용합니다."
"스프링 데이터 몽고디비에서 샤딩을 지원하는가?","네, 스프링 데이터 몽고디비는 샤딩을 지원합니다. 이를 위해 @Sharded 어노테이션을 사용하여 샤딩된 컬렉션에 저장된 엔티티를 식별할 수 있습니다. 그러나 스프링 데이터 몽고디비는 컬렉션이나 샤딩에 필요한 인덱스를 자동으로 설정하지는 않습니다. MongoDB 클라이언트 API를 사용하여 샤딩을 설정하고 요구 사항과 제한 사항을 MongoDB 문서를 참조해야 합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/sharding.html)"
"스프링 데이터 몽고디비에서 샤드 키란 무엇인가요?","샤드 키는 대상 컬렉션의 모든 문서에 존재해야 하는 하나 이상의 속성으로 구성됩니다. 샤드 키는 문서를 샤드 간에 분산하는 데 사용됩니다. @Sharded 어노테이션을 엔티티에 추가하면 스프링 데이터 몽고디비가 샤딩 시나리오에 필요한 최적의 최적화를 적용할 수 있습니다. 이는 엔티티를 업서팅할 때 replaceOne 필터 쿼리에 필요한 샤드 키 정보를 추가하는 것을 의미합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/sharding.html)"
"스프링 데이터 몽고디비에서 샤딩을 설정하는 방법은 무엇인가요?","스프링 데이터 몽고디비에서 샤딩을 설정하려면 MongoDB 클라이언트 API를 사용하여 샤딩을 설정하고 요구 사항과 제한 사항을 MongoDB 문서를 참조해야 합니다. 샤딩 명령은 admin 데이터베이스에 대해 실행되어야 합니다. 특정 데이터베이스에 대해 샤딩을 활성화하고, 샤딩이 활성화된 데이터베이스 내의 컬렉션을 샤딩하고, 샤드 키를 지정해야 합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/sharding.html)"
"Spring Data MongoDB에서 Client-Side Field Level Encryption을 사용하려면 어떻게 해야 하나요?","Spring Data MongoDB에서 Client-Side Field Level Encryption을 사용하려면, 먼저 MongoDB의 공식 문서에서 해당 기능에 대한 개념과 제한 사항을 숙지해야 합니다. 그런 다음, MongoDB 드라이버의 `com.mongodb.AutoEncryptionSettings`를 설정하여 클라이언트 측 암호화를 사용해야 합니다. 또한, MongoDB의 JSON 스키마를 정의하여 암호화된 읽기 및 쓰기 작업을 수행할 수 있도록 해야 합니다. 마지막으로, `MongoClientSettingsBuilderCustomizer`를 사용하여 `AutoEncryptionSettings`를 적용해야 합니다. 자세한 내용은 다음 링크를 참조하십시오: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/mongo-encryption.html"
"Spring Data MongoDB에서 명시적 암호화를 사용하는 방법은 무엇인가요?","Spring Data MongoDB에서 명시적 암호화를 사용하려면, `@ExplicitEncrypted` 어노테이션을 사용하면 됩니다. 이 어노테이션을 사용하면 JSON 스키마 생성에 사용되는 `@Encrypted` 어노테이션과 Property Converter를 결합하여, 명시적 암호화를 지원합니다. `@ExplicitEncrypted`로 어노테이션된 필드는 전체로 암호화됩니다. 또한, 암호화 알고리즘을 지정하고, Data Encryption Key (DEK)를 참조해야 합니다. 자세한 내용은 다음 링크를 참조하십시오: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/mongo-encryption.html"
"Spring Data MongoDB에서 `@EncryptedField` 어노테이션의 `altKeyName` 속성은 어떤 역할을 하나요?","`@EncryptedField` 어노테이션의 `altKeyName` 속성은 Data Encryption Key (DEK)를 참조하는 데 사용됩니다. 이 속성을 사용하여, `@EncryptedField` 어노테이션이 대체 이름으로 저장된 DEK를 사용하도록 지정할 수 있습니다. `altKeyName`을 사용하면, DEK를 직접 ID로 참조하는 대신, 대체 이름을 사용하여 DEK를 참조할 수 있습니다. 자세한 내용은 다음 링크를 참조하십시오: https://docs.spring.io/spring-data/mongodb/reference/4.3/mongodb/mongo-encryption.html"
"Spring Data repository abstraction의 목적은 무엇인가요?","다양한 지속성 저장소에 대한 데이터 액세스 계층을 구현하는 데 필요한 보일러플레이트 코드의 양을 크게 줄이는 것이 목표입니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories.html)"
"Spring Data repository가 MongoDB 데이터 액세스 계층을 구현하는 데 어떻게 도움이 되나요?","Spring Data repository 추상화는 다양한 지속성 저장소에 대한 데이터 액세스 계층을 구현하는 데 필요한 보일러플레이트 코드의 양을 크게 줄여 MongoDB 데이터 액세스 계층을 구현하는 데 도움이 됩니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories.html)"
"MongoDB 특정 내용에 대해 이해하기 전에 어떤 기본 개념을 숙지해야 하나요?","Spring Data repository 및 MongoDB 특정 내용에 대한 장에서는 MongoDB 특정 내용에 대해 계속하기 전에 기본 개념에 대한 확실한 이해가 필요합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories.html)"
"스프링 데이터 리포지토리 추상화에서 중심적인 인터페이스는 무엇인가요?","스프링 데이터 리포지토리 추상화에서 중심적인 인터페이스는 Repository입니다. (출처: <https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/core-concepts.html>) "
"CrudRepository와 ListCrudRepository 인터페이스는 어떤 기능을 제공하나요?","CrudRepository와 ListCrudRepository 인터페이스는 관리 중인 엔티티 클래스에 대한 정교한 CRUD 기능을 제공합니다. (출처: <https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/core-concepts.html>) "
"Spring Data에서 엔티티가 새로운지 여부를 감지하는 데 사용되는 전략은 무엇인가요?","Spring Data에서 엔티티가 새로운지 여부를 감지하는 데 사용되는 전략은 @Id -Property 검사 (기본값), @Version -Property 검사, Persistable 인터페이스 구현 및 사용자 정의 EntityInformation 구현 제공 등이 있습니다. (출처: <https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/core-concepts.html>) "
"Spring Data에서 리포지토리 인터페이스를 정의하는 방법은 무엇인가요?","Spring Data에서 리포지토리 인터페이스를 정의하려면, 먼저 도메인 클래스별 리포지토리 인터페이스를 정의해야 합니다. 이 인터페이스는 Repository를 상속받고, 도메인 클래스와 ID 타입에 대해 타입이 지정되어야 합니다. 해당 도메인 타입에 대한 CRUD 메서드를 노출하려면, Repository 대신 CrudRepository 또는 그 변형 중 하나를 상속받을 수 있습니다. CrudRepository를 상속받으면 CRUD 기능을 위한 메서드가 제공됩니다. CRUD는 Create, Read, Update, Delete의 약자입니다. 버전 3.0부터는 ListCrudRepository도 도입되었으며, 이는 CrudRepository와 매우 유사하지만 여러 엔티티를 반환하는 메서드에서 Iterable 대신 List를 반환합니다. ReactiveCrudRepository, RxJava3CrudRepository 또는 CoroutineCrudRepository를 선택할 수도 있습니다. 이는 사용하는 리액티브 프레임워크에 따라 다릅니다. 또한 PagingAndSortingRepository, ReactiveSortingRepository, RxJava3SortingRepository 또는 CoroutineSortingRepository를 상속받아 Sort 추상화 또는 Pageable 추상화를 지정할 수 있는 메서드가 필요한 경우 선택할 수 있습니다. 다양한 정렬 리포지토리는 Spring Data 3.0 이전 버전과 달리 더 이상 해당 CRUD 리포지토리를 상속받지 않습니다. 따라서, 두 인터페이스의 기능을 모두 사용하려면 두 인터페이스를 모두 상속받아야 합니다."
"Spring Data에서 여러 개의 Spring Data 모듈을 사용할 때 리포지토리를 사용하는 방법은 무엇인가요?","Spring Data에서 여러 개의 Spring Data 모듈을 사용할 때 리포지토리 정의는 지속성 기술을 구분해야 합니다. Spring Data는 클래스 경로에 여러 리포지토리 팩토리가 감지되면 엄격한 리포지토리 구성 모드로 전환됩니다. 엄격한 구성은 리포지토리 또는 도메인 클래스에 대한 세부 정보를 사용하여 리포지토리 정의에 대한 Spring Data 모듈 바인딩을 결정합니다. 리포지토리 정의가 모듈별 리포지토리 인터페이스를 상속하는 경우 해당 Spring Data 모듈의 유효한 후보입니다. 도메인 클래스가 모듈별 타입 어노테이션으로 주석이 달린 경우 해당 Spring Data 모듈의 유효한 후보입니다. Spring Data 모듈은 타사 어노테이션(예: JPA의 @Entity) 또는 자체 어노테이션(예: Spring Data MongoDB 및 Spring Data Elasticsearch의 @Document)을 사용합니다. 도메인 클래스를 사용하여 리포지토리를 정의하고 도메인 클래스에 어노테이션을 사용하여 리포지토리 바인딩을 결정하는 것이 좋습니다. 도메인 클래스에 JPA 및 Spring Data MongoDB 어노테이션을 혼합하여 사용하는 것은 가능하며, 이는 여러 지속성 기술 간에 도메인 타입을 재사용할 수 있게 합니다. 그러나 Spring Data는 더 이상 리포지토리를 구분할 수 없으므로 정의되지 않은 동작이 발생합니다."
"MongoDB에 저장된 도메인 엔티티에 접근하기 위해 Repository를 어떻게 설정하나요?","MongoDB에 저장된 도메인 엔티티에 접근하기 위해 Repository를 설정하려면, 해당 Repository에 대한 인터페이스를 생성하고, `PagingAndSortingRepository` 또는 `ReactiveSortingRepository`와 같은 적절한 인터페이스를 확장해야 합니다. 또한, `@EnableMongoRepositories` 또는 `@EnableReactiveMongoRepositories` 어노테이션을 사용하여 MongoDB Repository를 사용할 수 있도록 구성해야 합니다. 이는 제공된 정보에서 예시 코드와 함께 자세히 설명되어 있습니다."
"MongoDB Repository에서 ID로 매핑되는 유형은 무엇인가요?","MongoDB Repository에서 ID로 매핑되는 유형은 기본적으로 `String`, `ObjectId`, `BigInteger`입니다. 이는 제공된 정보에서 ID 매핑에 대한 섹션에서 언급되었습니다."
"MongoDB Repository에서 Custom Query Method를 구현하려면 어떻게 해야 하나요?","MongoDB Repository에서 Custom Query Method를 구현하려면, Repository 인터페이스에서 추가적인 메서드를 정의하면 됩니다. 이는 제공된 정보에서 Custom Query Method에 대한 섹션에서 설명되었습니다. 또한, Querydsl 라이브러리를 사용하여 Type-Safe Query Method를 구현할 수도 있습니다. 이는 해당 라이브러리의 문서에서 자세히 설명되어 있습니다."
"스프링 데이터에서 쿼리 메소드란 무엇이고 어떻게 정의하나요?","스프링 데이터에서 쿼리 메소드는 리포지토리 인터페이스에서 정의되는 특별한 메소드입니다. 이 메소드는 쿼리를 생성하고 실행하기 위한 방법입니다. 쿼리 메소드는 쿼리 메소드 이름에서 직접 생성하거나, 수동으로 정의한 쿼리를 사용하는 두 가지 방법으로 스토어별 쿼리를 파생할 수 있습니다. 쿼리 메소드는 리포지토리 인프라가 쿼리를 해결할 수 있도록 적절한 키워드로 메소드 이름을 지정하여 정의합니다. 쿼리 메소드 이름에서 쿼리를 생성하는 방법에 대한 자세한 내용은 '스프링 데이터 MongoDB 참조 문서'의 'Query Creation' 섹션을 참조하십시오. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/query-methods-details.html#repositories.query-methods.query-creation)"
"스프링 데이터에서 쿼리 조회 전략이란 무엇이고 어떻게 구성하나요?","스프링 데이터에서 쿼리 조회 전략은 리포지토리 인프라가 쿼리를 해결하기 위해 사용할 수 있는 전략입니다. 사용 가능한 전략은 CREATE, USE_DECLARED_QUERY 및 CREATE_IF_NOT_FOUND입니다. 이러한 전략은 리포지토리 인프라가 쿼리를 생성하는 방법을 결정합니다. 전략을 구성하려면 XML 구성에서 query-lookup-strategy 속성을 사용하거나 Java 구성에서 EnableMongoRepositories 어노테이션의 queryLookupStrategy 속성을 사용합니다. 쿼리 조회 전략에 대한 자세한 내용은 '스프링 데이터 MongoDB 참조 문서'의 'Query Lookup Strategies' 섹션을 참조하십시오. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/query-methods-details.html#repositories.query-methods.query-lookup-strategies)"
"스프링 데이터에서 쿼리 메소드에서 반환되는 컬렉션 또는 Iterable을 어떻게 사용할 수 있나요?","스프링 데이터에서 쿼리 메소드는 여러 결과를 반환하는 경우 표준 Java Iterable, List 및 Set을 사용할 수 있습니다. 이 외에도 Spring Data의 Streamable, Iterable의 사용자 지정 확장 및 Vavr에서 제공하는 컬렉션 유형을 지원합니다. 쿼리 메소드에서 이러한 컬렉션 또는 Iterable을 반환하려면 해당 컬렉션 또는 Iterable을 반환하는 메소드 시그니처를 정의하면 됩니다. Streamable을 쿼리 메소드 반환 유형으로 사용하려면 Streamable을 구현하고 Iterator를 delegate하는 유형을 만들어야 합니다. Streamable을 사용하여 쿼리 메소드 결과를 결합하려면 Streamable을 반환하는 메소드를 호출하고 and 메소드를 사용하여 다른 Streamable과 결합하면 됩니다. 사용자 지정 Streamable 래퍼 유형을 반환하려면 해당 유형이 Streamable을 구현하고 Streamable을 인수로 사용하는 생성자 또는 정적 팩토리 메소드를 노출해야 합니다. 쿼리 메소드에서 반환되는 컬렉션 또는 Iterable을 사용하는 방법에 대한 자세한 내용은 '스프링 데이터 MongoDB 참조 문서'의 'Repository Methods Returning Collections or Iterables' 섹션을 참조하십시오. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/query-methods-details.html#repositories.collections-and-iterables)"
"스프링 데이터 MongoDB에서 쿼리 메서드 외에 어떤 방법으로 데이터를 수정할 수 있나요?","스프링 데이터 MongoDB에서는 쿼리 메서드 외에도 @Update 어노테이션을 사용하여 데이터를 수정할 수 있습니다. 이 어노테이션은 메서드 자체에 적용되며, 업데이트 작업은 메서드 이름에서 파생된 필터 쿼리를 사용하여 수행됩니다. 업데이트 작업은 메서드 매개변수와 바인딩되거나 Spring Expression Language (SpEL)을 사용하여 바인딩될 수 있습니다. 또한, updateAllByLastname 메서드를 사용하여 모든 일치하는 문서에 업데이트를 적용할 수 있으며, 삭제 메서드를 사용하여 일치하는 문서를 삭제할 수 있습니다. 리포지토리 업데이트는 지속성 또는 매핑 수명 주기 이벤트를 발생시키지 않습니다."
"스프링 데이터 MongoDB에서 update 메서드와 delete 메서드의 차이점은 무엇인가요?","스프링 데이터 MongoDB에서 update 메서드는 특정 조건을 만족하는 문서에 대해 업데이트 작업을 수행하는 반면, delete 메서드는 특정 조건을 만족하는 문서를 삭제하는 작업을 수행합니다. update 메서드는 @Update 어노테이션을 사용하여 적용되며, delete 메서드는 삭제하려는 문서의 조건을 지정하는 키워드를 사용합니다. update 메서드는 'findAndIncrementVisitsByLastname', 'findAndPushShippingAddressByEmail' 등이 있고, delete 메서드는 'deleteByLastname', 'deletePersonByLastname', 'deleteSingleByLastname' 등이 있습니다."
"스프링 데이터 MongoDB에서 리포지토리 업데이트 시 어떤 이벤트가 발생하지 않나요?","스프링 데이터 MongoDB에서 리포지토리 업데이트 시 지속성 또는 매핑 수명 주기 이벤트가 발생하지 않습니다. 즉, 업데이트 작업 시에는 @PreUpdate, @PostUpdate, @PrePersist, @PostPersist 등의 이벤트가 호출되지 않습니다. 이러한 이벤트는 엔티티에 대한 JPA 또는 Spring Data MongoDB 특정 수명 주기 메서드를 호출하는 데 사용됩니다."
"프로퍼레이션이란 무엇이며, 스프링 데이터에서 어떻게 사용되나요?","프로퍼레이션은 스프링 데이터에서 쿼리 메소드의 결과를 모델링하여, 관리되는 애그리게이트의 부분적인 뷰를 더 선택적으로 검색할 수 있도록 하는 것입니다. 이를 위해 전용 반환 유형을 모델링하고, 쿼리 메소드를 추가하여 이름 속성만 검색할 수 있습니다. 인터페이스 기반 프로퍼레이션은 속성에 대한 접근자 메소드를 노출하는 인터페이스를 선언하고, 쿼리 메소드는 프로퍼레이션 인터페이스를 반환하는 형태로 추가됩니다. 쿼리 실행 엔진은 반환된 각 요소에 대해 런타임에 해당 인터페이스의 프록시 인스턴스를 생성하고, 노출된 메소드에 대한 호출을 대상 객체로 전달합니다."
"인터페이스 기반 프로퍼레이션과 클래스 기반 프로퍼레이션(DTO)의 차이점은 무엇인가요?","인터페이스 기반 프로퍼레이션은 대상 애그리게이트의 속성과 정확히 일치하는 접근자 메소드를 정의하는 인터페이스를 선언하는 것입니다. 클래스 기반 프로퍼레이션(DTO)은 검색할 필드에 대한 속성을 보유하는 값 유형 DTO를 사용하는 것입니다. 인터페이스 기반 프로퍼레이션은 프록시를 생성하고 중첩 프로퍼레이션을 적용할 수 있지만, 클래스 기반 프로퍼레이션은 그렇지 않습니다. 또한, 클래스 기반 프로퍼레이션은 생성자의 매개변수 이름을 기반으로 로드할 필드를 결정합니다."
"프로퍼레이션에서 닫힌 프로퍼레이션과 열린 프로퍼레이션의 차이점은 무엇인가요?","접근자 메소드가 모두 대상 애그리게이트의 속성과 일치하는 프로퍼레이션 인터페이스는 닫힌 프로퍼레이션으로 간주됩니다. 열린 프로퍼레이션은 @Value 어노테이션을 사용하여 새로운 값을 계산하는 접근자 메소드를 사용할 수 있습니다. 닫힌 프로퍼레이션을 사용하면 스프링 데이터는 쿼리 실행을 최적화할 수 있지만, 열린 프로퍼레이션은 쿼리 실행 최적화를 적용할 수 없습니다."
"Spring Data에서 @DomainEvents 어노테이션을 사용하는 목적은 무엇인가요?","Spring Data에서 @DomainEvents 어노테이션은 애그리게이트 루트의 메서드에 적용하여 도메인 이벤트의 게시를 용이하게 합니다. 이를 통해 이벤트 발생을 추적하고, 애플리케이션의 동작을 기록할 수 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/core-domain-events.html)"
"@DomainEvents를 사용한 메서드에서 반환되는 값의 형식은 어떻게 되나요?","@DomainEvents를 사용한 메서드는 단일 이벤트 인스턴스 또는 이벤트 컬렉션을 반환할 수 있습니다. 인자를 받지 않아야 합니다. 이를 통해 여러 이벤트를 일괄적으로 게시하거나, 필요한 경우 개별 이벤트의 데이터를 추가로 가공할 수 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/core-domain-events.html)"
"@AfterDomainEventPublication 어노테이션의 사용 목적은 무엇인가요?","@AfterDomainEventPublication 어노테이션은 모든 이벤트가 게시된 후에 호출되는 메서드에 적용됩니다. 이 메서드를 사용하여 게시할 이벤트 목록을 정리하거나, 이벤트 게시와 관련된 다른 작업을 수행할 수 있습니다. 이를 통해 이벤트 게시 후의 작업을 체계적으로 처리할 수 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/core-domain-events.html)"
"스프링 데이터 2.0부터 리포지토리 CRUD 메서드가 개별 애그리게이트 인스턴스를 반환할 때 NULL 값을 처리하는 방법은 무엇인가요?","스프링 데이터 2.0부터 리포지토리 CRUD 메서드가 개별 애그리게이트 인스턴스를 반환할 때 Java 8의 Optional을 사용하여 값의 부재를 나타냅니다. 또한, Spring Data는 쿼리 메서드에서 com.google.common.base.Optional, scala.Option, io.vavr.control.Option과 같은 래퍼 유형을 반환하는 것을 지원합니다. 또는 쿼리 메서드는 래퍼 유형을 사용하지 않을 수도 있습니다. 이 경우 null을 반환하여 쿼리 결과의 부재를 나타냅니다. 컬렉션, 컬렉션 대안, 래퍼 및 스트림을 반환하는 리포지토리 메서드는 null을 반환하지 않고 해당 빈 표현을 반환합니다. 자세한 내용은 'Repository query return types(query-return-types-reference.html)'를 참조하십시오. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/null-handling.html)"
"Spring Framework의 nullability annotations를 사용하여 리포지토리 메서드의 nullability constraints를 표현하는 방법은 무엇인가요?","Spring Framework의 nullability annotations를 사용하여 리포지토리 메서드의 nullability constraints를 표현할 수 있습니다. @NonNullApi, @NonNull, @Nullable annotations를 사용하여 매개변수 및 반환 값에 대한 nullability constraints를 선언할 수 있습니다. Spring annotations는 JSR 305 annotations로 메타 주석이 달려 있으므로 도구 공급업체가 Spring annotations에 대한 지원을 하드 코딩하지 않고도 일반적인 방식으로 null-safety 지원을 제공할 수 있습니다. 쿼리 메서드의 nullability constraints를 런타임에 확인하려면 package-info.java에서 Spring의 @NonNullApi를 사용하여 패키지 수준에서 nullability를 활성화해야 합니다. 이렇게 하면 메서드가 null을 반환하지만 null이 아닌 것으로 선언된 경우(리포지토리가 포함된 패키지에서 정의된 어노테이션으로 기본 설정됨) 예외가 발생합니다. 다시 nullable 결과에 대해 선택적으로 @Nullable을 개별 메서드에 사용하십시오. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/null-handling.html)"
"Kotlin 기반 리포지토리에서 nullability constraints를 사용하는 방법은 무엇인가요?","Kotlin에서는 언어에 nullability constraints의 정의가 내장되어 있습니다. Kotlin 코드는 메서드 시그니처를 통해 nullability constraints를 표현하는 대신 컴파일된 메타데이터를 통해 표현합니다. Kotlin의 nullability constraints를 검사하려면 프로젝트에 kotlin-reflect JAR를 포함해야 합니다. Spring Data 리포지토리는 언어 메커니즘을 사용하여 이러한 제약 조건을 정의하여 동일한 런타임 검사를 적용합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/null-handling.html)"
"스프링 데이터 리포지토리 쿼리 파생 메커니즘에서 일반적으로 지원되는 쿼리 대상 키워드는 무엇인가요?","find...By, read...By, get...By, query...By, search...By, stream...By, exists...By, count...By, delete...By, remove...By, ...First<number>... , ...Top<number>... , ...Distinct... 등이 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리 쿼리 파생 메커니즘에서 일반적으로 지원되는 쿼리 대상 키워드는 무엇인가요?","AND, OR, AFTER, Before, CONTAINING, BETWEEN, ENDING_WITH, EXISTS, FALSE, GREATER_THAN, GREATER_THAN_EQUALS, IN, IS, IS_EMPTY, IS_NOT_EMPTY, IS_NOT_NULL, IS_NULL, LESS_THAN, LESS_THAN_EQUAL, LIKE, NEAR, NOT, NOT_IN, NOT_LIKE, REGEX, STARTING_WITH, TRUE, WITHIN 등이 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리 쿼리 파생 메커니즘에서 지원되는 쿼리 대상 수정자 키워드는 무엇인가요?","IgnoreCase, IgnoringCase, AllIgnoreCase, AllIgnoringCase, OrderBy... 등이 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리에서 어떤 쿼리 반환 타입을 사용하나요?","스프링 데이터 리포지토리에서는 void, Java의 기본 타입(primitive)과 래퍼 타입(wrapper type), T(고유한 엔티티), Iterator<T>, Collection<T>, List<T>, Optional<T>, Option<T>, Stream<T>, Streamable<T>, Vavr의 컬렉션 타입, Future<T>, CompletableFuture<T>, Slice<T>, Page<T>, Window<T>, GeoResult<T>, GeoResults<T>, GeoPage<T>, Mono<T>, Flux<T>, Single<T>, Maybe<T>, Flowable<T> 등의 타입을 지원합니다. (출처: <https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/query-return-types-reference.html>)"
"스프링 데이터 리포지토리에서 Geospatial 쿼리 반환 타입은 어떤 것이 있나요?","스프링 데이터 리포지토리에서 Geospatial 쿼리 반환 타입으로는 GeoResult, GeoResults, GeoPage 등이 있습니다. 다만, 이러한 타입은 Geospatial 쿼리를 지원하는 데이터 저장소에만 적용됩니다. (출처: <https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/query-return-types-reference.html>)"
"스프링 데이터 리포지토리에서 Future<T> 타입의 쿼리 반환 타입을 사용하려면 어떤 제한이 있나요?","스프링 데이터 리포지토리에서 Future<T> 타입의 쿼리 반환 타입을 사용하려면, 해당 메서드가 @Async 어노테이션으로 주석 처리되어야 하며, 스프링의 비동기 메서드 실행 기능이 활성화되어 있어야 합니다. (출처: <https://docs.spring.io/spring-data/mongodb/reference/4.3/repositories/query-return-types-reference.html>)"
"Spring Data MongoDB에서 Observability를 지원하는 가장 최신 코드는 어디에 있나요?","Spring Data MongoDB에서 Observability를 지원하는 가장 최신 코드는 현재 Spring Data MongoDB에 있습니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/observability/observability.html)"
"Spring Boot에서 Spring Data MongoDB의 Observability를 사용하려면 어떻게 해야 하나요?","Spring Boot의 자동 구성 MongoDB 명령 리스너를 비활성화하고, application.properties 파일에 management.tracing.enabled=true 속성을 추가하여 수동으로 추적을 활성화해야 합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/observability/observability.html)"
"Spring Data MongoDB의 Observability를 사용하려면 어떤 단계를 따라야 하나요?","Spring Data MongoDB의 구성 설정에 대해 MongoClientSettingsBuilderCustomizer를 구현하여 opt-in하고, Spring Boot Actuator를 프로젝트에 추가해야 합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/observability/observability.html)"
"MongoHandlerContext에 대한 DefaultMongoHandlerObservationConvention의 클래스 이름은 무엇인가요?","org.springframework.data.mongodb.observability.DefaultMongoHandlerObservationConvention (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/observability/conventions.html)"
"MongoHandlerContext에 대한 MongoHandlerObservationConvention의 클래스 이름은 무엇인가요?","org.springframework.data.mongodb.observability.MongoHandlerObservationConvention (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/observability/conventions.html)"
"Table 1에서 선언된 ObservationConvention 구현체 중 어떤 클래스가 어떤 ObservationContext 클래스에 적용되나요?","org.springframework.data.mongodb.observability.DefaultMongoHandlerObservationConvention은 MongoHandlerContext에 적용되며, org.springframework.data.mongodb.observability.MongoHandlerObservationConvention도 MongoHandlerContext에 적용됩니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/observability/conventions.html)"
"Spring Data MongoDB에서 선언된 모든 메트릭을 어디에서 찾을 수 있나요?","Spring Data MongoDB에서 선언된 모든 메트릭은 해당 프로젝트의 공식 문서에 나열되어 있습니다. (Source: {https://docs.spring.io/spring-data/mongodb/reference/4.3/observability/metrics.html})"
"MongoDB 명령 실행 시간 측정을 위한 타이머의 이름과 유형은 무엇인가요?","MongoDB 명령 실행 시간 측정을 위한 타이머의 이름은 'spring.data.mongodb.command'이며, 타입은 'timer'입니다. (Source: {https://docs.spring.io/spring-data/mongodb/reference/4.3/observability/metrics.html})"
"MongoDB 명령 메트릭에서 KeyValues는 언제 추가되나요?","MongoDB 명령 메트릭에서 KeyValues는 관측 시작 후에 추가되므로 '*.active' 메트릭에는 누락될 수 있습니다. (Source: {https://docs.spring.io/spring-data/mongodb/reference/4.3/observability/metrics.html})"
"Kotlin은 어떤 종류의 언어를 대상으로 하며, 어떤 JVM 라이브러리와의 상호 운용성을 제공하나요?","Kotlin은 JVM(및 다른 플랫폼)을 대상으로 하는 정적으로 타입이 지정된 언어로, Java로 작성된 기존 라이브러리와의 우수한 상호 운용성을 제공합니다. (출처: https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-kotlin.html)"
"Spring Data는 Kotlin을 어떻게 지원하며, 개발자들은 Kotlin으로 어떤 종류의 애플리케이션을 작성할 수 있나요?","Spring Data는 Kotlin을 1급으로 지원하며, 개발자들은 Kotlin으로 Spring Data가 Kotlin 네이티브 프레임워크인 것처럼 거의 모든 종류의 Kotlin 애플리케이션을 작성할 수 있습니다. (출처: https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-kotlin.html)"
"Spring Boot와 Kotlin을 사용하여 Spring 애플리케이션을 구축하는 가장 쉬운 방법은 무엇인가요?","Spring Boot와 Kotlin을 사용하여 Spring 애플리케이션을 구축하는 가장 쉬운 방법은 Spring Boot와 그 전용 Kotlin 지원을 활용하는 것입니다. (출처: https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-kotlin.html)"
"Spring Data에서 Kotlin을 사용하기 위해 필요한 최소 버전은 무엇인가요?","Spring Data는 Kotlin 1.3 이상을 지원합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/kotlin/requirements.html)"
"Spring Data에서 Kotlin을 사용할 때 클래스패스에 어떤 라이브러리가 필요한가요?","kotlin-stdlib (또는 kotlin-stdlib-jdk8와 같은 변형)와 kotlin-reflect가 클래스패스에 있어야 합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/kotlin/requirements.html)"
"kotlin-stdlib와 kotlin-reflect를 어떻게 얻을 수 있나요?","start.spring.io를 통해 Kotlin 프로젝트를 부트스트랩하면 기본적으로 제공됩니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/kotlin/requirements.html)"
"코틀린에서 널 세이프티가 무엇인지 설명해주세요.","코틀린의 주요 기능 중 하나인 널 세이프티(Null Safety)는 컴파일 시간에 널 값을 깔끔하게 처리합니다. 이를 통해 부정확한 null 값으로 인해 발생하는 런타임 오류를 미리 방지하여 애플리케이션을 보다 안전하게 만들 수 있습니다. 코틀린에서는 널 가능한 값에 대한 함수형 구문을 사용할 수 있으며, 이에 대한 자세한 내용은 Kotlin Null Safety(https://www.baeldung.com/kotlin/null-safety)를 참조하시기 바랍니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/kotlin/null-safety.html)"
"자바에서 스프링 데이터 API를 사용할 때, 널 세이프티를 어떻게 처리할 수 있나요?","자바에서는 타입 시스템에 널 세이프티를 표현할 수 없지만, 스프링 데이터 API는 org.springframework.lang 패키지에 선언된 JSR-305 도구 친화적인 어노테이션으로 주석이 달려 있습니다. 코틀린에서 사용되는 자바 API의 타입은 기본적으로 플랫폼 타입으로 인식되어 널 체크가 완화됩니다. 코틀린에서 JSR-305 어노테이션과 스프링 널 가능 어노테이션을 사용하면 코틀린 개발자에게 스프링 데이터 API 전체에 대한 널 세이프티를 제공하며, 컴파일 시간에 널 관련 문제를 처리할 수 있는 장점이 있습니다. -Xjsr305 컴파일러 플래그를 추가하여 JSR-305 검사를 구성할 수 있으며, 옵션은 {strict|warn|ignore}입니다. 코틀린 버전 1.1 이상의 경우, 기본 동작은 -Xjsr305=warn과 동일합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/kotlin/null-safety.html)"
"스프링 데이터 리포지토리에서 널 세이프티가 어떻게 적용되나요?","스프링 데이터 리포지토리에서 널 세이프티는 리포지토리 메소드의 널 처리에 적용됩니다. 코틀린에서 추론된 타입은 스프링 API에서 추론되지만, 스프링 API 널 가능 선언이 마이너 버전 간에도 변경될 수 있으며, 향후 더 많은 체크가 추가될 수 있다는 점을 염두에 두어야 합니다. 제네릭 타입 인수, varargs 및 배열 요소의 널 가능 여부는 아직 지원되지 않지만, 향후 릴리스에서 지원될 예정입니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/kotlin/null-safety.html)"
"코틀린 익스텐션을 Spring Data에서 사용할 수 있나요?","네, 코틀린 익스텐션은 Spring Data Kotlin API에서 기존 Spring API에 새로운 코틀린 전용 편의 기능을 추가하는 데 사용됩니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/kotlin/extensions.html)"
"코틀린 익스텐션과 정적 가져오기의 차이점은 무엇인가요?","코틀린 익스텐션과 정적 가져오기 모두 클래스에서 멤버를 가져오는 데 사용되지만, 코틀린 익스텐션은 기존 클래스에 새로운 기능을 추가할 수 있는 기능을 제공하며, 정적 가져오기는 정적 멤버를 가져오는 데 사용됩니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/kotlin/extensions.html)"
"제네릭 타입 지우기와 코틀린 리파이드 타입 파라미터에 대해 설명해주세요.","제네릭 타입 지우기는 JVM의 기능으로, 타입 정보를 지우는 것을 의미합니다. 코틀린 리파이드 타입 파라미터는 제네릭 타입 지우기에 대한 해결책으로, Spring Data에서는 이 기능을 활용하여 Kotlin API를 개선합니다. (출처: https://docs.spring.io/spring-data/mongodb/reference/4.3/kotlin/extensions.html)"
"코루틴은 어떤 용도로 사용되나요?","코루틴은 Kotlin Coroutines(https://kotlinlang.org/docs/reference/coroutines-overview.html)에서 제공하는 비동기, 비차단적인 코드를 작성할 수 있는 인스턴스입니다."
"코루틴의 이점은 무엇인가요?","코루틴은 비동기적인 작업을 쉽게 처리할 수 있는 추상화를 제공하며, 라이브러리 측면에서는 async { }(https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html)와 Flow(https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html)와 같은 함수와 타입을 제공합니다."
"Spring Data에서 코루틴을 지원하는 버전은 어떤 것인가요?","Spring Data에서 코루틴을 지원하는 버전은 1.3.0 이상입니다."
"Spring Data Redis는 어떤 목적으로 사용되나요?","Spring Data Redis는 Redis에 대한 연결성과 저장소 지원을 제공하여 Redis 데이터 소스에 액세스해야 하는 일관된 프로그래밍 모델을 가진 애플리케이션의 개발을 용이하게 합니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/index.html)"
"Spring Data Redis에서 Repositories는 어떤 역할을 하나요?","Spring Data Redis에서 Repositories는 Redis 데이터 소스에 대한 일관된 프로그래밍 모델을 제공합니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/index.html)"
"Spring Data Redis에서 Observability는 어떻게 지원되나요?","Spring Data Redis에서 Observability는 Wiki 페이지 (https://github.com/spring-projects/spring-data-commons/wiki)에서 추가 크로스 버전 정보를 확인할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/index.html)"
"Spring Data를 업그레이드하려면 어떤 버전에서 어떻게 해야 하나요?","Spring Data를 업그레이드하려면 Spring Data Commons 프로젝트 위키의 릴리스 노트 섹션에서 원하는 버전으로 업그레이드하는 방법에 대한 지침을 찾을 수 있습니다. (출처: <https://docs.spring.io/spring-data/redis/reference/3.3/commons/upgrade.html>)"
"특정 버전의 Spring Data에서 특정 기능에 대한 자세한 정보를 찾을 수 있는 위치는 어디인가요?","특정 버전의 Spring Data에서 특정 기능에 대한 자세한 정보는 해당 버전의 릴리스 노트에서 찾을 수 있습니다. (출처: <https://docs.spring.io/spring-data/redis/reference/3.3/commons/upgrade.html>)"
"Spring Data의 릴리스 노트에서 어떤 정보를 찾을 수 있나요?","Spring Data의 릴리스 노트에서는 주요 버전 업그레이드에 대한 마이그레이션 가이드와 해당 버전에 포함된 최신 변경 사항에 대한 정보를 찾을 수 있습니다. (출처: <https://docs.spring.io/spring-data/redis/reference/3.3/commons/upgrade.html>)"
"Spring Data에서 지원하는 키-값 저장소 중 하나는 무엇인가요?","Spring Data에서 지원하는 키-값 저장소 중 하나는 Redis입니다. (출처: <https://docs.spring.io/spring-data/redis/reference/3.3/redis.html>)"
"Spring Data Redis는 어떤 기능을 제공하나요?","Spring Data Redis는 RedisTemplate 및 ReactiveRedisTemplate 도우미 클래스, 객체와 값 간의 통합 직렬화, Spring의 이식 가능한 데이터 액세스 예외 계층으로의 예외 변환, 사용자 정의 쿼리 메서드 지원을 포함한 Repository 인터페이스의 자동 구현, Spring의 변환 서비스와 통합된 기능이 풍부한 객체 매핑, 다른 메타데이터 형식을 지원하기 위한 확장 가능한 어노테이션 기반 매핑 메타데이터, 트랜잭션 및 파이프라인, Spring의 캐시 추상화를 통한 Redis Cache 통합, Redis Pub/Sub 메시징 및 Redis Stream 리스너, RedisList 또는 RedisSet과 같은 Java용 Redis 컬렉션 구현 등이 포함됩니다. (출처: <https://docs.spring.io/spring-data/redis/reference/3.3/redis.html>)"
"Spring Data Redis를 사용하는 이유는 무엇인가요?","Spring Data Redis (SDR) 프레임워크는 Spring의 훌륭한 인프라 지원 기능을 통해 Redis 키-값 저장소를 사용하는 Spring 애플리케이션을 쉽게 작성할 수 있도록 도와줍니다. 이를 통해 저장소와의 상호 작용에 필요한 중복 작업 및 보일러플레이트 코드를 제거하여 개발자가 Spring 애플리케이션을 Redis와 함께 사용하는 데 필요한 시간과 노력을 줄일 수 있습니다. (출처: <https://docs.spring.io/spring-data/redis/reference/3.3/redis.html>)"
"스프링 데이터 레디스를 사용하여 작동하는 환경을 설정하는 간단한 방법은 무엇인가요?","start.spring.io를 통해 스프링 기반의 프로젝트를 생성하거나, Spring Tools에서 스프링 프로젝트를 생성할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#getting-started)"
"스프링 데이터 레디스를 사용하는 방법에 대한 예제를 찾을 수 있는 곳은 어디인가요?","GitHub spring-data-examples 저장소에는 라이브러리의 작동 방식을 이해할 수 있는 여러 예제가 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#getting-started)"
"스프링 데이터 레디스를 사용하여 레디스에 데이터를 저장하고 검색하는 방법은 무엇인가요?","RedisConnectionFactory를 사용하여 RedisTemplate 또는 ReactiveRedisTemplate의 인스턴스를 생성하고, 다양한 데이터 구조(문자열, 리스트, 세트, 정렬된 세트, 스트림, 해시 등)를 사용하여 데이터를 저장하고 검색할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#getting-started)"
"Redis와 Spring을 사용할 때 IoC 컨테이너를 통해 스토어에 연결하는 가장 첫 번째 작업은 무엇인가요?","Java 커넥터(또는 바인딩)가 필요합니다. 라이브러리를 선택하든, 모든 커넥터에서 일관되게 작동하는 Spring Data Redis API 세트를 사용해야 합니다."
"Redis 연결 및 Redis 연결 팩토리 인터페이스는 무엇인가요?","org.springframework.data.redis.connection 패키지에는 RedisConnection 및 RedisConnectionFactory 인터페이스가 있습니다."
"RedisConnection은 어떤 역할을 하나요?","Redis와의 통신을 처리하고, 기본 연결 라이브러리 예외를 Spring의 일관된 DAO 예외 계층 구조로 자동으로 변환합니다."
"스프링 데이터 리디스에서 리디스를 어떤 모드로 운영할 수 있나요?","스프링 데이터 리디스에서 리디스를 Standalone, Master/Replica, Sentinel, Cluster 모드로 운영할 수 있습니다."
"스프링 데이터 리디스에서 Standalone 모드로 리디스를 구성하려면 어떤 클래스를 사용해야 하나요?","스프링 데이터 리디스에서 Standalone 모드로 리디스를 구성하려면 RedisStandaloneConfiguration 클래스를 사용해야 합니다."
"스프링 데이터 리디스에서 Master/Replica 모드에서 쓰기 연산은 어디에서 수행되고, 읽기 연산은 어디에서 수행되나요?","스프링 데이터 리디스에서 Master/Replica 모드에서 쓰기 연산은 마스터에서 수행되고, 읽기 연산은 레플리카에서 수행됩니다."
"스프링 데이터 리디스(Spring Data Redis)에서 RedisTemplate을 이용하는 이유가 무엇인가요?","RedisTemplate은 Redis와의 상호작용을 위한 고수준의 추상화를 제공하며, 직렬화 및 연결 관리를 처리하여 사용자가 세부 사항을 신경 쓰지 않아도 됩니다. 또한, RedisOperations 및 ReactiveRedisOperations 인터페이스를 구현하여 Redis에 대한 작업을 수행할 수 있는 풍부한 인터페이스를 제공합니다. RedisTemplate은 리디스 모듈의 중심 클래스로, 다양한 기능과 직렬화 메커니즘을 제공하여 사용자가 커스텀 타입과 원시 데이터(그리고 그 반대) 간의 변환을 처리할 수 있습니다. RedisTemplate은 리디스 연결 팩토리를 사용하여 구성할 수 있으며, 재사용 가능한 스레드 안전 클래스입니다."
"스프링 데이터 리디스에서 RedisTemplate을 통해 어떤 작업 뷰를 사용할 수 있나요?","RedisTemplate은 리디스 명령 참조에서 그룹화된 작업 뷰를 제공합니다. 작업 뷰에는 GeoOperations, HashOperations, HyperLogLogOperations, ListOperations, SetOperations, ValueOperations, ZSetOperations 등의 운영형 뷰와 BoundGeoOperations, BoundHashOperations, BoundKeyOperations, BoundListOperations, BoundSetOperations, BoundValueOperations, BoundZSetOperations 등의 키 바운드 작업이 포함됩니다. 이러한 뷰는 Redis의 특정 유형 또는 특정 키에 대한 작업을 쉽게 수행할 수 있는 풍부한 제네릭 인터페이스를 제공합니다."
"스프링 데이터 리디스에서 RedisTemplate의 직렬화 메커니즘을 어떻게 사용자 정의할 수 있나요?","RedisTemplate의 직렬화 메커니즘을 사용자 정의하려면 org.springframework.data.redis.serializer 패키지에서 제공하는 여러 구현체 중 하나를 설정하면 됩니다. RedisSerializer를 기반으로 하는 양방향 직렬라이저와 RedisElementReader 및 RedisElementWriter를 사용하는 요소 리더 및 라이터가 있습니다. 기본적으로 RedisCache 및 RedisTemplate은 Java 기본 직렬화를 사용하도록 구성되어 있으며, 이는 원격 코드 실행을 허용하여 취약한 라이브러리를 악용하는 페이로드 및 검증되지 않은 바이트 코드를 주입하는 취약한 클래스로 알려져 있습니다. 보안 취약점에 대해 걱정되는 경우 JVM 수준에서 일반적인 직렬화 필터 메커니즘을 고려하거나 JSON과 같은 다른 메시지 형식을 사용할 수 있습니다."
"Redis Cluster를 사용하려면 필요한 Redis Server 버전은 무엇인가요?","Redis Cluster를 사용하려면 Redis Server 버전 3.0 이상이 필요합니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/cluster.html)"
"Redis Cluster에서 Pub/Sub을 사용할 때 어떤 제한이 있나요?","Redis Cluster에서 Pub/Sub을 사용할 때, 구독자는 하나의 샤드에서만 키스페이스 이벤트를 받기 때문에 키스페이스 이벤트가 샤드 간에 복제되지 않습니다. 단일 노드 Redis를 사용하여 키스페이스 이벤트 손실을 피할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/cluster.html)"
"Redis Cluster에서 모든 키를 가져오려면 어떻게 해야 하나요?","Redis Cluster에서 모든 키를 가져오려면 클러스터의 모든 알려진 마스터 노드의 키를 읽어야 합니다. 이를 위해 RedisClusterConnection의 keys() 메서드를 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/cluster.html)"
"스프링 데이터 리뎀스에서 리뎀 해시를 어떻게 매핑할 수 있나요?","스프링 데이터 리뎀스에서는 리뎀 해시 매핑을 위해 HashMapper를 사용할 수 있습니다. HashMapper는 객체를 Map<K, V>로 변환하고 다시 객체로 변환하는 기능을 제공합니다. HashMapper는 BeanUtilsHashMapper, ObjectHashMapper, Jackson2HashMapper 등 다양한 구현체를 제공합니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#redis:hashmappers)"
"Jackson2HashMapper는 어떤 경우에 사용하나요?","Jackson2HashMapper는 FasterXML Jackson 라이브러리를 사용하여 도메인 객체를 리뎀 해시로 매핑할 수 있습니다. Jackson2HashMapper는 최상위 속성을 해시 필드 이름으로 매핑하고, 선택적으로 구조를 평평하게 만들 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#redis:hashmappers)"
"리뎀 해시 매핑에서 플랫팅(flattening)이란 어떤 의미인가요?","플랫팅은 해시 매퍼에서 중첩된 속성을 개별 해시 항목으로 생성하고, 가능한 한 복잡한 타입을 간단한 타입으로 변환하는 과정을 말합니다. 플랫팅된 해시는 다시 객체로 매핑할 수 없습니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#redis:hashmappers)"
"Spring Data는 Redis 메시징을 위해 어떤 패키지를 제공하나요?","org.springframework.data.redis.connection 및 org.springframework.data.redis.listener 패키지는 Redis 메시징의 핵심 기능을 제공합니다."
"Redis 메시징에서 메시지 제작에 사용되는 클래스는 무엇인가요?","RedisTemplate 클래스는 메시지 제작에 사용됩니다."
"Redis 메시징에서 메시지 구독을 구현하기 위해 어떤 인터페이스를 구현해야 하나요?","MessageListener 콜백을 구현해야 합니다."
"Spring Data Redis에서 스크립트를 실행하는 데 사용되는 기본 스크립트 실행기는 어떤 역할을 수행하나요?","기본 ScriptExecutor(../api/java/org/springframework/data/redis/core/script/ScriptExecutor.html) (또는 ReactiveScriptExecutor(../api/java/org/springframework/data/redis/core/script/ReactiveScriptExecutor.html) )는 제공된 스크립트를 실행하고, 제공된 키와 인자를 직렬화하고 스크립트 결과를 역직렬화하는 작업을 처리합니다. 이 작업은 템플릿의 키 및 값 직렬화기를 통해 수행됩니다. 또한, 스크립트의 SHA1을 검색하여 Redis 스크립트 캐시에 이미 있는 경우 evalsha를 실행하고, 그렇지 않은 경우 eval로 전환하여 성능을 최적화합니다."
"Spring Data Redis에서 스크립트 실행 시 사용자 정의 직렬화기를 사용하는 방법은 무엇인가요?","Spring Data Redis에서 스크립트 실행 시 사용자 정의 직렬화기를 사용하려면, RedisTemplate 및 ReactiveRedisTemplate의 execute 메서드에 제공된 스크립트 인자 및 결과에 대한 사용자 정의 직렬화기를 전달할 수 있는 추가 오버로드를 사용하면 됩니다."
"Spring Data Redis에서 Redis 스크립트를 주기적으로 실행하려면 어떻게 해야 하나요?","Spring Data Redis에서 Redis 스크립트를 주기적으로 실행하려면 Spring Task 및 Scheduler 추상화를 사용하여 스크립트를 예약할 수 있습니다. 자세한 내용은 Spring Framework(https://spring.io/projects/spring-framework/) 문서를 참조하십시오."
"Redis 트랜잭션(transaction)은 어떤 역할을 하나요?","Redis 트랜잭션은 여러 개의 Redis 명령어를 하나의 단위로 묶어서 처리하는 기능을 제공합니다. 이를 통해 원자성(atomicity), 일관성(consistency), 고립성(isolation), 지속성(durability)을 보장할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#transactions)"
"Redis 트랜잭션을 Spring Data Redis에서 어떻게 사용할 수 있나요?","Redis 트랜잭션을 Spring Data Redis에서 사용하려면 RedisTemplate의 multi, exec, discard 명령어를 사용하면 됩니다. 또한, SessionCallback 인터페이스를 사용하여 여러 개의 작업을 동일한 연결에서 수행할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#transactions)"
"Spring Data Redis에서 Redis 트랜잭션을 사용하려면 어떻게 설정해야 하나요?","RedisTemplate에서 transaction support를 명시적으로 활성화하고, RedisConnection을 현재 트랜잭션에 바인딩해야 합니다. 이를 통해 RedisTemplate은 @Transactional 또는 TransactionTemplate을 사용할 때 Redis 트랜잭션을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#transactions)"
"Spring Data Redis에서 파이프라이닝이란 무엇이며 어떤 상황에서 성능 향상을 제공할 수 있나요?","Spring Data Redis에서 파이프라이닝은 Redis 서버에 여러 명령을 보내고 응답을 기다리지 않고 한 번에 읽는 것을 의미합니다. 파이프라이닝은 여러 명령을 연속적으로 보내야 할 때 성능을 향상시킬 수 있으며, 예를 들어 동일한 리스트에 여러 요소를 추가해야 할 때 유용합니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/pipelining.html)"
"Spring Data Redis에서 파이프라인을 사용하여 RedisCallback을 실행하는 방법은 무엇인가요?","Spring Data Redis에서 파이프라인을 사용하여 RedisCallback을 실행하려면, executePipelined 메서드를 사용하면 됩니다. 이 메서드는 RedisCallback을 매개변수로 받아들이며, 파이프라인에서 제공된 RedisCallback을 실행하고 결과를 반환합니다. 예를 들어, 큐에서 지정된 개수의 항목을 일괄적으로 pop하는 파이프라인을 실행하려면, RedisCallback에서 여러 번 rPop 명령을 호출하면 됩니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/pipelining.html)"
"Lettuce 드라이버에서 파이프라인 플러시 정책이란 무엇이며, 이를 구성하는 방법은 무엇인가요?","Lettuce 드라이버에서 파이프라인 플러시 정책은 파이프라인 플러시 동작을 제어하는 것을 의미합니다. flushPolicy를 사용하여 파이프라인 플러시 정책을 구성할 수 있습니다. 예를 들어, PipeliningFlushPolicy.buffered(3)을 사용하여 로컬에 버퍼링하고 3번째 명령마다 플러시하도록 설정할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/pipelining.html)"
"스프링 데이터 리포지토리 추상화의 목표는 무엇인가요?","스프링 데이터 리포지토리 추상화의 목표는 다양한 지속성 저장소에 대한 데이터 액세스 레이어를 구현하는 데 필요한 보일러플레이트 코드의 양을 크게 줄이는 것입니다. (출처: {https://docs.spring.io/spring-data/redis/reference/3.3/repositories.html})"
"리디스 리포지토리를 사용할 때 어떤 기능을 사용할 수 있나요?","리디스 리포지토리를 사용하면 도메인 객체를 리디스 해시로 매끄럽게 변환하고 저장할 수 있으며, 사용자 정의 매핑 전략을 적용하고 보조 인덱스를 사용할 수 있습니다. (출처: {https://docs.spring.io/spring-data/redis/reference/3.3/repositories.html})"
"리디스 리포지토리를 사용하려면 어떤 버전의 리디스 서버가 필요한가요?","리디스 리포지토리를 사용하려면 최소 리디스 서버 버전 2.8.0이 필요합니다. (출처: {https://docs.spring.io/spring-data/redis/reference/3.3/repositories.html})"
"Spring Data에서 Repository 인터페이스는 어떤 역할을 하며, 어떤 정보를 캡처하는 역할을 하나요?","Spring Data에서 Repository 인터페이스는 Spring Data repository 추상화의 중심 인터페이스로, 관리할 도메인 클래스와 도메인 클래스의 식별자 타입을 타입 인자로 받습니다. 이 인터페이스는 주로 작업할 타입을 캡처하고, 이 인터페이스를 확장하는 인터페이스를 발견하는 역할을 합니다. (출처: https://docs.spring.io/spring-data/commons/docs/3.3.4/api//org/springframework/data/repository/Repository.html)"
"CrudRepository 인터페이스는 어떤 기능을 제공하며, 어떤 메서드를 포함하고 있나요?","CrudRepository 인터페이스는 관리되는 엔티티 클래스에 대한 정교한 CRUD 기능을 제공하며, save(), findById(), findAll(), count(), delete(), existsById() 등의 메서드를 포함합니다. (출처: https://docs.spring.io/spring-data/commons/docs/3.3.4/api//org/springframework/data/repository/CrudRepository.html)"
"Spring Data에서 Entity 정보 추상화에 대한 옵션은 무엇이며, 사용자 정의 EntityInformation 구현을 어떻게 설정하나요?","Spring Data에서 Entity 정보 추상화에 대한 옵션으로는 @Id 속성 검사, @Version 속성 검사, Persistable 구현, 사용자 정의 EntityInformation 구현 등이 있습니다. 사용자 정의 EntityInformation 구현을 설정하기 위해서는 모듈별 리포지토리 팩토리의 하위 클래스를 생성하고 getEntityInformation(…) 메서드를 오버라이드하여 사용자 정의 모듈별 리포지토리 팩토리의 구현을 Spring 빈으로 등록해야 합니다. (출처: https://docs.spring.io/spring-data/commons/docs/3.3.4/reference/html/)"
"스프링 데이터에서 저장소 인터페이스를 정의하는 방법은 무엇인가요?","저장소 인터페이스를 정의하려면, 도메인 클래스별 저장소 인터페이스를 정의해야 합니다. 이 인터페이스는 Repository를 상속해야 하며, 도메인 클래스와 ID 타입에 대해 타입이 지정되어야 합니다. 해당 도메인 타입에 대한 CRUD 메서드를 노출하려면, Repository 대신 CrudRepository 또는 그 변형 중 하나를 상속할 수 있습니다."
"스프링 데이터에서 저장소 인터페이스 확장은 어떤 방법이 있나요?","저장소 인터페이스를 확장하는 몇 가지 방법이 있습니다. 일반적인 접근 방식은 CrudRepository를 상속하는 것입니다. 이렇게 하면 CRUD 기능을 위한 메서드가 제공됩니다. CRUD는 Create, Read, Update, Delete의 약자입니다. 또한, 다양한 저장소 인터페이스를 확장하여 Sort 추상화를 지정할 수 있는 메서드가 필요한 경우 PagingAndSortingRepository, ReactiveSortingRepository, RxJava3SortingRepository 또는 CoroutineSortingRepository를 상속할 수 있습니다."
"스프링 데이터에서 여러 개의 Spring Data 모듈을 사용하는 저장소의 사용은 어떻게 되나요?","스프링 데이터는 엄격한 저장소 구성 모드로 진입합니다. 엄격한 구성은 저장소 또는 도메인 클래스에 대한 세부 정보를 사용하여 저장소 정의에 대한 Spring Data 모듈 바인딩을 결정합니다. 도메인 클래스가 모듈별 타입 어노테이션으로 주석 처리된 경우 해당 Spring Data 모듈의 유효한 후보입니다. Spring Data 모듈은 타사 어노테이션(예: JPA의 @Entity) 또는 자체 어노테이션(예: Spring Data MongoDB 및 Spring Data Elasticsearch의 @Document)을 허용합니다."
"Java Configuration에서 repository 활성화를 위한 설정 방법을 나타내는 데 사용되는 annotation은 무엇인가요?","@EnableRedisRepositories (출처: https://docs.spring.io/spring-data/redis/reference/3.3/repositories/create-instances.html)"
"XML Configuration에서 Spring Data repositories를 활성화하는 데 사용되는 요소는 무엇인가요?","repositories (출처: https://docs.spring.io/spring-data/redis/reference/3.3/repositories/create-instances.html)"
"Spring Data repositories에서 filter elements를 사용하는 목적은 무엇인가요?","repository로 인스턴스화되는 인터페이스를 더 세밀하게 제어할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/repositories/create-instances.html)"
"Spring Data Redis에서 도메인 엔티티를 구현하는 방법은 무엇인가요?","Spring Data Redis에서 도메인 엔티티를 구현하려면 @RedisHash 및 @Id 어노테이션을 사용하여 해시의 실제 키를 생성하는 데 필요한 id 속성을 지정해야 합니다. 그런 다음 CrudRepository를 확장하는 리포지토리 인터페이스를 정의하고 RedisConnectionFactory 및 RedisTemplate을 포함하는 Spring 구성을 설정해야 합니다. 마지막으로 리포지토리를 컴포넌트에 주입하여 CRUD 작업을 수행할 수 있습니다. (출처: <https://docs.spring.io/spring-data/redis/reference/html/>)"
"Spring Data Redis에서 참조를 사용하여 개체를 지속화하는 방법은 무엇인가요?","Spring Data Redis에서 참조를 사용하여 개체를 지속화하려면 @Reference 어노테이션을 사용하여 속성을 표시하면 됩니다. 참조된 객체는 참조되는 개체가 저장될 때 지속화되지 않으며, 참조만 저장됩니다. 참조된 유형의 속성에 설정된 인덱스는 해결되지 않습니다. (출처: <https://docs.spring.io/spring-data/redis/reference/html/>)"
"Spring Data Redis에서 부분 업데이트를 구현하는 방법은 무엇인가요?","Spring Data Redis에서 부분 업데이트를 구현하려면 PartialUpdate 클래스를 사용하여 기존 개체에 대한 설정 및 삭제 작업을 정의할 수 있습니다. 이를 통해 개체 자체 및 인덱스 구조의 잠재적인 만료 시간을 업데이트할 수 있습니다. 간단한 속성을 설정하거나 복잡한 개체 및 맵 구조를 설정하고 삭제할 수 있습니다. 부분 업데이트는 전체 엔티티를 다시 작성하는 것보다 느릴 수 있습니다. (출처: <https://docs.spring.io/spring-data/redis/reference/html/>)"
"스프링 데이터에서 객체 매핑이란 무엇인가요?","스프링 데이터에서 객체 매핑은 도메인 객체의 인스턴스를 생성하고, 스토어 네이티브 데이터 구조를 해당 객체에 매핑하는 것을 의미합니다. 이는 인스턴스 생성(object creation)과 필드 및 프로퍼티 액세스(field and property access)를 포함합니다. 객체 생성에는 퍼시스턴스 생성자, 정적 팩토리 메서드, 생성자 또는 빈 인자 생성자가 사용됩니다. 인스턴스 채우기(population)는 노출된 모든 프로퍼티를 구체화하기 위해 사용됩니다. 인스턴스 생성은 반사의 오버헤드를 피하기 위해, 스프링 데이터에서 기본적으로 런타임에 생성된 팩토리 클래스를 사용하여 도메인 클래스의 생성자를 직접 호출합니다."
"스프링 데이터에서 객체 생성에 영향을 미치는 제약 조건은 무엇인가요?","스프링 데이터에서 객체 생성에 영향을 미치는 제약 조건은 다음과 같습니다: 비공개 클래스, 정적이 아닌 내부 클래스, CGLib 프록시 클래스, 스프링 데이터에서 사용할 생성자가 비공개인 경우, 이러한 조건 중 하나라도 충족되면 스프링 데이터는 반사를 통해 엔티티 인스턴스화로 전환됩니다."
"스프링 데이터에서 프로퍼티 채우기(population)란 무엇인가요?","스프링 데이터에서 프로퍼티 채우기(population)는 엔티티의 인스턴스가 생성된 후, 해당 클래스의 모든 나머지 퍼시스턴트 프로퍼티를 설정하는 것을 의미합니다. 프로퍼티가 이미 엔티티의 생성자에 의해 채워지지 않은 경우(즉, 생성자 인자 목록을 통해 소비되지 않은 경우), 식별자 프로퍼티가 먼저 채워져 순환 객체 참조의 해결을 허용합니다. 그런 다음, 생성자에 의해 이미 채워지지 않은 모든 비일시적 프로퍼티가 엔티티 인스턴스에 설정됩니다."
"Redis Repository에서 Objects를 Hash로 지속시키기 위해 필요한 것은 무엇인가요?","Redis Repository에서 Objects를 Hash로 지속시키기 위해서는 Object-to-Hash 변환이 필요합니다. 이 변환은 RedisConverter를 통해 이루어지며, 기본 구현은 Converter를 사용하여 속성 값을 Redis의 기본 byte[]로 매핑합니다."
"Redis에서 Hash 표현으로 매핑되는 type은 어떻게 되나요?","Redis에서 Hash 표현으로 매핑되는 type은 Table 1. Default Mapping Rules에 설명되어 있습니다. 이 표는 Simple Type, Byte array ( byte[] ), Complex Type (for example, Address), List of Simple Type, Map of Simple Type, List of Complex Type, Map of Complex Type의 예시와 매핑된 값을 보여줍니다."
"Mapping behavior를 커스터마이징하려면 어떻게 해야 하나요?","Mapping behavior를 커스터마이징하려면 RedisCustomConversions에 해당하는 Converter를 등록하여 매핑할 수 있습니다. 이 Converter는 단일 byte[]와 Map<String, byte[]> 간의 변환을 처리할 수 있습니다. 더 자세한 제어를 위해서는 TypeInformationMapper 인터페이스와 MappingRedisConverter에서 구성할 수 있는 DefaultRedisTypeMapper를 살펴보세요."
"Spring Data Redis에서 keyspace를 구성하는 방법은 무엇인가요?","Spring Data Redis에서 keyspace를 구성하는 방법은 @EnableRedisRepositories 어노테이션을 사용하여 설정한 다음 MyKeyspaceConfiguration 클래스에서 keyspace를 정의하는 것입니다. 또는 RedisMappingContext 빈을 사용하여 keyspace를 프로그래밍 방식으로 설정할 수도 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/redis-repositories/keyspaces.html)"
"@EnableRedisRepositories 어노테이션을 사용하여 keyspace를 구성하는 방법은 무엇인가요?","@EnableRedisRepositories 어노테이션을 사용하여 keyspace를 구성하려면, keyspaceConfiguration 속성을 설정하여 MyKeyspaceConfiguration 클래스를 지정하면 됩니다. 이 클래스에서는 protected Iterable<KeyspaceSettings> initialConfiguration() 메소드를 오버라이드하여 keyspace를 정의할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/redis-repositories/keyspaces.html)"
"RedisMappingContext 빈을 사용하여 keyspace를 프로그래밍 방식으로 설정하는 방법은 무엇인가요?","RedisMappingContext 빈을 사용하여 keyspace를 프로그래밍 방식으로 설정하려면, keyValueMappingContext() 메소드를 오버라이드하여 새로운 RedisMappingContext 빈을 반환하면 됩니다. 이 빈은 새로운 MappingConfiguration과 MyKeyspaceConfiguration을 사용하여 생성됩니다. MyKeyspaceConfiguration 클래스에서는 protected Iterable<KeyspaceSettings> initialConfiguration() 메소드를 오버라이드하여 keyspace를 정의할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/redis-repositories/keyspaces.html)"
"Spring Data Redis에서 보조 인덱스는 어떻게 사용되나요?","Spring Data Redis에서 보조 인덱스는 기본 Redis 구조를 기반으로 조회 작업을 가능하게 합니다. 값은 모든 저장 작업 시 해당 인덱스에 작성되며, 객체가 삭제되거나 만료될 때 제거됩니다. 보조 인덱스의 생성은 @Indexed 어노테이션을 사용하여 실제 속성 값에 대한 인덱스를 빌드합니다. 또한, 중첩된 요소에 대한 인덱스를 프로그래밍 방식으로 설정할 수 있습니다. References에는 인덱스를 해결할 수 없습니다."
"Spring Data Redis에서 보조 인덱스를 프로그래밍 방식으로 설정하는 방법은 무엇인가요?","Spring Data Redis에서 보조 인덱스를 프로그래밍 방식으로 설정하려면 @EnableRedisRepositories 어노테이션을 사용하여 @RedisRepositories 또는 @EnableRedisRepositories 어노테이션과 함께 indexConfiguration 속성을 지정합니다. 그런 다음, IndexConfiguration 인터페이스를 구현하고 initialConfiguration 메서드를 재정의하여 초기 구성으로 Iterable<IndexDefinition>을 반환합니다."
"Spring Data Redis에서 지리 공간 인덱스는 어떻게 사용되나요?","Spring Data Redis에서 지리 공간 인덱스는 Point 유형의 위치를 포함하는 Address 유형의 속성에 @GeoIndexed 어노테이션을 사용하여 추가됩니다. 이렇게 하면 Spring Data Redis가 Redis GEO 명령을 사용하여 해당 값을 추가합니다. finder 메서드를 사용하여 Circle 또는 Point, Distance 조합을 사용하여 해당 값을 쿼리할 수 있습니다. 그러나 근처 및 범위와 다른 기준을 결합할 수는 없습니다."
"Redis에서 객체의 유효 기간을 설정하는 방법은 무엇인가요?","@RedisHash(timeToLive=...) 어노테이션과 KeyspaceConfiguration.KeyspaceSettings()를 사용하여 Redis에서 객체의 유효 기간을 설정할 수 있습니다. 더 유연한 유효 기간 설정은 @TimeToLife 어노테이션을 사용하여 숫자 속성이나 메서드에 적용할 수 있습니다. TTL(Time To Live) 값은 Redis에서 직접 읽히며, -1은 객체와 관련된 만료 시간이 없음을 나타냅니다. TTL이 양수 값으로 설정되면 해당 EXPIRE 명령이 실행됩니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#redis.repositories.expirations)"
"Redis에서 객체의 유효 기간이 만료되면 어떻게 되나요?","RedisKeyExpiredEvent가 발생하여 RedisKeyValueAdapter에서 처리됩니다. 기본적으로 키 만료 리스너는 애플리케이션 초기화 시 비활성화되어 있지만, @EnableRedisRepositories 또는 RedisKeyValueAdapter에서 시작 모드를 조정하여 리스너를 시작하거나 TTL이 있는 엔티티가 처음 삽입될 때 시작할 수 있습니다. TTL이 있는 엔티티가 처음 삽입될 때 리스너를 시작하면 RedisKeyExpiredEvent 게시가 영향을 받을 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#redis.repositories.expirations)"
"RedisKeyValueAdapter에서 @EnableKeyspaceEvents(shadowCopy = OFF)를 설정하면 어떤 영향이 있나요?","유령 복사본의 저장이 비활성화되고 Redis 내의 데이터 크기가 줄어듭니다. RedisKeyExpiredEvent에는 만료된 키의 ID만 포함됩니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#redis.repositories.expirations)"
"Redis 저장소에서 쿼리 메서드는 어떤 역할을 하며, 예를 들어 설명해주세요.","Redis 저장소에서 쿼리 메서드는 쿼리 메서드 이름에서 간단한 찾기 쿼리를 자동으로 유도하는 역할을 합니다. 예를 들어, `findByFirstname(String firstname)`와 같은 메서드는 'firstname'이라는 속성을 기준으로 엔티티를 검색하는 쿼리를 생성합니다. 그러나 찾기 메서드에서 사용되는 속성은 인덱싱을 위해 설정되어 있어야 합니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/redis-repositories/queries.html)"
"Redis 저장소에서 RedisCallback을 사용하는 이유는 무엇인가요?","Redis 저장소에서 RedisCallback을 사용하는 이유는 인덱스 구조 또는 사용자 지정 인덱스의 실제 일치를 더 세밀하게 제어할 수 있기 때문입니다. RedisCallback은 단일 또는 Iterable 집합의 id 값을 반환하는 콜백을 제공하여 이를 수행합니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/redis-repositories/queries.html)"
"Redis 저장소에서 정렬된 쿼리 결과를 얻기 위한 두 가지 접근 방식은 무엇인가요?","Redis 저장소에서 정렬된 쿼리 결과를 얻기 위한 두 가지 접근 방식은 메서드 이름에서 정렬을 유도하는 정적 정렬과 메서드 인수를 사용하는 동적 정렬입니다. 정적 정렬은 메서드 이름에서 유도된 정렬 순서를 사용하고, 동적 정렬은 Sort 객체를 인수로 사용하여 결과를 정렬하는 데 사용됩니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/redis-repositories/queries.html)"
"쿼리 바이 예제(Query by Example)란 무엇이며, 어떤 장점이 있나요?","쿼리 바이 예제(Query by Example, QBE)는 사용자 친화적인 쿼리 기법으로, 간단한 인터페이스를 제공합니다. 동적 쿼리 생성이 가능하며, 필드 이름이 포함된 쿼리를 작성할 필요가 없습니다. 쿼리 바이 예제는 도메인 객체의 실제 예제와 ExampleMatcher를 사용하여 예제를 생성하고, FetchableFluentQuery를 사용하여 쿼리를 추가로 사용자 정의할 수 있습니다. QBE는 데이터 저장소에서 정적 또는 동적 제약 조건을 사용하여 데이터를 쿼리하는 데 적합하며, 기존 쿼리를 깨뜨리지 않고 도메인 객체의 빈번한 리팩토링을 가능하게 합니다. 또한, 기본 데이터 저장소 API와 독립적으로 작동합니다. 그러나 중첩 또는 그룹화된 속성 제약 조건, 문자열 일치에 대한 저장소별 지원과 같은 몇 가지 제한 사항이 있습니다. 시작하려면 도메인 객체를 만들고, 리포지토리 인터페이스를 확장하여 QBE를 사용해야 합니다. 예제 매치러는 문자열 일치, 널 처리 및 속성별 설정에 대한 사용자 지정 기본값을 지정하는 데 사용할 수 있습니다. FetchableFluentQuery의 유동적인 API를 사용하여 정렬, 투영 및 결과 처리를 지정할 수 있습니다. QBE는 리포지토리 인터페이스를 사용하여 실행됩니다."
"쿼리 바이 예제에서 Probe, ExampleMatcher, Example 및 FetchableFluentQuery의 역할은 무엇인가요?","Probe는 채워진 필드를 가진 도메인 객체의 실제 예제입니다. ExampleMatcher는 특정 필드를 일치시키는 방법에 대한 세부 정보를 전달합니다. 여러 예제에서 재사용할 수 있습니다. Example은 프로브와 ExampleMatcher로 구성되며, 쿼리를 생성하는 데 사용됩니다. FetchableFluentQuery는 유동적인 API를 제공하여 예제에서 파생된 쿼리를 추가로 사용자 정의할 수 있습니다. 유동적인 API를 사용하면 쿼리에 대한 정렬, 투영 및 결과 처리를 지정할 수 있습니다."
"쿼리 바이 예제에서 문자열 일치에 대한 저장소별 지원은 어떻게 되나요?","문자열 일치에 대한 저장소별 지원은 데이터베이스에 따라 다를 수 있습니다. 문자열에 대해 시작/포함/끝/정규식을 지원하는 경우도 있고, 다른 속성 유형에 대해 정확한 일치를 지원하는 경우도 있습니다. 데이터베이스마다 문자열 일치에 대한 지원 수준이 다르므로, 사용하는 데이터베이스의 문서를 참조하여 자세한 정보를 확인해야 합니다."
"Redis Repositories Anatomy에서 Redis를 스토어로 사용할 때의 낮은 수준의 API는 어떤 기능을 제공하나요?","Redis를 스토어로 사용할 때의 낮은 수준의 API는 보조 인덱스 및 쿼리 작업과 같은 높은 수준의 기능을 제공하지 않습니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/redis-repositories/anatomy.html)"
"Redis Repositories Anatomy에서 repository abstraction이 발행하는 명령어의 자세한 내용은 무엇인가요?","Redis Repositories Anatomy에서는 repository abstraction이 발행하는 명령어의 자세한 내용을 설명하여 잠재적인 성능 영향을 더 잘 이해할 수 있도록 합니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/redis-repositories/anatomy.html)"
"Redis Repositories Anatomy에서 Redis 저장소에서 엔티티를 저장하는 방법은 무엇인가요?","Redis Repositories Anatomy에서는 Redis 저장소에서 엔티티를 저장하기 위해 HMSET, SADD, SADD, SADD 명령어를 사용합니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/redis/redis-repositories/anatomy.html)"
"스프링 데이터에서 프로젝션이란 무엇이며, 어떤 용도로 사용되나요?","스프링 데이터에서 프로젝션은 리포지토리가 관리하는 어그리게이트 루트의 특정 속성을 기반으로 하는 프로젝션을 생성하는 것을 말합니다. 이는 관리되는 어그리게이트의 부분 뷰를 더 선택적으로 검색하기 위해 사용됩니다. 프로젝션은 엔티티의 타입 계층 구조 외부에 있는 타입입니다. 인터페이스 기반 프로젝션은 액세스할 속성에 대한 접근자 메서드를 노출하는 인터페이스를 선언하여 프로젝션의 결과로 검색할 속성을 제한하는 가장 쉬운 방법입니다. 닫힌 프로젝션은 타겟 어그리게이트의 속성과 정확히 일치하는 액세스자 메서드를 가진 프로젝션 인터페이스입니다. 열린 프로젝션은 @Value 어노테이션을 사용하여 새로운 값을 계산하는 액세스자 메서드를 가진 프로젝션 인터페이스입니다. 스프링 데이터는 이 경우 쿼리 실행 최적화를 적용할 수 없습니다. 왜냐하면 SpEL 표현식은 어그리게이트 루트의 모든 속성을 사용할 수 있기 때문입니다. 널 가능한 래퍼는 프로젝션 인터페이스의 게터에 사용할 수 있으며, 이는 향상된 널 안전성을 위해 사용됩니다. 현재 지원되는 래퍼 유형은 java.util.Optional, com.google.common.base.Optional, scala.Option, io.vavr.control.Option입니다. DTO 기반 프로젝션도 사용할 수 있습니다. DTO는 검색할 필드에 대한 속성을 보유하는 값 유형입니다. 이 경우 프록시링이 발생하지 않으며 중첩된 프로젝션을 적용할 수 없습니다. 동적 프로젝션도 사용할 수 있으며, 이는 호출 시간에 사용할 유형을 선택하는 것입니다."
"스프링 데이터에서 인터페이스 기반 프로젝션을 어떻게 사용하나요?","스프링 데이터에서 인터페이스 기반 프로젝션을 사용하려면, 액세스할 속성에 대한 액세스자 메서드를 노출하는 인터페이스를 선언하면 됩니다. 이 인터페이스는 엔티티의 타입 계층 구조 외부에 있어야 하며, 인터페이스에서 정의된 속성은 프로젝션의 결과로 검색할 속성과 정확히 일치해야 합니다. 그런 다음 리포지토리에 쿼리 메서드를 추가하여 인터페이스 기반 프로젝션을 사용할 수 있습니다. 쿼리 실행 엔진은 반환된 각 요소에 대해 런타임에 해당 인터페이스의 프록시 인스턴스를 만들고 노출된 메서드에 대한 호출을 대상 객체로 전달합니다."
"스프링 데이터에서 동적 프로젝션을 어떻게 사용하나요?","스프링 데이터에서 동적 프로젝션을 사용하려면, 쿼리 메서드의 매개변수로 Class 유형을 사용해야 합니다. 그런 다음 메서드는 어그리게이트를 그대로 또는 프로젝션이 적용된 상태로 얻는 데 사용할 수 있습니다. 쿼리 매개변수의 Class 유형은 동적 프로젝션 매개변수로 사용할 수 있는지 검사됩니다. 쿼리의 실제 반환 유형이 Class 매개변수의 제네릭 매개변수 유형과 동일한 경우, 일치하는 Class 매개변수는 쿼리 또는 SpEL 표현식 내에서 사용할 수 없습니다. Class 매개변수를 쿼리 인수로 사용하려면 다른 제네릭 매개변수를 사용해야 합니다. 예를 들어 Class<?>를 사용할 수 있습니다."
"스프링 데이터에서 커스텀 리포지토리 구현을 어떻게 생성하나요?","먼저, 커스텀 리포지토리 기능을 위한 프래그먼트 인터페이스와 구현체를 정의해야 합니다. 그런 다음, 리포지토리 인터페이스를 프래그먼트 인터페이스로 확장할 수 있습니다. 클래스 이름은 프래그먼트 인터페이스와 일치하는 부분이 가장 중요합니다. 구현체는 스프링 데이터에 의존하지 않으므로 일반적인 스프링 빈일 수 있습니다. 커스텀 구현체는 기본 구현체 및 리포지토리 측면보다 우선순위가 높습니다. 리포지토리 프래그먼트는 단일 리포지토리 인터페이스에서만 사용할 수 있는 것은 아닙니다. 여러 리포지토리에서 커스텀화를 재사용할 수 있습니다. 리포지토리 프래그먼트와 구현체를 정의할 수 있습니다. 리포지토리 인프라는 커스톰 구현체 프래그먼트를 자동으로 감지하려고 시도합니다. 구현체 빈은 이름에 따라 해결됩니다. 커스텀 구현체가 어노테이션 기반 구성 및 자동 배선만 사용하는 경우, 이는 다른 스프링 빈과 마찬가지로 처리되므로 작동합니다. 구현체 프래그먼트 빈에 특별한 배선이 필요한 경우, 해당 빈을 선언하고 이름에 대한 규칙에 따라 이름을 지정할 수 있습니다. 커스텀 리포지토리 기본 클래스를 생성하여 리포지토리 프록시의 커스텀 기본 클래스로 사용할 수 있습니다. 최종 단계는 커스텀화된 리포지토리 기본 클래스를 스프링 데이터 인프라에 알립니다. 이를 통해 리포지토리 동작을 커스터마이징할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/repositories/custom-implementations.html)"
"스프링 데이터에서 리포지토리 동작을 커스터마이징하는 방법은 무엇인가요?","먼저, 커스텀 리포지토리 기능을 위한 프래그먼트 인터페이스와 구현체를 정의해야 합니다. 그런 다음, 리포지토리 인터페이스를 프래그먼트 인터페이스로 확장할 수 있습니다. 클래스 이름은 프래그먼트 인터페이스와 일치하는 부분이 가장 중요합니다. 구현체는 스프링 데이터에 의존하지 않으므로 일반적인 스프링 빈일 수 있습니다. 커스텀 구현체는 기본 구현체 및 리포지토리 측면보다 우선순위가 높습니다. 리포지토리 프래그먼트는 단일 리포지토리 인터페이스에서만 사용할 수 있는 것은 아닙니다. 여러 리포지토리에서 커스텀화를 재사용할 수 있습니다. 리포지토리 프래그먼트와 구현체를 정의할 수 있습니다. 리포지토리 인프라는 구현체 프래그먼트를 자동으로 감지하려고 시도합니다. 구현체 빈은 이름에 따라 해결됩니다. 커스텀 구현체가 어노테이션 기반 구성 및 자동 배선만 사용하는 경우, 이는 다른 스프링 빈과 마찬가지로 처리되므로 작동합니다. 구현체 프래그먼트 빈에 특별한 배선이 필요한 경우, 해당 빈을 선언하고 이름에 대한 규칙에 따라 이름을 지정할 수 있습니다. 커스텀 리포지토리 기본 클래스를 생성하여 리포지토리 프록시의 커스텀 기본 클래스로 사용할 수 있습니다. 최종 단계는 커스텀화된 리포지토리 기본 클래스를 스프링 데이터 인프라에 알립니다. 이를 통해 리포지토리 동작을 커스터마이징할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/repositories/custom-implementations.html)"
"스프링 데이터에서 리포지토리 프래그먼트란 무엇인가요?","리포지토리 인프라는 구현체 프래그먼트를 자동으로 감지하려고 시도합니다. 이러한 클래스는 리포지토리를 찾은 패키지의 하위 클래스를 스캔해야 합니다. 이러한 클래스는 Impl로 기본 접미사를 추가하는 명명 규칙을 따라야 합니다. 리포지토리 프래그먼트는 단일 리포지토리 인터페이스에서만 사용할 수 있는 것은 아닙니다. 여러 리포지토리에서 커스텀화를 재사용할 수 있습니다. 리포지토리 프래그먼트와 구현체를 정의할 수 있습니다. 구현체 빈은 이름에 따라 해결됩니다. 커스텀 구현체가 어노테이션 기반 구성 및 자동 배선만 사용하는 경우, 이는 다른 스프링 빈과 마찬가지로 처리되므로 작동합니다. 구현체 프래그먼트 빈에 특별한 배선이 필요한 경우, 해당 빈을 선언하고 이름에 대한 규칙에 따라 이름을 지정할 수 있습니다. 커스텀 리포지토리 기본 클래스를 생성하여 리포지토리 프록시의 커스텀 기본 클래스로 사용할 수 있습니다. 최종 단계는 커스텀화된 리포지토리 기본 클래스를 스프링 데이터 인프라에 알립니다. 이를 통해 리포지토리 동작을 커스터마이징할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/repositories/custom-implementations.html)"
"Spring Data에서 @DomainEvents 어노테이션의 목적은 무엇인가요?","Spring Data에서 @DomainEvents 어노테이션은 애그리게이트 루트의 메서드에 사용하여 도메인 이벤트의 게재를 최대한 쉽게 만드는 데 사용됩니다. 이 어노테이션을 가진 메서드는 단일 이벤트 인스턴스 또는 이벤트 컬렉션을 반환할 수 있으며 인수를 받지 않아야 합니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#repository-events)"
"Spring Data에서 애그리게이트 루트에서 도메인 이벤트를 노출하는 방법은 무엇인가요?","Spring Data에서 애그리게이트 루트에서 도메인 이벤트를 노출하려면 @DomainEvents 어노테이션을 사용한 메서드를 만들어 단일 이벤트 인스턴스 또는 이벤트 컬렉션을 반환할 수 있습니다. 이 메서드는 인수를 받지 않아야 하며 애그리게이트 루트 클래스의 일부여야 합니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#repository-events)"
"Spring Data에서 도메인 이벤트가 모두 게시된 후에 호출되는 메서드는 무엇인가요?","@AfterDomainEventPublication 어노테이션을 사용한 메서드는 Spring Data에서 도메인 이벤트가 모두 게시된 후에 호출됩니다. 이 메서드는 게시될 이벤트 목록을 정리하는 데 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/redis/reference/html/#repository-events)"
"스프링 데이터에서 리포지토리 메소드의 반환값이 없을 때 어떻게 처리하나요?","스프링 데이터 2.0부터는 리포지토리 CRUD 메소드 중 개별 애그리게이트 인스턴스를 반환하는 메소드는 Java 8의 Optional을 사용하여 값의 부재 가능성을 나타냅니다. 또한, Spring Data는 쿼리 메소드에서 다음과 같은 래퍼 타입을 반환하는 것을 지원합니다: com.google.common.base.Optional, scala.Option, io.vavr.control.Option. 쿼리 메소드는 래퍼 타입을 전혀 사용하지 않을 수도 있습니다(https://docs.spring.io/spring-data/redis/reference/3.3/repositories/null-handling.html)."
"스프링에서 리포지토리 메소드의 nullability 제약 조건을 표현하는 방법은 무엇인가요?","스프링 프레임워크의 nullability 어노테이션을 사용하여 리포지토리 메소드의 nullability 제약 조건을 표현할 수 있습니다. 이들은 다음과 같이 툴링 친화적인 접근 방식과 런타임 중 opt-in null 체크를 제공합니다: @NonNullApi, @NonNull, @Nullable. 스프링 어노테이션은 JSR 305 어노테이션으로 메타 어노테이션이 지정되어 있습니다. JSR 305 메타 어노테이션은 툴링 공급업체가 스프링 어노테이션에 대한 지원을 하드 코딩하지 않고도 일반적인 방식으로 null-safety 지원을 제공할 수 있도록 합니다(https://docs.spring.io/spring-data/redis/reference/3.3/repositories/null-handling.html)."
"코틀린 기반 리포지토리에서 nullability 제약 조건을 사용하는 방법은 무엇인가요?","코틀린은 nullability 제약 조건을 언어에 내장하고 있습니다. 코틀린 코드는 메소드 시그니처를 통해 nullability 제약 조건을 표현하지 않고 컴파일된 메타데이터를 통해 표현합니다. 리포지토리에서 코틀린의 nullability 제약 조건을 적용하려면 kotlin-reflect JAR을 프로젝트에 포함해야 합니다. 스프링 데이터 리포지토리는 언어 메커니즘을 사용하여 이러한 제약 조건을 정의하고 동일한 런타임 검사를 적용합니다(https://docs.spring.io/spring-data/redis/reference/3.3/repositories/null-handling.html)."
"Spring Data Redis가 CDI 환경에서 리포지토리 추상화를 가능하게 하는 방법은 무엇인가요?","Spring Data Redis는 커스텀 CDI 확장을 함께 제공하여 CDI 환경에서 리포지토리 추상화를 사용할 수 있습니다. 확장은 JAR 파일의 일부로 제공되므로 Spring Data Redis JAR 파일을 클래스패스에 추가하여 활성화할 수 있습니다. RedisConnectionFactory와 RedisOperations에 대한 CDI Producers를 구현하여 인프라를 설정할 수 있습니다. CDI 컨테이너에서 리포지토리 유형의 빈을 요청할 때마다 Spring Data CDI 확장 기능은 사용 가능한 모든 리포지토리를 CDI 빈으로 가져와 Spring Data 리포지토리의 프록시를 생성합니다."
"Spring Data Redis가 RedisKeyValueAdapter 및 RedisKeyValueTemplate 빈을 관리하는 방법은 무엇인가요?","Redis 리포지토리는 RedisKeyValueAdapter 및 RedisKeyValueTemplate 인스턴스를 필요로 합니다. 이러한 빈은 제공된 빈이 없는 경우 Spring Data CDI 확장 기능에 의해 자동으로 생성되고 관리됩니다. 그러나 RedisKeyValueAdapter 및 RedisKeyValueTemplate의 특정 속성을 구성하기 위해 자체 빈을 제공할 수도 있습니다."
"CDI 통합에서 Spring Data Redis 리포지토리의 인스턴스를 얻는 방법은 무엇인가요?","CDI 통합에서 Spring Data Redis 리포지토리의 인스턴스를 얻는 방법은 @Injected 속성을 선언하여 CDI 컨테이너에서 리포지토리 유형의 빈을 요청하는 것입니다. 예를 들어, RepositoryClient 클래스에서 PersonRepository를 @Inject로 선언하면 @Inject된 PersonRepository의 인스턴스를 얻을 수 있습니다."
"스프링 데이터 리포지토리 쿼리 파싱 메커니즘에서 일반적으로 지원되는 쿼리 메소드 서브젝트 키워드는 무엇인가요?","find…By, read…By, get…By, query…By, search…By, stream…By, exists…By, count…By, delete…By, remove…By, …First<number>…, …Top<number>…, …Distinct입니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리 쿼리 파싱 메커니즘에서 일반적으로 지원되는 쿼리 메소드 프래디케이트 키워드는 무엇인가요?","AND, OR, AFTER, Before, CONTAINING, BETWEEN, ENDING_WITH, EXISTS, FALSE, GREATER_THAN, GREATER_THAN_EQUALS, IN, IS, IS_EMPTY, IS_NOT_EMPTY, IS_NOT_NULL, IS_NULL, LESS_THAN, LESS_THAN_EQUAL, LIKE, NEAR, NOT, NOT_IN, NOT_LIKE, REGEX, STARTING_WITH, TRUE, WITHIN 키워드가 일반적으로 지원됩니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리 쿼리 파싱 메커니즘에서 쿼리 프래디케이트 수정자로 지원되는 키워드는 무엇인가요?","IgnoreCase, IgnoringCase, AllIgnoreCase, AllIgnoringCase, OrderBy 키워드가 일반적으로 지원됩니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리에서 어떤 쿼리 반환 유형이 지원되나요?","스프링 데이터 리포지토리에서는 void, Java의 원시 유형, 래퍼 유형, T(고유한 엔티티), Iterator<T>, Collection<T>, List<T>, Optional<T>, Option<T>, Stream<T>, Types that implement Streamable and take a Streamable constructor or factory method argument, Vavr Seq, List, Map, Set, Future<T>, CompletableFuture<T>, Slice<T>, Page<T>, Window<T>, GeoResult<T>, GeoResults<T>, GeoPage<T>, Mono<T>, Flux<T>, Single<T>, Maybe<T>, Flowable<T> 등의 쿼리 반환 유형이 지원됩니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/repositories/query-return-types-reference.html)"
"스프링 데이터 리포지토리에서 Java 8의 Optional과 유사한 동작을 하는 Result wrapper type은 무엇인가요?","스프링 데이터 리포지토리에서 Java 8의 Optional과 유사한 동작을 하는 Result wrapper type은 Option<T>입니다. 이는 Scala 또는 Vavr Option type입니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/repositories/query-return-types-reference.html)"
"스프링 데이터 리포지토리에서 Future<T>를 반환하는 쿼리 메서드는 어떤 어노테이션을 사용해야 하나요?","스프링 데이터 리포지토리에서 Future<T>를 반환하는 쿼리 메서드는 @Async 어노테이션을 사용해야 합니다. 이 어노테이션은 비동기 메서드 실행을 위해 사용됩니다. 또한, 스프링의 비동기 메서드 실행 기능이 활성화되어 있어야 합니다. (출처: https://docs.spring.io/spring-data/redis/reference/3.3/repositories/query-return-types-reference.html)"
"Spring Data REST란 무엇이며 어떤 프로그래밍 모델을 사용하나요?","Spring Data REST는 Spring Data repositories를 WebMVC를 통해 REST 리소스로 노출시키는 프레임워크입니다. Spring Data 모듈을 기반으로 일관된 프로그래밍 모델을 사용하여 애플리케이션 개발을 용이하게 합니다. (출처: <https://docs.spring.io/spring-data/rest/reference/4.3/intro.html>)"
"Spring Data REST에서 도메인 객체 표현은 어떻게 이루어지나요?","Spring Data REST에서 도메인 객체 표현은 객체 매핑을 통해 이루어집니다. 도메인 객체는 JSON, XML 등의 형식으로 표현될 수 있습니다. (출처: <https://docs.spring.io/spring-data/rest/docs/current/reference/html/#representations>)"
"Spring Data REST에서 ETag와 헤더를 사용하여 조건부 작업을 어떻게 수행할 수 있나요?","Spring Data REST에서는 ETag와 기타 헤더를 사용하여 조건부 작업을 수행할 수 있습니다. 이를 통해 클라이언트는 특정 조건이 충족될 때만 작업을 수행하도록 지정할 수 있습니다. (출처: <https://docs.spring.io/spring-data/rest/docs/current/reference/html/#etags-and-other-conditionals>)"
"REST 웹 서비스란 무엇이며, Spring MVC와 Spring WebFlux는 이를 구현하는 데 어떻게 사용되나요?","REST 웹 서비스는 웹에서 애플리케이션 통합의 주요 수단이 되었습니다. Spring MVC와 Spring WebFlux는 이러한 종류의 서비스를 구축하기 위한 견고한 기반을 제공하지만, 멀티 도메인 객체 시스템에 대한 REST 웹 서비스의 가장 간단한 원칙을 구현하는 것은 지루하고 많은 보일러플레이트 코드를 생성할 수 있습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/intro.html#introduction-what-is-rest)"
"Spring Data REST는 무엇이며, 어떻게 REST 리소스로 내보내나요?","Spring Data REST는 Spring Data 저장소를 기반으로 구축되며, 저장소를 자동으로 REST 리소스로 내보냅니다. 이는 하이퍼미디어를 활용하여 클라이언트가 저장소에서 노출되는 기능을 자동으로 찾고, 이러한 리소스를 관련 하이퍼미디어 기반 기능에 통합할 수 있도록 합니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/intro.html#introduction-what-is-spring-data-rest)"
"Spring Data REST를 시작하는 방법은 무엇인가요?","Spring Data REST를 시작하려면, Spring Data REST 참조 가이드를 참조하여 업그레이드, 시작, cURL을 사용하여 Spring Data REST와 대화하고, Spring Data REST 예제 프로젝트를 찾을 수 있습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/intro.html#introduction-introduction)"
"스프링 데이터 업그레이드 방법은 어떻게 되나요?","스프링 데이터 업그레이드 방법은 프로젝트 위키(https://github.com/spring-projects/spring-data-commons/wiki)에서 제공됩니다. 릴리스 노트 섹션(https://github.com/spring-projects/spring-data-commons/wiki#release-notes)의 링크를 따라 원하는 버전으로 이동하십시오. 업그레이드 지침은 항상 릴리스 노트의 첫 번째 항목입니다. 한 개 이상의 릴리스를 건너뛰는 경우 건너뛴 버전의 릴리스 노트도 검토해야 합니다."
"스프링 데이터 업그레이드에 대한 자세한 내용은 어디에서 찾을 수 있나요?","스프링 데이터 업그레이드에 대한 자세한 내용은 프로젝트 위키(https://github.com/spring-projects/spring-data-commons/wiki)에서 찾을 수 있습니다. 릴리스 노트 섹션(https://github.com/spring-projects/spring-data-commons/wiki#release-notes)의 링크를 따라 원하는 버전으로 이동하십시오. 업그레이드 지침은 항상 릴리스 노트의 첫 번째 항목입니다. 한 개 이상의 릴리스를 건너뛰는 경우 건너뛴 버전의 릴리스 노트도 검토해야 합니다."
"스프링 데이터 업그레이드 시 이전 버전을 검토해야 하는 이유는 무엇인가요?","스프링 데이터 업그레이드 시 이전 버전을 검토해야 하는 이유는 한 개 이상의 릴리스를 건너뛰는 경우 건너뛴 버전의 릴리스 노트도 검토해야 하기 때문입니다. 이렇게 하면 중요한 변경 사항이나 버그 수정을 놓치지 않을 수 있습니다."
"스프링 부트 프로젝트에 스프링 데이터 REST를 추가하는 방법은 무엇인가요?","스프링 부트 프로젝트에 스프링 데이터 REST를 추가하는 가장 간단한 방법은 스프링 데이터 REST 스타터와 자동 구성을 사용하는 스프링 부트 애플리케이션을 빌드하는 것입니다. 다음 예제는 Gradle을 사용하여 스프링 부트 프로젝트에 스프링 데이터 REST를 포함하는 방법을 보여줍니다. 예제 1. Gradle dependencies { ... compile('org.springframework.boot:spring-boot-starter-data-rest') ... }"
"Gradle 기반 프로젝트에 스프링 데이터 REST를 추가하는 방법은 무엇인가요?","Gradle 기반 프로젝트에 스프링 데이터 REST를 추가하려면 compile-time 종속성에 spring-data-rest-webmvc 아티팩트를 추가하십시오. dependencies { … 다른 프로젝트 종속성 compile('org.springframework.data:spring-data-rest-webmvc:4.3.4') }"
"스프링 데이터 REST의 기본 설정을 어떻게 변경하나요?","스프링 데이터 REST를 구성할 때 다음과 같은 기본 설정을 수정할 수 있습니다. 저장소 감지 전략 설정, 기본 URI 변경, 기타 스프링 데이터 REST 속성 변경 등입니다. 기본 URI를 변경하려면 Spring Boot 1.2 이상을 사용하는 경우 application.properties에 단일 속성을 설정하여 기본 URI를 변경할 수 있습니다. spring.data.rest.basePath=/api"
"Spring Data REST에서 cURL을 사용하여 Neo4j 데이터에 REST로 접근하는 방법은 무엇인가요?","Spring Data REST에서 cURL을 사용하여 Neo4j 데이터에 REST로 접근하려면, https://spring.io/guides/gs/accessing-neo4j-data-rest/에서 제공하는 가이드를 따르세요. 이 가이드에서는 cURL을 사용하여 Spring Data REST 서비스와 상호 작용하는 방법을 설명합니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/introduction/example-api-usage-with-curl.html)"
"Spring Data REST에서 MongoDB 데이터에 REST로 접근하는 예시는 어떤 가이드에서 확인할 수 있나요?","Spring Data REST에서 MongoDB 데이터에 REST로 접근하는 예시는 https://spring.io/guides/gs/accessing-mongodb-data-rest/에서 확인할 수 있습니다. 이 가이드는 cURL을 사용하여 Spring Data REST 서비스와 상호 작용하는 방법을 설명합니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/introduction/example-api-usage-with-curl.html)"
"Spring Data REST에서 cURL을 사용하여 GemFire 데이터에 REST로 접근하는 방법은 어떤 가이드에서 확인할 수 있나요?","Spring Data REST에서 cURL을 사용하여 GemFire 데이터에 REST로 접근하려면, https://spring.io/guides/gs/accessing-gemfire-data-rest/에서 제공하는 가이드를 따르세요. 이 가이드에서는 cURL을 사용하여 Spring Data REST 서비스와 상호 작용하는 방법을 설명합니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/introduction/example-api-usage-with-curl.html)"
"스프링 데이터 REST에서 어떤 핵심 아티팩트를 살펴보거나 커스터마이징하여 리소스 노출 방식을 설정할 수 있나요?","리포지토리 인터페이스(Source: <https://docs.spring.io/spring-data/rest/reference/4.3/repository-resources.html>)"
"Spring Data REST에서 컬렉션 리소스란 무엇이며, 어떤 HTTP 메서드를 지원하나요?","컬렉션 리소스는 내보낸 리포지토리가 처리하는 도메인 클래스의 소문자화된 복수형 이름과 일치하는 이름을 가진 리소스입니다. GET 및 POST 메서드를 지원합니다. (출처: <https://docs.spring.io/spring-data/rest/reference/4.3/repository-resources.html>)"
"Spring Data REST에서 연관 리소스란 무엇이며, 어떤 HTTP 메서드를 지원하나요?","연관 리소스는 항목 리소스의 각 연관 리소스에 대한 하위 리소스입니다. GET, PUT, POST 및 DELETE 메서드를 지원합니다. (출처: <https://docs.spring.io/spring-data/rest/reference/4.3/repository-resources.html>)"
"스프링 데이터 리포지토리 페이징 및 정렬 추상화를 사용하는 방법은 무엇인가요?","스프링 데이터 REST는 Spring Data Repository paging and sorting abstractions를 사용합니다. 이러한 기능을 익히려면 사용하는 리포지토리 구현(예: Spring Data JPA)에 대한 Spring Data 문서를 참조하십시오."
"스프링 데이터 REST에서 페이징을 구현하려면 어떻게 해야 하나요?","PagingAndSortingRepository<T, ID>를 확장하고 모든 엔티티의 목록에 액세스하면 첫 번째 20개 엔티티에 대한 링크가 제공됩니다. 페이지 크기를 다른 숫자로 설정하려면 다음과 같이 size 매개변수를 추가하십시오: <http://localhost:8080/people/?size=5>."
"스프링 데이터 REST에서 정렬을 구현하려면 어떻게 해야 하나요?","리포지토리 정렬 지원을 사용하는 정렬 매개변수를 인식하려면 결과를 정렬할 속성 이름을 가진 sort URL 매개변수를 추가하십시오. 정렬 방향을 제어하려면 속성 이름에 쉼표(,)를 추가하고 asc 또는 desc를 추가하십시오."
"스프링 데이터 REST에서 프로젝션과 발췌란 무엇인가요?","프로젝션과 발췌는 스프링 데이터 REST에서 도메인 모델의 뷰를 단순화하고 축소하여 제공하는 방법입니다. 프로젝션은 자바 인터페이스를 사용하여 리소스의 단순화된 뷰를 정의하는 것이고, 발췌는 컬렉션에 대해 프로젝션을 자동으로 적용하는 것입니다. 이들은 링크를 따라가야 하는 필요성을 줄이고, API의 성능을 향상시키는 데 사용될 수 있습니다."
"프로젝션과 발췌의 차이점은 무엇인가요?","프로젝션은 자바 인터페이스를 사용하여 리소스의 단순화된 뷰를 정의하는 것이고, 발췌는 컬렉션에 대해 프로젝션을 자동으로 적용하는 것입니다. 프로젝션은 리소스의 뷰를 단순화하고 축소하여 제공하는 데 사용되며, 발췌는 컬렉션에 대해 프로젝션을 자동으로 적용하여 기본 미리보기를 제공하는 데 사용됩니다."
"스프링 데이터 REST에서 프로젝션을 정의하는 방법은 무엇인가요?","스프링 데이터 REST에서 프로젝션을 정의하려면 @Projection 어노테이션을 사용하여 자바 인터페이스를 만듭니다. 이 인터페이스는 리소스에서 노출하려는 속성 및 메서드의 선언을 포함합니다. 그런 다음, @Projection 어노테이션을 사용하여 프로젝션 인터페이스를 리포지토리에 연결하고, 쿼리 매개변수를 사용하여 리소스 뷰에 적용할 수 있습니다."
"스프링 데이터 REST에서 도메인 객체 표현은 HTTP 요청의 Accept 타입에 따라 어떻게 반환되나요?","스프링 데이터 REST는 HTTP 요청의 Accept 타입에 따라 도메인 객체의 표현을 반환합니다. 현재는 JSON 표현만 지원되지만, 적절한 컨버터를 추가하고 컨트롤러 메서드를 적절한 콘텐츠 타입으로 업데이트하여 향후 다른 표현 타입을 지원할 수 있습니다. (출처: <https://docs.spring.io/spring-data/rest/reference/4.3/representations.html>)"
"스프링 데이터 REST에서 ObjectMapper의 동작이 도메인 모델을 올바르게 처리하지 못하는 경우 어떻게 해결할 수 있나요?","ObjectMapper에 사용자 정의 매퍼, 직렬화기 및 역직렬화기를 구성하여 도메인 모델을 올바르게 처리할 수 있습니다. 또한, 추상 클래스나 인터페이스를 사용하는 경우, Module을 사용하여 타입 매핑을 등록해야 합니다. (출처: <https://docs.spring.io/spring-data/rest/reference/4.3/representations.html>)"
"스프링 데이터 REST에서 커스텀 직렬화기 및 역직렬화기를 추가하는 방법은 무엇인가요?","configureJacksonObjectMapper 메서드를 오버라이드하여 ObjectMapper 인스턴스에 사용자 정의 모듈을 등록하여 커스텀 직렬화기 및 역직렬화기를 추가할 수 있습니다. setupModule 메서드 구현에서 직렬화기를 추가하고 이를 컨텍스트에 추가할 수 있습니다. (출처: <https://docs.spring.io/spring-data/rest/reference/4.3/representations.html>)"
"Spring Data REST에서 버전 필드를 가진 POJO의 ETag 헤더 값은 무엇인가요?","Spring Data REST에서 버전 필드를 가진 POJO의 ETag 헤더 값은 버전 필드의 값입니다. 이는 제공된 예제의 POJO가 REST 리소스로 제공될 때 ETag 헤더를 가지는 Example 1에서 확인할 수 있습니다."
"If-Modified-Since 헤더의 사용 목적은 무엇인가요?","If-Modified-Since 헤더는 마지막 요청 이후 리소스가 수정되었는지 확인하는 데 사용됩니다. 이를 통해 애플리케이션은 동일한 데이터를 다시 전송하지 않을 수 있습니다. 이는 제공된 예제의 마지막 수정 날짜가 도메인 유형에 캡처되어 있는 Example 2에서 확인할 수 있습니다."
"Spring Data REST에서 ETag 요소를 사용하여 더 효율적인 프론트 엔드를 설계하려면 어떤 단계를 따라야 하나요?","Spring Data REST에서 ETag 요소를 사용하여 더 효율적인 프론트 엔드를 설계하려면 잠금이 필요한 엔티티를 식별하고 버전 속성을 추가하고, 가장 최근 업데이트를 추적하는 데 도움이 되는 항목을 식별하고 Last-Modified 값을 저장하고, 리소스를 가져올 때 self URIs를 DOM 노드에 포함시키고, If-Match를 사용하여 PUT/PATCH/DELETE 작업을 조정하고 HTTP 412 Precondition Failed 상태 코드를 처리하며, If-None-Match 및 If-Modified-Since를 사용하여 GET 작업을 조정하고 HTTP 304 Not Modified 상태 코드를 처리해야 합니다. 이는 제공된 아키텍처 섹션에서 설명되어 있습니다."
"Spring Data REST에서 Validator 인스턴스를 등록하는 방법은 무엇인가요?","Spring Data REST에서 Validator 인스턴스를 등록하는 방법은 두 가지가 있습니다. 첫 번째 방법은 bean 이름으로 연결하는 것이고, 두 번째 방법은 수동으로 validator를 등록하는 것입니다. 대부분의 경우에는 간단한 bean 이름 접두사 스타일이 충분합니다. Spring Data REST에 특정 Validator를 특정 이벤트에 할당하려면 해당 이벤트와 함께 bean 이름을 접두사로 지정합니다. 예를 들어, Person 클래스의 인스턴스를 저장하기 전에 유효성을 검사하려면 beforeCreatePersonValidator라는 bean 이름으로 ApplicationContext에 Validator<Person>의 인스턴스를 선언합니다. beforeCreate 접두사는 알려진 Spring Data REST 이벤트와 일치하므로 해당 유효성 검사기가 올바른 이벤트에 연결됩니다."
"Spring Data REST에서 Validator를 수동으로 등록해야 하는 경우는 어떤 경우인가요?","bean 이름 접두사 접근 방식을 사용하지 않으려면 올바른 이벤트 후에 유효성 검사기를 호출하는 역할을 하는 bean에 유효성 검사기의 인스턴스를 등록해야 합니다. RepositoryRestConfigurer를 구현하는 구성에서 configureValidatingRepositoryEventListener 메서드를 재정의하고 ValidatingRepositoryEventListener의 addValidator를 호출하여 이 유효성 검사기를 트리거하려는 이벤트와 유효성 검사기의 인스턴스를 전달합니다. 다음 예제는 이를 보여주는 방법입니다: @Override void configureValidatingRepositoryEventListener(ValidatingRepositoryEventListener v) { v.addValidator('beforeSave', new BeforeSaveValidator()); }"
"Spring Data REST에서 Validator를 수동으로 등록하는 방법은 무엇인가요?","bean 이름 접두사 접근 방식을 사용하지 않으려면 올바른 이벤트 후에 유효성 검사기를 호출하는 역할을 하는 bean에 유효성 검사기의 인스턴스를 등록해야 합니다. RepositoryRestConfigurer를 구현하는 구성에서 configureValidatingRepositoryEventListener 메서드를 재정의하고 ValidatingRepositoryEventListener의 addValidator를 호출하여 이 유효성 검사기를 트리거하려는 이벤트와 유효성 검사기의 인스턴스를 전달합니다. 다음 예제는 이를 보여주는 방법입니다: @Override void configureValidatingRepositoryEventListener(ValidatingRepositoryEventListener v) { v.addValidator('beforeSave', new BeforeSaveValidator()); }"
"스프링 데이터 REST의 이벤트 유형은 어떤 것이 있나요?","스프링 데이터 REST의 이벤트 유형은 BeforeCreateEvent, AfterCreateEvent, BeforeSaveEvent, AfterSaveEvent, BeforeLinkSaveEvent, AfterLinkSaveEvent, BeforeDeleteEvent, AfterDeleteEvent 총 8가지입니다. (출처: <https://docs.spring.io/spring-data/rest/reference/4.3/events.html>)"
"스프링 데이터 REST에서 이벤트 리스너를 작성하는 방법은 무엇인가요?","스프링 데이터 REST에서 이벤트 리스너를 작성하는 방법은 AbstractRepositoryEventListener를 상속받아 해당 이벤트의 메서드를 오버라이딩하여 이벤트를 처리하는 방법을 구현하는 것입니다. (출처: <https://docs.spring.io/spring-data/rest/reference/4.3/events.html>)"
"스프링 데이터 REST에서 어노테이션을 사용한 핸들러를 작성하는 방법은 무엇인가요?","스프링 데이터 REST에서 어노테이션을 사용한 핸들러를 작성하는 방법은 @RepositoryEventHandler 어노테이션을 사용하여 POJO를 만들고, 해당 이벤트에 대한 어노테이션을 사용하여 이벤트를 처리하는 메서드를 정의하는 것입니다. 그런 다음, Spring의 @Component 스테레오타입 중 하나를 사용하여 이벤트 핸들러를 등록하고, RepositoryRestMvcConfiguration에서 BeanPostProcessor가 핸들러를 검사하고 올바른 이벤트에 연결합니다. (출처: <https://docs.spring.io/spring-data/rest/reference/4.3/events.html>)"
"스프링 데이터 REST 컴포넌트와 통합하는 다양한 방법은 무엇인가요?","스프링 데이터 REST를 사용하는 스프링 애플리케이션 또는 다른 수단에서 스프링 데이터 REST 컴포넌트와 통합하는 다양한 방법이 있습니다. 프로그램 링크, 수동 링크, Spring HATEOAS의 LinkBuilder, RepositoryEntityLinks를 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/integration.html)"
"Spring Data REST의 링크 생성에 대해 어떤 접근 방식이 권장되지 않나요?","수동으로 링크를 조립하는 것은 권장되지 않습니다. 이 방법은 코드를 취약하고 위험하게 만들기 때문입니다. Spring HATEOAS의 LinkBuilder를 사용하는 것이 좋습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/integration.html)"
"Spring Data REST의 RepositoryEntityLinks를 사용하는 방법은 무엇인가요?","MyWebApp과 같은 클래스를 생성하고 RepositoryEntityLinks를 자동 연결하여 사용할 수 있습니다. 이 클래스를 사용하면 테이블 1에 설명된 링크를 내보내는 리소스에 연결하는 방법을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/integration.html)"
"Spring Data REST에서 export된 repository마다 ALPS 문서는 어떤 정보를 포함하고 있나요?","RESTful 전환 및 각 repository의 속성에 대한 정보를 포함합니다 (Source: https://docs.spring.io/spring-data/rest/reference/4.3/metadata.html)"
"Spring Data REST 앱의 루트 URI에서 profile 링크는 어떤 용도로 사용되나요?","application-level details를 포함하는 용도로 사용됩니다 (Source: https://docs.spring.io/spring-data/rest/reference/4.3/metadata.html)"
"Spring Data REST에서 ALPS와 JSON Schema 중 어떤 형식의 metadata를 클라이언트가 더 선호할 수 있나요?","클라이언트의 요구사항과 선호도에 따라 다르며, 둘 다 사용 가능한 metadata 형식입니다 (Source: https://docs.spring.io/spring-data/rest/reference/4.3/metadata.html)"
"Spring Data REST에서 Spring Security를 사용하여 방법 수준 보안을 구현하는 방법은 무엇인가요?","@PreAuthorize와 @Secured 어노테이션을 사용하여 Spring Security를 통해 Spring Data REST 서비스에 대한 방법 수준 보안을 구현할 수 있습니다. 예시 1은 Spring Security SpEL 표현을 사용하여 '@PreAuthorize' 어노테이션을 사용하여 전체 리포지토리를 보호하는 방법을 보여줍니다. 예시 2는 역할 기반 보안에만 사용되는 '@Secured' 어노테이션을 사용하는 방법을 보여줍니다. 방법 수준 보안을 활성화하려면 @EnableGlobalMethodSecurity 어노테이션을 사용하여 @Secured 및 @Pre / @Post 지원을 모두 활성화하는 것이 좋습니다. 이는 Spring Security 참조 문서에서 읽을 수 있는 표준 관행을 따르는 Spring Security의 WebSecurityConfigurerAdapter를 사용하는 구성 클래스에 있습니다."
"Spring Data REST에서 리포지토리 및 메서드 수준 보안 설정은 어떻게 결합되나요?","리포지토리 및 메서드 수준 보안 설정은 결합되지 않습니다. 대신, 메서드 수준 설정은 리포지토리 수준 설정을 덮어씁니다. 예시 1에서는 '@PreAuthorize' 어노테이션이 리포지토리의 모든 메서드에 적용되어 모든 메서드에 대한 보안 요구 사항을 설정합니다. 예시 2에서는 '@Secured' 어노테이션이 리포지토리의 모든 메서드에 적용되어 모든 메서드에 대한 보안 요구 사항을 설정합니다."
"Spring Data REST와 함께 @PreAuthorize 및 @Secured 어노테이션을 사용하는 것의 장단점은 무엇인가요?","@PreAuthorize 어노테이션은 더 유연하며, 역할 외에도 다른 보안 메커니즘을 사용하여 액세스를 제한할 수 있습니다. 반면에 @Secured 어노테이션은 더 간단하고 역할 기반 보안에만 적합합니다. 새로운 프로젝트이거나 Spring Security를 처음 사용하는 경우 @PreAuthorize 어노테이션을 사용하는 것이 좋습니다. 이미 다른 부분에서 @Secured 어노테이션을 사용하는 경우 모든 것을 다시 작성하지 않고도 해당 경로를 계속 사용할 수 있습니다."
"Spring Data REST에서 HAL Explorer를 사용하는 방법은 무엇인가요?","HAL Explorer는 Angular 기반의 웹 애플리케이션으로, HAL 및 HAL-FORMS 기반 HTTP 응답을 쉽게 탐색할 수 있습니다. Spring Data REST API를 가리키고 앱에 임베드할 수 있습니다. Maven 또는 Gradle을 사용하여 종속성을 추가하고 브라우저에서 애플리케이션의 루트 URI를 방문하면 HAL Explorer가 자동으로 구성됩니다."
"HAL Explorer에서 URI 템플릿은 어떻게 지원되나요?","HAL Explorer는 URI 템플릿을 사용하여 링크를 읽고 응답에서 헤더와 본문(HAL 문서)을 가져옵니다. 템플릿 매개변수를 입력할 수 있는 모델 대화 상자가 나타납니다. 템플릿을 입력하지 않고 'Go!'를 클릭하면 변수가 무시됩니다."
"HAL Explorer는 어떻게 폼 필드를 자동으로 공급하나요?","HAL Explorer는 Spring Data REST에서 자동으로 생성된 리소스의 메타데이터에 따라 폼 필드를 자동으로 공급합니다. 도메인 개체를 업데이트하면 팝업이 업데이트됩니다."
"Spring Data REST에서 Customizing Item Resource URIs를 어떻게 구현하나요?","Spring Data REST 2.5부터 RepositoryRestConfiguration의 configuration API를 사용하거나 EntityLookup 인터페이스를 구현하는 Java 클래스를 등록하여 Customizing Item Resource URIs를 구현할 수 있습니다. @Component 어노테이션을 사용하여 Spring bean으로 매핑 메서드를 등록하거나 UserEntityLookup 클래스를 구현하여 resourceIdentifier(…) 메서드에서 반환된 값으로 엔티티 인스턴스를 조회할 수 있습니다. 또한, @RepositoryRestResource 어노테이션을 사용하여 리포지토리 노출을 커스터마이징하고 RepositoryDetectionStrategy를 사용하여 Spring Data REST에서 노출되는 리포지토리를 제어할 수 있습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/customizing-sdr.html)"
"Spring Data REST에서 지원되는 HTTP 메서드를 커스터마이징하는 방법은 무엇인가요?","ExposureConfiguration 클래스의 Lambda 기반 API를 사용하여 전역 및 유형별 규칙을 정의할 수 있습니다. forDomainType(…) 메서드를 사용하여 특정 도메인 유형에 대한 노출을 커스터마이징하고, disablePutForCreation()과 같은 메서드를 사용하여 특정 HTTP 메서드를 비활성화할 수 있습니다. 또한, withItemExposure(…) 메서드를 사용하여 모든 항목 리소스에 대한 특정 HTTP 메서드를 비활성화할 수 있습니다. 또한, @RestResource(exported = false) 어노테이션을 사용하여 내부적으로 사용하는 메서드에 대한 HTTP 메서드 노출을 비활성화할 수 있습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/customizing-sdr.html)"
"Spring Data REST에서 HTTP 리소스 및 메커니즘의 기본 노출을 어떻게 커스터마이징할 수 있나요?","Spring Data REST는 기본적으로 리포지토리가 공개되는 경우 HTTP 리소스 및 메커니즘을 노출합니다. 리포지토리의 CRUD 메서드에 따라 HTTP PUT 및 HTTP DELETE와 같은 메서드가 지원됩니다. @RestResource(exported = false) 어노테이션을 사용하여 내부적으로 사용하는 메서드에 대한 HTTP 메서드 노출을 비활성화할 수 있습니다. 또한, RepositoryRestConfiguration의 getExposureConfiguration() 메서드를 사용하여 어떤 HTTP 메서드가 노출되어야 하는지 정의할 수 있습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/customizing-sdr.html)"
"REST URL 경로에서 리포지토리의 URL 경로를 어떻게 변경할 수 있나요?","REST URL 경로에서 리포지토리의 URL 경로를 변경하려면, 리포지토리 클래스 또는 쿼리 메서드 레벨에서 @RepositoryRestResource 또는 @RestResource 어노테이션을 사용하여 경로를 지정할 수 있습니다. 예를 들어, @RepositoryRestResource(path = 'people') 어노테이션을 사용하면 리포지토리의 기본 URL 경로 'persons'가 'people'로 변경됩니다. 마찬가지로, @RestResource(path = 'names') 어노테이션을 사용하여 쿼리 메서드의 URL 경로를 'search/findByName'에서 'search/names'로 변경할 수 있습니다."
"REST URL 경로에서 리포지토리의 rel 속성을 어떻게 변경할 수 있나요?","REST URL 경로에서 리포지토리의 rel 속성을 변경하려면, 리포지토리 클래스 또는 쿼리 메서드 레벨에서 @RepositoryRestResource 또는 @RestResource 어노테이션의 rel 속성을 사용할 수 있습니다. 예를 들어, @RepositoryRestResource(path = 'people', rel = 'people') 어노테이션을 사용하면 리포지토리의 기본 rel 값 'persons'가 'people'로 변경됩니다. 마찬가지로, @RestResource(path = 'names', rel = 'names') 어노테이션을 사용하여 쿼리 메서드의 rel 값을 'findByName'에서 'names'로 변경할 수 있습니다."
"REST URL 경로에서 특정 쿼리 메소드나 필드를 노출하지 않으려면 어떻게 해야 하나요?","REST URL 경로에서 특정 쿼리 메소드나 필드를 노출하지 않으려면, 해당 쿼리 메소드나 필드에 @RestResource 어노테이션을 추가하고 exported 속성을 false로 설정하면 됩니다. 예를 들어, @RestResource(exported = false) 어노테이션을 사용하여 쿼리 메소드나 필드를 노출하지 않을 수 있습니다. 이렇게 하면 해당 쿼리 메소드나 필드가 노출되지 않으며, 클라이언트에서 해당 리소스에 접근할 수 없습니다."
"기존의 Spring MVC 애플리케이션에서 Spring Data REST를 통합하는 방법은 무엇인가요?","Spring MVC 구성(대부분 MVC 자원을 구성하는 위치)에서 RepositoryRestController를 구성하는 Java 구성 클래스에 대한 빈 참조를 추가해야 합니다. 클래스 이름은 org.springframework.data.rest.webmvc.RepositoryRestMvcConfiguration입니다. 다음 예제는 @Import 어노테이션을 사용하여 적절한 참조를 추가하는 방법을 보여줍니다. 구성은 다음과 같습니다: Java import org.springframework.context.annotation.Import; import org.springframework.data.rest.webmvc.RepositoryRestMvcConfiguration; @Configuration @Import(RepositoryRestMvcConfiguration.class) public class MyApplicationConfiguration { ... } XML <bean class='org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration'/> ApplicationContext가 이 빈 정의를 만나면 해당 ApplicationContext 및 상위 컨텍스트에서 찾은 저장소를 내보내기 위한 컨트롤러를 완전히 구성하기 위해 필요한 Spring MVC 리소스를 부트스트랩합니다. 자세한 내용은 Required Configuration에서 확인할 수 있습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/customizing/adding-sdr-to-spring-mvc-app.html)"
"Spring Data REST는 기존의 Spring MVC 애플리케이션 내에서 작동하기 위해 어떤 Spring MVC 리소스를 올바르게 구성해야 하나요?","Spring Data REST는 기존의 Spring MVC 애플리케이션 내에서 작동하기 위해 올바르게 구성해야 하는 몇 가지 Spring MVC 리소스에 의존합니다. 이러한 리소스는 애플리케이션 내에서 이미 존재하는 유사한 리소스와 격리되도록 노력했지만, 이러한 MVC 구성 요소를 수정하여 Spring Data REST의 일부 동작을 사용자 지정하려는 경우가 있을 수 있습니다. 다음 섹션에서 다루는 RepositoryRestHandlerMapping을 구성하는 데 특별한 주의를 기울여야 합니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/customizing/adding-sdr-to-spring-mvc-app.html)"
"Spring Data REST의 RepositoryRestHandlerMapping은 어떻게 작동하나요?","RepositoryRestController에 대해서만 응답하고 경로가 Spring Data REST에서 처리해야 하는 경우에만 응답하는 사용자 지정 HandlerMapping 인스턴스를 등록합니다. 애플리케이션에서 처리해야 하는 경로를 Spring Data REST에서 처리하는 경로와 분리하려면 이 사용자 지정 HandlerMapping 클래스는 URL 경로를 검사하고 해당 이름으로 저장소가 내보내졌는지 확인합니다. 내보내졌다면 사용자 지정 HandlerMapping 클래스는 요청을 Spring Data REST에서 처리하도록 합니다. 해당 이름으로 내보낸 저장소가 없으면 null을 반환하여 '다른 HandlerMapping 인스턴스가 이 요청을 처리하도록 시도합니다'라는 의미입니다. Spring Data REST HandlerMapping은 order=(Ordered.LOWEST_PRECEDENCE - 100)로 구성되므로 URL 경로를 매핑할 때 일반적으로 가장 먼저 처리됩니다. 기존 애플리케이션은 저장소에 대한 요청을 처리할 기회가 없습니다. 예를 들어, person이라는 이름으로 내보낸 저장소가 있는 경우 /person으로 시작하는 애플리케이션에 대한 모든 요청은 Spring Data REST에서 처리하며, 기존 애플리케이션은 해당 요청을 볼 수 없습니다. 그러나 저장소가 다른 이름(예: people)으로 내보내진 경우 /people에 대한 요청은 Spring Data REST로 이동하고 /person에 대한 요청은 기존 애플리케이션에서 처리됩니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/customizing/adding-sdr-to-spring-mvc-app.html)"
"스프링 데이터 REST와 스프링 HATEOAS의 통합 목적은 무엇인가요?","스프링 데이터 REST와 스프링 HATEOAS의 통합은 클라이언트에게 전송되는 리소스의 표현을 수정할 수 있는 확장 훅을 제공합니다. 이는 특정 엔티티에 대한 다른 리소스에 대한 링크를 제공해야 할 때 유용합니다. 예를 들어, 고객 응답은 현재 쇼핑 카트에 대한 링크 또는 해당 엔티티와 관련된 리소스를 관리하는 링크로 풍부해질 수 있습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/customizing/customizing-json-output.html)"
"스프링 HATEOAS에서 RepresentationModelProcessor 인터페이스는 어떤 역할을 하나요?","스프링 HATEOAS에서 RepresentationModelProcessor 인터페이스는 엔티티를 처리하는 역할을 합니다. RepresentationModelProcessor<EntityModel<T>> 유형의 모든 빈은 스프링 데이터 REST 수출기에 의해 자동으로 선택되며, T 유형의 엔티티를 직렬화할 때 트리거됩니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/customizing/customizing-json-output.html)"
"스프링 데이터 REST에서 RepresentationModelProcessor를 사용하여 엔티티의 기본 표현에 링크를 추가하는 방법은 무엇인가요?","스프링 데이터 REST에서 RepresentationModelProcessor를 사용하여 엔티티의 기본 표현에 링크를 추가하려면, 예제에서 보여지는 것처럼 model.add(Link)를 호출하면 됩니다. EntityModel에 추가한 모든 링크는 최종 출력에 추가됩니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/customizing/customizing-json-output.html)"
"Spring Data REST에서 ObjectMapper를 사용자 정의하는 이유는 무엇인가요?","Spring Data REST의 ObjectMapper가 도메인 모델을 올바르게 처리하지 못할 때 사용자 정의 Serializer 및 Deserializer를 추가하여 도메인 모델을 JSON으로 올바르게 변환할 수 있습니다. 또한, 복잡한 도메인 모델을 일반적으로 지원하는 것이 현실적이지 않거나 불가능한 경우도 있습니다. Spring Data REST는 대부분의 사용 사례를 수용하기 위해 객체 그래프를 올바르게 렌더링하려고 시도하지만, 도메인 모델이 일반 JSON으로 읽거나 쓰기에 적합하지 않은 경우 사용자 정의 타입 매핑 및 (디)시리얼라이저를 구성해야 할 수 있습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/customizing/custom-jackson-deserialization.html)"
"Spring Data REST에서 인터페이스를 사용할 때 Jackson은 어떤 구현 클래스를 사용해야 하는지 어떻게 알 수 있나요?","Jackson은 기본적으로 인터페이스에 대해 어떤 구현 클래스를 생성해야 하는지 알지 못합니다. 복잡한 도메인 모델을 다루거나 인터페이스를 사용하는 경우, 사용자 정의 타입 매핑을 구성하기 위해 Module을 사용하여 TypeResolver를 추가해야 합니다. Module을 생성하여 setupModule 메서드에서 적절한 TypeResolver를 추가하면, Spring Data REST의 ObjectMapper가 도메인 객체를 올바르게 처리할 수 있습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/customizing/custom-jackson-deserialization.html)"
"Jackson의 ObjectMapper에 사용자 정의 Serializer와 Deserializer를 어떻게 등록하나요?","사용자 정의 Serializer와 Deserializer를 Jackson의 ObjectMapper에 등록하려면, setupModule 메서드에서 SimpleSerializers 및 SimpleDeserializers 클래스를 사용하여 등록할 수 있습니다. 도메인 타입에 대한 Serializer와 Deserializer를 추가한 다음, 이들을 ObjectMapper에 추가하면 됩니다. 이렇게 하면 Spring Data REST의 Exporter가 도메인 객체를 올바르게 처리할 수 있습니다. (출처: https://docs.spring.io/spring-data/rest/reference/4.3/customizing/custom-jackson-deserialization.html)"
"스프링 데이터 REST에서 CORS를 구성하는 방법은 무엇인가요?","스프링 데이터 REST는 스프링의 CORS 지원을 통해 Cross-Origin Resource Sharing (CORS)를 지원합니다. Repository Interface CORS Configuration, Repository REST Controller Method CORS Configuration, Global CORS Configuration을 사용하여 CORS를 구성할 수 있습니다. @CrossOrigin 어노테이션과 CorsRegistry를 사용하여 CORS를 구성할 수 있습니다."
"스프링 데이터 REST에서 @CrossOrigin 어노테이션을 사용하는 방법은 무엇인가요?","@CrossOrigin 어노테이션을 사용하면 리포지토리 인터페이스에 CORS를 활성화할 수 있습니다. 이 어노테이션은 CORS 지원을 구성하기 위한 속성을 제공합니다. 예를 들어, 허용된 원본, HTTP 메서드, 최대 연령 등을 설정할 수 있습니다."
"스프링 데이터 REST에서 CORS를 구성하기 위해 CorsRegistry를 사용하는 방법은 무엇인가요?","CorsRegistry를 사용하면 세밀한 @CrossOrigin 어노테이션 기반 구성과 함께 전역적인 CORS 구성을 정의할 수 있습니다. CorsRegistry를 사용하여 허용된 원본, HTTP 메서드, 헤더, 최대 연령 등을 설정할 수 있습니다. CorsRegistry는 RepositoryRestConfigurer를 구현하는 @Component에서 사용할 수 있습니다."
"Spring Data Cassandra란 무엇인가요?","Spring Data Cassandra는 Apache Cassandra 데이터베이스에 대한 리포지토리 지원을 제공하는 Spring Data 모듈입니다. Cassandra 데이터 소스에 액세스해야 하는 일관된 프로그래밍 모델을 가진 애플리케이션 개발을 용이하게 합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/index.html)"
"Spring Data Cassandra를 사용하면 어떤 이점이 있나요?","Spring Data Cassandra를 사용하면 Cassandra 데이터베이스와의 연결 및 쿼리 작성이 간편해지며, 일관된 프로그래밍 모델을 통해 개발 생산성이 향상됩니다. 또한, 리포지토리 지원을 통해 데이터 액세스를 추상화하고, 다양한 데이터 소스에 대한 접근을 단순화할 수 있습니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/index.html)"
"Spring Data Cassandra는 어떤 프로그래밍 언어를 지원하나요?","Spring Data Cassandra는 Kotlin을 포함한 다양한 프로그래밍 언어를 지원합니다. 이를 통해 개발자는 자신이 선호하는 언어로 Cassandra 데이터베이스와 상호 작용할 수 있습니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/index.html)"
"스프링 데이터 업그레이드 가이드는 어디에서 찾을 수 있나요?","스프링 데이터 업그레이드 가이드는 프로젝트 위키(https://github.com/spring-projects/spring-data-commons/wiki)에서 찾을 수 있습니다. (출처: https://github.com/spring-projects/spring-data-commons/wiki)"
"스프링 데이터 버전을 업그레이드하려면 어떤 버전으로 업그레이드해야 하는지 어떻게 알 수 있나요?","업그레이드하려는 버전을 찾으려면 프로젝트 위키의 릴리스 노트 섹션(https://github.com/spring-projects/spring-data-commons/wiki#release-notes)의 링크를 따라가세요. (출처: https://github.com/spring-projects/spring-data-commons/wiki#release-notes)"
"여러 버전을 건너뛰고 스프링 데이터를 업그레이드할 때 고려해야 할 사항은 무엇인가요?","여러 버전을 건너뛰고 업그레이드할 경우, 건너뛴 버전의 릴리스 노트도 검토해야 합니다. (출처: https://github.com/spring-projects/spring-data-commons/wiki#release-notes)"
"1.x 버전에서 2.x로 업그레이드하려면 어떤 Spring Data Cassandra 마이그레이션 가이드가 필요한가요?","Migration Guide from 1.x to 2.x (Source: <https://docs.spring.io/spring-data/cassandra/reference/4.3/migration-guide/migration-guide-1.5-to-2.0.html>)"
"2.x 버전에서 3.x로 업그레이드하려면 어떤 Spring Data Cassandra 마이그레이션 가이드가 제공되나요?","Migration Guide from 2.x to 3.x (Source: <https://docs.spring.io/spring-data/cassandra/reference/4.3/migration-guide/migration-guide-2.2-to-3.0.html>)"
"3.x 버전에서 4.x로 업그레이드하려면 어떤 Spring Data Cassandra 마이그레이션 가이드가 필요한가요?","Migration Guide from 3.x to 4.x (Source: <https://docs.spring.io/spring-data/cassandra/reference/4.3/migration-guide/migration-guide-3.0-to-4.0.html>)"
"Spring Data for Apache Cassandra 2.0에서 CassandraOperations.selectBySimpleIds 메소드가 왜 제거되었나요?","복잡한 ID를 지원하지 않았기 때문에 제거되었습니다."
"1.x 버전에서 2.x로 업그레이드할 때 Spring Data for Apache Cassandra에서 어떤 변경 사항이 도입되었나요?","CassandraOperations.selectBySimpleIds 메소드가 제거되었고, CassandraRepository의 이름이 변경되었으며, SD Cassandra ConsistencyLevel 및 RetryPolicy 유형이 DataStax ConsistencyLevel 및 RetryPolicy 유형으로 대체되었습니다."
"Spring Data for Apache Cassandra 2.0에서 CqlTemplate API가 어떻게 수정되었나요?","JdbcTemplate과 일치하도록 수정되었습니다."
"Spring Data Cassandra 3.0으로 업그레이드할 때 어떤 변경 사항이 발생하나요?","Spring Data Cassandra 3.0으로 업그레이드하면 DataStax Driver 버전 4로 업그레이드해야 합니다. 새로운 드라이버로 업그레이드하면 종속성 변경이 발생하며, 특히 Google Guava가 드라이버에 번들로 포함되어 있습니다. DataStax Java Driver for Apache Cassandra 4 Upgrade Guide(https://docs.datastax.com/en/developer/java-driver/4.3/upgrade_guide/)에서 자세한 내용을 확인할 수 있습니다. 또한, ClusterBuilderConfigurer가 SessionBuilderConfigurer로 이름이 변경되었으며, Cluster.Builder 대신 CqlSessionBuilder를 사용합니다. local data center를 구성하여 로드 밸런싱을 올바르게 구성해야 합니다. Cluster와 Session 요소는 CqlSession 요소로 병합되어 keyspace와 endpoints를 구성합니다. SessionFactory 요소는 새로운 네임스페이스 요소로 이동되었습니다. Spring Data Cassandra 3.0은 더 이상 XML 네임스페이스 구성을 사용할 때 기본 Mapping Context, Context 및 Template API 빈을 등록하지 않습니다. Defaulting은 애플리케이션 또는 Spring Boot 수준에서 적용되어야 합니다. DataStax 드라이버 API를 직접 사용하는 코드를 조정해야 합니다."
"Spring Data Cassandra 2.x와 3.x에서 Template API 구성에 어떤 변경 사항이 있었나요?","Spring Data Cassandra 3.x에서 Template API 구성에 변경 사항이 있었습니다. Spring Data Cassandra 3.0은 더 이상 XML 네임스페이스 구성을 사용할 때 기본 Mapping Context, Context 및 Template API 빈을 등록하지 않습니다. Defaulting은 애플리케이션 또는 Spring Boot 수준에서 적용되어야 합니다. Template API: Spring Data for Apache Cassandra는 드라이버 업그레이드와 함께 제공되는 대부분의 변경 사항을 Template API 및 리포지토리 지원으로 캡슐화합니다. 응용 프로그램이 주로 매핑된 엔티티 또는 기본 Java 유형과 상호 작용하는 경우 CqlTemplate 및 CassandraTemplate 개체를 SessionFactory를 사용하여 생성하는 것이 좋습니다. factory 사용은 스키마 생성을 위한 동기화를 허용하고 여러 데이터베이스와 작업할 때 유연성 수준을 도입합니다. 버전 3에서 템플릿 API를 구성하려면 cassandra:session-factory를 사용하고, cassandra:cql-template을 사용하여 CqlTemplate을 생성하고, cassandra:template을 사용하여 CassandraTemplate을 생성해야 합니다. 또한, 템플릿 API를 사용하는 코드에서 DataStax 드라이버 API를 직접 사용하는 경우 코드를 조정해야 합니다. 예를 들어, ResultSetExtractor, RowCallbackHandler, RowMapper, PreparedStatementCreator의 구현체, queryForResultSet(…)을 호출하는 코드, Statement를 호출하는 메서드 등이 있습니다."
"Spring Data Cassandra 3.x에서 데이터 모델 마이그레이션에 어떤 변경 사항이 있었나요?","Spring Data Cassandra 3.x에서 데이터 모델 마이그레이션에 변경 사항이 있었습니다. 다음 기능을 사용하는 경우 데이터 모델을 업데이트해야 할 수 있습니다. @CassandraType, @Table, @Column, @PrimaryKeyColumn, @PrimaryKey 및 @UserDefinedType에서 forceQuote, java.lang.Date를 사용하는 속성, UDTValue 또는 TupleValue를 사용하는 속성. DataStax 드라이버 4는 Cassandra 유형을 설명하는 Name 열거형을 더 이상 제공하지 않습니다. 우리는 CassandraType.Name으로 열거형을 다시 도입하기로 결정했습니다. 임포트문을 업데이트하여 새로 도입된 대체 유형을 사용하십시오. Force Quote: 이 플래그는 이제 사용되지 않으며 더 이상 사용하지 않는 것이 좋습니다. Spring Data for Apache Cassandra는 내부적으로 필요한 경우 따옴표를 지정하는 드라이버의 CqlIdentifier를 사용합니다. 속성 유형: DataStax 드라이버 4는 더 이상 java.lang.Date를 사용하지 않습니다. 데이터 모델을 java.time.LocalDateTime을 사용하도록 업그레이드하십시오. 또한, 원시 UDT 및 튜플 유형을 새로운 드라이버 유형인 UdtValue 및 TupleValue로 마이그레이션하십시오. 또한, DataStax 드라이버 4는 ConsistencyLevel 상수 클래스를 제거하고 DefaultConsistencyLevel로 다시 도입했습니다. @Consistency는 DefaultConsistencyLevel로 조정되었습니다. QueryOptions 및 …CqlTemplate 유형의 RetryPolicy는 대체 없이 제거되었습니다. 드라이버의 PagingState 유형이 제거되었습니다. Paging state now uses ByteBuffer. SimpleUserTypeResolver는 Cluster 대신 CqlSession을 사용합니다. SimpleTupleTypeFactory는 열거형으로 마이그레이션되었습니다. SimpleTupleTypeFactory.INSTANCE는 더 이상 Cluster / CqlSession 컨텍스트를 필요로하지 않습니다."
"Spring Data for Apache Cassandra 4.0에서 이전 버전에서 업그레이드할 때 어떤 변경 사항이 있나요?","Spring Data for Apache Cassandra 4.0은 이전 버전에서 업그레이드할 때 ListenableFuture가 사용되지 않고, AsyncCqlOperations 및 AsyncCassandraOperations와 그 종속 클래스가 CompletableFuture로 마이그레이션되었습니다. (출처: {https://docs.spring.io/spring-data/cassandra/reference/4.3/migration-guide/migration-guide-3.0-to-4.0.html})"
"ListenableFuture를 많이 사용하는 애플리케이션에서 CompletableFuture로 쉽게 마이그레이션할 수 없는 경우 어떻게 해야 하나요?","ListenableFuture를 많이 사용하는 애플리케이션에서 CompletableFuture로 쉽게 마이그레이션할 수 없는 경우, legacy AsyncCqlOperations 및 AsyncCassandraOperations 유형으로 전환하는 것이 좋습니다. (출처: {https://docs.spring.io/spring-data/cassandra/reference/4.3/migration-guide/migration-guide-3.0-to-4.0.html})"
"Spring Data for Apache Cassandra에서 CompletableFuture 대신 ListenableFuture를 사용하려면 어떻게 해야 하나요?","Spring Data for Apache Cassandra에서 CompletableFuture 대신 ListenableFuture를 사용하려면 legacy AsyncCqlOperations 및 AsyncCassandraOperations를 사용해야 합니다. (출처: {https://docs.spring.io/spring-data/cassandra/reference/4.3/migration-guide/migration-guide-3.0-to-4.0.html})"
"Spring Data for Apache Cassandra 4.3에서 com.datastax.oss groupId가 org.apache.cassandra로 변경된 이유는 무엇인가요?","Datastax 드라이버가 Apache 재단으로 이전되었기 때문에, Spring Data for Apache Cassandra 4.3에서는 com.datastax.oss groupId가 org.apache.cassandra로 변경되었습니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/migration-guide/migration-guide-4.0-to-4.3.html)"
"Spring Data for Apache Cassandra 4.3에서 Maven 프로젝트 구성에서 어떤 변경 사항이 필요한가요?","Spring Data for Apache Cassandra 4.3에서 Maven 프로젝트 구성에서는 com.datastax.oss groupId를 org.apache.cassandra로 업데이트해야 합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/migration-guide/migration-guide-4.0-to-4.3.html)"
"Spring Data for Apache Cassandra 4.3에서 Maven 프로젝트 구성에서 groupId를 업데이트하는 방법은 무엇인가요?","Spring Data for Apache Cassandra 4.3에서 Maven 프로젝트 구성에서 groupId를 업데이트하려면, pom.xml 파일에서 com.datastax.oss groupId를 org.apache.cassandra로 변경하면 됩니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/migration-guide/migration-guide-4.0-to-4.3.html)"
"스프링 데이터 아파치 카산드라의 핵심 기능은 무엇인가요?","스프링 데이터 아파치 카산드라는 Java 기반의 @Configuration 클래스 또는 XML 네임스페이스를 사용한 스프링 설정 지원, CqlTemplate, AsyncCqlTemplate, ReactiveCqlTemplate 도우미 클래스, CassandraTemplate, AsyncCassandraTemplate, ReactiveCassandraTemplate 도우미 클래스, 예외 번역을 통한 스프링의 이식 가능한 데이터 액세스 예외 계층, 풍부한 객체 매핑, 어노테이션 기반 매핑 메타데이터, Java 기반의 쿼리, 기준 및 업데이트 DSL, 임페러티브 및 리액티브 리포지토리 인터페이스의 자동 구현을 제공합니다. (출처: {https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra.html})"
"스프링 데이터 아파치 카산드라에서 CQL과 엔티티 수준에서의 상호작용을 가능하게 하는 추상화에 대해 설명해주세요.","스프링 데이터 아파치 카산드라의 추상화는 연결 매개변수 정의, 연결 열기, CQL 문 지정, 매개변수 선언 및 매개변수 값 제공, 문 준비 및 실행, 결과(있는 경우)를 반복하는 루프 설정, 각 반복에 대한 작업 수행, 예외 처리, 세션 닫기 등의 저수준 세부 정보를 처리합니다. 매핑된 엔티티 객체를 사용하면 스키마 생성, 객체 매핑 및 리포지토리 지원이 가능합니다. (출처: {https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra.html})"
"카산드라 데이터베이스 액세스를 위한 접근 방식은 어떤 것이 있나요?","카산드라 데이터베이스 액세스를 위한 접근 방식으로는 CqlTemplate 및 ReactiveCqlTemplate, CassandraTemplate, ReactiveCassandraTemplate, 리포지토리 추상화 등이 있습니다. CqlTemplate 및 ReactiveCqlTemplate은 클래식한 스프링 CQL 접근 방식으로 가장 인기가 있으며, CassandraTemplate 및 ReactiveCassandraTemplate은 CqlTemplate을 사용하여 쿼리 결과-객체 매핑 및 SELECT, INSERT, UPDATE, DELETE 메서드 사용을 제공합니다. 리포지토리 추상화는 데이터 액세스 레이어에서 리포지토리 선언을 생성하고 데이터 액세스 레이어를 구현하는 데 필요한 보일러플레이트 코드의 양을 크게 줄이는 것을 목표로 합니다. 대부분의 데이터 지향 작업에는 Reactive|AsyncCassandraTemplate 또는 리포지토리 지원을 사용할 수 있으며, 둘 다 풍부한 객체 매핑 기능을 사용합니다. (출처: {https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra.html})"
"스프링 데이터 아파치 카산드라를 사용하기 위해 필요한 버전은 무엇인가요?","스프링 데이터 아카펠라 카산드라(Spring Data for Apache Cassandra)는 아파치 카산드라(Apache Cassandra) 2.1 이상 및 데이터스택 자바 드라이버(Datastax Java Driver) 4.0 이상이 필요합니다. (출처: <https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/getting-started.html>)"
"스프링 데이터 아카펠라 카산드라를 사용하는 데 도움이 되는 자습서가 있나요?","도서관을 사용하는 방법에 대한 아이디어를 얻으려면 여러 가지 예제를 다운로드하고 실험해 볼 수 있습니다. (출처: <https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/getting-started.html>)"
"스프링 프로젝트에서 스프링 데이터 아카펠라 카산드라를 사용하려면 어떤 단계를 거쳐야 하나요?","먼저 실행 중인 아파치 카산드라 서버를 설정해야 합니다. 아파치 카산드라 시작 방법에 대한 설명은 아파치 카산드라 퀵 스타트 가이드(<https://cassandra.apache.org/doc/latest/getting_started/index.html>)를 참조하십시오. 설치 후 카산드라를 시작하는 것은 일반적으로 다음 명령을 실행하는 것입니다. CASSANDRA_HOME/bin/cassandra -f. STS에서 스프링 프로젝트를 만들려면 파일 → 새로 만들기 → 스프링 템플릿 프로젝트 → 간단한 스프링 유틸리티 프로젝트로 이동하고 프롬프트가 나타나면 예를 누르십시오. 그런 다음 org.spring.data.cassandra.example과 같은 프로젝트 및 패키지 이름을 입력합니다. 그런 다음 다음 의존성 선언을 pom.xml 파일의 dependencies 섹션에 추가할 수 있습니다. <dependencies> <dependency> <groupId>org.springframework.data</groupId> <artifactId>spring-data-cassandra</artifactId> <version>4.3.4</version> </dependency> </dependencies> 또한 pom.xml 파일의 Spring 버전을 다음과 같이 변경해야 합니다. <spring.version>6.1.13</spring.version> GA 릴리스 대신 마일스톤 릴리스를 사용하는 경우 Maven의 Spring Milestone 저장소 위치를 pom.xml 파일에 추가하여 <dependencies/> 요소와 동일한 수준에 있어야 합니다. <repositories> <repository> <id>spring-milestone</id> <name>Spring Maven MILESTONE Repository</name> <url>https://repo.spring.io/milestone</url> </repository> </repositories> 저장소는 여기에서(<https://repo.spring.io/milestone/org/springframework/data/>) 찾아볼 수도 있습니다. 모든 Spring 저장소는 여기에서(<https://repo.spring.io/webapp/#/home>) 찾아볼 수 있습니다. 이제 Cassandra에 도메인 개체를 저장하고 읽는 간단한 Java 애플리케이션을 만들 수 있습니다. 이를 위해 먼저 지속할 간단한 도메인 개체 클래스를 만들어야 합니다. 다음 예제와 같이: package org.springframework.data.cassandra.example; import org.springframework.data.cassandra.core.mapping.PrimaryKey; import org.springframework.data.cassandra.core.mapping.Table; @Table public class Person { @PrimaryKey private final String id; private final String name; private final int age; public Person(String id, String name, int age) { this.id = id; this.name = name; this.age = age; } public String getId() { return id; } private String getName() { return name; } private int getAge() { return age; } @Override public String toString() { return String.format('{ @type = %1$s, id = %2$s, name = %3$s, age = %4$d }', getClass().getName(), getId(), getName(), getAge()); } } 그 다음, 다음 예제와 같이 실행할 메인 애플리케이션을 만듭니다. Imperative Reactive package org.springframework.data.cassandra.example; import java.util.UUID; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.springframework.data.cassandra.core.CassandraOperations; import org.springframework.data.cassandra.core.CassandraTemplate; import org.springframework.data.cassandra.core.query.Criteria; import org.springframework.data.cassandra.core.query.Query; import com.datastax.oss.driver.api.core.CqlSession; public class CassandraApplication { private static final Log LOG = LogFactory.getLog(CassandraApplication.class); private static Person newPerson(String name, int age) { return new Person(UUID.randomUUID().toString(), name, age); } public static void main(String[] args) { CqlSession cqlSession = CqlSession.builder().withKeyspace('mykeyspace').build(); CassandraOperations template = new CassandraTemplate(cqlSession); Person jonDoe = template.insert(newPerson('Jon Doe', 40)); LOG.info(template.selectOne(Query.query(Criteria.where('id').is(jonDoe.getId())), Person.class).getId()); template.truncate(Person.class); cqlSession.close(); } } package org.springframework.data.cassandra.example; import reactor.core.publisher.Mono; import java.util.UUID; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.springframework.data.cassandra.core.ReactiveCassandraOperations; import org.springframework.data.cassandra.core.ReactiveCassandraTemplate; import org.springframework.data.cassandra.core.cql.session.DefaultBridgedReactiveSession; import org.springframework.data.cassandra.core.query.Criteria; import org.springframework.data.cassandra.core.query.Query; import com.datastax.oss.driver.api.core.CqlSession; public class ReactiveCassandraApplication { private static final Log LOG = LogFactory.getLog(ReactiveCassandraApplication.class); private static Person newPerson(String name, int age) { return new Person(UUID.randomUUID().toString(), name, age); } public static void main(String[] args) { CqlSession cqlSession = CqlSession.builder().withKeyspace('mykeyspace').build(); ReactiveCassandraOperations template = new ReactiveCassandraTemplate(new DefaultBridgedReactiveSession(cqlSession)); Mono<Person> jonDoe = template.insert(newPerson('Jon Doe', 40)); jonDoe.flatMap(it -> template.selectOne(Query.query(Criteria.where('id').is(it.getId())), Person.class)) .doOnNext(it -> LOG.info(it.toString())) .then(template.truncate(Person.class)) .block(); cqlSession.close(); } } 이 간단한 예제에서도 몇 가지 주목할 만한 사항이 있습니다. 카산드라(Cassandra) CqlSession으로 CassandraTemplate(../api/java/org/springframework/data/cassandra/core/CassandraTemplate.html) (또는 반응형 사용을 위한 ReactiveCassandraTemplate(../api/java/org/springframework/data/cassandra/core/ReactiveCassandraTemplate.html))의 인스턴스를 만들 수 있습니다. POJO를 카산드라 @Table 엔티티로 주석 처리하고 @PrimaryKey도 주석 처리해야 합니다. 선택적으로 이러한 매핑 이름을 카산드라 데이터베이스 테이블 이름 및 열 이름과 일치하도록 재정의할 수 있습니다. 쿼리를 구성하기 위해 원시 CQL 또는 드라이버 QueryBuilder API를 사용할 수 있습니다. (출처: <https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/getting-started.html>)"
"CqlTemplate 클래스는 어떤 역할을 하나요?","CqlTemplate 클래스는 핵심 CQL 패키지의 중심 클래스로, 리소스의 생성과 해제를 처리합니다. 명세서 생성 및 실행과 같은 핵심 CQL 워크플로우의 기본 작업을 수행하며, CQL을 제공하고 결과를 추출하는 작업을 애플리케이션 코드에 맡깁니다."
"CqlTemplate을 DAO 구현에서 사용하려면 어떻게 해야 하나요?","CqlTemplate은 SessionFactory 참조를 사용하여 직접 인스턴스화하거나 Spring 컨테이너에서 구성한 다음 DAO에 빈 참조로 제공하여 DAO 구현에서 사용할 수 있습니다."
"CqlTemplate은 어떻게 Apache Cassandra와 연결되나요?","Applications connect to Apache Cassandra by using CqlSession objects. A Cassandra CqlSession keeps track of multiple connections to the individual nodes and is designed to be a thread-safe, long-lived object. Usually, you can use a single CqlSession for the whole application. Spring acquires a Cassandra CqlSession through a SessionFactory. SessionFactory is part of Spring Data for Apache Cassandra and is a generalized connection factory. It lets the container or framework hide connection handling and routing issues from the application code."
"스프링 데이터 for Apache Cassandra에서 ReactiveCassandraTemplate과 ReactiveCqlTemplate은 어떤 역할을 하나요?","ReactiveCassandraTemplate은 생산성을 높이기 위해 ReactiveCassandraOperations를 반응형으로 사용하는 도우미 클래스이며, ReactiveCqlTemplate은 일반적인 Cassandra 데이터 액세스 작업을 적절히 처리하여 생산성을 높이는 도우미 클래스입니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/reactive-cassandra.html)"
"스프링 데이터 for Apache Cassandra에서 ReactiveCassandraTemplate과 ReactiveCqlTemplate의 차이점은 무엇인가요?","ReactiveCassandraTemplate은 대부분의 데이터 지향 작업에 사용되며, 풍부한 객체 매핑 기능을 사용합니다. ReactiveCqlTemplate은 카운터를 증가시키거나 ad-hoc CRUD 작업을 수행하는 데 주로 사용됩니다. ReactiveCqlTemplate은 또한 com.datastax.oss.driver.api.core.CqlSession과 같은 저수준 API 개체를 쉽게 얻을 수 있는 콜백 메서드를 제공합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/reactive-cassandra.html)"
"스프링 데이터 for Apache Cassandra는 어떤 반응형 컴포지션 라이브러리를 사용하나요?","스프링 데이터 for Apache Cassandra는 DataStax Cassandra Driver 위에 구축되어 있으며, DataStax Cassandra Driver는 비동기 기능을 제공하지만 반응형이 아닙니다. 반응형 스트림 이니셔티브에 의존하여 최대한의 상호 운용성을 제공하기 위해 Publisher API를 채택하고 노출합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/reactive-cassandra.html)"
"CassandraTemplate과 ReactiveCassandraTemplate은 어떤 역할을 하며, 어떤 클래스에서 찾을 수 있나요?","CassandraTemplate과 ReactiveCassandraTemplate은 Spring의 Cassandra 지원에서 중요한 클래스로, 데이터베이스와 상호 작용하기 위한 풍부한 기능을 제공합니다. 이 클래스들은 org.springframework.data.cassandra 패키지에 위치해 있습니다."
"Spring의 Cassandra 지원에서 CassandraConverter 인터페이스는 어떤 역할을 하나요?","CassandraConverter 인터페이스는 Cassandra의 행과 애플리케이션 도메인 객체 간의 매핑을 담당합니다. Spring은 MappingCassandraConverter라는 기본 구현을 제공하지만, 사용자 정의 변환기를 작성할 수도 있습니다."
"Spring의 Cassandra 지원에서 [Reactive]CassandraOperations 인터페이스는 어떤 역할을 하나요?","CassandraOperations 인터페이스와 그 반응형 변형인 ReactiveCassandraOperations는 Spring의 Cassandra 지원에서 중요한 인터페이스로, 데이터베이스와 상호 작용하기 위한 다양한 메서드를 제공합니다. 가능한 한 Cassandra에서 사용 가능한 메서드와 동일한 이름을 사용하여 API를 개발자에게 친숙하게 만들었습니다."
"Spring Data Cassandra에서 Prepared Statements를 사용하는 방법은 무엇인가요?","CqlTemplate, AsyncCqlTemplate, 또는 ReactiveCqlTemplate을 통해 Prepared Statements를 사용할 수 있습니다. CassandraTemplate, AsyncCassandraTemplate, 또는 ReactiveCassandraTemplate의 템플릿 API를 기반으로 구축된 Cassandra repositories를 활성화하여 사용할 수 있습니다. CqlTemplate은 정적 CQL, Statement 객체 및 PreparedStatementCreator를 허용하는 다양한 메서드를 제공합니다. 정적 CQL을 추가 인수 없이 허용하는 메서드는 추가 처리 없이 CQL 문을 그대로 실행합니다. 정적 CQL과 인수 배열을 함께 허용하는 메서드는 Prepared Statements를 사용합니다. Spring Data Cassandra는 일반적으로 Prepared Statements에 대해 인덱스 기반 매개변수 바인딩을 사용합니다. Cassandra Driver 버전 4부터는 Prepared Statements가 드라이버 수준에서 캐시되므로 애플리케이션에서 Prepared Statements를 추적할 필요가 없습니다. 다음 예제는 매개변수화된 Prepared Statement로 쿼리를 발행하는 방법을 보여줍니다: Imperative Reactive 및 Mono 접근 방식입니다."
"CassandraTemplate을 사용하여 Prepared Statements를 사용하는 방법은 무엇인가요?","CassandraTemplate은 CqlTemplate 위에 구축되어 더 높은 수준의 추상화를 제공합니다. Prepared Statements의 사용 여부는 CassandraTemplate에서 직접 제어할 수 있습니다. setUsePreparedStatements(false) 또는 setUsePreparedStatements(true)를 호출하여 사용할 수 있습니다. CassandraTemplate에서 Prepared Statements의 사용은 기본적으로 활성화되어 있습니다. 다음 예제는 생성된 CQL 및 허용된 CQL을 사용하는 메서드를 보여줍니다: Imperative Reactive 및 Mono 접근 방식입니다."
"Spring Data Cassandra에서 Prepared Statements를 캐시하는 방법은 무엇인가요?","Cassandra Driver 4.0부터는 Prepared Statements가 CqlSession 캐시에 의해 캐시되므로 동일한 문자열을 두 번 준비하는 것은 괜찮습니다. 이전 버전은 드라이버 외부에서 Prepared Statements를 캐시해야 했습니다. 자세한 내용은 Driver 문서의 Prepared Statements 섹션을 참조하십시오."
"Spring Data에서 객체 매핑의 핵심 책임은 무엇인가요?","Spring Data 객체 매핑의 핵심 책임은 도메인 객체의 인스턴스를 생성하고 저장소 기본 데이터 구조를 해당 객체에 매핑하는 것입니다."
"Spring Data는 객체 생성을 위해 어떻게 필드 및 속성 액세스를 사용하나요?","Spring Data는 필드 및 속성 액세스를 사용하여 생성자 인수 목록을 통해 이미 채워지지 않은 경우 식별자 속성을 먼저 채웁니다. 그 후, 생성자에 의해 이미 채워지지 않은 모든 비 일시적 속성을 엔티티 인스턴스에 설정합니다."
"PersistenceConstructor는 어떻게 객체 생성을 위해 사용되나요?","PersistenceConstructor는 Spring Data에서 객체 생성을 위해 사용됩니다. PersistenceConstructor는 @PersistenceConstructor로 주석이 달린 생성자입니다. PersistenceConstructor는 도메인 객체의 인스턴스를 생성할 때 사용됩니다."
"스프링 변환기를 사용하여 어떻게 사용자 정의 이메일 값 객체로 문자열을 변환할 수 있나요?","@ReadingConverter 어노테이션을 사용하여 사용자 정의 이메일 값 객체로 문자열을 변환하는 스프링 변환기를 구현할 수 있습니다. 변환기의 convert 메서드에서 Email.valueOf() 메서드를 사용하여 문자열을 이메일 값 객체로 변환할 수 있습니다. 예를 들어: `@ReadingConverter public class EmailReadConverter implements Converter<String, Email> { public Email convert(String source) { return Email.valueOf(source); } }` (출처: <https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/converters.html>)"
"스프링 변환기를 사용하여 CassandraConverter에 대한 기본 매핑을 어떻게 재정의할 수 있나요?","스프링 변환기를 사용하여 CassandraConverter의 기본 매핑을 재정의하려면 MappingCassandraConverter에 스프링 변환기 인터페이스의 구현체를 만들고 등록해야 합니다. 변환기 인터페이스의 구현체를 만들고 MappingCassandraConverter에 등록하여 CassandraConverter의 기본 매핑 전략을 '탈취'할 수 있습니다. 예를 들어, 스프링 변환기를 사용하여 Person 객체를 Jackson 2를 사용하여 문자열로 변환하려면 다음과 같이 PersonWriteConverter를 구현할 수 있습니다: `class PersonWriteConverter implements Converter<Person, String> { public String convert(Person source) { try { return new ObjectMapper().writeValueAsString(source); } catch (IOException e) { throw new IllegalStateException(e); } } }` (출처: <https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/converters.html>)"
"스프링 변환기를 사용하여 CassandraConverter에서 읽기 및 변환을 어떻게 결합할 수 있나요?","스프링 변환기를 사용하여 CassandraConverter에서 읽기 및 변환을 결합하려면 Jackson 2를 사용하여 문자열을 Person 객체로 변환하는 변환기를 사용할 수 있습니다. 변환기의 convert 메서드에서 new ObjectMapper().readValue() 메서드를 사용하여 문자열을 Person 객체로 변환할 수 있습니다. 예를 들어, `class PersonReadConverter implements Converter<String, Person> { public Person convert(String source) { if (StringUtils.hasText(source)) { try { return new ObjectMapper().readValue(source, Person.class); } catch (IOException e) { throw new IllegalStateException(e); } } return null; } }` (출처: <https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/converters.html>)"
"Cassandra 매핑 프레임워크에서 application context event infrastructure를 기반으로 하는 것은 무엇인가요?","Spring Data Cassandra의 Lifecycle Events는 Spring의 application context event infrastructure를 기반으로 합니다. 이를 통해 Spring Integration과 같은 다른 제품들이 이벤트를 쉽게 수신할 수 있으며, Spring 기반 애플리케이션에서 잘 알려진 이벤트 메커니즘입니다."
"Spring Data Cassandra에서 Entity Callbacks를 사용하는 이유는 무엇인가요?","Entity Callbacks는 특정 메서드가 호출되기 전후에 엔티티를 수정하기 위한 훅을 제공합니다. Entity Callbacks는 동기 및 비동기 API와 모두 통합되어 처리 체인의 잘 정의된 체크포인트에서 순차적으로 실행되며, 잠재적으로 수정된 엔티티 또는 비동기 래퍼 유형을 반환합니다."
"Spring Data Cassandra에서 Entity Callbacks를 구현하는 방법은 무엇인가요?","Entity Callback는 해당 도메인 유형과 직접적으로 연관되어 있으며, 그 제네릭 타입 인자로 표시됩니다. 각 Spring Data 모듈은 일반적으로 엔티티 라이프사이클을 다루는 미리 정의된 EntityCallback 인터페이스 세트를 제공합니다. Entity Callback의 구현은 요구 사항에 따라 다양합니다."
"스프링 데이터 카산드라에서 감사 기능을 활성화하려면 어떻게 해야 하나요?","스프링 데이터 카산드라에서 감사 기능을 활성화하려면, 다음과 같은 예시와 같이 구성을 생성해야 합니다. Java 및 XML 구성에서 @EnableCassandraAuditing 및 <cassandra:auditing> 요소를 사용하여 감사 기능을 활성화할 수 있습니다. 또한, ReactiveAuditorAware 타입의 빈을 ApplicationContext에 노출시키면, 감사 인프라가 자동으로 이를 선택하고 도메인 유형에 설정할 현재 사용자를 결정하는 데 사용합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/auditing.html)"
"스프링 데이터 카산드라에서 감사 기능을 활성화하기 위해 어떤 속성을 구성할 수 있나요?","스프링 데이터 카산드라에서 감사 기능을 활성화하기 위해, @EnableCassandraAuditing의 auditorAwareRef 속성을 명시적으로 설정하여 사용할 구현체를 선택할 수 있습니다. 또한, <cassandra:auditing> 요소의 mapping-context-ref 및 auditor-aware-ref 속성을 구성하여 사용자 정의 매핑 컨텍스트 및 감사자 인식 구현체를 지정할 수 있습니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/auditing.html)"
"스프링 데이터 카산드라에서 반응형 프로그래밍 모델을 사용하여 감사 기능을 활성화하려면 어떻게 해야 하나요?","스프링 데이터 카산드라에서 반응형 프로그래밍 모델을 사용하여 감사 기능을 활성화하려면, @EnableReactiveCassandraAuditing 어노테이션을 사용해야 합니다. Java 및 XML 구성에서 @EnableReactiveCassandraAuditing 및 <cassandra:auditing> 요소를 사용하여 감사 기능을 활성화할 수 있습니다. 또한, ReactiveAuditorAware 타입의 빈을 ApplicationContext에 노출시키면, 감사 인프라가 자동으로 이를 선택하고 도메인 유형에 설정할 현재 사용자를 결정하는 데 사용합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/auditing.html)"
"스프링 데이터 리포지토리의 목표는 무엇인가요?","스프링 데이터 리포지토리 추상화의 목표는 다양한 지속성 저장소에 대한 데이터 액세스 레이어를 구현하는 데 필요한 보일러플레이트 코드의 양을 크게 줄이는 것입니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories.html)"
"스프링 데이터 캐시 리포지토리를 생성하는 방법은 무엇인가요?","스프링 데이터 캐시 리포지토리를 생성하려면 리포지토리 인터페이스를 정의하고 스프링에게 리포지토리 인스턴스를 생성하도록 지시해야합니다. 또한 쿼리 메서드를 정의하고 프로젝션을 사용하여 쿼리 결과의 모양을 제한할 수도 있습니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories.html)"
"스프링 데이터 캐시 리포지토리에서 쿼리 메서드 키워드에 대해 자세히 알려주세요.","스프링 데이터 캐시 리포지토리에서는 이름에 따라 쿼리 메서드를 자동으로 생성하는 키워드를 사용할 수 있습니다. 이러한 키워드에는 findBy, countBy, readBy 등이 포함됩니다. 또한 프로그래밍 방식으로 쿼리를 생성하기 위해 QueryDSL 및 JPA와 같은 쿼리 메서드 라이브러리를 사용할 수도 있습니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories.html)"
"스프링 데이터에서 Repository 인터페이스는 어떤 역할을 하나요?","스프링 데이터에서 Repository 인터페이스는 도메인 클래스와 도메인 클래스의 식별자 타입을 타입 인자로 받습니다. 이 인터페이스는 주로 작업할 타입을 캡처하고, 이 인터페이스를 확장하는 인터페이스를 발견하는 데 도움이 되는 마커 인터페이스로 작동합니다. CrudRepository와 ListCrudRepository 인터페이스는 관리 중인 엔티티 클래스에 대한 정교한 CRUD 기능을 제공합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/core-concepts.html#core-concepts)"
"CrudRepository 인터페이스에서 선언된 메서드는 어떻게 불리나요?","CrudRepository 인터페이스에서 선언된 메서드는 일반적으로 CRUD 메서드라고 불립니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/core-concepts.html#core-concepts)"
"PagingAndSortingRepository 인터페이스는 어떤 추가 메서드를 포함하고 있나요?","PagingAndSortingRepository 인터페이스는 엔티티에 대한 페이지화된 액세스를 용이하게 하는 추가 메서드를 포함하고 있습니다: Iterable<T> findAll(Sort sort); Page<T> findAll(Pageable pageable); (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/core-concepts.html#core-concepts)"
"도메인 클래스별 리포지토리 인터페이스를 정의하는 방법은 무엇인가요?","도메인 클래스별 리포지토리 인터페이스를 정의하려면, 먼저 Repository 인터페이스를 상속하고 도메인 클래스와 ID 타입으로 타입을 지정해야 합니다. 해당 도메인 타입에 대한 CRUD 메서드를 노출하려면 Repository 대신 CrudRepository 또는 그 변형 중 하나를 상속할 수 있습니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/definition.html)"
"Spring Data에서 리포지토리 인터페이스를 세밀하게 조정하는 방법은 무엇인가요?","Spring Data에서 리포지토리 인터페이스를 세밀하게 조정하려면, CrudRepository를 상속하는 것이 일반적인 방법입니다. 이렇게 하면 CRUD 기능을 위한 메서드를 사용할 수 있습니다. CRUD는 Create, Read, Update, Delete의 약자입니다. 버전 3.0부터는 ListCrudRepository도 도입되었으며, 이는 CrudRepository와 유사하지만 여러 엔티티를 반환하는 메서드에서는 Iterable 대신 List를 반환합니다. 반응형 스토어를 사용하는 경우 ReactiveCrudRepository, RxJava3CrudRepository를 선택할 수 있습니다. Kotlin을 사용하는 경우 CoroutineCrudRepository를 선택할 수 있습니다. 또한 PagingAndSortingRepository, ReactiveSortingRepository, RxJava3SortingRepository, CoroutineSortingRepository를 상속할 수도 있습니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/definition.html)"
"여러 Spring Data 모듈을 사용하여 리포지토리를 사용하는 방법은 무엇인가요?","여러 Spring Data 모듈을 사용하여 리포지토리를 사용하려면, 리포지토리 정의는 지속성 기술을 구분해야 합니다. Spring Data는 클래스패스에 여러 리포지토리 팩토리가 감지되면 엄격한 리포지토리 구성 모드로 전환됩니다. 엄격한 구성은 리포지토리 또는 도메인 클래스에 대한 세부 정보를 사용하여 특정 Spring Data 모듈에 대한 바인딩을 결정합니다. 도메인 클래스가 모듈별 타입 어노테이션으로 주석이 달린 경우 해당 Spring Data 모듈의 유효한 후보입니다. Spring Data 모듈은 타사 어노테이션(예: JPA의 @Entity)을 사용하거나 자체 어노테이션(예: Spring Data MongoDB 및 Spring Data Elasticsearch의 @Document)을 제공합니다. 리포지토리 정의가 모듈별 리포지토리를 상속하는 경우 해당 Spring Data 모듈의 유효한 후보입니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/definition.html)"
"Cassandra 데이터베이스에서 도메인 엔티티에 접근하기 위해 Spring Data에서 어떤 접근 방식을 사용하나요?","Cassandra 데이터베이스에서 도메인 엔티티에 접근하기 위해 Spring Data의 정교한 리포지토리 지원을 사용할 수 있습니다. 이를 위해 리포지토리 인터페이스를 생성하고, 엔티티와 리포지토리 인터페이스를 구성합니다."
"Cassandra 리포지토리에서 엔티티 ID에 대해 특별한 속성이 필요한가요?","네, Cassandra 리포지토리에서는 엔티티 ID에 대해 특별한 속성이 필요합니다. 기본적으로 MappingCassandraConverter에서 사용되는 변환 메커니즘은 id라는 이름의 속성을 행 ID로 간주합니다."
"Cassandra 리포지토리를 구성하기 위해 Java와 XML 구성 중 어떤 것을 선택할 수 있나요?","Cassandra 리포지토리를 구성하기 위해 Java와 XML 구성 중 선택할 수 있습니다. Java 구성을 사용하면 @EnableCassandraRepositories 또는 @EnableReactiveCassandraRepositories 어노테이션을 사용하고, Spring 구성 클래스에서 base package를 지정할 수 있습니다. XML 구성을 사용하면 cassandra:repositories 네임스페이스 요소를 사용하여 base package를 지정하고, 필요한 Cassandra 리소스를 구성합니다."
"스프링 데이터에서 리포지토리 인스턴스를 생성하는 방법은 무엇인가요?","리포지토리 인터페이스에 대한 인스턴스와 빈 정의를 생성하는 방법은 Java 구성 및 XML 구성 두 가지입니다. Java 구성에서는 Java 구성 클래스에 저장소별 @EnableCassandraRepositories 어노테이션을 사용하여 리포지토리 활성화에 대한 구성을 정의합니다. XML 구성에서는 각 스프링 데이터 모듈에 스프링이 스캔하여 기본 패키지를 정의할 수 있는 리포지토리 요소가 포함되어 있습니다. Spring은 com.acme.repositories 및 하위 패키지에서 Repository 또는 해당 하위 인터페이스를 확장하는 인터페이스를 스캔하도록 지시됩니다. 각 인터페이스에 대해 인프라가 적절한 프록시를 생성하는 지속성 기술별 FactoryBean을 등록합니다. 각 빈은 인터페이스 이름에서 파생된 빈 이름으로 등록되므로 UserRepository 인터페이스는 userRepository로 등록됩니다. 필터 사용, 독립 실행형 사용 등도 스프링 데이터에서 리포지토리 인스턴스를 생성하는 데 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/create-instances.html)"
"Java 구성에서 스프링 데이터 리포지토리 구성을 활성화하는 방법은 무엇인가요?","Java 구성에서 스프링 데이터 리포지토리 구성을 활성화하려면 Java 구성 클래스에 저장소별 @EnableCassandraRepositories 어노테이션을 사용해야 합니다. 그런 다음, repositories 요소를 사용하여 Spring이 스캔할 기본 패키지를 정의합니다. 예를 들어, 다음 샘플 구성은 JPA 리포지토리를 활성화합니다. Java 구성에서 스프링 데이터 리포지토리 구성을 활성화하려면 @Configuration 및 @EnableJpaRepositories 어노테이션을 적용해야 합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/create-instances.html)"
"XML 구성에서 스프링 데이터 리포지토리 구성을 활성화하는 방법은 무엇인가요?","XML 구성에서 스프링 데이터 리포지토리 구성을 활성화하려면 각 스프링 데이터 모듈에 스프링이 스캔하여 기본 패키지를 정의할 수 있는 repositories 요소가 포함되어 있습니다. 예를 들어, 다음 샘플 구성은 JPA 리포지토리를 활성화합니다. XML 구성에서 스프링 데이터 리포지토리 구성을 활성화하려면 jpa 네임스페이스를 사용해야 합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/create-instances.html)"
"Spring Data Cassandra에서 쿼리를 생성하는 방법은 무엇인가요?","Spring Data Cassandra에서 쿼리를 생성하려면, 리포지토리 인터페이스에서 쿼리 메서드를 정의할 수 있습니다. 쿼리 메서드는 쿼리의 이름을 직접 파싱하거나, 수동으로 정의된 쿼리를 사용할 수 있습니다. 쿼리 메서드 이름은 메서드 이름에서 직접 쿼리를 파싱하거나, 선언된 쿼리를 사용하여 쿼리를 파싱하는 두 가지 전략을 사용하여 파싱됩니다. 쿼리 메서드 이름 파싱은 주제와 술어로 나뉩니다. 첫 번째 부분(find...By, exists...By)은 쿼리의 주제를 정의하고, 두 번째 부분은 술어를 형성합니다. 소개 절(주제)에는 추가 표현이 포함될 수 있습니다. find(또는 다른 소개 키워드)와 By 사이의 모든 텍스트는 생성될 쿼리에 대한 distinct 플래그를 설정하기 위해 Distinct와 같은 결과 제한 키워드를 사용하거나, 쿼리 결과를 제한하기 위해 Top/First를 사용하지 않는 한 설명적인 것으로 간주됩니다. 속성 표현은 관리되는 엔티티의 직접 속성만 참조할 수 있지만, 중첩된 속성을 탐색하여 제약 조건을 정의할 수도 있습니다."
"Spring Data Cassandra에서 쿼리 결과를 처리하는 다양한 방법은 무엇인가요?","Spring Data Cassandra에서 쿼리 결과를 처리하는 방법에는 여러 가지가 있습니다. List<T>, Set<T>, Iterable<T>와 같은 표준 Java 컬렉션을 사용하여 결과를 반환할 수 있습니다. 또한, Streamable, Vavr 컬렉션, Java 8 Stream<T>와 같은 다른 유형을 사용하여 결과를 반환할 수도 있습니다. Stream<T>를 사용하여 쿼리 결과를 점진적으로 처리할 수 있습니다. 또한, @Async 어노테이션을 사용하여 리포지토리 쿼리를 비동기적으로 실행할 수 있습니다. 페이지네이션, 정렬 및 제한을 위해 Pageable, Sort 및 Limit 매개변수를 사용하여 쿼리에 동적으로 적용할 수 있습니다. 또한, Top 또는 First 키워드를 사용하여 쿼리 결과를 제한할 수 있습니다."
"Spring Data Cassandra에서 쿼리 메서드 이름 파싱에서 속성 표현식과 경로 모호성 개념은 무엇인가요?","Spring Data Cassandra에서 쿼리 메서드 이름 파싱에서 속성 표현식은 관리되는 엔티티의 속성을 참조하는 제약 조건입니다. 속성 표현식은 중첩된 속성을 탐색하여 정의할 수 있습니다. 속성 표현식은 일반적으로 연산자와 결합된 속성 탐색입니다. 경로 모호성은 속성 경로가 여러 속성과 일치할 수 있는 경우 발생합니다. 속성 표현식에서 모호성을 해결하기 위해 메서드 이름에 _를 사용하여 수동으로 탐색 지점을 정의할 수 있습니다."
"Spring Data Cassandra에서 쿼리 메소드는 어떻게 선언되나요?","Spring Data Cassandra에서 쿼리 메소드는 리포지토리 인터페이스에 메소드를 선언함으로써 정의됩니다. 쿼리 메소드의 이름은 Apache Cassandra 데이터베이스에서 실행되는 쿼리를 파싱하여 제약 조건을 파싱합니다. 쿼리 메소드의 이름은 SELECT * FROM person WHERE lastname = 'lastname'와 같은 쿼리 표현식으로 변환됩니다."
"Spring Data Cassandra에서 쿼리에 페이징을 어떻게 적용하나요?","Spring Data Cassandra에서 쿼리에 페이징을 적용하려면 메소드 시그니처에 Pageable 매개변수를 추가하고 메소드가 Slice 인스턴스를 반환하도록 하면 됩니다. 이렇게하면 자동으로 쿼리가 페이지 단위로 분할됩니다."
"Spring Data Cassandra에서 QueryOptions 객체를 사용하는 방법은 무엇인가요?","QueryOptions 객체를 사용하여 쿼리 메소드에 대한 쿼리 옵션을 지정할 수 있습니다. QueryOptions 객체를 전달하여 쿼리 실행 전에 쿼리에 옵션을 적용합니다. QueryOptions는 쿼리 매개변수로 취급되지 않으므로 쿼리 매개변수 값으로 간주되지 않습니다. 쿼리 옵션은 파생된 문자열 @Query 리포지토리 메소드 및 쿼리 메소드에 적용됩니다. 일관성 수준을 정적으로 설정하려면 쿼리 메소드에 @Consistency 어노테이션을 사용합니다."
"스프링 데이터에서 프로덕션을 사용하는 목적은 무엇인가요?","스프링 데이터에서 프로덕션은 쿼리 메소드가 리포지토리에서 관리하는 어그리게이트 루트의 특정 속성을 기반으로 프로덕션을 생성하는 데 사용됩니다. 이를 통해, 관리되는 어그리게이트의 부분적인 뷰를 더 선택적으로 검색할 수 있습니다. 프로덕션 유형은 엔티티의 유형 계층 구조 외부에 있는 유형입니다. 엔티티가 구현하는 슈퍼클래스 및 인터페이스는 유형 계층 구조 내부에 있으므로 슈퍼타입(또는 구현된 인터페이스)을 반환하면 완전히 구체화된 엔티티의 인스턴스가 반환됩니다. 프로덕션에는 인터페이스 기반 프로덕션과 클래스 기반 프로덕션(DTO)의 두 가지 유형이 있습니다. 인터페이스 기반 프로덕션은 읽기 위해 노출된 속성에 대한 접근자 메소드를 노출하는 인터페이스를 선언하여 구현되며, 클래스 기반 프로덕션은 값 유형 데이터 전송 객체(DTO)를 사용하여 검색할 필드에 대한 속성을 보유합니다."
"인터페이스 기반 프로덕션과 클래스 기반 프로덕션(DTO)의 차이점은 무엇인가요?","인터페이스 기반 프로덕션은 쿼리 메소드가 리포지토리에서 관리하는 어그리게이트 루트의 특정 속성을 기반으로 프로덕션을 생성하는 데 사용되는 프로덕션 인터페이스입니다. 반면, 클래스 기반 프로덕션(DTO)은 검색할 필드에 대한 속성을 보유하는 값 유형 데이터 전송 객체(DTO)를 사용하여 구현됩니다. 인터페이스 기반 프로덕션은 런타임에 해당 인터페이스의 프록시 인스턴스를 만들고 노출된 메소드에 대한 호출을 대상 객체로 전달합니다. 클래스 기반 프로덕션(DTO)은 프록시 생성이나 중첩된 프로덕션을 적용하지 않습니다. 대신, 생성자가 노출하는 매개 변수 이름에서 로드를 제한해야 하는 필드가 결정됩니다."
"스프링 데이터에서 프로덕션에 대해 어떤 유형의 널 래퍼를 사용할 수 있나요?","스프링 데이터에서 프로덕션에 대해 사용할 수 있는 널 래퍼 유형은 java.util.Optional, com.google.common.base.Optional, scala.Option, io.vavr.control.Option입니다. 널 가능한 래퍼를 사용하는 프로덕션 인터페이스는 Optional<String> getFirstname();과 같이 사용할 수 있습니다. 기본 프로덕션 값이 null이 아닌 경우, 값은 래퍼 유형의 현재 표현을 사용하여 반환됩니다. 기본 값이 null인 경우, getter 메소드는 사용된 래퍼 유형의 빈 표현을 반환합니다."
"스프링 데이터에서 커스텀 리포지토리 구현을 어떻게 할 수 있나요?","스프링 데이터에서 커스텀 리포지토리 구현을 하려면, 커스텀 기능을 위한 프래그먼트 인터페이스와 구현체를 정의해야 합니다. 클래스 이름에서 가장 중요한 부분은 Impl 접미사입니다. 구현체는 스프링 데이터에 의존하지 않으며, 일반적인 스프링 빈일 수 있습니다. 그런 다음 리포지토리 인터페이스를 프래그먼트 인터페이스로 확장하여 클라이언트에게 CRUD 및 커스텀 기능을 사용할 수 있도록 합니다."
"스프링 데이터에서 커스텀 리포지토리 구현의 우선순위는 어떻게 되나요?","커스텀 구현체는 기본 구현체 및 리포지토리 어스펙트보다 우선순위가 높습니다. 이 순서는 기본 리포지토리 및 어스펙트 메서드를 오버라이드하고, 두 개의 프래그먼트가 동일한 메서드 시그니처를 제공하는 경우 모호성을 해결합니다."
"스프링 데이터에서 커스텀 리포지토리 구현을 수동으로 연결하는 방법은 무엇인가요?","커스텀 구현체가 어노테이션 기반 구성 및 자동 와이어링만 사용하는 경우, 이전 섹션에서 설명한 접근 방식을 사용하면 됩니다. 구현 프래그먼트 빈이 특별한 와이어링이 필요한 경우, 빈을 선언하고 이전 섹션에서 설명한 규칙에 따라 이름을 지정할 수 있습니다. 인프라는 자동으로 빈 정의를 만드는 대신, 수동으로 정의된 빈 정의를 이름으로 참조합니다."
"Spring Data에서 @DomainEvents 어노테이션을 사용하는 목적은 무엇인가요?","@DomainEvents 어노테이션은 Aggregate Roots에서 도메인 이벤트를 게시하기 위해 사용됩니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/core-domain-events.html)"
"Aggregate Roots에서 도메인 이벤트를 게시하는 방법은 무엇인가요?","Aggregate Roots에서 도메인 이벤트를 게시하기 위해 @DomainEvents 어노테이션을 사용하고, 이 어노테이션이 적용된 메서드에서 이벤트 인스턴스 또는 이벤트 컬렉션을 반환할 수 있습니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/core-domain-events.html)"
"@AfterDomainEventPublication 어노테이션은 어떤 용도로 사용되나요?","@AfterDomainEventPublication 어노테이션은 모든 이벤트가 게시된 후에 호출되는 메서드에 사용됩니다. 이 메서드는 게시될 이벤트 목록을 정리하는 등의 용도로 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/core-domain-events.html)"
"스프링 데이터 리포지토리 메소드의 널 처리는 어떻게 하나요?","스프링 데이터 2.0부터는 리포지토리 CRUD 메소드에서 개별 애그리게이트 인스턴스를 반환할 때 Java 8의 Optional을 사용하여 값의 부재를 나타냅니다. 또한, 스프링 데이터는 쿼리 메소드에서 다음과 같은 래퍼 유형을 반환하는 것을 지원합니다: com.google.common.base.Optional, scala.Option, io.vavr.control.Option. 또는 쿼리 메소드는 래퍼 유형을 사용하지 않을 수도 있습니다. 쿼리 결과의 부재는 null을 반환하여 나타냅니다. 컬렉션, 컬렉션 대안, 래퍼 및 스트림을 반환하는 리포지토리 메소드는 null이 아닌 해당 빈 표현을 반환합니다. 자세한 내용은 '리포지토리 쿼리 반환 유형(query-return-types-reference.html)'을 참조하십시오. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/null-handling.html)"
"스프링 데이터에서 리포지토리 메소드의 널 불변성을 표현하는 방법은 무엇인가요?","스프링 프레임워크의 널 불변성 어노테이션(https://docs.spring.io/spring-framework/reference/6.1/core/null-safety.html)을 사용하여 리포지토리 메소드의 널 불변성 제약을 표현할 수 있습니다. 이들은 도구 친화적인 접근 방식과 런타임 중 옵트인 널 체크를 제공합니다. 예를 들어, @NonNullApi(https://docs.spring.io/spring-framework/docs/6.1.13/javadoc-api/org/springframework/lang/NonNullApi.html)는 패키지 수준에서 사용되어 매개변수 및 반환 값의 기본 동작이 각각 널 값을 허용하거나 생성하지 않음을 선언합니다. @NonNull(https://docs.spring.io/spring-framework/docs/6.1.13/javadoc-api/org/springframework/lang/NonNull.html)은 널이 아니어야 하는 매개변수 또는 반환 값에 사용됩니다(패키지 수준에서 @NonNullApi가 적용되는 매개변수 및 반환 값에는 필요하지 않음). @Nullable(https://docs.spring.io/spring-framework/docs/6.1.13/javadoc-api/org/springframework/lang/Nullable.html)은 널일 수 있는 매개변수 또는 반환 값에 사용됩니다. 스프링 어노테이션은 JSR 305(https://jcp.org/en/jsr/detail?id=305) 어노테이션(휴면 중이지만 널리 사용되는 JSR)으로 메타 어노테이션됩니다. JSR 305 메타 어노테이션은 도구 공급업체(예: IDEA(https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html), Eclipse(https://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm), Kotlin(https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types))가 스프링 어노테이션에 대한 지원을 하드 코딩하지 않고도 일반적인 방법으로 널 안전 지원을 제공할 수 있도록 합니다. 쿼리 메소드의 널 불변성 제약 조건에 대한 런타임 검사를 활성화하려면 다음 예제와 같이 package-info.java에서 스프링의 @NonNullApi를 사용하여 패키지 수준에서 널이 아닌 기본값을 활성화해야 합니다. package-info.java에서 널이 아닌 기본값을 선언하려면 @org.springframework.lang.NonNullApi 패키지 com.acme;. 널이 아닌 기본값이 설정되면 리포지토리 쿼리 메소드 호출은 널 불변성 제약 조건에 대해 런타임에서 유효성이 검사됩니다. 쿼리 결과가 정의된 제약 조건을 위반하면 예외가 발생합니다. 이는 메소드가 null을 반환하지만 널이 아닌 것으로 선언된 경우(리포지토리가 있는 패키지에 정의된 어노테이션으로 기본값) 발생합니다. 다시 널 가능한 결과에 대해 옵트인하려면 개별 메소드에서 @Nullable을 선택적으로 사용하십시오. 이 섹션의 시작 부분에서 언급된 결과 래퍼 유형을 사용하는 것은 예상대로 계속 작동합니다. 빈 결과는 부재를 나타내는 값으로 변환됩니다. 다음 예제는 방금 설명한 여러 기술을 보여줍니다. 다양한 널 불변성 제약 조건 사용 패키지 com.acme;. (1) import org.springframework.lang.Nullable; 인터페이스 UserRepository extends Repository<User, Long> { User getByEmailAddress(EmailAddress emailAddress); (2) @Nullable User findByEmailAddress(@Nullable EmailAddress emailAdress); (3) Optional<User> findOptionalByEmailAddress(EmailAddress emailAddress); (4) } 1. 리포지토리는 우리가 널이 아닌 동작을 정의한 패키지(또는 하위 패키지)에 있습니다. 2. 쿼리가 결과를 생성하지 않을 때 EmptyResultDataAccessException를 throw합니다. 메소드에 전달된 emailAddress가 null인 경우 IllegalArgumentException을 throw합니다. 3. 쿼리가 결과를 생성하지 않을 때 null을 반환합니다. 또한 emailAddress의 값으로 null을 허용합니다. 4. 쿼리가 결과를 생성하지 않을 때 Optional.empty()를 반환합니다. 메소드에 전달된 emailAddress가 null인 경우 IllegalArgumentException을 throw합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/repositories/null-handling.html)"
"Spring Data for Apache Cassandra에서 CDI 통합을 어떻게 활성화할 수 있나요?","Spring Data for Apache Cassandra JAR을 클래스패스에 드롭하여 CDI 통합을 활성화할 수 있습니다. 이 확장은 CassandraOperations를 CDI 빈으로 사용하고 컨테이너에서 리포지토리 유형의 빈이 요청될 때마다 Spring Data 리포지토리의 프록시를 생성합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/repositories/cdi-integration.html)"
"Spring Data for Apache Cassandra에서 CDI Producer를 구현하는 방법은 무엇인가요?","Spring Data for Apache Cassandra에서 CDI Producer를 구현하려면 CassandraTemplate을 확장하고 CqlSession을 생성하는 createSession 메서드와 CassandraOperations를 생성하는 createCassandraOperations 메서드를 구현해야 합니다. 이러한 메서드는 @Produces 어노테이션으로 주석이 달려 있어야 합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/repositories/cdi-integration.html)"
"Spring Data for Apache Cassandra에서 Spring Data 리포지토리의 인스턴스를 어떻게 얻을 수 있나요?","Spring Data for Apache Cassandra에서 Spring Data 리포지토리의 인스턴스를 얻으려면 리포지토리 인터페이스를 주입 속성으로 선언해야 합니다. 이렇게 하면 컨테이너에서 리포지토리 유형의 빈이 요청될 때마다 리포지토리의 프록시가 생성됩니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/cassandra/repositories/cdi-integration.html)"
"스프링 데이터 리포지토리에서 쿼리 메소드에서 일반적으로 지원되는 서브젝트 키워드는 무엇인가요?","스프링 데이터 리포지토리 쿼리 파생 메커니즘에서 일반적으로 지원되는 서브젝트 키워드는 다음과 같습니다: `find…By`, `read…By`, `get…By`, `query…By`, `search…By`, `stream…By`, `exists…By`, `count…By`, `delete…By`, `remove…By`, `…First<number>…`, `…Top<number>…`, `…Distinct…`. 각 키워드에 대한 설명은 주어진 정보에서 확인할 수 있습니다."
"스프링 데이터 리포지토리 쿼리 파생 메커니즘에서 일반적으로 지원되는 프래딕트 키워드와 수정자는 무엇인가요?","스프링 데이터 리포지토리 쿼리 파생 메커니즘에서 일반적으로 지원되는 프래딕트 키워드와 수정자는 다음과 같습니다: 논리 연산자, 비교 연산자, 존재 여부 검사, 부정 단어, 정규 표현식 매칭, 대소문자 무시, 정적 정렬 지정. 각 키워드와 수정자에 대한 설명은 주어진 정보에서 확인할 수 있습니다."
"특정 데이터 저장소에서 지원되는 키워드와 수정자는 어떻게 알 수 있나요?","특정 데이터 저장소에서 지원되는 키워드와 수정자는 해당 데이터 저장소의 스토어별 문서를 참조해야 합니다. 주어진 정보에 따르면, 일부 키워드는 특정 데이터 저장소에서 지원되지 않을 수 있으므로, 스토어별 문서를 참고하여 정확한 지원 목록을 확인해야 합니다."
"스프링 데이터 리포지토리에서 일반적으로 지원되는 쿼리 반환 유형은 무엇인가요?","스프링 데이터 리포지토리에서 일반적으로 지원되는 쿼리 반환 유형은 void, 기본 Java 유형, 래퍼 유형, T, Iterator<T>, Collection<T>, List<T>, Optional<T>, Option<T>, Stream<T>, Streamable<T>, Vavr 컬렉션 유형, Future<T>, CompletableFuture<T>, Slice<T>, Page<T>, Window<T>, GeoResult<T>, GeoResults<T>, GeoPage<T>, Mono<T>, Flux<T>, Single<T>, Maybe<T>, Flowable<T>입니다. 자세한 내용은 각 데이터 저장소별 문서를 참조하십시오."
"스프링 데이터 리포지토리에서 Geospatial 유형은 어떤 데이터 저장소에서 지원되나요?","스프링 데이터 리포지토리에서 Geospatial 유형(GeoResult, GeoResults, GeoPage 등)은 지리 공간 쿼리를 지원하는 데이터 저장소에서만 사용할 수 있습니다."
"스프링 데이터 리포지토리에서 QueryMethodEvaluator는 어떤 역할을 하나요?","스프링 데이터 리포지토리에서 QueryMethodEvaluator는 쿼리 메서드 인수를 파싱하고 쿼리를 실행하기 위해 필요한 정보를 추출하는 역할을 합니다."
"스프링 데이터 카산드라에서 CassandraObservationConvention을 어떻게 구성할 수 있나요?","ObservableCqlSessionFactoryBean 및 ObservableReactiveSessionFactoryBean을 사용하여 CassandraObservationConvention을 구성할 수 있습니다. 이 클래스들은 CassandraObservationConvention을 구성할 수 있는 옵션을 제공합니다. 또한, OpenTelemetry Semantic Conventions를 참조하여 더 많은 정보를 얻을 수 있습니다."
"스프링 데이터 카산드라에서 Cassandra 쿼리 관측을 위한 메트릭 이름은 무엇인가요?","Cassandra 쿼리 관측을 위한 메트릭 이름은 spring.data.cassandra.query입니다. 이 메트릭은 타이머 유형이며 기본 단위는 초입니다."
"스프링 데이터 카산드라에서 Cassandra 쿼리 관측 스팬에 어떤 태그 키가 사용되나요?","Cassandra 쿼리 관측 스팬에 사용되는 태그 키는 db.cassandra.consistency_level, db.cassandra.coordinator.dc, db.cassandra.coordinator.id, db.cassandra.idempotence, db.cassandra.page_size, db.name, db.operation, db.statement, db.system, net.peer.name, net.peer.port, net.sock.peer.addr, net.sock.peer.port, net.transport, spring.data.cassandra.methodName, spring.data.cassandra.node[%s].error, spring.data.cassandra.sessionName 등이 있습니다."
"Kotlin은 Spring Data와 어떻게 사용되나요?","Kotlin은 JVM을 대상으로 하는 정적 타입 언어이며, Java로 작성된 기존 라이브러리와의 상호 운용성이 뛰어납니다. Spring Data는 Kotlin을 기본적으로 지원하며, 개발자가 Kotlin 네이티브 프레임워크인 것처럼 Kotlin 애플리케이션을 작성할 수 있도록 합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/kotlin.html)"
"Spring Boot에서 Kotlin을 사용하는 가장 쉬운 방법은 무엇인가요?","Spring Boot에서 Kotlin을 사용하는 가장 쉬운 방법은 Spring Boot와 Kotlin 전용 지원을 활용하는 것입니다. 이 포괄적인 자습서에서는 start.spring.io를 사용하여 Kotlin으로 Spring Boot 애플리케이션을 빌드하는 방법을 배울 수 있습니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/kotlin.html)"
"Kotlin의 코루틴 기능은 무엇인가요?","코루틴은 Kotlin의 비동기적인 프로그래밍을 위한 기능으로, 경량화된 동시성을 제공합니다. 이 기능은 Kotlin에서 Kotlin 코드와 Java 코드를 함께 사용할 수 있도록 도와줍니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/kotlin.html)"
"Spring Data가 Kotlin을 지원하기 위해 필요한 최소 버전은 무엇인가요?","Spring Data는 Kotlin 1.3을 지원합니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/kotlin/requirements.html)"
"Spring Data를 Kotlin으로 사용할 때 필요한 라이브러리는 무엇인가요?","kotlin-stdlib (또는 kotlin-stdlib-jdk8와 같은 변형)과 kotlin-reflect가 클래스패스에 있어야 합니다. 이 라이브러리는 start.spring.io를 통해 Kotlin 프로젝트를 시작할 때 기본적으로 제공됩니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/kotlin/requirements.html)"
"Spring Data의 Kotlin 요구 사항을 충족하기 위해 start.spring.io를 사용하는 이점은 무엇인가요?","Spring Data의 Kotlin 요구 사항을 충족하기 위해 필요한 라이브러리인 kotlin-stdlib와 kotlin-reflect가 기본적으로 제공됩니다. (출처: https://docs.spring.io/spring-data/cassandra/reference/4.3/kotlin/requirements.html)"
"코틀린의 널 안전성은 어떻게 동작하며, 자바와 비교했을 때 어떤 장점이 있나요?","코틀린의 널 안전성은 컴파일 시간에 널 값을 깨끗하게 처리합니다. 이를 통해 널 가능성 선언과 '값이 있거나 없는' 의미론을 표현하며, Optional과 같은 래퍼를 사용하지 않아도 됩니다. 반면, 자바는 타입 시스템에서 널 안전성을 표현할 수 없지만, Spring Data API는 org.springframework.lang 패키지에 선언된 JSR-305(https://jcp.org/en/jsr/detail?id=305) 도구 친화적인 어노테이션으로 주석 처리됩니다. 이를 통해 코틀린 개발자는 Spring Data API 전체에 대한 널 안전성을 컴파일 시간에 처리할 수 있습니다. Kotlin의 JSR-305 어노테이션 및 Spring nullability 어노테이션에 대한 지원은 Spring Data API의 널 안전성을 제공합니다. 자세한 내용은 https://docs.spring.io/spring-data/cassandra/reference/4.3/kotlin/null-safety.html을 참조하십시오."
"Kotlin의 -Xjsr305 컴파일러 플래그는 어떤 역할을 하며, 가능한 옵션은 무엇인가요?","Kotlin의 -Xjsr305 컴파일러 플래그는 JSR-305 체크를 구성하는 데 사용됩니다. 가능한 옵션은 다음과 같습니다: -Xjsr305={strict|warn|ignore}. 기본적으로 Kotlin 버전 1.1 이상의 경우 기본 동작은 -Xjsr305=warn과 동일합니다. Spring Data API의 널 안전성을 고려하려면 strict 값이 필요합니다. 자세한 내용은 https://docs.spring.io/spring-data/cassandra/reference/4.3/kotlin/null-safety.html을 참조하십시오."
"Kotlin에서 Spring API에서 추론된 타입의 널 안전성에 대해 어떤 고려 사항이 필요한가요?","Kotlin에서 Spring API에서 추론된 타입은 플랫폼 타입으로 인식되어 널 체크가 완화됩니다. 그러나 Spring API의 널 가능성 선언은 마이너 릴리스 간에도 변경될 수 있으며, 앞으로 더 많은 체크가 추가될 수 있습니다. 따라서 이러한 타입을 사용할 때는 이 점을 고려해야 합니다. 또한, 제네릭 타입 인수, varargs 및 배열 요소의 널 안전성은 아직 지원되지 않지만, 향후 릴리스에서 지원될 예정입니다. 자세한 내용은 https://docs.spring.io/spring-data/cassandra/reference/4.3/kotlin/null-safety.html을 참조하십시오."
"Kotlin 객체가 Spring Data Cassandra에서 어떻게 구체화되는지 알려주세요.","Kotlin 객체가 Spring Data Cassandra에서 구체화되는 방법에 대한 자세한 내용은 Kotlin 지원(https://docs.spring.io/spring-data/cassandra/reference/4.3/kotlin/object-mapping.html)을 참조하세요."
"Spring Data Cassandra에서 Kotlin 객체 매핑에 대한 자세한 정보를 얻을 수 있는 곳은 어디인가요?","Spring Data Cassandra에서 Kotlin 객체 매핑에 대한 자세한 정보는 Kotlin 지원(https://docs.spring.io/spring-data/cassandra/reference/4.3/kotlin/object-mapping.html)을 참조하세요."
"Spring Data Cassandra에서 Kotlin과 관련하여 객체 매핑에 대해 어떤 내용을 알 수 있나요?","Spring Data Cassandra에서 Kotlin과 관련하여 객체 매핑에 대한 정보는 Kotlin 지원(https://docs.spring.io/spring-data/cassandra/reference/4.3/kotlin/object-mapping.html)에서 확인할 수 있습니다."
"Kotlin Coroutines란 무엇인가요?","Kotlin Coroutines는 비동기식 코드를 쉽게 작성할 수 있도록 도와주는 Kotlin의 기능입니다. 이를 통해 개발자는 코루틴을 사용하여 비동기적인 작업을 수행할 수 있습니다."
"Spring Data에서 Coroutines를 지원하는 범위는 어떻게 되나요?","Spring Data에서는 Kotlin Coroutines의 Deferred와 Flow를 지원합니다. 이를 통해 Coroutines를 사용하여 비동기적인 작업을 수행할 수 있습니다."
"Reactive와 Coroutines를 비교하면 어떻게 되나요?","Reactive는 비동기적인 작업을 처리하는 데 사용되는 프로그래밍 패러다임이며, Coroutines는 Kotlin에서 비동기적인 코드를 쉽게 작성할 수 있도록 도와주는 기능입니다. Coroutines는 Reactive보다 더 간단하고 쉽게 사용할 수 있습니다."
"Spring Data Elasticsearch는 엘라스틱서치 데이터베이스와 어떻게 상호 작용하나요?","Spring Data Elasticsearch는 엘라스틱서치 데이터베이스에 대한 리포지토리 지원을 제공하여 일관된 프로그래밍 모델로 엘라스틱서치 데이터 소스에 액세스해야 하는 애플리케이션의 개발을 용이하게 합니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/index.html)"
"Spring Data Elasticsearch 클라이언트 구성에 대한 정보는 어디에서 찾을 수 있나요?","Spring Data Elasticsearch 클라이언트 구성에 대한 정보는 엘라스틱서치 클라이언트 구성 섹션에서 찾을 수 있습니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/index.html)"
"Spring Data Elasticsearch의 이전 버전과의 호환성 정보는 어떻게 확인할 수 있나요?","Spring Data Elasticsearch의 이전 버전과의 호환성 정보는 버전 호환성 매트릭스를 참조하면 됩니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/index.html)"
"Spring Data를 업그레이드하는 방법에 대한 지침은 어디에서 찾을 수 있나요?","Spring Data를 업그레이드하는 방법에 대한 지침은 프로젝트 위키(https://github.com/spring-projects/spring-data-commons/wiki)에서 찾을 수 있습니다."
"Spring Data를 업그레이드하기 전에 어떤 버전을 확인해야 하나요?","Spring Data를 업그레이드하기 전에 버전 기록(https://github.com/spring-projects/spring-data-commons/wiki#release-notes)의 링크를 따라가서 원하는 버전을 찾을 수 있습니다."
"여러 버전을 건너뛰고 업그레이드할 때 고려해야 할 사항은 무엇인가요?","여러 버전을 건너뛰고 업그레이드할 경우, 건너뛴 버전의 릴리스 노트를 검토하는 것이 좋습니다."
"Spring Data Elasticsearch의 4.2.x에서 4.3.x로의 업그레이드에 대한 자세한 설명은 어디에서 찾을 수 있나요?","Spring Data Elasticsearch의 4.2.x에서 4.3.x로의 업그레이드에 대한 자세한 설명은 다음 링크에서 확인할 수 있습니다: https://docs.spring.io/spring-data/elasticsearch/reference/html/#migration-guides. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/migration-guides.html)"
"Spring Data Elasticsearch의 3.2.x에서 4.0.x로의 업그레이드에 대한 문서는 어디에서 찾을 수 있나요?","Spring Data Elasticsearch의 3.2.x에서 4.0.x로의 업그레이드에 대한 문서는 다음 링크에서 확인할 수 있습니다: https://docs.spring.io/spring-data/elasticsearch/reference/html/#migration-guides. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/migration-guides.html)"
"Spring Data Elasticsearch의 5.3.x로 업그레이드하는 데 도움이 되는 문서는 어떤 것이 있나요?","Spring Data Elasticsearch의 5.3.x로 업그레이드하는 데 도움이 되는 문서는 5.2.x에서 5.3.x로의 업그레이드 가이드입니다. 다음 링크에서 확인할 수 있습니다: https://docs.spring.io/spring-data/elasticsearch/reference/html/#migration-guides. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/migration-guides.html)"
"Spring Data Elasticsearch 4.0.x에서 Elasticsearch용 JSON 표현으로 엔티티를 매핑하는 데 사용되는 기본 맵퍼는 무엇인가요?","Spring Data Elasticsearch 4.0.x에서는 Elasticsearch용 JSON 표현으로 엔티티를 매핑하는 데 메타 모델 기반 컨버터(ElasticsearchEntityMapper)가 사용됩니다. 3.2.x 버전에서는 Jackson Mapper가 사용되었습니다. (출처: {https://docs.spring.io/spring-data/elasticsearch/reference/5.3/migration-guides/migration-guide-3.2-4.0.html})"
"Spring Data Elasticsearch 4.0.x에서 쿼리 객체의 인덱스 이름을 암시적으로 지정하는 방법이 변경되었나요?","Spring Data Elasticsearch 4.0.x에서는 쿼리 객체의 인덱스 이름을 암시적으로 지정하는 방법이 변경되었습니다. 이제 인덱스 이름(들)은 IndexCoordinates 유형의 추가 매개변수로 제공되어야 합니다. 이 분리를 통해 동일한 쿼리 객체를 다른 인덱스에 사용할 수 있습니다. 예를 들어, 이전 코드는 다음과 같이 변경되어야 합니다: `String documentId = elasticsearchOperations.index(indexQuery);`는 `IndexCoordinates indexCoordinates = elasticsearchOperations.getIndexCoordinatesFor(person.getClass()); IndexQuery indexQuery = new IndexQueryBuilder() .withId(person.getId().toString()) .withObject(person) .build(); String documentId = elasticsearchOperations.index(indexQuery, indexCoordinates);`로 변경되어야 합니다. (출처: {https://docs.spring.io/spring-data/elasticsearch/reference/5.3/migration-guides/migration-guide-3.2-4.0.html})"
"Spring Data Elasticsearch 4.0.x에서 ElasticsearchTemplate 클래스는 사용되지 않나요?","네, Spring Data Elasticsearch 4.0.x에서는 ElasticsearchTemplate 클래스가 사용되지 않습니다. Elasticsearch 7 버전부터 TransportClient가 사용되지 않으며, Elasticsearch 버전 8에서는 제거될 예정입니다. Spring Data Elasticsearch는 4.0 버전에서 TransportClient를 사용하는 ElasticsearchTemplate 클래스를 사용 중지합니다. (출처: {https://docs.spring.io/spring-data/elasticsearch/reference/5.3/migration-guides/migration-guide-3.2-4.0.html})"
"Spring Data Elasticsearch 4.1.x에서 id 속성을 어떻게 정의할 수 있나요?","Spring Data Elasticsearch 4.1.x에서는 @Id 어노테이션을 사용하여 엔티티의 속성을 id 속성으로 정의할 수 있습니다. id 또는 document라는 이름으로 id 속성을 정의하는 것은 더 이상 지원되지 않습니다."
"Spring Data Elasticsearch 4.1.x에서 ReactiveElasticsearchClient.Indices의 updateMapping 메서드는 어떻게 변경되었나요?","Spring Data Elasticsearch 4.1.x에서는 ReactiveElasticsearchClient.Indices의 updateMapping 메서드가 putMapping 메서드로 대체되었습니다. 이 변경은 Elasticsearch API와의 일관성을 유지하기 위해 이루어졌습니다."
"Spring Data Elasticsearch 4.1.x에서 IndexOperations의 removeAlias 메서드는 어떻게 변경되었나요?","Spring Data Elasticsearch 4.1.x에서는 removeAlias 메서드가 getAliases 메서드로 대체되었습니다. 이 변경은 더 많은 기능과 깔끔한 API를 제공하기 위해 이루어졌습니다."
"4.1.x에서 4.2.x로 업그레이드할 때, ElasticsearchOperations의 refresh 정책 변경은 어떻게 이루어졌나요?","4.1에서는 custom configuration class에서 AbstractReactiveElasticsearchConfiguration.refreshPolicy() 메서드를 오버라이딩하여 ReactiveElasticsearchTemplate의 refresh 정책을 구성할 수 있었습니다. 4.2에서는 이 메서드의 반환 값이 org.elasticsearch.action.support.WriteRequest.RefreshPolicy 클래스의 인스턴스에서 org.springframework.data.elasticsearch.core.RefreshPolicy로 변경되었습니다. 이 열거형은 이전과 동일한 값을 가지고 있으며 동일한 동작을 트리거하므로 import 문만 조정하면 됩니다. 또한, ElasticsearchOperations 및 ReactiveElasticsearchOperations는 이제 null이 아닌 경우 템플릿에 설정된 RefreshPolicy를 명시적으로 사용합니다."
"4.1.x에서 4.2.x로 업그레이드할 때, 삭제 쿼리를 사용하는 쿼리 메서드의 반환 유형은 어떻게 변경되었나요?","4.1.x에서는 reactive delete 쿼리 메서드가 삭제된 문서의 수를 나타내는 Mono<Long>을 반환하고, non-reactive 버전은 void를 반환했습니다. 4.2.x에서는 Mono<ByQueryResponse>를 반환하며, 삭제된 문서에 대한 자세한 정보와 발생할 수 있는 오류 정보를 포함합니다."
"4.1.x에서 4.2.x로 업그레이드할 때, 멀티겟 메서드의 구현은 어떻게 변경되었나요?","4.1.x에서는 멀티겟 메서드의 구현이 non-reactive 구현의 경우 List<T>로, reactive 구현의 경우 Flux<T>로 찾은 엔티티만 반환했습니다. 4.2.x에서는 멀티겟 메서드가 요청된 각 ID에 대해 MultiGetItem을 반환하며, 실패 정보(존재하지 않는 인덱스 등)와 항목이 존재하는지 여부에 대한 정보를 포함합니다."
"4.2.x에서 4.3.x로 업그레이드할 때 제거된 기능을 어떻게 대체할 수 있나요?","4.2.x에서 4.3.x로 업그레이드할 때 제거된 기능은 새로운 도입된 기능으로 대체될 수 있습니다. 예를 들어, RestHighLevelClient는 더 이상 Apache 2 라이선스가 아닌 Elasticsearch 코어 라이브러리의 코드를 사용하기 때문에 새로운 Client로 대체될 예정입니다. Spring Data Elasticsearch는 이러한 변경 사항을 준비하고 있으며, ElasticsearchOperations 또는 ReactiveElasticsearchOperations와 같은 인터페이스를 사용하여 프로그래밍하면 내부 구현이 변경되어야 합니다. ElasticsearchRestTemplate과 같은 구현 클래스를 직접 사용하는 경우 이러한 변경 사항에 적응해야 합니다."
"ElasticsearchOperations에서 제안 메서드에 어떤 변경 사항이 있었나요?","ElasticsearchOperations에서 org.elasticsearch.search.suggest.SuggestBuilder를 인수로 사용하고 org.elasticsearch.action.search.SearchResponse를 반환하는 제안 메서드는 사용되지 않습니다. 대신 Query query, Class<T> clazz를 사용하여 SearchHits<T> search(Query query, Class<T> clazz)를 사용하고, SuggestBuilder를 포함할 수 있는 NativeSearchQuery를 전달하고 반환된 SearchHit<T>에서 제안 결과를 읽어야 합니다. ReactiveSearchOperations에서는 새로운 제안 메서드가 이제 Mono<org.springframework.data.elasticsearch.core.suggest.response.Suggest>를 반환합니다. 이전 메서드는 모두 사용되지 않습니다."
"Elasticsearch의 org.elasticsearch 클래스는 Spring Data Elasticsearch의 API에서 어떻게 처리되나요?","Spring Data Elasticsearch는 API 클래스와 메서드에서 org.elasticsearch 패키지의 클래스 사용을 제거하거나 대체하고, Elasticsearch에 대한 액세스가 구현되는 구현에서만 사용합니다. 사용자에게는 동일한 값을 가진 org.springframework.data.elasticsearch에 속하는 열거형으로 대체된 사용된 일부 열거형 클래스와, 쉽게 대체할 수 없는 클래스를 사용하는 위치가 사용되지 않는 것으로 표시되며, 대체 방법을 연구 중입니다."
"Spring Data Elasticsearch 4.4에서 ElasticsearchTemplate 클래스가 제거된 이유는 무엇인가요?","Elasticsearch 7.0부터 TransportClient가 더 이상 사용되지 않기 때문에 ElasticsearchTemplate 클래스가 제거되었습니다. Elasticsearch에 연결하려면 imperative ElasticsearchRestTemplate 또는 reactive ReactiveElasticsearchTemplate을 사용해야 합니다."
"Spring Data Elasticsearch 4.4에서 ReactiveElasticsearchTemplate의 기본 refresh policy는 어떻게 변경되었나요?","ReactiveElasticsearchTemplate의 기본 refresh policy는 이제 NONE으로 설정되어 있으며, 이는 Elasticsearch의 기본 동작과 동일합니다. 이전에는 IMMEDIATE로 설정되어 있었습니다."
"Spring Data Elasticsearch 4.4에서 새로운 Elasticsearch 클라이언트를 사용하려면 어떻게 해야 하나요?","ElasticsearchConfiguration 또는 ReactiveElasticsearchConfiguration을 상속하여 구성 빈을 생성하고, pom.xml에서 새로운 클라이언트의 종속성을 추가하고, 기존 클라이언트를 구성하지 않도록 설정해야 합니다. 또한, 구성 빈을 Spring 애플리케이션 컨텍스트에서 제거해야 합니다."
"스프링 데이터 엘라스틱서치 4.4.x에서 5.0.x로 업그레이드할 때, 커스텀 trace 레벨 로깅을 어떻게 대체할 수 있나요?","스프링 데이터 엘라스틱서치 4.4.x에서 5.0.x로 업그레이드할 때, 커스텀 trace 레벨 로깅은 더 이상 사용되지 않습니다. 대신, Elasticsearch RestClient를 사용하여 로깅 레벨을 'trace'로 설정하여 대체할 수 있습니다."
"스프링 데이터 엘라스틱서치 4.4.x에서 5.0.x로 업그레이드할 때, org.springframework.data.elasticsearch.client.erhlc 패키지에 어떤 변경 사항이 있나요?","스프링 데이터 엘라스틱서치 4.4.x에서 5.0.x로 업그레이드할 때, org.springframework.data.elasticsearch.client.erhlc 패키지에 있는 모든 클래스는 사용되지 않게 되었습니다. 대신, Elasticsearch의 새로운 Java 클라이언트를 기반으로 한 기본 클라이언트 구현을 사용해야 합니다."
"스프링 데이터 엘라스틱서치 4.4.x에서 5.0.x로 업그레이드할 때, 어떤 breaking changes가 발생했나요?","스프링 데이터 엘라스틱서치 4.4.x에서 5.0.x로 업그레이드할 때, operations 인터페이스의 suggest 호출 제거, NativeSearchQuery 클래스의 NativeQuery 클래스로 변경, ElasticsearchRestHighLevelClient의 org.springframework.data.elasticsearch.client.erhlc 패키지로 이동 등 여러 breaking changes가 발생했습니다."
"Spring Data Elasticsearch 5.1에서 org.springframework.data.elasticsearch.annotations.Similarity가 어떻게 변경되었나요?","Spring Data Elasticsearch 5.1에서 org.springframework.data.elasticsearch.annotations.Similarity는 enum 클래스에서 단순한 String으로 변경되었습니다. 이전 enum 값은 여전히 String 상수로 존재하므로 기존 코드는 수정하지 않아도 됩니다. 그러나 이 enum이 @Field 어노테이션의 속성 이외의 다른 곳에서 사용되었다면 수정이 필요합니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/migration-guides/migration-guide-5.0-5.1.html)"
"Spring Data Elasticsearch 5.1에서 IndexOperations 및 ReactiverIndexOperations의 deprecation에 대한 대안은 무엇인가요?","Spring Data Elasticsearch 5.1에서 IndexOperations 및 ReactiverIndexOperations의 deprecation으로 인해, Elasticsearch 버전 7.8에서 deprecated된 old Elasticsearch API를 사용하는 함수들이 더 이상 사용되지 않습니다. 대신, composable index template API를 기반으로 한 새로운 함수들을 사용해야 합니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/migration-guides/migration-guide-5.0-5.1.html)"
"Spring Data Elasticsearch 5.1에서 AliasData 클래스의 filter 속성에 어떤 변경이 있었나요?","Spring Data Elasticsearch 5.1에서 AliasData 클래스의 filter 속성은 Document 타입에서 org.springframework.data.elasticsearch.core.query.Query 타입으로 변경되었습니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/migration-guides/migration-guide-5.0-5.1.html)"
"Spring Data Elasticsearch 5.1.x에서 5.2.x로 업그레이드할 때 BulkFailureException 클래스에서 어떤 변경 사항이 발생했나요?","Spring Data Elasticsearch 5.1.x에서 5.2.x로 업그레이드할 때 BulkFailureException 클래스의 getFailedDocuments() 메서드의 반환 타입이 Map<String, String>에서 Map<String, FailureDetails>로 변경되어 실패 이유에 대한 추가 세부 정보를 얻을 수 있게 되었습니다. FailureDetails 클래스는 (Integer status, String errorMessage)로 정의됩니다."
"Spring Data Elasticsearch 5.1.x에서 5.2.x로 업그레이드할 때 어떤 기능이 제거되었나요?","Spring Data Elasticsearch 5.1.x에서 5.2.x로 업그레이드할 때 org.springframework.data.elasticsearch.client.ClientLogger 클래스가 제거되었습니다. 이 로거는 org.springframework.data.elasticsearch.client.WIRE 설정으로 구성되었지만 모든 클라이언트에서 작동하지 않았습니다. 5.0 버전부터는 Elasticsearch Java 클라이언트에서 사용 가능한 trace 로거를 사용하십시오. Client Logging(../elasticsearch/clients.html#elasticsearch.clients.logging)을 참조하십시오."
"Spring Data Elasticsearch 5.1.x에서 5.2.x로 업그레이드할 때 어떤 기능이 사용되지 않게 되었나요?","Spring Data Elasticsearch 5.1.x에서 5.2.x로 업그레이드할 때 org.springframework.data.elasticsearch.core.ElasticsearchOperations의 stringIdRepresentation(Object) 메서드가 제거되었습니다. 대신 동일한 인터페이스에 정의된 convertId(Object) 메서드를 사용해야 합니다."
"스프링 데이터 엘라스틱서치에서 엘라스틱서치 클라이언트를 구성하는 방법은 무엇인가요?","스프링 데이터 엘라스틱서치는 다양한 엘라스틱서치 클라이언트에 대한 스프링 구성 지원을 제공합니다. 엘라스틱서치 클라이언트 구성에 대한 자세한 내용은 공식 문서(https://docs.spring.io/spring-data/elasticsearch/reference/5.3/elasticsearch.html#elasticsearch.clients)를 참조하세요."
"스프링 데이터 엘라스틱서치에서 객체 매핑 기능을 어떻게 활용할 수 있나요?","스프링 데이터 엘라스틱서치는 스프링의 변환 서비스와 통합된 풍부한 객체 매핑 기능을 제공합니다. 이 기능에 대한 자세한 내용은 공식 문서(https://docs.spring.io/spring-data/elasticsearch/reference/5.3/elasticsearch.html#elasticsearch.object-mapping)를 참조하세요."
"스프링 데이터 엘라스틱서치에서 리액티브 엘라스틱서치 작업을 어떻게 수행할 수 있나요?","스프링 데이터 엘라스틱서치는 리액티브 엘라스틱서치 작업을 위한 ReactiveElasticsearchTemplate 클래스를 제공합니다. 이 클래스에 대한 자세한 내용은 공식 문서(https://docs.spring.io/spring-data/elasticsearch/reference/5.3/elasticsearch.html#elasticsearch.reactive-template)를 참조하세요."
"Spring Data Elasticsearch에서 Elasticsearch 클라이언트를 어떻게 구성하나요?","Spring Data Elasticsearch에서 Elasticsearch 클라이언트를 구성하기 위해서는 Elasticsearch 클라이언트 라이브러리에서 제공하는 Elasticsearch 클라이언트 구현을 구성하고 사용해야 합니다. Elasticsearch Configuration 클래스를 사용하여 클라이언트 구성을 설정하고, jsonpMapper() 또는 transportOptions() 메서드를 오버라이딩하여 추가 구성을 수행할 수 있습니다. 이 후, ElasticsearchOperations, ElasticsearchClient, RestClient, JsonpMapper 등의 빈을 다른 Spring 컴포넌트에 주입할 수 있습니다."
"Elasticsearch 클라이언트에서 헤더를 커스터마이징하려면 어떻게 해야 하나요?","Elasticsearch 클라이언트에서 헤더를 커스터마이징하려면 ClientConfiguration 클래스를 사용하여 클라이언트 구성을 변경하면 됩니다. withDefaultHeaders() 메서드를 사용하여 기본 헤더를 설정하거나, withHeaders() 메서드를 사용하여 요청마다 호출되는 Supplier<HttpHeaders> 함수를 지정할 수 있습니다."
"Elasticsearch 클라이언트에서 SSL을 활성화하려면 어떻게 해야 하나요?","Elasticsearch 클라이언트에서 SSL을 활성화하려면 ClientConfiguration 클래스를 사용하여 클라이언트 구성을 변경할 수 있습니다. usingSsl() 메서드를 사용하여 SSL을 활성화하고, SSLContext 또는 인증서 지문을 매개변수로 받는 오버로드를 사용할 수도 있습니다."
"스프링 데이터 엘라스틱서치에서 객체 매핑이란 무엇인가요?","스프링 데이터 엘라스틱서치에서 객체 매핑은 자바 객체인 도메인 엔티티를 엘라스틱서치에 저장되는 JSON 표현으로 매핑하고, 다시 자바 객체로 역매핑하는 과정입니다. 이 매핑은 MappingElasticsearchConverter 클래스를 사용하여 내부적으로 이루어집니다."
"메타 모델 기반 접근 방식은 어떻게 작동하며, 특정 도메인 타입 매핑을 위해 Converter 인스턴스를 등록하는 방법은 무엇인가요?","메타 모델 기반 접근 방식은 도메인 타입 정보를 사용하여 엘라스틱서치로부터 읽기/쓰기를 수행합니다. 이 방식은 특정 도메인 타입 매핑을 위해 Converter 인스턴스를 등록할 수 있습니다. Converter 인스턴스를 등록하려면 ElasticsearchCustomConversions 빈을 오버라이딩하고 Converter 구현을 추가하면 됩니다."
"스프링 데이터 엘라스틱서치에서 @Transient, @ReadOnlyProperty, @WriteOnlyProperty 어노테이션은 어떻게 사용되나요?","@Transient 어노테이션을 사용하면 매핑에 포함되지 않고 엘라스틱서치에 값이 전송되지 않으며, @ReadOnlyProperty 어노테이션을 사용하면 값이 엘라스틱서치에 저장되지 않고, @WriteOnlyProperty 어노테이션을 사용하면 값이 엘라스틱서치에 저장되지만 문서 읽기 시 값이 설정되지 않습니다."
"Spring Data Elasticsearch에서 Elasticsearch 인덱스에 대해 호출할 수 있는 작업을 정의하는 데 사용되는 인터페이스는 무엇인가요?","Spring Data Elasticsearch는 Elasticsearch 인덱스에 대해 호출할 수 있는 작업을 정의하는 데 사용되는 여러 인터페이스를 사용합니다. 이에는 IndexOperations, DocumentOperations, SearchOperations 및 ElasticsearchOperations가 포함됩니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/elasticsearch/template.html)"
"Spring Data Elasticsearch에서 엔티티를 저장, 업데이트 및 검색하는 작업을 정의하는 인터페이스는 무엇인가요?","Spring Data Elasticsearch에서 엔티티를 저장, 업데이트 및 검색하는 작업을 정의하는 인터페이스는 DocumentOperations입니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/elasticsearch/template.html)"
"ElasticsearchOperations 인터페이스는 어떤 다른 인터페이스를 결합하나요?","ElasticsearchOperations 인터페이스는 Spring Data Elasticsearch에서 DocumentOperations 및 SearchOperations 인터페이스를 결합합니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/elasticsearch/template.html)"
"엔티티 콜백이란 무엇인가요?","엔티티 콜백은 특정 메서드가 호출되기 전과 후에 엔티티를 수정하기 위한 훅을 제공하는 Spring Data 인프라의 기능입니다. 이는 콜백 방식으로 엔티티를 확인하고 수정할 수 있는 편리한 방법을 제공합니다."
"Spring Data에서 엔티티 콜백의 장점은 무엇인가요?","엔티티 콜백은 동기 및 비동기 API와 통합 지점을 제공하여 처리 체인 내의 잘 정의된 체크포인트에서 순서대로 실행을 보장하고, 잠재적으로 수정된 엔티티 또는 반응형 래퍼 타입을 반환합니다. 이는 예기치 않은 결과를 초래할 수 있는 비동기 이벤트 처리보다 더 예측 가능한 결과를 제공합니다."
"엔티티 콜백은 어떻게 구현되나요?","엔티티 콜백은 특정 인터페이스를 구현하여 구현됩니다. 각 Spring Data 모듈은 엔티티 수명 주기를 다루는 미리 정의된 엔티티 콜백 인터페이스의 집합을 제공합니다. 콜백 구현은 애플리케이션의 요구 사항에 따라 수행되며, Ordered 인터페이스를 사용하여 여러 콜백이 동일한 도메인 유형에 존재하는 경우 순서를 지정할 수 있습니다."
"스프링 데이터 엘라스틱서치에서 Join 데이터 타입을 활용하려면 어떤 과정이 필요한가요?","해당 인덱스 매핑을 생성하고 관련 정보를 저장하기 위해 Join 데이터 타입(https://www.elastic.co/guide/en/elasticsearch/reference/current/parent-join.html)을 지원해야 합니다. 부모-자식 조인 관계에 사용될 엔티티는 JoinField 타입의 속성을 가져야 하며, 이 속성은 어노테이션으로 지정되어야 합니다. 이를 위해 @JoinTypeRelations 어노테이션을 사용하여 관계와 부모-자식 엔티티를 지정합니다. 또한, JoinField 속성은 관계의 이름(질문, 답변, 댓글 또는 투표)과 부모 ID를 결합하는 데 사용됩니다. 제네릭 타입은 @Id 어노테이션이 지정된 속성과 동일해야 합니다."
"Statement 엔티티의 @JoinTypeRelations 어노테이션에서 relations 어노테이션의 목적은 무엇인가요?","Statement 엔티티의 @JoinTypeRelations 어노테이션에서 relations 어노테이션은 부모-자식 조인 관계와 해당 관계에 참여하는 엔티티를 지정하는 데 사용됩니다. 이 어노테이션을 통해 질문과 답변, 답변과 투표 간의 관계를 설정할 수 있습니다."
"스프링 데이터 엘라스틱서치에서 JoinField 속성에 사용된 generic 타입은 어떤 역할을 하나요?","JoinField 속성에 사용된 generic 타입은 @Id 어노테이션이 지정된 속성과 동일해야 합니다. 이는 Spring Data Elasticsearch가 조인 관계를 구축하고 쿼리할 때 필요한 정보를 제공하는 데 사용됩니다. generic 타입은 부모 엔티티의 ID 타입과 일치해야 합니다."
"Spring Data Elasticsearch에서 라우팅이란 무엇이며, 왜 중요한가요?","Spring Data Elasticsearch에서 라우팅은 문서를 인덱싱할 때, 어떤 샤드에 인덱싱할지를 결정하는 값입니다. 라우팅은 여러 문서를 동일한 샤드에 인덱싱하도록 미리 정의할 수 있어, 조인 타입 및 관련 데이터 검색에 유용합니다. 라우팅은 인덱싱 및 검색 작업에 대한 사용자 정의 값을 정의하기 위해 @Routing 어노테이션을 사용하여 정의할 수 있습니다."
"Spring Data Elasticsearch에서 조인 타입에서 라우팅은 어떻게 처리되나요?","Spring Data Elasticsearch에서 조인 타입을 사용할 때, 엔티티의 JoinField 속성의 부모 속성이 라우팅 값으로 자동으로 사용됩니다. 이는 부모-자식 관계가 한 단계인 경우 올바릅니다. 그러나 만약 자식이 부모-자식-손자 관계와 같이 더 깊다면, 다음 섹션에서 설명한 기술을 사용하여 라우팅을 명시적으로 지정해야 합니다."
"Spring Data Elasticsearch에서 사용자 정의 라우팅 값을 정의하려면 어떻게 해야 하나요?","Spring Data Elasticsearch에서 사용자 정의 라우팅 값을 정의하려면, 먼저 엔티티에 @Routing 어노테이션을 적용해야 합니다. 어노테이션에서 라우팅 사양을 엔티티의 속성 이름으로 지정합니다. 라우팅 값은 속성의 값입니다. 또한, @Document 어노테이션에서 SpEL 표현을 사용하거나 RoutingResolver 인터페이스의 구현을 제공하여 라우팅 정의를 사용자 정의할 수 있습니다."
"Spring Data Elasticsearch에서 Elasticsearch 인덱스 설정은 어떻게 정의하나요?","Spring Data Elasticsearch에서 Elasticsearch 인덱스 설정은 `@Setting` 어노테이션을 사용하여 정의할 수 있습니다. `@Setting` 어노테이션을 사용하면 `settingPath`, `shards`, `replicas`, `refreshInterval`, `indexStoreType` 등의 인덱스 설정을 설정할 수 있습니다."
"Spring Data Elasticsearch에서 엘라스틱서치 연산 중 리포지토리 인터페이스를 통해 직접 접근할 수 없는 연산은 어떻게 지원되나요?","Spring Data Elasticsearch에서 리포지토리 인터페이스를 통해 직접 접근할 수 없는 연산은 커스텀 리포지토리 구현으로 추가할 수 있습니다. 커스텀 리포지토리 구현에서 해당 연산을 구현하여 사용할 수 있습니다."
"Spring Data Elasticsearch에서 엘라스틱서치 인덱스 맵핑은 어떻게 생성되나요?","Spring Data Elasticsearch에서 엘라스틱서치 인덱스 맵핑은 `@Document` 어노테이션과 `@Field` 어노테이션을 사용하여 생성됩니다. `@Document` 어노테이션은 엘라스틱서치 인덱스 이름을 정의하고, `@Field` 어노테이션은 엘라스틱서치 필드를 정의합니다. 또한 `@Mapping` 어노테이션을 사용하여 사용자 정의 맵핑을 추가할 수도 있습니다."
"@ScriptedField 어노테이션을 사용하는 목적은 무엇인가요?","인덱스 매핑에 해당하는 항목을 작성하지 않고, 검색 응답에서 계산된 필드를 넣을 대상으로 표시합니다."
"Spring Data Elasticsearch에서 스크립트 필드와 런타임 필드의 차이점은 무엇인가요?","스크립트 필드는 결과 문서에서 계산되어 반환 문서에 추가되는 필드를 반환하고, 런타임 필드는 저장된 문서에서 계산되어 쿼리에서 사용하거나 검색 결과에서 반환할 수 있습니다."
"Person 엔티티의 age 속성은 어떻게 계산되나요?","birthDate와 현재 날짜 간의 일 수를 기반으로 계산됩니다."
"스프링 데이터 저장소에서 기본 개념은 무엇인가요?","스프링 데이터 저장소 추상화는 다양한 지속성 저장소에 대한 데이터 액세스 레이어를 구현하는 데 필요한 보일러플레이트 코드의 양을 크게 줄이는 것이 목표입니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories.html)"
"스프링 데이터 엘라스틱서치에서 리액티브 엘라스틱서치 저장소란 무엇인가요?","리액티브 엘라스틱서치 저장소는 스프링 데이터 엘라스틱서치에서 제공하는 리액티브 저장소입니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories.html)"
"스프링 데이터 저장소에서 프로젝션이란 무엇인가요?","프로젝션은 쿼리 결과에서 반환되는 속성을 제어하는 방법입니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories.html)"
"Spring Data에서 리포지토리 인터페이스를 정의하려면 어떻게 해야 하나요?","도메인 클래스별 리포지토리 인터페이스를 정의하려면 먼저 Repository를 확장하고 도메인 클래스와 ID 타입에 대해 타입을 지정해야 합니다. 해당 도메인 유형에 대한 CRUD 메서드를 노출하려면 Repository 대신 CrudRepository 또는 해당 변형 중 하나를 확장할 수 있습니다."
"Spring Data에서 리포지토리 정의에 대해 다양한 접근 방식은 무엇인가요?","Spring Data에서 리포지토리 인터페이스를 정의하는 몇 가지 변형이 있습니다. 일반적인 접근 방식은 CrudRepository를 확장하여 CRUD 기능에 대한 메서드를 제공하는 것입니다. CRUD는 Create, Read, Update, Delete의 약자입니다. 버전 3.0에서는 CrudRepository와 유사하지만 여러 엔티티를 반환하는 메서드의 경우 Iterable 대신 List를 반환하는 ListCrudRepository도 도입되었습니다. 반응형 저장소를 사용하는 경우 사용하는 반응형 프레임워크에 따라 ReactiveCrudRepository 또는 RxJava3CrudRepository를 선택할 수 있습니다. Kotlin을 사용하는 경우 Kotlin의 코루틴을 활용하는 CoroutineCrudRepository를 선택할 수 있습니다."
"Spring Data에서 리포지토리 정의에 대한 엄격한 구성은 어떻게 이루어지며, 어떤 경우에 필요한가요?","Spring Data는 클래스 경로에 여러 리포지토리 팩토리가 있는 경우 엄격한 리포지토리 구성 모드로 전환됩니다. 엄격한 구성은 리포지토리 또는 도메인 클래스에 대한 세부 정보를 사용하여 리포지토리 정의에 대한 Spring Data 모듈 바인딩을 결정합니다. 리포지토리 정의가 모듈별 리포지토리 인터페이스(JPA의 경우 JpaRepository)를 확장하는 경우 해당 Spring Data 모듈의 유효한 후보입니다. 도메인 클래스가 모듈별 타입 어노테이션(JPA의 경우 @Entity, Spring Data MongoDB 및 Spring Data Elasticsearch의 경우 @Document)으로 주석이 달린 경우 해당 Spring Data 모듈의 유효한 후보입니다."
"스프링 데이터 엘라스틱서치에서 인덱스 생성과 매핑에 대해 설명해주세요.","스프링 데이터 엘라스틱서치에서 @Document 어노테이션의 createIndex 인자를 통해 인덱스를 자동으로 생성하고, 해당 인덱스에 해당하는 매핑을 만들 수 있습니다. @Document 어노테이션의 createIndex 인자가 true로 설정되어 있으면, 해당 인덱스가 존재하지 않을 경우 인덱스가 생성되고, 엔티티의 어노테이션에서 파생된 매핑이 새로운 인덱스에 작성됩니다. 생성될 인덱스의 세부 정보는 @Setting 어노테이션을 사용하여 설정할 수 있으며, 자세한 내용은 Index settings(../misc.html#elasticsearc.misc.index.settings)를 참조하세요. (출처: <https://docs.spring.io/spring-data/elasticsearch/reference/5.3/elasticsearch/repositories/elasticsearch-repositories.html>)"
"스프링 데이터 엘라스틱서치에서 리포지토리 메서드에 대한 @Highlight 어노테이션의 사용법에 대해 설명해주세요.","스프링 데이터 엘라스틱서치에서 @Highlight 어노테이션은 리포지토리 메서드에 대한 반환 엔티티의 어떤 필드에 강조 표시가 포함되어야 하는지를 정의합니다. 검색 결과에서 SearchHit 클래스에서 강조 표시 데이터를 검색할 수 있습니다. @Highlight 어노테이션과 @HighlightField 어노테이션은 @HighlightParameters 어노테이션을 사용하여 추가로 사용자 정의할 수 있습니다. 가능한 구성 옵션에 대한 자세한 내용은 Javadoc을 참조하세요. (출처: <https://docs.spring.io/spring-data/elasticsearch/reference/5.3/elasticsearch/repositories/elasticsearch-repositories.html>)"
"스프링 데이터 엘라스틱서치에서 리포지토리 빈을 설정하기 위해 네임스페이스를 사용하는 방법에 대해 설명해주세요.","스프링 데이터 엘라스틱서치 모듈은 사용자 정의 네임스페이스를 포함하여 리포지토리 빈 및 ElasticsearchServer 인스턴스화를 위한 요소를 정의할 수 있습니다. repositories 요소를 사용하여 Creating Repository Instances(../../repositories/create-instances.html)에 설명된 대로 Spring Data 리포지토리를 찾을 수 있습니다. Transport Client 또는 Rest Client 요소를 사용하여 컨텍스트에 Elasticsearch Server 인스턴스를 등록할 수 있습니다. (출처: <https://docs.spring.io/spring-data/elasticsearch/reference/5.3/elasticsearch/repositories/elasticsearch-repositories.html>)"
"Spring Data Elasticsearch에서 reactive repository support를 위해 어떤 reactive composition library를 사용하나요?","Spring Data Elasticsearch reactive repository support는 Project Reactor(https://projectreactor.io/)를 선택합니다."
"Elasticsearch에서 ReactiveRepository, ReactiveCrudRepository, ReactiveSortingRepository의 차이점은 무엇인가요?","ReactiveRepository는 가장 기본적인 인터페이스로, ReactiveCrudRepository는 CRUD 메서드를 포함하고 있으며, ReactiveSortingRepository는 정렬된 데이터에 접근하기 위한 메서드를 추가로 제공합니다."
"Elasticsearch에서 reactive repository를 Java configuration을 통해 활성화하는 방법은 무엇인가요?","@EnableReactiveElasticsearchRepositories 어노테이션을 사용하고, base package를 지정하지 않으면 어노테이션이 지정된 configuration 클래스의 패키지를 스캔합니다."
"Spring에서 정의된 리포지토리 인터페이스에 대한 인스턴스와 빈 정의를 생성하는 방법은 무엇인가요?","Java Configuration에서 store-specific @EnableElasticsearchRepositories 어노테이션을 사용하여 리포지토리 활성화에 대한 구성을 정의하거나, XML Configuration에서 각 Spring Data 모듈에 포함된 repositories 요소를 사용하여 Spring이 스캔할 기본 패키지를 정의할 수 있습니다. 자세한 내용은 다음 링크를 참조하십시오: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/create-instances.html"
"Spring에서 특정 리포지토리 인터페이스에 대한 빈 인스턴스 생성을 제어하는 방법은 무엇인가요?","필터 요소를 사용하여 리포지토리 선언 내부에 설정을 지정할 수 있습니다. 이 요소는 Spring의 컴포넌트 필터와 정확히 동일한 의미를 가집니다. 예를 들어, 특정 인터페이스를 리포지토리 빈으로 인스턴스화하지 않으려면 Java 또는 XML 구성을 사용하여 포함 및 제외 필터를 지정할 수 있습니다. 자세한 내용은 다음 링크를 참조하십시오: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/create-instances.html"
"Spring 컨테이너 외부에서 리포지토리 인프라를 사용할 수 있나요? 어떻게 설정하나요?","네, 리포지토리 인프라는 Spring 컨테이너 외부에서 사용할 수 있습니다. 예를 들어, CDI 환경에서는 여전히 일부 Spring 라이브러리가 클래스 경로에 필요하지만, 일반적으로 프로그래밍 방식으로 리포지토리를 설정할 수 있습니다. 리포지토리 지원을 제공하는 Spring Data 모듈은 지속성 기술별 RepositoryFactory를 함께 제공하므로 이를 사용하여 UserRepository 인스턴스를 다음과 같이 얻을 수 있습니다: RepositoryFactorySupport factory = … // Instantiate factory here UserRepository repository = factory.getRepository(UserRepository.class); 자세한 내용은 다음 링크를 참조하십시오: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/create-instances.html"
"쿼리 메소드 정의란 무엇인가요?","쿼리 메소드 정의는 Spring Data JPA에서 쿼리를 정의하는 방법입니다. 쿼리 메소드는 저장소 인터페이스에서 정의되며, 메소드 이름과 매개변수를 기반으로 SQL 쿼리가 생성됩니다. 이를 통해 개발자는 SQL을 직접 작성하지 않고도 데이터베이스에 대한 쿼리를 작성할 수 있습니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details"
"Spring Data에서 쿼리 메소드 리턴 타입은 어떤 종류가 있나요?","Spring Data에서는 다양한 쿼리 메소드 리턴 타입을 지원합니다. Standard Java Iterable, List, Set, Streamable, Vavr 컬렉션 등이 있습니다. 또한, 사용자 정의 Streamable 래퍼 타입을 리턴할 수도 있습니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/query-methods-details.html#repositories.query-methods.return-types"
"Spring Data에서 쿼리 메소드 이름에서 쿼리를 생성하는 방법은 무엇인가요?","Spring Data에서는 쿼리 메소드 이름에서 쿼리를 생성하는 방법이 두 가지 있습니다. 메소드 이름에서 직접 쿼리를 파싱하거나, 수동으로 쿼리를 정의할 수 있습니다. 자세한 내용은 다음 링크를 참조하세요: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/query-methods-details.html#repositories.query-methods.query-creation"
"스프링 데이터에서 프로젝션이란 무엇인가요?","스프링 데이터에서 프로젝션은 관리되는 집합체의 일부분만 선택적으로 검색하기 위해 전용 반환 유형을 모델링하는 것입니다. 프로젝션은 엔티티의 유형 계층 구조 외부에 있는 유형이며, 인터페이스 기반 프로젝션과 클래스 기반 프로젝션(DTO)이 있습니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/projections.html)"
"인터페이스 기반 프로젝션을 어떻게 사용하나요?","인터페이스 기반 프로젝션을 사용하려면, 읽을 속성에 대한 접근자 메서드를 노출하는 인터페이스를 선언해야 합니다. 그런 다음, 이 인터페이스를 리포지토리 메서드의 반환 유형으로 사용합니다. 쿼리 실행 엔진은 반환된 각 요소에 대해 런타임에 해당 인터페이스의 프록시 인스턴스를 생성하고, 노출된 메서드에 대한 호출을 대상 객체로 전달합니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/projections.html)"
"클로즈드 프로젝션과 오픈 프로젝션의 차이점은 무엇인가요?","클로즈드 프로젝션은 대상 집합체의 속성과 정확히 일치하는 액세스자 메서드를 가진 프로젝션 인터페이스입니다. 오픈 프로젝션은 @Value 어노테이션을 사용하여 새로운 값을 계산하는 데 액세스자 메서드를 사용할 수 있는 프로젝션 인터페이스입니다. 스프링 데이터는 클로즈드 프로젝션의 쿼리 실행을 최적화할 수 있지만, 오픈 프로젝션의 경우 쿼리 실행 최적화를 적용할 수 없습니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/projections.html)"
"Spring Data에서 @DomainEvents 어노테이션은 어떤 용도로 사용되나요?","Spring Data에서 @DomainEvents 어노테이션은 엔티티가 도메인 이벤트를 게시할 수 있도록 하는 데 사용됩니다. 이 어노테이션은 저장소에서 관리하는 엔티티의 메서드에 적용되어 도메인 이벤트를 가능한 쉽게 게시할 수 있도록 합니다."
"Spring Data에서 @AfterDomainEventPublication 어노테이션은 어떤 용도로 사용되나요?","@AfterDomainEventPublication 어노테이션은 이벤트가 모두 게시된 후에 호출되는 메서드에만 사용됩니다. 이 어노테이션은 게시될 이벤트 목록을 정리하는 데 사용될 수 있습니다(다른 용도도 있습니다)."
"Spring Data 저장소 메서드 중 어떤 것들이 도메인 이벤트를 게시하나요?","Spring Data에서 save(…), saveAll(…), delete(…), deleteAll(…), deleteAllInBatch(…), deleteInBatch(…) 저장소 메서드는 도메인 이벤트를 게시합니다. 그러나 deleteById(…)는 구현에 따라 쿼리를 발행하여 인스턴스를 삭제하는 메서드를 선택할 수 있으므로 도메인 이벤트를 게시하지 않습니다."
"스프링 데이터 2.0부터 리포지토리 CRUD 메서드는 개별 애그리게이트 인스턴스를 반환할 때 어떤 방식을 사용하여 값의 부재를 나타내나요?","스프링 데이터 2.0부터 리포지토리 CRUD 메서드는 개별 애그리게이트 인스턴스를 반환할 때 Java 8의 Optional을 사용하여 값의 부재를 나타냅니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/null-handling.html)"
"스프링 데이터에서 리포지토리 쿼리 메서드에서 값의 부재를 나타내기 위해 어떤 래퍼 타입을 사용할 수 있나요?","스프링 데이터에서 리포지토리 쿼리 메서드에서 값의 부재를 나타내기 위해 com.google.common.base.Optional, scala.Option, io.vavr.control.Option과 같은 래퍼 타입을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/null-handling.html)"
"스프링 데이터에서 리포지토리 메서드의 널 가능성 제약 조건을 표현하기 위해 어떤 어노테이션을 사용할 수 있나요?","스프링 데이터에서 리포지토리 메서드의 널 가능성 제약 조건을 표현하기 위해 @NonNullApi, @NonNull, @Nullable와 같은 스프링 프레임워크의 널 가능성 어노테이션을 사용할 수 있습니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/null-handling.html)"
"Spring Data Elasticsearch 저장소를 설정하는 데 사용되는 CDI 기능의 예시는 무엇인가요?","CDI 기능을 사용하여 Spring Data Elasticsearch 저장소를 설정하는 예시는 ElasticsearchTemplateProducer 클래스에서 확인할 수 있습니다. 이 클래스는 ElasticsearchOperations를 생성하고 @Produces 및 @ApplicationScoped 어노테이션을 사용하여 컴포넌트를 생성합니다. 그런 다음 ProductService 클래스에서 @Inject 어노테이션을 사용하여 CDI 프레임워크가 저장소를 클래스에 주입합니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/elasticsearch/repositories/cdi-integration.html)"
"CDI 통합에서 ElasticsearchOperations를 생성하는 방법은 무엇인가요?","CDI 통합에서 ElasticsearchOperations를 생성하려면 ElasticsearchTemplateProducer 클래스에서 ElasticsearchOperations를 생성하는 메서드를 만들고 @Produces 및 @ApplicationScoped 어노테이션을 사용하여 컴포넌트를 생성합니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/elasticsearch/repositories/cdi-integration.html)"
"Spring Data Elasticsearch에서 CDI 통합을 사용할 때 저장소를 클래스에 주입하는 방법은 무엇인가요?","Spring Data Elasticsearch에서 CDI 통합을 사용할 때 저장소를 클래스에 주입하려면 @Inject 어노테이션을 사용하여 CDI 프레임워크가 저장소를 클래스에 주입하도록 합니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/elasticsearch/repositories/cdi-integration.html)"
"스프링 데이터 저장소 쿼리 유도 메커니즘에서 일반적으로 지원되는 쿼리 주제 키워드는 무엇인가요?","find…By, read…By, get…By, query…By, search…By, stream…By 등이 일반적으로 지원되는 쿼리 주제 키워드입니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/query-keywords-reference.html)"
"스프링 데이터 저장소 쿼리 유도 메커니즘에서 일반적으로 지원되는 쿼리 필터 키워드는 무엇인가요?","AND, OR, AFTER, BEFORE, CONTAINING, BETWEEN, ENDING_WITH, EXISTS, FALSE, GREATER_THAN, GREATER_THAN_EQUALS, IN, IS, IS_EMPTY, IS_NOT_EMPTY, IS_NOT_NULL, IS_NULL, LESS_THAN, LESS_THAN_EQUAL, LIKE, NOT, NOT_IN, NOT_LIKE, REGEX, STARTING_WITH, TRUE, WITHIN 등이 일반적으로 지원되는 쿼리 필터 키워드입니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/query-keywords-reference.html)"
"스프링 데이터 저장소 쿼리 유도 메커니즘에서 일반적으로 지원되는 쿼리 수정자 키워드는 무엇인가요?","IgnoreCase, AllIgnoreCase, OrderBy 등이 일반적으로 지원되는 쿼리 수정자 키워드입니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리에서 지원되는 쿼리 반환 유형은 무엇인가요?","스프링 데이터 리포지토리에서 지원되는 쿼리 반환 유형은 void, Java의 기본 타입, Java의 래퍼 타입, T, Iterator<T>, Collection<T>, List<T>, Optional<T>, Option<T>, Stream<T>, Streamable<T>, Vavr의 컬렉션 타입, Future<T>, CompletableFuture<T>, Slice<T>, Page<T>, Window<T>, GeoResult<T>, GeoResults<T>, GeoPage<T>, Mono<T>, Flux<T>, Single<T>, Maybe<T>, Flowable<T> 등이 있습니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/query-return-types-reference.html)"
"스프링 데이터 리포지토리에서 T의 의미는 무엇인가요?","스프링 데이터 리포지토리에서 T는 유일한 엔티티를 의미합니다. 쿼리 메서드가 최대 하나의 결과를 반환할 것으로 예상하며, 결과가 없으면 null을 반환합니다. 여러 개의 결과가 있으면 IncorrectResultSizeDataAccessException이 발생합니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/query-return-types-reference.html)"
"스프링 데이터 리포지토리에서 Future<T>는 어떤 반환 유형인가요?","스프링 데이터 리포지토리에서 Future<T>는 Future를 반환하는 타입입니다. 메서드가 @Async 어노테이션을 달아야 하며, Spring의 비동기 메서드 실행 기능이 활성화되어 있어야 합니다. (출처: https://docs.spring.io/spring-data/elasticsearch/reference/5.3/repositories/query-return-types-reference.html)"
"이 문서는 어떤 사용자들을 대상으로 하고 있나요?","이 문서는 Spring Framework, Spring Data, Spring Data Neo4j 모듈, 그리고 Neo4j에 대해 처음 접하는 사람들, Spring Data에 대해 처음 접하는 경험이 있는 Neo4j 개발자들, 그리고 이 특정 모듈과 Neo4j에 대해 처음 접하는 경험이 있는 Spring Data 개발자들을 대상으로 합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/introduction-and-preface/index.html)"
"Spring Data Neo4j와 Spring Data JDBC, Mongo 등의 다른 Spring Data 모듈들의 프로그래밍 패러다임의 차이점은 무엇인가요?","Spring Data Neo4j의 프로그래밍 패러다임은 다른 Spring Data 모듈들과 매우 유사하지만, 쿼리 언어(Cypher), 트랜잭션 및 클러스터링 동작은 다르며 추상화될 수 없습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/introduction-and-preface/index.html)"
"Spring Data Neo4j에서 도메인 모델을 Neo4j 인스턴스에 매핑하는 방법은 무엇인가요?","Spring Data Neo4j에서 도메인 모델을 Neo4j 인스턴스에 매핑하려면, mapping(../object-mapping/metadata-based-mapping.html#mapping.annotations)을 참조하십시오. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/introduction-and-preface/index.html)"
"스프링 데이터에서 사용되는 스프링 프레임워크의 핵심 기능은 무엇인가요?","스프링 데이터에서는 Spring Framework의 IoC 컨테이너, 타입 변환 시스템, 표현 언어, JMX 통합 및 휴대용 DAO 예외 계층 구조 등의 핵심 기능을 사용합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/introduction-and-preface/preface-sd.html)"
"스프링 데이터에 대해 자세히 알아보려면 어떤 자료를 참고할 수 있나요?","스프링 프레임워크에 대한 상세한 설명은 포괄적인 문서를 참조할 수 있습니다. 또한 Spring Framework 홈페이지(https://spring.io/docs)에서 더 많은 정보, 기사, 블로그 항목 및 책을 확인할 수 있습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/introduction-and-preface/preface-sd.html)"
"스프링 데이터 저장소에서 작업하는 방법에 대한 일반적인 장은 어떤 문서에 포함되어 있나요?","일반적인 스프링 데이터 저장소 작업에 대한 장은 이 문서에 포함되어 있습니다. 특히, Spring Data 저장소 작업(../repositories.html#repositories)에 대한 일반적인 장은 해당 문서에 포함되어 있습니다. 이전에 Spring Data 모듈을 사용해 본 적이 없다면 해당 장을 참조하는 것이 좋습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/introduction-and-preface/preface-sd.html)"
"Spring Data Neo4j의 기본 구성 요소는 무엇인가요?","Spring Data Neo4j (SDN)은 조합 가능한 기본 구성 요소로 구성되어 있습니다. 이 기본 구성 요소는 Neo4j Java Driver 위에 구축되며, Spring Boot의 자동 구성을 통해 Java 드라이버의 인스턴스가 제공됩니다. SDN의 모든 기본 구성 요소는 imperative 및 reactive 방식으로 제공됩니다. SDN의 기본 구성 요소에 대한 자세한 정보는 https://docs.spring.io/spring-data/neo4j/reference/7.3/introduction-and-preface/building-blocks.html에서 확인할 수 있습니다."
"Spring Data Neo4j와 함께 Neo4j Java Driver를 사용하는 방법은 무엇인가요?","Spring Data Neo4j (SDN)은 Neo4j Java Driver 위에 구축되며, Spring Boot의 자동 구성을 통해 Java 드라이버의 인스턴스가 제공됩니다. Neo4j Java Driver의 모든 구성 옵션은 spring.neo4j 네임스페이스에서 액세스할 수 있습니다. 드라이버 빈은 Neo4j와 상호 작용하기 위한 imperative, asynchronous 및 reactive 메서드를 제공하며, 자동 커밋 트랜잭션, 트랜잭션 함수 및 미관리 트랜잭션과 같은 드라이버가 제공하는 모든 트랜잭션 메서드를 사용할 수 있습니다. 그러나 이러한 트랜잭션은 진행 중인 Spring 트랜잭션에 밀접하게 결합되지 않습니다. Neo4j Java Driver를 Spring Data Neo4j와 함께 사용하는 방법에 대한 자세한 정보는 https://docs.spring.io/spring-data/neo4j/reference/7.3/introduction-and-preface/building-blocks.html에서 확인할 수 있습니다."
"Spring Data Neo4j에서 Neo4j Client는 어떤 역할을 하나요?","Neo4j Client는 Spring Data Neo4j (SDN)의 다음 상위 수준의 추상화입니다. 클라이언트는 SDN의 일부로 구성되며, 별도의 스타터인 spring-boot-starter-data-neo4j를 통해 구성됩니다. 클라이언트의 구성 네임스페이스는 spring.data.neo4j입니다. 클라이언트는 매핑에 대해 중립적이며, 결과의 객체를 필요에 맞게 매핑하는 것은 사용자의 책임입니다. Neo4j Client에 대한 자세한 정보는 https://docs.spring.io/spring-data/neo4j/reference/7.3/introduction-and-preface/building-blocks.html에서 확인할 수 있습니다."
"Spring Data Neo4j 7.2 버전의 새로운 기능과 개선 사항에 대해 알려주세요.","Spring Data Neo4j 7.2 버전에서는 어떤 새로운 기능과 개선 사항이 있나요? (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/introduction-and-preface/new-and-noteworthy.html>)"
"Spring Data Neo4j 7.1 버전의 새로운 기능과 개선 사항에 대해 알려주세요.","Spring Data Neo4j 7.1 버전에서는 어떤 새로운 기능과 개선 사항이 있나요? (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/introduction-and-preface/new-and-noteworthy.html>)"
"Spring Data Neo4j 7.0 버전의 새로운 기능과 개선 사항에 대해 알려주세요.","Spring Data Neo4j 7.0 버전에서는 어떤 새로운 기능과 개선 사항이 있나요? (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/introduction-and-preface/new-and-noteworthy.html>)"
"스프링 데이터 모듈의 호환 가능한 버전을 어떻게 찾을 수 있나요?","스프링 데이터 릴리스 트레인 BOM을 사용하여 호환 가능한 버전을 찾을 수 있습니다. Maven 프로젝트에서는 POM의 <dependencyManagement> 섹션에 이 의존성을 다음과 같이 선언합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/dependencies.html)"
"BOM을 사용하는 작동 예제를 어디에서 찾을 수 있나요?","BOM을 사용하는 작동 예제는 스프링 데이터 예제 저장소에서 찾을 수 있습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/dependencies.html)"
"스프링 부트와 함께 사용할 때 스프링 데이터 모듈의 버전을 업그레이드하려면 어떻게 해야 하나요?","spring-data-bom.version 속성을 사용하려는 트레인 버전과 이터레이션으로 설정하면 됩니다. 자세한 내용은 스프링 부트의 문서를 참조하십시오. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/dependencies.html)"
"Spring Boot 프로젝트 생성을 위해 Spring Initializr를 어떻게 사용하나요?","Spring Initializr는 Spring Boot 프로젝트를 생성하는 데 사용되며, 웹사이트(https://start.spring.io) 또는 대부분의 IDE에 통합되어 있습니다. 웹 애플리케이션 생성에 필요한 종속성을 모두 얻으려면 'Spring Web Starter'를 선택하십시오. Spring Initializr는 선택한 빌드 도구에 대한 모든 파일과 설정이 포함된 유효한 프로젝트 구조를 생성합니다."
"Spring Data Neo4j를 사용하여 프로젝트를 구성하는 방법은 무엇인가요?","Spring Data Neo4j를 사용하여 프로젝트를 구성하려면 build.gradle 또는 pom.xml에 'org.springframework.boot:spring-boot-starter-data-neo4j' 종속성을 추가하고, application.properties에서 Neo4j 자격 증명을 구성하고, Neo4j 드라이버의 프로그래밍 방식의 구성을 추가할 필요가 없습니다. SDN 저장소는 이 스타터에 의해 자동으로 활성화됩니다."
"Spring Data Neo4j에서 속성 매핑을 어떻게 수행하나요?","Spring Data Neo4j에서 속성 매핑을 수행하려면 @Property 어노테이션을 사용하여 필드와 그래프 속성에 대해 다른 이름을 사용할 수 있습니다. 예를 들어, 'tagline' 속성에 'description'이라는 이름을 사용하려면 @Property('tagline')를 사용합니다."
"Spring Data Neo4j에서 객체 매핑이란 무엇이며, 어떤 부분으로 나뉘어지나요?","Spring Data Neo4j에서 객체 매핑은 그래프와 도메인 간의 매핑 프로세스를 의미합니다. 이 프로세스는 실제 매핑과 노드, 관계 및 속성을 객체로 매핑하는 방법을 설명하는 데 사용할 수 있는 도구를 설명하는 첫 번째 부분, 엔티티에 대한 특정 식별자 스타일을 사용하는 옵션과 영향을 보여주는 두 번째 부분, 그리고 일반적인 매핑, 불변 도메인 객체를 선호해야 하는 이유 및 Java 또는 Kotlin으로 모델링하는 방법에 대한 유용한 팁을 제공하는 세 번째 부분으로 구성됩니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/object-mapping.html)"
"Spring Data Neo4j에서 객체 매핑에서 사용 가능한 도구는 무엇인가요?","Spring Data Neo4j에서 객체 매핑에서 사용 가능한 도구는 노드, 관계 및 속성을 객체로 매핑하는 방법을 설명하는 데 사용되는 도구입니다. 이 문서에서는 이러한 도구에 대한 자세한 정보를 제공하지 않습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/object-mapping.html)"
"Spring Data Neo4j에서 불변 도메인 객체를 모델링하는 방법은 무엇인가요?","Spring Data Neo4j에서 불변 도메인 객체를 모델링하는 방법은 Java 또는 Kotlin으로 가능합니다. 이 문서에서는 불변 도메인 객체를 모델링하는 방법에 대한 자세한 정보를 제공하지 않습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/object-mapping.html)"
"SDN에서 객체 매핑 기능을 최대한 활용하려면 어떻게 해야 하나요?","매핑된 객체에 @Node 어노테이션을 추가해야 합니다. 이 어노테이션은 매핑 프레임워크에 필요하지 않지만, 클래스패스 스캐너가 도메인 객체를 찾고 필요한 메타데이터를 추출하기 위해 미리 처리할 수 있게 해줍니다. 이 어노테이션을 사용하지 않으면, 도메인 객체를 처음 저장할 때 성능에 약간의 영향을 줄 수 있습니다."
"@Node 어노테이션의 역할은 무엇인가요?","@Node 어노테이션은 클래스가 데이터베이스에 매핑될 수 있는 후보임을 나타내기 위해 클래스 레벨에서 적용됩니다. 또한, 매핑 컨텍스트에 의해 클래스패스 스캔의 대상이 되도록 합니다. 이 어노테이션은 클래스를 매핑할 때 사용할 레이블을 식별하기 위해 필요합니다."
"@Id, @GeneratedValue, @Property 어노테이션의 목적은 무엇인가요?","@Id 어노테이션은 객체의 고유 식별자를 나타내는 필드를 표시하는 데 사용됩니다. @GeneratedValue 어노테이션은 @Id와 함께 필드 레벨에서 사용되어 고유 식별자가 어떻게 생성되어야 하는지 지정합니다. @Property 어노테이션은 필드 레벨에서 사용되어 속성에서 속성으로의 매핑을 수정합니다."
"스프링 데이터 Neo4j에서 도메인 클래스에 고유 식별자를 제공하는 가장 간단한 방법은 무엇인가요?","스프링 데이터 Neo4j에서 도메인 클래스에 고유 식별자를 제공하는 가장 간단한 방법은 @Id와 @GeneratedValue를 String 또는 Long 형식의 필드에 조합하는 것입니다. (문자열이나 스칼라 long 대신 객체를 사용하는 것이 좋습니다. 문자열이나 스칼라 long은 인스턴스가 새로운지 여부를 더 잘 나타내는 더 나은 null입니다.)"
"스프링 데이터 Neo4j에서 고유 식별자를 사용하여 불변 엔티티를 만들려면 어떻게 해야 하나요?","스프링 데이터 Neo4j에서 고유 식별자를 사용하여 불변 엔티티를 만들려면 wither 메서드를 제공해야 합니다. 이 메서드는 새로운 엔티티를 생성하고 해당 필드를 설정하여 원래 엔티티를 수정하지 않고 불변으로 만듭니다."
"스프링 데이터 Neo4j에서 외부에서 생성된 대리 키를 사용하는 것의 장단점은 무엇인가요?","스프링 데이터 Neo4j에서 외부에서 생성된 대리 키를 사용하는 것의 장점은 애플리케이션이 고유 식별자를 완전히 제어할 수 있으며, 안정된 식별자를 생성하고 나중에 변경할 필요가 없다는 것입니다. 그러나 단점은 대리 키 생성 전략이 애플리케이션 측에서 적용되며, 복제본 간에 키를 생성할 때 중복 키가 발생할 수 있다는 것입니다."
"스프링 데이터에서 객체 매핑의 핵심 책임은 무엇인가요?","스프링 데이터 객체 매핑의 핵심 책임은 도메인 객체의 인스턴스를 생성하고, 저장소 네이티브 데이터 구조를 해당 객체에 매핑하는 것입니다."
"스프링 데이터는 도메인 클래스를 최적화할 수 있는 세트는 어떤 제약 조건을 준수해야 하나요?","도메인 클래스는 다음 제약 조건을 준수해야 합니다: 비공개 클래스가 아니어야 하며, 정적이 아닌 내부 클래스가 아니어야 하며, CGLib 프록시 클래스가 아니어야 하며, 스프링 데이터에서 사용할 생성자가 비공개가 아니어야 합니다."
"스프링 데이터에서 생성자 우선순위 지정은 어떻게 이루어지나요?","해결 알고리즘은 다음과 같이 작동합니다: 인수가 없는 생성자가 있는 경우 해당 생성자가 사용됩니다. 인수가 있는 단일 생성자가 있는 경우 해당 생성자가 사용됩니다. 인수가 있는 여러 생성자가 있는 경우, 스프링 데이터에서 사용할 생성자는 @PersistenceCreator로 주석이 달려 있어야 합니다."
"Spring Data repository abstraction에서 Repository 인터페이스는 어떤 역할을 하나요?","Repository 인터페이스는 Spring Data repository abstraction에서 중요한 역할을 합니다. 이 인터페이스는 관리할 도메인 클래스와 도메인 클래스의 식별자 유형을 타입 인자로 사용합니다. 이 인터페이스는 주로 작업할 유형을 캡처하고, 이를 확장하는 인터페이스를 발견하는 데 도움이 되는 마커 인터페이스 역할을 합니다. (출처: https://docs.spring.io/spring-data/commons/docs/3.3.4/api//org/springframework/data/repository/Repository.html)"
"CrudRepository 인터페이스는 어떤 기능을 제공하나요?","CrudRepository 인터페이스는 관리 중인 엔티티 클래스에 대한 정교한 CRUD 기능을 제공합니다. 이 인터페이스에 선언된 메서드는 일반적으로 CRUD 메서드로 알려져 있습니다. (출처: https://docs.spring.io/spring-data/commons/docs/3.3.4/api//org/springframework/data/repository/CrudRepository.html)"
"PagingAndSortingRepository 인터페이스는 어떤 기능을 제공하나요?","PagingAndSortingRepository 인터페이스는 엔티티에 대한 페이지네이션된 액세스를 용이하게 하는 추가 메서드를 제공합니다. (출처: https://docs.spring.io/spring-data/commons/docs/3.3.4/api//org/springframework/data/repository/PagingAndSortingRepository.html)"
"스프링 데이터에서 표준 CRUD 기능을 위한 쿼리 메소드를 선언하려면 어떤 단계를 거쳐야 하나요?","스프링 데이터에서 표준 CRUD 기능을 위한 쿼리 메소드를 선언하려면, Repository 인터페이스를 상속하는 인터페이스를 선언하고, 해당 인터페이스에 쿼리 메소드를 선언하며, JavaConfig 또는 XML 구성을 통해 Spring에서 해당 인터페이스에 대한 프록시 인스턴스를 생성하도록 설정하고, 마지막으로 리포지토리 인스턴스를 주입하여 사용하면 됩니다."
"스프링 데이터에서 리포지토리 인스턴스를 생성하는 방법은 무엇인가요?","스프링 데이터에서 리포지토리 인스턴스를 생성하려면, JavaConfig 또는 XML 구성을 통해 Spring에서 해당 인터페이스에 대한 프록시 인스턴스를 생성하도록 설정해야 합니다. JavaConfig에서는 @EnableNeo4jRepositories 어노테이션을 사용하고, XML 구성에서는 <repositories> 요소를 사용합니다."
"스프링 데이터 리포지토리에서 커스텀 구현체를 제공하는 방법은 무엇인가요?","스프링 데이터 리포지토리에서 커스텀 구현체를 제공하려면, @RepositoryRestResource 어노테이션을 사용하여 커스텀 구현체를 정의하고, @RepositoryRestResource 어노테이션의 value 속성을 사용하여 커스텀 구현체를 특정 URI 템플릿에 매핑할 수 있습니다."
"스프링 데이터에서 리포지토리 인터페이스를 정의하는 방법은 무엇인가요?","스프링 데이터에서 리포지토리 인터페이스를 정의하려면 먼저 도메인 클래스별 리포지토리 인터페이스를 정의해야 합니다. 이 인터페이스는 Repository를 확장하고 도메인 클래스와 ID 유형에 대해 타입이 지정되어야 합니다. 해당 도메인 유형에 대한 CRUD 메서드를 노출하려면 Repository 대신 CrudRepository 또는 해당 변형 중 하나를 확장할 수 있습니다. 더 많은 제어를 원한다면 CRUD 리포지토리에서 노출하려는 메서드를 도메인 리포지토리로 복사할 수 있습니다. 반환 유형을 변경할 수 있습니다."
"스프링 데이터에서 리포지토리 인터페이스를 세밀하게 조정하는 방법은 무엇인가요?","스프링 데이터에서 리포지토리 인터페이스를 세밀하게 조정하려면 다양한 방법으로 시작할 수 있습니다. 일반적인 접근 방식은 CRUD 기능을 위한 메서드를 제공하는 CrudRepository를 확장하는 것입니다. 버전 3.0에서는 사용하기가 더 쉬울 수 있는 List 대신 Iterable을 반환하는 ListCrudRepository도 도입했습니다. 리액티브 스토어를 사용하는 경우 사용하는 리액티브 프레임워크에 따라 ReactiveCrudRepository 또는 RxJava3CrudRepository를 선택할 수 있습니다. Kotlin을 사용하는 경우 Kotlin의 코루틴을 활용하는 CoroutineCrudRepository를 선택할 수 있습니다. Sort 추상화를 지정할 수 있는 메서드가 필요한 경우 PagingAndSortingRepository, ReactiveSortingRepository, RxJava3SortingRepository 또는 CoroutineSortingRepository를 추가로 확장할 수 있습니다."
"여러 스프링 데이터 모듈을 사용할 때 리포지토리를 사용하는 방법은 무엇인가요?","여러 스프링 데이터 모듈을 사용하는 경우 리포지토리 정의는 지속성 기술을 구분해야 합니다. 여러 리포지토리 팩토리가 클래스 경로에 있는 것을 감지하면 스프링 데이터는 엄격한 리포지토리 구성 모드로 전환됩니다. 엄격한 구성은 리포지토리 또는 도메인 클래스에 대한 세부 정보를 사용하여 리포지토리 정의에 대한 스프링 데이터 모듈 바인딩을 결정합니다. 리포지토리 정의가 모듈별 리포지토리(#repositories.multiple-modules.types)를 확장하는 경우 해당 스프링 데이터 모듈의 유효한 후보입니다. 도메인 클래스가 모듈별 유형 주석(#repositories.multiple-modules.annotations)으로 주석이 지정된 경우 해당 스프링 데이터 모듈의 유효한 후보입니다. 스프링 데이터는 더 이상 리포지토리를 자동으로 구분할 수 없으므로 모호한 동작을 유발할 수 있습니다. 이를 피하려면 각 모듈에 대해 별도의 패키지 또는 구성 클래스를 사용해야 합니다."
"스프링 데이터 리포지토리 인프라에서 쿼리 룩업 전략이란 무엇인가요?","쿼리 룩업 전략은 리포지토리 인프라는 쿼리를 해결하기 위해 사용할 수 있는 전략입니다. XML 구성에서는 query-lookup-strategy 속성을 통해 네임스페이스에서 전략을 구성할 수 있고, Java 구성에서는 EnableNeo4jRepositories 어노테이션의 queryLookupStrategy 속성을 사용할 수 있습니다. 일부 전략은 특정 데이터 저장소에 대해 지원되지 않을 수 있습니다. CREATE는 쿼리 메서드 이름에서 저장소별 쿼리를 구성하려고 시도하고, USE_DECLARED_QUERY는 선언된 쿼리를 찾으려고 시도하며, 찾을 수 없으면 예외를 throw합니다. CREATE_IF_NOT_FOUND(기본값)는 CREATE와 USE_DECLARED_QUERY를 결합하여 선언된 쿼리를 먼저 찾고, 선언된 쿼리를 찾을 수 없으면 사용자 정의 메서드 이름 기반 쿼리를 생성합니다."
"스프링 데이터 리포지토리 인프라에서 쿼리 메서드 이름에서 저장소별 쿼리를 구성하는 방법은 무엇인가요?","스프링 데이터 리포지토리 인프라에서 쿼리 메서드 이름에서 저장소별 쿼리를 구성하려면, 메서드 이름에서 주어진 일련의 잘 알려진 접두사를 제거하고 나머지 메서드를 구문 분석하여 저장소별 쿼리를 구성합니다. 자세한 내용은 'Query Creation(#repositories.query-methods.query-creation)'을 참조하십시오."
"스프링 데이터 리포지토리 인프라에서 쿼리 메서드 이름의 표현식 구문은 어떻게 되나요?","스프링 데이터 리포지토리 인프라에서 쿼리 메서드 이름의 표현식 구문은 메서드 이름에서 엔티티의 제약 쿼리를 구축하는 데 유용합니다. 표현식은 일반적으로 AND 및 OR로 연결할 수 있는 연산자와 결합된 속성 탐색입니다. 지원되는 연산자는 데이터 저장소에 따라 다를 수 있으므로 참조 문서의 해당 부분을 참조하십시오. 메서드 파서는 개별 속성에 대해 IgnoreCase 플래그를 설정하거나(예: findByLastnameIgnoreCase(…)) IgnoreCase를 지원하는 유형의 모든 속성에 대해 IgnoreCase 플래그를 설정할 수 있습니다(일반적으로 String 인스턴스 — 예: findByLastnameAndFirstnameAllIgnoreCase(…)). IgnoreCase를 지원하는지 여부는 저장소에 따라 다를 수 있으므로 저장소별 쿼리 메서드에 대한 참조 문서의 관련 섹션을 참조하십시오."
"스프링 데이터에서 커스텀 리포지토리 구현을 어떻게 만들 수 있나요?","스프링 데이터에서 커스텀 리포지토리 구현을 만들기 위해서는 먼저 커스텀 기능에 대한 프래그먼트 인터페이스와 구현을 정의해야 합니다. 그런 다음 리포지토리 인터페이스에서 해당 프래그먼트 인터페이스를 확장하면 됩니다. 커스텀 구현 클래스의 이름에서 가장 중요한 부분은 Impl 접미사입니다. 구현 자체는 스프링 데이터에 의존하지 않으며 일반적인 스프링 빈일 수 있습니다. 이렇게 하면 표준 의존성 주입 동작을 사용하여 다른 빈(예: JdbcTemplate)에 대한 참조를 주입하고, 어스펙트에 참여할 수 있습니다. 커스텀 구현은 기본 구현 및 리포지토리 어스펙트보다 우선 순위가 높습니다. 여러 리포지토리가 커스텀 구현을 사용할 수 있습니다. 커스텀 구현의 자동 감지는 리포지토리에서 인터페이스를 찾은 패키지 아래의 클래스를 스캔하여 수행됩니다. 이러한 클래스는 Impl로 끝나는 접미사를 추가하는 명명 규칙을 따라야 합니다. 충돌이 발생하는 경우 스프링 데이터는 빈 이름을 사용하여 사용할 구현을 식별합니다. 커스텀 구현이 주석 기반 구성 및 자동 와이어링만 사용하는 경우 자동으로 처리됩니다. 커스텀 구현이 특별한 와이어링을 필요로 하는 경우 빈을 선언하고 명명 규칙에 따라 이름을 지정할 수 있습니다. 이렇게 하면 인프라가 직접 빈을 만드는 대신 이름에 따라 수동으로 정의된 빈 정의를 참조합니다. 마지막으로, 모든 리포지토리에 영향을 미치도록 기본 리포지토리 동작을 커스터마이즈하려면 지속성 기술별 리포지토리 기본 클래스를 확장하는 구현을 만들 수 있습니다. 이 클래스는 리포지토리 프록시의 커스텀 기본 클래스로 작동합니다. 마지막으로, 스프링 데이터 인프라에 커스텀 리포지토리 기본 클래스를 알리기 위해 repositoryBaseClass를 사용할 수 있습니다."
"커스텀 리포지토리 구현에서 커스텀 기능에 대한 프래그먼트 인터페이스와 구현을 어떻게 정의하나요?","커스텀 리포지토리 구현에서 커스텀 기능에 대한 프래그먼트 인터페이스와 구현을 정의하려면 먼저 인터페이스를 만들어야 합니다. 그런 다음 해당 인터페이스를 구현하는 클래스를 만듭니다. 구현 클래스의 이름에서 가장 중요한 부분은 Impl 접미사입니다. 구현 자체는 스프링 데이터에 의존하지 않으며 일반적인 스프링 빈일 수 있습니다. 이렇게 하면 표준 의존성 주입 동작을 사용하여 다른 빈(예: JdbcTemplate)에 대한 참조를 주입하고, 어스펙트에 참여할 수 있습니다. 커스텀 구현은 기본 구현 및 리포지토리 어스펙트보다 우선 순위가 높습니다. 여러 리포지토리가 커스텀 구현을 사용할 수 있습니다. 커스텀 구현의 자동 감지는 리포지토리에서 인터페이스를 찾은 패키지 아래의 클래스를 스캔하여 수행됩니다. 이러한 클래스는 Impl로 끝나는 접미사를 추가하는 명명 규칙을 따라야 합니다. 충돌이 발생하는 경우 스프링 데이터는 빈 이름을 사용하여 사용할 구현을 식별합니다. 커스텀 구현이 주석 기반 구성 및 자동 와이어링만 사용하는 경우 자동으로 처리됩니다. 커스텀 구현이 특별한 와이어링을 필요로 하는 경우 빈을 선언하고 명명 규칙에 따라 이름을 지정할 수 있습니다. 이렇게 하면 인프라가 직접 빈을 만드는 대신 이름에 따라 수동으로 정의된 빈 정의를 참조합니다. 마지막으로, 모든 리포지토리에 영향을 미치도록 기본 리포지토리 동작을 커스터마이즈하려면 지속성 기술별 리포지토리 기본 클래스를 확장하는 구현을 만들 수 있습니다. 이 클래스는 리포지토리 프록시의 커스텀 기본 클래스로 작동합니다. 마지막으로, 스프링 데이터 인프라에 커스텀 리포지토리 기본 클래스를 알리기 위해 repositoryBaseClass를 사용할 수 있습니다."
"Spring Data의 @DomainEvents 어노테이션의 목적은 무엇인가요?","Spring Data의 @DomainEvents 어노테이션은 애그리게이트 루트의 메서드에 사용되어 도메인 이벤트의 게재를 최대한 쉽게 할 수 있도록 도와줍니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/repositories/core-domain-events.html)"
"애그리게이트 루트에서 @DomainEvents 메서드는 어떤 인스턴스나 컬렉션을 반환할 수 있나요?","애그리게이트 루트에서 @DomainEvents 메서드는 단일 이벤트 인스턴스나 이벤트 컬렉션을 반환할 수 있습니다. 이 메서드는 인수를 받지 않아야 합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/repositories/core-domain-events.html)"
"애그리게이트 루트에서 @AfterDomainEventPublication 어노테이션의 용도는 무엇인가요?","애그리게이트 루트에서 @AfterDomainEventPublication 어노테이션은 모든 이벤트가 게시된 후에 잠재적으로 게시될 이벤트 목록을 정리할 수 있는 메서드에 사용됩니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/repositories/core-domain-events.html)"
"Spring Data Extensions는 어떤 목적을 가지고 있나요?","Spring Data Extensions는 다양한 컨텍스트에서 Spring Data를 사용할 수 있도록 하는 확장 기능입니다."
"Querydsl Extension은 어떤 프레임워크인가요?","Querydsl Extension은 Querydsl(http://www.querydsl.com/)이라는 프레임워크로, 정적 타입의 SQL과 유사한 쿼리를 생성할 수 있는 기능을 제공합니다."
"QuerydslPredicateExecutor 인터페이스는 어떤 용도로 사용되나요?","QuerydslPredicateExecutor 인터페이스는 Querydsl과 통합된 Spring Data 모듈에서 Predicate 인스턴스를 사용하여 타입 안전한 쿼리를 작성할 수 있도록 합니다."
"Query by Example (QBE)는 무엇이며 어떤 기능을 제공하나요?","Query by Example (QBE)는 사용자 친화적인 쿼리 기술로, 간단한 인터페이스를 제공하며 동적 쿼리 생성을 가능하게 합니다. 필드 이름을 포함하는 쿼리를 작성할 필요 없이, 도메인 객체의 실제 예제와 ExampleMatcher를 사용하여 쿼리를 생성할 수 있습니다. QBE는 정적 또는 동적 제약 조건으로 데이터 저장소를 쿼리하고, 기존 쿼리를 깨뜨리지 않고 도메인 객체를 자주 리팩토링하며, 기본 데이터 저장소 API와 독립적으로 작동하는 데 적합합니다."
"Query by Example을 사용하기 위해 필요한 것은 무엇인가요?","Query by Example을 사용하기 전에 도메인 객체가 필요합니다. 예제를 만들기 위해 Person 클래스를 사용할 수 있으며, Example.of() 메서드 또는 ExampleMatcher를 사용하여 예제를 만들 수 있습니다. 예제는 불변이며, 예제는 정적 또는 동적 제약 조건으로 데이터 저장소를 쿼리하는 데 사용됩니다. 예제 매칭은 ExampleMatcher를 사용하여 사용자 정의할 수 있습니다."
"Query by Example을 사용하여 쿼리를 실행하는 방법은 무엇인가요?","QueryByExampleExecutor 인터페이스를 사용하여 예제 쿼리를 실행할 수 있습니다. QueryByExampleExecutor를 상속하는 저장소 인터페이스를 만들어야 합니다. 그런 다음 findOne() 및 findAll() 메서드를 사용하여 예제에서 파생된 쿼리를 실행할 수 있습니다. FetchableFluentQuery의 fluent API를 사용하여 쿼리를 추가로 사용자 정의할 수도 있습니다."
"스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 지원되는 쿼리 메서드 서브젝트 키워드의 종류는 무엇인가요?","스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 지원되는 쿼리 메서드 서브젝트 키워드로는 find…By, read…By, get…By, query…By, search…By, stream…By, exists…By, count…By, delete…By, remove…By 등이 있습니다. 각 스토리지별로 지원되는 키워드의 정확한 목록은 해당 스토리지의 문서를 참조해야 합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 지원되는 쿼리 메서드 서브젝트 키워드의 구문은 어떻게 되나요?","스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 지원되는 쿼리 메서드 서브젝트 키워드의 구문은 find…By, read…By, get…By, query…By, search…By, stream…By, exists…By, count…By, delete…By, remove…By 등이 있습니다. 각 키워드 뒤에 쿼리 조건을 지정하는 문자열이 오며, 쿼리 조건은 문자열, 숫자, 날짜 등의 형태로 지정됩니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 지원되는 쿼리 메서드 서브젝트 키워드 중 LIMIT을 지정하는 방법은 무엇인가요?","스프링 데이터 리포지토리 쿼리 도출 메커니즘에서 LIMIT을 지정하는 방법은 find, read, get, query, search, stream 등의 키워드 뒤에 …First<number>... 또는 …Top<number>... 키워드를 사용하는 것입니다. 예를 들어, findTop10ByAgeGreaterThan() 메서드는 나이가 10보다 큰 엔티티 중 상위 10개만 반환합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/repositories/query-keywords-reference.html)"
"스프링 데이터 리포지토리에서 일반적으로 지원되는 쿼리 반환 유형은 무엇인가요?","스프링 데이터 리포지토리에서 일반적으로 지원되는 쿼리 반환 유형에는 void, Java의 원시형, 래퍼형, T, Iterator<T>, Collection<T>, List<T>, Optional<T>, Stream<T>, Optional<T>, Future<T>, CompletableFuture<T>, Slice<T>, Page<T>, Window<T>, GeoResult<T>, GeoResults<T>, GeoPage<T>, Mono<T>, Flux<T>, Single<T>, Maybe<T>, Flowable<T> 등이 있습니다. (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/repositories/query-return-types-reference.html>)"
"스프링 데이터 리포지토리에서 Geospatial 쿼리를 지원하는 데이터 저장소는 어떤 것이 있나요?","스프링 데이터 리포지토리에서 Geospatial 쿼리를 지원하는 데이터 저장소에는 GeoResult, GeoResults, GeoPage 등의 지리공간 유형이 포함됩니다. (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/repositories/query-return-types-reference.html>)"
"스프링 데이터 리포지토리에서 반환되는 쿼리 유형 중 하나인 Future<T>는 어떤 특징을 가지고 있나요?","스프링 데이터 리포지토리에서 반환되는 쿼리 유형 중 하나인 Future<T>는 @Async 어노테이션이 달린 메서드를 기대하며, Spring의 비동기 메서드 실행 기능이 활성화되어야 합니다. (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/repositories/query-return-types-reference.html>)"
"스프링 데이터의 프로젝션이란 무엇이며, 어떻게 사용하는 건가요?","스프링 데이터의 프로젝션은 리포지토리에서 관리하는 어그리게이트 루트의 특정 속성을 기반으로 프로젝션을 생성하는 기능입니다. 이를 위해 프로퍼티에 대한 액세스 메서드를 노출하는 인터페이스를 선언하거나, 값 타입 DTO(Data Transfer Object)를 사용하여 필드를 지정할 수 있습니다. 프로젝션은 쿼리 메서드의 반환 유형으로 사용되며, 쿼리 메서드는 지정된 속성만 포함하도록 결과를 제한할 수 있습니다. 이를 통해 필요한 데이터만 검색하여 메모리 사용량과 네트워크 트래픽을 줄일 수 있습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/repositories/projections.html)"
"스프링 데이터의 프로젝션에는 어떤 유형이 있나요?","스프링 데이터의 프로젝션 유형에는 인터페이스 기반 프로젝션, 클래스 기반 프로젝션(DTO), 동적 프로젝션 등이 있습니다. 인터페이스 기반 프로젝션은 프로퍼티에 대한 액세스 메서드를 노출하는 인터페이스를 선언하여 사용하며, 클래스 기반 프로젝션은 값 타입 DTO를 사용하여 필드를 지정합니다. 동적 프로젝션은 메서드 호출 시 사용할 유형을 선택할 수 있어 유연성을 제공합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/repositories/projections.html)"
"인터페이스 기반 프로젝션과 클래스 기반 프로젝션(DTO)의 차이점은 무엇인가요?","인터페이스 기반 프로젝션은 메서드 호출 시 해당 인터페이스의 프록시 인스턴스를 생성하여 대상 객체에 대한 호출을 전달합니다. 반면, 클래스 기반 프로젝션(DTO)은 프록시 생성이 일어나지 않으며, 쿼리 메서드의 반환 유형으로 사용됩니다. 또한, 인터페이스 기반 프로젝션은 중첩 프로젝션을 적용할 수 있지만, 클래스 기반 프로젝션은 중첩 프로젝션을 적용할 수 없습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/repositories/projections.html)"
"Spring Data Neo4j에서 projection의 두 가지 유형은 무엇인가요?","Spring Data Neo4j에서 projection의 두 가지 유형은 인터페이스 기반 프로젝션과 DTO 기반 프로젝션입니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/projections/sdn-projections.html)"
"Spring Data Neo4j에서 projection을 사용하면 어떤 이점이 있나요?","Spring Data Neo4j에서 projection을 사용하면 애플리케이션의 모든 사용 시나리오에서 필요하지 않을 수 있는 많은 속성을 포함하는 노드 및 엔티티와 관련된 경우 데이터베이스의 부하를 줄일 수 있습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/projections/sdn-projections.html)"
"Spring Data Neo4j에서 projection을 사용하면 저장소 쿼리에 어떤 영향을 미치나요?","Spring Data Neo4j에서 projection을 사용하면 저장소의 도메인 유형이 쿼리 작성에 사용되며, 쿼리를 변경할 수 있는 모든 속성에 대한 모든 주석이 고려됩니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/projections/sdn-projections.html)"
"Spring Boot 없이 통합 테스트에서 구성에 사용되는 추상 기본 클래스는 무엇인가요?","Spring Boot 없이 통합 테스트에서 구성에 사용되는 추상 기본 클래스는 `AbstractNeo4jConfig`입니다. (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/testing/testing-without-spring-boot.html>)"
"Spring Boot 없이 통합 테스트에서 `@Autowired` 어노테이션을 사용하는 방법은 무엇인가요?","Spring Boot 없이 통합 테스트에서 `@Autowired` 어노테이션을 사용하려면 `@Autowired` 어노테이션을 필드에 추가하고, 해당 필드의 타입으로 자동 연결되는 빈을 주입해야 합니다. (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/testing/testing-without-spring-boot.html>)"
"Spring Boot 없이 통합 테스트에서 테스트 서버 또는 컨테이너에 연결을 제공해야 하는 이유는 무엇인가요?","Spring Boot 없이 통합 테스트에서 테스트 서버 또는 컨테이너에 연결을 제공해야 하는 이유는 실제 데이터베이스와 연동하여 테스트를 수행하기 위함입니다. (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/testing/testing-without-spring-boot.html>)"
"Spring Boot에서 @DataNeo4jTest를 사용하려면 어떤 스타터를 포함해야 하나요?","Spring Boot Starter Test (org.springframework.boot:spring-boot-starter-test)를 포함해야 합니다. 이를 통해 @DataNeo4jTest 어노테이션과 필요한 인프라스트럭처 코드를 사용할 수 있습니다."
"@DataNeo4jTest는 어떤 기능을 제공하나요?","@DataNeo4jTest는 Neo4j를 사용하는 테스트를 위한 필요한 인프라스트럭처를 제공하는 Spring Boot 테스트 슬라이스입니다. 이에는 트랜잭션 매니저, 클라이언트, 템플릿 및 선언된 리포지토리가 포함되며, 반응형 의존성이 있는지 여부에 따라 명령형 또는 반응형 변형으로 제공됩니다. 또한, 테스트 슬라이스는 이미 @ExtendWith(SpringExtension.class)를 포함하므로 JUnit 5 (Jupiter)로 자동으로 실행됩니다."
"Neo4j 테스트에서 연결을 설정하기 위해 어떤 옵션을 고려해야 하나요?","Neo4j 테스트에서 연결을 설정하기 위해 두 가지 옵션을 고려할 수 있습니다. Testcontainers Neo4j 모듈을 사용하거나 Neo4j 테스트 하네스를 사용할 수 있습니다. Testcontainers는 다양한 서비스에 대한 모듈을 갖춘 알려진 프로젝트이며, Neo4j 테스트 하네스는 특히 저장 프로시저를 테스트할 때 유용합니다. 테스트 하네스는 애플리케이션과 동일한 JVM 내에서 데이터베이스를 시작하므로 성능 및 타이밍이 프로덕션 설정과 다를 수 있습니다."
"Spring Data에서 엔티티가 생성되거나 변경되었을 때, 누가 변경했는지와 변경 시간을 자동으로 추적할 수 있는 방법은 무엇인가요?","Spring Data에서는 엔티티 클래스에 어노테이션이나 인터페이스를 사용하여 감사 메타데이터를 추가하면 자동으로 누가 변경했는지와 변경 시간을 추적할 수 있습니다. 또한, Annotation configuration 또는 XML configuration을 통해 감사를 활성화해야 합니다. 자세한 내용은 해당 스토어별 섹션을 참조하세요. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/auditing.html)"
"Spring Data에서 감사 메타데이터를 정의하는 데 어노테이션과 인터페이스 중 어떤 방식을 사용해야 하나요?","Spring Data에서는 어노테이션(Annotation-based Auditing Metadata) 또는 인터페이스(Interface-based Auditing Metadata)를 사용하여 감사 메타데이터를 정의할 수 있습니다. 어노테이션을 사용하여 원하는 정보에 따라 선택적으로 적용할 수 있고, 인터페이스를 사용하여 도메인 클래스가 Auditable 인터페이스를 구현하도록 할 수 있습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/auditing.html)"
"Spring Data에서 @CreatedBy 또는 @LastModifiedBy 어노테이션을 사용할 때, 현재 주체에 대한 정보를 어떻게 얻을 수 있나요?","Spring Data에서 @CreatedBy 또는 @LastModifiedBy 어노테이션을 사용할 때, 현재 주체에 대한 정보를 얻기 위해 AuditorAware<T> SPI 인터페이스를 구현해야 합니다. 이 인터페이스를 구현하여 현재 사용자 또는 시스템과 상호 작용하는 방법을 인프라에 알려야 합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/auditing.html)"
"Spring Data Neo4j를 사용하려면 Spring Boot를 반드시 사용해야 하나요?","아니요, Spring Boot를 사용하지 않고도 Spring Data Neo4j를 사용할 수 있습니다. Spring Data Neo4j를 사용하기 위해 필요한 의존성은 다음과 같습니다: https://docs.spring.io/spring-data/neo4j/reference/7.3/faq.html#spring-boot"
"Spring Data Neo4j에서 'Find by example' 기능을 사용하려면 어떻게 해야 하나요?","Spring Data Neo4j에서 'Find by example' 기능을 사용하려면 엔티티를 인스턴스화하거나 기존 엔티티를 사용하여 org.springframework.data.domain.Example을 생성하면 됩니다. 저장소가 org.springframework.data.neo4j.repository.Neo4jRepository 또는 org.springframework.data.neo4j.repository.ReactiveNeo4jRepository를 확장하는 경우, 예제를 인수로 사용하는 사용 가능한 findBy 메서드를 즉시 사용할 수 있습니다. 예: https://docs.spring.io/spring-data/neo4j/reference/7.3/faq.html#find-by-example-example"
"Spring Data Neo4j에서 사용자 정의 쿼리를 사용하여 Page<T> 또는 Slice<T>를 반환하는 리포지토리 메서드를 사용하려면 어떻게 해야 하나요?","Page<T> 또는 Slice<T>를 반환하는 사용자 정의 쿼리를 사용하려면 Pageable을 매개변수로 제공하고 쿼리가 페이지 가능한 매개변수를 처리하도록 준비해야 합니다. 자세한 내용은 다음 링크를 참조하십시오: https://docs.spring.io/spring-data/neo4j/reference/7.3/faq.html#custom-queries-with-page-and-slice-examples"
"Spring Data Neo4j에서 변환이란 무엇이며 어떻게 이루어지나요?","Spring Data Neo4j에서 변환은 다양한 데이터 유형을 네이티브 NEO4J 데이터베이스 형식으로 변환하는 과정입니다. 이 과정은 주로 사용자 정의 쿼리 생성 시 사용되며, 자세한 내용은 변환(conversions.html) 섹션에서 확인할 수 있습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/index.html)"
"Spring Data Neo4j를 사용하여 로그를 생성하는 방법은 무엇인가요?","Spring Data Neo4j를 사용하여 로그를 생성하려면 로깅(logging.html) 기능을 사용할 수 있습니다. 이를 통해 데이터베이스 작업 및 기타 관련 활동에 대한 정보를 기록할 수 있습니다. 자세한 내용은 해당 섹션에서 확인할 수 있습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/index.html)"
"Spring Data Neo4j에서 사용자 정의 쿼리를 어떻게 생성하고 사용할 수 있나요?","Spring Data Neo4j에서 사용자 정의 쿼리를 생성하려면 쿼리 생성(query-creation.html) 기능을 사용할 수 있습니다. 이를 통해 문서를 쿼리로 변환하고 사용자 정의 쿼리를 생성할 수 있습니다. 자세한 내용은 사용자 정의 쿼리(custom-queries.html) 섹션에서 확인할 수 있습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/index.html)"
"Neo4j Converter에서 객체 속성을 노드 필드로 매핑하는 데 사용되는 기본 매핑은 무엇인가요?","Neo4j Converter는 객체 속성을 노드 필드로 매핑하기 위해 추가적인 매핑 메타데이터가 제공되지 않을 때 몇 가지 기본 매핑을 사용합니다. 객체의 필드는 그래프의 필드로 변환하는 데 사용됩니다. 공개 JavaBean 속성은 사용되지 않습니다. 생성자 인자 이름이 노드의 최상위 속성 이름과 일치하는 단일 비-zero-argument 생성자가 있는 경우 해당 생성자가 사용됩니다. 그렇지 않으면 zero-argument 생성자가 사용됩니다. 비-zero-argument 생성자가 하나 이상인 경우 예외가 발생합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/conversions.html)"
"Neo4j와 함께 사용할 수 있는 다양한 데이터 유형은 무엇인가요?","Neo4j는 다양한 원시 유형, 래퍼 유형 및 사용자 정의 유형을 지원합니다. 부울, 정수, 실수, 문자열, 날짜 및 시간, 지리적 위치 및 사용자 정의 유형과 같은 데이터 유형을 매핑할 수 있습니다. 지원되는 Cypher 유형 목록은 공식 드라이버 매뉴얼의 유형 매핑 섹션에서 찾을 수 있습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/conversions.html)"
"Spring Data Neo4j에서 사용자 정의 변환기를 구현하려면 어떻게 해야 하나요?","Spring Data Neo4j에서 사용자 정의 변환기를 구현하려면 GenericConverter 인터페이스를 구현하고 변환기가 처리해야 하는 유형을 등록해야 합니다. 엔티티 속성 유형 변환기의 경우 유형을 Neo4j Java Driver Value로 변환하고 다시 변환해야 합니다. 사용자 정의 변환기를 사용하려면 Neo4jConversions에 등록해야 합니다. 이를 위해 org.springframework.data.neo4j.core.convert.Neo4jConversions 유형의 @Bean을 만들어 추가 변환기를 전달해야 합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/conversions.html)"
"Spring Data Neo4j에서 Neo4j Client는 어떤 역할을 하며 어떤 장점을 가지고 있나요?","Neo4j Client는 Spring Data Neo4j에서 제공되며, Neo4j의 Java 드라이버 위에 얇은 레이어를 제공합니다. 이 클라이언트는 imperative 및 reactive 버전에서 Spring 애플리케이션 레벨 트랜잭션을 통합하고, JTA 트랜잭션에 참여하며, imperative 및 reactive 시나리오에 대한 일관된 API를 제공하고, 매핑 오버헤드를 추가하지 않습니다. Neo4j Client는 두 가지 버전으로 제공되며, imperative 및 reactive 시나리오에 대한 일관된 API를 제공합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/neo4j-client.html)"
"Spring Data Neo4j에서 imperative 및 reactive Neo4j Client 간의 주요 차이점은 무엇인가요?","imperative 및 reactive Neo4j Client의 주요 차이점은 API 호환성이 없으며, 데이터베이스와의 상호 작용 및 결과 검색이 구독될 때까지 발생하지 않는다는 것입니다. imperative 버전은 Optional<> 또는 Collection으로 래핑된 요청된 결과 또는 요약을 가져오기 위해 이 시점에서 데이터베이스와 상호 작용합니다. reactive 버전은 요청된 유형의 게시자를 반환합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/neo4j-client.html)"
"Spring Data Neo4j에서 Neo4j Client를 사용하여 쿼리를 실행하는 방법은 무엇인가요?","Spring Data Neo4j에서 Neo4j Client를 사용하여 쿼리를 실행하려면 먼저 plain String 또는 Supplier<String>을 사용하여 쿼리를 정의해야 합니다. 그런 다음 Neo4jClient.create(driver) 또는 ReactiveNeo4jClient.create(driver)를 사용하여 Neo4jClient 또는 ReactiveNeo4jClient 인스턴스를 가져오고, query() 메서드를 사용하여 쿼리를 지정하고, fetch() 메서드를 호출하여 결과를 검색해야 합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/neo4j-client.html)"
"Spring Data Neo4j에서 Cypher 알림에 대한 로깅은 언제부터 지원되나요?","Spring Data Neo4j에서 Cypher 알림에 대한 로깅은 7.1.5 버전부터 지원됩니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/logging.html)"
"Spring Data Neo4j에서 Cypher 알림에 대한 logger는 어떤 것들이 있나요?","Spring Data Neo4j에서 Cypher 알림에 대한 logger는 org.springframework.data.neo4j.cypher, org.springframework.data.neo4j.cypher.performance, org.springframework.data.neo4j.cypher.hint, org.springframework.data.neo4j.cypher.unrecognized, org.springframework.data.neo4j.cypher.unsupported, org.springframework.data.neo4j.cypher.deprecation, org.springframework.data.neo4j.cypher.generic, org.springframework.data.neo4j.cypher.security, org.springframework.data.neo4j.cypher.topology이 있습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/logging.html)"
"Spring Data Neo4j에서 어떤 logger를 사용하면 모든 Cypher 알림을 볼 수 있나요?","Spring Data Neo4j에서 모든 Cypher 알림을 보려면 logger org.springframework.data.neo4j.cypher를 사용하면 됩니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/logging.html)"
"SDN의 추상화 계층을 사용할 때 쿼리 생성에 대한 정보 출처는 무엇인가요?","출처: {https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/query-creation.html}"
"SDN을 사용하여 데이터 작업 시 가장 많이 사용되는 작업 중 하나인 'save' 작업에 대한 자세한 정보를 알려주세요.","출처: {https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/query-creation.html}"
"SDN을 사용하여 데이터를 로드할 때, 데이터는 어떻게 반환되나요?","출처: {https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/query-creation.html}"
"커스텀 쿼리에서 Spring Data Neo4j는 무엇을 허용하나요?","Spring Data Neo4j는 리포지토리에서 커스텀 쿼리를 지정할 수 있도록 허용하며, 파인더 로직을 파생된 쿼리 함수를 통해 표현할 수 없는 경우 유용합니다. (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/custom-queries.html>)"
"Spring Data Neo4j에서 커스텀 쿼리와 커스텀 매핑을 함께 사용하는 방법은 무엇인가요?","FAQ에서 커스텀 쿼리와 커스텀 매핑을 함께 사용하는 대체 형태에 대해 알아보십시오. (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/custom-queries.html>)"
"커스텀 쿼리의 결과 집합을 하나의 '루트 노드'로 유지하는 방법은 무엇인가요?","Spring Data Neo4j는 내부적으로 레코드 지향적으로 작동하므로, 동일한 '루트 노드'에 대해 여러 레코드가 있는 결과 집합을 빌드하지 않도록 주의해야 합니다. (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/custom-queries.html>)"
"Spring Data Neo4j에서 지원되는 공간 유형은 무엇인가요?","Spring Data Neo4j에서 지원되는 공간 유형은 Point, GeographicPoint2d, GeographicPoint3d, CartesianPoint2d, CartesianPoint3d입니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/spatial-types.html)"
"Spring Data Neo4j에서 파생된 찾기 메서드에서 어떤 키워드와 매개변수 유형을 사용할 수 있나요?","Spring Data Neo4j에서 파생된 찾기 메서드에서 사용할 수 있는 키워드와 매개변수 유형은 within, near입니다. 매개변수 유형으로는 Circle, Box, BoundingBox, Point 등이 있습니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/spatial-types.html)"
"Spring Data Neo4j에서 BoundingBox를 사용하여 Polygon을 쿼리할 수 있나요?","Spring Data Neo4j에서는 BoundingBox를 사용하여 Polygon을 쿼리할 수 있습니다. Polygon을 BoundingBox로 변환하여 사용해야 합니다. (출처: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/spatial-types.html)"
"SDN+OGM 마이그레이션 시 주요 이슈는 무엇인가요?","SDN+OGM 마이그레이션 시 주요 이슈는 한 개 이상의 주요 업그레이드를 건너뛴 경우, Spring Data Neo4j에 의존하기 때문에 애플리케이션의 많은 부분에 영향을 미치는 경우, 애플리케이션에 여러 Spring Data 모듈이 있고 그래프 데이터베이스와 동일한 서비스 계층에서 관계형 데이터베이스에 액세스하는 경우, Spring Data를 통해 구성된 임베디드 데이터베이스에 의존하는 경우, 그리고 어떤 구성 요소를 포함해야 하는지 확실하지 않은 경우입니다. (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/migrating.html>)"
"SDN+OGM에서 SDN으로 마이그레이션하는 방법은 무엇인가요?","SDN+OGM에서 SDN으로 마이그레이션하려면, 먼저 애플리케이션이 Bolt 프로토콜을 통해 서버 모드에서 Neo4j와 함께 작동하는지 확인해야 합니다. 그런 다음, 모든 org.neo4j:neo4j-ogm-* 종속성을 제거하고, Spring Data를 통해 SDN을 구성하는 것을 중지하고, 속성을 업데이트하고, 새로운 종속성을 추가하고, 주석을 대체해야 합니다. 또한, 책갈피 관리, 제약 조건 및 인덱스 자동 생성 등의 기능은 더 이상 지원되지 않으므로, 데이터베이스 마이그레이션을 제어하는 도구를 사용하는 것이 좋습니다. (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/migrating.html>)"
"SDN과 Neo4j-OGM의 속성 차이는 무엇인가요?","SDN과 Neo4j-OGM의 속성 차이점은 Neo4j-OGM의 spring.data.neo4j.uri 속성이 SDN의 spring.neo4j.uri 속성으로 변경되고, Neo4j-OGM의 spring.data.neo4j.username 및 spring.data.neo4j.password 속성이 SDN의 spring.neo4j.authentication.username 및 spring.neo4j.authentication.password 속성으로 변경된다는 것입니다. (출처: <https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/migrating.html>)"
"Spring Data Neo4j를 빌드하기 위해 필요한 요구 사항은 무엇인가요?","Spring Data Neo4j를 빌드하기 위해서는 JDK 17 이상 (OpenJDK 또는 Oracle JDK), Maven 3.8.5 이상, 그리고 Neo4j 5.+ 데이터베이스가 필요합니다. (로컬에서 실행 중이거나 Testcontainers 및 Docker를 통해 간접적으로 실행 중이어야 함) (Source: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/build.html)"
"Spring Data Neo4j 빌드에서 사용되는 JDK 버전은 어떤 영향을 받았나요?","Spring Data Neo4j 빌드에서 사용되는 JDK 버전은 SDN이 Spring Data 프로젝트이기 때문에 Spring Data와 Spring Framework의 공통 기준인 JDK 17을 사용하는 것으로 결정되었습니다. (Source: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/build.html)"
"Spring Data Neo4j 빌드를 진행하기 전에 JDK 버전을 어떻게 확인할 수 있나요?","Spring Data Neo4j 빌드를 진행하기 전에 JDK 버전을 확인하려면 터미널에서 'java -version' 명령을 실행하면 됩니다. 출력 결과에는 JDK 버전 정보가 표시됩니다. (Source: https://docs.spring.io/spring-data/neo4j/reference/7.3/appendix/build.html)"
