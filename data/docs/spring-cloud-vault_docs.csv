"url","content"
"https://docs.spring.io/spring-cloud-vault/reference/index.html","Spring Cloud Vault: Spring Cloud Vault Config provides client-side support for externalized configuration in a distributed system built on top of Spring Vault(https://docs.spring.io/spring-vault/reference/) . With HashiCorp’s Vault(https://www.vaultproject.io) you have a central place to manage external secret properties for applications across all environments. Vault can manage static and dynamic secrets such as username/password for remote applications/resources and provide credentials for external services such as MySQL, PostgreSQL, Apache Cassandra, Couchbase, MongoDB, Consul, AWS and more. Config Data API(config-data.html) Application Configuration using Vault Secrets Authentication(authentication.html) Configuring Authentication with Vault Secret Backends(secret-backends.html) Mounting Secret Backends Advanced Topics(advanced-topics.html) Service Discovery, Fail-Fast, SSL Configuration, Lifecycle Management Mark Paluch, Jay Bryant, Spencer Gibb © 2008-2023 VMware, Inc. Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically."
"https://docs.spring.io/spring-cloud-vault/reference/quickstart.html","Quick Start: This section explains how to get you started with Vault and Spring Cloud Vault. Prerequisites: To get started with Vault and this guide you need a *NIX-like operating systems that provides: wget , openssl and unzip at least Java 8 and a properly configured JAVA_HOME environment variable This guide explains Vault setup from a Spring Cloud Vault perspective for integration testing. You can find a getting started guide directly on the Vault project site: learn.hashicorp.com/vault(https://learn.hashicorp.com/vault) Install Vault $ wget https://releases.hashicorp.com/vault/${vault_version}/vault_${vault_version}_${platform}.zip $ unzip vault_${vault_version}_${platform}.zip These steps can be achieved by downloading and running install_vault.sh(https://github.com/spring-cloud/spring-cloud-vault/blob/master/src/test/bash/install_vault.sh) . Create SSL certificates for Vault: Next, you’re required to generate a set of certificates: Root CA Vault Certificate (decrypted key work/ca/private/localhost.decrypted.key.pem and certificate work/ca/certs/localhost.cert.pem ) Make sure to import the Root Certificate into a Java-compliant truststore. The easiest way to achieve this is by using OpenSSL. create_certificates.sh(https://github.com/spring-cloud/spring-cloud-vault/blob/master/src/test/bash/) creates certificates in work/ca and a JKS truststore work/keystore.jks . If you want to run Spring Cloud Vault using this quickstart guide you need to configure the truststore the spring.cloud.vault.ssl.trust-store property to file:work/keystore.jks . Start Vault server: Next create a config file along the lines of: backend ""inmem"" { } listener ""tcp"" { address = ""0.0.0.0:8200"" tls_cert_file = ""work/ca/certs/localhost.cert.pem"" tls_key_file = ""work/ca/private/localhost.decrypted.key.pem"" } disable_mlock = true You can find an example config file at vault.conf(https://github.com/spring-clod/spring-cloud-vault/blob/master/src/test/bash/vault.conf) . $ vault server -config=vault.conf Vault is started listening on 0.0.0.0:8200 using the inmem storage and https . Vault is sealed and not initialized when starting up. If you want to run tests, leave Vault uninitialized. The tests will initialize Vault and create a root token 00000000-0000-0000-0000-000000000000 . If you want to use Vault for your application or give it a try then you need to initialize it first. $ export VAULT_ADDR=""https://localhost:8200"" $ export VAULT_SKIP_VERIFY=true # Don't do this for production $ vault operator init You should see something like: Key 1: 7149c6a2e16b8833f6eb1e76df03e47f6113a3288b3093faf5033d44f0e70fe701 Key 2: 901c534c7988c18c20435a85213c683bdcf0efcd82e38e2893779f152978c18c02 Key 3: 03ff3948575b1165a20c20ee7c3e6edf04f4cdbe0e82dbff5be49c63f98bc03a03 Key 4: 216ae5cc3ddaf93ceb8e1d15bb9fc3176653f5b738f5f3d1ee00cd7dccbe926e04 Key 5: b2898fc8130929d569c1677ee69dc5f3be57d7c4b494a6062693ce0b1c4d93d805 Initial Root Token: 19aefa97-cccc-bbbb-aaaa-225940e63d76 Vault initialized with 5 keys and a key threshold of 3. Please securely distribute the above keys. When the Vault is re-sealed, restarted, or stopped, you must provide at least 3 of these keys to unseal it again. Vault does not store the master key. Without at least 3 keys, your Vault will remain permanently sealed. Vault will initialize and return a set of unsealing keys and the root token. Pick 3 keys and unseal Vault. Store the Vault token in the VAULT_TOKEN environment variable. $ vault operator unseal (Key 1) $ vault operator unseal (Key 2) $ vault operator unseal (Key 3) $ export VAULT_TOKEN=(Root token) # Required to run Spring Cloud Vault tests after manual initialization $ vault token create -id=""00000000-0000-0000-0000-000000000000"" -policy=""root"" Spring Cloud Vault accesses different resources. By default, the secret backend is enabled which accesses secret config settings via JSON endpoints. The HTTP service has resources in the form: /secret/{application}/{profile} /secret/{application} /secret/{defaultContext}/{profile} /secret/{defaultContext} where the ""application"" is injected as the spring.application.name in the SpringApplication (i.e. what is normally ""application"" in a regular Spring Boot app), ""profile"" is an active profile (or comma-separated list of properties). Properties retrieved from Vault will be used ""as-is"" without further prefixing of the property names. Client Side Usage: To use these features in an application, just build it as a Spring Boot application that depends on spring-cloud-vault-config (e.g. see the test cases). Example Maven configuration: pom.xml <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>${springBootVersion}</version> <relativePath /> <!-- lookup parent from repository --> </parent> <dependencies> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-vault-config</artifactId> <version>4.1.3</version> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> <!-- repositories also needed for snapshots and milestones --> Then you can create a standard Spring Boot application, like this simple HTTP server: @SpringBootApplication @RestController public class Application { @RequestMapping(""/"") public String home() { return ""Hello World!""; } public static void main(String[] args) { SpringApplication.run(Application.class, args); } } When it runs it will pick up the external configuration from the default local Vault server on port 8200 if it is running. To modify the startup behavior you can change the location of the Vault server using application.properties , for example application.yml spring.cloud.vault: host: localhost port: 8200 scheme: https uri: https://localhost:8200 connection-timeout: 5000 read-timeout: 15000 spring.config.import: vault:// host sets the hostname of the Vault host. The host name will be used for SSL certificate validation port sets the Vault port scheme setting the scheme to http will use plain HTTP. Supported schemes are http and https . uri configure the Vault endpoint with an URI. Takes precedence over host/port/scheme configuration connection-timeout sets the connection timeout in milliseconds read-timeout sets the read timeout in milliseconds spring.config.import mounts Vault as PropertySource using all enabled secret backends (key-value enabled by default) Enabling further integrations requires additional dependencies and configuration. Depending on how you have set up Vault you might need additional configuration like SSL(advanced-topics.html#vault.config.ssl) and authentication(authentication.html#vault.config.authentication) . If the application imports the spring-boot-starter-actuator project, the status of the vault server will be available via the /health endpoint. The vault health indicator can be enabled or disabled through the property management.health.vault.enabled (default to true ). With Spring Cloud Vault 3.0 and Spring Boot 2.4, the bootstrap context initialization ( bootstrap.yml , bootstrap.properties ) of property sources was deprecated. Instead, Spring Cloud Vault favors Spring Boot’s Config Data API which allows importing configuration from Vault. With Spring Boot Config Data approach, you need to set the spring.config.import property in order to bind to Vault. You can read more about it in the Config Data Locations section(config-data.html#vault.configdata.locations) . You can enable the bootstrap context either by setting the configuration property spring.cloud.bootstrap.enabled=true or by including the dependency org.springframework.cloud:spring-cloud-starter-bootstrap . Authentication: Vault requires an authentication mechanism(https://www.vaultproject.io/docs/concepts/auth.html) to authorize client requests(https://www.vaultproject.io/docs/concepts/tokens.html) . Spring Cloud Vault supports multiple authentication mechanisms(authentication.html) to authenticate applications with Vault. For a quickstart, use the root token printed by the Vault initialization(#quickstart.vault.start) . application.yml spring.cloud.vault: token: 19aefa97-cccc-bbbb-aaaa-225940e63d76 spring.config.import: vault:// Consider carefully your security requirements. Static token authentication is fine if you want quickly get started with Vault, but a static token is not protected any further. Any disclosure to unintended parties allows Vault use with the associated token roles."
"https://docs.spring.io/spring-cloud-vault/reference/config-data.html","ConfigData API: Spring Boot provides since version 2.4 a ConfigData API that allows the declaration of configuration sources and importing these as property sources. Spring Cloud Vault uses as of version 3.0 the ConfigData API to mount Vault’s secret backends as property sources. In previous versions, the Bootstrap context was used. The ConfigData API is much more flexible as it allows specifying which configuration systems to import and in which order. You can enable the bootstrap context either by setting the configuration property spring.cloud.bootstrap.enabled=true or by including the dependency org.springframework.cloud:spring-cloud-starter-bootstrap . Using the boostrap context should be only rarely required hence we recommend using the Config Data API for more flexibility regarding property source ordering. ConfigData Locations: You can mount Vault configuration through one or more PropertySource that are materialized from Vault. Spring Cloud Vault supports two config locations: vault:// (default location) vault:///<context-path> (contextual location) Using the default location mounts property sources for all enabled Secret Backends(secret-backends.html) . Without further configuration, Spring Cloud Vault mounts the key-value backend at /secret/${spring.application.name} . Each activated profile adds another context path following the form /secret/$\{spring.application.name}/${profile} . Adding further modules to the classpath, such as spring-cloud-config-databases , provides additional secret backend configuration options which get mounted as property sources if enabled. If you want to control which context paths are mounted from Vault as PropertySource , you can either use a contextual location ( vault:///my/context/path ) or configure a VaultConfigurer(secret-backends.html#vault.config.backends.configurer) . Contextual locations are specified and mounted individually. Spring Cloud Vault mounts each location as a unique PropertySource . You can mix the default locations with contextual locations (or other config systems) to control the order of property sources. This approach is useful in particular if you want to disable the default key-value path computation and mount each key-value backend yourself instead. application.yml spring.config.import: vault://first/context/path, vault://other/path, vault:// Property names within a Spring Environment must be unique to avoid shadowing. If you use the same secret names in different context paths and you want to expose these as individual properties you can distinguish them by adding a prefix query parameter to the location. Example 1. application.yml spring.config.import: vault://my/path?prefix=foo., vault://my/other/path?prefix=bar. secret: ${foo.secret} other.secret: ${bar.secret} Prefixes are added as-is to all property names returned by Vault. If you want key names to be separated with a dot between the prefix and key name, make sure to add a trailing dot to the prefix. Conditionally enable/disable Vault Configuration: In some cases, it can be required to launch an application without Vault. You can express whether a Vault config location should be optional or mandatory (default) through the location string: optional:vault:// (default location) optional:vault:///<context-path> (contextual location) Optional locations are skipped during application startup if Vault support was disabled through spring.cloud.vault.enabled=false . Vault context paths that cannot be found (HTTP Status 404) are skipped regardless of whether the config location is marked optional. Vault Client Fail Fast(advanced-topics.html#vault.config.fail-fast) allows failing on start if a Vault context path cannot be found because of HTTP Status 404. Infrastructure Customization: Spring Cloud Vault requires infrastructure classes to interact with Vault. When not using the ConfigData API (meaning that you haven’t specified spring.config.import=vault:// or a contextual Vault path), Spring Cloud Vault defines its beans through VaultAutoConfiguration and VaultReactiveAutoConfiguration . Spring Boot bootstraps the application before a Spring Context is available. Therefore VaultConfigDataLoader registers beans itself to propagate these later on into the application context. You can customize the infrastructure used by Spring Cloud Vault by registering custom instances using the Bootstrapper API: Customizing ClientHttpRequestFactory ClientOptions options = new ClientOptions(); SslConfiguration sslConfiguration = SslConfiguration.unconfigured(); HttpClientBuilder builder = HttpComponents.getHttpClientBuilder(options, sslConfiguration); InstanceSupplier<ClientFactoryWrapper> supplier = context -> new ClientFactoryWrapper(new HttpComponentsClientHttpRequestFactory(builder.build())); SpringApplication application = new SpringApplication(MyApplication.class); application.addBootstrapRegistryInitializer(registry -> registry.register(ClientFactoryWrapper.class, supplier)); Customizing RestTemplateBuilder InstanceSupplier<RestTemplateBuilder> supplier = context -> { return RestTemplateBuilder .builder() .requestFactory(context.get(ClientFactoryWrapper.class).getClientHttpRequestFactory()) .defaultHeader(""X-Vault-Namespace"", ""my-namespace""); }; SpringApplication application = new SpringApplication(MyApplication.class); application.addBootstrapRegistryInitializer(registry -> registry.register(RestTemplateBuilder.class, supplier)); See also Customize which secret backends to expose as PropertySource(secret-backends.html#vault.config.backends.configurer) and the source of VaultConfigDataLoader for customization hooks."
"https://docs.spring.io/spring-cloud-vault/reference/authentication.html","Authentication methods: Different organizations have different requirements for security and authentication. Vault reflects that need by shipping multiple authentication methods. Spring Cloud Vault supports token and AppId authentication. Token authentication: Tokens are the core method for authentication within Vault. Token authentication requires a static token to be provided using the configuration. As a fallback, the token may also be retrieved from ~/.vault-token which is the default location used by the Vault CLI to cache tokens. Token authentication is the default authentication method. If a token is disclosed an unintended party gains access to Vault and can access secrets for the intended client. application.yml spring.cloud.vault: authentication: TOKEN token: 00000000-0000-0000-0000-000000000000 authentication setting this value to TOKEN selects the Token authentication method token sets the static token to use. If missing or empty, then an attempt will be made to retrieve a token from ~/.vault-token. See also: Vault Documentation: Tokens(https://www.vaultproject.io/docs/concepts/tokens.html) Vault Documentation: CLI login(https://www.vaultproject.io/docs/commands/login) Vault Documentation: CLI default to ~/.vault-token(https://www.vaultproject.io/docs/commands/token-helper) Vault Agent authentication: Vault ships a sidecar utility with Vault Agent since version 0.11.0. Vault Agent implements the functionality of Spring Vault’s SessionManager with its Auto-Auth feature. Applications can reuse cached session credentials by relying on Vault Agent running on localhost . Spring Vault can send requests without the X-Vault-Token header. Disable Spring Vault’s authentication infrastructure to disable client authentication and session management. application.yml spring.cloud.vault: authentication: NONE authentication setting this value to NONE disables ClientAuthentication and SessionManager . See also: Vault Documentation: Agent(https://www.vaultproject.io/docs/agent/index.html) AppId authentication: Vault supports AppId(https://www.vaultproject.io/docs/auth/app-id.html) authentication that consists of two hard to guess tokens. The AppId defaults to spring.application.name that is statically configured. The second token is the UserId which is a part determined by the application, usually related to the runtime environment. IP address, Mac address or a Docker container name are good examples. Spring Cloud Vault Config supports IP address, Mac address and static UserId’s (e.g. supplied via System properties). The IP and Mac address are represented as Hex-encoded SHA256 hash. IP address-based UserId’s use the local host’s IP address. application.yml using SHA256 IP-Address UserId’s spring.cloud.vault: authentication: APPID app-id: user-id: IP_ADDRESS authentication setting this value to APPID selects the AppId authentication method app-id-path sets the path of the AppId mount to use user-id sets the UserId method. Possible values are IP_ADDRESS , MAC_ADDRESS or a class name implementing a custom AppIdUserIdMechanism The corresponding command to generate the IP address UserId from a command line is: $ echo -n 192.168.99.1 | sha256sum Including the line break of echo leads to a different hash value so make sure to include the -n flag. Mac address-based UserId’s obtain their network device from the localhost-bound device. The configuration also allows specifying a network-interface hint to pick the right device. The value of network-interface is optional and can be either an interface name or interface index (0-based). application.yml using SHA256 Mac-Address UserId’s spring.cloud.vault: authentication: APPID app-id: user-id: MAC_ADDRESS network-interface: eth0 network-interface sets network interface to obtain the physical address The corresponding command to generate the IP address UserId from a command line is: $ echo -n 0AFEDE1234AC | sha256sum The Mac address is specified uppercase and without colons. Including the line break of echo leads to a different hash value so make sure to include the -n flag. Custom UserId: The UserId generation is an open mechanism. You can set spring.cloud.vault.app-id.user-id to any string and the configured value will be used as static UserId. A more advanced approach lets you set spring.cloud.vault.app-id.user-id to a classname. This class must be on your classpath and must implement the org.springframework.cloud.vault.AppIdUserIdMechanism interface and the createUserId method. Spring Cloud Vault will obtain the UserId by calling createUserId each time it authenticates using AppId to obtain a token. application.yml spring.cloud.vault: authentication: APPID app-id: user-id: com.examlple.MyUserIdMechanism MyUserIdMechanism.java public class MyUserIdMechanism implements AppIdUserIdMechanism { @Override public String createUserId() { String userId = ... return userId; } } See also: Vault Documentation: Using the App ID auth backend(https://www.vaultproject.io/docs/auth/app-id.html) AppRole authentication: AppRole(https://www.vaultproject.io/docs/auth/app-id.html) is intended for machine authentication, like the deprecated (since Vault 0.6.1) AppId authentication(#vault.config.authentication.appid) . AppRole authentication consists of two hard to guess (secret) tokens: RoleId and SecretId. Spring Vault supports various AppRole scenarios (push/pull mode and wrapped). RoleId and optionally SecretId must be provided by configuration, Spring Vault will not look up these or create a custom SecretId. application.yml with AppRole authentication properties spring.cloud.vault: authentication: APPROLE app-role: role-id: bde2076b-cccb-3cf0-d57e-bca7b1e83a52 The following scenarios are supported along the required configuration details: Table 1. Configuration Method RoleId SecretId RoleName Token Provided RoleId/SecretId Provided Provided Provided RoleId without SecretId Provided Provided RoleId, Pull SecretId Provided Provided Provided Pull RoleId, provided SecretId Provided Provided Provided Full Pull Mode Provided Provided Wrapped Provided Wrapped RoleId, provided SecretId Provided Provided Provided RoleId, wrapped SecretId Provided Provided Table 2. Pull/Push/Wrapped Matrix RoleId SecretId Supported Provided Provided ✅ Provided Pull ✅ Provided Wrapped ✅ Provided Absent ✅ Pull Provided ✅ Pull Pull ✅ Pull Wrapped ❌ Pull Absent ❌ Wrapped Provided ✅ Wrapped Pull ❌ Wrapped Wrapped ✅ Wrapped Absent ❌ You can use still all combinations of push/pull/wrapped modes by providing a configured AppRoleAuthentication bean within the context. Spring Cloud Vault cannot derive all possible AppRole combinations from the configuration properties. AppRole authentication is limited to simple pull mode using reactive infrastructure. Full pull mode is not yet supported. Using Spring Cloud Vault with the Spring WebFlux stack enables Vault’s reactive auto-configuration which can be disabled by setting spring.cloud.vault.reactive.enabled=false . application.yml with all AppRole authentication properties spring.cloud.vault: authentication: APPROLE app-role: role-id: bde2076b-cccb-3cf0-d57e-bca7b1e83a52 secret-id: 1696536f-1976-73b1-b241-0b4213908d39 role: my-role app-role-path: approle role-id sets the RoleId. secret-id sets the SecretId. SecretId can be omitted if AppRole is configured without requiring SecretId (See bind_secret_id ). role : sets the AppRole name for pull mode. app-role-path sets the path of the approle authentication mount to use. See also: Vault Documentation: Using the AppRole auth backend(https://www.vaultproject.io/docs/auth/approle.html) AWS-EC2 authentication: The aws-ec2(https://www.vaultproject.io/docs/auth/aws-ec2.html) auth backend provides a secure introduction mechanism for AWS EC2 instances, allowing automated retrieval of a Vault token. Unlike most Vault authentication backends, this backend does not require first-deploying, or provisioning security-sensitive credentials (tokens, username/password, client certificates, etc.). Instead, it treats AWS as a Trusted Third Party and uses the cryptographically signed dynamic metadata information that uniquely represents each EC2 instance. application.yml using AWS-EC2 Authentication spring.cloud.vault: authentication: AWS_EC2 AWS-EC2 authentication enables nonce by default to follow the Trust On First Use (TOFU) principle. Any unintended party that gains access to the PKCS#7 identity metadata can authenticate against Vault. During the first login, Spring Cloud Vault generates a nonce that is stored in the auth backend aside the instance Id. Re-authentication requires the same nonce to be sent. Any other party does not have the nonce and can raise an alert in Vault for further investigation. The nonce is kept in memory and is lost during application restart. You can configure a static nonce with spring.cloud.vault.aws-ec2.nonce . AWS-EC2 authentication roles are optional and default to the AMI. You can configure the authentication role by setting the spring.cloud.vault.aws-ec2.role property. application.yml with configured role spring.cloud.vault: authentication: AWS_EC2 aws-ec2: role: application-server application.yml with all AWS EC2 authentication properties spring.cloud.vault: authentication: AWS_EC2 aws-ec2: role: application-server aws-ec2-path: aws-ec2 identity-document: http://... nonce: my-static-nonce authentication setting this value to AWS_EC2 selects the AWS EC2 authentication method role sets the name of the role against which the login is being attempted. aws-ec2-path sets the path of the AWS EC2 mount to use identity-document sets URL of the PKCS#7 AWS EC2 identity document nonce used for AWS-EC2 authentication. An empty nonce defaults to nonce generation See also: Vault Documentation: Using the aws auth backend(https://www.vaultproject.io/docs/auth/aws.html) AWS-IAM authentication: The aws(https://www.vaultproject.io/docs/auth/aws-ec2.html) backend provides a secure authentication mechanism for AWS IAM roles, allowing the automatic authentication with vault based on the current IAM role of the running application. Unlike most Vault authentication backends, this backend does not require first-deploying, or provisioning security-sensitive credentials (tokens, username/password, client certificates, etc.). Instead, it treats AWS as a Trusted Third Party and uses the 4 pieces of information signed by the caller with their IAM credentials to verify that the caller is indeed using that IAM role. The current IAM role the application is running in is automatically calculated. If you are running your application on AWS ECS then the application will use the IAM role assigned to the ECS task of the running container. If you are running your application naked on top of an EC2 instance then the IAM role used will be the one assigned to the EC2 instance. When using the AWS-IAM authentication you must create a role in Vault and assign it to your IAM role. An empty role defaults to the friendly name the current IAM role. application.yml with required AWS-IAM Authentication properties spring.cloud.vault: authentication: AWS_IAM application.yml with all AWS-IAM Authentication properties spring.cloud.vault: authentication: AWS_IAM aws-iam: region: aws-global role: my-dev-role aws-path: aws server-name: some.server.name endpoint-uri: https://sts.eu-central-1.amazonaws.com region sets the name of the AWS region. If not supplied, the region will be determined by AWS defaults. role sets the name of the role against which the login is being attempted. This should be bound to your IAM role. If one is not supplied then the friendly name of the current IAM user will be used as the vault role. aws-path sets the path of the AWS mount to use server-name sets the value to use for the X-Vault-AWS-IAM-Server-ID header preventing certain types of replay attacks. endpoint-uri sets the value to use for the AWS STS API used for the iam_request_url parameter. AWS-IAM requires the AWS Java SDK v2 dependency ( software.amazon.awssdk:auth ) as the authentication implementation uses AWS SDK types for credentials and request signing. See also: Vault Documentation: Using the aws auth backend(https://www.vaultproject.io/docs/auth/aws.html) Azure MSI authentication: The azure(https://www.vaultproject.io/docs/auth/azure.html) auth backend provides a secure introduction mechanism for Azure VM instances, allowing automated retrieval of a Vault token. Unlike most Vault authentication backends, this backend does not require first-deploying, or provisioning security-sensitive credentials (tokens, username/password, client certificates, etc.). Instead, it treats Azure as a Trusted Third Party and uses the managed service identity and instance metadata information that can be bound to a VM instance. application.yml with required Azure Authentication properties spring.cloud.vault: authentication: AZURE_MSI azure-msi: role: my-dev-role application.yml with all Azure Authentication properties spring.cloud.vault: authentication: AZURE_MSI azure-msi: role: my-dev-role azure-path: azure metadata-service: http://169.254.169.254/metadata/instance… identity-token-service: http://169.254.169.254/metadata/identity… role sets the name of the role against which the login is being attempted. azure-path sets the path of the Azure mount to use metadata-service sets the URI at which to access the instance metadata service identity-token-service sets the URI at which to access the identity token service Azure MSI authentication obtains environmental details about the virtual machine (subscription Id, resource group, VM name) from the instance metadata service. The Vault server has Resource Id defaults to vault.hashicorp.com(https://vault.hashicorp.com) . To change this, set spring.cloud.vault.azure-msi.identity-token-service accordingly. See also: Vault Documentation: Using the azure auth backend(https://www.vaultproject.io/docs/auth/azure.html) Azure Documentation: Azure Instance Metadata Service(https://docs.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service) TLS certificate authentication: The cert auth backend allows authentication using SSL/TLS client certificates that are either signed by a CA or self-signed. To enable cert authentication you need to: Use SSL, see Vault Client SSL configuration(advanced-topics.html#vault.config.ssl) Configure a Java Keystore that contains the client certificate and the private key Set the spring.cloud.vault.authentication to CERT application.yml spring.cloud.vault: authentication: CERT ssl: key-store: classpath:keystore.jks key-store-password: changeit key-store-type: JKS cert-auth-path: cert See also: Vault Documentation: Using the Cert auth backend(https://www.vaultproject.io/docs/auth/cert.html) Cubbyhole authentication: Cubbyhole authentication uses Vault primitives to provide a secured authentication workflow. Cubbyhole authentication uses tokens as primary login method. An ephemeral token is used to obtain a second, login VaultToken from Vault’s Cubbyhole secret backend. The login token is usually longer-lived and used to interact with Vault. The login token will be retrieved from a wrapped response stored at /cubbyhole/response . Creating a wrapped token Response Wrapping for token creation requires Vault 0.6.0 or higher. Creating and storing tokens $ vault token-create -wrap-ttl=""10m"" Key Value --- ----- wrapping_token: 397ccb93-ff6c-b17b-9389-380b01ca2645 wrapping_token_ttl: 0h10m0s wrapping_token_creation_time: 2016-09-18 20:29:48.652957077 +0200 CEST wrapped_accessor: 46b6aebb-187f-932a-26d7-4f3d86a68319 application.yml spring.cloud.vault: authentication: CUBBYHOLE token: 397ccb93-ff6c-b17b-9389-380b01ca2645 See also: Vault Documentation: Tokens(https://www.vaultproject.io/docs/concepts/tokens.html) Vault Documentation: Cubbyhole Secret Backend(https://www.vaultproject.io/docs/secrets/cubbyhole/index.html) Vault Documentation: Response Wrapping(https://www.vaultproject.io/docs/concepts/response-wrapping.html) GCP-GCE authentication: The gcp(https://www.vaultproject.io/docs/auth/gcp.html) auth backend allows Vault login by using existing GCP (Google Cloud Platform) IAM and GCE credentials. GCP GCE (Google Compute Engine) authentication creates a signature in the form of a JSON Web Token (JWT) for a service account. A JWT for a Compute Engine instance is obtained from the GCE metadata service using Instance identification(https://cloud.google.com/compute/docs/instances/verifying-instance-identity) . This API creates a JSON Web Token that can be used to confirm the instance identity. Unlike most Vault authentication backends, this backend does not require first-deploying, or provisioning security-sensitive credentials (tokens, username/password, client certificates, etc.). Instead, it treats GCP as a Trusted Third Party and uses the cryptographically signed dynamic metadata information that uniquely represents each GCP service account. application.yml with required GCP-GCE Authentication properties spring.cloud.vault: authentication: GCP_GCE gcp-gce: role: my-dev-role application.yml with all GCP-GCE Authentication properties spring.cloud.vault: authentication: GCP_GCE gcp-gce: gcp-path: gcp role: my-dev-role service-account: [email protected](/cdn-cgi/l/email-protection) role sets the name of the role against which the login is being attempted. gcp-path sets the path of the GCP mount to use service-account allows overriding the service account Id to a specific value. Defaults to the default service account. See also: Vault Documentation: Using the GCP auth backend(https://www.vaultproject.io/docs/auth/gcp.html) GCP Documentation: Verifying the Identity of Instances(https://cloud.google.com/compute/docs/instances/verifying-instance-identity) GCP-IAM authentication: The gcp(https://www.vaultproject.io/docs/auth/gcp.html) auth backend allows Vault login by using existing GCP (Google Cloud Platform) IAM and GCE credentials. GCP IAM authentication creates a signature in the form of a JSON Web Token (JWT) for a service account. A JWT for a service account is obtained by calling GCP IAM’s projects.serviceAccounts.signJwt(https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signJwt) API. The caller authenticates against GCP IAM and proves thereby its identity. This Vault backend treats GCP as a Trusted Third Party. IAM credentials can be obtained from either the runtime environment , specifically the GOOGLE_APPLICATION_CREDENTIALS(https://cloud.google.com/docs/authentication/production) environment variable, the Google Compute metadata service, or supplied externally as e.g. JSON or base64 encoded. JSON is the preferred form as it carries the project id and service account identifier required for calling projects.serviceAccounts.signJwt . application.yml with required GCP-IAM Authentication properties spring.cloud.vault: authentication: GCP_IAM gcp-iam: role: my-dev-role application.yml with all GCP-IAM Authentication properties spring.cloud.vault: authentication: GCP_IAM gcp-iam: credentials: location: classpath:credentials.json encoded-key: e+KApn0= gcp-path: gcp jwt-validity: 15m project-id: my-project-id role: my-dev-role service-account-id: [email protected](/cdn-cgi/l/email-protection) role sets the name of the role against which the login is being attempted. credentials.location path to the credentials resource that contains Google credentials in JSON format. credentials.encoded-key the base64 encoded contents of an OAuth2 account private key in the JSON format. gcp-path sets the path of the GCP mount to use jwt-validity configures the JWT token validity. Defaults to 15 minutes. project-id allows overriding the project Id to a specific value. Defaults to the project Id from the obtained credential. service-account allows overriding the service account Id to a specific value. Defaults to the service account from the obtained credential. GCP IAM authentication requires the Google Cloud Java SDK dependency ( com.google.apis:google-api-services-iam and com.google.auth:google-auth-library-oauth2-http ) as the authentication implementation uses Google APIs for credentials and JWT signing. Google credentials require an OAuth 2 token maintaining the token lifecycle. All API is synchronous therefore, GcpIamAuthentication does not support AuthenticationSteps which is required for reactive usage. See also: Vault Documentation: Using the GCP auth backend(https://www.vaultproject.io/docs/auth/gcp.html) GCP Documentation: projects.serviceAccounts.signJwt(https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signJwt) Kubernetes authentication: Kubernetes authentication mechanism (since Vault 0.8.3) allows to authenticate with Vault using a Kubernetes Service Account Token. The authentication is role based and the role is bound to a service account name and a namespace. A file containing a JWT token for a pod’s service account is automatically mounted at /var/run/secrets/kubernetes.io/serviceaccount/token . application.yml with all Kubernetes authentication properties spring.cloud.vault: authentication: KUBERNETES kubernetes: role: my-dev-role kubernetes-path: kubernetes service-account-token-file: /var/run/secrets/kubernetes.io/serviceaccount/token role sets the Role. kubernetes-path sets the path of the Kubernetes mount to use. service-account-token-file sets the location of the file containing the Kubernetes Service Account Token. Defaults to /var/run/secrets/kubernetes.io/serviceaccount/token . See also: Vault Documentation: Kubernetes(https://www.vaultproject.io/docs/auth/kubernetes.html) Kubernetes Documentation: Configure Service Accounts for Pods(https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) Pivotal CloudFoundry authentication: The pcf(https://www.vaultproject.io/docs/auth/pcf.html) auth backend provides a secure introduction mechanism for applications running within Pivotal’s CloudFoundry instances allowing automated retrieval of a Vault token. Unlike most Vault authentication backends, this backend does not require first-deploying, or provisioning security-sensitive credentials (tokens, username/password, client certificates, etc.) as identity provisioning is handled by PCF itself. Instead, it treats PCF as a Trusted Third Party and uses the managed instance identity. application.yml with required PCF Authentication properties spring.cloud.vault: authentication: PCF pcf: role: my-dev-role application.yml with all PCF Authentication properties spring.cloud.vault: authentication: PCF pcf: role: my-dev-role pcf-path: path instance-certificate: /etc/cf-instance-credentials/instance.crt instance-key: /etc/cf-instance-credentials/instance.key role sets the name of the role against which the login is being attempted. pcf-path sets the path of the PCF mount to use. instance-certificate sets the path to the PCF instance identity certificate. Defaults to ${CF_INSTANCE_CERT} env variable. instance-key sets the path to the PCF instance identity key. Defaults to ${CF_INSTANCE_KEY} env variable. PCF authentication requires BouncyCastle (bcpkix-jdk15on) to be on the classpath for RSA PSS signing. See also: Vault Documentation: Using the pcf auth backend(https://www.vaultproject.io/docs/auth/pcf.html) ACL Requirements: This section explains which paths are accessed by Spring Vault so you can derive your policy declarations from the required capabilities. Capability Associated HTTP verbs create POST / PUT read GET update POST / PUT delete DELETE list LIST ( GET ) See also www.vaultproject.io/guides/identity/policies(https://www.vaultproject.io/guides/identity/policies) . Authentication: Login: POST auth/$authMethod/login KeyValue Mount Discovery: GET sys/internal/ui/mounts/$mountPath SecretLeaseContainer: SecretLeaseContainer uses different paths depending on the configured lease endpoint. LeaseEndpoints.Legacy Revocation: PUT sys/revoke Renewal: PUT sys/renew LeaseEndpoints.Leases ( SysLeases ) Revocation: PUT sys/leases/revoke Renewal: PUT sys/leases/renew Session Management: Token lookup: GET auth/token/lookup-self Renewal: POST auth/token/renew-self Revoke: POST auth/token/revoke-self"
"https://docs.spring.io/spring-cloud-vault/reference/secret-backends.html","Secret Backends: Key-Value Backend: Spring Cloud Vault supports both Key-Value secret backends, the versioned (v2) and unversioned (v1). The key-value backend allows storage of arbitrary values as key-value store. A single context can store one or many key-value tuples. Contexts can be organized hierarchically. Spring Cloud Vault determines itself whether a secret is using versioning and maps the path to its appropriate URL. Spring Cloud Vault allows using the Application name, and a default context name ( application ) in combination with active profiles. /secret/{application}/{profile} /secret/{application} /secret/{default-context}/{profile} /secret/{default-context} The application name is determined by the properties: spring.cloud.vault.kv.application-name spring.cloud.vault.application-name spring.application.name The profiles are determined by the properties: spring.cloud.vault.kv.profiles spring.profiles.active Secrets can be obtained from other contexts within the key-value backend by adding their paths to the application name, separated by commas. For example, given the application name usefulapp,mysql1,projectx/aws , each of these folders will be used: /secret/usefulapp /secret/mysql1 /secret/projectx/aws Spring Cloud Vault adds all active profiles to the list of possible context paths. No active profiles will skip accessing contexts with a profile name. Properties are exposed like they are stored (i.e. without additional prefixes). Spring Cloud Vault adds the data/ context between the mount path and the actual context path depending on whether the mount uses the versioned key-value backend. spring.cloud.vault: kv: enabled: true backend: secret profile-separator: '/' default-context: application application-name: my-app profiles: local, cloud enabled setting this value to false disables the secret backend config usage backend sets the path of the secret mount to use default-context sets the context name used by all applications application-name overrides the application name for use in the key-value backend profiles overrides the active profiles for use in the key-value backend profile-separator separates the profile name from the context in property sources with profiles The key-value secret backend can be operated in versioned (v2) and non-versioned (v1) modes. See also: Vault Documentation: Using the KV Secrets Engine - Version 1 (generic secret backend)(https://www.vaultproject.io/docs/secrets/kv/kv-v1.html) Vault Documentation: Using the KV Secrets Engine - Version 2 (versioned key-value backend)(https://www.vaultproject.io/docs/secrets/kv/kv-v2.html) Consul: Spring Cloud Vault can obtain credentials for HashiCorp Consul. The Consul integration requires the spring-cloud-vault-config-consul dependency. pom.xml <dependencies> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-vault-config-consul</artifactId> <version>4.1.3</version> </dependency> </dependencies> The integration can be enabled by setting spring.cloud.vault.consul.enabled=true (default false ) and providing the role name with spring.cloud.vault.consul.role=… . The obtained token is stored in spring.cloud.consul.token so using Spring Cloud Consul can pick up the generated credentials without further configuration. You can configure the property name by setting spring.cloud.vault.consul.token-property . spring.cloud.vault: consul: enabled: true role: readonly backend: consul token-property: spring.cloud.consul.token enabled setting this value to true enables the Consul backend config usage role sets the role name of the Consul role definition backend sets the path of the Consul mount to use token-property sets the property name in which the Consul ACL token is stored See also: Vault Documentation: Setting up Consul with Vault(https://www.vaultproject.io/docs/secrets/consul/index.html) RabbitMQ: Spring Cloud Vault can obtain credentials for RabbitMQ. The RabbitMQ integration requires the spring-cloud-vault-config-rabbitmq dependency. pom.xml <dependencies> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-vault-config-rabbitmq</artifactId> <version>4.1.3</version> </dependency> </dependencies> The integration can be enabled by setting spring.cloud.vault.rabbitmq.enabled=true (default false ) and providing the role name with spring.cloud.vault.rabbitmq.role=… . Username and password are stored in spring.rabbitmq.username and spring.rabbitmq.password so using Spring Boot will pick up the generated credentials without further configuration. You can configure the property names by setting spring.cloud.vault.rabbitmq.username-property and spring.cloud.vault.rabbitmq.password-property . spring.cloud.vault: rabbitmq: enabled: true role: readonly backend: rabbitmq username-property: spring.rabbitmq.username password-property: spring.rabbitmq.password enabled setting this value to true enables the RabbitMQ backend config usage role sets the role name of the RabbitMQ role definition backend sets the path of the RabbitMQ mount to use username-property sets the property name in which the RabbitMQ username is stored password-property sets the property name in which the RabbitMQ password is stored See also: Vault Documentation: Setting up RabbitMQ with Vault(https://www.vaultproject.io/docs/secrets/rabbitmq/index.html) AWS: Spring Cloud Vault can obtain credentials for AWS. The AWS integration requires the spring-cloud-vault-config-aws dependency. pom.xml <dependencies> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-vault-config-aws</artifactId> <version>4.1.3</version> </dependency> </dependencies> The integration can be enabled by setting spring.cloud.vault.aws=true (default false ) and providing the role name with spring.cloud.vault.aws.role=… . Supported AWS credential Types: iam_user (Defaults) assumed_role (STS) federation_token (STS) The access key and secret key are stored in cloud.aws.credentials.accessKey and cloud.aws.credentials.secretKey . So using Spring Cloud AWS will pick up the generated credentials without further configuration. You can configure the property names by setting spring.cloud.vault.aws.access-key-property and spring.cloud.vault.aws.secret-key-property . For STS security token, you can configure the property name by setting spring.cloud.vault.aws.session-token-key-property . The security token is stored under cloud.aws.credentials.sessionToken (defaults). Example: iam_user spring.cloud.vault: aws: enabled: true role: readonly backend: aws access-key-property: cloud.aws.credentials.accessKey secret-key-property: cloud.aws.credentials.secretKey Example: assumed_role (STS) spring.cloud.vault: aws: enabled: true role: sts-vault-role backend: aws credential-type: assumed_role access-key-property: cloud.aws.credentials.accessKey secret-key-property: cloud.aws.credentials.secretKey session-token-key-property: cloud.aws.credentials.sessionToken ttl: 3600s role-arn: arn:aws:iam::${AWS_ACCOUNT}:role/sts-app-role enabled setting this value to true enables the AWS backend config usage role sets the role name of the AWS role definition backend sets the path of the AWS mount to use access-key-property sets the property name in which the AWS access key is stored secret-key-property sets the property name in which the AWS secret key is stored session-token-key-property sets the property name in which the AWS STS security token is stored. credential-type sets the aws credential type to use for this backend. Defaults to iam_user ttl sets the ttl for the STS token when using assumed_role or federation_token . Defaults to the ttl specified by the vault role. Min/Max values are also limited to what AWS would support for STS. role-arn sets the IAM role to assume if more than one are configured for the vault role when using assumed_role . See also: Vault Documentation: Setting up AWS with Vault(https://www.vaultproject.io/docs/secrets/aws/index.html) Database backends: Vault supports several database secret backends to generate database credentials dynamically based on configured roles. This means services that need to access a database no longer need to configure credentials: they can request them from Vault, and use Vault’s leasing mechanism to more easily roll keys. Spring Cloud Vault integrates with these backends: Database(#vault.config.backends.database) Apache Cassandra(#vault.config.backends.cassandra) Couchbase Database(#vault.config.backends.couchbase) Elasticsearch(#vault.config.backends.elasticsearch) MongoDB(#vault.config.backends.mongodb) MySQL(#vault.config.backends.mysql) PostgreSQL(#vault.config.backends.postgresql) Using a database secret backend requires to enable the backend in the configuration and the spring-cloud-vault-config-databases dependency. Vault ships since 0.7.1 with a dedicated database secret backend that allows database integration via plugins. You can use that specific backend by using the generic database backend. Make sure to specify the appropriate backend path, e.g. spring.cloud.vault.mysql.role.backend=database . pom.xml <dependencies> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-vault-config-databases</artifactId> <version>4.1.3</version> </dependency> </dependencies> Enabling multiple JDBC-compliant databases will generate credentials and store them by default in the same property keys hence property names for JDBC secrets need to be configured separately. Database: Spring Cloud Vault can obtain credentials for any database listed at www.vaultproject.io/api/secret/databases/index.html(https://www.vaultproject.io/api/secret/databases/index.html) . The integration can be enabled by setting spring.cloud.vault.database.enabled=true (default false ) and providing the role name with spring.cloud.vault.database.role=… . While the database backend is a generic one, spring.cloud.vault.database specifically targets JDBC databases. Username and password are available from spring.datasource.username and spring.datasource.password properties so using Spring Boot will pick up the generated credentials for your DataSource without further configuration. You can configure the property names by setting spring.cloud.vault.database.username-property and spring.cloud.vault.database.password-property . spring.cloud.vault: database: enabled: true role: readonly backend: database username-property: spring.datasource.username password-property: spring.datasource.password Multiple Databases: Sometimes, credentials for a single database isn’t sufficient because an application might connect to two or more databases of the same kind. Beginning with version 3.0.5, Spring Vault supports the configuration of multiple database secret backends under the spring.cloud.vault.databases.* namespace. The configuration accepts multiple database backends to materialize credentials into the specified properties. Make sure to configure username-property and password-property appropriately. spring.cloud.vault: databases: primary: enabled: true role: readwrite backend: database username-property: spring.primary-datasource.username password-property: spring.primary-datasource.password other-database: enabled: true role: readonly backend: database username-property: spring.secondary-datasource.username password-property: spring.secondary-datasource.password <name> descriptive name of the database configuration. <name>.enabled setting this value to true enables the Database backend config usage <name>.role sets the role name of the Database role definition <name>.backend sets the path of the Database mount to use <name>.username-property sets the property name in which the Database username is stored. Make sure to use unique property names to avoid property shadowing. <name>.password-property sets the property name in which the Database password is stored Make sure to use unique property names to avoid property shadowing. See also: Vault Documentation: Database Secrets backend(https://www.vaultproject.io/docs/secrets/databases/index.html) Spring Cloud Vault does not support getting new credentials and configuring your DataSource with them when the maximum lease time has been reached. That is, if max_ttl of the Database role in Vault is set to 24h that means that 24 hours after your application has started it can no longer authenticate with the database. Apache Cassandra: The cassandra backend has been deprecated in Vault 0.7.1 and it is recommended to use the database backend and mount it as cassandra . Spring Cloud Vault can obtain credentials for Apache Cassandra. The integration can be enabled by setting spring.cloud.vault.cassandra.enabled=true (default false ) and providing the role name with spring.cloud.vault.cassandra.role=… . Username and password are available from spring.data.cassandra.username and spring.data.cassandra.password properties so using Spring Boot will pick up the generated credentials without further configuration. You can configure the property names by setting spring.cloud.vault.cassandra.username-property and spring.cloud.vault.cassandra.password-property . spring.cloud.vault: cassandra: enabled: true role: readonly backend: cassandra username-property: spring.data.cassandra.username password-property: spring.data.cassandra.password enabled setting this value to true enables the Cassandra backend config usage role sets the role name of the Cassandra role definition backend sets the path of the Cassandra mount to use username-property sets the property name in which the Cassandra username is stored password-property sets the property name in which the Cassandra password is stored See also: Vault Documentation: Setting up Apache Cassandra with Vault(https://www.vaultproject.io/docs/secrets/cassandra/index.html) Couchbase Database: Spring Cloud Vault can obtain credentials for Couchbase. The integration can be enabled by setting spring.cloud.vault.couchbase.enabled=true (default false ) and providing the role name with spring.cloud.vault.couchbase.role=… . Username and password are available from spring.couchbase.username and spring.couchbase.password properties so using Spring Boot will pick up the generated credentials without further configuration. You can configure the property names by setting spring.cloud.vault.couchbase.username-property and spring.cloud.vault.couchbase.password-property . spring.cloud.vault: couchbase: enabled: true role: readonly backend: database username-property: spring.couchbase.username password-property: spring.couchbase.password enabled setting this value to true enables the Couchbase backend config usage role sets the role name of the Couchbase role definition backend sets the path of the Couchbase mount to use username-property sets the property name in which the Couchbase username is stored password-property sets the property name in which the Couchbase password is stored See also: Couchbase Database Plugin Documentation(https://github.com/hashicorp/vault-plugin-database-couchbase) Elasticsearch: Spring Cloud Vault can obtain since version 3.0 credentials for Elasticsearch. The integration can be enabled by setting spring.cloud.vault.elasticsearch.enabled=true (default false ) and providing the role name with spring.cloud.vault.elasticsearch.role=… . Username and password are available from spring.elasticsearch.rest.username and spring.elasticsearch.rest.password properties so using Spring Boot will pick up the generated credentials without further configuration. You can configure the property names by setting spring.cloud.vault.elasticsearch.username-property and spring.cloud.vault.elasticsearch.password-property . spring.cloud.vault: elasticsearch: enabled: true role: readonly backend: mongodb username-property: spring.elasticsearch.rest.username password-property: spring.elasticsearch.rest.password enabled setting this value to true enables the Elasticsearch database backend config usage role sets the role name of the Elasticsearch role definition backend sets the path of the Elasticsearch mount to use username-property sets the property name in which the Elasticsearch username is stored password-property sets the property name in which the Elasticsearch password is stored See also: Vault Documentation: Setting up Elasticsearch with Vault(https://www.vaultproject.io/docs/secrets/databases/elasticdb) MongoDB: The mongodb backend has been deprecated in Vault 0.7.1 and it is recommended to use the database backend and mount it as mongodb . Spring Cloud Vault can obtain credentials for MongoDB. The integration can be enabled by setting spring.cloud.vault.mongodb.enabled=true (default false ) and providing the role name with spring.cloud.vault.mongodb.role=… . Username and password are stored in spring.data.mongodb.username and spring.data.mongodb.password so using Spring Boot will pick up the generated credentials without further configuration. You can configure the property names by setting spring.cloud.vault.mongodb.username-property and spring.cloud.vault.mongodb.password-property . spring.cloud.vault: mongodb: enabled: true role: readonly backend: mongodb username-property: spring.data.mongodb.username password-property: spring.data.mongodb.password enabled setting this value to true enables the MongodB backend config usage role sets the role name of the MongoDB role definition backend sets the path of the MongoDB mount to use username-property sets the property name in which the MongoDB username is stored password-property sets the property name in which the MongoDB password is stored See also: Vault Documentation: Setting up MongoDB with Vault(https://www.vaultproject.io/docs/secrets/mongodb/index.html) MySQL: The mysql backend has been deprecated in Vault 0.7.1 and it is recommended to use the database backend and mount it as mysql . Configuration for spring.cloud.vault.mysql will be removed in a future version. Spring Cloud Vault can obtain credentials for MySQL. The integration can be enabled by setting spring.cloud.vault.mysql.enabled=true (default false ) and providing the role name with spring.cloud.vault.mysql.role=… . Username and password are available from spring.datasource.username and spring.datasource.password properties so using Spring Boot will pick up the generated credentials without further configuration. You can configure the property names by setting spring.cloud.vault.mysql.username-property and spring.cloud.vault.mysql.password-property . spring.cloud.vault: mysql: enabled: true role: readonly backend: mysql username-property: spring.datasource.username password-property: spring.datasource.password enabled setting this value to true enables the MySQL backend config usage role sets the role name of the MySQL role definition backend sets the path of the MySQL mount to use username-property sets the property name in which the MySQL username is stored password-property sets the property name in which the MySQL password is stored See also: Vault Documentation: Setting up MySQL with Vault(https://www.vaultproject.io/docs/secrets/mysql/index.html) PostgreSQL: The postgresql backend has been deprecated in Vault 0.7.1 and it is recommended to use the database backend and mount it as postgresql . Configuration for spring.cloud.vault.postgresql will be removed in a future version. Spring Cloud Vault can obtain credentials for PostgreSQL. The integration can be enabled by setting spring.cloud.vault.postgresql.enabled=true (default false ) and providing the role name with spring.cloud.vault.postgresql.role=… . Username and password are available from spring.datasource.username and spring.datasource.password properties so using Spring Boot will pick up the generated credentials without further configuration. You can configure the property names by setting spring.cloud.vault.postgresql.username-property and spring.cloud.vault.postgresql.password-property . spring.cloud.vault: postgresql: enabled: true role: readonly backend: postgresql username-property: spring.datasource.username password-property: spring.datasource.password enabled setting this value to true enables the PostgreSQL backend config usage role sets the role name of the PostgreSQL role definition backend sets the path of the PostgreSQL mount to use username-property sets the property name in which the PostgreSQL username is stored password-property sets the property name in which the PostgreSQL password is stored See also: Vault Documentation: Setting up PostgreSQL with Vault(https://www.vaultproject.io/docs/secrets/postgresql/index.html) Customize which secret backends to expose as PropertySource: Spring Cloud Vault uses property-based configuration to create PropertySource s for key-value and discovered secret backends. Discovered backends provide VaultSecretBackendDescriptor beans to describe the configuration state to use secret backend as PropertySource . A SecretBackendMetadataFactory is required to create a SecretBackendMetadata object which contains path, name and property transformation configuration. SecretBackendMetadata is used to back a particular PropertySource . You can register a VaultConfigurer for customization. Default key-value and discovered backend registration is disabled if you provide a VaultConfigurer . You can however enable default registration with SecretBackendConfigurer.registerDefaultKeyValueSecretBackends() and SecretBackendConfigurer.registerDefaultDiscoveredSecretBackends() . public class CustomizationBean implements VaultConfigurer { @Override public void addSecretBackends(SecretBackendConfigurer configurer) { configurer.add(""secret/my-application""); configurer.registerDefaultKeyValueSecretBackends(false); configurer.registerDefaultDiscoveredSecretBackends(true); } } SpringApplication application = new SpringApplication(MyApplication.class); application.addBootstrapper(VaultBootstrapper.fromConfigurer(new CustomizationBean())); Custom Secret Backend Implementations: Spring Cloud Vault ships with secret backend support for the most common backend integrations. You can integrate with any kind of backend by providing an implementation that describes how to obtain data from the backend you want to use and how to surface data provided by that backend by providing a PropertyTransformer . Adding a custom implementation for a backend requires implementation of two interfaces: org.springframework.cloud.vault.config.VaultSecretBackendDescriptor org.springframework.cloud.vault.config.SecretBackendMetadataFactory VaultSecretBackendDescriptor is typically an object that holds configuration data, such as VaultDatabaseProperties . Spring Cloud Vault requires that your type is annotated with @ConfigurationProperties to materialize the class from the configuration. SecretBackendMetadataFactory accepts VaultSecretBackendDescriptor to create the actual SecretBackendMetadata object which holds the context path within your Vault server, any path variables required to resolve parametrized context paths and PropertyTransformer . Both, VaultSecretBackendDescriptor and SecretBackendMetadataFactory types must be registered in spring.factories which is an extension mechanism provided by Spring, similar to Java’s ServiceLoader."
"https://docs.spring.io/spring-cloud-vault/reference/advanced-topics.html","Service Registry Configuration: You can use a DiscoveryClient (such as from Spring Cloud Consul) to locate a Vault server by setting spring.cloud.vault.discovery.enabled=true (default false ). The net result of that is that your apps need a application.yml (or an environment variable) with the appropriate discovery configuration. The benefit is that the Vault can change its co-ordinates, as long as the discovery service is a fixed point. The default service id is vault but you can change that on the client with spring.cloud.vault.discovery.serviceId . The discovery client implementations all support some kind of metadata map (e.g. for Eureka we have eureka.instance.metadataMap). Some additional properties of the service may need to be configured in its service registration metadata so that clients can connect correctly. Service registries that do not provide details about transport layer security need to provide a scheme metadata entry to be set either to https or http . If no scheme is configured and the service is not exposed as secure service, then configuration defaults to spring.cloud.vault.scheme which is https when it’s not set. spring.cloud.vault.discovery: enabled: true service-id: my-vault-service Vault Client Fail Fast: In some cases, it may be desirable to fail startup of a service if it cannot connect to the Vault Server. If this is the desired behavior, set the bootstrap configuration property spring.cloud.vault.fail-fast=true and the client will halt with an Exception. spring.cloud.vault: fail-fast: true Vault Enterprise Namespace Support: Vault Enterprise allows using namespaces to isolate multiple Vaults on a single Vault server. Configuring a namespace by setting spring.cloud.vault.namespace=… enables the namespace header X-Vault-Namespace on every outgoing HTTP request when using the Vault RestTemplate or WebClient . Please note that this feature is not supported by Vault Community edition and has no effect on Vault operations. spring.cloud.vault: namespace: my-namespace See also: Vault Enterprise: Namespaces(https://www.vaultproject.io/docs/enterprise/namespaces/index.html) Vault Client SSL configuration: SSL can be configured declaratively by setting various properties. You can set either javax.net.ssl.trustStore to configure JVM-wide SSL settings or spring.cloud.vault.ssl.trust-store to set SSL settings only for Spring Cloud Vault Config. spring.cloud.vault: ssl: trust-store: classpath:keystore.jks trust-store-password: changeit trust-store-type: JKS enabled-protocols: TLSv1.2,TLSv1.3 enabled-cipher-suites: TLS_AES_128_GCM_SHA256 trust-store sets the resource for the trust-store. SSL-secured Vault communication will validate the Vault SSL certificate with the specified trust-store. trust-store-password sets the trust-store password trust-store-type sets the trust-store type. Supported values are all supported KeyStore types including PEM . enabled-protocols sets the list of enabled SSL/TLS protocols (since 3.0.2). enabled-cipher-suites sets the list of enabled SSL/TLS cipher suites (since 3.0.2). Please note that configuring spring.cloud.vault.ssl.* can be only applied when either Apache Http Components or the OkHttp client is on your class-path. Lease lifecycle management (renewal and revocation): With every secret, Vault creates a lease: metadata containing information such as a time duration, renewability, and more. Vault promises that the data will be valid for the given duration, or Time To Live (TTL). Once the lease is expired, Vault can revoke the data, and the consumer of the secret can no longer be certain that it is valid. Spring Cloud Vault maintains a lease lifecycle beyond the creation of login tokens and secrets. That said, login tokens and secrets associated with a lease are scheduled for renewal just before the lease expires until terminal expiry. Application shutdown revokes obtained login tokens and renewable leases. Secret service and database backends (such as MongoDB or MySQL) usually generate a renewable lease so generated credentials will be disabled on application shutdown. Static tokens are not renewed or revoked. Lease renewal and revocation is enabled by default and can be disabled by setting spring.cloud.vault.config.lifecycle.enabled to false . This is not recommended as leases can expire and Spring Cloud Vault cannot longer access Vault or services using generated credentials and valid credentials remain active after application shutdown. spring.cloud.vault: config.lifecycle: enabled: true min-renewal: 10s expiry-threshold: 1m lease-endpoints: Legacy enabled controls whether leases associated with secrets are considered to be renewed and expired secrets are rotated. Enabled by default. min-renewal sets the duration that is at least required before renewing a lease. This setting prevents renewals from happening too often. expiry-threshold sets the expiry threshold. A lease is renewed the configured period of time before it expires. lease-endpoints sets the endpoints for renew and revoke. Legacy for vault versions before 0.8 and SysLeases for later. lease-strategy sets the LeaseStrategy ( DropOnError , RetainOnError , RetainOnIoError ) to control error handling on lease renewal. See also: Vault Documentation: Lease, Renew, and Revoke(https://www.vaultproject.io/docs/concepts/lease.html) Session token lifecycle management (renewal, re-login and revocation): A Vault session token (also referred to as LoginToken ) is quite similar to a lease as it has a TTL, max TTL, and may expire. Once a login token expires, it cannot be used anymore to interact with Vault. Therefore, Spring Vault ships with a SessionManager API for imperative and reactive use. Spring Cloud Vault maintains the session token lifecycle by default. Session tokens are obtained lazily so the actual login is deferred until the first session-bound use of Vault. Once Spring Cloud Vault obtains a session token, it retains it until expiry. The next time a session-bound activity is used, Spring Cloud Vault re-logins into Vault and obtains a new session token. On application shut down, Spring Cloud Vault revokes the token if it was still active to terminate the session. Session lifecycle is enabled by default and can be disabled by setting spring.cloud.vault.session.lifecycle.enabled to false . Disabling is not recommended as session tokens can expire and Spring Cloud Vault cannot longer access Vault. spring.cloud.vault: session.lifecycle: enabled: true refresh-before-expiry: 10s expiry-threshold: 20s enabled controls whether session lifecycle management is enabled to renew session tokens. Enabled by default. refresh-before-expiry controls the point in time when the session token gets renewed. The refresh time is calculated by subtracting refresh-before-expiry from the token expiry time. Defaults to 5 seconds . expiry-threshold sets the expiry threshold. The threshold represents a minimum TTL duration to consider a session token as valid. Tokens with a shorter TTL are considered expired and are not used anymore. Should be greater than refresh-before-expiry to prevent token expiry. Defaults to 7 seconds . See also: Vault Documentation: Token Renewal(https://www.vaultproject.io/api-docs/auth/token#renew-a-token-self)"
"https://docs.spring.io/spring-cloud-vault/reference/appendix.html","Common application properties: Various properties can be specified inside your application.properties file, inside your application.yml file, or as command line switches. This appendix provides a list of common Spring Cloud Vault properties and references to the underlying classes that consume them. Property contributions can come from additional jar files on your classpath, so you should not consider this an exhaustive list. Also, you can define your own properties. Name Default Description spring.cloud.vault.app-id.app-id-path app-id Mount path of the AppId authentication backend. spring.cloud.vault.app-id.network-interface Network interface hint for the ""MAC_ADDRESS"" UserId mechanism. spring.cloud.vault.app-id.user-id MAC_ADDRESS UserId mechanism. Can be either ""MAC_ADDRESS"", ""IP_ADDRESS"", a string or a class name. spring.cloud.vault.app-role.app-role-path approle Mount path of the AppRole authentication backend. spring.cloud.vault.app-role.role Name of the role, optional, used for pull-mode. spring.cloud.vault.app-role.role-id The RoleId. spring.cloud.vault.app-role.secret-id The SecretId. spring.cloud.vault.application-name application Application name for AppId authentication. spring.cloud.vault.authentication spring.cloud.vault.aws-ec2.aws-ec2-path aws-ec2 Mount path of the AWS-EC2 authentication backend. spring.cloud.vault.aws-ec2.identity-document http://169.254.169.254/latest/dynamic/instance-identity/pkcs7 URL of the AWS-EC2 PKCS7 identity document. spring.cloud.vault.aws-ec2.nonce Nonce used for AWS-EC2 authentication. An empty nonce defaults to nonce generation. spring.cloud.vault.aws-ec2.role Name of the role, optional. spring.cloud.vault.aws-iam.aws-path aws Mount path of the AWS authentication backend. spring.cloud.vault.aws-iam.endpoint-uri STS server URI. @since 2.2 spring.cloud.vault.aws-iam.region Name of the region, optional. Inferred by AWS defaults if not set. @since 4.0.1 spring.cloud.vault.aws-iam.role Name of the role, optional. Defaults to the friendly IAM name if not set. spring.cloud.vault.aws-iam.server-name Name of the server used to set {@code X-Vault-AWS-IAM-Server-ID} header in the headers of login requests. spring.cloud.vault.aws.access-key-property cloud.aws.credentials.accessKey Target property for the obtained access key. spring.cloud.vault.aws.backend aws aws backend path. spring.cloud.vault.aws.credential-type aws credential type spring.cloud.vault.aws.enabled false Enable aws backend usage. spring.cloud.vault.aws.role Role name for credentials. spring.cloud.vault.aws.role-arn Role arn for assumed_role in case we have multiple roles associated with the vault role. @since 3.0.2 spring.cloud.vault.aws.secret-key-property cloud.aws.credentials.secretKey Target property for the obtained secret key. spring.cloud.vault.aws.session-token-key-property cloud.aws.credentials.sessionToken Target property for the obtained secret key. spring.cloud.vault.aws.ttl 0 TTL for sts tokens. Defaults to whatever the vault Role may have for Max. Also limited to what AWS supports to be the max for STS. @since 3.0.2 spring.cloud.vault.azure-msi.azure-path azure Mount path of the Azure MSI authentication backend. spring.cloud.vault.azure-msi.identity-token-service Identity token service URI. @since 3.0 spring.cloud.vault.azure-msi.metadata-service Instance metadata service URI. @since 3.0 spring.cloud.vault.azure-msi.role Name of the role. spring.cloud.vault.cassandra.backend cassandra Cassandra backend path. spring.cloud.vault.cassandra.enabled false Enable cassandra backend usage. spring.cloud.vault.cassandra.password-property spring.data.cassandra.password Target property for the obtained password. spring.cloud.vault.cassandra.role Role name for credentials. spring.cloud.vault.cassandra.static-role false Enable static role usage. @since 2.2 spring.cloud.vault.cassandra.username-property spring.data.cassandra.username Target property for the obtained username. spring.cloud.vault.config.lifecycle.enabled true Enable lifecycle management. spring.cloud.vault.config.lifecycle.expiry-threshold The expiry threshold. {@link Lease} is renewed the given {@link Duration} before it expires. @since 2.2 spring.cloud.vault.config.lifecycle.lease-endpoints Set the {@link LeaseEndpoints} to delegate renewal/revocation calls to. {@link LeaseEndpoints} encapsulates differences between Vault versions that affect the location of renewal/revocation endpoints. Can be {@link LeaseEndpoints#SysLeases} for version 0.8 or above of Vault or {@link LeaseEndpoints#Legacy} for older versions (the default). @since 2.2 spring.cloud.vault.config.lifecycle.lease-strategy Sets the {@link LeaseStrategy} to be used with {@link org.springframework.vault.core.lease.SecretLeaseContainer#setLeaseStrategy(LeaseStrategy)} to retain or drop tokens on renewal errors. @since 4.1 spring.cloud.vault.config.lifecycle.min-renewal The time period that is at least required before renewing a lease. @since 2.2 spring.cloud.vault.config.order 0 Used to set a {@link org.springframework.core.env.PropertySource} priority. This is useful to use Vault as an override on other property sources. @see org.springframework.core.PriorityOrdered spring.cloud.vault.connection-timeout 5000 Connection timeout. spring.cloud.vault.consul.backend consul Consul backend path. spring.cloud.vault.consul.enabled false Enable consul backend usage. spring.cloud.vault.consul.role Role name for credentials. spring.cloud.vault.consul.token-property spring.cloud.consul.token Target property for the obtained token. spring.cloud.vault.couchbase.backend database Couchbase backend path. spring.cloud.vault.couchbase.enabled false Enable couchbase backend usage. spring.cloud.vault.couchbase.password-property spring.couchbase.password Target property for the obtained password. spring.cloud.vault.couchbase.role Role name for credentials. spring.cloud.vault.couchbase.static-role false Enable static role usage. spring.cloud.vault.couchbase.username-property spring.couchbase.username Target property for the obtained username. spring.cloud.vault.database.backend database Database backend path. spring.cloud.vault.database.enabled false Enable database backend usage. spring.cloud.vault.database.password-property spring.datasource.password Target property for the obtained password. spring.cloud.vault.database.role Role name for credentials. spring.cloud.vault.database.static-role false Enable static role usage. spring.cloud.vault.database.username-property spring.datasource.username Target property for the obtained username. spring.cloud.vault.databases spring.cloud.vault.discovery.enabled false Flag to indicate that Vault server discovery is enabled (vault server URL will be looked up via discovery). spring.cloud.vault.discovery.service-id vault Service id to locate Vault. spring.cloud.vault.elasticsearch.backend database Database backend path. spring.cloud.vault.elasticsearch.enabled false Enable elasticsearch backend usage. spring.cloud.vault.elasticsearch.password-property spring.elasticsearch.rest.password Target property for the obtained password. spring.cloud.vault.elasticsearch.role Role name for credentials. spring.cloud.vault.elasticsearch.static-role false Enable static role usage. spring.cloud.vault.elasticsearch.username-property spring.elasticsearch.rest.username Target property for the obtained username. spring.cloud.vault.enabled true Enable Vault config server. spring.cloud.vault.fail-fast false Fail fast if data cannot be obtained from Vault. spring.cloud.vault.gcp-gce.gcp-path gcp Mount path of the Kubernetes authentication backend. spring.cloud.vault.gcp-gce.role Name of the role against which the login is being attempted. spring.cloud.vault.gcp-gce.service-account Optional service account id. Using the default id if left unconfigured. spring.cloud.vault.gcp-iam.credentials.encoded-key The base64 encoded contents of an OAuth2 account private key in JSON format. spring.cloud.vault.gcp-iam.credentials.location Location of the OAuth2 credentials private key. <p> Since this is a Resource, the private key can be in a multitude of locations, such as a local file system, classpath, URL, etc. spring.cloud.vault.gcp-iam.gcp-path gcp Mount path of the Kubernetes authentication backend. spring.cloud.vault.gcp-iam.jwt-validity 15m Validity of the JWT token. spring.cloud.vault.gcp-iam.project-id Overrides the GCP project Id. spring.cloud.vault.gcp-iam.role Name of the role against which the login is being attempted. spring.cloud.vault.gcp-iam.service-account-id Overrides the GCP service account Id. spring.cloud.vault.host localhost Vault server host. spring.cloud.vault.kubernetes.kubernetes-path kubernetes Mount path of the Kubernetes authentication backend. spring.cloud.vault.kubernetes.role Name of the role against which the login is being attempted. spring.cloud.vault.kubernetes.service-account-token-file /var/run/secrets/kubernetes.io/serviceaccount/token Path to the service account token file. spring.cloud.vault.kv.application-name application Application name to be used for the context. spring.cloud.vault.kv.backend secret Name of the default backend. spring.cloud.vault.kv.backend-version 2 Key-Value backend version. Currently supported versions are: <ul> <li>Version 1 (unversioned key-value backend).</li> <li>Version 2 (versioned key-value backend).</li> </ul> spring.cloud.vault.kv.default-context application Name of the default context. spring.cloud.vault.kv.enabled true Enable the key-value backend. spring.cloud.vault.kv.profile-separator / Profile-separator to combine application name and profile. spring.cloud.vault.kv.profiles List of active profiles. @since 3.0 spring.cloud.vault.mongodb.backend mongodb MongoDB backend path. spring.cloud.vault.mongodb.enabled false Enable mongodb backend usage. spring.cloud.vault.mongodb.password-property spring.data.mongodb.password Target property for the obtained password. spring.cloud.vault.mongodb.role Role name for credentials. spring.cloud.vault.mongodb.static-role false Enable static role usage. @since 2.2 spring.cloud.vault.mongodb.username-property spring.data.mongodb.username Target property for the obtained username. spring.cloud.vault.mysql.backend mysql mysql backend path. spring.cloud.vault.mysql.enabled false Enable mysql backend usage. spring.cloud.vault.mysql.password-property spring.datasource.password Target property for the obtained username. spring.cloud.vault.mysql.role Role name for credentials. spring.cloud.vault.mysql.username-property spring.datasource.username Target property for the obtained username. spring.cloud.vault.namespace Vault namespace (requires Vault Enterprise). spring.cloud.vault.pcf.instance-certificate Path to the instance certificate (PEM). Defaults to {@code CF_INSTANCE_CERT} env variable. spring.cloud.vault.pcf.instance-key Path to the instance key (PEM). Defaults to {@code CF_INSTANCE_KEY} env variable. spring.cloud.vault.pcf.pcf-path pcf Mount path of the Kubernetes authentication backend. spring.cloud.vault.pcf.role Name of the role against which the login is being attempted. spring.cloud.vault.port 8200 Vault server port. spring.cloud.vault.postgresql.backend postgresql postgresql backend path. spring.cloud.vault.postgresql.enabled false Enable postgresql backend usage. spring.cloud.vault.postgresql.password-property spring.datasource.password Target property for the obtained username. spring.cloud.vault.postgresql.role Role name for credentials. spring.cloud.vault.postgresql.username-property spring.datasource.username Target property for the obtained username. spring.cloud.vault.rabbitmq.backend rabbitmq rabbitmq backend path. spring.cloud.vault.rabbitmq.enabled false Enable rabbitmq backend usage. spring.cloud.vault.rabbitmq.password-property spring.rabbitmq.password Target property for the obtained password. spring.cloud.vault.rabbitmq.role Role name for credentials. spring.cloud.vault.rabbitmq.username-property spring.rabbitmq.username Target property for the obtained username. spring.cloud.vault.reactive.enabled true Flag to indicate that reactive discovery is enabled spring.cloud.vault.read-timeout 15000 Read timeout. spring.cloud.vault.scheme https Protocol scheme. Can be either ""http"" or ""https"". spring.cloud.vault.session.lifecycle.enabled true Enable session lifecycle management. spring.cloud.vault.session.lifecycle.expiry-threshold 7s The expiry threshold for a {@link LoginToken}. The threshold represents a minimum TTL duration to consider a login token as valid. Tokens with a shorter TTL are considered expired and are not used anymore. Should be greater than {@code refreshBeforeExpiry} to prevent token expiry. spring.cloud.vault.session.lifecycle.refresh-before-expiry 5s The time period that is at least required before renewing the {@link LoginToken}. spring.cloud.vault.ssl.cert-auth-path cert Mount path of the TLS cert authentication backend. spring.cloud.vault.ssl.enabled-cipher-suites List of enabled SSL/TLS cipher suites. @since 3.0.2 spring.cloud.vault.ssl.enabled-protocols List of enabled SSL/TLS protocol. @since 3.0.2 spring.cloud.vault.ssl.key-store Trust store that holds certificates and private keys. spring.cloud.vault.ssl.key-store-password Password used to access the key store. spring.cloud.vault.ssl.key-store-type Type of the key store. @since 3.0 spring.cloud.vault.ssl.trust-store Trust store that holds SSL certificates. spring.cloud.vault.ssl.trust-store-password Password used to access the trust store. spring.cloud.vault.ssl.trust-store-type Type of the trust store. @since 3.0 spring.cloud.vault.token Static vault token. Required if {@link #authentication} is {@code TOKEN}. spring.cloud.vault.uri Vault URI. Can be set with scheme, host and port."
