"url","content"
"https://docs.spring.io/spring-session/reference/3.0/whats-new.html","For the latest stable version, please use Spring Session 3.3.2(../whats-new.html) ! What’s New:"
"https://docs.spring.io/spring-session/reference/3.0/samples.html","For the latest stable version, please use Spring Session 3.3.2(../samples.html) ! Samples and Guides (Start Here): To get started with Spring Session, the best place to start is our Sample Applications. Table 1. Sample Applications that use Spring Boot Source Description Guide HttpSession with Redis(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-redis) Demonstrates how to use Spring Session to replace the HttpSession with Redis. HttpSession with Redis Guide(guides/boot-redis.html) HttpSession with JDBC(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-jdbc) Demonstrates how to use Spring Session to replace the HttpSession with a relational database store. HttpSession with JDBC Guide(guides/boot-jdbc.html) HttpSession with Hazelcast(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-hazelcast) Demonstrates how to use Spring Session to replace the HttpSession with Hazelcast. Find by Username(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-findbyusername) Demonstrates how to use Spring Session to find sessions by username. Find by Username Guide(guides/boot-findbyusername.html) WebSockets(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-websocket) Demonstrates how to use Spring Session with WebSockets. WebSockets Guide(guides/boot-websocket.html) WebFlux(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-webflux) Demonstrates how to use Spring Session to replace the Spring WebFlux’s WebSession with Redis. WebFlux with Custom Cookie(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-webflux-custom-cookie) Demonstrates how to use Spring Session to customize the Session cookie in a WebFlux based application. WebFlux with Custom Cookie Guide(guides/boot-webflux-custom-cookie.html) HttpSession with Redis JSON serialization(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-redis-json) Demonstrates how to use Spring Session to replace the HttpSession with Redis using JSON serialization. Spring Session with MongoDB Repositories (servlet-based)(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-mongodb-traditional) Demonstrates how to back Spring Session with traditional MongoDB repositories. Spring Session with MongoDB Repositories(guides/boot-mongo.html) Spring Session with MongoDB Repositories (reactive)(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-mongodb-reactive) Demonstrates how to back Spring Session with reactive MongoDB repositories. Spring Session with MongoDB Repositories(guides/boot-mongo.html) Table 2. Sample Applications that use Spring Java-based configuration Source Description Guide HttpSession with Redis(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-javaconfig-redis) Demonstrates how to use Spring Session to replace the HttpSession with Redis. HttpSession with Redis Guide(guides/java-redis.html) HttpSession with JDBC(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-javaconfig-jdbc) Demonstrates how to use Spring Session to replace the HttpSession with a relational database store. HttpSession with JDBC Guide(guides/java-jdbc.html) HttpSession with Hazelcast(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-javaconfig-hazelcast) Demonstrates how to use Spring Session to replace the HttpSession with Hazelcast. HttpSession with Hazelcast Guide(guides/java-hazelcast.html) Custom Cookie(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-javaconfig-custom-cookie) Demonstrates how to use Spring Session and customize the cookie. Custom Cookie Guide(guides/java-custom-cookie.html) Spring Security(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-javaconfig-security) Demonstrates how to use Spring Session with an existing Spring Security application. Spring Security Guide(guides/java-security.html) REST(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-javaconfig-rest) Demonstrates how to use Spring Session in a REST application to support authenticating with a header. REST Guide(guides/java-rest.html) Table 3. Sample Applications that use Spring XML-based configuration Source Description Guide HttpSession with Redis(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-xml-redis) Demonstrates how to use Spring Session to replace the HttpSession with a Redis store. HttpSession with Redis Guide(guides/xml-redis.html) HttpSession with JDBC(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-xml-jdbc) Demonstrates how to use Spring Session to replace the HttpSession with a relational database store. HttpSession with JDBC Guide(guides/xml-jdbc.html) Table 4. Miscellaneous sample Applications Source Description Guide Hazelcast(https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-misc-hazelcast) Demonstrates how to use Spring Session with Hazelcast in a Java EE application."
"https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-redis-json",""
"https://docs.spring.io/spring-session/reference/3.0/guides/boot-redis.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/boot-redis.html) ! Spring Session - Spring Boot: This guide describes how to use Spring Session to transparently leverage Redis to back a web application’s HttpSession when you use Spring Boot. You can find the completed guide in the boot sample application(#boot-sample) . Index(../index.html) Updating Dependencies: Before you use Spring Session with Redis, you must ensure that you have the right dependencies. We assume you are working with a working Spring Boot web application. pom.xml <dependencies> <!-- ... --> <dependency> <groupId>org.springframework.session</groupId> <artifactId>spring-session-data-redis</artifactId> </dependency> </dependencies> build.gradle implementation(""org.springframework.session:spring-session-data-redis"") Spring Boot provides dependency management for Spring Session modules, so you need not explicitly declare dependency version. Spring Boot Configuration: After adding the required dependencies, we can create our Spring Boot configuration. Thanks to first-class auto-configuration support, setting up Spring Session backed by Redis is as simple as adding a single configuration property to your application.properties , as the following listing shows: src/main/resources/application.properties spring.session.store-type=redis # Session store type. Under the hood, Spring Boot applies configuration that is equivalent to manually adding @EnableRedisHttpSession annotation. This creates a Spring bean with the name of springSessionRepositoryFilter that implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. Further customization is possible by using application.properties , as the following listing shows: src/main/resources/application.properties server.servlet.session.timeout= # Session timeout. If a duration suffix is not specified, seconds is used. spring.session.redis.flush-mode=on_save # Sessions flush mode. spring.session.redis.namespace=spring:session # Namespace for keys used to store sessions. For more information, see the Spring Session(https://docs.spring.io/spring-boot/docs/3.0.7/reference/htmlsingle/#boot-features-session) portion of the Spring Boot documentation. Configuring the Redis Connection: Spring Boot automatically creates a RedisConnectionFactory that connects Spring Session to a Redis Server on localhost on port 6379 (default port). In a production environment, you need to update your configuration to point to your Redis server. For example, you can include the following in your application.properties: src/main/resources/application.properties spring.data.redis.host=localhost # Redis server host. spring.data.redis.password= # Login password of the redis server. spring.data.redis.port=6379 # Redis server port. For more information, see the Connecting to Redis(https://docs.spring.io/spring-boot/docs/3.0.7/reference/htmlsingle/#boot-features-connecting-to-redis) portion of the Spring Boot documentation. Servlet Container Initialization: Our Spring Boot Configuration(#boot-spring-configuration) created a Spring bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our Config class. Last, we need to ensure that our servlet container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. Fortunately, Spring Boot takes care of both of these steps for us. Boot Sample Application: The Boot Sample Application demonstrates how to use Spring Session to transparently leverage Redis to back a web application’s HttpSession when you use Spring Boot. Running the Boot Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: $ ./gradlew :spring-session-sample-boot-redis:bootRun For the sample to work, you must install Redis 2.8+(https://redis.io/download) on localhost and run it with the default port (6379). Alternatively, you can update the RedisConnectionFactory to point to a Redis server. Another option is to use Docker(https://www.docker.com/) to run Redis on localhost. See Docker Redis repository(https://hub.docker.com/_/redis/) for detailed instructions. You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the security Sample Application: Now you can try using the application. Enter the following to log in: Username user Password password Now click the Login button. You should now see a message indicating you are logged in with the user entered previously. The user’s information is stored in Redis rather than Tomcat’s HttpSession implementation. How Does It Work?: Instead of using Tomcat’s HttpSession , we persist the values in Redis. Spring Session replaces the HttpSession with an implementation that is backed by Redis. When Spring Security’s SecurityContextPersistenceFilter saves the SecurityContext to the HttpSession , it is then persisted into Redis. When a new HttpSession is created, Spring Session creates a cookie named SESSION in your browser. That cookie contains the ID of your session. You can view the cookies (with Chrome(https://developers.google.com/web/tools/chrome-devtools/manage-data/cookies) or Firefox(https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector) ). You can remove the session by using redis-cli. For example, on a Linux based system you can type the following: $ redis-cli keys '*' | xargs redis-cli del The Redis documentation has instructions for installing redis-cli(https://redis.io/topics/quickstart) . Alternatively, you can also delete the explicit key. To do so, enter the following into your terminal, being sure to replace 7e8383a4-082c-4ffe-a4bc-c40fd3363c5e with the value of your SESSION cookie: $ redis-cli del spring:session:sessions:7e8383a4-082c-4ffe-a4bc-c40fd3363c5e Now you can visit the application at localhost:8080/(http://localhost:8080/) and observe that we are no longer authenticated."
"https://docs.spring.io/spring-session/reference/3.0/guides/boot-mongo.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/boot-mongo.html) ! Spring Session - MongoDB Repositories: This guide describes how to use Spring Session backed by MongoDB. The completed guide can be found in the mongo sample application(#mongo-sample) . Index(../index.html) Updating Dependencies: Before you use Spring Session MongoDB, you must ensure to update your dependencies. We assume you are working with a working Spring Boot web application. If you are using Maven, ensure to add the following dependencies: pom.xml <dependencies> <!-- ... --> <dependency> <groupId>org.springframework.session</groupId> <artifactId>spring-session-data-mongodb</artifactId> </dependency> </dependencies> Spring Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a Servlet Filter that replaces the HttpSession implementation with an implementation backed by Spring Session. All you have to do is to add the following Spring Configuration: @Configuration(proxyBeanMethods = false) @EnableMongoHttpSession (1) public class HttpSessionConfig { @Bean public JdkMongoSessionConverter jdkMongoSessionConverter() { return new JdkMongoSessionConverter(Duration.ofMinutes(30)); (2) } } 1 The @EnableMongoHttpSession annotation creates a Spring Bean with the name of springSessionRepositoryFilter that implements Filter. This filter is what replaces the default HttpSession with the MongoDB-backed bean. 2 Configures the session timeout to 30 minutes. Configuring the MongoDB Connection: Spring Boot automatically creates a MongoClient that connects Spring Session to a MongoDB Server on localhost on port 27017 (default port). In a production environment you need to ensure to update your configuration to point to your MongoDB server. For example, you can include the following in your application.properties src/main/resources/application.properties spring.data.mongodb.host=mongo-srv spring.data.mongodb.port=27018 spring.data.mongodb.database=prod For more information, refer to Connecting to MongoDB(https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-connecting-to-mongodb) portion of the Spring Boot documentation. Servlet Container Initialization: Our Spring Configuration(#boot-mongo-configuration) created a Spring Bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our Config class. Last we need to ensure that our Servlet Container (i.e. Tomcat) uses our springSessionRepositoryFilter for every request. Fortunately, Spring Boot takes care of both of these steps for us. MongoDB Sample Application: The MongoDB Sample Application demonstrates how to use Spring Session to transparently leverage MongoDB to back a web application’s HttpSession when using Spring Boot. Running the MongoDB Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: $ ./gradlew :samples:mongo:bootRun You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the security Sample Application: Try using the application. Enter the following to log in: Username user Password password Now click the Login button. You should now see a message indicating your are logged in with the user entered previously. The user’s information is stored in MongoDB rather than Tomcat’s HttpSession implementation. How does it work?: Instead of using Tomcat’s HttpSession , we are actually persisting the values in Mongo. Spring Session replaces the HttpSession with an implementation that is backed by Mongo. When Spring Security’s SecurityContextPersistenceFilter saves the SecurityContext to the HttpSession it is then persisted into Mongo. When a new HttpSession is created, Spring Session creates a cookie named SESSION in your browser that contains the id of your session. Go ahead and view the cookies (click for help with Chrome(https://developer.chrome.com/devtools/docs/resources#cookies) or Firefox(https://getfirebug.com/wiki/index.php/Cookies_Panel#Cookies_List) ). If you like, you can easily inspect the session using mongo client. For example, on a Linux based system you can type: The sample application uses an embedded MongoDB instance that listens on a randomly allocated port. The port used by embedded MongoDB together with exact command to connect to it is logged during application startup. $ mongo --port ... > use test > db.sessions.find().pretty() Alternatively, you can also delete the explicit key. Enter the following into your terminal ensuring to replace 60f17293-839b-477c-bb92-07a9c3658843 with the value of your SESSION cookie: > db.sessions.remove({""_id"":""60f17293-839b-477c-bb92-07a9c3658843""}) Now visit the application at localhost:8080/(http://localhost:8080/) and observe that we are no longer authenticated."
"https://docs.spring.io/spring-session/reference/3.0/guides/boot-jdbc.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/boot-jdbc.html) ! Spring Session - Spring Boot: This guide describes how to use Spring Session to transparently leverage a relational database to back a web application’s HttpSession when you use Spring Boot. You can find the completed guide in the httpsession-jdbc-boot sample application(#httpsession-jdbc-boot-sample) . Index(../index.html) Updating Dependencies: Before you use Spring Session, you must update your dependencies. We assume you are working with a working Spring Boot web application. If you use Maven, you must add the following dependencies: pom.xml <dependencies> <!-- ... --> <dependency> <groupId>org.springframework.session</groupId> <artifactId>spring-session-jdbc</artifactId> </dependency> </dependencies> Spring Boot provides dependency management for Spring Session modules, so you need not explicitly declare the dependency version. Spring Boot Configuration: After adding the required dependencies, we can create our Spring Boot configuration. Thanks to first-class auto configuration support, setting up Spring Session backed by a relational database is as simple as adding a single configuration property to your application.properties . The following listing shows how to do so: src/main/resources/application.properties spring.session.store-type=jdbc # Session store type. If a single Spring Session module is present on the classpath, Spring Boot uses that store implementation automatically. If you have more than one implementation, you must choose the StoreType that you wish to use to store the sessions, as shows above. Under the hood, Spring Boot applies configuration that is equivalent to manually adding the @EnableJdbcHttpSession annotation. This creates a Spring bean with the name of springSessionRepositoryFilter . That bean implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. You can further customize by using application.properties . The following listing shows how to do so: src/main/resources/application.properties server.servlet.session.timeout= # Session timeout. If a duration suffix is not specified, seconds are used. spring.session.jdbc.initialize-schema=embedded # Database schema initialization mode. spring.session.jdbc.schema=classpath:org/springframework/session/jdbc/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema. spring.session.jdbc.table-name=SPRING_SESSION # Name of the database table used to store sessions. For more information, see the Spring Session(https://docs.spring.io/spring-boot/docs/3.0.7/reference/htmlsingle/#boot-features-session) portion of the Spring Boot documentation. Configuring the DataSource: Spring Boot automatically creates a DataSource that connects Spring Session to an embedded instance of an H2 database. In a production environment, you need to update your configuration to point to your relational database. For example, you can include the following in your application.properties: src/main/resources/application.properties spring.datasource.url= # JDBC URL of the database. spring.datasource.username= # Login username of the database. spring.datasource.password= # Login password of the database. For more information, see the Configure a DataSource(https://docs.spring.io/spring-boot/docs/3.0.7/reference/htmlsingle/#boot-features-configure-datasource) portion of the Spring Boot documentation. Servlet Container Initialization: Our Spring Boot Configuration(#httpsession-jdbc-boot-spring-configuration) created a Spring bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our Config class. Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. Fortunately, Spring Boot takes care of both of these steps for us. httpsession-jdbc-boot Sample Application: The httpsession-jdbc-boot Sample Application demonstrates how to use Spring Session to transparently leverage an H2 database to back a web application’s HttpSession when you use Spring Boot. Running the httpsession-jdbc-boot Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: $ ./gradlew :spring-session-sample-boot-jdbc:bootRun You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the Security Sample Application: You can now try using the application. To do so, enter the following to log in: Username user Password password Now click the Login button. You should now see a message indicating that your are logged in with the user entered previously. The user’s information is stored in the H2 database rather than Tomcat’s HttpSession implementation. How Does It Work?: Instead of using Tomcat’s HttpSession , we persist the values in the H2 database. Spring Session replaces the HttpSession with an implementation that is backed by a relational database. When Spring Security’s SecurityContextPersistenceFilter saves the SecurityContext to the HttpSession , it is then persisted into the H2 database. When a new HttpSession is created, Spring Session creates a cookie named SESSION in your browser. That cookie contains the ID of your session. You can view the cookies (with Chrome(https://developers.google.com/web/tools/chrome-devtools/manage-data/cookies) or Firefox(https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector) ). You can remove the session by using the H2 web console available at: localhost:8080/h2-console/(http://localhost:8080/h2-console/) (use jdbc:h2:mem:testdb for JDBC URL). Now you can visit the application at localhost:8080/(http://localhost:8080/) and see that we are no longer authenticated."
"https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-hazelcast",""
"https://docs.spring.io/spring-session/reference/3.0/guides/boot-findbyusername.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/boot-findbyusername.html) ! Spring Session - find by username: This guide describes how to use Spring Session to find sessions by username. You can find the completed guide in the findbyusername application(#findbyusername-sample) . Index(../index.html) Assumptions: The guide assumes you have already added Spring Session to your application by using the built-in Redis configuration support. The guide also assumes you have already applied Spring Security to your application. However, we the guide is somewhat general purpose and can be applied to any technology with minimal changes, which we discuss later in the guide. If you need to learn how to add Spring Session to your project, see the listing of samples and guides(../#samples) About the Sample: Our sample uses this feature to invalidate the users session that might have been compromised. Consider the following scenario: User goes to library and authenticates to the application. User goes home and realizes they forgot to log out. User can log in and end the session from the library using clues like the location, created time, last accessed time, and so on. Would it not be nice if we could let the user invalidate the session at the library from any device with which they authenticate? This sample demonstrates how this is possible. Using FindByIndexNameSessionRepository: To look up a user by their username, you must first choose a SessionRepository that implements FindByIndexNameSessionRepository(../#api-findbyindexnamesessionrepository) . Our sample application assumes that the Redis support is already set up, so we are ready to go. Mapping the User Name: FindByIndexNameSessionRepository can find a session only by the user name if the developer instructs Spring Session what user is associated with the Session . You can do so by ensuring that the session attribute with the name FindByUsernameSessionRepository.PRINCIPAL_NAME_INDEX_NAME is populated with the username. Generally speaking, you can do so with the following code immediately after the user authenticates: String username = ""username""; this.session.setAttribute(FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, username); Mapping the User Name with Spring Security: Since we use Spring Security, the user name is automatically indexed for us. This means we need not perform any steps to ensure the user name is indexed. Adding Additional Data to the Session: It may be nice to associate additional information (such as the IP Address, the browser, location, and other details) to the session. Doing so makes it easier for the user to know which session they are looking at. To do so, determine which session attribute you want to use and what information you wish to provide. Then create a Java bean that is added as a session attribute. For example, our sample application includes the location and access type of the session, as the following listing shows: public class SessionDetails implements Serializable { private String location; private String accessType; public String getLocation() { return this.location; } public void setLocation(String location) { this.location = location; } public String getAccessType() { return this.accessType; } public void setAccessType(String accessType) { this.accessType = accessType; } private static final long serialVersionUID = 8850489178248613501L; } We then inject that information into the session on each HTTP request using a SessionDetailsFilter , as the following example shows: @Override public void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { chain.doFilter(request, response); HttpSession session = request.getSession(false); if (session != null) { String remoteAddr = getRemoteAddress(request); String geoLocation = getGeoLocation(remoteAddr); SessionDetails details = new SessionDetails(); details.setAccessType(request.getHeader(""User-Agent"")); details.setLocation(remoteAddr + "" "" + geoLocation); session.setAttribute(""SESSION_DETAILS"", details); } } We obtain the information we want and then set the SessionDetails as an attribute in the Session . When we retrieve the Session by user name, we can then use the session to access our SessionDetails as we would any other session attribute. You might wonder why Spring Session does not provide SessionDetails functionality out of the box. We have two reasons. The first reason is that it is very trivial for applications to implement this themselves. The second reason is that the information that is populated in the session (and how frequently that information is updated) is highly application-dependent. Finding sessions for a specific user: We can now find all the sessions for a specific user. The following example shows how to do so: @Autowired FindByIndexNameSessionRepository<? extends Session> sessions; @RequestMapping(""/"") public String index(Principal principal, Model model) { Collection<? extends Session> usersSessions = this.sessions.findByPrincipalName(principal.getName()).values(); model.addAttribute(""sessions"", usersSessions); return ""index""; } In our instance, we find all sessions for the currently logged in user. However, you can modify this for an administrator to use a form to specify which user to look up. findbyusername Sample Application: This section describes how to use the findbyusername sample application. Running the findbyusername Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: $ ./gradlew :spring-session-sample-boot-findbyusername:bootRun For the sample to work, you must install Redis 2.8+(https://redis.io/download) on localhost and run it with the default port (6379). Alternatively, you can update the RedisConnectionFactory to point to a Redis server. Another option is to use Docker(https://www.docker.com/) to run Redis on localhost. See Docker Redis repository(https://hub.docker.com/_/redis/) for detailed instructions. You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the security Sample Application: You can now try using the application. Enter the following to log in: Username user Password password Now click the Login button. You should now see a message indicating your are logged in with the user entered previously. You should also see a listing of active sessions for the currently logged in user. You can emulate the flow we discussed in the About the Sample(#_about_the_sample) section by doing the following: Open a new incognito window and navigate to localhost:8080/(http://localhost:8080/) Enter the following to log in: Username user Password password End your original session. Refresh the original window and see that you are logged out."
"https://docs.spring.io/spring-session/reference/3.0/guides/boot-websocket.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/boot-websocket.html) ! Spring Session - WebSocket: This guide describes how to use Spring Session to ensure that WebSocket messages keep your HttpSession alive. Spring Session’s WebSocket support works only with Spring’s WebSocket support. Specifically,it does not work with using JSR-356(https://www.jcp.org/en/jsr/detail?id=356) directly, because JSR-356 does not have a mechanism for intercepting incoming WebSocket messages. Index(../index.html) HttpSession Setup: The first step is to integrate Spring Session with the HttpSession. These steps are already outlined in the HttpSession with Redis Guide(./boot-redis.html) . Please make sure you have already integrated Spring Session with HttpSession before proceeding. Spring Configuration: In a typical Spring WebSocket application, you would implement WebSocketMessageBrokerConfigurer . For example, the configuration might look something like the following: @Configuration @EnableScheduling @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(""/messages"").withSockJS(); } @Override public void configureMessageBroker(MessageBrokerRegistry registry) { registry.enableSimpleBroker(""/queue/"", ""/topic/""); registry.setApplicationDestinationPrefixes(""/app""); } } We can update our configuration to use Spring Session’s WebSocket support. The following example shows how to do so: src/main/java/samples/config/WebSocketConfig.java @Configuration @EnableScheduling @EnableWebSocketMessageBroker public class WebSocketConfig extends AbstractSessionWebSocketMessageBrokerConfigurer<Session> { (1) @Override protected void configureStompEndpoints(StompEndpointRegistry registry) { (2) registry.addEndpoint(""/messages"").withSockJS(); } @Override public void configureMessageBroker(MessageBrokerRegistry registry) { registry.enableSimpleBroker(""/queue/"", ""/topic/""); registry.setApplicationDestinationPrefixes(""/app""); } } To hook in the Spring Session support we only need to change two things: 1 Instead of implementing WebSocketMessageBrokerConfigurer , we extend AbstractSessionWebSocketMessageBrokerConfigurer 2 We rename the registerStompEndpoints method to configureStompEndpoints What does AbstractSessionWebSocketMessageBrokerConfigurer do behind the scenes? WebSocketConnectHandlerDecoratorFactory is added as a WebSocketHandlerDecoratorFactory to WebSocketTransportRegistration . This ensures a custom SessionConnectEvent is fired that contains the WebSocketSession . The WebSocketSession is necessary to end any WebSocket connections that are still open when a Spring Session is ended. SessionRepositoryMessageInterceptor is added as a HandshakeInterceptor to every StompWebSocketEndpointRegistration . This ensures that the Session is added to the WebSocket properties to enable updating the last accessed time. SessionRepositoryMessageInterceptor is added as a ChannelInterceptor to our inbound ChannelRegistration . This ensures that every time an inbound message is received, that the last accessed time of our Spring Session is updated. WebSocketRegistryListener is created as a Spring bean. This ensures that we have a mapping of all of the Session IDs to the corresponding WebSocket connections. By maintaining this mapping, we can close all the WebSocket connections when a Spring Session (HttpSession) is ended. websocket Sample Application: The websocket sample application demonstrates how to use Spring Session with WebSockets. Running the websocket Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: $ ./gradlew :spring-session-sample-boot-websocket:bootRun For the purposes of testing session expiration, you may want to change the session expiration to be 1 minute (the default is 30 minutes) by adding the following configuration property before starting the application: src/main/resources/application.properties server.servlet.session.timeout=1m # Session timeout. If a duration suffix is not specified, seconds will be used. For the sample to work, you must install Redis 2.8+(https://redis.io/download) on localhost and run it with the default port (6379). Alternatively, you can update the RedisConnectionFactory to point to a Redis server. Another option is to use Docker(https://www.docker.com/) to run Redis on localhost. See Docker Redis repository(https://hub.docker.com/_/redis/) for detailed instructions. You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the websocket Sample Application: Now you can try using the application. Authenticate with the following information: Username rob Password password Now click the Login button. You should now be authenticated as the user rob . Open an incognito window and access localhost:8080/(http://localhost:8080/) You are prompted with a login form. Authenticate with the following information: Username luke Password password Now send a message from rob to luke. The message should appear. Wait for two minutes and try sending a message from rob to luke again. You can see that the message is no longer sent. Why two minutes? Spring Session expires in 60 seconds, but the notification from Redis is not guaranteed to happen within 60 seconds. To ensure the socket is closed in a reasonable amount of time, Spring Session runs a background task every minute at 00 seconds that forcibly cleans up any expired sessions. This means you need to wait at most two minutes before the WebSocket connection is closed. You can now try accessing localhost:8080/(http://localhost:8080/) You are prompted to authenticate again. This demonstrates that the session properly expires. Now repeat the same exercise, but instead of waiting two minutes, send a message from each of the users every 30 seconds. You can see that the messages continue to be sent. Try accessing localhost:8080/(http://localhost:8080/) You are not prompted to authenticate again. This demonstrates the session is kept alive. Only messages sent from a user keep the session alive. This is because only messages coming from a user imply user activity. Received messages do not imply activity and, thus, do not renew the session expiration."
"https://github.com/spring-projects/spring-session/tree/3.0.4/spring-session-samples/spring-session-sample-boot-webflux",""
"https://docs.spring.io/spring-session/reference/3.0/guides/boot-webflux-custom-cookie.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/boot-webflux-custom-cookie.html) ! Spring Session - WebFlux with Custom Cookie: This guide describes how to configure Spring Session to use custom cookies in a WebFlux based application. The guide assumes you have already set up Spring Session in your project using your chosen data store. For example, HttpSession with Redis(./boot-redis.html) . You can find the completed guide in the WebFlux Custom Cookie sample application(#webflux-custom-cookie-sample) . Index(../index.html) Spring Boot Configuration: Once you have set up Spring Session, you can customize how the session cookie is written by exposing a WebSessionIdResolver as a Spring bean. Spring Session uses a CookieWebSessionIdResolver by default. Exposing the WebSessionIdResolver as a Spring bean augments the existing configuration when you use configurations like @EnableRedisHttpSession . The following example shows how to customize Spring Session’s cookie: @Bean public WebSessionIdResolver webSessionIdResolver() { CookieWebSessionIdResolver resolver = new CookieWebSessionIdResolver(); resolver.setCookieName(""JSESSIONID""); (1) resolver.addCookieInitializer((builder) -> builder.path(""/"")); (2) resolver.addCookieInitializer((builder) -> builder.sameSite(""Strict"")); (3) return resolver; } 1 We customize the name of the cookie to be JSESSIONID . 2 We customize the path of the cookie to be / (rather than the default of the context root). 3 We customize the SameSite cookie directive to be Strict . webflux-custom-cookie Sample Application: This section describes how to work with the webflux-custom-cookie sample application. Running the webflux-custom-cookie Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: $ ./gradlew :spring-session-sample-boot-webflux-custom-cookie:bootRun For the sample to work, you must install Redis 2.8+(https://redis.io/download) on localhost and run it with the default port (6379). Alternatively, you can update the RedisConnectionFactory to point to a Redis server. Another option is to use Docker(https://www.docker.com/) to run Redis on localhost. See Docker Redis repository(https://hub.docker.com/_/redis/) for detailed instructions. You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the webflux-custom-cookie Sample Application: Now you can use the application. Fill out the form with the following information: Attribute Name: username Attribute Value: rob Now click the Set Attribute button. You should now see the values displayed in the table. If you look at the cookies for the application, you can see the cookie is saved to the custom name of JSESSIONID ."
"https://docs.spring.io/spring-session/reference/3.0/guides/java-custom-cookie.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/java-custom-cookie.html) ! Spring Session - Custom Cookie: This guide describes how to configure Spring Session to use custom cookies with Java Configuration. The guide assumes you have already set up Spring Session in your project using your chosen data store. For example, HttpSession with Redis(./boot-redis.html) . You can find the completed guide in the Custom Cookie sample application(#custom-cookie-sample) . Index(../index.html) Spring Java Configuration: Once you have set up Spring Session, you can customize how the session cookie is written by exposing a CookieSerializer as a Spring bean. Spring Session comes with DefaultCookieSerializer . Exposing the DefaultCookieSerializer as a Spring bean augments the existing configuration when you use configurations like @EnableRedisHttpSession . The following example shows how to customize Spring Session’s cookie: @Bean public CookieSerializer cookieSerializer() { DefaultCookieSerializer serializer = new DefaultCookieSerializer(); serializer.setCookieName(""JSESSIONID""); (1) serializer.setCookiePath(""/""); (2) serializer.setDomainNamePattern(""^.+?\\.(\\w+\\.[a-z]+)$""); (3) return serializer; } 1 We customize the name of the cookie to be JSESSIONID . 2 We customize the path of the cookie to be / (rather than the default of the context root). 3 We customize the domain name pattern (a regular expression) to be ^.?\\.(\\w\\.[a-z]+)$ . This allows sharing a session across domains and applications. If the regular expression does not match, no domain is set and the existing domain is used. If the regular expression matches, the first grouping(https://docs.oracle.com/javase/tutorial/essential/regex/groups.html) is used as the domain. This means that a request to child.example.com(https://child.example.com) sets the domain to example.com . However, a request to localhost:8080/(http://localhost:8080/) or 192.168.1.100:8080/(https://192.168.1.100:8080/) leaves the cookie unset and, thus, still works in development without any changes being necessary for production. You should only match on valid domain characters, since the domain name is reflected in the response. Doing so prevents a malicious user from performing such attacks as HTTP Response Splitting(https://en.wikipedia.org/wiki/HTTP_response_splitting) . Configuration Options: The following configuration options are available: cookieName : The name of the cookie to use. Default: SESSION . useSecureCookie : Specifies whether a secure cookie should be used. Default: Use the value of HttpServletRequest.isSecure() at the time of creation. cookiePath : The path of the cookie. Default: The context root. cookieMaxAge : Specifies the max age of the cookie to be set at the time the session is created. Default: -1 , which indicates the cookie should be removed when the browser is closed. jvmRoute : Specifies a suffix to be appended to the session ID and included in the cookie. Used to identify which JVM to route to for session affinity. With some implementations (that is, Redis) this option provides no performance benefit. However, it can help with tracing logs of a particular user. domainName : Allows specifying a specific domain name to be used for the cookie. This option is simple to understand but often requires a different configuration between development and production environments. See domainNamePattern as an alternative. domainNamePattern : A case-insensitive pattern used to extract the domain name from the HttpServletRequest#getServerName() . The pattern should provide a single grouping that is used to extract the value of the cookie domain. If the regular expression does not match, no domain is set and the existing domain is used. If the regular expression matches, the first grouping(https://docs.oracle.com/javase/tutorial/essential/regex/groups.html) is used as the domain. sameSite : The value for the SameSite cookie directive. To disable the serialization of the SameSite cookie directive, you may set this value to null . Default: Lax You should only match on valid domain characters, since the domain name is reflected in the response. Doing so prevents a malicious user from performing such attacks as HTTP Response Splitting(https://en.wikipedia.org/wiki/HTTP_response_splitting) . custom-cookie Sample Application: This section describes how to work with the custom-cookie sample application. Running the custom-cookie Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: $ ./gradlew :spring-session-sample-javaconfig-custom-cookie:tomcatRun For the sample to work, you must install Redis 2.8+(https://redis.io/download) on localhost and run it with the default port (6379). Alternatively, you can update the RedisConnectionFactory to point to a Redis server. Another option is to use Docker(https://www.docker.com/) to run Redis on localhost. See Docker Redis repository(https://hub.docker.com/_/redis/) for detailed instructions. You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the custom-cookie Sample Application: Now you can use the application. Fill out the form with the following information: Attribute Name: username Attribute Value: rob Now click the Set Attribute button. You should now see the values displayed in the table. If you look at the cookies for the application, you can see the cookie is saved to the custom name of JSESSIONID ."
"https://docs.spring.io/spring-session/reference/3.0/guides/java-redis.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/java-redis.html) ! Spring Session - HttpSession (Quick Start): This guide describes how to use Spring Session to transparently leverage Redis to back a web application’s HttpSession with Java Configuration. You can find the completed guide in the httpsession sample application(#httpsession-sample) . Index(../index.html) Updating Dependencies: Before you use Spring Session, you must update your dependencies. If you are using Maven, you must add the following dependencies: pom.xml <dependencies> <!-- ... --> <dependency> <groupId>org.springframework.session</groupId> <artifactId>spring-session-data-redis</artifactId> <version>3.0.4</version> <type>pom</type> </dependency> <dependency> <groupId>io.lettuce</groupId> <artifactId>lettuce-core</artifactId> <version>6.2.1.RELEASE</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-web</artifactId> <version>6.0.13</version> </dependency> </dependencies> Since we are using a SNAPSHOT version, we need to ensure to add the Spring Snapshot Maven Repository. You must have the following in your pom.xml: pom.xml <repositories> <!-- ... --> <repository> <id>spring-snapshot</id> <url>https://repo.spring.io/libs-snapshot</url> </repository> </repositories> Spring Java Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a servlet filter that replaces the HttpSession implementation with an implementation backed by Spring Session. To do so, add the following Spring Configuration: @Configuration(proxyBeanMethods = false) @EnableRedisHttpSession (1) public class Config { @Bean public LettuceConnectionFactory connectionFactory() { return new LettuceConnectionFactory(); (2) } } 1 The @EnableRedisHttpSession annotation creates a Spring Bean with the name of springSessionRepositoryFilter that implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by Redis. 2 We create a RedisConnectionFactory that connects Spring Session to the Redis Server. We configure the connection to connect to localhost on the default port (6379). For more information on configuring Spring Data Redis, see the reference documentation(https://docs.spring.io/spring-data/data-redis/docs/3.0.11/reference/html/) . Java Servlet Container Initialization: Our Spring Configuration(#httpsession-spring-configuration) created a Spring Bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our Config class. Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. Fortunately, Spring Session provides a utility class named AbstractHttpSessionApplicationInitializer to make both of these steps easy. The following shows an example: src/main/java/sample/Initializer.java public class Initializer extends AbstractHttpSessionApplicationInitializer { (1) public Initializer() { super(Config.class); (2) } } The name of our class ( Initializer ) does not matter. What is important is that we extend AbstractHttpSessionApplicationInitializer . 1 The first step is to extend AbstractHttpSessionApplicationInitializer . Doing so ensures that the Spring Bean by the name of springSessionRepositoryFilter is registered with our Servlet Container for every request. 2 AbstractHttpSessionApplicationInitializer also provides a mechanism to ensure Spring loads our Config . httpsession Sample Application: Running the httpsession Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: $ ./gradlew :spring-session-sample-javaconfig-redis:tomcatRun For the sample to work, you must install Redis 2.8+(https://redis.io/download) on localhost and run it with the default port (6379). Alternatively, you can update the RedisConnectionFactory to point to a Redis server. Another option is to use Docker(https://www.docker.com/) to run Redis on localhost. See Docker Redis repository(https://hub.docker.com/_/redis/) for detailed instructions. You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the httpsession Sample Application: Now you can try to use the application. To do so, fill out the form with the following information: Attribute Name: username Attribute Value: rob Now click the Set Attribute button. You should now see the values displayed in the table. How Does It Work?: We interact with the standard HttpSession in the SessionServlet shown in the following listing: src/main/java/sample/SessionServlet.java @WebServlet(""/session"") public class SessionServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException { String attributeName = req.getParameter(""attributeName""); String attributeValue = req.getParameter(""attributeValue""); req.getSession().setAttribute(attributeName, attributeValue); resp.sendRedirect(req.getContextPath() + ""/""); } private static final long serialVersionUID = 2878267318695777395L; } Instead of using Tomcat’s HttpSession , we persist the values in Redis. Spring Session creates a cookie named SESSION in your browser. That cookie contains the ID of your session. You can view the cookies (with Chrome(https://developers.google.com/web/tools/chrome-devtools/manage-data/cookies) or Firefox(https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector) ). You can remove the session by using redis-cli. For example, on a Linux based system you can type the following: $ redis-cli keys '*' | xargs redis-cli del The Redis documentation has instructions for installing redis-cli(https://redis.io/topics/quickstart) . Alternatively, you can also delete the explicit key. Enter the following into your terminal, being sure to replace 7e8383a4-082c-4ffe-a4bc-c40fd3363c5e with the value of your SESSION cookie: $ redis-cli del spring:session:sessions:7e8383a4-082c-4ffe-a4bc-c40fd3363c5e Now you can visit the application at localhost:8080/(http://localhost:8080/) and see that the attribute we added is no longer displayed."
"https://docs.spring.io/spring-session/reference/3.0/guides/java-jdbc.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/java-jdbc.html) ! Spring Session - HttpSession (Quick Start): This guide describes how to use Spring Session to transparently leverage a relational database to back a web application’s HttpSession with Java Configuration. You can find the completed guide in the httpsession-jdbc sample application(#httpsession-jdbc-sample) . Index(../index.html) Updating Dependencies: Before you use Spring Session, you must update your dependencies. If you use Maven, you must add the following dependencies: pom.xml <dependencies> <!-- ... --> <dependency> <groupId>org.springframework.session</groupId> <artifactId>spring-session-jdbc</artifactId> <version>3.0.4</version> <type>pom</type> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-web</artifactId> <version>6.0.13</version> </dependency> </dependencies> Spring Java Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a Servlet Filter that replaces the HttpSession implementation with an implementation backed by Spring Session. To do so, add the following Spring Configuration: @Configuration(proxyBeanMethods = false) @EnableJdbcHttpSession (1) public class Config { @Bean public EmbeddedDatabase dataSource() { return new EmbeddedDatabaseBuilder() (2) .setType(EmbeddedDatabaseType.H2).addScript(""org/springframework/session/jdbc/schema-h2.sql"").build(); } @Bean public PlatformTransactionManager transactionManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); (3) } } 1 The @EnableJdbcHttpSession annotation creates a Spring Bean with the name of springSessionRepositoryFilter . That bean implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by a relational database. 2 We create a dataSource that connects Spring Session to an embedded instance of an H2 database. We configure the H2 database to create database tables by using the SQL script that is included in Spring Session. 3 We create a transactionManager that manages transactions for previously configured dataSource . For additional information on how to configure data access related concerns, see the Spring Framework Reference Documentation(https://docs.spring.io/spring/docs/6.0.13/reference/html/data-access.html) . Java Servlet Container Initialization: Our Spring Configuration(#httpsession-jdbc-spring-configuration) created a Spring bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our Config class. Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. Fortunately, Spring Session provides a utility class named AbstractHttpSessionApplicationInitializer to make both of these steps easy. The following example shows how to do so: src/main/java/sample/Initializer.java public class Initializer extends AbstractHttpSessionApplicationInitializer { (1) public Initializer() { super(Config.class); (2) } } The name of our class (Initializer) does not matter. What is important is that we extend AbstractHttpSessionApplicationInitializer . 1 The first step is to extend AbstractHttpSessionApplicationInitializer . Doing so ensures that the Spring bean named springSessionRepositoryFilter is registered with our Servlet Container for every request. 2 AbstractHttpSessionApplicationInitializer also provides a mechanism to ensure Spring loads our Config . Multiple DataSources: Spring Session provides the @SpringSessionDataSource qualifier, allowing you to explicitly declare which DataSource bean should be injected in JdbcIndexedSessionRepository . This is particularly useful in scenarios with multiple DataSource beans present in the application context. The following example shows how to do so: Config.java @EnableJdbcHttpSession public class Config { @Bean @SpringSessionDataSource (1) public EmbeddedDatabase firstDataSource() { return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2).addScript(""org/springframework/session/jdbc/schema-h2.sql"").build(); } @Bean public HikariDataSource secondDataSource() { // ... } } 1 This qualifier declares that firstDataSource is to be used by Spring Session. httpsession-jdbc Sample Application: This section describes how to work with the httpsession-jdbc Sample Application. Running the httpsession-jdbc Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: $ ./gradlew :spring-session-sample-javaconfig-jdbc:tomcatRun You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the httpsession-jdbc Sample Application: Now you can try using the application. To do so, fill out the form with the following information: Attribute Name: username Attribute Value: rob Now click the Set Attribute button. You should now see the values displayed in the table. How Does It Work?: We interact with the standard HttpSession in the SessionServlet shown in the following listing: src/main/java/sample/SessionServlet.java @WebServlet(""/session"") public class SessionServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException { String attributeName = req.getParameter(""attributeName""); String attributeValue = req.getParameter(""attributeValue""); req.getSession().setAttribute(attributeName, attributeValue); resp.sendRedirect(req.getContextPath() + ""/""); } private static final long serialVersionUID = 2878267318695777395L; } Instead of using Tomcat’s HttpSession , we persist the values in H2 database. Spring Session creates a cookie named SESSION in your browser. That cookie contains the ID of your session. You can view the cookies (with Chrome(https://developers.google.com/web/tools/chrome-devtools/manage-data/cookies) or Firefox(https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector) ). If you like, you can remove the session by using the H2 web console available at: localhost:8080/h2-console/(http://localhost:8080/h2-console/) (use jdbc:h2:mem:testdb for JDBC URL). Now you can visit the application at localhost:8080/(http://localhost:8080/) and see that the attribute we added is no longer displayed."
"https://docs.spring.io/spring-session/reference/3.0/guides/java-hazelcast.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/java-hazelcast.html) ! Spring Session and Spring Security with Hazelcast: This guide describes how to use Spring Session along with Spring Security when you use Hazelcast as your data store. It assumes that you have already applied Spring Security to your application. You cand find the completed guide in the Hazelcast Spring Security sample application(#hazelcast-spring-security-sample) . Index(../index.html) Updating Dependencies: Before you use Spring Session, you must update your dependencies. If you use Maven, you must add the following dependencies: pom.xml <dependencies> <!-- ... --> <dependency> <groupId>com.hazelcast</groupId> <artifactId>hazelcast</artifactId> <version>5.1.4</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-web</artifactId> <version>6.0.13</version> </dependency> </dependencies> Spring Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a servlet filter that replaces the HttpSession implementation with an implementation backed by Spring Session. To do so, add the following Spring Configuration: @EnableHazelcastHttpSession (1) @Configuration public class HazelcastHttpSessionConfig { @Bean public HazelcastInstance hazelcastInstance() { Config config = new Config(); AttributeConfig attributeConfig = new AttributeConfig() .setName(HazelcastIndexedSessionRepository.PRINCIPAL_NAME_ATTRIBUTE) .setExtractorClassName(PrincipalNameExtractor.class.getName()); config.getMapConfig(HazelcastIndexedSessionRepository.DEFAULT_SESSION_MAP_NAME) (2) .addAttributeConfig(attributeConfig).addIndexConfig( new IndexConfig(IndexType.HASH, HazelcastIndexedSessionRepository.PRINCIPAL_NAME_ATTRIBUTE)); SerializerConfig serializerConfig = new SerializerConfig(); serializerConfig.setImplementation(new HazelcastSessionSerializer()).setTypeClass(MapSession.class); config.getSerializationConfig().addSerializerConfig(serializerConfig); (3) return Hazelcast.newHazelcastInstance(config); (4) } } 1 The @EnableHazelcastHttpSession annotation creates a Spring bean named springSessionRepositoryFilter that implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by Hazelcast. 2 In order to support retrieval of sessions by principal name index, an appropriate ValueExtractor needs to be registered. Spring Session provides PrincipalNameExtractor for this purpose. 3 In order to serialize MapSession objects efficiently, HazelcastSessionSerializer needs to be registered. If this is not set, Hazelcast will serialize sessions using native Java serialization. 4 We create a HazelcastInstance that connects Spring Session to Hazelcast. By default, the application starts and connects to an embedded instance of Hazelcast. For more information on configuring Hazelcast, see the reference documentation(https://docs.hazelcast.com/hazelcast/latest/) . If HazelcastSessionSerializer is preferred, it needs to be configured for all Hazelcast cluster members before they start. In a Hazelcast cluster, all members should use the same serialization method for sessions. Also, if Hazelcast Client/Server topology is used, then both members and clients must use the same serialization method. The serializer can be registered via ClientConfig with the same SerializerConfiguration of members. Servlet Container Initialization: Our Spring Configuration(java-security.html#security-spring-configuration) created a Spring bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our SessionConfig class. Since our application is already loading Spring configuration by using our SecurityInitializer class, we can add our SessionConfig class to it. The following listing shows how to do so: src/main/java/sample/SecurityInitializer.java public class SecurityInitializer extends AbstractSecurityWebApplicationInitializer { public SecurityInitializer() { super(SecurityConfig.class, SessionConfig.class); } } Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. It is extremely important that Spring Session’s springSessionRepositoryFilter is invoked before Spring Security’s springSecurityFilterChain . Doing so ensures that the HttpSession that Spring Security uses is backed by Spring Session. Fortunately, Spring Session provides a utility class named AbstractHttpSessionApplicationInitializer that makes this doing so easy. The following example shows how to do so: src/main/java/sample/Initializer.java public class Initializer extends AbstractHttpSessionApplicationInitializer { } The name of our class ( Initializer ) does not matter. What is important is that we extend AbstractHttpSessionApplicationInitializer . By extending AbstractHttpSessionApplicationInitializer , we ensure that the Spring Bean named springSessionRepositoryFilter is registered with our servlet container for every request before Spring Security’s springSecurityFilterChain . Hazelcast Spring Security Sample Application: This section describes how to work with the Hazelcast Spring Security sample application. Running the Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: $ ./gradlew :spring-session-sample-javaconfig-hazelcast:tomcatRun By default, Hazelcast runs in embedded mode with your application. However, if you want to connect to a standalone instance instead, you can configure it by following the instructions in the reference documentation(https://docs.hazelcast.com/hazelcast/latest/getting-started/get-started-cli) . You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the Security Sample Application: You can now try using the application. To do so, enter the following to log in: Username user Password password Now click the Login button. You should now see a message indicating that your are logged in with the user entered previously. The user’s information is stored in Hazelcast rather than Tomcat’s HttpSession implementation. How Does It Work?: Instead of using Tomcat’s HttpSession , we persist the values in Hazelcast. Spring Session replaces the HttpSession with an implementation that is backed by a Map in Hazelcast. When Spring Security’s SecurityContextPersistenceFilter saves the SecurityContext to the HttpSession , it is then persisted into Hazelcast. When a new HttpSession is created, Spring Session creates a cookie named SESSION in your browser. That cookie contains the ID of your session. You can view the cookies (with Chrome(https://developers.google.com/web/tools/chrome-devtools/manage-data/cookies) or Firefox(https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector) ). Interacting with the Data Store: You can remove the session by using a Java client(https://docs.hazelcast.com/hazelcast/latest/clients/java) , one of the other clients(https://hazelcast.com/clients/) , or the management center(https://docs.hazelcast.com/management-center/latest/getting-started/overview) . Using the Console: For example, to remove the session by using the management center console after connecting to your Hazelcast node, run the following commands: default> ns spring:session:sessions spring:session:sessions> m.clear The Hazelcast documentation has instructions for the console(https://docs.hazelcast.com/hazelcast/latest/clients/clc) . Alternatively, you can also delete the explicit key. Enter the following into the console, being sure to replace 7e8383a4-082c-4ffe-a4bc-c40fd3363c5e with the value of your SESSION cookie: spring:session:sessions> m.remove 7e8383a4-082c-4ffe-a4bc-c40fd3363c5e Now visit the application at localhost:8080/(http://localhost:8080/) and observe that we are no longer authenticated. Using the REST API: As described in the section of the documentation that cover other clients, there is a REST API(https://docs.hazelcast.com/hazelcast/latest/clients/rest) provided by the Hazelcast node(s). For example, you could delete an individual key as follows (being sure to replace 7e8383a4-082c-4ffe-a4bc-c40fd3363c5e with the value of your SESSION cookie): $ curl -v -X DELETE http://localhost:xxxxx/hazelcast/rest/maps/spring:session:sessions/7e8383a4-082c-4ffe-a4bc-c40fd3363c5e The port number of the Hazelcast node is printed to the console on startup. Replace xxxxx with the port number. Now you can see that you are no longer authenticated with this session."
"https://docs.spring.io/spring-session/reference/3.0/guides/java-rest.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/java-rest.html) ! Spring Session - REST: This guide describes how to use Spring Session to transparently leverage Redis to back a web application’s HttpSession when you use REST endpoints. You can find the completed guide in the rest sample application(#rest-sample) . Index(../index.html) Updating Dependencies: Before you use Spring Session, you must update your dependencies. If you use Maven, you must add the following dependencies: pom.xml <dependencies> <!-- ... --> <dependency> <groupId>org.springframework.session</groupId> <artifactId>spring-session-data-redis</artifactId> <version>3.0.4</version> <type>pom</type> </dependency> <dependency> <groupId>io.lettuce</groupId> <artifactId>lettuce-core</artifactId> <version>6.2.1.RELEASE</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-web</artifactId> <version>6.0.13</version> </dependency> </dependencies> Spring Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a servlet filter that replaces the HttpSession implementation with an implementation backed by Spring Session. To do so, add the following Spring Configuration: @Configuration @EnableRedisHttpSession (1) public class HttpSessionConfig { @Bean public LettuceConnectionFactory connectionFactory() { return new LettuceConnectionFactory(); (2) } @Bean public HttpSessionIdResolver httpSessionIdResolver() { return HeaderHttpSessionIdResolver.xAuthToken(); (3) } } 1 The @EnableRedisHttpSession annotation creates a Spring bean named springSessionRepositoryFilter that implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by Redis. 2 We create a RedisConnectionFactory that connects Spring Session to the Redis Server. We configure the connection to connect to localhost on the default port (6379). For more information on configuring Spring Data Redis, see the reference documentation(https://docs.spring.io/spring-data/data-redis/docs/3.0.11/reference/html/) . 3 We customize Spring Session’s HttpSession integration to use HTTP headers to convey the current session information instead of cookies. Servlet Container Initialization: Our Spring Configuration(#rest-spring-configuration) created a Spring Bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our Config class. We provide the configuration in our Spring MvcInitializer , as the following example shows: src/main/java/sample/mvc/MvcInitializer.java @Override protected Class<?>[] getRootConfigClasses() { return new Class[] { SecurityConfig.class, HttpSessionConfig.class }; } Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. Fortunately, Spring Session provides a utility class named AbstractHttpSessionApplicationInitializer that makes doing so easy. To do so, extend the class with the default constructor, as the following example shows: src/main/java/sample/Initializer.java public class Initializer extends AbstractHttpSessionApplicationInitializer { } The name of our class ( Initializer ) does not matter. What is important is that we extend AbstractHttpSessionApplicationInitializer . rest Sample Application: This section describes how to use the rest sample application. Running the rest Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: For the sample to work, you must install Redis 2.8+(https://redis.io/download) on localhost and run it with the default port (6379). Alternatively, you can update the RedisConnectionFactory to point to a Redis server. Another option is to use Docker(https://www.docker.com/) to run Redis on localhost. See Docker Redis repository(https://hub.docker.com/_/redis/) for detailed instructions. $ ./gradlew :spring-session-sample-javaconfig-rest:tomcatRun You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the rest Sample Application: You can now try to use the application. To do so, use your favorite REST client to request localhost:8080/(http://localhost:8080/) $ curl -v http://localhost:8080/ Note that you are prompted for basic authentication. Provide the following information for the username and password: Username user Password password Then run the following command: $ curl -v http://localhost:8080/ -u user:password In the output, you should notice the following: HTTP/1.1 200 OK ... X-Auth-Token: 0dc1f6e1-c7f1-41ac-8ce2-32b6b3e57aa3 {""username"":""user""} Specifically, you should notice the following things about our response: The HTTP Status is now a 200. We have a header a the name of X-Auth-Token and that contains a new session ID. The current username is displayed. We can now use the X-Auth-Token to make another request without providing the username and password again. For example, the following command outputs the username, as before: $ curl -v http://localhost:8080/ -H ""X-Auth-Token: 0dc1f6e1-c7f1-41ac-8ce2-32b6b3e57aa3"" The only difference is that the session ID is not provided in the response headers because we are reusing an existing session. If we invalidate the session, the X-Auth-Token is displayed in the response with an empty value. For example, the following command invalidates our session: $ curl -v http://localhost:8080/logout -H ""X-Auth-Token: 0dc1f6e1-c7f1-41ac-8ce2-32b6b3e57aa3"" You can see in the output that the X-Auth-Token provides an empty String indicating that the previous session was invalidated: HTTP/1.1 204 No Content ... X-Auth-Token: How Does It Work?: Spring Security interacts with the standard HttpSession in SecurityContextPersistenceFilter . Instead of using Tomcat’s HttpSession , Spring Security is now persisting the values in Redis. Spring Session creates a header named X-Auth-Token in your browser. That header contains the ID of your session. If you like, you can easily see that the session is created in Redis. To do so, create a session by using the following command: $ curl -v http://localhost:8080/ -u user:password In the output, you should notice the following: HTTP/1.1 200 OK ... X-Auth-Token: 7e8383a4-082c-4ffe-a4bc-c40fd3363c5e {""username"":""user""} Now you can remove the session by using redis-cli. For example, on a Linux based system, you can type: $ redis-cli keys '*' | xargs redis-cli del The Redis documentation has instructions for installing redis-cli(https://redis.io/topics/quickstart) . Alternatively, you can also delete the explicit key. To do so, enter the following into your terminal, being sure to replace 7e8383a4-082c-4ffe-a4bc-c40fd3363c5e with the value of your SESSION cookie: $ redis-cli del spring:session:sessions:7e8383a4-082c-4ffe-a4bc-c40fd3363c5e We can now use the X-Auth-Token to make another request with the session we deleted and observe we that are prompted for authentication. For example, the following returns an HTTP 401: $ curl -v http://localhost:8080/ -H ""X-Auth-Token: 0dc1f6e1-c7f1-41ac-8ce2-32b6b3e57aa3"""
"https://docs.spring.io/spring-session/reference/3.0/guides/java-security.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/java-security.html) ! Spring Session and Spring Security: This guide describes how to use Spring Session along with Spring Security. It assumes you have already applied Spring Security to your application. You can find the completed guide in the security sample application(#security-sample) . Index(../index.html) Updating Dependencies: Before you use Spring Session, you must update your dependencies. If you use Maven, you must add the following dependencies: pom.xml <dependencies> <!-- ... --> <dependency> <groupId>org.springframework.session</groupId> <artifactId>spring-session-data-redis</artifactId> <version>3.0.4</version> <type>pom</type> </dependency> <dependency> <groupId>io.lettuce</groupId> <artifactId>lettuce-core</artifactId> <version>6.2.1.RELEASE</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-web</artifactId> <version>6.0.13</version> </dependency> </dependencies> Spring Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a servlet filter that replaces the HttpSession implementation with an implementation backed by Spring Session. To do so, add the following Spring Configuration: @Configuration @EnableRedisHttpSession (1) public class Config { @Bean public LettuceConnectionFactory connectionFactory() { return new LettuceConnectionFactory(); (2) } } 1 The @EnableRedisHttpSession annotation creates a Spring bean with the name of springSessionRepositoryFilter that implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance Spring Session is backed by Redis. 2 We create a RedisConnectionFactory that connects Spring Session to the Redis Server. We configure the connection to connect to localhost on the default port (6379) For more information on configuring Spring Data Redis, see the reference documentation(https://docs.spring.io/spring-data/data-redis/docs/3.0.11/reference/html/) . Servlet Container Initialization: Our Spring Configuration(#security-spring-configuration) created a Spring bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our Config class. Since our application is already loading Spring configuration by using our SecurityInitializer class, we can add our configuration class to it. The following example shows how to do so: src/main/java/sample/SecurityInitializer.java public class SecurityInitializer extends AbstractSecurityWebApplicationInitializer { public SecurityInitializer() { super(SecurityConfig.class, Config.class); } } Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. It is extremely important that Spring Session’s springSessionRepositoryFilter is invoked before Spring Security’s springSecurityFilterChain . This ensures that the HttpSession that Spring Security uses is backed by Spring Session. Fortunately, Spring Session provides a utility class named AbstractHttpSessionApplicationInitializer that makes doing so easy. The following example shows how to do so: src/main/java/sample/Initializer.java public class Initializer extends AbstractHttpSessionApplicationInitializer { } The name of our class (Initializer) does not matter. What is important is that we extend AbstractHttpSessionApplicationInitializer . By extending AbstractHttpSessionApplicationInitializer , we ensure that the Spring bean named springSessionRepositoryFilter is registered with our Servlet Container for every request before Spring Security’s springSecurityFilterChain . security Sample Application: This section describes how to work with the security sample application. Running the security Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: $ ./gradlew :spring-session-sample-javaconfig-security:tomcatRun For the sample to work, you must install Redis 2.8+(https://redis.io/download) on localhost and run it with the default port (6379). Alternatively, you can update the RedisConnectionFactory to point to a Redis server. Another option is to use Docker(https://www.docker.com/) to run Redis on localhost. See Docker Redis repository(https://hub.docker.com/_/redis/) for detailed instructions. You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the security Sample Application: Now you can use the application. Enter the following to log in: Username user Password password Now click the Login button. You should now see a message indicating your are logged in with the user entered previously. The user’s information is stored in Redis rather than Tomcat’s HttpSession implementation. How Does It Work?: Instead of using Tomcat’s HttpSession , we persist the values in Redis. Spring Session replaces the HttpSession with an implementation that is backed by Redis. When Spring Security’s SecurityContextPersistenceFilter saves the SecurityContext to the HttpSession , it is then persisted into Redis. When a new HttpSession is created, Spring Session creates a cookie named SESSION in your browser. That cookie contains the ID of your session. You can view the cookies (with Chrome(https://developers.google.com/web/tools/chrome-devtools/manage-data/cookies) or Firefox(https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector) ). You can remove the session using redis-cli. For example, on a Linux-based system you can type the following command: $ redis-cli keys '*' | xargs redis-cli del The Redis documentation has instructions for installing redis-cli(https://redis.io/topics/quickstart) . Alternatively, you can also delete the explicit key. Enter the following command into your terminal, being sure to replace 7e8383a4-082c-4ffe-a4bc-c40fd3363c5e with the value of your SESSION cookie: $ redis-cli del spring:session:sessions:7e8383a4-082c-4ffe-a4bc-c40fd3363c5e Now you can visit the application at localhost:8080/(http://localhost:8080/) and see that we are no longer authenticated."
"https://docs.spring.io/spring-session/reference/3.0/guides/xml-redis.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/xml-redis.html) ! Spring Session - HttpSession (Quick Start): This guide describes how to use Spring Session to transparently leverage Redis to back a web application’s HttpSession with XML-based configuration. You can find the completed guide in the httpsession-xml sample application(#httpsession-xml-sample) . Index(../index.html) Updating Dependencies: Before you use Spring Session, you must update your dependencies. If you use Maven, you must add the following dependencies: pom.xml <dependencies> <!-- ... --> <dependency> <groupId>org.springframework.session</groupId> <artifactId>spring-session-data-redis</artifactId> <version>3.0.4</version> <type>pom</type> </dependency> <dependency> <groupId>io.lettuce</groupId> <artifactId>lettuce-core</artifactId> <version>6.2.1.RELEASE</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-web</artifactId> <version>6.0.13</version> </dependency> </dependencies> Spring XML Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a servlet filter that replaces the HttpSession implementation with an implementation backed by Spring Session. To do so, add the following Spring Configuration: src/main/webapp/WEB-INF/spring/session.xml (1) <context:annotation-config/> <bean class=""org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration""/> (2) <bean class=""org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory""/> 1 We use the combination of <context:annotation-config/> and RedisHttpSessionConfiguration because Spring Session does not yet provide XML Namespace support (see gh-104(https://github.com/spring-projects/spring-session/issues/104) ). This creates a Spring Bean with the name of springSessionRepositoryFilter that implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by Redis. 2 We create a RedisConnectionFactory that connects Spring Session to the Redis Server. We configure the connection to connect to localhost on the default port (6379) For more information on configuring Spring Data Redis, see the reference documentation(https://docs.spring.io/spring-data/data-redis/docs/3.0.11/reference/html/) . XML Servlet Container Initialization: Our Spring Configuration(#httpsession-xml-spring-configuration) created a Spring Bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, we need to instruct Spring to load our session.xml configuration. We can do so with the following configuration: src/main/webapp/WEB-INF/web.xml <context-param> <param-name>contextConfigLocation</param-name> <param-value> /WEB-INF/spring/session.xml </param-value> </context-param> <listener> <listener-class> org.springframework.web.context.ContextLoaderListener </listener-class> </listener> The ContextLoaderListener(https://docs.spring.io/spring/docs/6.0.13/spring-framework-reference/core.html#context-create) reads the contextConfigLocation and picks up our session.xml configuration. Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. The following snippet performs this last step for us: src/main/webapp/WEB-INF/web.xml <filter> <filter-name>springSessionRepositoryFilter</filter-name> <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class> </filter> <filter-mapping> <filter-name>springSessionRepositoryFilter</filter-name> <url-pattern>/*</url-pattern> <dispatcher>REQUEST</dispatcher> <dispatcher>ERROR</dispatcher> </filter-mapping> The DelegatingFilterProxy(https://docs.spring.io/spring-framework/docs/6.0.13/javadoc-api/org/springframework/web/filter/DelegatingFilterProxy.html) looks up a Bean by the name of springSessionRepositoryFilter and cast it to a Filter . For every request that DelegatingFilterProxy is invoked, the springSessionRepositoryFilter is invoked. httpsession-xml Sample Application: This section describes how to work with the httpsession-xml sample application. Running the httpsession-xml Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: For the sample to work, you must install Redis 2.8+(https://redis.io/download) on localhost and run it with the default port (6379). Alternatively, you can update the RedisConnectionFactory to point to a Redis server. Another option is to use Docker(https://www.docker.com/) to run Redis on localhost. See Docker Redis repository(https://hub.docker.com/_/redis/) for detailed instructions. $ ./gradlew :spring-session-sample-xml-redis:tomcatRun You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the httpsession-xml Sample Application: Now you can try using the application. Fill out the form with the following information: Attribute Name: username Attribute Value: rob Now click the Set Attribute button. You should now see the values displayed in the table. How Does It Work?: We interact with the standard HttpSession in the SessionServlet shown in the following listing: src/main/java/sample/SessionServlet.java public class SessionServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException { String attributeName = req.getParameter(""attributeName""); String attributeValue = req.getParameter(""attributeValue""); req.getSession().setAttribute(attributeName, attributeValue); resp.sendRedirect(req.getContextPath() + ""/""); } private static final long serialVersionUID = 2878267318695777395L; } Instead of using Tomcat’s HttpSession , we persist the values in Redis. Spring Session creates a cookie named SESSION in your browser. That cookie contains the ID of your session. You can view the cookies (with Chrome(https://developers.google.com/web/tools/chrome-devtools/manage-data/cookies) or Firefox(https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector) ). You can remove the session using redis-cli. For example, on a Linux based system you can type the following: $ redis-cli keys '*' | xargs redis-cli del The Redis documentation has instructions for installing redis-cli(https://redis.io/topics/quickstart) . Alternatively, you can also delete the explicit key. To do so, enter the following into your terminal, being sure to replace 7e8383a4-082c-4ffe-a4bc-c40fd3363c5e with the value of your SESSION cookie: $ redis-cli del spring:session:sessions:7e8383a4-082c-4ffe-a4bc-c40fd3363c5e Now you can visit the application at localhost:8080/(http://localhost:8080/) and see that the attribute we added is no longer displayed."
"https://docs.spring.io/spring-session/reference/3.0/guides/xml-jdbc.html","For the latest stable version, please use Spring Session 3.3.2(../../guides/xml-jdbc.html) ! Spring Session - HttpSession (Quick Start): This guide describes how to use Spring Session to transparently leverage a relational to back a web application’s HttpSession with XML based configuration. You can find the completed guide in the httpsession-jdbc-xml sample application(#httpsession-jdbc-xml-sample) . Index(../index.html) Updating Dependencies: Before you use Spring Session, you must update your dependencies. If you are using Maven, you must add the following dependencies: pom.xml <dependencies> <!-- ... --> <dependency> <groupId>org.springframework.session</groupId> <artifactId>spring-session-jdbc</artifactId> <version>3.0.4</version> <type>pom</type> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-web</artifactId> <version>6.0.13</version> </dependency> </dependencies> Spring XML Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a servlet filter that replaces the HttpSession implementation with an implementation backed by Spring Session. The following listing shows how to add the following Spring Configuration: src/main/webapp/WEB-INF/spring/session.xml (1) <context:annotation-config/> <bean class=""org.springframework.session.jdbc.config.annotation.web.http.JdbcHttpSessionConfiguration""/> (2) <jdbc:embedded-database id=""dataSource"" database-name=""testdb"" type=""H2""> <jdbc:script location=""classpath:org/springframework/session/jdbc/schema-h2.sql""/> </jdbc:embedded-database> (3) <bean class=""org.springframework.jdbc.datasource.DataSourceTransactionManager""> <constructor-arg ref=""dataSource""/> </bean> 1 We use the combination of <context:annotation-config/> and JdbcHttpSessionConfiguration because Spring Session does not yet provide XML Namespace support (see gh-104(https://github.com/spring-projects/spring-session/issues/104) ). This creates a Spring bean with the name of springSessionRepositoryFilter . That bean implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by a relational database. 2 We create a dataSource that connects Spring Session to an embedded instance of an H2 database. We configure the H2 database to create database tables by using the SQL script that is included in Spring Session. 3 We create a transactionManager that manages transactions for previously configured dataSource . For additional information on how to configure data access-related concerns, see the Spring Framework Reference Documentation(https://docs.spring.io/spring/docs/6.0.13/spring-framework-reference/data-access.html) . XML Servlet Container Initialization: Our Spring Configuration(#httpsession-jdbc-xml-spring-configuration) created a Spring bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, we need to instruct Spring to load our session.xml configuration. We do so with the following configuration: src/main/webapp/WEB-INF/web.xml <context-param> <param-name>contextConfigLocation</param-name> <param-value> /WEB-INF/spring/session.xml </param-value> </context-param> <listener> <listener-class> org.springframework.web.context.ContextLoaderListener </listener-class> </listener> The ContextLoaderListener(https://docs.spring.io/spring/docs/6.0.13/spring-framework-reference/core.html#context-create) reads the contextConfigLocation and picks up our session.xml configuration. Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. The following snippet performs this last step for us: src/main/webapp/WEB-INF/web.xml <filter> <filter-name>springSessionRepositoryFilter</filter-name> <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class> </filter> <filter-mapping> <filter-name>springSessionRepositoryFilter</filter-name> <url-pattern>/*</url-pattern> <dispatcher>REQUEST</dispatcher> <dispatcher>ERROR</dispatcher> </filter-mapping> The DelegatingFilterProxy(https://docs.spring.io/spring-framework/docs/6.0.13/javadoc-api/org/springframework/web/filter/DelegatingFilterProxy.html) looks up a bean named springSessionRepositoryFilter and casts it to a Filter . For every request on which DelegatingFilterProxy is invoked, the springSessionRepositoryFilter is invoked. httpsession-jdbc-xml Sample Application: This section describes how to work with the httpsession-jdbc-xml Sample Application. Running the httpsession-jdbc-xml Sample Application: You can run the sample by obtaining the source code(https://github.com/spring-projects/spring-session/archive/3.0.4.zip) and invoking the following command: $ ./gradlew :spring-session-sample-xml-jdbc:tomcatRun You should now be able to access the application at localhost:8080/(http://localhost:8080/) Exploring the httpsession-jdbc-xml Sample Application: Now you can try using the application. To do so, fill out the form with the following information: Attribute Name: username Attribute Value: rob Now click the Set Attribute button. You should now see the values displayed in the table. How Does It Work?: We interact with the standard HttpSession in the following SessionServlet : src/main/java/sample/SessionServlet.java public class SessionServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException { String attributeName = req.getParameter(""attributeName""); String attributeValue = req.getParameter(""attributeValue""); req.getSession().setAttribute(attributeName, attributeValue); resp.sendRedirect(req.getContextPath() + ""/""); } private static final long serialVersionUID = 2878267318695777395L; } Instead of using Tomcat’s HttpSession , we persist the values in the H2 database. Spring Session creates a cookie named SESSION in your browser. That cookie contains the ID of your session. You can view the cookies (with Chrome(https://developers.google.com/web/tools/chrome-devtools/manage-data/cookies) or Firefox(https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector) ). You can remove the session by using H2 web console available at: localhost:8080/h2-console/(http://localhost:8080/h2-console/) (use jdbc:h2:mem:testdb for JDBC URL) Now you can visit the application at localhost:8080/(http://localhost:8080/) and observe that the attribute we added is no longer displayed."
"https://docs.spring.io/spring-session/reference/3.0/configurations.html","For the latest stable version, please use Spring Session 3.3.2(../configurations.html) ! Configuration: This section provides guidance on how to further configure Spring Session for each of its supported datastores."
"https://docs.spring.io/spring-session/reference/3.0/configuration/redis.html","For the latest stable version, please use Spring Session 3.3.2(../../configuration/redis.html) ! Redis Configurations: Now that you have your application configured, you might want to start customizing things: I want to customize the Redis configuration(https://docs.spring.io/spring-boot/docs/3.0.7/reference/html/application-properties.html#application-properties.data.spring.data.redis.host) using Spring Boot properties I want help in choosing(#choosing-between-regular-and-indexed) RedisSessionRepository or RedisIndexedSessionRepository . I want to serialize the session using JSON(#serializing-session-using-json) . I want to specify a different namespace(#using-a-different-namespace) . I want to know when a session is created, deleted, destroyed or expires(#listening-session-events) . I want to find all sessions of a specific user(#finding-all-user-sessions) Serializing the Session using JSON: By default, Spring Session uses Java Serialization to serialize the session attributes. Sometimes it might be problematic, especially when you have multiple applications that use the same Redis instance but have different versions of the same class. You can provide a RedisSerializer bean to customize how the session is serialized into Redis. Spring Data Redis provides the GenericJackson2JsonRedisSerializer that serializes and deserializes objects using Jackson’s ObjectMapper . Configuring the RedisSerializer @Configuration public class SessionConfig implements BeanClassLoaderAware { private ClassLoader loader; @Bean public RedisSerializer<Object> springSessionDefaultRedisSerializer() { return new GenericJackson2JsonRedisSerializer(objectMapper()); } /** * Customized {@link ObjectMapper} to add mix-in for class that doesn't have default * constructors * @return the {@link ObjectMapper} to use */ private ObjectMapper objectMapper() { ObjectMapper mapper = new ObjectMapper(); mapper.registerModules(SecurityJackson2Modules.getModules(this.loader)); return mapper; } /* * @see * org.springframework.beans.factory.BeanClassLoaderAware#setBeanClassLoader(java.lang * .ClassLoader) */ @Override public void setBeanClassLoader(ClassLoader classLoader) { this.loader = classLoader; } } The above code snippet is using Spring Security, therefore we are creating a custom ObjectMapper that uses Spring Security’s Jackson modules. If you do not need Spring Security Jackson modules, you can inject your application’s ObjectMapper bean and use it like so: @Bean public RedisSerializer<Object> springSessionDefaultRedisSerializer(ObjectMapper objectMapper) { return new GenericJackson2JsonRedisSerializer(objectMapper); } Specifying a Different Namespace: It is not uncommon to have multiple applications that use the same Redis instance. For that reason, Spring Session uses a namespace (defaults to spring:session ) to keep the session data separated if needed. Using Spring Boot Properties: You can specify it by setting the spring.session.redis.namespace property. application.properties spring.session.redis.namespace=spring:session:myapplication application.yml spring: session: redis: namespace: ""spring:session:myapplication"" Using the Annotation’s Attributes: You can specify the namespace by setting the redisNamespace property in the @EnableRedisHttpSession , @EnableRedisIndexedHttpSession , or @EnableRedisWebSession annotations: @EnableRedisHttpSession @Configuration @EnableRedisHttpSession(redisNamespace = ""spring:session:myapplication"") public class SessionConfig { // ... } @EnableRedisIndexedHttpSession @Configuration @EnableRedisIndexedHttpSession(redisNamespace = ""spring:session:myapplication"") public class SessionConfig { // ... } @EnableRedisWebSession @Configuration @EnableRedisWebSession(redisNamespace = ""spring:session:myapplication"") public class SessionConfig { // ... } Choosing Between RedisSessionRepository and RedisIndexedSessionRepository: When working with Spring Session Redis, you will likely have to choose between the RedisSessionRepository and the RedisIndexedSessionRepository . Both are implementations of the SessionRepository interface that store session data in Redis. However, they differ in how they handle session indexing and querying. RedisSessionRepository : RedisSessionRepository is a basic implementation that stores session data in Redis without any additional indexing. It uses a simple key-value structure to store session attributes. Each session is assigned a unique session ID, and the session data is stored under a Redis key associated with that ID. When a session needs to be retrieved, the repository queries Redis using the session ID to fetch the associated session data. Since there is no indexing, querying sessions based on attributes or criteria other than the session ID can be inefficient. RedisIndexedSessionRepository : RedisIndexedSessionRepository is an extended implementation that provides indexing capabilities for sessions stored in Redis. It introduces additional data structures in Redis to efficiently query sessions based on attributes or criteria. In addition to the key-value structure used by RedisSessionRepository , it maintains additional indexes to enable fast lookups. For example, it may create indexes based on session attributes like user ID or last access time. These indexes allow for efficient querying of sessions based on specific criteria, enhancing performance and enabling advanced session management features. In addition to that, RedisIndexedSessionRepository also supports session expiration and deletion. Configuring the RedisSessionRepository: Using Spring Boot Properties: If you are using Spring Boot, the RedisSessionRepository is the default implementation. However, if you want to be explicit about it, you can set the following property in your application: application.properties spring.session.redis.repository-type=default application.yml spring: session: redis: repository-type: default Using Annotations: You can configure the RedisSessionRepository by using the @EnableRedisHttpSession annotation: @Configuration @EnableRedisHttpSession public class SessionConfig { // ... } Configuring the RedisIndexedSessionRepository: Using Spring Boot Properties: You can configure the RedisIndexedSessionRepository by setting the following properties in your application: application.properties spring.session.redis.repository-type=indexed application.yml spring: session: redis: repository-type: indexed Using Annotations: You can configure the RedisIndexedSessionRepository by using the @EnableRedisIndexedHttpSession annotation: @Configuration @EnableRedisIndexedHttpSession public class SessionConfig { // ... } Listening to Session Events: Often times it is valuable to react to session events, for example, you might want to do some kind of processing depending on the session lifecycle. In order to be able to do that, you must be using the indexed repository(#configuring-redisindexedsessionrepository) . If you do not know the difference between the indexed and the default repository, you can go to this section(#choosing-between-regular-and-indexed) . With the indexed repository configured, you can now start to listen to SessionCreatedEvent , SessionDeletedEvent , SessionDestroyedEvent and SessionExpiredEvent events. There are a few ways to listen to application events(https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-functionality-events) in Spring, we are going to use the @EventListener annotation. @Component public class SessionEventListener { @EventListener public void processSessionCreatedEvent(SessionCreatedEvent event) { // do the necessary work } @EventListener public void processSessionDeletedEvent(SessionDeletedEvent event) { // do the necessary work } @EventListener public void processSessionDestroyedEvent(SessionDestroyedEvent event) { // do the necessary work } @EventListener public void processSessionExpiredEvent(SessionExpiredEvent event) { // do the necessary work } } Finding All Sessions of a Specific User: By retrieving all sessions of a specific user, you can track the user’s active sessions across devices or browsers. For example, you can use this information session management purposes, such as allowing the user to invalidate or logout from specific sessions or performing actions based on the user’s session activity. To do that, first you must be using the indexed repository(#configuring-redisindexedsessionrepository) , and then you can inject the FindByIndexNameSessionRepository interface, like so: @Autowired public FindByIndexNameSessionRepository<? extends Session> sessions; public Collection<? extends Session> getSessions(Principal principal) { Collection<? extends Session> usersSessions = this.sessions.findByPrincipalName(principal.getName()).values(); return usersSessions; } public void removeSession(Principal principal, String sessionIdToDelete) { Set<String> usersSessionIds = this.sessions.findByPrincipalName(principal.getName()).keySet(); if (usersSessionIds.contains(sessionIdToDelete)) { this.sessions.deleteById(sessionIdToDelete); } } In the example above, you can use the getSessions method to find all sessions of a specific user, and the removeSession method to remove a specific session of a user."
"https://docs.spring.io/spring-session/reference/3.0/configuration/common.html","For the latest stable version, please use Spring Session 3.3.2(../../configuration/common.html) ! Common Configurations: This section contains common configurations that applies to all or most Spring Session modules. It contains configuration examples for the following use cases: I need to customize the session cookie properties(#customizing-session-cookie) Customizing Session Cookie: Once you have set up Spring Session, you can customize how the session cookie is written by exposing a CookieSerializer as a Spring bean. Spring Session comes with DefaultCookieSerializer . Exposing the DefaultCookieSerializer as a Spring bean augments the existing configuration when you use configurations like @EnableRedisHttpSession . The following example shows how to customize Spring Session’s cookie: @Bean public CookieSerializer cookieSerializer() { DefaultCookieSerializer serializer = new DefaultCookieSerializer(); serializer.setCookieName(""JSESSIONID""); (1) serializer.setCookiePath(""/""); (2) serializer.setDomainNamePattern(""^.+?\\.(\\w+\\.[a-z]+)$""); (3) return serializer; } 1 We customize the name of the cookie to be JSESSIONID . 2 We customize the path of the cookie to be / (rather than the default of the context root). 3 We customize the domain name pattern (a regular expression) to be ^.?\\.(\\w\\.[a-z]+)$ . This allows sharing a session across domains and applications. If the regular expression does not match, no domain is set and the existing domain is used. If the regular expression matches, the first grouping(https://docs.oracle.com/javase/tutorial/essential/regex/groups.html) is used as the domain. This means that a request to child.example.com(https://child.example.com) sets the domain to example.com . However, a request to localhost:8080/(http://localhost:8080/) or 192.168.1.100:8080/(https://192.168.1.100:8080/) leaves the cookie unset and, thus, still works in development without any changes being necessary for production. You should only match on valid domain characters, since the domain name is reflected in the response. Doing so prevents a malicious user from performing such attacks as HTTP Response Splitting(https://en.wikipedia.org/wiki/HTTP_response_splitting) . Configuration Options: The following configuration options are available: cookieName : The name of the cookie to use. Default: SESSION . useSecureCookie : Specifies whether a secure cookie should be used. Default: Use the value of HttpServletRequest.isSecure() at the time of creation. cookiePath : The path of the cookie. Default: The context root. cookieMaxAge : Specifies the max age of the cookie to be set at the time the session is created. Default: -1 , which indicates the cookie should be removed when the browser is closed. jvmRoute : Specifies a suffix to be appended to the session ID and included in the cookie. Used to identify which JVM to route to for session affinity. With some implementations (that is, Redis) this option provides no performance benefit. However, it can help with tracing logs of a particular user. domainName : Allows specifying a specific domain name to be used for the cookie. This option is simple to understand but often requires a different configuration between development and production environments. See domainNamePattern as an alternative. domainNamePattern : A case-insensitive pattern used to extract the domain name from the HttpServletRequest#getServerName() . The pattern should provide a single grouping that is used to extract the value of the cookie domain. If the regular expression does not match, no domain is set and the existing domain is used. If the regular expression matches, the first grouping(https://docs.oracle.com/javase/tutorial/essential/regex/groups.html) is used as the domain. sameSite : The value for the SameSite cookie directive. To disable the serialization of the SameSite cookie directive, you may set this value to null . Default: Lax Custom Cookie in WebFlux: You can customize how the session cookie is written in a WebFlux application by exposing a WebSessionIdResolver as a Spring bean. Spring Session uses a CookieWebSessionIdResolver by default. The following example shows how to customize Spring Session’s cookie: @Bean public WebSessionIdResolver webSessionIdResolver() { CookieWebSessionIdResolver resolver = new CookieWebSessionIdResolver(); resolver.setCookieName(""JSESSIONID""); (1) resolver.addCookieInitializer((builder) -> builder.path(""/"")); (2) resolver.addCookieInitializer((builder) -> builder.sameSite(""Strict"")); (3) return resolver; } 1 We customize the name of the cookie to be JSESSIONID . 2 We customize the path of the cookie to be / (rather than the default of the context root). 3 We customize the SameSite cookie directive to be Strict ."
"https://docs.spring.io/spring-session/reference/3.0/http-session.html","For the latest stable version, please use Spring Session 3.3.2(../http-session.html) ! HttpSession Integration: Spring Session provides transparent integration with HttpSession . This means that developers can switch the HttpSession implementation out with an implementation that is backed by Spring Session. Why Spring Session and HttpSession?: We have already mentioned that Spring Session provides transparent integration with HttpSession , but what benefits do we get out of this? Clustered Sessions : Spring Session makes it trivial to support clustered sessions(#httpsession-redis) without being tied to an application container specific solution. RESTful APIs : Spring Session lets providing session IDs in headers work with RESTful APIs(#httpsession-rest) HttpSession with Redis: Using Spring Session with HttpSession is enabled by adding a Servlet Filter before anything that uses the HttpSession . You can choose from enabling this by using either: Java-based Configuration(#httpsession-redis-jc) XML-based Configuration(#httpsession-redis-xml) Redis Java-based Configuration: This section describes how to use Redis to back HttpSession by using Java based configuration. The HttpSession Sample(samples.html#samples) provides a working sample of how to integrate Spring Session and HttpSession by using Java configuration. You can read the basic steps for integration in the next few sections, but we encourage you to follow along with the detailed HttpSession Guide when integrating with your own application. Spring Java Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a servlet filter that replaces the HttpSession implementation with an implementation backed by Spring Session. To do so, add the following Spring Configuration: @Configuration(proxyBeanMethods = false) @EnableRedisHttpSession (1) public class Config { @Bean public LettuceConnectionFactory connectionFactory() { return new LettuceConnectionFactory(); (2) } } 1 The @EnableRedisHttpSession annotation creates a Spring Bean with the name of springSessionRepositoryFilter that implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by Redis. 2 We create a RedisConnectionFactory that connects Spring Session to the Redis Server. We configure the connection to connect to localhost on the default port (6379). For more information on configuring Spring Data Redis, see the reference documentation(https://docs.spring.io/spring-data/data-redis/docs/3.0.11/reference/html/) . Java Servlet Container Initialization: Our Spring Configuration(#httpsession-spring-configuration) created a Spring Bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our Config class. Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. Fortunately, Spring Session provides a utility class named AbstractHttpSessionApplicationInitializer to make both of these steps easy. The following shows an example: src/main/java/sample/Initializer.java public class Initializer extends AbstractHttpSessionApplicationInitializer { (1) public Initializer() { super(Config.class); (2) } } The name of our class ( Initializer ) does not matter. What is important is that we extend AbstractHttpSessionApplicationInitializer . 1 The first step is to extend AbstractHttpSessionApplicationInitializer . Doing so ensures that the Spring Bean by the name of springSessionRepositoryFilter is registered with our Servlet Container for every request. 2 AbstractHttpSessionApplicationInitializer also provides a mechanism to ensure Spring loads our Config . Redis XML-based Configuration: This section describes how to use Redis to back HttpSession by using XML based configuration. The HttpSession XML Sample(samples.html#samples) provides a working sample of how to integrate Spring Session and HttpSession using XML configuration. You can read the basic steps for integration in the next few sections, but we encourage you to follow along with the detailed HttpSession XML Guide when integrating with your own application. Spring XML Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a servlet filter that replaces the HttpSession implementation with an implementation backed by Spring Session. To do so, add the following Spring Configuration: src/main/webapp/WEB-INF/spring/session.xml (1) <context:annotation-config/> <bean class=""org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration""/> (2) <bean class=""org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory""/> 1 We use the combination of <context:annotation-config/> and RedisHttpSessionConfiguration because Spring Session does not yet provide XML Namespace support (see gh-104(https://github.com/spring-projects/spring-session/issues/104) ). This creates a Spring Bean with the name of springSessionRepositoryFilter that implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by Redis. 2 We create a RedisConnectionFactory that connects Spring Session to the Redis Server. We configure the connection to connect to localhost on the default port (6379) For more information on configuring Spring Data Redis, see the reference documentation(https://docs.spring.io/spring-data/data-redis/docs/3.0.11/reference/html/) . XML Servlet Container Initialization: Our Spring Configuration(#httpsession-xml-spring-configuration) created a Spring Bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, we need to instruct Spring to load our session.xml configuration. We can do so with the following configuration: src/main/webapp/WEB-INF/web.xml <context-param> <param-name>contextConfigLocation</param-name> <param-value> /WEB-INF/spring/session.xml </param-value> </context-param> <listener> <listener-class> org.springframework.web.context.ContextLoaderListener </listener-class> </listener> The ContextLoaderListener(https://docs.spring.io/spring/docs/6.0.13/spring-framework-reference/core.html#context-create) reads the contextConfigLocation and picks up our session.xml configuration. Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. The following snippet performs this last step for us: src/main/webapp/WEB-INF/web.xml <filter> <filter-name>springSessionRepositoryFilter</filter-name> <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class> </filter> <filter-mapping> <filter-name>springSessionRepositoryFilter</filter-name> <url-pattern>/*</url-pattern> <dispatcher>REQUEST</dispatcher> <dispatcher>ERROR</dispatcher> </filter-mapping> The DelegatingFilterProxy(https://docs.spring.io/spring-framework/docs/6.0.13/javadoc-api/org/springframework/web/filter/DelegatingFilterProxy.html) looks up a Bean by the name of springSessionRepositoryFilter and cast it to a Filter . For every request that DelegatingFilterProxy is invoked, the springSessionRepositoryFilter is invoked. HttpSession with Mongo: Using Spring Session with HttpSession is enabled by adding a Servlet Filter before anything that uses the HttpSession . This section describes how to use Mongo to back HttpSession using Java based configuration. The HttpSession Mongo Sample(#samples) provides a working sample on how to integrate Spring Session and HttpSession using Java configuration. You can read the basic steps for integration below, but you are encouraged to follow along with the detailed HttpSession Guide when integrating with your own application. All you have to do is to add the following Spring Configuration: @Configuration(proxyBeanMethods = false) @EnableMongoHttpSession (1) public class HttpSessionConfig { @Bean public JdkMongoSessionConverter jdkMongoSessionConverter() { return new JdkMongoSessionConverter(Duration.ofMinutes(30)); (2) } } 1 The @EnableMongoHttpSession annotation creates a Spring Bean with the name of springSessionRepositoryFilter that implements Filter. This filter is what replaces the default HttpSession with the MongoDB-backed bean. 2 Configures the session timeout to 30 minutes. Session serialization mechanisms: To be able to persist session objects in MongoDB we need to provide the serialization/deserialization mechanism. By default, Spring Session MongoDB will use JdkMongoSessionConverter . However, you may switch to JacksonMongoSessionConverter by merely adding the following code to your Boot app: @Bean JacksonMongoSessionConverter mongoSessionConverter() { return new JacksonMongoSessionConverter(); } JacksonMongoSessionConverter: This mechanism uses Jackson to serialize session objects to/from JSON. By creating the following bean: @Bean JacksonMongoSessionConverter mongoSessionConverter() { return new JacksonMongoSessionConverter(); } …​you are able to switch from the default (JDK-based serialization) to using Jackson. If you are integrating with Spring Security (by storing your sessions in MongoDB), this configuration will register the proper whitelisted components so Spring Security works properly. If you would like to provide custom Jackson modules you can do it by explicitly registering modules as shown below: Unresolved include directive in modules/ROOT/pages/http-session.adoc - include::example$spring-session-data-mongodb-dir/src/integration-test/java/org/springframework/session/data/mongo/integration/MongoRepositoryJacksonITest.java[] JdkMongoSessionConverter: JdkMongoSessionConverter uses standard Java serialization to persist session attributes map to MongoDB in a binary form. However, standard session elements like id, access time, etc are still written as a plain Mongo objects and can be read and queried without additional effort. JdkMongoSessionConverter is used if no explicit AbstractMongoSessionConverter Bean has been defined. There is also a constructor taking Serializer and Deserializer objects, allowing you to pass custom implementations, which is especially important when you want to use non-default classloader. HttpSession with JDBC: You can use Spring Session with HttpSession by adding a servlet filter before anything that uses the HttpSession . You can choose to do in any of the following ways: Java-based Configuration(#httpsession-jdbc-jc) XML-based Configuration(#httpsession-jdbc-xml) Spring Boot-based Configuration(#httpsession-jdbc-boot) JDBC Java-based Configuration: This section describes how to use a relational database to back HttpSession when you use Java-based configuration. The HttpSession JDBC Sample(samples.html#samples) provides a working sample of how to integrate Spring Session and HttpSession by using Java configuration. You can read the basic steps for integration in the next few sections, but we encouraged you to follow along with the detailed HttpSession JDBC Guide when integrating with your own application. Spring Java Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a Servlet Filter that replaces the HttpSession implementation with an implementation backed by Spring Session. To do so, add the following Spring Configuration: @Configuration(proxyBeanMethods = false) @EnableJdbcHttpSession (1) public class Config { @Bean public EmbeddedDatabase dataSource() { return new EmbeddedDatabaseBuilder() (2) .setType(EmbeddedDatabaseType.H2).addScript(""org/springframework/session/jdbc/schema-h2.sql"").build(); } @Bean public PlatformTransactionManager transactionManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); (3) } } 1 The @EnableJdbcHttpSession annotation creates a Spring Bean with the name of springSessionRepositoryFilter . That bean implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by a relational database. 2 We create a dataSource that connects Spring Session to an embedded instance of an H2 database. We configure the H2 database to create database tables by using the SQL script that is included in Spring Session. 3 We create a transactionManager that manages transactions for previously configured dataSource . For additional information on how to configure data access related concerns, see the Spring Framework Reference Documentation(https://docs.spring.io/spring/docs/6.0.13/reference/html/data-access.html) . Java Servlet Container Initialization: Our Spring Configuration(#httpsession-jdbc-spring-configuration) created a Spring bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our Config class. Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. Fortunately, Spring Session provides a utility class named AbstractHttpSessionApplicationInitializer to make both of these steps easy. The following example shows how to do so: src/main/java/sample/Initializer.java public class Initializer extends AbstractHttpSessionApplicationInitializer { (1) public Initializer() { super(Config.class); (2) } } The name of our class (Initializer) does not matter. What is important is that we extend AbstractHttpSessionApplicationInitializer . 1 The first step is to extend AbstractHttpSessionApplicationInitializer . Doing so ensures that the Spring bean named springSessionRepositoryFilter is registered with our Servlet Container for every request. 2 AbstractHttpSessionApplicationInitializer also provides a mechanism to ensure Spring loads our Config . Multiple DataSources: Spring Session provides the @SpringSessionDataSource qualifier, allowing you to explicitly declare which DataSource bean should be injected in JdbcIndexedSessionRepository . This is particularly useful in scenarios with multiple DataSource beans present in the application context. The following example shows how to do so: Config.java @EnableJdbcHttpSession public class Config { @Bean @SpringSessionDataSource (1) public EmbeddedDatabase firstDataSource() { return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2).addScript(""org/springframework/session/jdbc/schema-h2.sql"").build(); } @Bean public HikariDataSource secondDataSource() { // ... } } 1 This qualifier declares that firstDataSource is to be used by Spring Session. JDBC XML-based Configuration: This section describes how to use a relational database to back HttpSession when you use XML based configuration. The HttpSession JDBC XML Sample(samples.html#samples) provides a working sample of how to integrate Spring Session and HttpSession by using XML configuration. You can read the basic steps for integration in the next few sections, but we encourage you to follow along with the detailed HttpSession JDBC XML Guide when integrating with your own application. Spring XML Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a servlet filter that replaces the HttpSession implementation with an implementation backed by Spring Session. The following listing shows how to add the following Spring Configuration: src/main/webapp/WEB-INF/spring/session.xml (1) <context:annotation-config/> <bean class=""org.springframework.session.jdbc.config.annotation.web.http.JdbcHttpSessionConfiguration""/> (2) <jdbc:embedded-database id=""dataSource"" database-name=""testdb"" type=""H2""> <jdbc:script location=""classpath:org/springframework/session/jdbc/schema-h2.sql""/> </jdbc:embedded-database> (3) <bean class=""org.springframework.jdbc.datasource.DataSourceTransactionManager""> <constructor-arg ref=""dataSource""/> </bean> 1 We use the combination of <context:annotation-config/> and JdbcHttpSessionConfiguration because Spring Session does not yet provide XML Namespace support (see gh-104(https://github.com/spring-projects/spring-session/issues/104) ). This creates a Spring bean with the name of springSessionRepositoryFilter . That bean implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by a relational database. 2 We create a dataSource that connects Spring Session to an embedded instance of an H2 database. We configure the H2 database to create database tables by using the SQL script that is included in Spring Session. 3 We create a transactionManager that manages transactions for previously configured dataSource . For additional information on how to configure data access-related concerns, see the Spring Framework Reference Documentation(https://docs.spring.io/spring/docs/6.0.13/spring-framework-reference/data-access.html) . XML Servlet Container Initialization: Our Spring Configuration(#httpsession-jdbc-xml-spring-configuration) created a Spring bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, we need to instruct Spring to load our session.xml configuration. We do so with the following configuration: src/main/webapp/WEB-INF/web.xml <context-param> <param-name>contextConfigLocation</param-name> <param-value> /WEB-INF/spring/session.xml </param-value> </context-param> <listener> <listener-class> org.springframework.web.context.ContextLoaderListener </listener-class> </listener> The ContextLoaderListener(https://docs.spring.io/spring/docs/6.0.13/spring-framework-reference/core.html#context-create) reads the contextConfigLocation and picks up our session.xml configuration. Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. The following snippet performs this last step for us: src/main/webapp/WEB-INF/web.xml <filter> <filter-name>springSessionRepositoryFilter</filter-name> <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class> </filter> <filter-mapping> <filter-name>springSessionRepositoryFilter</filter-name> <url-pattern>/*</url-pattern> <dispatcher>REQUEST</dispatcher> <dispatcher>ERROR</dispatcher> </filter-mapping> The DelegatingFilterProxy(https://docs.spring.io/spring-framework/docs/6.0.13/javadoc-api/org/springframework/web/filter/DelegatingFilterProxy.html) looks up a bean named springSessionRepositoryFilter and casts it to a Filter . For every request on which DelegatingFilterProxy is invoked, the springSessionRepositoryFilter is invoked. JDBC Spring Boot-based Configuration: This section describes how to use a relational database to back HttpSession when you use Spring Boot. The HttpSession JDBC Spring Boot Sample(samples.html#samples) provides a working sample of how to integrate Spring Session and HttpSession by using Spring Boot. You can read the basic steps for integration in the next few sections, but we encourage you to follow along with the detailed HttpSession JDBC Spring Boot Guide when integrating with your own application. Spring Boot Configuration: After adding the required dependencies, we can create our Spring Boot configuration. Thanks to first-class auto configuration support, setting up Spring Session backed by a relational database is as simple as adding a single configuration property to your application.properties . The following listing shows how to do so: src/main/resources/application.properties spring.session.store-type=jdbc # Session store type. If a single Spring Session module is present on the classpath, Spring Boot uses that store implementation automatically. If you have more than one implementation, you must choose the StoreType that you wish to use to store the sessions, as shows above. Under the hood, Spring Boot applies configuration that is equivalent to manually adding the @EnableJdbcHttpSession annotation. This creates a Spring bean with the name of springSessionRepositoryFilter . That bean implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. You can further customize by using application.properties . The following listing shows how to do so: src/main/resources/application.properties server.servlet.session.timeout= # Session timeout. If a duration suffix is not specified, seconds are used. spring.session.jdbc.initialize-schema=embedded # Database schema initialization mode. spring.session.jdbc.schema=classpath:org/springframework/session/jdbc/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema. spring.session.jdbc.table-name=SPRING_SESSION # Name of the database table used to store sessions. For more information, see the Spring Session(https://docs.spring.io/spring-boot/docs/3.0.7/reference/htmlsingle/#boot-features-session) portion of the Spring Boot documentation. Configuring the DataSource: Spring Boot automatically creates a DataSource that connects Spring Session to an embedded instance of an H2 database. In a production environment, you need to update your configuration to point to your relational database. For example, you can include the following in your application.properties: src/main/resources/application.properties spring.datasource.url= # JDBC URL of the database. spring.datasource.username= # Login username of the database. spring.datasource.password= # Login password of the database. For more information, see the Configure a DataSource(https://docs.spring.io/spring-boot/docs/3.0.7/reference/htmlsingle/#boot-features-configure-datasource) portion of the Spring Boot documentation. Servlet Container Initialization: Our Spring Boot Configuration(#httpsession-jdbc-boot-spring-configuration) created a Spring bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our Config class. Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. Fortunately, Spring Boot takes care of both of these steps for us. HttpSession with Hazelcast: Using Spring Session with HttpSession is enabled by adding a Servlet Filter before anything that uses the HttpSession . This section describes how to use Hazelcast to back HttpSession by using Java-based configuration. The Hazelcast Spring Sample(samples.html#samples) provides a working sample of how to integrate Spring Session and HttpSession by using Java configuration. You can read the basic steps for integration in the next few sections, but we encourage you to follow along with the detailed Hazelcast Spring Guide when integrating with your own application. Spring Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a servlet filter that replaces the HttpSession implementation with an implementation backed by Spring Session. To do so, add the following Spring Configuration: @EnableHazelcastHttpSession (1) @Configuration public class HazelcastHttpSessionConfig { @Bean public HazelcastInstance hazelcastInstance() { Config config = new Config(); AttributeConfig attributeConfig = new AttributeConfig() .setName(HazelcastIndexedSessionRepository.PRINCIPAL_NAME_ATTRIBUTE) .setExtractorClassName(PrincipalNameExtractor.class.getName()); config.getMapConfig(HazelcastIndexedSessionRepository.DEFAULT_SESSION_MAP_NAME) (2) .addAttributeConfig(attributeConfig).addIndexConfig( new IndexConfig(IndexType.HASH, HazelcastIndexedSessionRepository.PRINCIPAL_NAME_ATTRIBUTE)); SerializerConfig serializerConfig = new SerializerConfig(); serializerConfig.setImplementation(new HazelcastSessionSerializer()).setTypeClass(MapSession.class); config.getSerializationConfig().addSerializerConfig(serializerConfig); (3) return Hazelcast.newHazelcastInstance(config); (4) } } 1 The @EnableHazelcastHttpSession annotation creates a Spring bean named springSessionRepositoryFilter that implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by Hazelcast. 2 In order to support retrieval of sessions by principal name index, an appropriate ValueExtractor needs to be registered. Spring Session provides PrincipalNameExtractor for this purpose. 3 In order to serialize MapSession objects efficiently, HazelcastSessionSerializer needs to be registered. If this is not set, Hazelcast will serialize sessions using native Java serialization. 4 We create a HazelcastInstance that connects Spring Session to Hazelcast. By default, the application starts and connects to an embedded instance of Hazelcast. For more information on configuring Hazelcast, see the reference documentation(https://docs.hazelcast.com/hazelcast/latest/) . If HazelcastSessionSerializer is preferred, it needs to be configured for all Hazelcast cluster members before they start. In a Hazelcast cluster, all members should use the same serialization method for sessions. Also, if Hazelcast Client/Server topology is used, then both members and clients must use the same serialization method. The serializer can be registered via ClientConfig with the same SerializerConfiguration of members. Servlet Container Initialization: Our Spring Configuration(guides/java-security.html#security-spring-configuration) created a Spring bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our SessionConfig class. Since our application is already loading Spring configuration by using our SecurityInitializer class, we can add our SessionConfig class to it. The following listing shows how to do so: src/main/java/sample/SecurityInitializer.java public class SecurityInitializer extends AbstractSecurityWebApplicationInitializer { public SecurityInitializer() { super(SecurityConfig.class, SessionConfig.class); } } Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. It is extremely important that Spring Session’s springSessionRepositoryFilter is invoked before Spring Security’s springSecurityFilterChain . Doing so ensures that the HttpSession that Spring Security uses is backed by Spring Session. Fortunately, Spring Session provides a utility class named AbstractHttpSessionApplicationInitializer that makes this doing so easy. The following example shows how to do so: src/main/java/sample/Initializer.java public class Initializer extends AbstractHttpSessionApplicationInitializer { } The name of our class ( Initializer ) does not matter. What is important is that we extend AbstractHttpSessionApplicationInitializer . By extending AbstractHttpSessionApplicationInitializer , we ensure that the Spring Bean named springSessionRepositoryFilter is registered with our servlet container for every request before Spring Security’s springSecurityFilterChain . How HttpSession Integration Works: Fortunately, both HttpSession and HttpServletRequest (the API for obtaining an HttpSession ) are both interfaces. This means that we can provide our own implementations for each of these APIs. This section describes how Spring Session provides transparent integration with HttpSession . We offer this content so that you can understand what is happening under the covers. This functionality is already integrated and you do NOT need to implement this logic yourself. First, we create a custom HttpServletRequest that returns a custom implementation of HttpSession . It looks something like the following: public class SessionRepositoryRequestWrapper extends HttpServletRequestWrapper { public SessionRepositoryRequestWrapper(HttpServletRequest original) { super(original); } public HttpSession getSession() { return getSession(true); } public HttpSession getSession(boolean createNew) { // create an HttpSession implementation from Spring Session } // ... other methods delegate to the original HttpServletRequest ... } Any method that returns an HttpSession is overridden. All other methods are implemented by HttpServletRequestWrapper and delegate to the original HttpServletRequest implementation. We replace the HttpServletRequest implementation by using a servlet Filter called SessionRepositoryFilter . The following pseudocode shows how it works: public class SessionRepositoryFilter implements Filter { public doFilter(ServletRequest request, ServletResponse response, FilterChain chain) { HttpServletRequest httpRequest = (HttpServletRequest) request; SessionRepositoryRequestWrapper customRequest = new SessionRepositoryRequestWrapper(httpRequest); chain.doFilter(customRequest, response, chain); } // ... } By passing a custom HttpServletRequest implementation into the FilterChain , we ensure that anything invoked after our Filter uses the custom HttpSession implementation. This highlights why it is important that Spring Session’s SessionRepositoryFilter be placed before anything that interacts with the HttpSession . HttpSession and RESTful APIs: Spring Session can work with RESTful APIs by letting the session be provided in a header. The REST Sample(samples.html#samples) provides a working sample of how to use Spring Session in a REST application to support authenticating with a header. You can follow the basic steps for integration described in the next few sections, but we encourage you to follow along with the detailed REST Guide when integrating with your own application. Spring Configuration: After adding the required dependencies, we can create our Spring configuration. The Spring configuration is responsible for creating a servlet filter that replaces the HttpSession implementation with an implementation backed by Spring Session. To do so, add the following Spring Configuration: @Configuration @EnableRedisHttpSession (1) public class HttpSessionConfig { @Bean public LettuceConnectionFactory connectionFactory() { return new LettuceConnectionFactory(); (2) } @Bean public HttpSessionIdResolver httpSessionIdResolver() { return HeaderHttpSessionIdResolver.xAuthToken(); (3) } } 1 The @EnableRedisHttpSession annotation creates a Spring bean named springSessionRepositoryFilter that implements Filter . The filter is in charge of replacing the HttpSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by Redis. 2 We create a RedisConnectionFactory that connects Spring Session to the Redis Server. We configure the connection to connect to localhost on the default port (6379). For more information on configuring Spring Data Redis, see the reference documentation(https://docs.spring.io/spring-data/data-redis/docs/3.0.11/reference/html/) . 3 We customize Spring Session’s HttpSession integration to use HTTP headers to convey the current session information instead of cookies. Servlet Container Initialization: Our Spring Configuration(#rest-spring-configuration) created a Spring Bean named springSessionRepositoryFilter that implements Filter . The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session. In order for our Filter to do its magic, Spring needs to load our Config class. We provide the configuration in our Spring MvcInitializer , as the following example shows: src/main/java/sample/mvc/MvcInitializer.java @Override protected Class<?>[] getRootConfigClasses() { return new Class[] { SecurityConfig.class, HttpSessionConfig.class }; } Last, we need to ensure that our Servlet Container (that is, Tomcat) uses our springSessionRepositoryFilter for every request. Fortunately, Spring Session provides a utility class named AbstractHttpSessionApplicationInitializer that makes doing so easy. To do so, extend the class with the default constructor, as the following example shows: src/main/java/sample/Initializer.java public class Initializer extends AbstractHttpSessionApplicationInitializer { } The name of our class ( Initializer ) does not matter. What is important is that we extend AbstractHttpSessionApplicationInitializer . Using HttpSessionListener: Spring Session supports HttpSessionListener by translating SessionDestroyedEvent and SessionCreatedEvent into HttpSessionEvent by declaring SessionEventHttpSessionListenerAdapter . To use this support, you need to: Ensure your SessionRepository implementation supports and is configured to fire SessionDestroyedEvent and SessionCreatedEvent . Configure SessionEventHttpSessionListenerAdapter as a Spring bean. Inject every HttpSessionListener into the SessionEventHttpSessionListenerAdapter If you use the Redis support with enableIndexingAndEvents set to true , @EnableRedisHttpSession(enableIndexingAndEvents = true) , all you need to do is register every HttpSessionListener as a bean. For example, assume you want to support Spring Security’s concurrency control and need to use HttpSessionEventPublisher . In that case, you can add HttpSessionEventPublisher as a bean. In Java configuration, this might look like the following: @Configuration @EnableRedisHttpSession public class RedisHttpSessionConfig { @Bean public HttpSessionEventPublisher httpSessionEventPublisher() { return new HttpSessionEventPublisher(); } // ... } In XML configuration, this might look like the following: <bean class=""org.springframework.security.web.session.HttpSessionEventPublisher""/>"
"https://docs.spring.io/spring-session/reference/3.0/web-socket.html","For the latest stable version, please use Spring Session 3.3.2(../web-socket.html) ! WebSocket Integration: Spring Session provides transparent integration with Spring’s WebSocket support. Spring Session’s WebSocket support works only with Spring’s WebSocket support. Specifically,it does not work with using JSR-356(https://www.jcp.org/en/jsr/detail?id=356) directly, because JSR-356 does not have a mechanism for intercepting incoming WebSocket messages. Why Spring Session and WebSockets?: So why do we need Spring Session when we use WebSockets? Consider an email application that does much of its work through HTTP requests. However, there is also a chat application embedded within it that works over WebSocket APIs. If a user is actively chatting with someone, we should not timeout the HttpSession , since this would be a pretty poor user experience. However, this is exactly what JSR-356(https://java.net/jira/browse/WEBSOCKET_SPEC-175) does. Another issue is that, according to JSR-356, if the HttpSession times out, any WebSocket that was created with that HttpSession and an authenticated user should be forcibly closed. This means that, if we are actively chatting in our application and are not using the HttpSession, we also do disconnect from our conversation. WebSocket Usage: The WebSocket Sample(samples.html#samples) provides a working sample of how to integrate Spring Session with WebSockets. You can follow the basic steps for integration described in the next few headings, but we encourage you to follow along with the detailed WebSocket Guide when integrating with your own application. HttpSession Integration: Before using WebSocket integration, you should be sure that you have HttpSession Integration(http-session.html#httpsession) working first. Spring Configuration: In a typical Spring WebSocket application, you would implement WebSocketMessageBrokerConfigurer . For example, the configuration might look something like the following: @Configuration @EnableScheduling @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(""/messages"").withSockJS(); } @Override public void configureMessageBroker(MessageBrokerRegistry registry) { registry.enableSimpleBroker(""/queue/"", ""/topic/""); registry.setApplicationDestinationPrefixes(""/app""); } } We can update our configuration to use Spring Session’s WebSocket support. The following example shows how to do so: src/main/java/samples/config/WebSocketConfig.java @Configuration @EnableScheduling @EnableWebSocketMessageBroker public class WebSocketConfig extends AbstractSessionWebSocketMessageBrokerConfigurer<Session> { (1) @Override protected void configureStompEndpoints(StompEndpointRegistry registry) { (2) registry.addEndpoint(""/messages"").withSockJS(); } @Override public void configureMessageBroker(MessageBrokerRegistry registry) { registry.enableSimpleBroker(""/queue/"", ""/topic/""); registry.setApplicationDestinationPrefixes(""/app""); } } To hook in the Spring Session support we only need to change two things: 1 Instead of implementing WebSocketMessageBrokerConfigurer , we extend AbstractSessionWebSocketMessageBrokerConfigurer 2 We rename the registerStompEndpoints method to configureStompEndpoints What does AbstractSessionWebSocketMessageBrokerConfigurer do behind the scenes? WebSocketConnectHandlerDecoratorFactory is added as a WebSocketHandlerDecoratorFactory to WebSocketTransportRegistration . This ensures a custom SessionConnectEvent is fired that contains the WebSocketSession . The WebSocketSession is necessary to end any WebSocket connections that are still open when a Spring Session is ended. SessionRepositoryMessageInterceptor is added as a HandshakeInterceptor to every StompWebSocketEndpointRegistration . This ensures that the Session is added to the WebSocket properties to enable updating the last accessed time. SessionRepositoryMessageInterceptor is added as a ChannelInterceptor to our inbound ChannelRegistration . This ensures that every time an inbound message is received, that the last accessed time of our Spring Session is updated. WebSocketRegistryListener is created as a Spring bean. This ensures that we have a mapping of all of the Session IDs to the corresponding WebSocket connections. By maintaining this mapping, we can close all the WebSocket connections when a Spring Session (HttpSession) is ended."
"https://docs.spring.io/spring-session/reference/3.0/web-session.html","For the latest stable version, please use Spring Session 3.3.2(../web-session.html) ! WebSession Integration: Spring Session provides transparent integration with Spring WebFlux’s WebSession . This means that you can switch the WebSession implementation out with an implementation that is backed by Spring Session. Why Spring Session and WebSession?: We have already mentioned that Spring Session provides transparent integration with Spring WebFlux’s WebSession , but what benefits do we get out of this? As with HttpSession , Spring Session makes it trivial to support clustered sessions(#websession-redis) without being tied to an application container specific solution. WebSession with Redis: Using Spring Session with WebSession is enabled by registering a WebSessionManager implementation backed by Spring Session’s ReactiveSessionRepository . The Spring configuration is responsible for creating a WebSessionManager that replaces the WebSession implementation with an implementation backed by Spring Session. To do so, add the following Spring Configuration: @EnableRedisWebSession (1) public class SessionConfiguration { @Bean public LettuceConnectionFactory redisConnectionFactory() { return new LettuceConnectionFactory(); (2) } } 1 The @EnableRedisWebSession annotation creates a Spring bean with the name of webSessionManager . That bean implements the WebSessionManager . This is what is in charge of replacing the WebSession implementation to be backed by Spring Session. In this instance, Spring Session is backed by Redis. 2 We create a RedisConnectionFactory that connects Spring Session to the Redis Server. We configure the connection to connect to localhost on the default port (6379) For more information on configuring Spring Data Redis, see the reference documentation(https://docs.spring.io/spring-data/data-redis/docs/3.0.11/reference/html/) . How WebSession Integration Works: It is considerably easier for Spring Session to integrate with Spring WebFlux and its WebSession , compared to Servlet API and its HttpSession . Spring WebFlux provides the WebSessionStore API, which presents a strategy for persisting WebSession . This section describes how Spring Session provides transparent integration with WebSession . We offer this content so that you can understand what is happening under the covers. This functionality is already integrated and you do NOT need to implement this logic yourself. First, we create a custom SpringSessionWebSession that delegates to Spring Session’s Session . It looks something like the following: public class SpringSessionWebSession implements WebSession { enum State { NEW, STARTED } private final S session; private AtomicReference<State> state = new AtomicReference<>(); SpringSessionWebSession(S session, State state) { this.session = session; this.state.set(state); } @Override public void start() { this.state.compareAndSet(State.NEW, State.STARTED); } @Override public boolean isStarted() { State value = this.state.get(); return (State.STARTED.equals(value) || (State.NEW.equals(value) && !this.session.getAttributes().isEmpty())); } @Override public Mono<Void> changeSessionId() { return Mono.defer(() -> { this.session.changeSessionId(); return save(); }); } // ... other methods delegate to the original Session } Next, we create a custom WebSessionStore that delegates to the ReactiveSessionRepository and wraps Session into custom WebSession implementation, as the following listing shows: public class SpringSessionWebSessionStore<S extends Session> implements WebSessionStore { private final ReactiveSessionRepository<S> sessions; public SpringSessionWebSessionStore(ReactiveSessionRepository<S> reactiveSessionRepository) { this.sessions = reactiveSessionRepository; } // ... } To be detected by Spring WebFlux, this custom WebSessionStore needs to be registered with ApplicationContext as a bean named webSessionManager . For additional information on Spring WebFlux, see the Spring Framework Reference Documentation(https://docs.spring.io/spring-framework/docs/6.0.13/reference/html/web-reactive.html) ."
"https://docs.spring.io/spring-session/reference/3.0/spring-security.html","For the latest stable version, please use Spring Session 3.3.2(../spring-security.html) ! Spring Security Integration: Spring Session provides integration with Spring Security. Spring Security Remember-me Support: Spring Session provides integration with Spring Security’s Remember-me Authentication(https://docs.spring.io/spring-security/site/docs/6.0.8/reference/html5/#servlet-rememberme) . The support: Changes the session expiration length Ensures that the session cookie expires at Integer.MAX_VALUE . The cookie expiration is set to the largest possible value, because the cookie is set only when the session is created. If it were set to the same value as the session expiration, the session would get renewed when the user used it but the cookie expiration would not be updated (causing the expiration to be fixed). To configure Spring Session with Spring Security in Java Configuration, you can use the following listing as a guide: @Bean SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... additional configuration ... .rememberMe((rememberMe) -> rememberMe .rememberMeServices(rememberMeServices()) ); } @Bean public SpringSessionRememberMeServices rememberMeServices() { SpringSessionRememberMeServices rememberMeServices = new SpringSessionRememberMeServices(); // optionally customize rememberMeServices.setAlwaysRemember(true); return rememberMeServices; } An XML-based configuration would look something like the following: <security:http> <!-- ... --> <security:form-login /> <security:remember-me services-ref=""rememberMeServices""/> <security:intercept-url pattern=""/**"" access=""permitAll()""/> </security:http> <bean id=""rememberMeServices"" class=""org.springframework.session.security.web.authentication.SpringSessionRememberMeServices"" p:alwaysRemember=""true""/> Spring Security Concurrent Session Control: Spring Session provides integration with Spring Security to support its concurrent session control. This allows limiting the number of active sessions that a single user can have concurrently, but, unlike the default Spring Security support, this also works in a clustered environment. This is done by providing a custom implementation of Spring Security’s SessionRegistry interface. When using Spring Security’s Java config DSL, you can configure the custom SessionRegistry through the SessionManagementConfigurer , as the following listing shows: @Configuration public class SecurityConfiguration<S extends Session> { @Autowired private FindByIndexNameSessionRepository<S> sessionRepository; @Bean SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { return http // other config goes here... .sessionManagement((sessionManagement) -> sessionManagement .maximumSessions(2) .sessionRegistry(sessionRegistry()) ) .build(); } @Bean public SpringSessionBackedSessionRegistry<S> sessionRegistry() { return new SpringSessionBackedSessionRegistry<>(this.sessionRepository); } } This assumes that you have also configured Spring Session to provide a FindByIndexNameSessionRepository that returns Session instances. When using XML configuration, it would look something like the following listing: <security:http> <!-- other config goes here... --> <security:session-management> <security:concurrency-control max-sessions=""2"" session-registry-ref=""sessionRegistry""/> </security:session-management> </security:http> <bean id=""sessionRegistry"" class=""org.springframework.session.security.SpringSessionBackedSessionRegistry""> <constructor-arg ref=""sessionRepository""/> </bean> This assumes that your Spring Session SessionRegistry bean is called sessionRegistry , which is the name used by all SpringHttpSessionConfiguration subclasses. Limitations: Spring Session’s implementation of Spring Security’s SessionRegistry interface does not support the getAllPrincipals method, as this information cannot be retrieved by using Spring Session. This method is never called by Spring Security, so this affects only applications that access the SessionRegistry themselves."
"https://docs.spring.io/spring-session/reference/3.0/api.html","For the latest stable version, please use Spring Session 3.3.2(../api.html) ! API Documentation: You can browse the complete Javadoc(https://docs.spring.io/spring-session/docs/3.0.4/api/) online. The key APIs are described in the following sections: Using Session(#api-session) Using SessionRepository(#api-sessionrepository) Using FindByIndexNameSessionRepository(#api-findbyindexnamesessionrepository) Using ReactiveSessionRepository(#api-reactivesessionrepository) Using @EnableSpringHttpSession(#api-enablespringhttpsession) Using @EnableSpringWebSession(#api-enablespringwebsession) Using RedisIndexedSessionRepository(#api-redisindexedsessionrepository) Using ReactiveRedisSessionRepository(#api-reactiveredissessionrepository) Using MapSessionRepository(#api-mapsessionrepository) Using ReactiveMapSessionRepository(#api-reactivemapsessionrepository) Using JdbcIndexedSessionRepository(#api-jdbcindexedsessionrepository) Using HazelcastIndexedSessionRepository(#api-hazelcastindexedsessionrepository) Using CookieSerializer(#api-cookieserializer) Using Session: A Session is a simplified Map of name value pairs. Typical usage might look like the following listing: public class RepositoryDemo<S extends Session> { private SessionRepository<S> repository; (1) public void demo() { S toSave = this.repository.createSession(); (2) (3) User rwinch = new User(""rwinch""); toSave.setAttribute(ATTR_USER, rwinch); this.repository.save(toSave); (4) S session = this.repository.findById(toSave.getId()); (5) (6) User user = session.getAttribute(ATTR_USER); assertThat(user).isEqualTo(rwinch); } // ... setter methods ... } 1 We create a SessionRepository instance with a generic type, S , that extends Session . The generic type is defined in our class. 2 We create a new Session by using our SessionRepository and assign it to a variable of type S . 3 We interact with the Session . In our example, we demonstrate saving a User to the Session . 4 We now save the Session . This is why we needed the generic type S . The SessionRepository only allows saving Session instances that were created or retrieved by using the same SessionRepository . This allows for the SessionRepository to make implementation specific optimizations (that is, writing only attributes that have changed). 5 We retrieve the Session from the SessionRepository . 6 We obtain the persisted User from our Session without the need for explicitly casting our attribute. The Session API also provides attributes related to the Session instance’s expiration. Typical usage might look like the following listing: public class ExpiringRepositoryDemo<S extends Session> { private SessionRepository<S> repository; (1) public void demo() { S toSave = this.repository.createSession(); (2) // ... toSave.setMaxInactiveInterval(Duration.ofSeconds(30)); (3) this.repository.save(toSave); (4) S session = this.repository.findById(toSave.getId()); (5) // ... } // ... setter methods ... } 1 We create a SessionRepository instance with a generic type, S , that extends Session . The generic type is defined in our class. 2 We create a new Session by using our SessionRepository and assign it to a variable of type S . 3 We interact with the Session . In our example, we demonstrate updating the amount of time the Session can be inactive before it expires. 4 We now save the Session . This is why we needed the generic type, S . The SessionRepository allows saving only Session instances that were created or retrieved using the same SessionRepository . This allows for the SessionRepository to make implementation specific optimizations (that is, writing only attributes that have changed). The last accessed time is automatically updated when the Session is saved. 5 We retrieve the Session from the SessionRepository . If the Session were expired, the result would be null. Using SessionRepository: A SessionRepository is in charge of creating, retrieving, and persisting Session instances. If possible, you should not interact directly with a SessionRepository or a Session . Instead, developers should prefer interacting with SessionRepository and Session indirectly through the HttpSession(http-session.html#httpsession) and WebSocket(web-socket.html#websocket) integration. Using FindByIndexNameSessionRepository: Spring Session’s most basic API for using a Session is the SessionRepository . This API is intentionally very simple, so that you can easily provide additional implementations with basic functionality. Some SessionRepository implementations may also choose to implement FindByIndexNameSessionRepository . For example, Spring’s Redis, JDBC, and Hazelcast support libraries all implement FindByIndexNameSessionRepository . The FindByIndexNameSessionRepository provides a method to look up all the sessions with a given index name and index value. As a common use case that is supported by all provided FindByIndexNameSessionRepository implementations, you can use a convenient method to look up all the sessions for a particular user. This is done by ensuring that the session attribute with the name of FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME is populated with the username. It is your responsibility to ensure that the attribute is populated, since Spring Session is not aware of the authentication mechanism being used. An example of how to use this can be seen in the following listing: String username = ""username""; this.session.setAttribute(FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME, username); Some implementations of FindByIndexNameSessionRepository provide hooks to automatically index other session attributes. For example, many implementations automatically ensure that the current Spring Security user name is indexed with the index name of FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME . Once the session is indexed, you can find by using code similar to the following: String username = ""username""; Map<String, Session> sessionIdToSession = this.sessionRepository.findByPrincipalName(username); Using ReactiveSessionRepository: A ReactiveSessionRepository is in charge of creating, retrieving, and persisting Session instances in a non-blocking and reactive manner. If possible, you should not interact directly with a ReactiveSessionRepository or a Session . Instead, you should prefer interacting with ReactiveSessionRepository and Session indirectly through the WebSession(web-session.html#websession) integration. Using @EnableSpringHttpSession: You can add the @EnableSpringHttpSession annotation to a @Configuration class to expose the SessionRepositoryFilter as a bean named springSessionRepositoryFilter . In order to use the annotation, you must provide a single SessionRepository bean. The following example shows how to do so: @EnableSpringHttpSession @Configuration public class SpringHttpSessionConfig { @Bean public MapSessionRepository sessionRepository() { return new MapSessionRepository(new ConcurrentHashMap<>()); } } Note that no infrastructure for session expirations is configured for you. This is because things such as session expiration are highly implementation-dependent. This means that, if you need to clean up expired sessions, you are responsible for cleaning up the expired sessions. Using @EnableSpringWebSession: You can add the @EnableSpringWebSession annotation to a @Configuration class to expose the WebSessionManager as a bean named webSessionManager . To use the annotation, you must provide a single ReactiveSessionRepository bean. The following example shows how to do so: @Configuration(proxyBeanMethods = false) @EnableSpringWebSession public class SpringWebSessionConfig { @Bean public ReactiveSessionRepository reactiveSessionRepository() { return new ReactiveMapSessionRepository(new ConcurrentHashMap<>()); } } Note that no infrastructure for session expirations is configured for you. This is because things such as session expiration are highly implementation-dependent. This means that, if you require cleaning up expired sessions, you are responsible for cleaning up the expired sessions. Using RedisSessionRepository: RedisSessionRepository is a SessionRepository that is implemented by using Spring Data’s RedisOperations . In a web environment, this is typically used in combination with SessionRepositoryFilter . Note that this implementation does not support publishing of session events. Instantiating a RedisSessionRepository: You can see a typical example of how to create a new instance in the following listing: RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>(); // ... configure redisTemplate ... SessionRepository<? extends Session> repository = new RedisSessionRepository(redisTemplate); For additional information on how to create a RedisConnectionFactory , see the Spring Data Redis Reference. Using @EnableRedisHttpSession: In a web environment, the simplest way to create a new RedisSessionRepository is to use @EnableRedisHttpSession . You can find complete example usage in the Samples and Guides (Start Here)(samples.html#samples) . You can use the following attributes to customize the configuration: enableIndexingAndEvents * enableIndexingAndEvents : Whether to use a RedisIndexedSessionRepository instead of a RedisSessionRepository . The default is false . * maxInactiveIntervalInSeconds : The amount of time before the session expires, in seconds. * redisNamespace : Allows configuring an application specific namespace for the sessions. Redis keys and channel IDs start with the prefix of <redisNamespace>: . * flushMode : Allows specifying when data is written to Redis. The default is only when save is invoked on SessionRepository . A value of FlushMode.IMMEDIATE writes to Redis as soon as possible. Custom RedisSerializer: You can customize the serialization by creating a bean named springSessionDefaultRedisSerializer that implements RedisSerializer<Object> . Viewing the Session in Redis: After installing redis-cli(https://redis.io/topics/quickstart) , you can inspect the values in Redis using the redis-cli(https://redis.io/commands#hash) . For example, you can enter the following command into a terminal window: $ redis-cli redis 127.0.0.1:6379> keys * 1) ""spring:session:sessions:4fc39ce3-63b3-4e17-b1c4-5e1ed96fb021"" (1) 1 The suffix of this key is the session identifier of the Spring Session. You can also view the attributes of each session by using the hkeys command. The following example shows how to do so: redis 127.0.0.1:6379> hkeys spring:session:sessions:4fc39ce3-63b3-4e17-b1c4-5e1ed96fb021 1) ""lastAccessedTime"" 2) ""creationTime"" 3) ""maxInactiveInterval"" 4) ""sessionAttr:username"" redis 127.0.0.1:6379> hget spring:session:sessions:4fc39ce3-63b3-4e17-b1c4-5e1ed96fb021 sessionAttr:username ""\xac\xed\x00\x05t\x00\x03rob"" Using RedisIndexedSessionRepository: RedisIndexedSessionRepository is a SessionRepository that is implemented by using Spring Data’s RedisOperations . In a web environment, this is typically used in combination with SessionRepositoryFilter . The implementation supports SessionDestroyedEvent and SessionCreatedEvent through SessionMessageListener . Instantiating a RedisIndexedSessionRepository: You can see a typical example of how to create a new instance in the following listing: RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>(); // ... configure redisTemplate ... SessionRepository<? extends Session> repository = new RedisIndexedSessionRepository(redisTemplate); For additional information on how to create a RedisConnectionFactory , see the Spring Data Redis Reference. Using @EnableRedisHttpSession(enableIndexingAndEvents = true): In a web environment, the simplest way to create a new RedisIndexedSessionRepository is to use @EnableRedisHttpSession(enableIndexingAndEvents = true) . You can find complete example usage in the Samples and Guides (Start Here)(samples.html#samples) . You can use the following attributes to customize the configuration: enableIndexingAndEvents : Whether to use a RedisIndexedSessionRepository instead of a RedisSessionRepository . The default is false . maxInactiveIntervalInSeconds : The amount of time before the session expires, in seconds. redisNamespace : Allows configuring an application specific namespace for the sessions. Redis keys and channel IDs start with the prefix of <redisNamespace>: . flushMode : Allows specifying when data is written to Redis. The default is only when save is invoked on SessionRepository . A value of FlushMode.IMMEDIATE writes to Redis as soon as possible. Custom RedisSerializer: You can customize the serialization by creating a bean named springSessionDefaultRedisSerializer that implements RedisSerializer<Object> . Redis TaskExecutor: RedisIndexedSessionRepository is subscribed to receive events from Redis by using a RedisMessageListenerContainer . You can customize the way those events are dispatched by creating a bean named springSessionRedisTaskExecutor , a bean springSessionRedisSubscriptionExecutor , or both. You can find more details on configuring Redis task executors here(https://docs.spring.io/spring-data-redis/docs/3.0.11/reference/html/#redis:pubsub:subscribe:containers) . Storage Details: The following sections outline how Redis is updated for each operation. The following example shows an example of creating a new session: HMSET spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe creationTime 1404360000000 \ maxInactiveInterval 1800 \ lastAccessedTime 1404360000000 \ sessionAttr:attrName someAttrValue \ sessionAttr:attrName2 someAttrValue2 EXPIRE spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe 2100 APPEND spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe """" EXPIRE spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe 1800 SADD spring:session:expirations:1439245080000 expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe EXPIRE spring:session:expirations1439245080000 2100 The subsequent sections describe the details. Saving a Session: Each session is stored in Redis as a Hash . Each session is set and updated by using the HMSET command. The following example shows how each session is stored: HMSET spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe creationTime 1404360000000 \ maxInactiveInterval 1800 \ lastAccessedTime 1404360000000 \ sessionAttr:attrName someAttrValue \ sessionAttr:attrName2 someAttrValue2 In the preceding example, the following statements are true about the session: The session ID is 33fdd1b6-b496-4b33-9f7d-df96679d32fe. The session was created at 1404360000000 (in milliseconds since midnight of 1/1/1970 GMT). The session expires in 1800 seconds (30 minutes). The session was last accessed at 1404360000000 (in milliseconds since midnight of 1/1/1970 GMT). The session has two attributes. The first is attrName , with a value of someAttrValue . The second session attribute is named attrName2 , with a value of someAttrValue2 . Optimized Writes: The Session instances managed by RedisIndexedSessionRepository keeps track of the properties that have changed and updates only those. This means that, if an attribute is written once and read many times, we need to write that attribute only once. For example, assume the attrName2 session attribute from the lsiting in the preceding section was updated. The following command would be run upon saving: HMSET spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe sessionAttr:attrName2 newValue Session Expiration: An expiration is associated with each session by using the EXPIRE command, based upon the Session.getMaxInactiveInterval() . The following example shows a typical EXPIRE command: EXPIRE spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe 2100 Note that the expiration that is set to five minutes after the session actually expires. This is necessary so that the value of the session can be accessed when the session expires. An expiration is set on the session itself five minutes after it actually expires to ensure that it is cleaned up, but only after we perform any necessary processing. The SessionRepository.findById(String) method ensures that no expired sessions are returned. This means that you need not check the expiration before using a session. Spring Session relies on the delete and expired keyspace notifications(https://redis.io/topics/notifications) from Redis to fire a SessionDeletedEvent(#api-redisindexedsessionrepository-sessiondestroyedevent) and a SessionExpiredEvent(#api-redisindexedsessionrepository-sessiondestroyedevent) , respectively. SessionDeletedEvent or SessionExpiredEvent ensure that resources associated with the Session are cleaned up. For example, when you use Spring Session’s WebSocket support, the Redis expired or delete event triggers any WebSocket connections associated with the session to be closed. Expiration is not tracked directly on the session key itself, since this would mean the session data would no longer be available. Instead, a special session expires key is used. In the preceding example, the expires key is as follows: APPEND spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe """" EXPIRE spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe 1800 When a session expires key is deleted or expires, the keyspace notification triggers a lookup of the actual session, and a SessionDestroyedEvent is fired. One problem with relying on Redis expiration exclusively is that, if the key has not been accessed, Redis makes no guarantee of when the expired event is fired. Specifically, the background task that Redis uses to clean up expired keys is a low-priority task and may not trigger the key expiration. For additional details, see the Timing of Expired Events(https://redis.io/topics/notifications) section in the Redis documentation. To circumvent the fact that expired events are not guaranteed to happen, we can ensure that each key is accessed when it is expected to expire. This means that, if the TTL is expired on the key, Redis removes the key and fires the expired event when we try to access the key. For this reason, each session expiration is also tracked to the nearest minute. This lets a background task access the potentially expired sessions to ensure that Redis expired events are fired in a more deterministic fashion. The following example shows these events: SADD spring:session:expirations:1439245080000 expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe EXPIRE spring:session:expirations1439245080000 2100 The background task then uses these mappings to explicitly request each key. By accessing the key, rather than deleting it, we ensure that Redis deletes the key for us only if the TTL is expired. We do not explicitly delete the keys, since, in some instances, there may be a race condition that incorrectly identifies a key as expired when it is not. Short of using distributed locks (which would kill our performance), there is no way to ensure the consistency of the expiration mapping. By simply accessing the key, we ensure that the key is only removed if the TTL on that key is expired. SessionDeletedEvent and SessionExpiredEvent: SessionDeletedEvent and SessionExpiredEvent are both types of SessionDestroyedEvent . RedisIndexedSessionRepository supports firing a SessionDeletedEvent when a Session is deleted or a SessionExpiredEvent when a Session expires. This is necessary to ensure resources associated with the Session are properly cleaned up. For example, when integrating with WebSockets, the SessionDestroyedEvent is in charge of closing any active WebSocket connections. Firing SessionDeletedEvent or SessionExpiredEvent is made available through the SessionMessageListener , which listens to Redis Keyspace events(https://redis.io/topics/notifications) . In order for this to work, Redis Keyspace events for Generic commands and Expired events needs to be enabled. The following example shows how to do so: redis-cli config set notify-keyspace-events Egx If you use @EnableRedisHttpSession(enableIndexingAndEvents = true) , managing the SessionMessageListener and enabling the necessary Redis Keyspace events is done automatically. However, in a secured Redis enviornment, the config command is disabled. This means that Spring Session cannot configure Redis Keyspace events for you. To disable the automatic configuration, add ConfigureRedisAction.NO_OP as a bean. For example, with Java configuration, you can use the following: @Bean ConfigureRedisAction configureRedisAction() { return ConfigureRedisAction.NO_OP; } In XML configuration, you can use the following: <util:constant static-field=""org.springframework.session.data.redis.config.ConfigureRedisAction.NO_OP""/> Using SessionCreatedEvent: When a session is created, an event is sent to Redis with a channel ID of spring:session:channel:created:33fdd1b6-b496-4b33-9f7d-df96679d32fe , where 33fdd1b6-b496-4b33-9f7d-df96679d32fe is the session ID. The body of the event is the session that was created. If registered as a MessageListener (the default), RedisIndexedSessionRepository then translates the Redis message into a SessionCreatedEvent . Viewing the Session in Redis: After installing redis-cli(https://redis.io/topics/quickstart) , you can inspect the values in Redis using the redis-cli(https://redis.io/commands#hash) . For example, you can enter the following into a terminal: $ redis-cli redis 127.0.0.1:6379> keys * 1) ""spring:session:sessions:4fc39ce3-63b3-4e17-b1c4-5e1ed96fb021"" (1) 2) ""spring:session:expirations:1418772300000"" (2) 1 The suffix of this key is the session identifier of the Spring Session. 2 This key contains all the session IDs that should be deleted at the time 1418772300000 . You can also view the attributes of each session. The following example shows how to do so: redis 127.0.0.1:6379> hkeys spring:session:sessions:4fc39ce3-63b3-4e17-b1c4-5e1ed96fb021 1) ""lastAccessedTime"" 2) ""creationTime"" 3) ""maxInactiveInterval"" 4) ""sessionAttr:username"" redis 127.0.0.1:6379> hget spring:session:sessions:4fc39ce3-63b3-4e17-b1c4-5e1ed96fb021 sessionAttr:username ""\xac\xed\x00\x05t\x00\x03rob"" Using ReactiveRedisSessionRepository: ReactiveRedisSessionRepository is a ReactiveSessionRepository that is implemented by using Spring Data’s ReactiveRedisOperations . In a web environment, this is typically used in combination with WebSessionStore . Instantiating a ReactiveRedisSessionRepository: The following example shows how to create a new instance: // ... create and configure connectionFactory and serializationContext ... ReactiveRedisTemplate<String, Object> redisTemplate = new ReactiveRedisTemplate<>(connectionFactory, serializationContext); ReactiveSessionRepository<? extends Session> repository = new ReactiveRedisSessionRepository(redisTemplate); For additional information on how to create a ReactiveRedisConnectionFactory , see the Spring Data Redis Reference. Using @EnableRedisWebSession: In a web environment, the simplest way to create a new ReactiveRedisSessionRepository is to use @EnableRedisWebSession . You can use the following attributes to customize the configuration: maxInactiveIntervalInSeconds : The amount of time before the session expires, in seconds redisNamespace : Allows configuring an application specific namespace for the sessions. Redis keys and channel IDs start with q prefix of <redisNamespace>: . flushMode : Allows specifying when data is written to Redis. The default is only when save is invoked on ReactiveSessionRepository . A value of FlushMode.IMMEDIATE writes to Redis as soon as possible. Optimized Writes: The Session instances managed by ReactiveRedisSessionRepository keep track of the properties that have changed and updates only those. This means that, if an attribute is written once and read many times, we need to write that attribute only once. Viewing the Session in Redis: After installing redis-cli(https://redis.io/topics/quickstart) , you can inspect the values in Redis using the redis-cli(https://redis.io/commands#hash) . For example, you can enter the following command into a terminal window: $ redis-cli redis 127.0.0.1:6379> keys * 1) ""spring:session:sessions:4fc39ce3-63b3-4e17-b1c4-5e1ed96fb021"" (1) 1 The suffix of this key is the session identifier of the Spring Session. You can also view the attributes of each session by using the hkeys command. The following example shows how to do so: redis 127.0.0.1:6379> hkeys spring:session:sessions:4fc39ce3-63b3-4e17-b1c4-5e1ed96fb021 1) ""lastAccessedTime"" 2) ""creationTime"" 3) ""maxInactiveInterval"" 4) ""sessionAttr:username"" redis 127.0.0.1:6379> hget spring:session:sessions:4fc39ce3-63b3-4e17-b1c4-5e1ed96fb021 sessionAttr:username ""\xac\xed\x00\x05t\x00\x03rob"" Using MapSessionRepository: The MapSessionRepository allows for persisting Session in a Map , with the key being the Session ID and the value being the Session . You can use the implementation with a ConcurrentHashMap as a testing or convenience mechanism. Alternatively, you can use it with distributed Map implementations. For example, it can be used with Hazelcast. Instantiating MapSessionRepository: The following example shows how to create a new instance: SessionRepository<? extends Session> repository = new MapSessionRepository(new ConcurrentHashMap<>()); Using Spring Session and Hazlecast: The Hazelcast Sample(samples.html#samples) is a complete application that demonstrates how to use Spring Session with Hazelcast. To run it, use the following command: ./gradlew :samples:hazelcast:tomcatRun The Hazelcast Spring Sample(samples.html#samples) is a complete application that demonstrates how to use Spring Session with Hazelcast and Spring Security. It includes example Hazelcast MapListener implementations that support firing SessionCreatedEvent , SessionDeletedEvent , and SessionExpiredEvent . To run it, use the following command: ./gradlew :samples:hazelcast-spring:tomcatRun Using ReactiveMapSessionRepository: The ReactiveMapSessionRepository allows for persisting Session in a Map , with the key being the Session ID and the value being the Session . You can use the implementation with a ConcurrentHashMap as a testing or convenience mechanism. Alternatively, you can use it with distributed Map implementations, with the requirement that the supplied Map must be non-blocking. Using JdbcIndexedSessionRepository: JdbcIndexedSessionRepository is a SessionRepository implementation that uses Spring’s JdbcOperations to store sessions in a relational database. In a web environment, this is typically used in combination with SessionRepositoryFilter . Note that this implementation does not support publishing of session events. Instantiating a JdbcIndexedSessionRepository: The following example shows how to create a new instance: JdbcTemplate jdbcTemplate = new JdbcTemplate(); // ... configure jdbcTemplate ... TransactionTemplate transactionTemplate = new TransactionTemplate(); // ... configure transactionTemplate ... SessionRepository<? extends Session> repository = new JdbcIndexedSessionRepository(jdbcTemplate, transactionTemplate); For additional information on how to create and configure JdbcTemplate and PlatformTransactionManager , see the Spring Framework Reference Documentation(https://docs.spring.io/spring/docs/6.0.13/spring-framework-reference/data-access.html) . Using @EnableJdbcHttpSession: In a web environment, the simplest way to create a new JdbcIndexedSessionRepository is to use @EnableJdbcHttpSession . You can find complete example usage in the Samples and Guides (Start Here)(samples.html#samples) You can use the following attributes to customize the configuration: tableName : The name of database table used by Spring Session to store sessions maxInactiveIntervalInSeconds : The amount of time before the session will expire in seconds Customizing LobHandler: You can customize BLOB handling by creating a bean named springSessionLobHandler that implements LobHandler . Customizing ConversionService: You can customize the default serialization and deserialization of the session by providing a ConversionService instance. When working in a typical Spring environment, the default ConversionService bean (named conversionService ) is automatically picked up and used for serialization and deserialization. However, you can override the default ConversionService by providing a bean named springSessionConversionService . Storage Details: By default, this implementation uses SPRING_SESSION and SPRING_SESSION_ATTRIBUTES tables to store sessions. Note that you can customize the table name, as already described. In that case, the table used to store attributes is named by using the provided table name suffixed with _ATTRIBUTES . If further customizations are needed, you can customize the SQL queries used by the repository by using set*Query setter methods. In this case, you need to manually configure the sessionRepository bean. Due to the differences between the various database vendors, especially when it comes to storing binary data, make sure to use SQL scripts specific to your database. Scripts for most major database vendors are packaged as org/springframework/session/jdbc/schema-*.sql , where * is the target database type. For example, with PostgreSQL, you can use the following schema script: CREATE TABLE SPRING_SESSION ( PRIMARY_ID CHAR(36) NOT NULL, SESSION_ID CHAR(36) NOT NULL, CREATION_TIME BIGINT NOT NULL, LAST_ACCESS_TIME BIGINT NOT NULL, MAX_INACTIVE_INTERVAL INT NOT NULL, EXPIRY_TIME BIGINT NOT NULL, PRINCIPAL_NAME VARCHAR(100), CONSTRAINT SPRING_SESSION_PK PRIMARY KEY (PRIMARY_ID) ); CREATE UNIQUE INDEX SPRING_SESSION_IX1 ON SPRING_SESSION (SESSION_ID); CREATE INDEX SPRING_SESSION_IX2 ON SPRING_SESSION (EXPIRY_TIME); CREATE INDEX SPRING_SESSION_IX3 ON SPRING_SESSION (PRINCIPAL_NAME); CREATE TABLE SPRING_SESSION_ATTRIBUTES ( SESSION_PRIMARY_ID CHAR(36) NOT NULL, ATTRIBUTE_NAME VARCHAR(200) NOT NULL, ATTRIBUTE_BYTES BYTEA NOT NULL, CONSTRAINT SPRING_SESSION_ATTRIBUTES_PK PRIMARY KEY (SESSION_PRIMARY_ID, ATTRIBUTE_NAME), CONSTRAINT SPRING_SESSION_ATTRIBUTES_FK FOREIGN KEY (SESSION_PRIMARY_ID) REFERENCES SPRING_SESSION(PRIMARY_ID) ON DELETE CASCADE ); With MySQL database, you can use the following script: CREATE TABLE SPRING_SESSION ( PRIMARY_ID CHAR(36) NOT NULL, SESSION_ID CHAR(36) NOT NULL, CREATION_TIME BIGINT NOT NULL, LAST_ACCESS_TIME BIGINT NOT NULL, MAX_INACTIVE_INTERVAL INT NOT NULL, EXPIRY_TIME BIGINT NOT NULL, PRINCIPAL_NAME VARCHAR(100), CONSTRAINT SPRING_SESSION_PK PRIMARY KEY (PRIMARY_ID) ) ENGINE=InnoDB ROW_FORMAT=DYNAMIC; CREATE UNIQUE INDEX SPRING_SESSION_IX1 ON SPRING_SESSION (SESSION_ID); CREATE INDEX SPRING_SESSION_IX2 ON SPRING_SESSION (EXPIRY_TIME); CREATE INDEX SPRING_SESSION_IX3 ON SPRING_SESSION (PRINCIPAL_NAME); CREATE TABLE SPRING_SESSION_ATTRIBUTES ( SESSION_PRIMARY_ID CHAR(36) NOT NULL, ATTRIBUTE_NAME VARCHAR(200) NOT NULL, ATTRIBUTE_BYTES BLOB NOT NULL, CONSTRAINT SPRING_SESSION_ATTRIBUTES_PK PRIMARY KEY (SESSION_PRIMARY_ID, ATTRIBUTE_NAME), CONSTRAINT SPRING_SESSION_ATTRIBUTES_FK FOREIGN KEY (SESSION_PRIMARY_ID) REFERENCES SPRING_SESSION(PRIMARY_ID) ON DELETE CASCADE ) ENGINE=InnoDB ROW_FORMAT=DYNAMIC; Transaction Management: All JDBC operations in JdbcIndexedSessionRepository are performed in a transactional manner. Transactions are performed with propagation set to REQUIRES_NEW in order to avoid unexpected behavior due to interference with existing transactions (for example, running a save operation in a thread that already participates in a read-only transaction). Using HazelcastIndexedSessionRepository: HazelcastIndexedSessionRepository is a SessionRepository implementation that stores sessions in Hazelcast’s distributed IMap . In a web environment, this is typically used in combination with SessionRepositoryFilter . Instantiating a HazelcastIndexedSessionRepository: The following example shows how to create a new instance: Config config = new Config(); // ... configure Hazelcast ... HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance(config); HazelcastIndexedSessionRepository repository = new HazelcastIndexedSessionRepository(hazelcastInstance); For additional information on how to create and configure Hazelcast instance, see the Hazelcast documentation(https://docs.hazelcast.org/docs/5.1.4/manual/html-single/index.html#hazelcast-configuration) . Using @EnableHazelcastHttpSession: To use Hazelcast(https://hazelcast.org/) as your backing source for the SessionRepository , you can add the @EnableHazelcastHttpSession annotation to a @Configuration class. Doing so extends the functionality provided by the @EnableSpringHttpSession annotation but makes the SessionRepository for you in Hazelcast. You must provide a single HazelcastInstance bean for the configuration to work. You can find a complete configuration example in the Samples and Guides (Start Here)(samples.html#samples) . Basic Customization: You can use the following attributes on @EnableHazelcastHttpSession to customize the configuration: maxInactiveIntervalInSeconds : The amount of time before the session expires, in seconds. The default is 1800 seconds (30 minutes) sessionMapName : The name of the distributed Map that is used in Hazelcast to store the session data. Session Events: Using a MapListener to respond to entries being added, evicted, and removed from the distributed Map causes these events to trigger publishing of SessionCreatedEvent , SessionExpiredEvent , and SessionDeletedEvent events (respectively) through the ApplicationEventPublisher . Storage Details: Sessions are stored in a distributed IMap in Hazelcast. The IMap interface methods are used to get() and put() Sessions. Additionally, the values() method supports a FindByIndexNameSessionRepository#findByIndexNameAndIndexValue operation, together with appropriate ValueExtractor (which needs to be registered with Hazelcast). See the Hazelcast Spring Sample(samples.html#samples) for more details on this configuration. The expiration of a session in the IMap is handled by Hazelcast’s support for setting the time to live on an entry when it is put() into the IMap . Entries (sessions) that have been idle longer than the time to live are automatically removed from the IMap . You should not need to configure any settings such as max-idle-seconds or time-to-live-seconds for the IMap within the Hazelcast configuration. Note that if you use Hazelcast’s MapStore to persist your sessions IMap , the following limitations apply when reloading the sessions from MapStore : Reloading triggers EntryAddedListener results in SessionCreatedEvent being re-published Reloading uses default TTL for a given IMap results in sessions losing their original TTL Using CookieSerializer: A CookieSerializer is responsible for defining how the session cookie is written. Spring Session comes with a default implementation using DefaultCookieSerializer . Exposing CookieSerializer as a bean: Exposing the CookieSerializer as a Spring bean augments the existing configuration when you use configurations like @EnableRedisHttpSession . The following example shows how to do so: @Bean public CookieSerializer cookieSerializer() { DefaultCookieSerializer serializer = new DefaultCookieSerializer(); serializer.setCookieName(""JSESSIONID""); (1) serializer.setCookiePath(""/""); (2) serializer.setDomainNamePattern(""^.+?\\.(\\w+\\.[a-z]+)$""); (3) return serializer; } 1 We customize the name of the cookie to be JSESSIONID . 2 We customize the path of the cookie to be / (rather than the default of the context root). 3 We customize the domain name pattern (a regular expression) to be ^.?\\.(\\w\\.[a-z]+)$ . This allows sharing a session across domains and applications. If the regular expression does not match, no domain is set and the existing domain is used. If the regular expression matches, the first grouping(https://docs.oracle.com/javase/tutorial/essential/regex/groups.html) is used as the domain. This means that a request to child.example.com(https://child.example.com) sets the domain to example.com . However, a request to localhost:8080/(http://localhost:8080/) or 192.168.1.100:8080/(https://192.168.1.100:8080/) leaves the cookie unset and, thus, still works in development without any changes being necessary for production. You should only match on valid domain characters, since the domain name is reflected in the response. Doing so prevents a malicious user from performing such attacks as HTTP Response Splitting(https://en.wikipedia.org/wiki/HTTP_response_splitting) . Customizing CookieSerializer: You can customize how the session cookie is written by using any of the following configuration options on the DefaultCookieSerializer . cookieName : The name of the cookie to use. Default: SESSION . useSecureCookie : Specifies whether a secure cookie should be used. Default: Use the value of HttpServletRequest.isSecure() at the time of creation. cookiePath : The path of the cookie. Default: The context root. cookieMaxAge : Specifies the max age of the cookie to be set at the time the session is created. Default: -1 , which indicates the cookie should be removed when the browser is closed. jvmRoute : Specifies a suffix to be appended to the session ID and included in the cookie. Used to identify which JVM to route to for session affinity. With some implementations (that is, Redis) this option provides no performance benefit. However, it can help with tracing logs of a particular user. domainName : Allows specifying a specific domain name to be used for the cookie. This option is simple to understand but often requires a different configuration between development and production environments. See domainNamePattern as an alternative. domainNamePattern : A case-insensitive pattern used to extract the domain name from the HttpServletRequest#getServerName() . The pattern should provide a single grouping that is used to extract the value of the cookie domain. If the regular expression does not match, no domain is set and the existing domain is used. If the regular expression matches, the first grouping(https://docs.oracle.com/javase/tutorial/essential/regex/groups.html) is used as the domain. sameSite : The value for the SameSite cookie directive. To disable the serialization of the SameSite cookie directive, you may set this value to null . Default: Lax You should only match on valid domain characters, since the domain name is reflected in the response. Doing so prevents a malicious user from performing such attacks as HTTP Response Splitting(https://en.wikipedia.org/wiki/HTTP_response_splitting) . Customizing SessionRepository: Implementing a custom SessionRepository(#api-sessionrepository) API should be a fairly straightforward task. Coupling the custom implementation with @EnableSpringHttpSession(#api-enablespringhttpsession) support lets you reuse existing Spring Session configuration facilities and infrastructure. There are, however, a couple of aspects that deserve closer consideration. During the lifecycle of an HTTP request, the HttpSession is typically persisted to SessionRepository twice. The first persist operation is to ensure that the session is available to the client as soon as the client has access to the session ID, and it is also necessary to write after the session is committed because further modifications to the session might be made. Having this in mind, we generally recommend that a SessionRepository implementation keep track of changes to ensure that only deltas are saved. This is particularly important in highly concurrent environments, where multiple requests operate on the same HttpSession and, therefore, cause race conditions, with requests overriding each other’s changes to session attributes. All of the SessionRepository implementations provided by Spring Session use the described approach to persist session changes and can be used for guidance when you implement custom SessionRepository . Note that the same recommendations apply for implementing a custom ReactiveSessionRepository(#api-reactivesessionrepository) as well. In this case, you should use the @EnableSpringWebSession(#api-enablespringwebsession) ."
"https://docs.spring.io/spring-session/reference/3.0/upgrading.html","For the latest stable version, please use Spring Session 3.3.2(../upgrading.html) ! Upgrading to 3.x: With the new major release version, the Spring Session team took the opportunity to make some non-passive changes. The focus of these changes is to improve and harmonize Spring Session’s APIs as well as remove the deprecated components. Baseline Update: Spring Session 3.0 requires Java 17 and Spring Framework 6.0 as a baseline, since its entire codebase is now based on Java 17 source code. See Upgrading to Spring Framework 5.x(https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-5.x) for more on upgrading Spring Framework. Replaced and Removed Packages, Classes, and Methods: The following changes were made to packages, classes, and methods: Dropped Support:"
