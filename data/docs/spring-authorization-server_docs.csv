"url","content"
"https://docs.spring.io/spring-authorization-server/reference/1.3/overview.html","Overview: This site contains reference documentation and how-to guides for Spring Authorization Server. Introducing Spring Authorization Server: Spring Authorization Server is a framework that provides implementations of the OAuth 2.1(https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07) and OpenID Connect 1.0(https://openid.net/specs/openid-connect-core-1_0.html) specifications and other related specifications. It is built on top of Spring Security(https://spring.io/projects/spring-security) to provide a secure, light-weight, and customizable foundation for building OpenID Connect 1.0 Identity Providers and OAuth2 Authorization Server products. Use Cases: The following list provides some use cases for using Spring Authorization Server compared to using an open source or commercial OAuth2 or OpenID Connect 1.0 Provider product. Provides full control of configuration and customization when advanced customization scenarios are required. Preference for a light-weight authorization server compared to a commercial product that includes all the ""bells and whistles"". Potential savings in software licensing and/or hosting costs. Quick startup and ease of use during development using the familiar Spring programming model. Feature List: Spring Authorization Server supports the following features: Category Feature Related specifications Authorization Grant(protocol-endpoints.html#oauth2-token-endpoint) Authorization Code User Consent(protocol-endpoints.html#oauth2-authorization-endpoint) Client Credentials Refresh Token Device Code User Consent(protocol-endpoints.html#oauth2-device-verification-endpoint) Token Exchange The OAuth 2.1 Authorization Framework ( draft(https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07) ) Authorization Code Grant(https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-4.1) Client Credentials Grant(https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-4.2) Refresh Token Grant(https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-4.3) OpenID Connect Core 1.0 ( spec(https://openid.net/specs/openid-connect-core-1_0.html) ) Authorization Code Flow(https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth) OAuth 2.0 Device Authorization Grant ( spec(https://tools.ietf.org/html/rfc8628) ) Device Flow(https://tools.ietf.org/html/rfc8628#section-3) OAuth 2.0 Token Exchange ( spec(https://datatracker.ietf.org/doc/html/rfc8693) ) Token Exchange Flow(https://datatracker.ietf.org/doc/html/rfc8693#section-2) Token Formats(core-model-components.html#oauth2-token-generator) Self-contained (JWT) Reference (Opaque) JSON Web Token (JWT) ( RFC 7519(https://tools.ietf.org/html/rfc7519) ) JSON Web Signature (JWS) ( RFC 7515(https://tools.ietf.org/html/rfc7515) ) Client Authentication(configuration-model.html#configuring-client-authentication) client_secret_basic client_secret_post client_secret_jwt private_key_jwt tls_client_auth self_signed_tls_client_auth none (public clients) The OAuth 2.1 Authorization Framework ( Client Authentication(https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-2.4) ) JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication ( RFC 7523(https://tools.ietf.org/html/rfc7523) ) OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens ( RFC 8705(https://datatracker.ietf.org/doc/html/rfc8705) ) Proof Key for Code Exchange by OAuth Public Clients (PKCE) ( RFC 7636(https://tools.ietf.org/html/rfc7636) ) Protocol Endpoints(protocol-endpoints.html) OAuth2 Authorization Endpoint(protocol-endpoints.html#oauth2-authorization-endpoint) OAuth2 Device Authorization Endpoint(protocol-endpoints.html#oauth2-device-authorization-endpoint) OAuth2 Device Verification Endpoint(protocol-endpoints.html#oauth2-device-verification-endpoint) OAuth2 Token Endpoint(protocol-endpoints.html#oauth2-token-endpoint) OAuth2 Token Introspection Endpoint(protocol-endpoints.html#oauth2-token-introspection-endpoint) OAuth2 Token Revocation Endpoint(protocol-endpoints.html#oauth2-token-revocation-endpoint) OAuth2 Authorization Server Metadata Endpoint(protocol-endpoints.html#oauth2-authorization-server-metadata-endpoint) JWK Set Endpoint(protocol-endpoints.html#jwk-set-endpoint) OpenID Connect 1.0 Provider Configuration Endpoint(protocol-endpoints.html#oidc-provider-configuration-endpoint) OpenID Connect 1.0 Logout Endpoint(protocol-endpoints.html#oidc-logout-endpoint) OpenID Connect 1.0 UserInfo Endpoint(protocol-endpoints.html#oidc-user-info-endpoint) OpenID Connect 1.0 Client Registration Endpoint(protocol-endpoints.html#oidc-client-registration-endpoint) The OAuth 2.1 Authorization Framework ( draft(https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07) ) Authorization Endpoint(https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-3.1) Token Endpoint(https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-3.2) OAuth 2.0 Device Authorization Grant ( RFC 8628(https://tools.ietf.org/html/rfc8628) ) Device Authorization Endpoint(https://tools.ietf.org/html/rfc8628#section-3.1) Device Verification Endpoint(https://tools.ietf.org/html/rfc8628#section-3.3) OAuth 2.0 Token Introspection ( RFC 7662(https://tools.ietf.org/html/rfc7662) ) OAuth 2.0 Token Revocation ( RFC 7009(https://tools.ietf.org/html/rfc7009) ) OAuth 2.0 Authorization Server Metadata ( RFC 8414(https://tools.ietf.org/html/rfc8414) ) JSON Web Key (JWK) ( RFC 7517(https://tools.ietf.org/html/rfc7517) ) OpenID Connect Discovery 1.0 ( spec(https://openid.net/specs/openid-connect-discovery-1_0.html) ) Provider Configuration Endpoint(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) OpenID Connect RP-Initiated Logout 1.0 ( spec(https://openid.net/specs/openid-connect-rpinitiated-1_0.html) ) Logout Endpoint(https://openid.net/specs/openid-connect-rpinitiated-1_0.html#RPLogout) OpenID Connect Core 1.0 ( spec(https://openid.net/specs/openid-connect-core-1_0.html) ) UserInfo Endpoint(https://openid.net/specs/openid-connect-core-1_0.html#UserInfo) OpenID Connect Dynamic Client Registration 1.0 ( spec(https://openid.net/specs/openid-connect-registration-1_0.html) ) Client Registration Endpoint(https://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration) Client Configuration Endpoint(https://openid.net/specs/openid-connect-registration-1_0.html#ClientConfigurationEndpoint)"
"https://docs.spring.io/spring-authorization-server/reference/1.3/getting-help.html","Getting Help: Community: Welcome to the Spring Security Community(https://docs.spring.io/spring-security/reference/community.html) . Spring Authorization Server is an open source project led by the Spring Security team. If you need help with Spring Authorization Server, we are here to help. Resources: The following are some of the best ways to get help: Try the How-to guides(how-to.html) . They provide solutions to the most common questions. Learn the Spring Security basics that Spring Authorization Server builds on. If you are starting out with Spring Security, check the reference documentation(https://spring.io/projects/spring-security#learn) or try one of the samples(https://github.com/spring-projects/spring-security-samples) . Read through this documentation(index.html) . Try one of our many sample applications(https://github.com/spring-projects/spring-authorization-server/tree/main/samples) . Ask a question on Stack Overflow with the spring-authorization-server(https://stackoverflow.com/questions/tagged/spring-authorization-server) tag. Report bugs and enhancement requests on GitHub(https://github.com/spring-projects/spring-authorization-server/issues) . Spring Authorization Server is open source, including the documentation. If you find problems with the docs or if you want to improve them, please get involved(https://github.com/spring-projects/spring-authorization-server) ."
"https://docs.spring.io/spring-authorization-server/reference/1.3/getting-started.html","Getting Started: If you are just getting started with Spring Authorization Server, the following sections walk you through creating your first application. System Requirements: Spring Authorization Server requires a Java 17 or higher Runtime Environment. Installing Spring Authorization Server: Spring Authorization Server can be used anywhere you already use Spring Security(https://docs.spring.io/spring-security/reference/prerequisites.html) . The easiest way to begin using Spring Authorization Server is by creating a Spring Boot(https://spring.io/projects/spring-boot) -based application. You can use start.spring.io(https://start.spring.io) to generate a basic project or use the default authorization server sample(https://github.com/spring-projects/spring-authorization-server/tree/main/samples/default-authorizationserver) as a guide. Then add Spring Boot’s starter for Spring Authorization Server as a dependency: Maven Gradle <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId> </dependency> implementation ""org.springframework.boot:spring-boot-starter-oauth2-authorization-server"" See Installing Spring Boot(https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.installing) for more information on using Spring Boot with Maven or Gradle. Alternatively, you can add Spring Authorization Server without Spring Boot using the following example: Maven Gradle <dependency> <groupId>org.springframework.security</groupId> <artifactId>spring-security-oauth2-authorization-server</artifactId> <version>1.3.2</version> </dependency> implementation ""org.springframework.security:spring-security-oauth2-authorization-server:1.3.2"" Developing Your First Application: To get started, you need the minimum required components defined as a @Bean . When using the spring-boot-starter-oauth2-authorization-server dependency, define the following properties and Spring Boot will provide the necessary @Bean definitions for you: application.yml server: port: 9000 logging: level: org.springframework.security: trace spring: security: user: name: user password: password oauth2: authorizationserver: client: oidc-client: registration: client-id: ""oidc-client"" client-secret: ""{noop}secret"" client-authentication-methods: - ""client_secret_basic"" authorization-grant-types: - ""authorization_code"" - ""refresh_token"" redirect-uris: - ""http://127.0.0.1:8080/login/oauth2/code/oidc-client"" post-logout-redirect-uris: - ""http://127.0.0.1:8080/"" scopes: - ""openid"" - ""profile"" require-authorization-consent: true Beyond the Getting Started experience, most users will want to customize the default configuration. The next section(#defining-required-components) demonstrates providing all of the necessary beans yourself. Defining Required Components: If you want to customize the default configuration (regardless of whether you’re using Spring Boot), you can define the minimum required components as a @Bean in a Spring @Configuration . These components can be defined as follows: SecurityConfig.java import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.util.UUID; import com.nimbusds.jose.jwk.JWKSet; import com.nimbusds.jose.jwk.RSAKey; import com.nimbusds.jose.jwk.source.ImmutableJWKSet; import com.nimbusds.jose.jwk.source.JWKSource; import com.nimbusds.jose.proc.SecurityContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.annotation.Order; import org.springframework.http.MediaType; import org.springframework.security.config.Customizer; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.oauth2.core.AuthorizationGrantType; import org.springframework.security.oauth2.core.ClientAuthenticationMethod; import org.springframework.security.oauth2.core.oidc.OidcScopes; import org.springframework.security.oauth2.jwt.JwtDecoder; import org.springframework.security.oauth2.server.authorization.client.InMemoryRegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.client.RegisteredClient; import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configuration.OAuth2AuthorizationServerConfiguration; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configurers.OAuth2AuthorizationServerConfigurer; import org.springframework.security.oauth2.server.authorization.settings.AuthorizationServerSettings; import org.springframework.security.oauth2.server.authorization.settings.ClientSettings; import org.springframework.security.provisioning.InMemoryUserDetailsManager; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint; import org.springframework.security.web.util.matcher.MediaTypeRequestMatcher; @Configuration @EnableWebSecurity public class SecurityConfig { @Bean (1) @Order(1) public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); http.getConfigurer(OAuth2AuthorizationServerConfigurer.class) .oidc(Customizer.withDefaults()); // Enable OpenID Connect 1.0 http // Redirect to the login page when not authenticated from the // authorization endpoint .exceptionHandling((exceptions) -> exceptions .defaultAuthenticationEntryPointFor( new LoginUrlAuthenticationEntryPoint(""/login""), new MediaTypeRequestMatcher(MediaType.TEXT_HTML) ) ) // Accept access tokens for User Info and/or Client Registration .oauth2ResourceServer((resourceServer) -> resourceServer .jwt(Customizer.withDefaults())); return http.build(); } @Bean (2) @Order(2) public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) // Form login handles the redirect to the login page from the // authorization server filter chain .formLogin(Customizer.withDefaults()); return http.build(); } @Bean (3) public UserDetailsService userDetailsService() { UserDetails userDetails = User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .roles(""USER"") .build(); return new InMemoryUserDetailsManager(userDetails); } @Bean (4) public RegisteredClientRepository registeredClientRepository() { RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(""oidc-client"") .clientSecret(""{noop}secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN) .redirectUri(""http://127.0.0.1:8080/login/oauth2/code/oidc-client"") .postLogoutRedirectUri(""http://127.0.0.1:8080/"") .scope(OidcScopes.OPENID) .scope(OidcScopes.PROFILE) .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build()) .build(); return new InMemoryRegisteredClientRepository(oidcClient); } @Bean (5) public JWKSource<SecurityContext> jwkSource() { KeyPair keyPair = generateRsaKey(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); RSAKey rsaKey = new RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build(); JWKSet jwkSet = new JWKSet(rsaKey); return new ImmutableJWKSet<>(jwkSet); } private static KeyPair generateRsaKey() { (6) KeyPair keyPair; try { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA""); keyPairGenerator.initialize(2048); keyPair = keyPairGenerator.generateKeyPair(); } catch (Exception ex) { throw new IllegalStateException(ex); } return keyPair; } @Bean (7) public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) { return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource); } @Bean (8) public AuthorizationServerSettings authorizationServerSettings() { return AuthorizationServerSettings.builder().build(); } } This is a minimal configuration for getting started quickly. To understand what each component is used for, see the following descriptions: 1 A Spring Security filter chain for the Protocol Endpoints(protocol-endpoints.html) . 2 A Spring Security filter chain for authentication(https://docs.spring.io/spring-security/reference/servlet/authentication/index.html) . 3 An instance of UserDetailsService(https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/UserDetailsService.html) for retrieving users to authenticate. 4 An instance of RegisteredClientRepository(core-model-components.html#registered-client-repository) for managing clients. 5 An instance of com.nimbusds.jose.jwk.source.JWKSource for signing access tokens. 6 An instance of java.security.KeyPair with keys generated on startup used to create the JWKSource above. 7 An instance of JwtDecoder(https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/jwt/JwtDecoder.html) for decoding signed access tokens. 8 An instance of AuthorizationServerSettings(configuration-model.html#configuring-authorization-server-settings) to configure Spring Authorization Server."
"https://docs.spring.io/spring-authorization-server/reference/1.3/configuration-model.html","Configuration Model: Default configuration: OAuth2AuthorizationServerConfiguration is a @Configuration that provides the minimal default configuration for an OAuth2 authorization server. OAuth2AuthorizationServerConfiguration uses OAuth2AuthorizationServerConfigurer(#customizing-the-configuration) to apply the default configuration and registers a SecurityFilterChain @Bean composed of all the infrastructure components supporting an OAuth2 authorization server. OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(HttpSecurity) is a convenience ( static ) utility method that applies the default OAuth2 security configuration to HttpSecurity . The OAuth2 authorization server SecurityFilterChain @Bean is configured with the following default protocol endpoints: OAuth2 Authorization endpoint(protocol-endpoints.html#oauth2-authorization-endpoint) OAuth2 Device Authorization Endpoint(protocol-endpoints.html#oauth2-device-authorization-endpoint) OAuth2 Device Verification Endpoint(protocol-endpoints.html#oauth2-device-verification-endpoint) OAuth2 Token endpoint(protocol-endpoints.html#oauth2-token-endpoint) OAuth2 Token Introspection endpoint(protocol-endpoints.html#oauth2-token-introspection-endpoint) OAuth2 Token Revocation endpoint(protocol-endpoints.html#oauth2-token-revocation-endpoint) OAuth2 Authorization Server Metadata endpoint(protocol-endpoints.html#oauth2-authorization-server-metadata-endpoint) JWK Set endpoint(protocol-endpoints.html#jwk-set-endpoint) The JWK Set endpoint is configured only if a JWKSource<SecurityContext> @Bean is registered. The following example shows how to use OAuth2AuthorizationServerConfiguration to apply the minimal default configuration: @Configuration @Import(OAuth2AuthorizationServerConfiguration.class) public class AuthorizationServerConfig { @Bean public RegisteredClientRepository registeredClientRepository() { List<RegisteredClient> registrations = ... return new InMemoryRegisteredClientRepository(registrations); } @Bean public JWKSource<SecurityContext> jwkSource() { RSAKey rsaKey = ... JWKSet jwkSet = new JWKSet(rsaKey); return (jwkSelector, securityContext) -> jwkSelector.select(jwkSet); } } The authorization_code grant(https://datatracker.ietf.org/doc/html/rfc6749#section-4.1) requires the resource owner to be authenticated. Therefore, a user authentication mechanism must be configured in addition to the default OAuth2 security configuration. OpenID Connect 1.0(https://openid.net/specs/openid-connect-core-1_0.html) is disabled in the default configuration. The following example shows how to enable OpenID Connect 1.0 by initializing the OidcConfigurer : @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); http.getConfigurer(OAuth2AuthorizationServerConfigurer.class) .oidc(Customizer.withDefaults()); // Initialize `OidcConfigurer` return http.build(); } In addition to the default protocol endpoints, the OAuth2 authorization server SecurityFilterChain @Bean is configured with the following OpenID Connect 1.0 protocol endpoints: OpenID Connect 1.0 Provider Configuration endpoint(protocol-endpoints.html#oidc-provider-configuration-endpoint) OpenID Connect 1.0 Logout endpoint(protocol-endpoints.html#oidc-logout-endpoint) OpenID Connect 1.0 UserInfo endpoint(protocol-endpoints.html#oidc-user-info-endpoint) The OpenID Connect 1.0 Client Registration endpoint(protocol-endpoints.html#oidc-client-registration-endpoint) is disabled by default because many deployments do not require dynamic client registration. OAuth2AuthorizationServerConfiguration.jwtDecoder(JWKSource<SecurityContext>) is a convenience ( static ) utility method that can be used to register a JwtDecoder @Bean , which is REQUIRED for the OpenID Connect 1.0 UserInfo endpoint(protocol-endpoints.html#oidc-user-info-endpoint) and the OpenID Connect 1.0 Client Registration endpoint(protocol-endpoints.html#oidc-client-registration-endpoint) . The following example shows how to register a JwtDecoder @Bean : @Bean public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) { return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource); } The main intent of OAuth2AuthorizationServerConfiguration is to provide a convenient method to apply the minimal default configuration for an OAuth2 authorization server. However, in most cases, customizing the configuration will be required. Customizing the configuration: OAuth2AuthorizationServerConfigurer provides the ability to fully customize the security configuration for an OAuth2 authorization server. It lets you specify the core components to use - for example, RegisteredClientRepository(core-model-components.html#registered-client-repository) , OAuth2AuthorizationService(core-model-components.html#oauth2-authorization-service) , OAuth2TokenGenerator(core-model-components.html#oauth2-token-generator) , and others. Furthermore, it lets you customize the request processing logic for the protocol endpoints – for example, authorization endpoint(protocol-endpoints.html#oauth2-authorization-endpoint) , device authorization endpoint(protocol-endpoints.html#oauth2-device-authorization-endpoint) , device verification endpoint(protocol-endpoints.html#oauth2-device-verification-endpoint) , token endpoint(protocol-endpoints.html#oauth2-token-endpoint) , token introspection endpoint(protocol-endpoints.html#oauth2-token-introspection-endpoint) , and others. OAuth2AuthorizationServerConfigurer provides the following configuration options: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .registeredClientRepository(registeredClientRepository) (1) .authorizationService(authorizationService) (2) .authorizationConsentService(authorizationConsentService) (3) .authorizationServerSettings(authorizationServerSettings) (4) .tokenGenerator(tokenGenerator) (5) .clientAuthentication(clientAuthentication -> { }) (6) .authorizationEndpoint(authorizationEndpoint -> { }) (7) .deviceAuthorizationEndpoint(deviceAuthorizationEndpoint -> { }) (8) .deviceVerificationEndpoint(deviceVerificationEndpoint -> { }) (9) .tokenEndpoint(tokenEndpoint -> { }) (10) .tokenIntrospectionEndpoint(tokenIntrospectionEndpoint -> { }) (11) .tokenRevocationEndpoint(tokenRevocationEndpoint -> { }) (12) .authorizationServerMetadataEndpoint(authorizationServerMetadataEndpoint -> { }) (13) .oidc(oidc -> oidc .providerConfigurationEndpoint(providerConfigurationEndpoint -> { }) (14) .logoutEndpoint(logoutEndpoint -> { }) (15) .userInfoEndpoint(userInfoEndpoint -> { }) (16) .clientRegistrationEndpoint(clientRegistrationEndpoint -> { }) (17) ); return http.build(); } 1 registeredClientRepository() : The RegisteredClientRepository(core-model-components.html#registered-client-repository) ( REQUIRED ) for managing new and existing clients. 2 authorizationService() : The OAuth2AuthorizationService(core-model-components.html#oauth2-authorization-service) for managing new and existing authorizations. 3 authorizationConsentService() : The OAuth2AuthorizationConsentService(core-model-components.html#oauth2-authorization-consent-service) for managing new and existing authorization consents. 4 authorizationServerSettings() : The AuthorizationServerSettings(#configuring-authorization-server-settings) ( REQUIRED ) for customizing configuration settings for the OAuth2 authorization server. 5 tokenGenerator() : The OAuth2TokenGenerator(core-model-components.html#oauth2-token-generator) for generating tokens supported by the OAuth2 authorization server. 6 clientAuthentication() : The configurer for OAuth2 Client Authentication(#configuring-client-authentication) . 7 authorizationEndpoint() : The configurer for the OAuth2 Authorization endpoint(protocol-endpoints.html#oauth2-authorization-endpoint) . 8 deviceAuthorizationEndpoint() : The configurer for the OAuth2 Device Authorization endpoint(protocol-endpoints.html#oauth2-device-authorization-endpoint) . 9 deviceVerificationEndpoint() : The configurer for the OAuth2 Device Verification endpoint(protocol-endpoints.html#oauth2-device-verification-endpoint) . 10 tokenEndpoint() : The configurer for the OAuth2 Token endpoint(protocol-endpoints.html#oauth2-token-endpoint) . 11 tokenIntrospectionEndpoint() : The configurer for the OAuth2 Token Introspection endpoint(protocol-endpoints.html#oauth2-token-introspection-endpoint) . 12 tokenRevocationEndpoint() : The configurer for the OAuth2 Token Revocation endpoint(protocol-endpoints.html#oauth2-token-revocation-endpoint) . 13 authorizationServerMetadataEndpoint() : The configurer for the OAuth2 Authorization Server Metadata endpoint(protocol-endpoints.html#oauth2-authorization-server-metadata-endpoint) . 14 providerConfigurationEndpoint() : The configurer for the OpenID Connect 1.0 Provider Configuration endpoint(protocol-endpoints.html#oidc-provider-configuration-endpoint) . 15 logoutEndpoint() : The configurer for the OpenID Connect 1.0 Logout endpoint(protocol-endpoints.html#oidc-logout-endpoint) . 16 userInfoEndpoint() : The configurer for the OpenID Connect 1.0 UserInfo endpoint(protocol-endpoints.html#oidc-user-info-endpoint) . 17 clientRegistrationEndpoint() : The configurer for the OpenID Connect 1.0 Client Registration endpoint(protocol-endpoints.html#oidc-client-registration-endpoint) . Configuring Authorization Server Settings: AuthorizationServerSettings contains the configuration settings for the OAuth2 authorization server. It specifies the URI for the protocol endpoints as well as the issuer identifier(https://datatracker.ietf.org/doc/html/rfc8414#section-2) . The default URI for the protocol endpoints are as follows: public final class AuthorizationServerSettings extends AbstractSettings { ... public static Builder builder() { return new Builder() .authorizationEndpoint(""/oauth2/authorize"") .deviceAuthorizationEndpoint(""/oauth2/device_authorization"") .deviceVerificationEndpoint(""/oauth2/device_verification"") .tokenEndpoint(""/oauth2/token"") .tokenIntrospectionEndpoint(""/oauth2/introspect"") .tokenRevocationEndpoint(""/oauth2/revoke"") .jwkSetEndpoint(""/oauth2/jwks"") .oidcLogoutEndpoint(""/connect/logout"") .oidcUserInfoEndpoint(""/userinfo"") .oidcClientRegistrationEndpoint(""/connect/register""); } ... } AuthorizationServerSettings is a REQUIRED component. @Import(OAuth2AuthorizationServerConfiguration.class)(#default-configuration) automatically registers an AuthorizationServerSettings @Bean , if not already provided. The following example shows how to customize the configuration settings and register an AuthorizationServerSettings @Bean : @Bean public AuthorizationServerSettings authorizationServerSettings() { return AuthorizationServerSettings.builder() .issuer(""https://example.com"") .authorizationEndpoint(""/oauth2/v1/authorize"") .deviceAuthorizationEndpoint(""/oauth2/v1/device_authorization"") .deviceVerificationEndpoint(""/oauth2/v1/device_verification"") .tokenEndpoint(""/oauth2/v1/token"") .tokenIntrospectionEndpoint(""/oauth2/v1/introspect"") .tokenRevocationEndpoint(""/oauth2/v1/revoke"") .jwkSetEndpoint(""/oauth2/v1/jwks"") .oidcLogoutEndpoint(""/connect/v1/logout"") .oidcUserInfoEndpoint(""/connect/v1/userinfo"") .oidcClientRegistrationEndpoint(""/connect/v1/register"") .build(); } The AuthorizationServerContext is a context object that holds information of the Authorization Server runtime environment. It provides access to the AuthorizationServerSettings and the “current” issuer identifier. If the issuer identifier is not configured in AuthorizationServerSettings.builder().issuer(String) , it is resolved from the current request. The AuthorizationServerContext is accessible through the AuthorizationServerContextHolder , which associates it with the current request thread by using a ThreadLocal . Configuring Client Authentication: OAuth2ClientAuthenticationConfigurer provides the ability to customize OAuth2 client authentication(https://datatracker.ietf.org/doc/html/rfc6749#section-2.3) . It defines extension points that let you customize the pre-processing, main processing, and post-processing logic for client authentication requests. OAuth2ClientAuthenticationConfigurer provides the following configuration options: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .clientAuthentication(clientAuthentication -> clientAuthentication .authenticationConverter(authenticationConverter) (1) .authenticationConverters(authenticationConvertersConsumer) (2) .authenticationProvider(authenticationProvider) (3) .authenticationProviders(authenticationProvidersConsumer) (4) .authenticationSuccessHandler(authenticationSuccessHandler) (5) .errorResponseHandler(errorResponseHandler) (6) ); return http.build(); } 1 authenticationConverter() : Adds an AuthenticationConverter ( pre-processor ) used when attempting to extract client credentials from HttpServletRequest to an instance of OAuth2ClientAuthenticationToken . 2 authenticationConverters() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationConverter 's allowing the ability to add, remove, or customize a specific AuthenticationConverter . 3 authenticationProvider() : Adds an AuthenticationProvider ( main processor ) used for authenticating the OAuth2ClientAuthenticationToken . 4 authenticationProviders() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationProvider 's allowing the ability to add, remove, or customize a specific AuthenticationProvider . 5 authenticationSuccessHandler() : The AuthenticationSuccessHandler ( post-processor ) used for handling a successful client authentication and associating the OAuth2ClientAuthenticationToken to the SecurityContext . 6 errorResponseHandler() : The AuthenticationFailureHandler ( post-processor ) used for handling a failed client authentication and returning the OAuth2Error response(https://datatracker.ietf.org/doc/html/rfc6749#section-5.2) . OAuth2ClientAuthenticationConfigurer configures the OAuth2ClientAuthenticationFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . OAuth2ClientAuthenticationFilter is the Filter that processes client authentication requests. By default, client authentication is required for the OAuth2 Token endpoint(protocol-endpoints.html#oauth2-token-endpoint) , the OAuth2 Token Introspection endpoint(protocol-endpoints.html#oauth2-token-introspection-endpoint) , and the OAuth2 Token Revocation endpoint(protocol-endpoints.html#oauth2-token-revocation-endpoint) . The supported client authentication methods are client_secret_basic , client_secret_post , private_key_jwt , client_secret_jwt , tls_client_auth , self_signed_tls_client_auth , and none (public clients). OAuth2ClientAuthenticationFilter is configured with the following defaults: AuthenticationConverter — A DelegatingAuthenticationConverter composed of JwtClientAssertionAuthenticationConverter , X509ClientCertificateAuthenticationConverter , ClientSecretBasicAuthenticationConverter , ClientSecretPostAuthenticationConverter , and PublicClientAuthenticationConverter . AuthenticationManager — An AuthenticationManager composed of JwtClientAssertionAuthenticationProvider , X509ClientCertificateAuthenticationProvider , ClientSecretAuthenticationProvider , and PublicClientAuthenticationProvider . AuthenticationSuccessHandler — An internal implementation that associates the “authenticated” OAuth2ClientAuthenticationToken (current Authentication ) to the SecurityContext . AuthenticationFailureHandler — An internal implementation that uses the OAuth2Error associated with the OAuth2AuthenticationException to return the OAuth2 error response. Customizing Jwt Client Assertion Validation: JwtClientAssertionDecoderFactory.DEFAULT_JWT_VALIDATOR_FACTORY is the default factory that provides an OAuth2TokenValidator<Jwt> for the specified RegisteredClient and is used for validating the iss , sub , aud , exp and nbf claims of the Jwt client assertion. JwtClientAssertionDecoderFactory provides the ability to override the default Jwt client assertion validation by supplying a custom factory of type Function<RegisteredClient, OAuth2TokenValidator<Jwt>> to setJwtValidatorFactory() . JwtClientAssertionDecoderFactory is the default JwtDecoderFactory used by JwtClientAssertionAuthenticationProvider that provides a JwtDecoder for the specified RegisteredClient and is used for authenticating a Jwt Bearer Token during OAuth2 client authentication. A common use case for customizing JwtClientAssertionDecoderFactory is to validate additional claims in the Jwt client assertion. The following example shows how to configure JwtClientAssertionAuthenticationProvider with a customized JwtClientAssertionDecoderFactory that validates an additional claim in the Jwt client assertion: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .clientAuthentication(clientAuthentication -> clientAuthentication .authenticationProviders(configureJwtClientAssertionValidator()) ); return http.build(); } private Consumer<List<AuthenticationProvider>> configureJwtClientAssertionValidator() { return (authenticationProviders) -> authenticationProviders.forEach((authenticationProvider) -> { if (authenticationProvider instanceof JwtClientAssertionAuthenticationProvider) { // Customize JwtClientAssertionDecoderFactory JwtClientAssertionDecoderFactory jwtDecoderFactory = new JwtClientAssertionDecoderFactory(); Function<RegisteredClient, OAuth2TokenValidator<Jwt>> jwtValidatorFactory = (registeredClient) -> new DelegatingOAuth2TokenValidator<>( // Use default validators JwtClientAssertionDecoderFactory.DEFAULT_JWT_VALIDATOR_FACTORY.apply(registeredClient), // Add custom validator new JwtClaimValidator<>(""claim"", ""value""::equals)); jwtDecoderFactory.setJwtValidatorFactory(jwtValidatorFactory); ((JwtClientAssertionAuthenticationProvider) authenticationProvider) .setJwtDecoderFactory(jwtDecoderFactory); } }); } Customizing Mutual-TLS Client Authentication: X509ClientCertificateAuthenticationProvider is used for authenticating the client X509Certificate chain received when ClientAuthenticationMethod.TLS_CLIENT_AUTH or ClientAuthenticationMethod.SELF_SIGNED_TLS_CLIENT_AUTH method is used during OAuth2 client authentication. It is also composed with a ""Certificate Verifier"" , which is used to verify the contents of the client X509Certificate after the TLS handshake has successfully completed. PKI Mutual-TLS Method: For the PKI Mutual-TLS ( ClientAuthenticationMethod.TLS_CLIENT_AUTH ) method, the default implementation of the certificate verifier verifies the subject distinguished name of the client X509Certificate against the setting RegisteredClient.getClientSettings.getX509CertificateSubjectDN() . If you need to verify another attribute of the client X509Certificate , for example, a Subject Alternative Name (SAN) entry, the following example shows how to configure X509ClientCertificateAuthenticationProvider with a custom implementation of a certificate verifier: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .clientAuthentication(clientAuthentication -> clientAuthentication .authenticationProviders(configureX509ClientCertificateVerifier()) ); return http.build(); } private Consumer<List<AuthenticationProvider>> configureX509ClientCertificateVerifier() { return (authenticationProviders) -> authenticationProviders.forEach((authenticationProvider) -> { if (authenticationProvider instanceof X509ClientCertificateAuthenticationProvider) { Consumer<OAuth2ClientAuthenticationContext> certificateVerifier = (clientAuthenticationContext) -> { OAuth2ClientAuthenticationToken clientAuthentication = clientAuthenticationContext.getAuthentication(); RegisteredClient registeredClient = clientAuthenticationContext.getRegisteredClient(); X509Certificate[] clientCertificateChain = (X509Certificate[]) clientAuthentication.getCredentials(); X509Certificate clientCertificate = clientCertificateChain[0]; // TODO Verify Subject Alternative Name (SAN) entry }; ((X509ClientCertificateAuthenticationProvider) authenticationProvider) .setCertificateVerifier(certificateVerifier); } }); } Self-Signed Certificate Mutual-TLS Method: For the Self-Signed Certificate Mutual-TLS ( ClientAuthenticationMethod.SELF_SIGNED_TLS_CLIENT_AUTH ) method, the default implementation of the certificate verifier will retrieve the client’s JSON Web Key Set using the setting RegisteredClient.getClientSettings.getJwkSetUrl() and expect to find a match against the client X509Certificate received during the TLS handshake. The RegisteredClient.getClientSettings.getJwkSetUrl() setting is used to retrieve the client’s certificates via a JSON Web Key (JWK) Set. A certificate is represented with the x5c parameter of an individual JWK within the set. Client Certificate-Bound Access Tokens: When Mutual-TLS client authentication is used at the token endpoint, the authorization server is able to bind the issued access token to the client’s X509Certificate . The binding is accomplished by computing the SHA-256 thumbprint of the client’s X509Certificate and associating the thumbprint with the access token. For example, a JWT access token would include a x5t#S256 claim, containing the X509Certificate thumbprint, within the top-level cnf (confirmation method) claim. Binding the access token to the client’s X509Certificate provides the ability to implement a proof-of-possession mechanism during protected resource access. For example, the protected resource would obtain the client’s X509Certificate used during Mutual-TLS authentication and then verify that the certificate thumbprint matches the x5t#S256 claim associated with the access token. The following example shows how to enable certificate-bound access tokens for a client: RegisteredClient mtlsClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(""mtls-client"") .clientAuthenticationMethod(ClientAuthenticationMethod.TLS_CLIENT_AUTH) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) .scope(""scope-a"") .clientSettings( ClientSettings.builder() .x509CertificateSubjectDN(""CN=mtls-client,OU=Spring Samples,O=Spring,C=US"") .build() ) .tokenSettings( TokenSettings.builder() .x509CertificateBoundAccessTokens(true) .build() ) .build();"
"https://docs.spring.io/spring-authorization-server/reference/1.3/core-model-components.html","Core Model / Components: RegisteredClient: A RegisteredClient is a representation of a client that is registered(https://datatracker.ietf.org/doc/html/rfc6749#section-2) with the authorization server. A client must be registered with the authorization server before it can initiate an authorization grant flow, such as authorization_code or client_credentials . During client registration, the client is assigned a unique client identifier(https://datatracker.ietf.org/doc/html/rfc6749#section-2.2) , (optionally) a client secret (depending on client type(https://datatracker.ietf.org/doc/html/rfc6749#section-2.1) ), and metadata associated with its unique client identifier. The client’s metadata can range from human-facing display strings (such as client name) to items specific to a protocol flow (such as the list of valid redirect URIs). The corresponding client registration model in Spring Security’s OAuth2 Client support is ClientRegistration(https://docs.spring.io/spring-security/reference/servlet/oauth2/client/core.html#oauth2Client-client-registration) . The primary purpose of a client is to request access to protected resources. The client first requests an access token by authenticating with the authorization server and presenting the authorization grant. The authorization server authenticates the client and authorization grant, and, if they are valid, issues an access token. The client can now request the protected resource from the resource server by presenting the access token. The following example shows how to configure a RegisteredClient that is allowed to perform the authorization_code grant(https://datatracker.ietf.org/doc/html/rfc6749#section-4.1) flow to request an access token: RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(""client-a"") .clientSecret(""{noop}secret"") (1) .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .redirectUri(""http://127.0.0.1:8080/authorized"") .scope(""scope-a"") .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build()) .build(); 1 {noop} represents the PasswordEncoder id for Spring Security’s NoOpPasswordEncoder(https://docs.spring.io/spring-security/reference/features/authentication/password-storage.html#authentication-password-storage-dpe) . The corresponding configuration in Spring Security’s OAuth2 Client support(https://docs.spring.io/spring-security/reference/servlet/oauth2/client/index.html) is: spring: security: oauth2: client: registration: client-a: provider: spring client-id: client-a client-secret: secret authorization-grant-type: authorization_code redirect-uri: ""http://127.0.0.1:8080/authorized"" scope: scope-a provider: spring: issuer-uri: http://localhost:9000 A RegisteredClient has metadata (attributes) associated with its unique Client Identifier and is defined as follows: public class RegisteredClient implements Serializable { private String id; (1) private String clientId; (2) private Instant clientIdIssuedAt; (3) private String clientSecret; (4) private Instant clientSecretExpiresAt; (5) private String clientName; (6) private Set<ClientAuthenticationMethod> clientAuthenticationMethods; (7) private Set<AuthorizationGrantType> authorizationGrantTypes; (8) private Set<String> redirectUris; (9) private Set<String> postLogoutRedirectUris; (10) private Set<String> scopes; (11) private ClientSettings clientSettings; (12) private TokenSettings tokenSettings; (13) ... } 1 id : The ID that uniquely identifies the RegisteredClient . 2 clientId : The client identifier. 3 clientIdIssuedAt : The time at which the client identifier was issued. 4 clientSecret : The client’s secret. The value should be encoded using Spring Security’s PasswordEncoder(https://docs.spring.io/spring-security/reference/features/authentication/password-storage.html#authentication-password-storage-dpe) . 5 clientSecretExpiresAt : The time at which the client secret expires. 6 clientName : A descriptive name used for the client. The name may be used in certain scenarios, such as when displaying the client name in the consent page. 7 clientAuthenticationMethods : The authentication method(s) that the client may use. The supported values are client_secret_basic , client_secret_post , private_key_jwt(https://datatracker.ietf.org/doc/html/rfc7523) , client_secret_jwt , and none (public clients)(https://datatracker.ietf.org/doc/html/rfc7636) . 8 authorizationGrantTypes : The authorization grant type(s)(https://datatracker.ietf.org/doc/html/rfc6749#section-1.3) that the client can use. The supported values are authorization_code , client_credentials , refresh_token , urn:ietf:params:oauth:grant-type:device_code , and urn:ietf:params:oauth:grant-type:token-exchange . 9 redirectUris : The registered redirect URI(s)(https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2) that the client may use in redirect-based flows – for example, authorization_code grant. 10 postLogoutRedirectUris : The post logout redirect URI(s) that the client may use for logout. 11 scopes : The scope(s) that the client is allowed to request. 12 clientSettings : The custom settings for the client – for example, require PKCE(https://datatracker.ietf.org/doc/html/rfc7636) , require authorization consent, and others. 13 tokenSettings : The custom settings for the OAuth2 tokens issued to the client – for example, access/refresh token time-to-live, reuse refresh tokens, and others. RegisteredClientRepository: The RegisteredClientRepository is the central component where new clients can be registered and existing clients can be queried. It is used by other components when following a specific protocol flow, such as client authentication, authorization grant processing, token introspection, dynamic client registration, and others. The provided implementations of RegisteredClientRepository are InMemoryRegisteredClientRepository and JdbcRegisteredClientRepository . The InMemoryRegisteredClientRepository implementation stores RegisteredClient instances in-memory and is recommended ONLY to be used during development and testing. JdbcRegisteredClientRepository is a JDBC implementation that persists RegisteredClient instances by using JdbcOperations . The RegisteredClientRepository is a REQUIRED component. The following example shows how to register a RegisteredClientRepository @Bean : @Bean public RegisteredClientRepository registeredClientRepository() { List<RegisteredClient> registrations = ... return new InMemoryRegisteredClientRepository(registrations); } Alternatively, you can configure the RegisteredClientRepository through the OAuth2AuthorizationServerConfigurer(configuration-model.html#customizing-the-configuration) : @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .registeredClientRepository(registeredClientRepository); ... return http.build(); } The OAuth2AuthorizationServerConfigurer is useful when applying multiple configuration options simultaneously. OAuth2Authorization: An OAuth2Authorization is a representation of an OAuth2 authorization, which holds state related to the authorization granted to a client(#registered-client) , by the resource owner or itself in the case of the client_credentials authorization grant type. The corresponding authorization model in Spring Security’s OAuth2 Client support is OAuth2AuthorizedClient(https://docs.spring.io/spring-security/reference/servlet/oauth2/client/core.html#oauth2Client-authorized-client) . After the successful completion of an authorization grant flow, an OAuth2Authorization is created and associates an OAuth2AccessToken(https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/core/OAuth2AccessToken.html) , an (optional) OAuth2RefreshToken(https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/core/OAuth2RefreshToken.html) , and additional state specific to the executed authorization grant type. The OAuth2Token(https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/core/OAuth2Token.html) instances associated with an OAuth2Authorization vary, depending on the authorization grant type. For the OAuth2 authorization_code grant(https://datatracker.ietf.org/doc/html/rfc6749#section-4.1) , an OAuth2AuthorizationCode , an OAuth2AccessToken , and an (optional) OAuth2RefreshToken are associated. For the OpenID Connect 1.0 authorization_code grant(https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth) , an OAuth2AuthorizationCode , an OidcIdToken(https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/core/oidc/OidcIdToken.html) , an OAuth2AccessToken , and an (optional) OAuth2RefreshToken are associated. For the OAuth2 client_credentials grant(https://datatracker.ietf.org/doc/html/rfc6749#section-4.4) , only an OAuth2AccessToken is associated. OAuth2Authorization and its attributes are defined as follows: public class OAuth2Authorization implements Serializable { private String id; (1) private String registeredClientId; (2) private String principalName; (3) private AuthorizationGrantType authorizationGrantType; (4) private Set<String> authorizedScopes; (5) private Map<Class<? extends OAuth2Token>, Token<?>> tokens; (6) private Map<String, Object> attributes; (7) ... } 1 id : The ID that uniquely identifies the OAuth2Authorization . 2 registeredClientId : The ID that uniquely identifies the RegisteredClient(#registered-client) . 3 principalName : The principal name of the resource owner (or client). 4 authorizationGrantType : The AuthorizationGrantType used. 5 authorizedScopes : The Set of scope(s) authorized for the client. 6 tokens : The OAuth2Token instances (and associated metadata) specific to the executed authorization grant type. 7 attributes : The additional attributes specific to the executed authorization grant type – for example, the authenticated Principal , OAuth2AuthorizationRequest , and others. OAuth2Authorization and its associated OAuth2Token instances have a set lifespan. A newly issued OAuth2Token is active and becomes inactive when it either expires or is invalidated (revoked). The OAuth2Authorization is (implicitly) inactive when all associated OAuth2Token instances are inactive. Each OAuth2Token is held in an OAuth2Authorization.Token , which provides accessors for isExpired() , isInvalidated() , and isActive() . OAuth2Authorization.Token also provides getClaims() , which returns the claims (if any) associated with the OAuth2Token . OAuth2AuthorizationService: The OAuth2AuthorizationService is the central component where new authorizations are stored and existing authorizations are queried. It is used by other components when following a specific protocol flow – for example, client authentication, authorization grant processing, token introspection, token revocation, dynamic client registration, and others. The provided implementations of OAuth2AuthorizationService are InMemoryOAuth2AuthorizationService and JdbcOAuth2AuthorizationService . The InMemoryOAuth2AuthorizationService implementation stores OAuth2Authorization instances in-memory and is recommended ONLY to be used during development and testing. JdbcOAuth2AuthorizationService is a JDBC implementation that persists OAuth2Authorization instances by using JdbcOperations . The OAuth2AuthorizationService is an OPTIONAL component and defaults to InMemoryOAuth2AuthorizationService . The following example shows how to register an OAuth2AuthorizationService @Bean : @Bean public OAuth2AuthorizationService authorizationService() { return new InMemoryOAuth2AuthorizationService(); } Alternatively, you can configure the OAuth2AuthorizationService through the OAuth2AuthorizationServerConfigurer(configuration-model.html#customizing-the-configuration) : @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .authorizationService(authorizationService); ... return http.build(); } The OAuth2AuthorizationServerConfigurer is useful when applying multiple configuration options simultaneously. OAuth2AuthorizationConsent: An OAuth2AuthorizationConsent is a representation of an authorization ""consent"" (decision) from an OAuth2 authorization request flow(https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1) – for example, the authorization_code grant, which holds the authorities granted to a client(#registered-client) by the resource owner. When authorizing access to a client, the resource owner may grant only a subset of the authorities requested by the client. The typical use case is the authorization_code grant flow, in which the client requests scope(s) and the resource owner grants (or denies) access to the requested scope(s). After the completion of an OAuth2 authorization request flow, an OAuth2AuthorizationConsent is created (or updated) and associates the granted authorities with the client and resource owner. OAuth2AuthorizationConsent and its attributes are defined as follows: public final class OAuth2AuthorizationConsent implements Serializable { private final String registeredClientId; (1) private final String principalName; (2) private final Set<GrantedAuthority> authorities; (3) ... } 1 registeredClientId : The ID that uniquely identifies the RegisteredClient(#registered-client) . 2 principalName : The principal name of the resource owner. 3 authorities : The authorities granted to the client by the resource owner. An authority can represent a scope, a claim, a permission, a role, and others. OAuth2AuthorizationConsentService: The OAuth2AuthorizationConsentService is the central component where new authorization consents are stored and existing authorization consents are queried. It is primarily used by components that implement an OAuth2 authorization request flow – for example, the authorization_code grant. The provided implementations of OAuth2AuthorizationConsentService are InMemoryOAuth2AuthorizationConsentService and JdbcOAuth2AuthorizationConsentService . The InMemoryOAuth2AuthorizationConsentService implementation stores OAuth2AuthorizationConsent instances in-memory and is recommended ONLY for development and testing. JdbcOAuth2AuthorizationConsentService is a JDBC implementation that persists OAuth2AuthorizationConsent instances by using JdbcOperations . The OAuth2AuthorizationConsentService is an OPTIONAL component and defaults to InMemoryOAuth2AuthorizationConsentService . The following example shows how to register an OAuth2AuthorizationConsentService @Bean : @Bean public OAuth2AuthorizationConsentService authorizationConsentService() { return new InMemoryOAuth2AuthorizationConsentService(); } Alternatively, you can configure the OAuth2AuthorizationConsentService through the OAuth2AuthorizationServerConfigurer(configuration-model.html#customizing-the-configuration) : @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .authorizationConsentService(authorizationConsentService); ... return http.build(); } The OAuth2AuthorizationServerConfigurer is useful when applying multiple configuration options simultaneously. OAuth2TokenContext: An OAuth2TokenContext is a context object that holds information associated with an OAuth2Token and is used by an OAuth2TokenGenerator(#oauth2-token-generator) and OAuth2TokenCustomizer(#oauth2-token-customizer) . OAuth2TokenContext provides the following accessors: public interface OAuth2TokenContext extends Context { default RegisteredClient getRegisteredClient() ... (1) default <T extends Authentication> T getPrincipal() ... (2) default AuthorizationServerContext getAuthorizationServerContext() ... (3) @Nullable default OAuth2Authorization getAuthorization() ... (4) default Set<String> getAuthorizedScopes() ... (5) default OAuth2TokenType getTokenType() ... (6) default AuthorizationGrantType getAuthorizationGrantType() ... (7) default <T extends Authentication> T getAuthorizationGrant() ... (8) ... } 1 getRegisteredClient() : The RegisteredClient(#registered-client) associated with the authorization grant. 2 getPrincipal() : The Authentication instance of the resource owner (or client). 3 getAuthorizationServerContext() : The AuthorizationServerContext(configuration-model.html#configuring-authorization-server-settings) object that holds information of the Authorization Server runtime environment. 4 getAuthorization() : The OAuth2Authorization(#oauth2-authorization) associated with the authorization grant. 5 getAuthorizedScopes() : The scope(s) authorized for the client. 6 getTokenType() : The OAuth2TokenType to generate. The supported values are code , access_token , refresh_token , and id_token . 7 getAuthorizationGrantType() : The AuthorizationGrantType associated with the authorization grant. 8 getAuthorizationGrant() : The Authentication instance used by the AuthenticationProvider that processes the authorization grant. OAuth2TokenGenerator: An OAuth2TokenGenerator is responsible for generating an OAuth2Token from the information contained in the provided OAuth2TokenContext(#oauth2-token-context) . The OAuth2Token generated primarily depends on the type of OAuth2TokenType specified in the OAuth2TokenContext . For example, when the value for OAuth2TokenType is: code , then OAuth2AuthorizationCode is generated. access_token , then OAuth2AccessToken is generated. refresh_token , then OAuth2RefreshToken is generated. id_token , then OidcIdToken is generated. Furthermore, the format of the generated OAuth2AccessToken varies, depending on the TokenSettings.getAccessTokenFormat() configured for the RegisteredClient(#registered-client) . If the format is OAuth2TokenFormat.SELF_CONTAINED (the default), then a Jwt is generated. If the format is OAuth2TokenFormat.REFERENCE , then an ""opaque"" token is generated. Finally, if the generated OAuth2Token has a set of claims and implements ClaimAccessor , the claims are made accessible from OAuth2Authorization.Token.getClaims()(#oauth2-authorization) . The OAuth2TokenGenerator is primarily used by components that implement authorization grant processing – for example, authorization_code , client_credentials , and refresh_token . The provided implementations are OAuth2AccessTokenGenerator , OAuth2RefreshTokenGenerator , and JwtGenerator . The OAuth2AccessTokenGenerator generates an ""opaque"" ( OAuth2TokenFormat.REFERENCE ) access token, and the JwtGenerator generates a Jwt ( OAuth2TokenFormat.SELF_CONTAINED ). The OAuth2TokenGenerator is an OPTIONAL component and defaults to a DelegatingOAuth2TokenGenerator composed of an OAuth2AccessTokenGenerator and OAuth2RefreshTokenGenerator . If a JwtEncoder @Bean or JWKSource<SecurityContext> @Bean is registered, then a JwtGenerator is additionally composed in the DelegatingOAuth2TokenGenerator . The OAuth2TokenGenerator provides great flexibility, as it can support any custom token format for access_token and refresh_token . The following example shows how to register an OAuth2TokenGenerator @Bean : @Bean public OAuth2TokenGenerator<?> tokenGenerator() { JwtEncoder jwtEncoder = ... JwtGenerator jwtGenerator = new JwtGenerator(jwtEncoder); OAuth2AccessTokenGenerator accessTokenGenerator = new OAuth2AccessTokenGenerator(); OAuth2RefreshTokenGenerator refreshTokenGenerator = new OAuth2RefreshTokenGenerator(); return new DelegatingOAuth2TokenGenerator( jwtGenerator, accessTokenGenerator, refreshTokenGenerator); } Alternatively, you can configure the OAuth2TokenGenerator through the OAuth2AuthorizationServerConfigurer(configuration-model.html#customizing-the-configuration) : @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .tokenGenerator(tokenGenerator); ... return http.build(); } The OAuth2AuthorizationServerConfigurer is useful when applying multiple configuration options simultaneously. OAuth2TokenCustomizer: An OAuth2TokenCustomizer provides the ability to customize the attributes of an OAuth2Token , which are accessible in the provided OAuth2TokenContext(#oauth2-token-context) . It is used by an OAuth2TokenGenerator(#oauth2-token-generator) to let it customize the attributes of the OAuth2Token before it is generated. An OAuth2TokenCustomizer<OAuth2TokenClaimsContext> declared with a generic type of OAuth2TokenClaimsContext ( implements OAuth2TokenContext ) provides the ability to customize the claims of an ""opaque"" OAuth2AccessToken . OAuth2TokenClaimsContext.getClaims() provides access to the OAuth2TokenClaimsSet.Builder , allowing the ability to add, replace, and remove claims. The following example shows how to implement an OAuth2TokenCustomizer<OAuth2TokenClaimsContext> and configure it with an OAuth2AccessTokenGenerator : @Bean public OAuth2TokenGenerator<?> tokenGenerator() { JwtEncoder jwtEncoder = ... JwtGenerator jwtGenerator = new JwtGenerator(jwtEncoder); OAuth2AccessTokenGenerator accessTokenGenerator = new OAuth2AccessTokenGenerator(); accessTokenGenerator.setAccessTokenCustomizer(accessTokenCustomizer()); OAuth2RefreshTokenGenerator refreshTokenGenerator = new OAuth2RefreshTokenGenerator(); return new DelegatingOAuth2TokenGenerator( jwtGenerator, accessTokenGenerator, refreshTokenGenerator); } @Bean public OAuth2TokenCustomizer<OAuth2TokenClaimsContext> accessTokenCustomizer() { return context -> { OAuth2TokenClaimsSet.Builder claims = context.getClaims(); // Customize claims }; } If the OAuth2TokenGenerator is not provided as a @Bean or is not configured through the OAuth2AuthorizationServerConfigurer , an OAuth2TokenCustomizer<OAuth2TokenClaimsContext> @Bean will automatically be configured with an OAuth2AccessTokenGenerator . An OAuth2TokenCustomizer<JwtEncodingContext> declared with a generic type of JwtEncodingContext ( implements OAuth2TokenContext ) provides the ability to customize the headers and claims of a Jwt . JwtEncodingContext.getJwsHeader() provides access to the JwsHeader.Builder , allowing the ability to add, replace, and remove headers. JwtEncodingContext.getClaims() provides access to the JwtClaimsSet.Builder , allowing the ability to add, replace, and remove claims. The following example shows how to implement an OAuth2TokenCustomizer<JwtEncodingContext> and configure it with a JwtGenerator : @Bean public OAuth2TokenGenerator<?> tokenGenerator() { JwtEncoder jwtEncoder = ... JwtGenerator jwtGenerator = new JwtGenerator(jwtEncoder); jwtGenerator.setJwtCustomizer(jwtCustomizer()); OAuth2AccessTokenGenerator accessTokenGenerator = new OAuth2AccessTokenGenerator(); OAuth2RefreshTokenGenerator refreshTokenGenerator = new OAuth2RefreshTokenGenerator(); return new DelegatingOAuth2TokenGenerator( jwtGenerator, accessTokenGenerator, refreshTokenGenerator); } @Bean public OAuth2TokenCustomizer<JwtEncodingContext> jwtCustomizer() { return context -> { JwsHeader.Builder headers = context.getJwsHeader(); JwtClaimsSet.Builder claims = context.getClaims(); if (context.getTokenType().equals(OAuth2TokenType.ACCESS_TOKEN)) { // Customize headers/claims for access_token } else if (context.getTokenType().getValue().equals(OidcParameterNames.ID_TOKEN)) { // Customize headers/claims for id_token } }; } If the OAuth2TokenGenerator is not provided as a @Bean or is not configured through the OAuth2AuthorizationServerConfigurer , an OAuth2TokenCustomizer<JwtEncodingContext> @Bean will automatically be configured with a JwtGenerator . For an example showing how you can customize the ID token(guides/how-to-userinfo.html#customize-id-token) , see the guide How-to: Customize the OpenID Connect 1.0 UserInfo response(guides/how-to-userinfo.html) . SessionRegistry: If OpenID Connect 1.0 is enabled, a SessionRegistry instance is used to track authenticated sessions. The SessionRegistry is used by the default implementation of SessionAuthenticationStrategy associated to the OAuth2 Authorization Endpoint(protocol-endpoints.html#oauth2-authorization-endpoint) for registering new authenticated sessions. If a SessionRegistry @Bean is not registered, the default implementation SessionRegistryImpl will be used. If a SessionRegistry @Bean is registered and is an instance of SessionRegistryImpl , a HttpSessionEventPublisher @Bean SHOULD also be registered as it’s responsible for notifying SessionRegistryImpl of session lifecycle events, for example, SessionDestroyedEvent , to provide the ability to remove the SessionInformation instance. When a logout is requested by an End-User, the OpenID Connect 1.0 Logout Endpoint(protocol-endpoints.html#oidc-logout-endpoint) uses the SessionRegistry to lookup the SessionInformation associated to the authenticated End-User to perform the logout. If Spring Security’s Concurrent Session Control(https://docs.spring.io/spring-security/reference/servlet/authentication/session-management.html#ns-concurrent-sessions) feature is being used, it is RECOMMENDED to register a SessionRegistry @Bean to ensure it’s shared between Spring Security’s Concurrent Session Control and Spring Authorization Server’s Logout feature. The following example shows how to register a SessionRegistry @Bean and HttpSessionEventPublisher @Bean (required by SessionRegistryImpl ): @Bean public SessionRegistry sessionRegistry() { return new SessionRegistryImpl(); } @Bean public HttpSessionEventPublisher httpSessionEventPublisher() { return new HttpSessionEventPublisher(); }"
"https://docs.spring.io/spring-authorization-server/reference/1.3/protocol-endpoints.html","Protocol Endpoints: OAuth2 Authorization Endpoint: OAuth2AuthorizationEndpointConfigurer provides the ability to customize the OAuth2 Authorization endpoint(https://datatracker.ietf.org/doc/html/rfc6749#section-3.1) . It defines extension points that let you customize the pre-processing, main processing, and post-processing logic for OAuth2 authorization requests(https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1) . OAuth2AuthorizationEndpointConfigurer provides the following configuration options: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .authorizationEndpoint(authorizationEndpoint -> authorizationEndpoint .authorizationRequestConverter(authorizationRequestConverter) (1) .authorizationRequestConverters(authorizationRequestConvertersConsumer) (2) .authenticationProvider(authenticationProvider) (3) .authenticationProviders(authenticationProvidersConsumer) (4) .authorizationResponseHandler(authorizationResponseHandler) (5) .errorResponseHandler(errorResponseHandler) (6) .consentPage(""/oauth2/v1/authorize"") (7) ); return http.build(); } 1 authorizationRequestConverter() : Adds an AuthenticationConverter ( pre-processor ) used when attempting to extract an OAuth2 authorization request(https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1) (or consent) from HttpServletRequest to an instance of OAuth2AuthorizationCodeRequestAuthenticationToken or OAuth2AuthorizationConsentAuthenticationToken . 2 authorizationRequestConverters() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationConverter 's allowing the ability to add, remove, or customize a specific AuthenticationConverter . 3 authenticationProvider() : Adds an AuthenticationProvider ( main processor ) used for authenticating the OAuth2AuthorizationCodeRequestAuthenticationToken or OAuth2AuthorizationConsentAuthenticationToken . 4 authenticationProviders() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationProvider 's allowing the ability to add, remove, or customize a specific AuthenticationProvider . 5 authorizationResponseHandler() : The AuthenticationSuccessHandler ( post-processor ) used for handling an “authenticated” OAuth2AuthorizationCodeRequestAuthenticationToken and returning the OAuth2AuthorizationResponse(https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2) . 6 errorResponseHandler() : The AuthenticationFailureHandler ( post-processor ) used for handling an OAuth2AuthorizationCodeRequestAuthenticationException and returning the OAuth2Error response(https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2.1) . 7 consentPage() : The URI of the custom consent page to redirect resource owners to if consent is required during the authorization request flow. OAuth2AuthorizationEndpointConfigurer configures the OAuth2AuthorizationEndpointFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . OAuth2AuthorizationEndpointFilter is the Filter that processes OAuth2 authorization requests (and consents). OAuth2AuthorizationEndpointFilter is configured with the following defaults: AuthenticationConverter — A DelegatingAuthenticationConverter composed of OAuth2AuthorizationCodeRequestAuthenticationConverter and OAuth2AuthorizationConsentAuthenticationConverter . AuthenticationManager — An AuthenticationManager composed of OAuth2AuthorizationCodeRequestAuthenticationProvider and OAuth2AuthorizationConsentAuthenticationProvider . AuthenticationSuccessHandler — An internal implementation that handles an “authenticated” OAuth2AuthorizationCodeRequestAuthenticationToken and returns the OAuth2AuthorizationResponse . AuthenticationFailureHandler — An internal implementation that uses the OAuth2Error associated with the OAuth2AuthorizationCodeRequestAuthenticationException and returns the OAuth2Error response. Customizing Authorization Request Validation: OAuth2AuthorizationCodeRequestAuthenticationValidator is the default validator used for validating specific OAuth2 authorization request parameters used in the Authorization Code Grant. The default implementation validates the redirect_uri and scope parameters. If validation fails, an OAuth2AuthorizationCodeRequestAuthenticationException is thrown. OAuth2AuthorizationCodeRequestAuthenticationProvider provides the ability to override the default authorization request validation by supplying a custom authentication validator of type Consumer<OAuth2AuthorizationCodeRequestAuthenticationContext> to setAuthenticationValidator() . OAuth2AuthorizationCodeRequestAuthenticationContext holds the OAuth2AuthorizationCodeRequestAuthenticationToken , which contains the OAuth2 authorization request parameters. If validation fails, the authentication validator MUST throw OAuth2AuthorizationCodeRequestAuthenticationException . A common use case during the development life cycle phase is to allow for localhost in the redirect_uri parameter. The following example shows how to configure OAuth2AuthorizationCodeRequestAuthenticationProvider with a custom authentication validator that allows for localhost in the redirect_uri parameter: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .authorizationEndpoint(authorizationEndpoint -> authorizationEndpoint .authenticationProviders(configureAuthenticationValidator()) ); return http.build(); } private Consumer<List<AuthenticationProvider>> configureAuthenticationValidator() { return (authenticationProviders) -> authenticationProviders.forEach((authenticationProvider) -> { if (authenticationProvider instanceof OAuth2AuthorizationCodeRequestAuthenticationProvider) { Consumer<OAuth2AuthorizationCodeRequestAuthenticationContext> authenticationValidator = // Override default redirect_uri validator new CustomRedirectUriValidator() // Reuse default scope validator .andThen(OAuth2AuthorizationCodeRequestAuthenticationValidator.DEFAULT_SCOPE_VALIDATOR); ((OAuth2AuthorizationCodeRequestAuthenticationProvider) authenticationProvider) .setAuthenticationValidator(authenticationValidator); } }); } static class CustomRedirectUriValidator implements Consumer<OAuth2AuthorizationCodeRequestAuthenticationContext> { @Override public void accept(OAuth2AuthorizationCodeRequestAuthenticationContext authenticationContext) { OAuth2AuthorizationCodeRequestAuthenticationToken authorizationCodeRequestAuthentication = authenticationContext.getAuthentication(); RegisteredClient registeredClient = authenticationContext.getRegisteredClient(); String requestedRedirectUri = authorizationCodeRequestAuthentication.getRedirectUri(); // Use exact string matching when comparing client redirect URIs against pre-registered URIs if (!registeredClient.getRedirectUris().contains(requestedRedirectUri)) { OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.INVALID_REQUEST); throw new OAuth2AuthorizationCodeRequestAuthenticationException(error, null); } } } OAuth2 Device Authorization Endpoint: OAuth2DeviceAuthorizationEndpointConfigurer provides the ability to customize the OAuth2 Device Authorization endpoint(https://datatracker.ietf.org/doc/html/rfc8628#section-3.1) . It defines extension points that let you customize the pre-processing, main processing, and post-processing logic for OAuth2 device authorization requests. OAuth2DeviceAuthorizationEndpointConfigurer provides the following configuration options: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .deviceAuthorizationEndpoint(deviceAuthorizationEndpoint -> deviceAuthorizationEndpoint .deviceAuthorizationRequestConverter(deviceAuthorizationRequestConverter) (1) .deviceAuthorizationRequestConverters(deviceAuthorizationRequestConvertersConsumer) (2) .authenticationProvider(authenticationProvider) (3) .authenticationProviders(authenticationProvidersConsumer) (4) .deviceAuthorizationResponseHandler(deviceAuthorizationResponseHandler) (5) .errorResponseHandler(errorResponseHandler) (6) .verificationUri(""/oauth2/v1/device_verification"") (7) ); return http.build(); } 1 deviceAuthorizationRequestConverter() : Adds an AuthenticationConverter ( pre-processor ) used when attempting to extract an OAuth2 device authorization request(https://datatracker.ietf.org/doc/html/rfc8628#section-3.1) from HttpServletRequest to an instance of OAuth2DeviceAuthorizationRequestAuthenticationToken . 2 deviceAuthorizationRequestConverters() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationConverter 's allowing the ability to add, remove, or customize a specific AuthenticationConverter . 3 authenticationProvider() : Adds an AuthenticationProvider ( main processor ) used for authenticating the OAuth2DeviceAuthorizationRequestAuthenticationToken . 4 authenticationProviders() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationProvider 's allowing the ability to add, remove, or customize a specific AuthenticationProvider . 5 deviceAuthorizationResponseHandler() : The AuthenticationSuccessHandler ( post-processor ) used for handling an “authenticated” OAuth2DeviceAuthorizationRequestAuthenticationToken and returning the OAuth2DeviceAuthorizationResponse(https://datatracker.ietf.org/doc/html/rfc8628#section-3.2) . 6 errorResponseHandler() : The AuthenticationFailureHandler ( post-processor ) used for handling an OAuth2AuthenticationException and returning the OAuth2Error response(https://datatracker.ietf.org/doc/html/rfc6749#section-5.2) . 7 verificationUri() : The URI of the custom end-user verification page to direct resource owners to on a secondary device. OAuth2DeviceAuthorizationEndpointConfigurer configures the OAuth2DeviceAuthorizationEndpointFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . OAuth2DeviceAuthorizationEndpointFilter is the Filter that processes OAuth2 device authorization requests. OAuth2DeviceAuthorizationEndpointFilter is configured with the following defaults: AuthenticationConverter — An OAuth2DeviceAuthorizationRequestAuthenticationConverter . AuthenticationManager — An AuthenticationManager composed of OAuth2DeviceAuthorizationRequestAuthenticationProvider . AuthenticationSuccessHandler — An internal implementation that handles an “authenticated” OAuth2DeviceAuthorizationRequestAuthenticationToken and returns the OAuth2DeviceAuthorizationResponse . AuthenticationFailureHandler — An OAuth2ErrorAuthenticationFailureHandler . OAuth2 Device Verification Endpoint: OAuth2DeviceVerificationEndpointConfigurer provides the ability to customize the OAuth2 Device Verification endpoint(https://datatracker.ietf.org/doc/html/rfc8628#section-3.3) (or ""User Interaction""). It defines extension points that let you customize the pre-processing, main processing, and post-processing logic for OAuth2 device verification requests. OAuth2DeviceVerificationEndpointConfigurer provides the following configuration options: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .deviceVerificationEndpoint(deviceVerificationEndpoint -> deviceVerificationEndpoint .deviceVerificationRequestConverter(deviceVerificationRequestConverter) (1) .deviceVerificationRequestConverters(deviceVerificationRequestConvertersConsumer) (2) .authenticationProvider(authenticationProvider) (3) .authenticationProviders(authenticationProvidersConsumer) (4) .deviceVerificationResponseHandler(deviceVerificationResponseHandler) (5) .errorResponseHandler(errorResponseHandler) (6) .consentPage(""/oauth2/v1/consent"") (7) ); return http.build(); } 1 deviceVerificationRequestConverter() : Adds an AuthenticationConverter ( pre-processor ) used when attempting to extract an OAuth2 device verification request(https://datatracker.ietf.org/doc/html/rfc8628#section-3.3) (or consent) from HttpServletRequest to an instance of OAuth2DeviceVerificationAuthenticationToken or OAuth2DeviceAuthorizationConsentAuthenticationToken . 2 deviceVerificationRequestConverters() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationConverter 's allowing the ability to add, remove, or customize a specific AuthenticationConverter . 3 authenticationProvider() : Adds an AuthenticationProvider ( main processor ) used for authenticating the OAuth2DeviceVerificationAuthenticationToken or OAuth2DeviceAuthorizationConsentAuthenticationToken . 4 authenticationProviders() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationProvider 's allowing the ability to add, remove, or customize a specific AuthenticationProvider . 5 deviceVerificationResponseHandler() : The AuthenticationSuccessHandler ( post-processor ) used for handling an “authenticated” OAuth2DeviceVerificationAuthenticationToken and directing the resource owner to return to their device. 6 errorResponseHandler() : The AuthenticationFailureHandler ( post-processor ) used for handling an OAuth2AuthenticationException and returning the error response. 7 consentPage() : The URI of the custom consent page to redirect resource owners to if consent is required during the device verification request flow. OAuth2DeviceVerificationEndpointConfigurer configures the OAuth2DeviceVerificationEndpointFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . OAuth2DeviceVerificationEndpointFilter is the Filter that processes OAuth2 device verification requests (and consents). OAuth2DeviceVerificationEndpointFilter is configured with the following defaults: AuthenticationConverter — A DelegatingAuthenticationConverter composed of OAuth2DeviceVerificationAuthenticationConverter and OAuth2DeviceAuthorizationConsentAuthenticationConverter . AuthenticationManager — An AuthenticationManager composed of OAuth2DeviceVerificationAuthenticationProvider and OAuth2DeviceAuthorizationConsentAuthenticationProvider . AuthenticationSuccessHandler — A SimpleUrlAuthenticationSuccessHandler that handles an “authenticated” OAuth2DeviceVerificationAuthenticationToken and redirects the user to a success page ( /?success ). AuthenticationFailureHandler — An internal implementation that uses the OAuth2Error associated with the OAuth2AuthenticationException and returns the OAuth2Error response. OAuth2 Token Endpoint: OAuth2TokenEndpointConfigurer provides the ability to customize the OAuth2 Token endpoint(https://datatracker.ietf.org/doc/html/rfc6749#section-3.2) . It defines extension points that let you customize the pre-processing, main processing, and post-processing logic for OAuth2 access token requests(https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3) . OAuth2TokenEndpointConfigurer provides the following configuration options: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .tokenEndpoint(tokenEndpoint -> tokenEndpoint .accessTokenRequestConverter(accessTokenRequestConverter) (1) .accessTokenRequestConverters(accessTokenRequestConvertersConsumer) (2) .authenticationProvider(authenticationProvider) (3) .authenticationProviders(authenticationProvidersConsumer) (4) .accessTokenResponseHandler(accessTokenResponseHandler) (5) .errorResponseHandler(errorResponseHandler) (6) ); return http.build(); } 1 accessTokenRequestConverter() : Adds an AuthenticationConverter ( pre-processor ) used when attempting to extract an OAuth2 access token request(https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3) from HttpServletRequest to an instance of OAuth2AuthorizationGrantAuthenticationToken . 2 accessTokenRequestConverters() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationConverter 's allowing the ability to add, remove, or customize a specific AuthenticationConverter . 3 authenticationProvider() : Adds an AuthenticationProvider ( main processor ) used for authenticating the OAuth2AuthorizationGrantAuthenticationToken . 4 authenticationProviders() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationProvider 's allowing the ability to add, remove, or customize a specific AuthenticationProvider . 5 accessTokenResponseHandler() : The AuthenticationSuccessHandler ( post-processor ) used for handling an OAuth2AccessTokenAuthenticationToken and returning the OAuth2AccessTokenResponse(https://datatracker.ietf.org/doc/html/rfc6749#section-5.1) . 6 errorResponseHandler() : The AuthenticationFailureHandler ( post-processor ) used for handling an OAuth2AuthenticationException and returning the OAuth2Error response(https://datatracker.ietf.org/doc/html/rfc6749#section-5.2) . OAuth2TokenEndpointConfigurer configures the OAuth2TokenEndpointFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . OAuth2TokenEndpointFilter is the Filter that processes OAuth2 access token requests. The supported authorization grant types(https://datatracker.ietf.org/doc/html/rfc6749#section-1.3) are authorization_code , refresh_token , client_credentials , urn:ietf:params:oauth:grant-type:device_code , and urn:ietf:params:oauth:grant-type:token-exchange . OAuth2TokenEndpointFilter is configured with the following defaults: AuthenticationConverter — A DelegatingAuthenticationConverter composed of OAuth2AuthorizationCodeAuthenticationConverter , OAuth2RefreshTokenAuthenticationConverter , OAuth2ClientCredentialsAuthenticationConverter , OAuth2DeviceCodeAuthenticationConverter , and OAuth2TokenExchangeAuthenticationConverter . AuthenticationManager — An AuthenticationManager composed of OAuth2AuthorizationCodeAuthenticationProvider , OAuth2RefreshTokenAuthenticationProvider , OAuth2ClientCredentialsAuthenticationProvider , OAuth2DeviceCodeAuthenticationProvider , and OAuth2TokenExchangeAuthenticationProvider . AuthenticationSuccessHandler — An OAuth2AccessTokenResponseAuthenticationSuccessHandler . AuthenticationFailureHandler — An OAuth2ErrorAuthenticationFailureHandler . Customizing Client Credentials Grant Request Validation: OAuth2ClientCredentialsAuthenticationValidator is the default validator used for validating specific OAuth2 Client Credentials Grant request parameters. The default implementation validates the scope parameter. If validation fails, an OAuth2AuthenticationException is thrown. OAuth2ClientCredentialsAuthenticationProvider provides the ability to override the default request validation by supplying a custom authentication validator of type Consumer<OAuth2ClientCredentialsAuthenticationContext> to setAuthenticationValidator() . OAuth2ClientCredentialsAuthenticationContext holds the OAuth2ClientCredentialsAuthenticationToken , which contains the OAuth2 Client Credentials Grant request parameters. If validation fails, the authentication validator MUST throw OAuth2AuthenticationException . The following example shows how to configure OAuth2ClientCredentialsAuthenticationProvider with a custom authentication validator that overrides the default scope validation: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .tokenEndpoint(tokenEndpoint -> tokenEndpoint .authenticationProviders(configureAuthenticationValidator()) ); return http.build(); } private Consumer<List<AuthenticationProvider>> configureAuthenticationValidator() { return (authenticationProviders) -> authenticationProviders.forEach((authenticationProvider) -> { if (authenticationProvider instanceof OAuth2ClientCredentialsAuthenticationProvider) { Consumer<OAuth2ClientCredentialsAuthenticationContext> authenticationValidator = new CustomScopeValidator(); // Override default scope validation ((OAuth2ClientCredentialsAuthenticationProvider) authenticationProvider) .setAuthenticationValidator(authenticationValidator); } }); } static class CustomScopeValidator implements Consumer<OAuth2ClientCredentialsAuthenticationContext> { @Override public void accept(OAuth2ClientCredentialsAuthenticationContext authenticationContext) { OAuth2ClientCredentialsAuthenticationToken clientCredentialsAuthentication = authenticationContext.getAuthentication(); Set<String> requestedScopes = clientCredentialsAuthentication.getScopes(); RegisteredClient registeredClient = authenticationContext.getRegisteredClient(); Set<String> allowedScopes = registeredClient.getScopes(); // TODO Implement scope validation } } OAuth2 Token Introspection Endpoint: OAuth2TokenIntrospectionEndpointConfigurer provides the ability to customize the OAuth2 Token Introspection endpoint(https://datatracker.ietf.org/doc/html/rfc7662#section-2) . It defines extension points that let you customize the pre-processing, main processing, and post-processing logic for OAuth2 introspection requests(https://datatracker.ietf.org/doc/html/rfc7662#section-2.1) . OAuth2TokenIntrospectionEndpointConfigurer provides the following configuration options: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .tokenIntrospectionEndpoint(tokenIntrospectionEndpoint -> tokenIntrospectionEndpoint .introspectionRequestConverter(introspectionRequestConverter) (1) .introspectionRequestConverters(introspectionRequestConvertersConsumer) (2) .authenticationProvider(authenticationProvider) (3) .authenticationProviders(authenticationProvidersConsumer) (4) .introspectionResponseHandler(introspectionResponseHandler) (5) .errorResponseHandler(errorResponseHandler) (6) ); return http.build(); } 1 introspectionRequestConverter() : Adds an AuthenticationConverter ( pre-processor ) used when attempting to extract an OAuth2 introspection request(https://datatracker.ietf.org/doc/html/rfc7662#section-2.1) from HttpServletRequest to an instance of OAuth2TokenIntrospectionAuthenticationToken . 2 introspectionRequestConverters() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationConverter 's allowing the ability to add, remove, or customize a specific AuthenticationConverter . 3 authenticationProvider() : Adds an AuthenticationProvider ( main processor ) used for authenticating the OAuth2TokenIntrospectionAuthenticationToken . 4 authenticationProviders() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationProvider 's allowing the ability to add, remove, or customize a specific AuthenticationProvider . 5 introspectionResponseHandler() : The AuthenticationSuccessHandler ( post-processor ) used for handling an “authenticated” OAuth2TokenIntrospectionAuthenticationToken and returning the OAuth2TokenIntrospection response(https://datatracker.ietf.org/doc/html/rfc7662#section-2.2) . 6 errorResponseHandler() : The AuthenticationFailureHandler ( post-processor ) used for handling an OAuth2AuthenticationException and returning the OAuth2Error response(https://datatracker.ietf.org/doc/html/rfc7662#section-2.3) . OAuth2TokenIntrospectionEndpointConfigurer configures the OAuth2TokenIntrospectionEndpointFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . OAuth2TokenIntrospectionEndpointFilter is the Filter that processes OAuth2 introspection requests. OAuth2TokenIntrospectionEndpointFilter is configured with the following defaults: AuthenticationConverter — An OAuth2TokenIntrospectionAuthenticationConverter . AuthenticationManager — An AuthenticationManager composed of OAuth2TokenIntrospectionAuthenticationProvider . AuthenticationSuccessHandler — An internal implementation that handles an “authenticated” OAuth2TokenIntrospectionAuthenticationToken and returns the OAuth2TokenIntrospection response. AuthenticationFailureHandler — An OAuth2ErrorAuthenticationFailureHandler . OAuth2 Token Revocation Endpoint: OAuth2TokenRevocationEndpointConfigurer provides the ability to customize the OAuth2 Token Revocation endpoint(https://datatracker.ietf.org/doc/html/rfc7009#section-2) . It defines extension points that let you customize the pre-processing, main processing, and post-processing logic for OAuth2 revocation requests(https://datatracker.ietf.org/doc/html/rfc7009#section-2.1) . OAuth2TokenRevocationEndpointConfigurer provides the following configuration options: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .tokenRevocationEndpoint(tokenRevocationEndpoint -> tokenRevocationEndpoint .revocationRequestConverter(revocationRequestConverter) (1) .revocationRequestConverters(revocationRequestConvertersConsumer) (2) .authenticationProvider(authenticationProvider) (3) .authenticationProviders(authenticationProvidersConsumer) (4) .revocationResponseHandler(revocationResponseHandler) (5) .errorResponseHandler(errorResponseHandler) (6) ); return http.build(); } 1 revocationRequestConverter() : Adds an AuthenticationConverter ( pre-processor ) used when attempting to extract an OAuth2 revocation request(https://datatracker.ietf.org/doc/html/rfc7009#section-2.1) from HttpServletRequest to an instance of OAuth2TokenRevocationAuthenticationToken . 2 revocationRequestConverters() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationConverter 's allowing the ability to add, remove, or customize a specific AuthenticationConverter . 3 authenticationProvider() : Adds an AuthenticationProvider ( main processor ) used for authenticating the OAuth2TokenRevocationAuthenticationToken . 4 authenticationProviders() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationProvider 's allowing the ability to add, remove, or customize a specific AuthenticationProvider . 5 revocationResponseHandler() : The AuthenticationSuccessHandler ( post-processor ) used for handling an “authenticated” OAuth2TokenRevocationAuthenticationToken and returning the OAuth2 revocation response(https://datatracker.ietf.org/doc/html/rfc7009#section-2.2) . 6 errorResponseHandler() : The AuthenticationFailureHandler ( post-processor ) used for handling an OAuth2AuthenticationException and returning the OAuth2Error response(https://datatracker.ietf.org/doc/html/rfc7009#section-2.2.1) . OAuth2TokenRevocationEndpointConfigurer configures the OAuth2TokenRevocationEndpointFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . OAuth2TokenRevocationEndpointFilter is the Filter that processes OAuth2 revocation requests. OAuth2TokenRevocationEndpointFilter is configured with the following defaults: AuthenticationConverter — An OAuth2TokenRevocationAuthenticationConverter . AuthenticationManager — An AuthenticationManager composed of OAuth2TokenRevocationAuthenticationProvider . AuthenticationSuccessHandler — An internal implementation that handles an “authenticated” OAuth2TokenRevocationAuthenticationToken and returns the OAuth2 revocation response. AuthenticationFailureHandler — An OAuth2ErrorAuthenticationFailureHandler . OAuth2 Authorization Server Metadata Endpoint: OAuth2AuthorizationServerMetadataEndpointConfigurer provides the ability to customize the OAuth2 Authorization Server Metadata endpoint(https://datatracker.ietf.org/doc/html/rfc8414#section-3) . It defines an extension point that lets you customize the OAuth2 Authorization Server Metadata response(https://datatracker.ietf.org/doc/html/rfc8414#section-3.2) . OAuth2AuthorizationServerMetadataEndpointConfigurer provides the following configuration option: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .authorizationServerMetadataEndpoint(authorizationServerMetadataEndpoint -> authorizationServerMetadataEndpoint .authorizationServerMetadataCustomizer(authorizationServerMetadataCustomizer)); (1) return http.build(); } 1 authorizationServerMetadataCustomizer() : The Consumer providing access to the OAuth2AuthorizationServerMetadata.Builder allowing the ability to customize the claims of the Authorization Server’s configuration. OAuth2AuthorizationServerMetadataEndpointConfigurer configures the OAuth2AuthorizationServerMetadataEndpointFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . OAuth2AuthorizationServerMetadataEndpointFilter is the Filter that returns the OAuth2AuthorizationServerMetadata response(https://datatracker.ietf.org/doc/html/rfc8414#section-3.2) . JWK Set Endpoint: OAuth2AuthorizationServerConfigurer provides support for the JWK Set endpoint(https://datatracker.ietf.org/doc/html/rfc7517) . OAuth2AuthorizationServerConfigurer configures the NimbusJwkSetEndpointFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . NimbusJwkSetEndpointFilter is the Filter that returns the JWK Set(https://datatracker.ietf.org/doc/html/rfc7517#section-5) . The JWK Set endpoint is configured only if a JWKSource<SecurityContext> @Bean is registered. OpenID Connect 1.0 Provider Configuration Endpoint: OidcProviderConfigurationEndpointConfigurer provides the ability to customize the OpenID Connect 1.0 Provider Configuration endpoint(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) . It defines an extension point that lets you customize the OpenID Provider Configuration response(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse) . OidcProviderConfigurationEndpointConfigurer provides the following configuration option: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .oidc(oidc -> oidc .providerConfigurationEndpoint(providerConfigurationEndpoint -> providerConfigurationEndpoint .providerConfigurationCustomizer(providerConfigurationCustomizer) (1) ) ); return http.build(); } 1 providerConfigurationCustomizer() : The Consumer providing access to the OidcProviderConfiguration.Builder allowing the ability to customize the claims of the OpenID Provider’s configuration. OidcProviderConfigurationEndpointConfigurer configures the OidcProviderConfigurationEndpointFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . OidcProviderConfigurationEndpointFilter is the Filter that returns the OidcProviderConfiguration response(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse) . OpenID Connect 1.0 Logout Endpoint: OidcLogoutEndpointConfigurer provides the ability to customize the OpenID Connect 1.0 Logout endpoint(https://openid.net/specs/openid-connect-rpinitiated-1_0.html#RPLogout) . It defines extension points that let you customize the pre-processing, main processing, and post-processing logic for RP-Initiated Logout requests. OidcLogoutEndpointConfigurer provides the following configuration options: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .oidc(oidc -> oidc .logoutEndpoint(logoutEndpoint -> logoutEndpoint .logoutRequestConverter(logoutRequestConverter) (1) .logoutRequestConverters(logoutRequestConvertersConsumer) (2) .authenticationProvider(authenticationProvider) (3) .authenticationProviders(authenticationProvidersConsumer) (4) .logoutResponseHandler(logoutResponseHandler) (5) .errorResponseHandler(errorResponseHandler) (6) ) ); return http.build(); } 1 logoutRequestConverter() : Adds an AuthenticationConverter ( pre-processor ) used when attempting to extract a Logout request(https://openid.net/specs/openid-connect-rpinitiated-1_0.html#RPLogout) from HttpServletRequest to an instance of OidcLogoutAuthenticationToken . 2 logoutRequestConverters() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationConverter 's allowing the ability to add, remove, or customize a specific AuthenticationConverter . 3 authenticationProvider() : Adds an AuthenticationProvider ( main processor ) used for authenticating the OidcLogoutAuthenticationToken . 4 authenticationProviders() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationProvider 's allowing the ability to add, remove, or customize a specific AuthenticationProvider . 5 logoutResponseHandler() : The AuthenticationSuccessHandler ( post-processor ) used for handling an “authenticated” OidcLogoutAuthenticationToken and performing the logout. 6 errorResponseHandler() : The AuthenticationFailureHandler ( post-processor ) used for handling an OAuth2AuthenticationException and returning the error response. OidcLogoutEndpointConfigurer configures the OidcLogoutEndpointFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . OidcLogoutEndpointFilter is the Filter that processes RP-Initiated Logout requests(https://openid.net/specs/openid-connect-rpinitiated-1_0.html#RPLogout) and performs the logout of the End-User. OidcLogoutEndpointFilter is configured with the following defaults: AuthenticationConverter — An OidcLogoutAuthenticationConverter . AuthenticationManager — An AuthenticationManager composed of OidcLogoutAuthenticationProvider . AuthenticationSuccessHandler — An internal implementation that handles an “authenticated” OidcLogoutAuthenticationToken and performs the logout. AuthenticationFailureHandler — An internal implementation that uses the OAuth2Error associated with the OAuth2AuthenticationException and returns the OAuth2Error response. OidcLogoutAuthenticationProvider uses a SessionRegistry(core-model-components.html#session-registry) to look up the SessionInformation instance associated to the End-User requesting to be logged out. OidcClientInitiatedLogoutSuccessHandler is the corresponding configuration in Spring Security’s OAuth2 Client support for configuring OpenID Connect 1.0 RP-Initiated Logout(https://docs.spring.io/spring-security/reference/servlet/oauth2/login/advanced.html#oauth2login-advanced-oidc-logout) . OpenID Connect 1.0 UserInfo Endpoint: OidcUserInfoEndpointConfigurer provides the ability to customize the OpenID Connect 1.0 UserInfo endpoint(https://openid.net/specs/openid-connect-core-1_0.html#UserInfo) . It defines extension points that let you customize the pre-processing, main processing, and post-processing logic for UserInfo requests(https://openid.net/specs/openid-connect-core-1_0.html#UserInfoRequest) . OidcUserInfoEndpointConfigurer provides the following configuration options: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .oidc(oidc -> oidc .userInfoEndpoint(userInfoEndpoint -> userInfoEndpoint .userInfoRequestConverter(userInfoRequestConverter) (1) .userInfoRequestConverters(userInfoRequestConvertersConsumer) (2) .authenticationProvider(authenticationProvider) (3) .authenticationProviders(authenticationProvidersConsumer) (4) .userInfoResponseHandler(userInfoResponseHandler) (5) .errorResponseHandler(errorResponseHandler) (6) .userInfoMapper(userInfoMapper) (7) ) ); return http.build(); } 1 userInfoRequestConverter() : Adds an AuthenticationConverter ( pre-processor ) used when attempting to extract an UserInfo request(https://openid.net/specs/openid-connect-core-1_0.html#UserInfoRequest) from HttpServletRequest to an instance of OidcUserInfoAuthenticationToken . 2 userInfoRequestConverters() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationConverter 's allowing the ability to add, remove, or customize a specific AuthenticationConverter . 3 authenticationProvider() : Adds an AuthenticationProvider ( main processor ) used for authenticating the OidcUserInfoAuthenticationToken . 4 authenticationProviders() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationProvider 's allowing the ability to add, remove, or customize a specific AuthenticationProvider . 5 userInfoResponseHandler() : The AuthenticationSuccessHandler ( post-processor ) used for handling an “authenticated” OidcUserInfoAuthenticationToken and returning the UserInfo response(https://openid.net/specs/openid-connect-core-1_0.html#UserInfoResponse) . 6 errorResponseHandler() : The AuthenticationFailureHandler ( post-processor ) used for handling an OAuth2AuthenticationException and returning the UserInfo Error response(https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError) . 7 userInfoMapper() : The Function used to extract claims from OidcUserInfoAuthenticationContext to an instance of OidcUserInfo . OidcUserInfoEndpointConfigurer configures the OidcUserInfoEndpointFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . OidcUserInfoEndpointFilter is the Filter that processes UserInfo requests(https://openid.net/specs/openid-connect-core-1_0.html#UserInfoRequest) and returns the OidcUserInfo response(https://openid.net/specs/openid-connect-core-1_0.html#UserInfoResponse) . OidcUserInfoEndpointFilter is configured with the following defaults: AuthenticationConverter — An internal implementation that obtains the Authentication from the SecurityContext and creates an OidcUserInfoAuthenticationToken with the principal. AuthenticationManager — An AuthenticationManager composed of OidcUserInfoAuthenticationProvider , which is associated with an internal implementation of userInfoMapper that extracts standard claims(https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) from the ID Token(https://openid.net/specs/openid-connect-core-1_0.html#IDToken) based on the scopes requested(https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) during authorization. AuthenticationSuccessHandler — An internal implementation that handles an “authenticated” OidcUserInfoAuthenticationToken and returns the OidcUserInfo response. AuthenticationFailureHandler — An internal implementation that uses the OAuth2Error associated with the OAuth2AuthenticationException and returns the OAuth2Error response. You can customize the ID Token by providing an OAuth2TokenCustomizer<JwtEncodingContext>(core-model-components.html#oauth2-token-customizer) @Bean . The OpenID Connect 1.0 UserInfo endpoint is an OAuth2 protected resource, which REQUIRES an access token to be sent as a bearer token in the UserInfo request(https://openid.net/specs/openid-connect-core-1_0.html#UserInfoRequest) . The following example shows how to enable the OAuth2 resource server configuration: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); ... http.oauth2ResourceServer(resourceServer -> resourceServer.jwt(Customizer.withDefaults())); return http.build(); } @Bean public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) { return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource); } A JwtDecoder @Bean is REQUIRED for the OpenID Connect 1.0 UserInfo endpoint. The guide How-to: Customize the OpenID Connect 1.0 UserInfo response(guides/how-to-userinfo.html) contains examples of customizing the UserInfo endpoint. OpenID Connect 1.0 Client Registration Endpoint: OidcClientRegistrationEndpointConfigurer provides the ability to customize the OpenID Connect 1.0 Client Registration endpoint(https://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration) . It defines extension points that let you customize the pre-processing, main processing, and post-processing logic for Client Registration requests(https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationRequest) or Client Read requests(https://openid.net/specs/openid-connect-registration-1_0.html#ReadRequest) . OidcClientRegistrationEndpointConfigurer provides the following configuration options: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); authorizationServerConfigurer .oidc(oidc -> oidc .clientRegistrationEndpoint(clientRegistrationEndpoint -> clientRegistrationEndpoint .clientRegistrationRequestConverter(clientRegistrationRequestConverter) (1) .clientRegistrationRequestConverters(clientRegistrationRequestConvertersConsumers) (2) .authenticationProvider(authenticationProvider) (3) .authenticationProviders(authenticationProvidersConsumer) (4) .clientRegistrationResponseHandler(clientRegistrationResponseHandler) (5) .errorResponseHandler(errorResponseHandler) (6) ) ); return http.build(); } 1 clientRegistrationRequestConverter() : Adds an AuthenticationConverter ( pre-processor ) used when attempting to extract a Client Registration request(https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationRequest) or Client Read request(https://openid.net/specs/openid-connect-registration-1_0.html#ReadRequest) from HttpServletRequest to an instance of OidcClientRegistrationAuthenticationToken . 2 clientRegistrationRequestConverters() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationConverter 's allowing the ability to add, remove, or customize a specific AuthenticationConverter . 3 authenticationProvider() : Adds an AuthenticationProvider ( main processor ) used for authenticating the OidcClientRegistrationAuthenticationToken . 4 authenticationProviders() : Sets the Consumer providing access to the List of default and (optionally) added AuthenticationProvider 's allowing the ability to add, remove, or customize a specific AuthenticationProvider . 5 clientRegistrationResponseHandler() : The AuthenticationSuccessHandler ( post-processor ) used for handling an “authenticated” OidcClientRegistrationAuthenticationToken and returning the Client Registration response(https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationResponse) or Client Read response(https://openid.net/specs/openid-connect-registration-1_0.html#ReadResponse) . 6 errorResponseHandler() : The AuthenticationFailureHandler ( post-processor ) used for handling an OAuth2AuthenticationException and returning the Client Registration Error response(https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationError) or Client Read Error response(https://openid.net/specs/openid-connect-registration-1_0.html#ReadError) . The OpenID Connect 1.0 Client Registration endpoint is disabled by default because many deployments do not require dynamic client registration. OidcClientRegistrationEndpointConfigurer configures the OidcClientRegistrationEndpointFilter and registers it with the OAuth2 authorization server SecurityFilterChain @Bean . OidcClientRegistrationEndpointFilter is the Filter that processes Client Registration requests(https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationRequest) and returns the OidcClientRegistration response(https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationResponse) . OidcClientRegistrationEndpointFilter also processes Client Read requests(https://openid.net/specs/openid-connect-registration-1_0.html#ReadRequest) and returns the OidcClientRegistration response(https://openid.net/specs/openid-connect-registration-1_0.html#ReadResponse) . OidcClientRegistrationEndpointFilter is configured with the following defaults: AuthenticationConverter — An OidcClientRegistrationAuthenticationConverter . AuthenticationManager — An AuthenticationManager composed of OidcClientRegistrationAuthenticationProvider and OidcClientConfigurationAuthenticationProvider . AuthenticationSuccessHandler — An internal implementation that handles an “authenticated” OidcClientRegistrationAuthenticationToken and returns the OidcClientRegistration response. AuthenticationFailureHandler — An internal implementation that uses the OAuth2Error associated with the OAuth2AuthenticationException and returns the OAuth2Error response. The OpenID Connect 1.0 Client Registration endpoint is an OAuth2 protected resource(https://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration) , which REQUIRES an access token to be sent as a bearer token in the Client Registration (or Client Read) request. The access token in a Client Registration request REQUIRES the OAuth2 scope client.create . The access token in a Client Read request REQUIRES the OAuth2 scope client.read . The following example shows how to enable the OAuth2 resource server configuration: @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); http.apply(authorizationServerConfigurer); ... http.oauth2ResourceServer(resourceServer -> resourceServer.jwt(Customizer.withDefaults())); return http.build(); } @Bean public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) { return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource); } A JwtDecoder @Bean is REQUIRED for the OpenID Connect 1.0 Client Registration endpoint."
"https://docs.spring.io/spring-authorization-server/reference/1.3/how-to.html","How-to Guides: Section Summary: How-to: Authenticate using a Single Page Application with PKCE(guides/how-to-pkce.html) How-to: Authenticate using Social Login(guides/how-to-social-login.html) How-to: Implement an Extension Authorization Grant Type(guides/how-to-ext-grant-type.html) How-to: Implement Multitenancy(guides/how-to-multitenancy.html) How-to: Customize the OpenID Connect 1.0 UserInfo response(guides/how-to-userinfo.html) How-to: Implement core services with JPA(guides/how-to-jpa.html) How-to: Add authorities as custom claims in JWT access tokens(guides/how-to-custom-claims-authorities.html) How-to: Register a client dynamically(guides/how-to-dynamic-client-registration.html)"
"https://docs.spring.io/spring-authorization-server/reference/1.3/guides/how-to-pkce.html","How-to: Authenticate using a Single Page Application with PKCE: This guide shows how to configure Spring Authorization Server(../index.html) to support a Single Page Application (SPA) with Proof Key for Code Exchange (PKCE). The purpose of this guide is to demonstrate how to support a public client and require PKCE for client authentication. Spring Authorization Server will not issue refresh tokens for a public client. We recommend the backend for frontend (BFF) pattern as an alternative to exposing a public client. See gh-297(https://github.com/spring-projects/spring-authorization-server/issues/297#issue-896744390) for more information. Enable CORS(#enable-cors) Configure a Public Client(#configure-public-client) Authenticate with the Client(#authenticate-with-client) Enable CORS: A SPA consists of static resources that can be deployed in a variety of ways. It can be deployed separately from the backend such as with a CDN or separate web server, or it can be deployed along side the backend using Spring Boot. When a SPA is hosted under a different domain, Cross Origin Resource Sharing (CORS) can be used to allow the application to communicate with the backend. For example, if you have an Angular dev server running locally on port 4200 , you can define a CorsConfigurationSource @Bean and configure Spring Security to allow pre-flight requests using the cors() DSL as in the following example: Enable CORS import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.annotation.Order; import org.springframework.http.MediaType; import org.springframework.security.config.Customizer; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configuration.OAuth2AuthorizationServerConfiguration; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configurers.OAuth2AuthorizationServerConfigurer; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint; import org.springframework.security.web.util.matcher.MediaTypeRequestMatcher; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.CorsConfigurationSource; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; @Configuration @EnableWebSecurity public class SecurityConfig { @Bean @Order(1) public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); http.getConfigurer(OAuth2AuthorizationServerConfigurer.class) .oidc(Customizer.withDefaults()); // Enable OpenID Connect 1.0 http // Redirect to the login page when not authenticated from the // authorization endpoint .exceptionHandling((exceptions) -> exceptions .defaultAuthenticationEntryPointFor( new LoginUrlAuthenticationEntryPoint(""/login""), new MediaTypeRequestMatcher(MediaType.TEXT_HTML) ) ) // Accept access tokens for User Info and/or Client Registration .oauth2ResourceServer((oauth2) -> oauth2.jwt(Customizer.withDefaults())); return http.cors(Customizer.withDefaults()).build(); } @Bean @Order(2) public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) // Form login handles the redirect to the login page from the // authorization server filter chain .formLogin(Customizer.withDefaults()); return http.cors(Customizer.withDefaults()).build(); } @Bean public CorsConfigurationSource corsConfigurationSource() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.addAllowedHeader(""*""); config.addAllowedMethod(""*""); config.addAllowedOrigin(""http://127.0.0.1:4200""); config.setAllowCredentials(true); source.registerCorsConfiguration(""/**"", config); return source; } } Click on the ""Expand folded text"" icon in the code sample above to display the full example. Configure a Public Client: A SPA cannot securely store credentials and therefore must be treated as a public client(https://datatracker.ietf.org/doc/html/rfc6749#section-2.1) . Public clients should be required to use Proof Key for Code Exchange(https://datatracker.ietf.org/doc/html/rfc7636#section-4) (PKCE). Continuing the earlier(#enable-cors-configuration) example, you can configure Spring Authorization Server to support a public client using the Client Authentication Method none and require PKCE as in the following example: Yaml Java spring: security: oauth2: authorizationserver: client: public-client: registration: client-id: ""public-client"" client-authentication-methods: - ""none"" authorization-grant-types: - ""authorization_code"" redirect-uris: - ""http://127.0.0.1:4200"" scopes: - ""openid"" - ""profile"" require-authorization-consent: true require-proof-key: true @Bean public RegisteredClientRepository registeredClientRepository() { RegisteredClient publicClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(""public-client"") .clientAuthenticationMethod(ClientAuthenticationMethod.NONE) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .redirectUri(""http://127.0.0.1:4200"") .scope(OidcScopes.OPENID) .scope(OidcScopes.PROFILE) .clientSettings(ClientSettings.builder() .requireAuthorizationConsent(true) .requireProofKey(true) .build() ) .build(); return new InMemoryRegisteredClientRepository(publicClient); } The requireProofKey setting is important to prevent the PKCE Downgrade Attack(https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-25#name-pkce-downgrade-attack) . Authenticate with the Client: Once the server is configured to support a public client, a common question is: How do I authenticate the client and get an access token? The short answer is: The same way you would with any other client. A SPA is a browser-based application and therefore uses the same redirection-based flow as any other client. This question is usually related to an expectation that authentication can be performed via a REST API, which is not the case with OAuth2. A more detailed answer requires an understanding of the flow(s) involved in OAuth2 and OpenID Connect, in this case the Authorization Code flow. The steps of the Authorization Code flow are as follows: The client initiates an OAuth2 request via a redirect to the Authorization Endpoint(../protocol-endpoints.html#oauth2-authorization-endpoint) . For a public client, this step includes generating the code_verifier and calculating the code_challenge , which is then sent as a query parameter. If the user is not authenticated, the authorization server will redirect to the login page. After authentication, the user is redirected back to the Authorization Endpoint again. If the user has not consented to the requested scope(s) and consent is required, the consent page is displayed. Once the user has consented, the authorization server generates an authorization_code and redirects back to the client via the redirect_uri . The client obtains the authorization_code via a query parameter and performs a request to the Token Endpoint(../protocol-endpoints.html#oauth2-token-endpoint) . For a public client, this step includes sending the code_verifier parameter instead of credentials for authentication. As you can see, the flow is fairly involved and this overview only scratches the surface. It is recommended that you use a robust client-side library supported by your single-page app framework to handle the Authorization Code flow."
"https://docs.spring.io/spring-authorization-server/reference/1.3/guides/how-to-social-login.html","How-to: Authenticate using Social Login: This guide shows how to configure Spring Authorization Server(../index.html) with a social login provider (such as Google, GitHub, etc.) for authentication(https://docs.spring.io/spring-security/reference/servlet/authentication/index.html) . The purpose of this guide is to demonstrate how to replace Form Login(https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/form.html) with OAuth 2.0 Login(https://docs.spring.io/spring-security/reference/servlet/oauth2/login/index.html) . Spring Authorization Server is built on Spring Security(https://docs.spring.io/spring-security/reference/index.html) and we will be using Spring Security concepts throughout this guide. Register with Social Login Provider(#register-social-login-provider) Configure OAuth 2.0 Login(#configure-oauth2-login) Advanced Use Cases(#advanced-use-cases) Register with Social Login Provider: To get started, you will need to set up an application with your chosen social login provider. Common providers include: Google(https://developers.google.com/identity/openid-connect/openid-connect#appsetup) GitHub(https://github.com/settings/developers) Facebook(https://developers.facebook.com/apps) Okta(https://www.okta.com/developer/signup) Follow the steps for your provider until you are asked to specify a Redirect URI. To set up a Redirect URI, choose a registrationId (such as google , my-client or any other unique identifier you wish) which you will use to configure both Spring Security and your provider. The registrationId is a unique identifier for the ClientRegistration in Spring Security. The default Redirect URI template is {baseUrl}/login/oauth2/code/{registrationId} . See Setting the Redirect URI(https://docs.spring.io/spring-security/reference/servlet/oauth2/login/core.html#oauth2login-sample-redirect-uri) in the Spring Security reference for more information. For example, testing locally on port 9000 with a registrationId of google , your Redirect URI would be localhost:9000/login/oauth2/code/google(http://localhost:9000/login/oauth2/code/google) . Enter this value as the Redirect URI when setting up the application with your provider. Once you’ve completed the set-up process with your social login provider, you should have obtained credentials (a Client ID and Client Secret). In addition, you will need to reference the provider’s documentation and take note of the following values: Authorization URI : The endpoint that is used to initiate the authorization_code flow at the provider. Token URI : The endpoint that is used to exchange an authorization_code for an access_token and optionally an id_token . JWK Set URI : The endpoint that is used to obtain keys for verifying the signature of a JWT, which is required when an id_token is available. User Info URI : The endpoint that is used to obtain user information, which is required when an id_token is not available. User Name Attribute : The claim in either the id_token or the User Info Response containing the username of the user. Configure OAuth 2.0 Login: Once you’ve registered(#register-social-login-provider) with a social login provider, you can proceed to configuring Spring Security for OAuth 2.0 Login(https://docs.spring.io/spring-security/reference/servlet/oauth2/login/index.html) . Add OAuth2 Client Dependency(#configure-oauth2-login-dependency) Register a Client(#configure-oauth2-login-client-registration) Configure Authentication(#configure-oauth2-login-authentication) Add OAuth2 Client Dependency: First, add the following dependency: Maven Gradle <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-oauth2-client</artifactId> </dependency> implementation ""org.springframework.boot:spring-boot-starter-oauth2-client"" Register a Client: Next, configure the ClientRegistration with the values obtained earlier(#register-social-login-provider) . Using Okta as an example, configure the following properties: application.yml okta: base-url: ${OKTA_BASE_URL} spring: security: oauth2: client: registration: my-client: provider: okta client-id: ${OKTA_CLIENT_ID} client-secret: ${OKTA_CLIENT_SECRET} scope: - openid - profile - email provider: okta: authorization-uri: ${okta.base-url}/oauth2/v1/authorize token-uri: ${okta.base-url}/oauth2/v1/token user-info-uri: ${okta.base-url}/oauth2/v1/userinfo jwk-set-uri: ${okta.base-url}/oauth2/v1/keys user-name-attribute: sub The registrationId in the above example is my-client . The above example demonstrates the recommended way to set the Provider URL, Client ID and Client Secret using environment variables ( OKTA_BASE_URL , OKTA_CLIENT_ID and OKTA_CLIENT_SECRET ). See Externalized Configuration(https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config) in the Spring Boot reference for more information. This simple example demonstrates a typical configuration, but some providers will require additional configuration. For more information about configuring the ClientRegistration , see Spring Boot Property Mappings(https://docs.spring.io/spring-security/reference/servlet/oauth2/login/core.html#oauth2login-boot-property-mappings) in the Spring Security reference. Configure Authentication: Finally, to configure Spring Authorization Server to use a social login provider for authentication, you can use oauth2Login() instead of formLogin() . You can also automatically redirect an unauthenticated user to the provider by configuring exceptionHandling() with an AuthenticationEntryPoint . Continuing our earlier example(#configure-oauth2-login-okta-example) , configure Spring Security using a @Configuration as in the following example: Configure OAuth 2.0 Login import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.annotation.Order; import org.springframework.http.MediaType; import org.springframework.security.config.Customizer; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configuration.OAuth2AuthorizationServerConfiguration; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configurers.OAuth2AuthorizationServerConfigurer; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint; import org.springframework.security.web.util.matcher.MediaTypeRequestMatcher; @Configuration @EnableWebSecurity public class SecurityConfig { @Bean (1) @Order(1) public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); http.getConfigurer(OAuth2AuthorizationServerConfigurer.class) .oidc(Customizer.withDefaults()); // Enable OpenID Connect 1.0 http // Redirect to the OAuth 2.0 Login endpoint when not authenticated // from the authorization endpoint .exceptionHandling((exceptions) -> exceptions .defaultAuthenticationEntryPointFor( (2) new LoginUrlAuthenticationEntryPoint(""/oauth2/authorization/my-client""), new MediaTypeRequestMatcher(MediaType.TEXT_HTML) ) ) // Accept access tokens for User Info and/or Client Registration .oauth2ResourceServer((oauth2) -> oauth2.jwt(Customizer.withDefaults())); return http.build(); } @Bean (3) @Order(2) public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) // OAuth2 Login handles the redirect to the OAuth 2.0 Login endpoint // from the authorization server filter chain .oauth2Login(Customizer.withDefaults()); (4) return http.build(); } } 1 A Spring Security filter chain for the Protocol Endpoints(../protocol-endpoints.html) . 2 Configure an AuthenticationEntryPoint for redirecting to the OAuth 2.0 Login endpoint(https://docs.spring.io/spring-security/reference/servlet/oauth2/login/advanced.html#oauth2login-advanced-login-page) . 3 A Spring Security filter chain for authentication(https://docs.spring.io/spring-security/reference/servlet/authentication/index.html) . 4 Configure OAuth 2.0 Login(https://docs.spring.io/spring-security/reference/servlet/oauth2/login/index.html) for authentication. If you configured a UserDetailsService when getting started(../getting-started.html#developing-your-first-application) , you can remove it now. Advanced Use Cases: The demo authorization server sample(https://github.com/spring-projects/spring-authorization-server/tree/main/samples#demo-sample) demonstrates advanced configuration options for federating identity providers. Select from the following use cases to see an example of each: I want to Capture Users in a Database(#advanced-use-cases-capture-users) I want to Map Claims to an ID Token(#advanced-use-cases-map-claims) Capture Users in a Database: The following example AuthenticationSuccessHandler uses a custom component to capture users in a local database when they first log in: FederatedIdentityAuthenticationSuccessHandler import java.io.IOException; import java.util.function.Consumer; import jakarta.servlet.ServletException; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.springframework.security.core.Authentication; import org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken; import org.springframework.security.oauth2.core.oidc.user.OidcUser; import org.springframework.security.oauth2.core.user.OAuth2User; import org.springframework.security.web.authentication.AuthenticationSuccessHandler; import org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler; public final class FederatedIdentityAuthenticationSuccessHandler implements AuthenticationSuccessHandler { private final AuthenticationSuccessHandler delegate = new SavedRequestAwareAuthenticationSuccessHandler(); private Consumer<OAuth2User> oauth2UserHandler = (user) -> {}; private Consumer<OidcUser> oidcUserHandler = (user) -> this.oauth2UserHandler.accept(user); @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { if (authentication instanceof OAuth2AuthenticationToken) { if (authentication.getPrincipal() instanceof OidcUser) { this.oidcUserHandler.accept((OidcUser) authentication.getPrincipal()); } else if (authentication.getPrincipal() instanceof OAuth2User) { this.oauth2UserHandler.accept((OAuth2User) authentication.getPrincipal()); } } this.delegate.onAuthenticationSuccess(request, response, authentication); } public void setOAuth2UserHandler(Consumer<OAuth2User> oauth2UserHandler) { this.oauth2UserHandler = oauth2UserHandler; } public void setOidcUserHandler(Consumer<OidcUser> oidcUserHandler) { this.oidcUserHandler = oidcUserHandler; } } Using the AuthenticationSuccessHandler above, you can plug in your own Consumer<OAuth2User> that can capture users in a database or other data store for concepts like Federated Account Linking or JIT Account Provisioning. Here is an example that simply stores users in-memory: UserRepositoryOAuth2UserHandler import java.util.Map; import java.util.concurrent.ConcurrentHashMap; import java.util.function.Consumer; import org.springframework.security.oauth2.core.user.OAuth2User; public final class UserRepositoryOAuth2UserHandler implements Consumer<OAuth2User> { private final UserRepository userRepository = new UserRepository(); @Override public void accept(OAuth2User user) { // Capture user in a local data store on first authentication if (this.userRepository.findByName(user.getName()) == null) { System.out.println(""Saving first-time user: name="" + user.getName() + "", claims="" + user.getAttributes() + "", authorities="" + user.getAuthorities()); this.userRepository.save(user); } } static class UserRepository { private final Map<String, OAuth2User> userCache = new ConcurrentHashMap<>(); public OAuth2User findByName(String name) { return this.userCache.get(name); } public void save(OAuth2User oauth2User) { this.userCache.put(oauth2User.getName(), oauth2User); } } } Map Claims to an ID Token: The following example OAuth2TokenCustomizer maps a user’s claims from an authentication provider to the id_token produced by Spring Authorization Server: FederatedIdentityIdTokenCustomizer import java.util.Arrays; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Set; import org.springframework.security.core.Authentication; import org.springframework.security.oauth2.core.oidc.IdTokenClaimNames; import org.springframework.security.oauth2.core.oidc.OidcIdToken; import org.springframework.security.oauth2.core.oidc.endpoint.OidcParameterNames; import org.springframework.security.oauth2.core.oidc.user.OidcUser; import org.springframework.security.oauth2.core.user.OAuth2User; import org.springframework.security.oauth2.server.authorization.token.JwtEncodingContext; import org.springframework.security.oauth2.server.authorization.token.OAuth2TokenCustomizer; public final class FederatedIdentityIdTokenCustomizer implements OAuth2TokenCustomizer<JwtEncodingContext> { private static final Set<String> ID_TOKEN_CLAIMS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList( IdTokenClaimNames.ISS, IdTokenClaimNames.SUB, IdTokenClaimNames.AUD, IdTokenClaimNames.EXP, IdTokenClaimNames.IAT, IdTokenClaimNames.AUTH_TIME, IdTokenClaimNames.NONCE, IdTokenClaimNames.ACR, IdTokenClaimNames.AMR, IdTokenClaimNames.AZP, IdTokenClaimNames.AT_HASH, IdTokenClaimNames.C_HASH ))); @Override public void customize(JwtEncodingContext context) { if (OidcParameterNames.ID_TOKEN.equals(context.getTokenType().getValue())) { Map<String, Object> thirdPartyClaims = extractClaims(context.getPrincipal()); context.getClaims().claims(existingClaims -> { // Remove conflicting claims set by this authorization server existingClaims.keySet().forEach(thirdPartyClaims::remove); // Remove standard id_token claims that could cause problems with clients ID_TOKEN_CLAIMS.forEach(thirdPartyClaims::remove); // Add all other claims directly to id_token existingClaims.putAll(thirdPartyClaims); }); } } private Map<String, Object> extractClaims(Authentication principal) { Map<String, Object> claims; if (principal.getPrincipal() instanceof OidcUser) { OidcUser oidcUser = (OidcUser) principal.getPrincipal(); OidcIdToken idToken = oidcUser.getIdToken(); claims = idToken.getClaims(); } else if (principal.getPrincipal() instanceof OAuth2User) { OAuth2User oauth2User = (OAuth2User) principal.getPrincipal(); claims = oauth2User.getAttributes(); } else { claims = Collections.emptyMap(); } return new HashMap<>(claims); } } You can configure Spring Authorization Server to use this customizer by publishing it as a @Bean as in the following example: Configure FederatedIdentityIdTokenCustomizer @Bean public OAuth2TokenCustomizer<JwtEncodingContext> idTokenCustomizer() { return new FederatedIdentityIdTokenCustomizer(); }"
"https://docs.spring.io/spring-authorization-server/reference/1.3/guides/how-to-ext-grant-type.html","How-to: Implement an Extension Authorization Grant Type: This guide shows how to extend Spring Authorization Server(../index.html) with an extension authorization grant type(https://datatracker.ietf.org/doc/html/rfc6749#section-4.5) . The purpose of this guide is to demonstrate how to implement an extension authorization grant type and configure it at the OAuth2 Token endpoint(../protocol-endpoints.html#oauth2-token-endpoint) . Extending Spring Authorization Server with a new authorization grant type requires implementing an AuthenticationConverter and AuthenticationProvider , and configuring both components at the OAuth2 Token endpoint(../protocol-endpoints.html#oauth2-token-endpoint) . In addition to the component implementations, a unique absolute URI needs to be assigned for use with the grant_type parameter. Implement AuthenticationConverter(#implement-authentication-converter) Implement AuthenticationProvider(#implement-authentication-provider) Configure OAuth2 Token Endpoint(#configure-token-endpoint) Request the Access Token(#request-access-token) Implement AuthenticationConverter: Assuming the absolute URI for the grant_type parameter is urn:ietf:params:oauth:grant-type:custom_code and the code parameter represents the authorization grant, the following example shows a sample implementation of the AuthenticationConverter : AuthenticationConverter import java.util.HashMap; import java.util.Map; import jakarta.servlet.http.HttpServletRequest; import org.springframework.lang.Nullable; import org.springframework.security.core.Authentication; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.oauth2.core.OAuth2AuthenticationException; import org.springframework.security.oauth2.core.OAuth2ErrorCodes; import org.springframework.security.oauth2.core.endpoint.OAuth2ParameterNames; import org.springframework.security.web.authentication.AuthenticationConverter; import org.springframework.util.LinkedMultiValueMap; import org.springframework.util.MultiValueMap; import org.springframework.util.StringUtils; public class CustomCodeGrantAuthenticationConverter implements AuthenticationConverter { @Nullable @Override public Authentication convert(HttpServletRequest request) { // grant_type (REQUIRED) String grantType = request.getParameter(OAuth2ParameterNames.GRANT_TYPE); if (!""urn:ietf:params:oauth:grant-type:custom_code"".equals(grantType)) { (1) return null; } Authentication clientPrincipal = SecurityContextHolder.getContext().getAuthentication(); MultiValueMap<String, String> parameters = getParameters(request); // code (REQUIRED) String code = parameters.getFirst(OAuth2ParameterNames.CODE); (2) if (!StringUtils.hasText(code) || parameters.get(OAuth2ParameterNames.CODE).size() != 1) { throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_REQUEST); } Map<String, Object> additionalParameters = new HashMap<>(); parameters.forEach((key, value) -> { if (!key.equals(OAuth2ParameterNames.GRANT_TYPE) && !key.equals(OAuth2ParameterNames.CLIENT_ID) && !key.equals(OAuth2ParameterNames.CODE)) { additionalParameters.put(key, value.get(0)); } }); return new CustomCodeGrantAuthenticationToken(code, clientPrincipal, additionalParameters); (3) } private static MultiValueMap<String, String> getParameters(HttpServletRequest request) { Map<String, String[]> parameterMap = request.getParameterMap(); MultiValueMap<String, String> parameters = new LinkedMultiValueMap<>(parameterMap.size()); parameterMap.forEach((key, values) -> { if (values.length > 0) { for (String value : values) { parameters.add(key, value); } } }); return parameters; } } Click on the ""Expand folded text"" icon in the code sample above to display the full example. 1 If the grant_type parameter is not urn:ietf:params:oauth:grant-type:custom_code , then return null , allowing another AuthenticationConverter to process the token request. 2 The code parameter contains the authorization grant. 3 Return an instance of CustomCodeGrantAuthenticationToken , which is processed by CustomCodeGrantAuthenticationProvider(#implement-authentication-provider) . Implement AuthenticationProvider: The AuthenticationProvider implementation is responsible for validating the authorization grant, and if valid and authorized, issues an access token. The following example shows a sample implementation of the AuthenticationProvider : AuthenticationProvider import org.springframework.security.authentication.AuthenticationProvider; import org.springframework.security.core.Authentication; import org.springframework.security.core.AuthenticationException; import org.springframework.security.oauth2.core.ClaimAccessor; import org.springframework.security.oauth2.core.OAuth2AccessToken; import org.springframework.security.oauth2.core.OAuth2AuthenticationException; import org.springframework.security.oauth2.core.OAuth2Error; import org.springframework.security.oauth2.core.OAuth2ErrorCodes; import org.springframework.security.oauth2.core.OAuth2Token; import org.springframework.security.oauth2.server.authorization.OAuth2Authorization; import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationService; import org.springframework.security.oauth2.server.authorization.OAuth2TokenType; import org.springframework.security.oauth2.server.authorization.authentication.OAuth2AccessTokenAuthenticationToken; import org.springframework.security.oauth2.server.authorization.authentication.OAuth2ClientAuthenticationToken; import org.springframework.security.oauth2.server.authorization.client.RegisteredClient; import org.springframework.security.oauth2.server.authorization.context.AuthorizationServerContextHolder; import org.springframework.security.oauth2.server.authorization.token.DefaultOAuth2TokenContext; import org.springframework.security.oauth2.server.authorization.token.OAuth2TokenContext; import org.springframework.security.oauth2.server.authorization.token.OAuth2TokenGenerator; import org.springframework.util.Assert; public class CustomCodeGrantAuthenticationProvider implements AuthenticationProvider { private final OAuth2AuthorizationService authorizationService; private final OAuth2TokenGenerator<? extends OAuth2Token> tokenGenerator; public CustomCodeGrantAuthenticationProvider(OAuth2AuthorizationService authorizationService, OAuth2TokenGenerator<? extends OAuth2Token> tokenGenerator) { Assert.notNull(authorizationService, ""authorizationService cannot be null""); Assert.notNull(tokenGenerator, ""tokenGenerator cannot be null""); this.authorizationService = authorizationService; this.tokenGenerator = tokenGenerator; } @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { CustomCodeGrantAuthenticationToken customCodeGrantAuthentication = (CustomCodeGrantAuthenticationToken) authentication; // Ensure the client is authenticated OAuth2ClientAuthenticationToken clientPrincipal = getAuthenticatedClientElseThrowInvalidClient(customCodeGrantAuthentication); RegisteredClient registeredClient = clientPrincipal.getRegisteredClient(); // Ensure the client is configured to use this authorization grant type if (!registeredClient.getAuthorizationGrantTypes().contains(customCodeGrantAuthentication.getGrantType())) { throw new OAuth2AuthenticationException(OAuth2ErrorCodes.UNAUTHORIZED_CLIENT); } // TODO Validate the code parameter // Generate the access token OAuth2TokenContext tokenContext = DefaultOAuth2TokenContext.builder() .registeredClient(registeredClient) .principal(clientPrincipal) .authorizationServerContext(AuthorizationServerContextHolder.getContext()) .tokenType(OAuth2TokenType.ACCESS_TOKEN) .authorizationGrantType(customCodeGrantAuthentication.getGrantType()) .authorizationGrant(customCodeGrantAuthentication) .build(); OAuth2Token generatedAccessToken = this.tokenGenerator.generate(tokenContext); if (generatedAccessToken == null) { OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR, ""The token generator failed to generate the access token."", null); throw new OAuth2AuthenticationException(error); } OAuth2AccessToken accessToken = new OAuth2AccessToken(OAuth2AccessToken.TokenType.BEARER, generatedAccessToken.getTokenValue(), generatedAccessToken.getIssuedAt(), generatedAccessToken.getExpiresAt(), null); // Initialize the OAuth2Authorization OAuth2Authorization.Builder authorizationBuilder = OAuth2Authorization.withRegisteredClient(registeredClient) .principalName(clientPrincipal.getName()) .authorizationGrantType(customCodeGrantAuthentication.getGrantType()); if (generatedAccessToken instanceof ClaimAccessor) { authorizationBuilder.token(accessToken, (metadata) -> metadata.put( OAuth2Authorization.Token.CLAIMS_METADATA_NAME, ((ClaimAccessor) generatedAccessToken).getClaims()) ); } else { authorizationBuilder.accessToken(accessToken); } OAuth2Authorization authorization = authorizationBuilder.build(); // Save the OAuth2Authorization this.authorizationService.save(authorization); return new OAuth2AccessTokenAuthenticationToken(registeredClient, clientPrincipal, accessToken); } @Override public boolean supports(Class<?> authentication) { return CustomCodeGrantAuthenticationToken.class.isAssignableFrom(authentication); } private static OAuth2ClientAuthenticationToken getAuthenticatedClientElseThrowInvalidClient(Authentication authentication) { OAuth2ClientAuthenticationToken clientPrincipal = null; if (OAuth2ClientAuthenticationToken.class.isAssignableFrom(authentication.getPrincipal().getClass())) { clientPrincipal = (OAuth2ClientAuthenticationToken) authentication.getPrincipal(); } if (clientPrincipal != null && clientPrincipal.isAuthenticated()) { return clientPrincipal; } throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_CLIENT); } } CustomCodeGrantAuthenticationProvider processes CustomCodeGrantAuthenticationToken , which is created by CustomCodeGrantAuthenticationConverter(#implement-authentication-converter) . Configure OAuth2 Token Endpoint: The following example shows how to configure the OAuth2 Token endpoint(../protocol-endpoints.html#oauth2-token-endpoint) with the AuthenticationConverter and AuthenticationProvider : SecurityConfig import java.util.UUID; import com.nimbusds.jose.jwk.source.JWKSource; import com.nimbusds.jose.proc.SecurityContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.oauth2.core.AuthorizationGrantType; import org.springframework.security.oauth2.core.ClientAuthenticationMethod; import org.springframework.security.oauth2.jwt.NimbusJwtEncoder; import org.springframework.security.oauth2.server.authorization.InMemoryOAuth2AuthorizationService; import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationService; import org.springframework.security.oauth2.server.authorization.client.InMemoryRegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.client.RegisteredClient; import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configurers.OAuth2AuthorizationServerConfigurer; import org.springframework.security.oauth2.server.authorization.token.DelegatingOAuth2TokenGenerator; import org.springframework.security.oauth2.server.authorization.token.JwtGenerator; import org.springframework.security.oauth2.server.authorization.token.OAuth2AccessTokenGenerator; import org.springframework.security.oauth2.server.authorization.token.OAuth2RefreshTokenGenerator; import org.springframework.security.oauth2.server.authorization.token.OAuth2TokenGenerator; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.util.matcher.RequestMatcher; @Configuration @EnableWebSecurity public class SecurityConfig { @Bean SecurityFilterChain authorizationServerSecurityFilterChain( HttpSecurity http, OAuth2AuthorizationService authorizationService, OAuth2TokenGenerator<?> tokenGenerator) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); authorizationServerConfigurer .tokenEndpoint(tokenEndpoint -> tokenEndpoint .accessTokenRequestConverter( (1) new CustomCodeGrantAuthenticationConverter()) .authenticationProvider( (2) new CustomCodeGrantAuthenticationProvider( authorizationService, tokenGenerator))); RequestMatcher endpointsMatcher = authorizationServerConfigurer.getEndpointsMatcher(); http .securityMatcher(endpointsMatcher) .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .csrf(csrf -> csrf.ignoringRequestMatchers(endpointsMatcher)) .apply(authorizationServerConfigurer); return http.build(); } @Bean RegisteredClientRepository registeredClientRepository() { RegisteredClient messagingClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(""messaging-client"") .clientSecret(""{noop}secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(new AuthorizationGrantType(""urn:ietf:params:oauth:grant-type:custom_code"")) .scope(""message.read"") .scope(""message.write"") .build(); return new InMemoryRegisteredClientRepository(messagingClient); } @Bean OAuth2AuthorizationService authorizationService() { return new InMemoryOAuth2AuthorizationService(); } @Bean OAuth2TokenGenerator<?> tokenGenerator(JWKSource<SecurityContext> jwkSource) { JwtGenerator jwtGenerator = new JwtGenerator(new NimbusJwtEncoder(jwkSource)); OAuth2AccessTokenGenerator accessTokenGenerator = new OAuth2AccessTokenGenerator(); OAuth2RefreshTokenGenerator refreshTokenGenerator = new OAuth2RefreshTokenGenerator(); return new DelegatingOAuth2TokenGenerator( jwtGenerator, accessTokenGenerator, refreshTokenGenerator); } } 1 Add the AuthenticationConverter to the OAuth2 Token endpoint configuration. 2 Add the AuthenticationProvider to the OAuth2 Token endpoint configuration. Request the Access Token: The client can request the access token by making the following (authenticated) request to the OAuth2 Token endpoint: POST /oauth2/token HTTP/1.1 Authorization: Basic bWVzc2FnaW5nLWNsaWVudDpzZWNyZXQ= Content-Type: application/x-www-form-urlencoded grant_type=urn:ietf:params:oauth:grant-type:custom_code&code=7QR49T1W3"
"https://docs.spring.io/spring-authorization-server/reference/1.3/guides/how-to-multitenancy.html","How-to: Implement Multitenancy: This guide shows how to customize Spring Authorization Server to support multiple issuers per host in a multi-tenant hosting configuration. The purpose of this guide is to demonstrate a general pattern for building multi-tenant capable components for Spring Authorization Server, which can also be applied to other components to suit your needs. Define the tenant identifier(#multi-tenant-define-tenant-identifier) Enable multiple issuers(#multi-tenant-enable-multiple-issuers) Create a component registry(#multi-tenant-create-component-registry) Create multi-tenant components(#multi-tenant-create-components) Add tenants dynamically(#multi-tenant-add-tenants-dynamically) Define the tenant identifier: The OpenID Connect 1.0 Provider Configuration Endpoint(../protocol-endpoints.html#oidc-provider-configuration-endpoint) and OAuth2 Authorization Server Metadata Endpoint(../protocol-endpoints.html#oauth2-authorization-server-metadata-endpoint) allow for path components in the issuer identifier value, which effectively enables supporting multiple issuers per host. For example, an OpenID Provider Configuration Request(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationRequest) ""http://localhost:9000/issuer1/.well-known/openid-configuration"" or an Authorization Server Metadata Request(https://datatracker.ietf.org/doc/html/rfc8414#section-3.1) ""http://localhost:9000/.well-known/oauth-authorization-server/issuer1"" would return the following configuration metadata: { ""issuer"": ""http://localhost:9000/issuer1"", ""authorization_endpoint"": ""http://localhost:9000/issuer1/oauth2/authorize"", ""token_endpoint"": ""http://localhost:9000/issuer1/oauth2/token"", ""jwks_uri"": ""http://localhost:9000/issuer1/oauth2/jwks"", ""revocation_endpoint"": ""http://localhost:9000/issuer1/oauth2/revoke"", ""introspection_endpoint"": ""http://localhost:9000/issuer1/oauth2/introspect"", ... } The base URL of the Protocol Endpoints(../protocol-endpoints.html) is the issuer identifier value. Essentially, an issuer identifier with a path component represents the ""tenant identifier"" . Enable multiple issuers: Support for using multiple issuers per host is disabled by default. To enable, add the following configuration: AuthorizationServerSettingsConfig import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.oauth2.server.authorization.settings.AuthorizationServerSettings; @Configuration(proxyBeanMethods = false) public class AuthorizationServerSettingsConfig { @Bean public AuthorizationServerSettings authorizationServerSettings() { return AuthorizationServerSettings.builder() .multipleIssuersAllowed(true) (1) .build(); } } 1 Set to true to allow usage of multiple issuers per host. Create a component registry: We start by building a simple registry for managing the concrete components for each tenant. The registry contains the logic for retrieving a concrete implementation of a particular class using the issuer identifier value. We will use the following class in each of the delegating implementations below: TenantPerIssuerComponentRegistry import java.util.Map; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; import org.springframework.lang.Nullable; import org.springframework.security.oauth2.server.authorization.context.AuthorizationServerContext; import org.springframework.security.oauth2.server.authorization.context.AuthorizationServerContextHolder; import org.springframework.stereotype.Component; import org.springframework.util.Assert; @Component public class TenantPerIssuerComponentRegistry { private final ConcurrentMap<String, Map<Class<?>, Object>> registry = new ConcurrentHashMap<>(); public <T> void register(String tenantId, Class<T> componentClass, T component) { (1) Assert.hasText(tenantId, ""tenantId cannot be empty""); Assert.notNull(componentClass, ""componentClass cannot be null""); Assert.notNull(component, ""component cannot be null""); Map<Class<?>, Object> components = this.registry.computeIfAbsent(tenantId, (key) -> new ConcurrentHashMap<>()); components.put(componentClass, component); } @Nullable public <T> T get(Class<T> componentClass) { AuthorizationServerContext context = AuthorizationServerContextHolder.getContext(); if (context == null || context.getIssuer() == null) { return null; } for (Map.Entry<String, Map<Class<?>, Object>> entry : this.registry.entrySet()) { if (context.getIssuer().endsWith(entry.getKey())) { return componentClass.cast(entry.getValue().get(componentClass)); } } return null; } } 1 Component registration implicitly enables an allowlist of approved issuers that can be used. This registry is designed to allow components to be easily registered at startup to support adding tenants statically, but also supports adding tenants dynamically(#multi-tenant-add-tenants-dynamically) at runtime. Create multi-tenant components: The components that require multi-tenant capability are: RegisteredClientRepository(#multi-tenant-registered-client-repository) OAuth2AuthorizationService(#multi-tenant-oauth2-authorization-service) OAuth2AuthorizationConsentService(#multi-tenant-oauth2-authorization-consent-service) JWKSource<SecurityContext>(#multi-tenant-jwk-source) For each of these components, an implementation of a composite can be provided that delegates to the concrete component associated to the ""requested"" issuer identifier. Let’s step through a scenario of how to customize Spring Authorization Server to support 2x tenants for each multi-tenant capable component. Multi-tenant RegisteredClientRepository: The following example shows a sample implementation of a RegisteredClientRepository(../core-model-components.html#registered-client-repository) that is composed of 2x JdbcRegisteredClientRepository instances, where each instance is mapped to an issuer identifier: RegisteredClientRepositoryConfig import java.util.UUID; import javax.sql.DataSource; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.security.oauth2.core.AuthorizationGrantType; import org.springframework.security.oauth2.core.ClientAuthenticationMethod; import org.springframework.security.oauth2.server.authorization.client.JdbcRegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.client.RegisteredClient; import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository; import org.springframework.util.Assert; @Configuration(proxyBeanMethods = false) public class RegisteredClientRepositoryConfig { @Bean public RegisteredClientRepository registeredClientRepository( @Qualifier(""issuer1-data-source"") DataSource issuer1DataSource, @Qualifier(""issuer2-data-source"") DataSource issuer2DataSource, TenantPerIssuerComponentRegistry componentRegistry) { JdbcRegisteredClientRepository issuer1RegisteredClientRepository = new JdbcRegisteredClientRepository(new JdbcTemplate(issuer1DataSource)); (1) issuer1RegisteredClientRepository.save( RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(""client-1"") .clientSecret(""{noop}secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) .scope(""scope-1"") .build() ); JdbcRegisteredClientRepository issuer2RegisteredClientRepository = new JdbcRegisteredClientRepository(new JdbcTemplate(issuer2DataSource)); (2) issuer2RegisteredClientRepository.save( RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(""client-2"") .clientSecret(""{noop}secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) .scope(""scope-2"") .build() ); componentRegistry.register(""issuer1"", RegisteredClientRepository.class, issuer1RegisteredClientRepository); componentRegistry.register(""issuer2"", RegisteredClientRepository.class, issuer2RegisteredClientRepository); return new DelegatingRegisteredClientRepository(componentRegistry); } private static class DelegatingRegisteredClientRepository implements RegisteredClientRepository { (3) private final TenantPerIssuerComponentRegistry componentRegistry; private DelegatingRegisteredClientRepository(TenantPerIssuerComponentRegistry componentRegistry) { this.componentRegistry = componentRegistry; } @Override public void save(RegisteredClient registeredClient) { getRegisteredClientRepository().save(registeredClient); } @Override public RegisteredClient findById(String id) { return getRegisteredClientRepository().findById(id); } @Override public RegisteredClient findByClientId(String clientId) { return getRegisteredClientRepository().findByClientId(clientId); } private RegisteredClientRepository getRegisteredClientRepository() { RegisteredClientRepository registeredClientRepository = this.componentRegistry.get(RegisteredClientRepository.class); (4) Assert.state(registeredClientRepository != null, ""RegisteredClientRepository not found for \""requested\"" issuer identifier.""); (5) return registeredClientRepository; } } } Click on the ""Expand folded text"" icon in the code sample above to display the full example. 1 A JdbcRegisteredClientRepository instance mapped to issuer identifier issuer1 and using a dedicated DataSource . 2 A JdbcRegisteredClientRepository instance mapped to issuer identifier issuer2 and using a dedicated DataSource . 3 A composite implementation of a RegisteredClientRepository that delegates to a JdbcRegisteredClientRepository mapped to the ""requested"" issuer identifier. 4 Obtain the JdbcRegisteredClientRepository that is mapped to the ""requested"" issuer identifier indicated by AuthorizationServerContext.getIssuer() . 5 If unable to find JdbcRegisteredClientRepository , then error since the ""requested"" issuer identifier is not in the allowlist of approved issuers. Explicitly configuring the issuer identifier via AuthorizationServerSettings.builder().issuer(""http://localhost:9000"") forces to a single-tenant configuration. Avoid explicitly configuring the issuer identifier when using a multi-tenant hosting configuration. In the preceding example, each of the JdbcRegisteredClientRepository instances are configured with a JdbcTemplate and associated DataSource . This is important in a multi-tenant configuration as a primary requirement is to have the ability to isolate the data from each tenant. Configuring a dedicated DataSource for each component instance provides the flexibility to isolate the data in its own schema within the same database instance or alternatively isolate the data in a separate database instance altogether. The following example shows a sample configuration of 2x DataSource @Bean (one for each tenant) that are used by the multi-tenant capable components: DataSourceConfig import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.jdbc.datasource.embedded.EmbeddedDatabase; import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder; import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType; @Configuration(proxyBeanMethods = false) public class DataSourceConfig { @Bean(""issuer1-data-source"") public EmbeddedDatabase issuer1DataSource() { return new EmbeddedDatabaseBuilder() .setName(""issuer1-db"") (1) .setType(EmbeddedDatabaseType.H2) .setScriptEncoding(""UTF-8"") .addScript(""org/springframework/security/oauth2/server/authorization/oauth2-authorization-schema.sql"") .addScript(""org/springframework/security/oauth2/server/authorization/oauth2-authorization-consent-schema.sql"") .addScript(""org/springframework/security/oauth2/server/authorization/client/oauth2-registered-client-schema.sql"") .build(); } @Bean(""issuer2-data-source"") public EmbeddedDatabase issuer2DataSource() { return new EmbeddedDatabaseBuilder() .setName(""issuer2-db"") (2) .setType(EmbeddedDatabaseType.H2) .setScriptEncoding(""UTF-8"") .addScript(""org/springframework/security/oauth2/server/authorization/oauth2-authorization-schema.sql"") .addScript(""org/springframework/security/oauth2/server/authorization/oauth2-authorization-consent-schema.sql"") .addScript(""org/springframework/security/oauth2/server/authorization/client/oauth2-registered-client-schema.sql"") .build(); } } 1 Use a separate H2 database instance using issuer1-db as the name. 2 Use a separate H2 database instance using issuer2-db as the name. Multi-tenant OAuth2AuthorizationService: The following example shows a sample implementation of an OAuth2AuthorizationService(../core-model-components.html#oauth2-authorization-service) that is composed of 2x JdbcOAuth2AuthorizationService instances, where each instance is mapped to an issuer identifier: OAuth2AuthorizationServiceConfig import javax.sql.DataSource; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.security.oauth2.server.authorization.JdbcOAuth2AuthorizationService; import org.springframework.security.oauth2.server.authorization.OAuth2Authorization; import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationService; import org.springframework.security.oauth2.server.authorization.OAuth2TokenType; import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository; import org.springframework.util.Assert; @Configuration(proxyBeanMethods = false) public class OAuth2AuthorizationServiceConfig { @Bean public OAuth2AuthorizationService authorizationService( @Qualifier(""issuer1-data-source"") DataSource issuer1DataSource, @Qualifier(""issuer2-data-source"") DataSource issuer2DataSource, TenantPerIssuerComponentRegistry componentRegistry, RegisteredClientRepository registeredClientRepository) { componentRegistry.register(""issuer1"", OAuth2AuthorizationService.class, new JdbcOAuth2AuthorizationService( (1) new JdbcTemplate(issuer1DataSource), registeredClientRepository)); componentRegistry.register(""issuer2"", OAuth2AuthorizationService.class, new JdbcOAuth2AuthorizationService( (2) new JdbcTemplate(issuer2DataSource), registeredClientRepository)); return new DelegatingOAuth2AuthorizationService(componentRegistry); } private static class DelegatingOAuth2AuthorizationService implements OAuth2AuthorizationService { (3) private final TenantPerIssuerComponentRegistry componentRegistry; private DelegatingOAuth2AuthorizationService(TenantPerIssuerComponentRegistry componentRegistry) { this.componentRegistry = componentRegistry; } @Override public void save(OAuth2Authorization authorization) { getAuthorizationService().save(authorization); } @Override public void remove(OAuth2Authorization authorization) { getAuthorizationService().remove(authorization); } @Override public OAuth2Authorization findById(String id) { return getAuthorizationService().findById(id); } @Override public OAuth2Authorization findByToken(String token, OAuth2TokenType tokenType) { return getAuthorizationService().findByToken(token, tokenType); } private OAuth2AuthorizationService getAuthorizationService() { OAuth2AuthorizationService authorizationService = this.componentRegistry.get(OAuth2AuthorizationService.class); (4) Assert.state(authorizationService != null, ""OAuth2AuthorizationService not found for \""requested\"" issuer identifier.""); (5) return authorizationService; } } } 1 A JdbcOAuth2AuthorizationService instance mapped to issuer identifier issuer1 and using a dedicated DataSource . 2 A JdbcOAuth2AuthorizationService instance mapped to issuer identifier issuer2 and using a dedicated DataSource . 3 A composite implementation of an OAuth2AuthorizationService that delegates to a JdbcOAuth2AuthorizationService mapped to the ""requested"" issuer identifier. 4 Obtain the JdbcOAuth2AuthorizationService that is mapped to the ""requested"" issuer identifier indicated by AuthorizationServerContext.getIssuer() . 5 If unable to find JdbcOAuth2AuthorizationService , then error since the ""requested"" issuer identifier is not in the allowlist of approved issuers. Multi-tenant OAuth2AuthorizationConsentService: The following example shows a sample implementation of an OAuth2AuthorizationConsentService(../core-model-components.html#oauth2-authorization-consent-service) that is composed of 2x JdbcOAuth2AuthorizationConsentService instances, where each instance is mapped to an issuer identifier: OAuth2AuthorizationConsentServiceConfig import javax.sql.DataSource; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.security.oauth2.server.authorization.JdbcOAuth2AuthorizationConsentService; import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationConsent; import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationConsentService; import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository; import org.springframework.util.Assert; @Configuration(proxyBeanMethods = false) public class OAuth2AuthorizationConsentServiceConfig { @Bean public OAuth2AuthorizationConsentService authorizationConsentService( @Qualifier(""issuer1-data-source"") DataSource issuer1DataSource, @Qualifier(""issuer2-data-source"") DataSource issuer2DataSource, TenantPerIssuerComponentRegistry componentRegistry, RegisteredClientRepository registeredClientRepository) { componentRegistry.register(""issuer1"", OAuth2AuthorizationConsentService.class, new JdbcOAuth2AuthorizationConsentService( (1) new JdbcTemplate(issuer1DataSource), registeredClientRepository)); componentRegistry.register(""issuer2"", OAuth2AuthorizationConsentService.class, new JdbcOAuth2AuthorizationConsentService( (2) new JdbcTemplate(issuer2DataSource), registeredClientRepository)); return new DelegatingOAuth2AuthorizationConsentService(componentRegistry); } private static class DelegatingOAuth2AuthorizationConsentService implements OAuth2AuthorizationConsentService { (3) private final TenantPerIssuerComponentRegistry componentRegistry; private DelegatingOAuth2AuthorizationConsentService(TenantPerIssuerComponentRegistry componentRegistry) { this.componentRegistry = componentRegistry; } @Override public void save(OAuth2AuthorizationConsent authorizationConsent) { getAuthorizationConsentService().save(authorizationConsent); } @Override public void remove(OAuth2AuthorizationConsent authorizationConsent) { getAuthorizationConsentService().remove(authorizationConsent); } @Override public OAuth2AuthorizationConsent findById(String registeredClientId, String principalName) { return getAuthorizationConsentService().findById(registeredClientId, principalName); } private OAuth2AuthorizationConsentService getAuthorizationConsentService() { OAuth2AuthorizationConsentService authorizationConsentService = this.componentRegistry.get(OAuth2AuthorizationConsentService.class); (4) Assert.state(authorizationConsentService != null, ""OAuth2AuthorizationConsentService not found for \""requested\"" issuer identifier.""); (5) return authorizationConsentService; } } } 1 A JdbcOAuth2AuthorizationConsentService instance mapped to issuer identifier issuer1 and using a dedicated DataSource . 2 A JdbcOAuth2AuthorizationConsentService instance mapped to issuer identifier issuer2 and using a dedicated DataSource . 3 A composite implementation of an OAuth2AuthorizationConsentService that delegates to a JdbcOAuth2AuthorizationConsentService mapped to the ""requested"" issuer identifier. 4 Obtain the JdbcOAuth2AuthorizationConsentService that is mapped to the ""requested"" issuer identifier indicated by AuthorizationServerContext.getIssuer() . 5 If unable to find JdbcOAuth2AuthorizationConsentService , then error since the ""requested"" issuer identifier is not in the allowlist of approved issuers. Multi-tenant JWKSource: And finally, the following example shows a sample implementation of a JWKSource<SecurityContext> that is composed of 2x JWKSet instances, where each instance is mapped to an issuer identifier: JWKSourceConfig import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.util.List; import java.util.UUID; import com.nimbusds.jose.KeySourceException; import com.nimbusds.jose.jwk.JWK; import com.nimbusds.jose.jwk.JWKSelector; import com.nimbusds.jose.jwk.JWKSet; import com.nimbusds.jose.jwk.RSAKey; import com.nimbusds.jose.jwk.source.JWKSource; import com.nimbusds.jose.proc.SecurityContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.util.Assert; @Configuration(proxyBeanMethods = false) public class JWKSourceConfig { @Bean public JWKSource<SecurityContext> jwkSource(TenantPerIssuerComponentRegistry componentRegistry) { componentRegistry.register(""issuer1"", JWKSet.class, new JWKSet(generateRSAJwk())); (1) componentRegistry.register(""issuer2"", JWKSet.class, new JWKSet(generateRSAJwk())); (2) return new DelegatingJWKSource(componentRegistry); } private static RSAKey generateRSAJwk() { KeyPair keyPair; try { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA""); keyPairGenerator.initialize(2048); keyPair = keyPairGenerator.generateKeyPair(); } catch (Exception ex) { throw new IllegalStateException(ex); } RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); return new RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build(); } private static class DelegatingJWKSource implements JWKSource<SecurityContext> { (3) private final TenantPerIssuerComponentRegistry componentRegistry; private DelegatingJWKSource(TenantPerIssuerComponentRegistry componentRegistry) { this.componentRegistry = componentRegistry; } @Override public List<JWK> get(JWKSelector jwkSelector, SecurityContext context) throws KeySourceException { return jwkSelector.select(getJwkSet()); } private JWKSet getJwkSet() { JWKSet jwkSet = this.componentRegistry.get(JWKSet.class); (4) Assert.state(jwkSet != null, ""JWKSet not found for \""requested\"" issuer identifier.""); (5) return jwkSet; } } } 1 A JWKSet instance mapped to issuer identifier issuer1 . 2 A JWKSet instance mapped to issuer identifier issuer2 . 3 A composite implementation of an JWKSource<SecurityContext> that uses the JWKSet mapped to the ""requested"" issuer identifier. 4 Obtain the JWKSet that is mapped to the ""requested"" issuer identifier indicated by AuthorizationServerContext.getIssuer() . 5 If unable to find JWKSet , then error since the ""requested"" issuer identifier is not in the allowlist of approved issuers. Add Tenants Dynamically: If the number of tenants is dynamic and can change at runtime, defining each DataSource as a @Bean may not be feasible. In this case, the DataSource and corresponding components can be registered through other means at application startup and/or runtime. The following example shows a Spring @Service capable of adding tenants dynamically: TenantService import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.util.UUID; import com.nimbusds.jose.jwk.JWKSet; import com.nimbusds.jose.jwk.RSAKey; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.datasource.embedded.EmbeddedDatabase; import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder; import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType; import org.springframework.security.oauth2.server.authorization.JdbcOAuth2AuthorizationConsentService; import org.springframework.security.oauth2.server.authorization.JdbcOAuth2AuthorizationService; import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationConsentService; import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationService; import org.springframework.security.oauth2.server.authorization.client.JdbcRegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository; import org.springframework.stereotype.Service; @Service public class TenantService { private final TenantPerIssuerComponentRegistry componentRegistry; public TenantService(TenantPerIssuerComponentRegistry componentRegistry) { this.componentRegistry = componentRegistry; } public void createTenant(String tenantId) { EmbeddedDatabase dataSource = createDataSource(tenantId); JdbcTemplate jdbcOperations = new JdbcTemplate(dataSource); RegisteredClientRepository registeredClientRepository = new JdbcRegisteredClientRepository(jdbcOperations); this.componentRegistry.register(tenantId, RegisteredClientRepository.class, registeredClientRepository); OAuth2AuthorizationService authorizationService = new JdbcOAuth2AuthorizationService(jdbcOperations, registeredClientRepository); this.componentRegistry.register(tenantId, OAuth2AuthorizationService.class, authorizationService); OAuth2AuthorizationConsentService authorizationConsentService = new JdbcOAuth2AuthorizationConsentService(jdbcOperations, registeredClientRepository); this.componentRegistry.register(tenantId, OAuth2AuthorizationConsentService.class, authorizationConsentService); JWKSet jwkSet = new JWKSet(generateRSAJwk()); this.componentRegistry.register(tenantId, JWKSet.class, jwkSet); } private EmbeddedDatabase createDataSource(String tenantId) { return new EmbeddedDatabaseBuilder() .setName(tenantId) .setType(EmbeddedDatabaseType.H2) .setScriptEncoding(""UTF-8"") .addScript(""org/springframework/security/oauth2/server/authorization/oauth2-authorization-schema.sql"") .addScript(""org/springframework/security/oauth2/server/authorization/oauth2-authorization-consent-schema.sql"") .addScript(""org/springframework/security/oauth2/server/authorization/client/oauth2-registered-client-schema.sql"") .build(); } private static RSAKey generateRSAJwk() { KeyPair keyPair; try { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA""); keyPairGenerator.initialize(2048); keyPair = keyPairGenerator.generateKeyPair(); } catch (Exception ex) { throw new IllegalStateException(ex); } RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); return new RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build(); } }"
"https://docs.spring.io/spring-authorization-server/reference/1.3/guides/how-to-userinfo.html","How-to: Customize the OpenID Connect 1.0 UserInfo response: This guide shows how to customize the UserInfo endpoint(../protocol-endpoints.html#oidc-user-info-endpoint) of the Spring Authorization Server(../index.html) . The purpose of this guide is to demonstrate how to enable the endpoint and use the available customization options to produce a custom response. Enable the User Info Endpoint(#enable-user-info) Customize the User Info response(#customize-user-info) Enable the User Info Endpoint: The OpenID Connect 1.0 UserInfo endpoint(../protocol-endpoints.html#oidc-user-info-endpoint) is an OAuth2 protected resource, which REQUIRES an access token to be sent as a bearer token in the UserInfo request(https://openid.net/specs/openid-connect-core-1_0.html#UserInfoRequest) . The Access Token obtained from an OpenID Connect Authentication Request MUST be sent as a Bearer Token, per Section 2 of OAuth 2.0 Bearer Token Usage(https://openid.net/specs/openid-connect-core-1_0.html#RFC6750) [RFC6750]. Before customizing the response, you need to enable the UserInfo endpoint. The following listing shows how to enable the OAuth2 resource server configuration(https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html) . import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.util.UUID; import com.nimbusds.jose.jwk.JWKSet; import com.nimbusds.jose.jwk.RSAKey; import com.nimbusds.jose.jwk.source.ImmutableJWKSet; import com.nimbusds.jose.jwk.source.JWKSource; import com.nimbusds.jose.proc.SecurityContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.annotation.Order; import org.springframework.http.MediaType; import org.springframework.security.config.Customizer; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.oauth2.core.AuthorizationGrantType; import org.springframework.security.oauth2.core.ClientAuthenticationMethod; import org.springframework.security.oauth2.core.oidc.OidcScopes; import org.springframework.security.oauth2.jwt.JwtDecoder; import org.springframework.security.oauth2.server.authorization.client.InMemoryRegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.client.RegisteredClient; import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configuration.OAuth2AuthorizationServerConfiguration; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configurers.OAuth2AuthorizationServerConfigurer; import org.springframework.security.oauth2.server.authorization.settings.AuthorizationServerSettings; import org.springframework.security.oauth2.server.authorization.settings.ClientSettings; import org.springframework.security.provisioning.InMemoryUserDetailsManager; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint; import org.springframework.security.web.util.matcher.MediaTypeRequestMatcher; @Configuration(proxyBeanMethods = false) @EnableWebSecurity public class EnableUserInfoSecurityConfig { @Bean (1) @Order(1) public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); http.getConfigurer(OAuth2AuthorizationServerConfigurer.class) .oidc(Customizer.withDefaults()); // Enable OpenID Connect 1.0 http .oauth2ResourceServer((oauth2) -> oauth2.jwt(Customizer.withDefaults())) (2) .exceptionHandling((exceptions) -> exceptions .defaultAuthenticationEntryPointFor( new LoginUrlAuthenticationEntryPoint(""/login""), new MediaTypeRequestMatcher(MediaType.TEXT_HTML) ) ); return http.build(); } @Bean @Order(2) public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) .formLogin(Customizer.withDefaults()); return http.build(); } @Bean (3) public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) { return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource); } @Bean public UserDetailsService userDetailsService() { UserDetails userDetails = User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .roles(""USER"") .build(); return new InMemoryUserDetailsManager(userDetails); } @Bean public RegisteredClientRepository registeredClientRepository() { RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(""messaging-client"") .clientSecret(""{noop}secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) .redirectUri(""http://127.0.0.1:8080/login/oauth2/code/messaging-client-oidc"") .redirectUri(""http://127.0.0.1:8080/authorized"") .scope(OidcScopes.OPENID) .scope(OidcScopes.ADDRESS) .scope(OidcScopes.EMAIL) .scope(OidcScopes.PHONE) .scope(OidcScopes.PROFILE) .scope(""message.read"") .scope(""message.write"") .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build()) .build(); return new InMemoryRegisteredClientRepository(registeredClient); } @Bean public JWKSource<SecurityContext> jwkSource() { KeyPair keyPair = generateRsaKey(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); RSAKey rsaKey = new RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build(); JWKSet jwkSet = new JWKSet(rsaKey); return new ImmutableJWKSet<>(jwkSet); } private static KeyPair generateRsaKey() { KeyPair keyPair; try { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA""); keyPairGenerator.initialize(2048); keyPair = keyPairGenerator.generateKeyPair(); } catch (Exception ex) { throw new IllegalStateException(ex); } return keyPair; } @Bean public AuthorizationServerSettings authorizationServerSettings() { return AuthorizationServerSettings.builder().build(); } } Click on the ""Expand folded text"" icon in the code sample above to display the full example. This configuration provides the following: 1 A Spring Security filter chain for the Protocol Endpoints(../protocol-endpoints.html) . 2 Resource server support that allows User Info requests to be authenticated with access tokens. 3 An instance of JwtDecoder used to validate access tokens. Customize the User Info response: The following sections describe some options for customizing the user info response. Customize the ID Token(#customize-id-token) Customize the User Info Mapper(#customize-user-info-mapper) Customize the ID Token: By default, the user info response is generated by using claims from the id_token that are returned with the token response(../protocol-endpoints.html#oauth2-token-endpoint) . Using the default strategy, standard claims(https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) are returned only with the user info response based on the requested scopes(https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) during authorization. The preferred way to customize the user info response is to add standard claims to the id_token . The following listing shows how to add claims to the id_token . import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.oauth2.core.oidc.OidcUserInfo; import org.springframework.security.oauth2.core.oidc.endpoint.OidcParameterNames; import org.springframework.security.oauth2.server.authorization.token.JwtEncodingContext; import org.springframework.security.oauth2.server.authorization.token.OAuth2TokenCustomizer; @Configuration public class IdTokenCustomizerConfig { @Bean (1) public OAuth2TokenCustomizer<JwtEncodingContext> tokenCustomizer( OidcUserInfoService userInfoService) { return (context) -> { if (OidcParameterNames.ID_TOKEN.equals(context.getTokenType().getValue())) { OidcUserInfo userInfo = userInfoService.loadUser( (2) context.getPrincipal().getName()); context.getClaims().claims(claims -> claims.putAll(userInfo.getClaims())); } }; } } This configuration provides the following: 1 An instance of OAuth2TokenCustomizer(../core-model-components.html#oauth2-token-customizer) for customizing the id_token . 2 A custom service used to obtain user info in a domain-specific way. The following listing shows a custom service for looking up user info in a domain-specific way: import java.util.Collections; import java.util.HashMap; import java.util.Map; import org.springframework.security.oauth2.core.oidc.OidcUserInfo; import org.springframework.stereotype.Service; /** * Example service to perform lookup of user info for customizing an {@code id_token}. */ @Service public class OidcUserInfoService { private final UserInfoRepository userInfoRepository = new UserInfoRepository(); public OidcUserInfo loadUser(String username) { return new OidcUserInfo(this.userInfoRepository.findByUsername(username)); } static class UserInfoRepository { private final Map<String, Map<String, Object>> userInfo = new HashMap<>(); public UserInfoRepository() { this.userInfo.put(""user1"", createUser(""user1"")); this.userInfo.put(""user2"", createUser(""user2"")); } public Map<String, Object> findByUsername(String username) { return this.userInfo.get(username); } private static Map<String, Object> createUser(String username) { return OidcUserInfo.builder() .subject(username) .name(""First Last"") .givenName(""First"") .familyName(""Last"") .middleName(""Middle"") .nickname(""User"") .preferredUsername(username) .profile(""https://example.com/"" + username) .picture(""https://example.com/"" + username + "".jpg"") .website(""https://example.com"") .email(username + ""@example.com"") .emailVerified(true) .gender(""female"") .birthdate(""1970-01-01"") .zoneinfo(""Europe/Paris"") .locale(""en-US"") .phoneNumber(""+1 (604) 555-1234;ext=5678"") .phoneNumberVerified(false) .claim(""address"", Collections.singletonMap(""formatted"", ""Champ de Mars\n5 Av. Anatole France\n75007 Paris\nFrance"")) .updatedAt(""1970-01-01T00:00:00Z"") .build() .getClaims(); } } } Customize the User Info Mapper: To fully customize the user info response, you can provide a custom user info mapper capable of generating the object used to render the response, which is an instance of the OidcUserInfo class from Spring Security. The mapper implementation receives an instance of OidcUserInfoAuthenticationContext with information about the current request, including the OAuth2Authorization(../core-model-components.html#oauth2-authorization) . The following listing shows how to use the customization option that is available while working directly with the OAuth2AuthorizationServerConfigurer . import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.util.UUID; import java.util.function.Function; import com.nimbusds.jose.jwk.JWKSet; import com.nimbusds.jose.jwk.RSAKey; import com.nimbusds.jose.jwk.source.ImmutableJWKSet; import com.nimbusds.jose.jwk.source.JWKSource; import com.nimbusds.jose.proc.SecurityContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.annotation.Order; import org.springframework.http.MediaType; import org.springframework.security.config.Customizer; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.oauth2.core.AuthorizationGrantType; import org.springframework.security.oauth2.core.ClientAuthenticationMethod; import org.springframework.security.oauth2.core.oidc.OidcScopes; import org.springframework.security.oauth2.core.oidc.OidcUserInfo; import org.springframework.security.oauth2.jwt.JwtDecoder; import org.springframework.security.oauth2.server.authorization.client.InMemoryRegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.client.RegisteredClient; import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configuration.OAuth2AuthorizationServerConfiguration; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configurers.OAuth2AuthorizationServerConfigurer; import org.springframework.security.oauth2.server.authorization.oidc.authentication.OidcUserInfoAuthenticationContext; import org.springframework.security.oauth2.server.authorization.oidc.authentication.OidcUserInfoAuthenticationToken; import org.springframework.security.oauth2.server.authorization.settings.AuthorizationServerSettings; import org.springframework.security.oauth2.server.authorization.settings.ClientSettings; import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken; import org.springframework.security.provisioning.InMemoryUserDetailsManager; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint; import org.springframework.security.web.util.matcher.MediaTypeRequestMatcher; import org.springframework.security.web.util.matcher.RequestMatcher; @Configuration(proxyBeanMethods = false) @EnableWebSecurity public class JwtUserInfoMapperSecurityConfig { @Bean (1) @Order(1) public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = new OAuth2AuthorizationServerConfigurer(); RequestMatcher endpointsMatcher = authorizationServerConfigurer .getEndpointsMatcher(); Function<OidcUserInfoAuthenticationContext, OidcUserInfo> userInfoMapper = (context) -> { (2) OidcUserInfoAuthenticationToken authentication = context.getAuthentication(); JwtAuthenticationToken principal = (JwtAuthenticationToken) authentication.getPrincipal(); return new OidcUserInfo(principal.getToken().getClaims()); }; authorizationServerConfigurer .oidc((oidc) -> oidc .userInfoEndpoint((userInfo) -> userInfo .userInfoMapper(userInfoMapper) (3) ) ); http .securityMatcher(endpointsMatcher) .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) .csrf(csrf -> csrf.ignoringRequestMatchers(endpointsMatcher)) .oauth2ResourceServer(resourceServer -> resourceServer .jwt(Customizer.withDefaults()) (4) ) .exceptionHandling((exceptions) -> exceptions .defaultAuthenticationEntryPointFor( new LoginUrlAuthenticationEntryPoint(""/login""), new MediaTypeRequestMatcher(MediaType.TEXT_HTML) ) ) .apply(authorizationServerConfigurer); (5) return http.build(); } @Bean @Order(2) public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) .formLogin(Customizer.withDefaults()); return http.build(); } @Bean public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) { return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource); } @Bean public UserDetailsService userDetailsService() { UserDetails userDetails = User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .roles(""USER"") .build(); return new InMemoryUserDetailsManager(userDetails); } @Bean public RegisteredClientRepository registeredClientRepository() { RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(""messaging-client"") .clientSecret(""{noop}secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) .redirectUri(""http://127.0.0.1:8080/login/oauth2/code/messaging-client-oidc"") .redirectUri(""http://127.0.0.1:8080/authorized"") .scope(OidcScopes.OPENID) .scope(""message.read"") .scope(""message.write"") .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build()) .build(); return new InMemoryRegisteredClientRepository(registeredClient); } @Bean public JWKSource<SecurityContext> jwkSource() { KeyPair keyPair = generateRsaKey(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); RSAKey rsaKey = new RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build(); JWKSet jwkSet = new JWKSet(rsaKey); return new ImmutableJWKSet<>(jwkSet); } private static KeyPair generateRsaKey() { KeyPair keyPair; try { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA""); keyPairGenerator.initialize(2048); keyPair = keyPairGenerator.generateKeyPair(); } catch (Exception ex) { throw new IllegalStateException(ex); } return keyPair; } @Bean public AuthorizationServerSettings authorizationServerSettings() { return AuthorizationServerSettings.builder().build(); } } This configuration maps claims from the access token (which is a JWT when using the Getting Started config(../getting-started.html#sample.gettingstarted) ) to populate the user info response and provides the following: 1 A Spring Security filter chain for the Protocol Endpoints(../protocol-endpoints.html) . 2 A user info mapper that maps claims in a domain-specific way. 3 An example showing the configuration option for customizing the user info mapper. 4 Resource server support that allows User Info requests to be authenticated with access tokens. 5 An example showing how to apply the OAuth2AuthorizationServerConfigurer to the Spring Security configuration. The user info mapper is not limited to mapping claims from a JWT, but this is a simple example that demonstrates the customization option. Similar to the example shown earlier(#customize-id-token) where we customize claims of the ID token, you can customize claims of the access token itself ahead of time, as in the following example: import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.oauth2.server.authorization.OAuth2TokenType; import org.springframework.security.oauth2.server.authorization.token.JwtEncodingContext; import org.springframework.security.oauth2.server.authorization.token.OAuth2TokenCustomizer; @Configuration public class JwtTokenCustomizerConfig { @Bean public OAuth2TokenCustomizer<JwtEncodingContext> tokenCustomizer() { return (context) -> { if (OAuth2TokenType.ACCESS_TOKEN.equals(context.getTokenType())) { context.getClaims().claims((claims) -> { claims.put(""claim-1"", ""value-1""); claims.put(""claim-2"", ""value-2""); }); } }; } } Whether you customize the user info response directly or use this example and customize the access token, you can look up information in a database, perform an LDAP query, make a request to another service, or use any other means of obtaining the information you want to be presented in the user info response."
"https://docs.spring.io/spring-authorization-server/reference/1.3/guides/how-to-jpa.html","How-to: Implement core services with JPA: This guide shows how to implement the core services(../core-model-components.html) of Spring Authorization Server(../index.html) with JPA. The purpose of this guide is to provide a starting point for implementing these services yourself, with the intention that you can make modifications to suit your needs. Define the data model(#define-data-model) Create JPA entities(#create-jpa-entities) Create Spring Data repositories(#create-spring-data-repositories) Implement core services(#implement-core-services) Define the data model: This guide provides a starting point for the data model and uses the simplest possible structure and data types. To come up with the initial schema, we begin by reviewing the domain objects(../core-model-components.html) used by the core services. Except for token, state, metadata, settings, and claims values, we use the JPA default column length of 255 for all columns. In reality, the length and even type of columns you use may need to be customized. You are encouraged to experiment and test before deploying to production. Client Schema(#client-schema) Authorization Schema(#authorization-schema) Authorization Consent Schema(#authorization-consent-schema) Client Schema: The RegisteredClient(../core-model-components.html#registered-client) domain object contains a few multi-valued fields and some settings fields that require storing arbitrary key/value data. The following listing shows the client schema. Client Schema CREATE TABLE client ( id varchar(255) NOT NULL, clientId varchar(255) NOT NULL, clientIdIssuedAt timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL, clientSecret varchar(255) DEFAULT NULL, clientSecretExpiresAt timestamp DEFAULT NULL, clientName varchar(255) NOT NULL, clientAuthenticationMethods varchar(1000) NOT NULL, authorizationGrantTypes varchar(1000) NOT NULL, redirectUris varchar(1000) DEFAULT NULL, postLogoutRedirectUris varchar(1000) DEFAULT NULL, scopes varchar(1000) NOT NULL, clientSettings varchar(2000) NOT NULL, tokenSettings varchar(2000) NOT NULL, PRIMARY KEY (id) ); Authorization Schema: The OAuth2Authorization(../core-model-components.html#oauth2-authorization) domain object is more complex and contains several multi-valued fields as well as numerous arbitrarily long token values, metadata, settings and claims values. The built-in JDBC implementation utilizes a flattened structure that prefers performance over normalization, which we adopt here as well. It has been difficult to find a flattened database schema that works well in all cases and with all database vendors. You may need to normalize or heavily alter the following schema for your needs. The following listing shows the authorization schema. Authorization Schema CREATE TABLE authorization ( id varchar(255) NOT NULL, registeredClientId varchar(255) NOT NULL, principalName varchar(255) NOT NULL, authorizationGrantType varchar(255) NOT NULL, authorizedScopes varchar(1000) DEFAULT NULL, attributes varchar(4000) DEFAULT NULL, state varchar(500) DEFAULT NULL, authorizationCodeValue varchar(4000) DEFAULT NULL, authorizationCodeIssuedAt timestamp DEFAULT NULL, authorizationCodeExpiresAt timestamp DEFAULT NULL, authorizationCodeMetadata varchar(2000) DEFAULT NULL, accessTokenValue varchar(4000) DEFAULT NULL, accessTokenIssuedAt timestamp DEFAULT NULL, accessTokenExpiresAt timestamp DEFAULT NULL, accessTokenMetadata varchar(2000) DEFAULT NULL, accessTokenType varchar(255) DEFAULT NULL, accessTokenScopes varchar(1000) DEFAULT NULL, refreshTokenValue varchar(4000) DEFAULT NULL, refreshTokenIssuedAt timestamp DEFAULT NULL, refreshTokenExpiresAt timestamp DEFAULT NULL, refreshTokenMetadata varchar(2000) DEFAULT NULL, oidcIdTokenValue varchar(4000) DEFAULT NULL, oidcIdTokenIssuedAt timestamp DEFAULT NULL, oidcIdTokenExpiresAt timestamp DEFAULT NULL, oidcIdTokenMetadata varchar(2000) DEFAULT NULL, oidcIdTokenClaims varchar(2000) DEFAULT NULL, userCodeValue varchar(4000) DEFAULT NULL, userCodeIssuedAt timestamp DEFAULT NULL, userCodeExpiresAt timestamp DEFAULT NULL, userCodeMetadata varchar(2000) DEFAULT NULL, deviceCodeValue varchar(4000) DEFAULT NULL, deviceCodeIssuedAt timestamp DEFAULT NULL, deviceCodeExpiresAt timestamp DEFAULT NULL, deviceCodeMetadata varchar(2000) DEFAULT NULL, PRIMARY KEY (id) ); Authorization Consent Schema: The OAuth2AuthorizationConsent(../core-model-components.html#oauth2-authorization-consent) domain object is the simplest to model and contains only a single multi-valued field in addition to a composite key. The following listing shows the authorizationconsent schema. Authorization Consent Schema CREATE TABLE authorizationConsent ( registeredClientId varchar(255) NOT NULL, principalName varchar(255) NOT NULL, authorities varchar(1000) NOT NULL, PRIMARY KEY (registeredClientId, principalName) ); Create JPA entities: The preceding schema examples provide a reference for the structure of the entities we need to create. The following entities are minimally annotated and are just examples. They allow the schema to be created dynamically and therefore do not require the above sql scripts to be executed manually. Client Entity(#client-entity) Authorization Entity(#authorization-entity) Authorization Consent Entity(#authorization-consent-entity) Client Entity: The following listing shows the Client entity, which is used to persist information mapped from the RegisteredClient(../core-model-components.html#registered-client) domain object. Client Entity import java.time.Instant; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.Id; import jakarta.persistence.Table; @Entity @Table(name = ""`client`"") public class Client { @Id private String id; private String clientId; private Instant clientIdIssuedAt; private String clientSecret; private Instant clientSecretExpiresAt; private String clientName; @Column(length = 1000) private String clientAuthenticationMethods; @Column(length = 1000) private String authorizationGrantTypes; @Column(length = 1000) private String redirectUris; @Column(length = 1000) private String postLogoutRedirectUris; @Column(length = 1000) private String scopes; @Column(length = 2000) private String clientSettings; @Column(length = 2000) private String tokenSettings; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getClientId() { return clientId; } public void setClientId(String clientId) { this.clientId = clientId; } public Instant getClientIdIssuedAt() { return clientIdIssuedAt; } public void setClientIdIssuedAt(Instant clientIdIssuedAt) { this.clientIdIssuedAt = clientIdIssuedAt; } public String getClientSecret() { return clientSecret; } public void setClientSecret(String clientSecret) { this.clientSecret = clientSecret; } public Instant getClientSecretExpiresAt() { return clientSecretExpiresAt; } public void setClientSecretExpiresAt(Instant clientSecretExpiresAt) { this.clientSecretExpiresAt = clientSecretExpiresAt; } public String getClientName() { return clientName; } public void setClientName(String clientName) { this.clientName = clientName; } public String getClientAuthenticationMethods() { return clientAuthenticationMethods; } public void setClientAuthenticationMethods(String clientAuthenticationMethods) { this.clientAuthenticationMethods = clientAuthenticationMethods; } public String getAuthorizationGrantTypes() { return authorizationGrantTypes; } public void setAuthorizationGrantTypes(String authorizationGrantTypes) { this.authorizationGrantTypes = authorizationGrantTypes; } public String getRedirectUris() { return redirectUris; } public void setRedirectUris(String redirectUris) { this.redirectUris = redirectUris; } public String getPostLogoutRedirectUris() { return this.postLogoutRedirectUris; } public void setPostLogoutRedirectUris(String postLogoutRedirectUris) { this.postLogoutRedirectUris = postLogoutRedirectUris; } public String getScopes() { return scopes; } public void setScopes(String scopes) { this.scopes = scopes; } public String getClientSettings() { return clientSettings; } public void setClientSettings(String clientSettings) { this.clientSettings = clientSettings; } public String getTokenSettings() { return tokenSettings; } public void setTokenSettings(String tokenSettings) { this.tokenSettings = tokenSettings; } } Authorization Entity: The following listing shows the Authorization entity, which is used to persist information mapped from the OAuth2Authorization(../core-model-components.html#oauth2-authorization) domain object. Authorization Entity import java.time.Instant; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.Id; import jakarta.persistence.Table; @Entity @Table(name = ""`authorization`"") public class Authorization { @Id @Column private String id; private String registeredClientId; private String principalName; private String authorizationGrantType; @Column(length = 1000) private String authorizedScopes; @Column(length = 4000) private String attributes; @Column(length = 500) private String state; @Column(length = 4000) private String authorizationCodeValue; private Instant authorizationCodeIssuedAt; private Instant authorizationCodeExpiresAt; private String authorizationCodeMetadata; @Column(length = 4000) private String accessTokenValue; private Instant accessTokenIssuedAt; private Instant accessTokenExpiresAt; @Column(length = 2000) private String accessTokenMetadata; private String accessTokenType; @Column(length = 1000) private String accessTokenScopes; @Column(length = 4000) private String refreshTokenValue; private Instant refreshTokenIssuedAt; private Instant refreshTokenExpiresAt; @Column(length = 2000) private String refreshTokenMetadata; @Column(length = 4000) private String oidcIdTokenValue; private Instant oidcIdTokenIssuedAt; private Instant oidcIdTokenExpiresAt; @Column(length = 2000) private String oidcIdTokenMetadata; @Column(length = 2000) private String oidcIdTokenClaims; @Column(length = 4000) private String userCodeValue; private Instant userCodeIssuedAt; private Instant userCodeExpiresAt; @Column(length = 2000) private String userCodeMetadata; @Column(length = 4000) private String deviceCodeValue; private Instant deviceCodeIssuedAt; private Instant deviceCodeExpiresAt; @Column(length = 2000) private String deviceCodeMetadata; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getRegisteredClientId() { return registeredClientId; } public void setRegisteredClientId(String registeredClientId) { this.registeredClientId = registeredClientId; } public String getPrincipalName() { return principalName; } public void setPrincipalName(String principalName) { this.principalName = principalName; } public String getAuthorizationGrantType() { return authorizationGrantType; } public void setAuthorizationGrantType(String authorizationGrantType) { this.authorizationGrantType = authorizationGrantType; } public String getAuthorizedScopes() { return this.authorizedScopes; } public void setAuthorizedScopes(String authorizedScopes) { this.authorizedScopes = authorizedScopes; } public String getAttributes() { return attributes; } public void setAttributes(String attributes) { this.attributes = attributes; } public String getState() { return state; } public void setState(String state) { this.state = state; } public String getAuthorizationCodeValue() { return authorizationCodeValue; } public void setAuthorizationCodeValue(String authorizationCode) { this.authorizationCodeValue = authorizationCode; } public Instant getAuthorizationCodeIssuedAt() { return authorizationCodeIssuedAt; } public void setAuthorizationCodeIssuedAt(Instant authorizationCodeIssuedAt) { this.authorizationCodeIssuedAt = authorizationCodeIssuedAt; } public Instant getAuthorizationCodeExpiresAt() { return authorizationCodeExpiresAt; } public void setAuthorizationCodeExpiresAt(Instant authorizationCodeExpiresAt) { this.authorizationCodeExpiresAt = authorizationCodeExpiresAt; } public String getAuthorizationCodeMetadata() { return authorizationCodeMetadata; } public void setAuthorizationCodeMetadata(String authorizationCodeMetadata) { this.authorizationCodeMetadata = authorizationCodeMetadata; } public String getAccessTokenValue() { return accessTokenValue; } public void setAccessTokenValue(String accessToken) { this.accessTokenValue = accessToken; } public Instant getAccessTokenIssuedAt() { return accessTokenIssuedAt; } public void setAccessTokenIssuedAt(Instant accessTokenIssuedAt) { this.accessTokenIssuedAt = accessTokenIssuedAt; } public Instant getAccessTokenExpiresAt() { return accessTokenExpiresAt; } public void setAccessTokenExpiresAt(Instant accessTokenExpiresAt) { this.accessTokenExpiresAt = accessTokenExpiresAt; } public String getAccessTokenMetadata() { return accessTokenMetadata; } public void setAccessTokenMetadata(String accessTokenMetadata) { this.accessTokenMetadata = accessTokenMetadata; } public String getAccessTokenType() { return accessTokenType; } public void setAccessTokenType(String accessTokenType) { this.accessTokenType = accessTokenType; } public String getAccessTokenScopes() { return accessTokenScopes; } public void setAccessTokenScopes(String accessTokenScopes) { this.accessTokenScopes = accessTokenScopes; } public String getRefreshTokenValue() { return refreshTokenValue; } public void setRefreshTokenValue(String refreshToken) { this.refreshTokenValue = refreshToken; } public Instant getRefreshTokenIssuedAt() { return refreshTokenIssuedAt; } public void setRefreshTokenIssuedAt(Instant refreshTokenIssuedAt) { this.refreshTokenIssuedAt = refreshTokenIssuedAt; } public Instant getRefreshTokenExpiresAt() { return refreshTokenExpiresAt; } public void setRefreshTokenExpiresAt(Instant refreshTokenExpiresAt) { this.refreshTokenExpiresAt = refreshTokenExpiresAt; } public String getRefreshTokenMetadata() { return refreshTokenMetadata; } public void setRefreshTokenMetadata(String refreshTokenMetadata) { this.refreshTokenMetadata = refreshTokenMetadata; } public String getOidcIdTokenValue() { return oidcIdTokenValue; } public void setOidcIdTokenValue(String idToken) { this.oidcIdTokenValue = idToken; } public Instant getOidcIdTokenIssuedAt() { return oidcIdTokenIssuedAt; } public void setOidcIdTokenIssuedAt(Instant idTokenIssuedAt) { this.oidcIdTokenIssuedAt = idTokenIssuedAt; } public Instant getOidcIdTokenExpiresAt() { return oidcIdTokenExpiresAt; } public void setOidcIdTokenExpiresAt(Instant idTokenExpiresAt) { this.oidcIdTokenExpiresAt = idTokenExpiresAt; } public String getOidcIdTokenMetadata() { return oidcIdTokenMetadata; } public void setOidcIdTokenMetadata(String idTokenMetadata) { this.oidcIdTokenMetadata = idTokenMetadata; } public String getOidcIdTokenClaims() { return oidcIdTokenClaims; } public void setOidcIdTokenClaims(String idTokenClaims) { this.oidcIdTokenClaims = idTokenClaims; } public String getUserCodeValue() { return this.userCodeValue; } public void setUserCodeValue(String userCodeValue) { this.userCodeValue = userCodeValue; } public Instant getUserCodeIssuedAt() { return this.userCodeIssuedAt; } public void setUserCodeIssuedAt(Instant userCodeIssuedAt) { this.userCodeIssuedAt = userCodeIssuedAt; } public Instant getUserCodeExpiresAt() { return this.userCodeExpiresAt; } public void setUserCodeExpiresAt(Instant userCodeExpiresAt) { this.userCodeExpiresAt = userCodeExpiresAt; } public String getUserCodeMetadata() { return this.userCodeMetadata; } public void setUserCodeMetadata(String userCodeMetadata) { this.userCodeMetadata = userCodeMetadata; } public String getDeviceCodeValue() { return this.deviceCodeValue; } public void setDeviceCodeValue(String deviceCodeValue) { this.deviceCodeValue = deviceCodeValue; } public Instant getDeviceCodeIssuedAt() { return this.deviceCodeIssuedAt; } public void setDeviceCodeIssuedAt(Instant deviceCodeIssuedAt) { this.deviceCodeIssuedAt = deviceCodeIssuedAt; } public Instant getDeviceCodeExpiresAt() { return this.deviceCodeExpiresAt; } public void setDeviceCodeExpiresAt(Instant deviceCodeExpiresAt) { this.deviceCodeExpiresAt = deviceCodeExpiresAt; } public String getDeviceCodeMetadata() { return this.deviceCodeMetadata; } public void setDeviceCodeMetadata(String deviceCodeMetadata) { this.deviceCodeMetadata = deviceCodeMetadata; } } Authorization Consent Entity: The following listing shows the AuthorizationConsent entity, which is used to persist information mapped from the OAuth2AuthorizationConsent(../core-model-components.html#oauth2-authorization-consent) domain object. Authorization Consent Entity import java.io.Serializable; import java.util.Objects; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.Id; import jakarta.persistence.IdClass; import jakarta.persistence.Table; @Entity @Table(name = ""`authorizationConsent`"") @IdClass(AuthorizationConsent.AuthorizationConsentId.class) public class AuthorizationConsent { @Id private String registeredClientId; @Id private String principalName; @Column(length = 1000) private String authorities; public String getRegisteredClientId() { return registeredClientId; } public void setRegisteredClientId(String registeredClientId) { this.registeredClientId = registeredClientId; } public String getPrincipalName() { return principalName; } public void setPrincipalName(String principalName) { this.principalName = principalName; } public String getAuthorities() { return authorities; } public void setAuthorities(String authorities) { this.authorities = authorities; } public static class AuthorizationConsentId implements Serializable { private String registeredClientId; private String principalName; public String getRegisteredClientId() { return registeredClientId; } public void setRegisteredClientId(String registeredClientId) { this.registeredClientId = registeredClientId; } public String getPrincipalName() { return principalName; } public void setPrincipalName(String principalName) { this.principalName = principalName; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; AuthorizationConsentId that = (AuthorizationConsentId) o; return registeredClientId.equals(that.registeredClientId) && principalName.equals(that.principalName); } @Override public int hashCode() { return Objects.hash(registeredClientId, principalName); } } } Create Spring Data repositories: By closely examining the interfaces of each core service and reviewing the Jdbc implementations, we can derive a minimal set of queries needed for supporting a JPA version of each interface. Client Repository(#client-repository) Authorization Repository(#authorization-repository) Authorization Consent Repository(#authorization-consent-repository) Client Repository: The following listing shows the ClientRepository , which is able to find a Client(#client-entity) by the id and clientId fields. Client Repository import java.util.Optional; import sample.jpa.entity.client.Client; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository; @Repository public interface ClientRepository extends JpaRepository<Client, String> { Optional<Client> findByClientId(String clientId); } Authorization Repository: The following listing shows the AuthorizationRepository , which is able to find an Authorization(#authorization-entity) by the id field as well as the state , authorizationCodeValue , accessTokenValue , refreshTokenValue , userCodeValue and deviceCodeValue token fields. It also allows querying a combination of token fields. Authorization Repository import java.util.Optional; import sample.jpa.entity.authorization.Authorization; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.query.Param; import org.springframework.stereotype.Repository; @Repository public interface AuthorizationRepository extends JpaRepository<Authorization, String> { Optional<Authorization> findByState(String state); Optional<Authorization> findByAuthorizationCodeValue(String authorizationCode); Optional<Authorization> findByAccessTokenValue(String accessToken); Optional<Authorization> findByRefreshTokenValue(String refreshToken); Optional<Authorization> findByOidcIdTokenValue(String idToken); Optional<Authorization> findByUserCodeValue(String userCode); Optional<Authorization> findByDeviceCodeValue(String deviceCode); @Query(""select a from Authorization a where a.state = :token"" + "" or a.authorizationCodeValue = :token"" + "" or a.accessTokenValue = :token"" + "" or a.refreshTokenValue = :token"" + "" or a.oidcIdTokenValue = :token"" + "" or a.userCodeValue = :token"" + "" or a.deviceCodeValue = :token"" ) Optional<Authorization> findByStateOrAuthorizationCodeValueOrAccessTokenValueOrRefreshTokenValueOrOidcIdTokenValueOrUserCodeValueOrDeviceCodeValue(@Param(""token"") String token); } Authorization Consent Repository: The following listing shows the AuthorizationConsentRepository , which is able to find and delete an AuthorizationConsent(#authorization-consent-entity) by the registeredClientId and principalName fields that form a composite primary key. Authorization Consent Repository import java.util.Optional; import sample.jpa.entity.authorizationconsent.AuthorizationConsent; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository; @Repository public interface AuthorizationConsentRepository extends JpaRepository<AuthorizationConsent, AuthorizationConsent.AuthorizationConsentId> { Optional<AuthorizationConsent> findByRegisteredClientIdAndPrincipalName(String registeredClientId, String principalName); void deleteByRegisteredClientIdAndPrincipalName(String registeredClientId, String principalName); } Implement core services: With the above entities(#create-jpa-entities) and repositories(#create-spring-data-repositories) , we can begin implementing the core services. By reviewing the Jdbc implementations, we can derive a minimal set of internal utilities for converting to and from string values for enumerations and reading and writing JSON data for attributes, settings, metadata and claims fields. Keep in mind that writing JSON data to text columns with a fixed length has proven problematic with the Jdbc implementations. While these examples continue to do so, you may need to split these fields out into a separate table or data store that supports arbitrarily long data values. Registered Client Repository(#registered-client-repository) Authorization Service(#authorization-service) Authorization Consent Service(#authorization-consent-service) Registered Client Repository: The following listing shows the JpaRegisteredClientRepository , which uses a ClientRepository(#client-repository) for persisting a Client(#client-entity) and maps to and from the RegisteredClient(../core-model-components.html#registered-client) domain object. RegisteredClientRepository Implementation import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.Set; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.Module; import com.fasterxml.jackson.databind.ObjectMapper; import sample.jpa.entity.client.Client; import sample.jpa.repository.client.ClientRepository; import org.springframework.security.jackson2.SecurityJackson2Modules; import org.springframework.security.oauth2.core.AuthorizationGrantType; import org.springframework.security.oauth2.core.ClientAuthenticationMethod; import org.springframework.security.oauth2.server.authorization.client.RegisteredClient; import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.jackson2.OAuth2AuthorizationServerJackson2Module; import org.springframework.security.oauth2.server.authorization.settings.ClientSettings; import org.springframework.security.oauth2.server.authorization.settings.TokenSettings; import org.springframework.stereotype.Component; import org.springframework.util.Assert; import org.springframework.util.StringUtils; @Component public class JpaRegisteredClientRepository implements RegisteredClientRepository { private final ClientRepository clientRepository; private final ObjectMapper objectMapper = new ObjectMapper(); public JpaRegisteredClientRepository(ClientRepository clientRepository) { Assert.notNull(clientRepository, ""clientRepository cannot be null""); this.clientRepository = clientRepository; ClassLoader classLoader = JpaRegisteredClientRepository.class.getClassLoader(); List<Module> securityModules = SecurityJackson2Modules.getModules(classLoader); this.objectMapper.registerModules(securityModules); this.objectMapper.registerModule(new OAuth2AuthorizationServerJackson2Module()); } @Override public void save(RegisteredClient registeredClient) { Assert.notNull(registeredClient, ""registeredClient cannot be null""); this.clientRepository.save(toEntity(registeredClient)); } @Override public RegisteredClient findById(String id) { Assert.hasText(id, ""id cannot be empty""); return this.clientRepository.findById(id).map(this::toObject).orElse(null); } @Override public RegisteredClient findByClientId(String clientId) { Assert.hasText(clientId, ""clientId cannot be empty""); return this.clientRepository.findByClientId(clientId).map(this::toObject).orElse(null); } private RegisteredClient toObject(Client client) { Set<String> clientAuthenticationMethods = StringUtils.commaDelimitedListToSet( client.getClientAuthenticationMethods()); Set<String> authorizationGrantTypes = StringUtils.commaDelimitedListToSet( client.getAuthorizationGrantTypes()); Set<String> redirectUris = StringUtils.commaDelimitedListToSet( client.getRedirectUris()); Set<String> postLogoutRedirectUris = StringUtils.commaDelimitedListToSet( client.getPostLogoutRedirectUris()); Set<String> clientScopes = StringUtils.commaDelimitedListToSet( client.getScopes()); RegisteredClient.Builder builder = RegisteredClient.withId(client.getId()) .clientId(client.getClientId()) .clientIdIssuedAt(client.getClientIdIssuedAt()) .clientSecret(client.getClientSecret()) .clientSecretExpiresAt(client.getClientSecretExpiresAt()) .clientName(client.getClientName()) .clientAuthenticationMethods(authenticationMethods -> clientAuthenticationMethods.forEach(authenticationMethod -> authenticationMethods.add(resolveClientAuthenticationMethod(authenticationMethod)))) .authorizationGrantTypes((grantTypes) -> authorizationGrantTypes.forEach(grantType -> grantTypes.add(resolveAuthorizationGrantType(grantType)))) .redirectUris((uris) -> uris.addAll(redirectUris)) .postLogoutRedirectUris((uris) -> uris.addAll(postLogoutRedirectUris)) .scopes((scopes) -> scopes.addAll(clientScopes)); Map<String, Object> clientSettingsMap = parseMap(client.getClientSettings()); builder.clientSettings(ClientSettings.withSettings(clientSettingsMap).build()); Map<String, Object> tokenSettingsMap = parseMap(client.getTokenSettings()); builder.tokenSettings(TokenSettings.withSettings(tokenSettingsMap).build()); return builder.build(); } private Client toEntity(RegisteredClient registeredClient) { List<String> clientAuthenticationMethods = new ArrayList<>(registeredClient.getClientAuthenticationMethods().size()); registeredClient.getClientAuthenticationMethods().forEach(clientAuthenticationMethod -> clientAuthenticationMethods.add(clientAuthenticationMethod.getValue())); List<String> authorizationGrantTypes = new ArrayList<>(registeredClient.getAuthorizationGrantTypes().size()); registeredClient.getAuthorizationGrantTypes().forEach(authorizationGrantType -> authorizationGrantTypes.add(authorizationGrantType.getValue())); Client entity = new Client(); entity.setId(registeredClient.getId()); entity.setClientId(registeredClient.getClientId()); entity.setClientIdIssuedAt(registeredClient.getClientIdIssuedAt()); entity.setClientSecret(registeredClient.getClientSecret()); entity.setClientSecretExpiresAt(registeredClient.getClientSecretExpiresAt()); entity.setClientName(registeredClient.getClientName()); entity.setClientAuthenticationMethods(StringUtils.collectionToCommaDelimitedString(clientAuthenticationMethods)); entity.setAuthorizationGrantTypes(StringUtils.collectionToCommaDelimitedString(authorizationGrantTypes)); entity.setRedirectUris(StringUtils.collectionToCommaDelimitedString(registeredClient.getRedirectUris())); entity.setPostLogoutRedirectUris(StringUtils.collectionToCommaDelimitedString(registeredClient.getPostLogoutRedirectUris())); entity.setScopes(StringUtils.collectionToCommaDelimitedString(registeredClient.getScopes())); entity.setClientSettings(writeMap(registeredClient.getClientSettings().getSettings())); entity.setTokenSettings(writeMap(registeredClient.getTokenSettings().getSettings())); return entity; } private Map<String, Object> parseMap(String data) { try { return this.objectMapper.readValue(data, new TypeReference<Map<String, Object>>() { }); } catch (Exception ex) { throw new IllegalArgumentException(ex.getMessage(), ex); } } private String writeMap(Map<String, Object> data) { try { return this.objectMapper.writeValueAsString(data); } catch (Exception ex) { throw new IllegalArgumentException(ex.getMessage(), ex); } } private static AuthorizationGrantType resolveAuthorizationGrantType(String authorizationGrantType) { if (AuthorizationGrantType.AUTHORIZATION_CODE.getValue().equals(authorizationGrantType)) { return AuthorizationGrantType.AUTHORIZATION_CODE; } else if (AuthorizationGrantType.CLIENT_CREDENTIALS.getValue().equals(authorizationGrantType)) { return AuthorizationGrantType.CLIENT_CREDENTIALS; } else if (AuthorizationGrantType.REFRESH_TOKEN.getValue().equals(authorizationGrantType)) { return AuthorizationGrantType.REFRESH_TOKEN; } return new AuthorizationGrantType(authorizationGrantType); // Custom authorization grant type } private static ClientAuthenticationMethod resolveClientAuthenticationMethod(String clientAuthenticationMethod) { if (ClientAuthenticationMethod.CLIENT_SECRET_BASIC.getValue().equals(clientAuthenticationMethod)) { return ClientAuthenticationMethod.CLIENT_SECRET_BASIC; } else if (ClientAuthenticationMethod.CLIENT_SECRET_POST.getValue().equals(clientAuthenticationMethod)) { return ClientAuthenticationMethod.CLIENT_SECRET_POST; } else if (ClientAuthenticationMethod.NONE.getValue().equals(clientAuthenticationMethod)) { return ClientAuthenticationMethod.NONE; } return new ClientAuthenticationMethod(clientAuthenticationMethod); // Custom client authentication method } } Authorization Service: The following listing shows the JpaOAuth2AuthorizationService , which uses an AuthorizationRepository(#authorization-repository) for persisting an Authorization(#authorization-entity) and maps to and from the OAuth2Authorization(../core-model-components.html#oauth2-authorization) domain object. OAuth2AuthorizationService Implementation import java.time.Instant; import java.util.List; import java.util.Map; import java.util.Optional; import java.util.function.Consumer; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.Module; import com.fasterxml.jackson.databind.ObjectMapper; import sample.jpa.entity.authorization.Authorization; import sample.jpa.repository.authorization.AuthorizationRepository; import org.springframework.dao.DataRetrievalFailureException; import org.springframework.security.jackson2.SecurityJackson2Modules; import org.springframework.security.oauth2.core.AuthorizationGrantType; import org.springframework.security.oauth2.core.OAuth2AccessToken; import org.springframework.security.oauth2.core.OAuth2DeviceCode; import org.springframework.security.oauth2.core.OAuth2RefreshToken; import org.springframework.security.oauth2.core.OAuth2Token; import org.springframework.security.oauth2.core.OAuth2UserCode; import org.springframework.security.oauth2.core.endpoint.OAuth2ParameterNames; import org.springframework.security.oauth2.core.oidc.OidcIdToken; import org.springframework.security.oauth2.core.oidc.endpoint.OidcParameterNames; import org.springframework.security.oauth2.server.authorization.OAuth2Authorization; import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationCode; import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationService; import org.springframework.security.oauth2.server.authorization.OAuth2TokenType; import org.springframework.security.oauth2.server.authorization.client.RegisteredClient; import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.jackson2.OAuth2AuthorizationServerJackson2Module; import org.springframework.stereotype.Component; import org.springframework.util.Assert; import org.springframework.util.StringUtils; @Component public class JpaOAuth2AuthorizationService implements OAuth2AuthorizationService { private final AuthorizationRepository authorizationRepository; private final RegisteredClientRepository registeredClientRepository; private final ObjectMapper objectMapper = new ObjectMapper(); public JpaOAuth2AuthorizationService(AuthorizationRepository authorizationRepository, RegisteredClientRepository registeredClientRepository) { Assert.notNull(authorizationRepository, ""authorizationRepository cannot be null""); Assert.notNull(registeredClientRepository, ""registeredClientRepository cannot be null""); this.authorizationRepository = authorizationRepository; this.registeredClientRepository = registeredClientRepository; ClassLoader classLoader = JpaOAuth2AuthorizationService.class.getClassLoader(); List<Module> securityModules = SecurityJackson2Modules.getModules(classLoader); this.objectMapper.registerModules(securityModules); this.objectMapper.registerModule(new OAuth2AuthorizationServerJackson2Module()); } @Override public void save(OAuth2Authorization authorization) { Assert.notNull(authorization, ""authorization cannot be null""); this.authorizationRepository.save(toEntity(authorization)); } @Override public void remove(OAuth2Authorization authorization) { Assert.notNull(authorization, ""authorization cannot be null""); this.authorizationRepository.deleteById(authorization.getId()); } @Override public OAuth2Authorization findById(String id) { Assert.hasText(id, ""id cannot be empty""); return this.authorizationRepository.findById(id).map(this::toObject).orElse(null); } @Override public OAuth2Authorization findByToken(String token, OAuth2TokenType tokenType) { Assert.hasText(token, ""token cannot be empty""); Optional<Authorization> result; if (tokenType == null) { result = this.authorizationRepository.findByStateOrAuthorizationCodeValueOrAccessTokenValueOrRefreshTokenValueOrOidcIdTokenValueOrUserCodeValueOrDeviceCodeValue(token); } else if (OAuth2ParameterNames.STATE.equals(tokenType.getValue())) { result = this.authorizationRepository.findByState(token); } else if (OAuth2ParameterNames.CODE.equals(tokenType.getValue())) { result = this.authorizationRepository.findByAuthorizationCodeValue(token); } else if (OAuth2ParameterNames.ACCESS_TOKEN.equals(tokenType.getValue())) { result = this.authorizationRepository.findByAccessTokenValue(token); } else if (OAuth2ParameterNames.REFRESH_TOKEN.equals(tokenType.getValue())) { result = this.authorizationRepository.findByRefreshTokenValue(token); } else if (OidcParameterNames.ID_TOKEN.equals(tokenType.getValue())) { result = this.authorizationRepository.findByOidcIdTokenValue(token); } else if (OAuth2ParameterNames.USER_CODE.equals(tokenType.getValue())) { result = this.authorizationRepository.findByUserCodeValue(token); } else if (OAuth2ParameterNames.DEVICE_CODE.equals(tokenType.getValue())) { result = this.authorizationRepository.findByDeviceCodeValue(token); } else { result = Optional.empty(); } return result.map(this::toObject).orElse(null); } private OAuth2Authorization toObject(Authorization entity) { RegisteredClient registeredClient = this.registeredClientRepository.findById(entity.getRegisteredClientId()); if (registeredClient == null) { throw new DataRetrievalFailureException( ""The RegisteredClient with id '"" + entity.getRegisteredClientId() + ""' was not found in the RegisteredClientRepository.""); } OAuth2Authorization.Builder builder = OAuth2Authorization.withRegisteredClient(registeredClient) .id(entity.getId()) .principalName(entity.getPrincipalName()) .authorizationGrantType(resolveAuthorizationGrantType(entity.getAuthorizationGrantType())) .authorizedScopes(StringUtils.commaDelimitedListToSet(entity.getAuthorizedScopes())) .attributes(attributes -> attributes.putAll(parseMap(entity.getAttributes()))); if (entity.getState() != null) { builder.attribute(OAuth2ParameterNames.STATE, entity.getState()); } if (entity.getAuthorizationCodeValue() != null) { OAuth2AuthorizationCode authorizationCode = new OAuth2AuthorizationCode( entity.getAuthorizationCodeValue(), entity.getAuthorizationCodeIssuedAt(), entity.getAuthorizationCodeExpiresAt()); builder.token(authorizationCode, metadata -> metadata.putAll(parseMap(entity.getAuthorizationCodeMetadata()))); } if (entity.getAccessTokenValue() != null) { OAuth2AccessToken accessToken = new OAuth2AccessToken( OAuth2AccessToken.TokenType.BEARER, entity.getAccessTokenValue(), entity.getAccessTokenIssuedAt(), entity.getAccessTokenExpiresAt(), StringUtils.commaDelimitedListToSet(entity.getAccessTokenScopes())); builder.token(accessToken, metadata -> metadata.putAll(parseMap(entity.getAccessTokenMetadata()))); } if (entity.getRefreshTokenValue() != null) { OAuth2RefreshToken refreshToken = new OAuth2RefreshToken( entity.getRefreshTokenValue(), entity.getRefreshTokenIssuedAt(), entity.getRefreshTokenExpiresAt()); builder.token(refreshToken, metadata -> metadata.putAll(parseMap(entity.getRefreshTokenMetadata()))); } if (entity.getOidcIdTokenValue() != null) { OidcIdToken idToken = new OidcIdToken( entity.getOidcIdTokenValue(), entity.getOidcIdTokenIssuedAt(), entity.getOidcIdTokenExpiresAt(), parseMap(entity.getOidcIdTokenClaims())); builder.token(idToken, metadata -> metadata.putAll(parseMap(entity.getOidcIdTokenMetadata()))); } if (entity.getUserCodeValue() != null) { OAuth2UserCode userCode = new OAuth2UserCode( entity.getUserCodeValue(), entity.getUserCodeIssuedAt(), entity.getUserCodeExpiresAt()); builder.token(userCode, metadata -> metadata.putAll(parseMap(entity.getUserCodeMetadata()))); } if (entity.getDeviceCodeValue() != null) { OAuth2DeviceCode deviceCode = new OAuth2DeviceCode( entity.getDeviceCodeValue(), entity.getDeviceCodeIssuedAt(), entity.getDeviceCodeExpiresAt()); builder.token(deviceCode, metadata -> metadata.putAll(parseMap(entity.getDeviceCodeMetadata()))); } return builder.build(); } private Authorization toEntity(OAuth2Authorization authorization) { Authorization entity = new Authorization(); entity.setId(authorization.getId()); entity.setRegisteredClientId(authorization.getRegisteredClientId()); entity.setPrincipalName(authorization.getPrincipalName()); entity.setAuthorizationGrantType(authorization.getAuthorizationGrantType().getValue()); entity.setAuthorizedScopes(StringUtils.collectionToDelimitedString(authorization.getAuthorizedScopes(), "","")); entity.setAttributes(writeMap(authorization.getAttributes())); entity.setState(authorization.getAttribute(OAuth2ParameterNames.STATE)); OAuth2Authorization.Token<OAuth2AuthorizationCode> authorizationCode = authorization.getToken(OAuth2AuthorizationCode.class); setTokenValues( authorizationCode, entity::setAuthorizationCodeValue, entity::setAuthorizationCodeIssuedAt, entity::setAuthorizationCodeExpiresAt, entity::setAuthorizationCodeMetadata ); OAuth2Authorization.Token<OAuth2AccessToken> accessToken = authorization.getToken(OAuth2AccessToken.class); setTokenValues( accessToken, entity::setAccessTokenValue, entity::setAccessTokenIssuedAt, entity::setAccessTokenExpiresAt, entity::setAccessTokenMetadata ); if (accessToken != null && accessToken.getToken().getScopes() != null) { entity.setAccessTokenScopes(StringUtils.collectionToDelimitedString(accessToken.getToken().getScopes(), "","")); } OAuth2Authorization.Token<OAuth2RefreshToken> refreshToken = authorization.getToken(OAuth2RefreshToken.class); setTokenValues( refreshToken, entity::setRefreshTokenValue, entity::setRefreshTokenIssuedAt, entity::setRefreshTokenExpiresAt, entity::setRefreshTokenMetadata ); OAuth2Authorization.Token<OidcIdToken> oidcIdToken = authorization.getToken(OidcIdToken.class); setTokenValues( oidcIdToken, entity::setOidcIdTokenValue, entity::setOidcIdTokenIssuedAt, entity::setOidcIdTokenExpiresAt, entity::setOidcIdTokenMetadata ); if (oidcIdToken != null) { entity.setOidcIdTokenClaims(writeMap(oidcIdToken.getClaims())); } OAuth2Authorization.Token<OAuth2UserCode> userCode = authorization.getToken(OAuth2UserCode.class); setTokenValues( userCode, entity::setUserCodeValue, entity::setUserCodeIssuedAt, entity::setUserCodeExpiresAt, entity::setUserCodeMetadata ); OAuth2Authorization.Token<OAuth2DeviceCode> deviceCode = authorization.getToken(OAuth2DeviceCode.class); setTokenValues( deviceCode, entity::setDeviceCodeValue, entity::setDeviceCodeIssuedAt, entity::setDeviceCodeExpiresAt, entity::setDeviceCodeMetadata ); return entity; } private void setTokenValues( OAuth2Authorization.Token<?> token, Consumer<String> tokenValueConsumer, Consumer<Instant> issuedAtConsumer, Consumer<Instant> expiresAtConsumer, Consumer<String> metadataConsumer) { if (token != null) { OAuth2Token oAuth2Token = token.getToken(); tokenValueConsumer.accept(oAuth2Token.getTokenValue()); issuedAtConsumer.accept(oAuth2Token.getIssuedAt()); expiresAtConsumer.accept(oAuth2Token.getExpiresAt()); metadataConsumer.accept(writeMap(token.getMetadata())); } } private Map<String, Object> parseMap(String data) { try { return this.objectMapper.readValue(data, new TypeReference<Map<String, Object>>() { }); } catch (Exception ex) { throw new IllegalArgumentException(ex.getMessage(), ex); } } private String writeMap(Map<String, Object> metadata) { try { return this.objectMapper.writeValueAsString(metadata); } catch (Exception ex) { throw new IllegalArgumentException(ex.getMessage(), ex); } } private static AuthorizationGrantType resolveAuthorizationGrantType(String authorizationGrantType) { if (AuthorizationGrantType.AUTHORIZATION_CODE.getValue().equals(authorizationGrantType)) { return AuthorizationGrantType.AUTHORIZATION_CODE; } else if (AuthorizationGrantType.CLIENT_CREDENTIALS.getValue().equals(authorizationGrantType)) { return AuthorizationGrantType.CLIENT_CREDENTIALS; } else if (AuthorizationGrantType.REFRESH_TOKEN.getValue().equals(authorizationGrantType)) { return AuthorizationGrantType.REFRESH_TOKEN; } else if (AuthorizationGrantType.DEVICE_CODE.getValue().equals(authorizationGrantType)) { return AuthorizationGrantType.DEVICE_CODE; } return new AuthorizationGrantType(authorizationGrantType); // Custom authorization grant type } } Authorization Consent Service: The following listing shows the JpaOAuth2AuthorizationConsentService , which uses an AuthorizationConsentRepository(#authorization-consent-repository) for persisting an AuthorizationConsent(#authorization-consent-entity) and maps to and from the OAuth2AuthorizationConsent(../core-model-components.html#oauth2-authorization-consent) domain object. OAuth2AuthorizationConsentService Implementation import java.util.HashSet; import java.util.Set; import sample.jpa.entity.authorizationconsent.AuthorizationConsent; import sample.jpa.repository.authorizationconsent.AuthorizationConsentRepository; import org.springframework.dao.DataRetrievalFailureException; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationConsent; import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationConsentService; import org.springframework.security.oauth2.server.authorization.client.RegisteredClient; import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository; import org.springframework.stereotype.Component; import org.springframework.util.Assert; import org.springframework.util.StringUtils; @Component public class JpaOAuth2AuthorizationConsentService implements OAuth2AuthorizationConsentService { private final AuthorizationConsentRepository authorizationConsentRepository; private final RegisteredClientRepository registeredClientRepository; public JpaOAuth2AuthorizationConsentService(AuthorizationConsentRepository authorizationConsentRepository, RegisteredClientRepository registeredClientRepository) { Assert.notNull(authorizationConsentRepository, ""authorizationConsentRepository cannot be null""); Assert.notNull(registeredClientRepository, ""registeredClientRepository cannot be null""); this.authorizationConsentRepository = authorizationConsentRepository; this.registeredClientRepository = registeredClientRepository; } @Override public void save(OAuth2AuthorizationConsent authorizationConsent) { Assert.notNull(authorizationConsent, ""authorizationConsent cannot be null""); this.authorizationConsentRepository.save(toEntity(authorizationConsent)); } @Override public void remove(OAuth2AuthorizationConsent authorizationConsent) { Assert.notNull(authorizationConsent, ""authorizationConsent cannot be null""); this.authorizationConsentRepository.deleteByRegisteredClientIdAndPrincipalName( authorizationConsent.getRegisteredClientId(), authorizationConsent.getPrincipalName()); } @Override public OAuth2AuthorizationConsent findById(String registeredClientId, String principalName) { Assert.hasText(registeredClientId, ""registeredClientId cannot be empty""); Assert.hasText(principalName, ""principalName cannot be empty""); return this.authorizationConsentRepository.findByRegisteredClientIdAndPrincipalName( registeredClientId, principalName).map(this::toObject).orElse(null); } private OAuth2AuthorizationConsent toObject(AuthorizationConsent authorizationConsent) { String registeredClientId = authorizationConsent.getRegisteredClientId(); RegisteredClient registeredClient = this.registeredClientRepository.findById(registeredClientId); if (registeredClient == null) { throw new DataRetrievalFailureException( ""The RegisteredClient with id '"" + registeredClientId + ""' was not found in the RegisteredClientRepository.""); } OAuth2AuthorizationConsent.Builder builder = OAuth2AuthorizationConsent.withId( registeredClientId, authorizationConsent.getPrincipalName()); if (authorizationConsent.getAuthorities() != null) { for (String authority : StringUtils.commaDelimitedListToSet(authorizationConsent.getAuthorities())) { builder.authority(new SimpleGrantedAuthority(authority)); } } return builder.build(); } private AuthorizationConsent toEntity(OAuth2AuthorizationConsent authorizationConsent) { AuthorizationConsent entity = new AuthorizationConsent(); entity.setRegisteredClientId(authorizationConsent.getRegisteredClientId()); entity.setPrincipalName(authorizationConsent.getPrincipalName()); Set<String> authorities = new HashSet<>(); for (GrantedAuthority authority : authorizationConsent.getAuthorities()) { authorities.add(authority.getAuthority()); } entity.setAuthorities(StringUtils.collectionToCommaDelimitedString(authorities)); return entity; } }"
"https://docs.spring.io/spring-authorization-server/reference/1.3/guides/how-to-custom-claims-authorities.html","How-to: Add authorities as custom claims in JWT access tokens: This guide demonstrates how to add resource owner authorities to a JWT access token. The term ""authorities"" may represent varying forms such as roles, permissions, or groups of the resource owner. To make resource owner’s authorities available to the resource server, we add custom claims to the access token. When the client uses the access token to access a protected resource, the resource server will be able to obtain the information about the resource owner’s level of access, among other potential uses and benefits. Add custom claims to JWT access tokens(#custom-claims) Add authorities as custom claims to JWT access tokens(#custom-claims-authorities) Add custom claims to JWT access tokens: You may add your own custom claims to an access token using an OAuth2TokenCustomizer<JWTEncodingContext> @Bean . Please note that this @Bean may only be defined once, and so care must be taken to ensure that you are customizing the appropriate token type — an access token in this case. If you are interested in customizing the ID Token, see the User Info Mapper guide(how-to-userinfo.html#customize-user-info-mapper) for more information. The following is an example of adding custom claims to an access token — in other words, every access token that is issued by the authorization server will have the custom claims populated. import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.oauth2.server.authorization.OAuth2TokenType; import org.springframework.security.oauth2.server.authorization.token.JwtEncodingContext; import org.springframework.security.oauth2.server.authorization.token.OAuth2TokenCustomizer; @Configuration public class CustomClaimsConfiguration { @Bean public OAuth2TokenCustomizer<JwtEncodingContext> jwtTokenCustomizer() { return (context) -> { if (OAuth2TokenType.ACCESS_TOKEN.equals(context.getTokenType())) { context.getClaims().claims((claims) -> { claims.put(""claim-1"", ""value-1""); claims.put(""claim-2"", ""value-2""); }); } }; } } Add authorities as custom claims to JWT access tokens: To add authorities of the resource owner to a JWT access token, we can refer to the custom claim mapping method above and populate a custom claim with the authorities of the Principal . We define a sample user with a set of authorities for demonstration purposes, and populate a custom claim in the access token with those authorities. import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.core.authority.AuthorityUtils; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.oauth2.server.authorization.OAuth2TokenType; import org.springframework.security.oauth2.server.authorization.token.JwtEncodingContext; import org.springframework.security.oauth2.server.authorization.token.OAuth2TokenCustomizer; import org.springframework.security.provisioning.InMemoryUserDetailsManager; import java.util.Collections; import java.util.Set; import java.util.stream.Collectors; @Configuration public class CustomClaimsWithAuthoritiesConfiguration { @Bean public UserDetailsService users() { UserDetails user = User.withDefaultPasswordEncoder() .username(""user1"") (1) .password(""password"") .roles(""user"", ""admin"") (2) .build(); return new InMemoryUserDetailsManager(user); } @Bean public OAuth2TokenCustomizer<JwtEncodingContext> jwtTokenCustomizer() { (3) return (context) -> { if (OAuth2TokenType.ACCESS_TOKEN.equals(context.getTokenType())) { (4) context.getClaims().claims((claims) -> { (5) Set<String> roles = AuthorityUtils.authorityListToSet(context.getPrincipal().getAuthorities()) .stream() .map(c -> c.replaceFirst(""^ROLE_"", """")) .collect(Collectors.collectingAndThen(Collectors.toSet(), Collections::unmodifiableSet)); (6) claims.put(""roles"", roles); (7) }); } }; } } 1 Define a sample user user1 with an in-memory UserDetailsService . 2 Assign the roles for user1 . 3 Define an OAuth2TokenCustomizer<JwtEncodingContext> @Bean that allows for customizing the JWT claims. 4 Check whether the JWT is an access token. 5 Access the default claims via the JwtEncodingContext . 6 Extract the roles from the Principal object. The role information is stored as a string prefixed with ROLE_ , so we strip the prefix here. 7 Set the custom claim roles to the set of roles collected from the previous step. As a result of this customization, authorities information about the user will be included as a custom claim in the access token."
"https://docs.spring.io/spring-authorization-server/reference/1.3/guides/how-to-dynamic-client-registration.html","How-to: Register a client dynamically: This guide shows how to configure OpenID Connect Dynamic Client Registration in Spring Authorization Server and walks through an example of how to register a client. Spring Authorization Server implements the OpenID Connect Dynamic Client Registration 1.0(https://openid.net/specs/openid-connect-registration-1_0.html) specification, providing the capability to dynamically register and retrieve OpenID Connect clients. Enable Dynamic Client Registration(#enable-dynamic-client-registration) Configure client registrar(#configure-client-registrar) Obtain initial access token(#obtain-initial-access-token) Register a client(#register-client) Enable Dynamic Client Registration: By default, dynamic client registration functionality is disabled in Spring Authorization Server. To enable, add the following configuration: import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.Customizer; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configuration.OAuth2AuthorizationServerConfiguration; import org.springframework.security.oauth2.server.authorization.config.annotation.web.configurers.OAuth2AuthorizationServerConfigurer; import org.springframework.security.web.SecurityFilterChain; import static sample.registration.CustomClientMetadataConfig.configureCustomClientMetadataConverters; @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http); http.getConfigurer(OAuth2AuthorizationServerConfigurer.class) .oidc(oidc -> oidc.clientRegistrationEndpoint(clientRegistrationEndpoint -> { (1) clientRegistrationEndpoint .authenticationProviders(configureCustomClientMetadataConverters()); (2) })); http.oauth2ResourceServer(oauth2ResourceServer -> oauth2ResourceServer.jwt(Customizer.withDefaults())); return http.build(); } } 1 Enable the OpenID Connect 1.0 Client Registration Endpoint(../protocol-endpoints.html#oidc-client-registration-endpoint) with the default configuration. 2 Optionally, customize the default AuthenticationProvider 's to support custom client metadata parameters. In order to support custom client metadata parameters when registering a client, a few additional implementation details are required. The following example shows a sample implementation of Converter 's that support custom client metadata parameters ( logo_uri and contacts ) and are configured in OidcClientRegistrationAuthenticationProvider and OidcClientConfigurationAuthenticationProvider . import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.function.Consumer; import java.util.function.Function; import java.util.stream.Collectors; import org.springframework.core.convert.converter.Converter; import org.springframework.security.authentication.AuthenticationProvider; import org.springframework.security.oauth2.server.authorization.client.RegisteredClient; import org.springframework.security.oauth2.server.authorization.oidc.OidcClientRegistration; import org.springframework.security.oauth2.server.authorization.oidc.authentication.OidcClientConfigurationAuthenticationProvider; import org.springframework.security.oauth2.server.authorization.oidc.authentication.OidcClientRegistrationAuthenticationProvider; import org.springframework.security.oauth2.server.authorization.oidc.converter.OidcClientRegistrationRegisteredClientConverter; import org.springframework.security.oauth2.server.authorization.oidc.converter.RegisteredClientOidcClientRegistrationConverter; import org.springframework.security.oauth2.server.authorization.settings.ClientSettings; import org.springframework.util.CollectionUtils; public class CustomClientMetadataConfig { public static Consumer<List<AuthenticationProvider>> configureCustomClientMetadataConverters() { (1) List<String> customClientMetadata = List.of(""logo_uri"", ""contacts""); (2) return (authenticationProviders) -> { CustomRegisteredClientConverter registeredClientConverter = new CustomRegisteredClientConverter(customClientMetadata); CustomClientRegistrationConverter clientRegistrationConverter = new CustomClientRegistrationConverter(customClientMetadata); authenticationProviders.forEach((authenticationProvider) -> { if (authenticationProvider instanceof OidcClientRegistrationAuthenticationProvider provider) { provider.setRegisteredClientConverter(registeredClientConverter); (3) provider.setClientRegistrationConverter(clientRegistrationConverter); (4) } if (authenticationProvider instanceof OidcClientConfigurationAuthenticationProvider provider) { provider.setClientRegistrationConverter(clientRegistrationConverter); (5) } }); }; } private static class CustomRegisteredClientConverter implements Converter<OidcClientRegistration, RegisteredClient> { private final List<String> customClientMetadata; private final OidcClientRegistrationRegisteredClientConverter delegate; private CustomRegisteredClientConverter(List<String> customClientMetadata) { this.customClientMetadata = customClientMetadata; this.delegate = new OidcClientRegistrationRegisteredClientConverter(); } @Override public RegisteredClient convert(OidcClientRegistration clientRegistration) { RegisteredClient registeredClient = this.delegate.convert(clientRegistration); ClientSettings.Builder clientSettingsBuilder = ClientSettings.withSettings( registeredClient.getClientSettings().getSettings()); if (!CollectionUtils.isEmpty(this.customClientMetadata)) { clientRegistration.getClaims().forEach((claim, value) -> { if (this.customClientMetadata.contains(claim)) { clientSettingsBuilder.setting(claim, value); } }); } return RegisteredClient.from(registeredClient) .clientSettings(clientSettingsBuilder.build()) .build(); } } private static class CustomClientRegistrationConverter implements Converter<RegisteredClient, OidcClientRegistration> { private final List<String> customClientMetadata; private final RegisteredClientOidcClientRegistrationConverter delegate; private CustomClientRegistrationConverter(List<String> customClientMetadata) { this.customClientMetadata = customClientMetadata; this.delegate = new RegisteredClientOidcClientRegistrationConverter(); } @Override public OidcClientRegistration convert(RegisteredClient registeredClient) { OidcClientRegistration clientRegistration = this.delegate.convert(registeredClient); Map<String, Object> claims = new HashMap<>(clientRegistration.getClaims()); if (!CollectionUtils.isEmpty(this.customClientMetadata)) { ClientSettings clientSettings = registeredClient.getClientSettings(); claims.putAll(this.customClientMetadata.stream() .filter(metadata -> clientSettings.getSetting(metadata) != null) .collect(Collectors.toMap(Function.identity(), clientSettings::getSetting))); } return OidcClientRegistration.withClaims(claims).build(); } } } 1 Define a Consumer<List<AuthenticationProvider>> providing the ability to customize the default AuthenticationProvider 's. 2 Define custom client metadata parameters that are supported for client registration. 3 Configure OidcClientRegistrationAuthenticationProvider.setRegisteredClientConverter() with a CustomRegisteredClientConverter . 4 Configure OidcClientRegistrationAuthenticationProvider.setClientRegistrationConverter() with a CustomClientRegistrationConverter . 5 Configure OidcClientConfigurationAuthenticationProvider.setClientRegistrationConverter() with a CustomClientRegistrationConverter . Configure client registrar: An existing client is used to register new clients with the authorization server. The client must be configured with scopes client.create and optionally client.read for registering clients and retrieving clients, respectively. The following listing shows an example client: import java.util.UUID; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.oauth2.core.AuthorizationGrantType; import org.springframework.security.oauth2.core.ClientAuthenticationMethod; import org.springframework.security.oauth2.server.authorization.client.InMemoryRegisteredClientRepository; import org.springframework.security.oauth2.server.authorization.client.RegisteredClient; import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository; @Configuration public class ClientConfig { @Bean public RegisteredClientRepository registeredClientRepository() { RegisteredClient registrarClient = RegisteredClient.withId(UUID.randomUUID().toString()) .clientId(""registrar-client"") .clientSecret(""{noop}secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS) (1) .scope(""client.create"") (2) .scope(""client.read"") (3) .build(); return new InMemoryRegisteredClientRepository(registrarClient); } } 1 client_credentials grant type is configured to obtain access tokens directly. 2 client.create scope is configured to allow the client to register a new client. 3 client.read scope is configured to allow the client to retrieve a registered client. Obtain initial access token: An ""initial"" access token is required for the client registration request. The access token request MUST contain the scope parameter value client.create only. POST /oauth2/token HTTP/1.1 Authorization: Basic <base64-encoded-credentials> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=client.create The client registration request requires an access token with a single scope of client.create . If the access token contains additional scope, the client registration request will be denied. To obtain encoded credentials for the above request, base64 encode the client credentials in the format of <clientId>:<clientSecret> . Below is an encoding operation for the example in this guide. echo -n ""registrar-client:secret"" | base64 Register a client: With an access token obtained from the previous step, a client can now be dynamically registered. The ""initial"" access token can only be used once. After the client is registered, the access token is invalidated. import java.util.List; import java.util.Objects; import com.fasterxml.jackson.annotation.JsonProperty; import reactor.core.publisher.Mono; import org.springframework.http.HttpHeaders; import org.springframework.http.MediaType; import org.springframework.security.oauth2.core.AuthorizationGrantType; import org.springframework.web.reactive.function.client.WebClient; public class ClientRegistrar { private final WebClient webClient; public ClientRegistrar(WebClient webClient) { this.webClient = webClient; } public record ClientRegistrationRequest( (1) @JsonProperty(""client_name"") String clientName, @JsonProperty(""grant_types"") List<String> grantTypes, @JsonProperty(""redirect_uris"") List<String> redirectUris, @JsonProperty(""logo_uri"") String logoUri, List<String> contacts, String scope) { } public record ClientRegistrationResponse( (2) @JsonProperty(""registration_access_token"") String registrationAccessToken, @JsonProperty(""registration_client_uri"") String registrationClientUri, @JsonProperty(""client_name"") String clientName, @JsonProperty(""client_id"") String clientId, @JsonProperty(""client_secret"") String clientSecret, @JsonProperty(""grant_types"") List<String> grantTypes, @JsonProperty(""redirect_uris"") List<String> redirectUris, @JsonProperty(""logo_uri"") String logoUri, List<String> contacts, String scope) { } public void exampleRegistration(String initialAccessToken) { (3) ClientRegistrationRequest clientRegistrationRequest = new ClientRegistrationRequest( (4) ""client-1"", List.of(AuthorizationGrantType.AUTHORIZATION_CODE.getValue()), List.of(""https://client.example.org/callback"", ""https://client.example.org/callback2""), ""https://client.example.org/logo"", List.of(""contact-1"", ""contact-2""), ""openid email profile"" ); ClientRegistrationResponse clientRegistrationResponse = registerClient(initialAccessToken, clientRegistrationRequest); (5) assert (clientRegistrationResponse.clientName().contentEquals(""client-1"")); (6) assert (!Objects.isNull(clientRegistrationResponse.clientSecret())); assert (clientRegistrationResponse.scope().contentEquals(""openid profile email"")); assert (clientRegistrationResponse.grantTypes().contains(AuthorizationGrantType.AUTHORIZATION_CODE.getValue())); assert (clientRegistrationResponse.redirectUris().contains(""https://client.example.org/callback"")); assert (clientRegistrationResponse.redirectUris().contains(""https://client.example.org/callback2"")); assert (!clientRegistrationResponse.registrationAccessToken().isEmpty()); assert (!clientRegistrationResponse.registrationClientUri().isEmpty()); assert (clientRegistrationResponse.logoUri().contentEquals(""https://client.example.org/logo"")); assert (clientRegistrationResponse.contacts().size() == 2); assert (clientRegistrationResponse.contacts().contains(""contact-1"")); assert (clientRegistrationResponse.contacts().contains(""contact-2"")); String registrationAccessToken = clientRegistrationResponse.registrationAccessToken(); (7) String registrationClientUri = clientRegistrationResponse.registrationClientUri(); ClientRegistrationResponse retrievedClient = retrieveClient(registrationAccessToken, registrationClientUri); (8) assert (retrievedClient.clientName().contentEquals(""client-1"")); (9) assert (!Objects.isNull(retrievedClient.clientId())); assert (!Objects.isNull(retrievedClient.clientSecret())); assert (retrievedClient.scope().contentEquals(""openid profile email"")); assert (retrievedClient.grantTypes().contains(AuthorizationGrantType.AUTHORIZATION_CODE.getValue())); assert (retrievedClient.redirectUris().contains(""https://client.example.org/callback"")); assert (retrievedClient.redirectUris().contains(""https://client.example.org/callback2"")); assert (retrievedClient.logoUri().contentEquals(""https://client.example.org/logo"")); assert (retrievedClient.contacts().size() == 2); assert (retrievedClient.contacts().contains(""contact-1"")); assert (retrievedClient.contacts().contains(""contact-2"")); assert (Objects.isNull(retrievedClient.registrationAccessToken())); assert (!retrievedClient.registrationClientUri().isEmpty()); } public ClientRegistrationResponse registerClient(String initialAccessToken, ClientRegistrationRequest request) { (10) return this.webClient .post() .uri(""/connect/register"") .contentType(MediaType.APPLICATION_JSON) .accept(MediaType.APPLICATION_JSON) .header(HttpHeaders.AUTHORIZATION, ""Bearer %s"".formatted(initialAccessToken)) .body(Mono.just(request), ClientRegistrationRequest.class) .retrieve() .bodyToMono(ClientRegistrationResponse.class) .block(); } public ClientRegistrationResponse retrieveClient(String registrationAccessToken, String registrationClientUri) { (11) return this.webClient .get() .uri(registrationClientUri) .header(HttpHeaders.AUTHORIZATION, ""Bearer %s"".formatted(registrationAccessToken)) .retrieve() .bodyToMono(ClientRegistrationResponse.class) .block(); } } 1 A minimal representation of a client registration request. You may add additional client metadata parameters as per Client Registration Request(https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationRequest) . This example request contains custom client metadata parameters logo_uri and contacts . 2 A minimal representation of a client registration response. You may add additional client metadata parameters as per Client Registration Response(https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationResponse) . This example response contains custom client metadata parameters logo_uri and contacts . 3 Example demonstrating client registration and client retrieval. 4 A sample client registration request object. 5 Register the client using the ""initial"" access token and client registration request object. 6 After successful registration, assert on the client metadata parameters that should be populated in the response. 7 Extract registration_access_token and registration_client_uri response parameters, for use in retrieval of the newly registered client. 8 Retrieve the client using the registration_access_token and registration_client_uri . 9 After client retrieval, assert on the client metadata parameters that should be populated in the response. 10 Sample Client Registration Request(https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationRequest) using WebClient . 11 Sample Client Read Request(https://openid.net/specs/openid-connect-registration-1_0.html#ReadRequest) using WebClient . The Client Read Response(https://openid.net/specs/openid-connect-registration-1_0.html#ReadResponse) should contain the same client metadata parameters as the Client Registration Response(https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationResponse) , except the registration_access_token parameter."
