"url","content"
"https://docs.spring.io/spring-cloud-netflix/reference/index.html","Spring Cloud Netflix: This project provides Netflix OSS integrations for Spring Boot apps through autoconfiguration and binding to the Spring Environment and other Spring programming model idioms. With a few simple annotations you can quickly enable and configure the common patterns inside your application and build large distributed systems with battle-tested Netflix components. The patterns provided include Service Discovery (Eureka)."
"https://docs.spring.io/spring-cloud-netflix/reference/spring-cloud-netflix.html","Spring Cloud Netflix Features: Service Discovery: Eureka Clients: Service Discovery is one of the key tenets of a microservice-based architecture. Trying to hand-configure each client or some form of convention can be difficult to do and can be brittle. Eureka is the Netflix Service Discovery Server and Client. The server can be configured and deployed to be highly available, with each server replicating state about the registered services to the others. How to Include Eureka Client: To include the Eureka Client in your project, use the starter with a group ID of org.springframework.cloud and an artifact ID of spring-cloud-starter-netflix-eureka-client . See the Spring Cloud Project page(https://projects.spring.io/spring-cloud/) for details on setting up your build system with the current Spring Cloud Release Train. Registering with Eureka: When a client registers with Eureka, it provides meta-data about itself — such as host, port, health indicator URL, home page, and other details. Eureka receives heartbeat messages from each instance belonging to a service. If the heartbeat fails over a configurable timetable, the instance is normally removed from the registry. The following example shows a minimal Eureka client application: @SpringBootApplication @RestController public class Application { @RequestMapping(""/"") public String home() { return ""Hello world""; } public static void main(String[] args) { new SpringApplicationBuilder(Application.class).web(true).run(args); } } Note that the preceding example shows a normal Spring Boot(https://projects.spring.io/spring-boot/) application. By having spring-cloud-starter-netflix-eureka-client on the classpath, your application automatically registers with the Eureka Server. Configuration is required to locate the Eureka server, as shown in the following example: application.yml eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ In the preceding example, defaultZone is a magic string fallback value that provides the service URL for any client that does not express a preference (in other words, it is a useful default). The defaultZone property is case sensitive and requires camel case because the serviceUrl property is a Map<String, String> . Therefore, the defaultZone property does not follow the normal Spring Boot snake-case convention of default-zone . The default application name (that is, the service ID), virtual host, and non-secure port (taken from the Environment ) are ${spring.application.name} , ${spring.application.name} and ${server.port} , respectively. Having spring-cloud-starter-netflix-eureka-client on the classpath makes the app into both a Eureka “instance” (that is, it registers itself) and a “client” (it can query the registry to locate other services). The instance behaviour is driven by eureka.instance.* configuration keys, but the defaults are fine if you ensure that your application has a value for spring.application.name (this is the default for the Eureka service ID or VIP). See EurekaInstanceConfigBean(https://github.com/spring-cloud/spring-cloud-netflix/tree/docs-build/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java) and EurekaClientConfigBean(https://github.com/spring-cloud/spring-cloud-netflix/tree/docs-build/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java) for more details on the configurable options. To disable the Eureka Discovery Client, you can set eureka.client.enabled to false . Eureka Discovery Client will also be disabled when spring.cloud.discovery.enabled is set to false . Specifying the version of the Spring Cloud Netflix Eureka server as a path parameter is not currently supported. This means you cannot set the version in the context path ( eurekaServerURLContext ). Instead, you can include the version in the server URL (for example, you can set defaultZone: localhost:8761/eureka/v2(http://localhost:8761/eureka/v2) ). Authenticating with the Eureka Server: HTTP basic authentication is automatically added to your eureka client if one of the eureka.client.serviceUrl.defaultZone URLs has credentials embedded in it (curl style, as follows: user:password@localhost:8761/eureka(https://user:password@localhost:8761/eureka) ). For more complex needs, you can create a @Bean of type DiscoveryClientOptionalArgs and inject ClientFilter instances into it, all of which is applied to the calls from the client to the server. When Eureka server requires client side certificate for authentication, the client side certificate and trust store can be configured via properties, as shown in following example: application.yml eureka: client: tls: enabled: true key-store: <path-of-key-store> key-store-type: PKCS12 key-store-password: <key-store-password> key-password: <key-password> trust-store: <path-of-trust-store> trust-store-type: PKCS12 trust-store-password: <trust-store-password> The eureka.client.tls.enabled needs to be true to enable Eureka client side TLS. When eureka.client.tls.trust-store is omitted, a JVM default trust store is used. The default value for eureka.client.tls.key-store-type and eureka.client.tls.trust-store-type is PKCS12. When password properties are omitted, empty password is assumed. Because of a limitation in Eureka, it is not possible to support per-server basic auth credentials, so only the first set that are found is used. If you want to customize the RestTemplate used by the Eureka HTTP Client you may want to create a bean of EurekaClientHttpRequestFactorySupplier and provide your own logic for generating a ClientHttpRequestFactory instance. All default timeout-related properties for RestTemplate used by the Eureka HTTP Client are set to 3 minutes (in keeping with Apache HC5 default RequestConfig and SocketConfig ). Therefore, to specify the timeout values, you must specify the value directly with the properties in eureka.client.rest-template-timeout . (All timeout properties are in milliseconds.) application.yml eureka: client: rest-template-timeout: connect-timeout: 5000 connect-request-timeout: 8000 socket-timeout: 10000 Status Page and Health Indicator: The status page and health indicators for a Eureka instance default to /info and /health respectively, which are the default locations of useful endpoints in a Spring Boot Actuator application. You need to change these, even for an Actuator application if you use a non-default context path or servlet path (such as server.servletPath=/custom ). The following example shows the default values for the two settings: application.yml eureka: instance: statusPageUrlPath: ${server.servletPath}/info healthCheckUrlPath: ${server.servletPath}/health These links show up in the metadata that is consumed by clients and are used in some scenarios to decide whether to send requests to your application, so it is helpful if they are accurate. In Dalston it was also required to set the status and health check URLs when changing that management context path. This requirement was removed beginning in Edgware. Registering a Secure Application: If your app wants to be contacted over HTTPS, you can set two flags in the EurekaInstanceConfigBean : eureka.instance.[nonSecurePortEnabled]=[false] eureka.instance.[securePortEnabled]=[true] Doing so makes Eureka publish instance information that shows an explicit preference for secure communication. The Spring Cloud DiscoveryClient always returns a URI starting with https for a service configured this way. Similarly, when a service is configured this way, the Eureka (native) instance information has a secure health check URL. Because of the way Eureka works internally, it still publishes a non-secure URL for the status and home pages unless you also override those explicitly. You can use placeholders to configure the eureka instance URLs, as shown in the following example: application.yml eureka: instance: statusPageUrl: https://${eureka.hostname}/info healthCheckUrl: https://${eureka.hostname}/health homePageUrl: https://${eureka.hostname}/ (Note that ${eureka.hostname} is a native placeholder only available in later versions of Eureka. You could achieve the same thing with Spring placeholders as well — for example, by using ${eureka.instance.hostName} .) If your application runs behind a proxy, and the SSL termination is in the proxy (for example, if you run in Cloud Foundry or other platforms as a service), then you need to ensure that the proxy “forwarded” headers are intercepted and handled by the application. If the Tomcat container embedded in a Spring Boot application has explicit configuration for the 'X-Forwarded-\*` headers, this happens automatically. The links rendered by your app to itself being wrong (the wrong host, port, or protocol) is a sign that you got this configuration wrong. Eureka’s Health Checks: By default, Eureka uses the client heartbeat to determine if a client is up. Unless specified otherwise, the Discovery Client does not propagate the current health check status of the application, per the Spring Boot Actuator. Consequently, after successful registration, Eureka always announces that the application is in 'UP' state. This behavior can be altered by enabling Eureka health checks, which results in propagating application status to Eureka. As a consequence, every other application does not send traffic to applications in states other then 'UP'. The following example shows how to enable health checks for the client: application.yml eureka: client: healthcheck: enabled: true eureka.client.healthcheck.enabled=true should only be set in application.yml . Setting the value in bootstrap.yml causes undesirable side effects, such as registering in Eureka with an UNKNOWN status. If you require more control over the health checks, consider implementing your own com.netflix.appinfo.HealthCheckHandler . Eureka Metadata for Instances and Clients: It is worth spending a bit of time understanding how the Eureka metadata works, so you can use it in a way that makes sense in your platform. There is standard metadata for information such as hostname, IP address, port numbers, the status page, and health check. These are published in the service registry and used by clients to contact the services in a straightforward way. Additional metadata can be added to the instance registration in the eureka.instance.metadataMap , and this metadata is accessible in the remote clients. In general, additional metadata does not change the behavior of the client, unless the client is made aware of the meaning of the metadata. There are a couple of special cases, described later in this document, where Spring Cloud already assigns meaning to the metadata map. Using Eureka on Cloud Foundry: Cloud Foundry has a global router so that all instances of the same app have the same hostname (other PaaS solutions with a similar architecture have the same arrangement). This is not necessarily a barrier to using Eureka. However, if you use the router (recommended or even mandatory, depending on the way your platform was set up), you need to explicitly set the hostname and port numbers (secure or non-secure) so that they use the router. You might also want to use instance metadata so that you can distinguish between the instances on the client (for example, in a custom load balancer). By default, the eureka.instance.instanceId is vcap.application.instance_id , as shown in the following example: application.yml eureka: instance: hostname: ${vcap.application.uris[0]} nonSecurePort: 80 Depending on the way the security rules are set up in your Cloud Foundry instance, you might be able to register and use the IP address of the host VM for direct service-to-service calls. This feature is not yet available on Pivotal Web Services ( PWS(https://run.pivotal.io) ). Using Eureka on AWS: If the application is planned to be deployed to an AWS cloud, the Eureka instance must be configured to be AWS-aware. You can do so by customizing the EurekaInstanceConfigBean(https://github.com/spring-cloud/spring-cloud-netflix/tree/docs-build/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java) as follows: @Bean @Profile(""!default"") public EurekaInstanceConfigBean eurekaInstanceConfig(InetUtils inetUtils) { EurekaInstanceConfigBean bean = new EurekaInstanceConfigBean(inetUtils); AmazonInfo info = AmazonInfo.Builder.newBuilder().autoBuild(""eureka""); bean.setDataCenterInfo(info); return bean; } Changing the Eureka Instance ID: A vanilla Netflix Eureka instance is registered with an ID that is equal to its host name (that is, there is only one service per host). Spring Cloud Eureka provides a sensible default, which is defined as follows: ${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}} An example is myhost:myappname:8080 . By using Spring Cloud, you can override this value by providing a unique identifier in eureka.instance.instanceId , as shown in the following example: application.yml eureka: instance: instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}} With the metadata shown in the preceding example and multiple service instances deployed on localhost, the random value is inserted there to make the instance unique. In Cloud Foundry, the vcap.application.instance_id is populated automatically in a Spring Boot application, so the random value is not needed. Using the EurekaClient: Once you have an application that is a discovery client, you can use it to discover service instances from the Eureka Server(#spring-cloud-eureka-server) . One way to do so is to use the native com.netflix.discovery.EurekaClient (as opposed to the Spring Cloud DiscoveryClient ), as shown in the following example: @Autowired private EurekaClient discoveryClient; public String serviceUrl() { InstanceInfo instance = discoveryClient.getNextServerFromEureka(""STORES"", false); return instance.getHomePageUrl(); } Do not use the EurekaClient in a @PostConstruct method or in a @Scheduled method (or anywhere where the ApplicationContext might not be started yet). It is initialized in a SmartLifecycle (with phase=0 ), so the earliest you can rely on it being available is in another SmartLifecycle with a higher phase. Underlying HTTP clients: EurekaClient uses either RestTemplate , WebClient or JerseyClient under the hood. In order to use the EurekaClient , you need to have one of the supported HTTP clients on your classpath. To use RestTemplate , add spring-boot-starter-web to your dependencies. To use WebClient , add spring-boot-starter-webflux to your dependencies. If both RestTemplate and WebClient are on the classpath when eureka.client.webclient.enabled is set to true , WebClient is used. Otherwise, RestTemplate is used. If you wish to use Jersey instead, you need to add the Jersey dependencies to your classpath. The following example shows the dependencies you need to add: <dependencies> <dependency> <groupId>com.sun.jersey</groupId> <artifactId>jersey-client</artifactId> </dependency> <dependency> <groupId>com.sun.jersey</groupId> <artifactId>jersey-core</artifactId> </dependency> <dependency> <groupId>com.sun.jersey.contribs</groupId> <artifactId>jersey-apache-client4</artifactId> </dependency> </dependencies> If you have JerseyClient on the classpath but do not wish to use it in your EuerekaClient , make sure to set eureka.client.jersey.enabled to false . Alternatives to the Native Netflix EurekaClient: You need not use the raw Netflix EurekaClient . Also, it is usually more convenient to use it behind a wrapper of some sort. Spring Cloud has support for Feign(#spring-cloud-feign) (a REST client builder) and Spring Cloud LoadBalancer(https://docs.spring.io/spring-cloud-commons/reference/4.1/spring-cloud-commons/loadbalancer.html) through the logical Eureka service identifiers (VIPs) instead of physical URLs. You can also use the org.springframework.cloud.client.discovery.DiscoveryClient , which provides a simple API (not specific to Netflix) for discovery clients, as shown in the following example: @Autowired private DiscoveryClient discoveryClient; public String serviceUrl() { List<ServiceInstance> list = discoveryClient.getInstances(""STORES""); if (list != null && list.size() > 0 ) { return list.get(0).getUri(); } return null; } Why Is It so Slow to Register a Service?: Being an instance also involves a periodic heartbeat to the registry (through the client’s serviceUrl ) with a default duration of 30 seconds. A service is not available for discovery by clients until the instance, the server, and the client all have the same metadata in their local cache (so it could take 3 heartbeats). You can change the period by setting eureka.instance.leaseRenewalIntervalInSeconds . Setting it to a value of less than 30 speeds up the process of getting clients connected to other services. In production, it is probably better to stick with the default, because of internal computations in the server that make assumptions about the lease renewal period. Zones: If you have deployed Eureka clients to multiple zones, you may prefer that those clients use services within the same zone before trying services in another zone. To set that up, you need to configure your Eureka clients correctly. First, you need to make sure you have Eureka servers deployed to each zone and that they are peers of each other. See the section on zones and regions(#spring-cloud-eureka-server-zones-and-regions) for more information. Next, you need to tell Eureka which zone your service is in. You can do so by using the metadataMap property. For example, if service 1 is deployed to both zone 1 and zone 2 , you need to set the following Eureka properties in service 1 : Service 1 in Zone 1 eureka.instance.metadataMap.zone = zone1 eureka.client.preferSameZoneEureka = true Service 1 in Zone 2 eureka.instance.metadataMap.zone = zone2 eureka.client.preferSameZoneEureka = true Refreshing Eureka Clients: By default, the EurekaClient bean is refreshable, meaning the Eureka client properties can be changed and refreshed. When a refresh occurs clients will be unregistered from the Eureka server and there might be a brief moment of time where all instance of a given service are not available. One way to eliminate this from happening is to disable the ability to refresh Eureka clients. To do this set eureka.client.refresh.enable=false . Using Eureka with Spring Cloud LoadBalancer: We offer support for the Spring Cloud LoadBalancer ZonePreferenceServiceInstanceListSupplier . The zone value from the Eureka instance metadata ( eureka.instance.metadataMap.zone ) is used for setting the value of spring-cloud-loadbalancer-zone property that is used to filter service instances by zone. If that is missing and if the spring.cloud.loadbalancer.eureka.approximateZoneFromHostname flag is set to true , it can use the domain name from the server hostname as a proxy for the zone. If there is no other source of zone data, then a guess is made, based on the client configuration (as opposed to the instance configuration). We take eureka.client.availabilityZones , which is a map from region name to a list of zones, and pull out the first zone for the instance’s own region (that is, the eureka.client.region , which defaults to ""us-east-1"", for compatibility with native Netflix). AOT and Native Image Support: Spring Cloud Netflix Eureka Client integration supports Spring AOT transformations and native images, however, only with refresh mode disabled. If you want to run Eureka Client in AOT or native image modes, make sure to set spring.cloud.refresh.enabled to false Service Discovery: Eureka Server: This section describes how to set up a Eureka server. How to Include Eureka Server: To include Eureka Server in your project, use the starter with a group ID of org.springframework.cloud and an artifact ID of spring-cloud-starter-netflix-eureka-server . See the Spring Cloud Project page(https://projects.spring.io/spring-cloud/) for details on setting up your build system with the current Spring Cloud Release Train. If your project already uses Thymeleaf as its template engine, the Freemarker templates of the Eureka server may not be loaded correctly. In this case it is necessary to configure the template loader manually: application.yml spring: freemarker: template-loader-path: classpath:/templates/ prefer-file-system-access: false How to Run a Eureka Server: The following example shows a minimal Eureka server: @SpringBootApplication @EnableEurekaServer public class Application { public static void main(String[] args) { new SpringApplicationBuilder(Application.class).web(true).run(args); } } The server has a home page with a UI and HTTP API endpoints for the normal Eureka functionality under /eureka/* . The following links have some Eureka background reading: flux capacitor(https://github.com/cfregly/fluxcapacitor/wiki/NetflixOSS-FAQ#eureka-service-discovery-load-balancer) and google group discussion(https://groups.google.com/forum/?fromgroups#!topic/eureka_netflix/g3p2r7gHnN0) . Due to Gradle’s dependency resolution rules and the lack of a parent bom feature, depending on spring-cloud-starter-netflix-eureka-server can cause failures on application startup. To remedy this issue, add the Spring Boot Gradle plugin and import the Spring cloud starter parent bom as follows: build.gradle buildscript { dependencies { classpath(""org.springframework.boot:spring-boot-gradle-plugin:{spring-boot-docs-version}"") } } apply plugin: ""spring-boot"" dependencyManagement { imports { mavenBom ""org.springframework.cloud:spring-cloud-dependencies:{spring-cloud-version}"" } } defaultOpenForTrafficCount and its effect on EurekaServer warmup time: Netflix Eureka’s waitTimeInMsWhenSyncEmpty setting is not taken into account in Spring Cloud Eureka server at the beginning. In order to enable the warmup time, set eureka.server.defaultOpenForTrafficCount=0 . High Availability, Zones and Regions: The Eureka server does not have a back end store, but the service instances in the registry all have to send heartbeats to keep their registrations up to date (so this can be done in memory). Clients also have an in-memory cache of Eureka registrations (so they do not have to go to the registry for every request to a service). By default, every Eureka server is also a Eureka client and requires (at least one) service URL to locate a peer. If you do not provide it, the service runs and works, but it fills your logs with a lot of noise about not being able to register with the peer. Standalone Mode: The combination of the two caches (client and server) and the heartbeats make a standalone Eureka server fairly resilient to failure, as long as there is some sort of monitor or elastic runtime (such as Cloud Foundry) keeping it alive. In standalone mode, you might prefer to switch off the client side behavior so that it does not keep trying and failing to reach its peers. The following example shows how to switch off the client-side behavior: application.yml (Standalone Eureka Server) server: port: 8761 eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ Notice that the serviceUrl is pointing to the same host as the local instance. Peer Awareness: Eureka can be made even more resilient and available by running multiple instances and asking them to register with each other. In fact, this is the default behavior, so all you need to do to make it work is add a valid serviceUrl to a peer, as shown in the following example: application.yml (Two Peer Aware Eureka Servers) --- spring: profiles: peer1 eureka: instance: hostname: peer1 client: serviceUrl: defaultZone: https://peer2/eureka/ --- spring: profiles: peer2 eureka: instance: hostname: peer2 client: serviceUrl: defaultZone: https://peer1/eureka/ In the preceding example, we have a YAML file that can be used to run the same server on two hosts ( peer1 and peer2 ) by running it in different Spring profiles. You could use this configuration to test the peer awareness on a single host (there is not much value in doing that in production) by manipulating /etc/hosts to resolve the host names. In fact, the eureka.instance.hostname is not needed if you are running on a machine that knows its own hostname (by default, it is looked up by using java.net.InetAddress ). You can add multiple peers to a system, and, as long as they are all connected to each other by at least one edge, they synchronize the registrations amongst themselves. If the peers are physically separated (inside a data center or between multiple data centers), then the system can, in principle, survive “split-brain” type failures. You can add multiple peers to a system, and as long as they are all directly connected to each other, they will synchronize the registrations amongst themselves. application.yml (Three Peer Aware Eureka Servers) eureka: client: serviceUrl: defaultZone: https://peer1/eureka/,http://peer2/eureka/,http://peer3/eureka/ --- spring: profiles: peer1 eureka: instance: hostname: peer1 --- spring: profiles: peer2 eureka: instance: hostname: peer2 --- spring: profiles: peer3 eureka: instance: hostname: peer3 When to Prefer IP Address: In some cases, it is preferable for Eureka to advertise the IP addresses of services rather than the hostname. Set eureka.instance.preferIpAddress to true and, when the application registers with eureka, it uses its IP address rather than its hostname. If the hostname cannot be determined by Java, then the IP address is sent to Eureka. Only explict way of setting the hostname is by setting eureka.instance.hostname property. You can set your hostname at the run-time by using an environment variable — for example, eureka.instance.hostname=${HOST_NAME} . Securing The Eureka Server: You can secure your Eureka server simply by adding Spring Security to your server’s classpath via spring-boot-starter-security . By default, when Spring Security is on the classpath it will require that a valid CSRF token be sent with every request to the app. Eureka clients will not generally possess a valid cross site request forgery (CSRF) token you will need to disable this requirement for the /eureka/** endpoints. For example: @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.authorizeHttpRequests((authz) -> authz .anyRequest().authenticated()) .httpBasic(withDefaults()); http.csrf().ignoringRequestMatchers(""/eureka/**""); return http.build(); } For more information on CSRF see the Spring Security documentation(https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf) . A demo Eureka Server can be found in the Spring Cloud Samples repo(https://github.com/spring-cloud-samples/eureka/tree/Eureka-With-Security-4.x) . JDK 11 Support: The JAXB modules which the Eureka server depends upon were removed in JDK 11. If you intend to use JDK 11 when running a Eureka server you must include these dependencies in your POM or Gradle file. <dependency> <groupId>org.glassfish.jaxb</groupId> <artifactId>jaxb-runtime</artifactId> </dependency> AOT and Native Image Support: Spring Cloud Netflix Eureka Server does not support Spring AOT transformations or native images. Metrics: EurekaInstanceMonitor listens to events related to Eureka instance registration and creates/updates Gauge`s for Eureka instance information in Micrometer’s `MeterRegistry . By default, this behavior is disabled. If you want to enable it, you need to set eureka.server.metrics.enabled to true . By default, the Gauge`s are named `eureka.server.instances and have the following tags: application : application name status : instance status ( UP , DOWN , STARTING , OUT_OF_SERVICE , UNKNOWN , see: com.netflix.appinfo.InstanceInfo.InstanceStatus ) You can add additional tags by injecting your own implementation of EurekaInstanceTagsProvider . Configuration properties: To see the list of all Spring Cloud Netflix related configuration properties please check the Appendix page(appendix.html) ."
"https://docs.spring.io/spring-cloud-netflix/reference/appendix.html","Common application properties: Various properties can be specified inside your application.properties file, inside your application.yml file, or as command line switches. This appendix provides a list of common Spring Cloud Netflix properties and references to the underlying classes that consume them. Property contributions can come from additional jar files on your classpath, so you should not consider this an exhaustive list. Also, you can define your own properties. Section Summary: Configuration Properties(configprops.html)"
"https://docs.spring.io/spring-cloud-netflix/reference/configprops.html","Configuration Properties: Below you can find a list of configuration properties. Name Default Description eureka.client.allow-redirects false Indicates whether server can redirect a client request to a backup server/cluster. If set to false, the server will handle the request directly, If set to true, it may send HTTP redirect to the client, with a new server location. eureka.client.availability-zones Gets the list of availability zones (used in AWS data centers) for the region in which this instance resides. The changes are effective at runtime at the next registry fetch cycle as specified by registryFetchIntervalSeconds. eureka.client.backup-registry-impl Gets the name of the implementation which implements BackupRegistry to fetch the registry information as a fallback option for only the first time when the eureka client starts. This may be needed for applications which needs additional resiliency for registry information without which it cannot operate. eureka.client.cache-refresh-executor-exponential-back-off-bound 10 Cache refresh executor exponential back off related property. It is a maximum multiplier value for retry delay, in case where a sequence of timeouts occurred. eureka.client.cache-refresh-executor-thread-pool-size 2 The thread pool size for the cacheRefreshExecutor to initialise with. eureka.client.client-data-accept EurekaAccept name for client data accept. eureka.client.decoder-name This is a transient config and once the latest codecs are stable, can be removed (as there will only be one). eureka.client.disable-delta false Indicates whether the eureka client should disable fetching of delta and should rather resort to getting the full registry information. Note that the delta fetches can reduce the traffic tremendously, because the rate of change with the eureka server is normally much lower than the rate of fetches. The changes are effective at runtime at the next registry fetch cycle as specified by registryFetchIntervalSeconds eureka.client.dollar-replacement _- Get a replacement string for Dollar sign <code>$</code> during serializing/deserializing information in eureka server. eureka.client.enabled true Flag to indicate that the Eureka client is enabled. eureka.client.encoder-name This is a transient config and once the latest codecs are stable, can be removed (as there will only be one). eureka.client.escape-char-replacement __ Get a replacement string for underscore sign <code>_</code> during serializing/ deserializing information in eureka server. eureka.client.eureka-connection-idle-timeout-seconds 30 Indicates how much time (in seconds) that the HTTP connections to eureka server can stay idle before it can be closed. In the AWS environment, it is recommended that the values is 30 seconds or less, since the firewall cleans up the connection information after a few mins leaving the connection hanging in limbo. eureka.client.eureka-server-connect-timeout-seconds 5 Indicates how long to wait (in seconds) before a connection to eureka server needs to timeout. Note that the connections in the client are pooled by {@link HttpClient} and this setting affects the actual connection creation and also the wait time to get the connection from the pool. eureka.client.eureka-server-d-n-s-name Gets the DNS name to be queried to get the list of eureka servers.This information is not required if the contract returns the service urls by implementing serviceUrls. The DNS mechanism is used when useDnsForFetchingServiceUrls is set to true and the eureka client expects the DNS to configured a certain way so that it can fetch changing eureka servers dynamically. The changes are effective at runtime. eureka.client.eureka-server-port Gets the port to be used to construct the service url to contact eureka server when the list of eureka servers come from the DNS.This information is not required if the contract returns the service urls eurekaServerServiceUrls(String). The DNS mechanism is used when useDnsForFetchingServiceUrls is set to true and the eureka client expects the DNS to configured a certain way so that it can fetch changing eureka servers dynamically. The changes are effective at runtime. eureka.client.eureka-server-read-timeout-seconds 8 Indicates how long to wait (in seconds) before a read from eureka server needs to timeout. eureka.client.eureka-server-total-connections 200 Gets the total number of connections that is allowed from eureka client to all eureka servers. eureka.client.eureka-server-total-connections-per-host 50 Gets the total number of connections that is allowed from eureka client to a eureka server host. eureka.client.eureka-server-u-r-l-context Gets the URL context to be used to construct the service url to contact eureka server when the list of eureka servers come from the DNS. This information is not required if the contract returns the service urls from eurekaServerServiceUrls. The DNS mechanism is used when useDnsForFetchingServiceUrls is set to true and the eureka client expects the DNS to configured a certain way so that it can fetch changing eureka servers dynamically. The changes are effective at runtime. eureka.client.eureka-service-url-poll-interval-seconds 0 Indicates how often(in seconds) to poll for changes to eureka server information. Eureka servers could be added or removed and this setting controls how soon the eureka clients should know about it. eureka.client.fetch-registry true Indicates whether this client should fetch eureka registry information from eureka server. eureka.client.fetch-remote-regions-registry Comma separated list of regions for which the eureka registry information will be fetched. It is mandatory to define the availability zones for each of these regions as returned by availabilityZones. Failing to do so, will result in failure of discovery client startup. eureka.client.filter-only-up-instances true Indicates whether to get the applications after filtering the applications for instances with only InstanceStatus UP states. eureka.client.g-zip-content true Indicates whether the content fetched from eureka server has to be compressed whenever it is supported by the server. The registry information from the eureka server is compressed for optimum network traffic. eureka.client.healthcheck.enabled true Enables the Eureka health check handler. eureka.client.heartbeat-executor-exponential-back-off-bound 10 Heartbeat executor exponential back off related property. It is a maximum multiplier value for retry delay, in case where a sequence of timeouts occurred. eureka.client.heartbeat-executor-thread-pool-size 2 The thread pool size for the heartbeatExecutor to initialise with. eureka.client.initial-instance-info-replication-interval-seconds 40 Indicates how long initially (in seconds) to replicate instance info to the eureka server. eureka.client.instance-info-replication-interval-seconds 30 Indicates how often(in seconds) to replicate instance changes to be replicated to the eureka server. eureka.client.log-delta-diff false Indicates whether to log differences between the eureka server and the eureka client in terms of registry information. Eureka client tries to retrieve only delta changes from eureka server to minimize network traffic. After receiving the deltas, eureka client reconciles the information from the server to verify it has not missed out some information. Reconciliation failures could happen when the client has had network issues communicating to server.If the reconciliation fails, eureka client gets the full registry information. While getting the full registry information, the eureka client can log the differences between the client and the server and this setting controls that. The changes are effective at runtime at the next registry fetch cycle as specified by registryFetchIntervalSecondsr eureka.client.on-demand-update-status-change true If set to true, local status updates via ApplicationInfoManager will trigger on-demand (but rate limited) register/updates to remote eureka servers. eureka.client.order 0 Order of the discovery client used by CompositeDiscoveryClient for sorting available clients. eureka.client.prefer-same-zone-eureka true Indicates whether or not this instance should try to use the eureka server in the same zone for latency and/or other reason. Ideally eureka clients are configured to talk to servers in the same zone The changes are effective at runtime at the next registry fetch cycle as specified by registryFetchIntervalSeconds eureka.client.property-resolver eureka.client.proxy-host Gets the proxy host to eureka server if any. eureka.client.proxy-password Gets the proxy password if any. eureka.client.proxy-port Gets the proxy port to eureka server if any. eureka.client.proxy-user-name Gets the proxy user name if any. eureka.client.refresh.enable true Determines whether the EurekaClient instance can be refreshed or not(If disabled none of the Eureka client properties will be refreshable). eureka.client.region us-east-1 Gets the region (used in AWS datacenters) where this instance resides. eureka.client.register-with-eureka true Indicates whether or not this instance should register its information with eureka server for discovery by others. In some cases, you do not want your instances to be discovered whereas you just want do discover other instances. eureka.client.registry-fetch-interval-seconds 30 Indicates how often(in seconds) to fetch the registry information from the eureka server. eureka.client.registry-refresh-single-vip-address Indicates whether the client is only interested in the registry information for a single VIP. eureka.client.rest-template-timeout.connect-request-timeout 0 eureka.client.rest-template-timeout.connect-timeout 0 Default values are set to 180000, in keeping with {@link RequestConfig} and {@link SocketConfig} defaults. eureka.client.rest-template-timeout.socket-timeout 0 eureka.client.service-url Map of availability zone to list of fully qualified URLs to communicate with eureka server. Each value can be a single URL or a comma separated list of alternative locations. Typically the eureka server URLs carry protocol,host,port,context and version information if any. Example: ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/(https://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/) The changes are effective at runtime at the next service url refresh cycle as specified by eurekaServiceUrlPollIntervalSeconds. eureka.client.should-enforce-registration-at-init false Indicates whether the client should enforce registration during initialization. Defaults to false. eureka.client.should-unregister-on-shutdown true Indicates whether the client should explicitly unregister itself from the remote server on client shutdown. eureka.client.tls.enabled eureka.client.tls.key-password eureka.client.tls.key-store eureka.client.tls.key-store-password eureka.client.tls.key-store-type eureka.client.tls.trust-store eureka.client.tls.trust-store-password eureka.client.tls.trust-store-type eureka.client.use-dns-for-fetching-service-urls false Indicates whether the eureka client should use the DNS mechanism to fetch a list of eureka servers to talk to. When the DNS name is updated to have additional servers, that information is used immediately after the eureka client polls for that information as specified in eurekaServiceUrlPollIntervalSeconds. Alternatively, the service urls can be returned serviceUrls, but the users should implement their own mechanism to return the updated list in case of changes. The changes are effective at runtime. eureka.client.webclient.enabled false Enables the use of WebClient for Eureka HTTP Client. eureka.dashboard.enabled true Flag to enable the Eureka dashboard. Default true. eureka.dashboard.path / The path to the Eureka dashboard (relative to the servlet path). Defaults to ""/"". eureka.datacenter default Eureka datacenter. Defaults to ""default"". eureka.environment test Eureka environment. Defaults to ""test"". eureka.instance.a-s-g-name Gets the AWS autoscaling group name associated with this instance. This information is specifically used in an AWS environment to automatically put an instance out of service after the instance is launched and it has been disabled for traffic.. eureka.instance.app-group-name Get the name of the application group to be registered with eureka. eureka.instance.appname unknown Get the name of the application to be registered with eureka. eureka.instance.async-client-initialization false If true the EurekaClient will be initialized asynchronously when the InstanceRegistry bean is created. eureka.instance.data-center-info Returns the data center this instance is deployed. This information is used to get some AWS specific instance information if the instance is deployed in AWS. eureka.instance.default-address-resolution-order [] eureka.instance.environment eureka.instance.health-check-url Gets the absolute health check page URL for this instance. The users can provide the healthCheckUrlPath if the health check page resides in the same instance talking to eureka, else in the cases where the instance is a proxy for some other server, users can provide the full URL. If the full URL is provided it takes precedence. <p> It is normally used for making educated decisions based on the health of the instance - for example, it can be used to determine whether to proceed deployments to an entire farm or stop the deployments without causing further damage. The full URL should follow the format ${eureka.hostname}:7001/(http://${eureka.hostname}:7001/) where the value ${eureka.hostname} is replaced at runtime. eureka.instance.health-check-url-path Gets the relative health check URL path for this instance. The health check page URL is then constructed out of the hostname and the type of communication - secure or unsecure as specified in securePort and nonSecurePort. It is normally used for making educated decisions based on the health of the instance - for example, it can be used to determine whether to proceed deployments to an entire farm or stop the deployments without causing further damage. eureka.instance.home-page-url Gets the absolute home page URL for this instance. The users can provide the homePageUrlPath if the home page resides in the same instance talking to eureka, else in the cases where the instance is a proxy for some other server, users can provide the full URL. If the full URL is provided it takes precedence. It is normally used for informational purposes for other services to use it as a landing page. The full URL should follow the format ${eureka.hostname}:7001/(http://${eureka.hostname}:7001/) where the value ${eureka.hostname} is replaced at runtime. eureka.instance.home-page-url-path / Gets the relative home page URL Path for this instance. The home page URL is then constructed out of the hostName and the type of communication - secure or unsecure. It is normally used for informational purposes for other services to use it as a landing page. eureka.instance.hostname The hostname if it can be determined at configuration time (otherwise it will be guessed from OS primitives). eureka.instance.initial-status Initial status to register with remote Eureka server. eureka.instance.instance-enabled-onit false Indicates whether the instance should be enabled for taking traffic as soon as it is registered with eureka. Sometimes the application might need to do some pre-processing before it is ready to take traffic. eureka.instance.instance-id Get the unique Id (within the scope of the appName) of this instance to be registered with eureka. eureka.instance.ip-address Get the IPAdress of the instance. This information is for academic purposes only as the communication from other instances primarily happen using the information supplied in {@link #getHostName(boolean)}. eureka.instance.lease-expiration-duration-in-seconds 90 Indicates the time in seconds that the eureka server waits since it received the last heartbeat before it can remove this instance from its view and there by disallowing traffic to this instance. Setting this value too long could mean that the traffic could be routed to the instance even though the instance is not alive. Setting this value too small could mean, the instance may be taken out of traffic because of temporary network glitches.This value to be set to atleast higher than the value specified in leaseRenewalIntervalInSeconds. eureka.instance.lease-renewal-interval-in-seconds 30 Indicates how often (in seconds) the eureka client needs to send heartbeats to eureka server to indicate that it is still alive. If the heartbeats are not received for the period specified in leaseExpirationDurationInSeconds, eureka server will remove the instance from its view, there by disallowing traffic to this instance. Note that the instance could still not take traffic if it implements HealthCheckCallback and then decides to make itself unavailable. eureka.instance.metadata-map Gets the metadata name/value pairs associated with this instance. This information is sent to eureka server and can be used by other instances. eureka.instance.metadata-map.weight 1 The weight of service instance for weighted load balancing. eureka.instance.namespace eureka Get the namespace used to find properties. Ignored in Spring Cloud. eureka.instance.non-secure-port 80 Get the non-secure port on which the instance should receive traffic. eureka.instance.non-secure-port-enabled true Indicates whether the non-secure port should be enabled for traffic or not. eureka.instance.prefer-ip-address false Flag to say that, when guessing a hostname, the IP address of the server should be used in preference to the hostname reported by the OS. eureka.instance.registry.default-open-for-traffic-count 1 Value used in determining when leases are cancelled, default to 1 for standalone. Should be set to 0 for peer replicated eurekas eureka.instance.registry.expected-number-of-clients-sending-renews 1 eureka.instance.secure-health-check-url Gets the absolute secure health check page URL for this instance. The users can provide the secureHealthCheckUrl if the health check page resides in the same instance talking to eureka, else in the cases where the instance is a proxy for some other server, users can provide the full URL. If the full URL is provided it takes precedence. <p> It is normally used for making educated decisions based on the health of the instance - for example, it can be used to determine whether to proceed deployments to an entire farm or stop the deployments without causing further damage. The full URL should follow the format ${eureka.hostname}:7001/(http://${eureka.hostname}:7001/) where the value ${eureka.hostname} is replaced at runtime. eureka.instance.secure-port 443 Get the Secure port on which the instance should receive traffic. eureka.instance.secure-port-enabled false Indicates whether the secure port should be enabled for traffic or not. eureka.instance.secure-virtual-host-name unknown Gets the secure virtual host name defined for this instance. This is typically the way other instance would find this instance by using the secure virtual host name.Think of this as similar to the fully qualified domain name, that the users of your services will need to find this instance. eureka.instance.status-page-url Gets the absolute status page URL path for this instance. The users can provide the statusPageUrlPath if the status page resides in the same instance talking to eureka, else in the cases where the instance is a proxy for some other server, users can provide the full URL. If the full URL is provided it takes precedence. It is normally used for informational purposes for other services to find about the status of this instance. Users can provide a simple HTML indicating what is the current status of the instance. eureka.instance.status-page-url-path Gets the relative status page URL path for this instance. The status page URL is then constructed out of the hostName and the type of communication - secure or unsecure as specified in securePort and nonSecurePort. It is normally used for informational purposes for other services to find about the status of this instance. Users can provide a simple HTML indicating what is the current status of the instance. eureka.instance.virtual-host-name unknown Gets the virtual host name defined for this instance. This is typically the way other instance would find this instance by using the virtual host name.Think of this as similar to the fully qualified domain name, that the users of your services will need to find this instance. eureka.server.a-s-g-cache-expiry-timeout-ms 0 eureka.server.a-s-g-query-timeout-ms 300 eureka.server.a-s-g-update-interval-ms 0 eureka.server.a-w-s-access-id eureka.server.a-w-s-secret-key eureka.server.batch-replication false eureka.server.binding-strategy eureka.server.delta-retention-timer-interval-in-ms 0 eureka.server.disable-delta false eureka.server.disable-delta-for-remote-regions false eureka.server.disable-transparent-fallback-to-other-region false eureka.server.e-i-p-bind-rebind-retries 3 eureka.server.e-i-p-binding-retry-interval-ms 0 eureka.server.e-i-p-binding-retry-interval-ms-when-unbound 0 eureka.server.enable-replicated-request-compression false eureka.server.enable-self-preservation true eureka.server.eviction-interval-timer-in-ms 0 eureka.server.expected-client-renewal-interval-seconds 30 eureka.server.g-zip-content-from-remote-region true eureka.server.initial-capacity-of-response-cache 1000 eureka.server.json-codec-name eureka.server.list-auto-scaling-groups-role-name ListAutoScalingGroups eureka.server.log-identity-headers true eureka.server.max-elements-in-peer-replication-pool 10000 eureka.server.max-elements-in-status-replication-pool 10000 eureka.server.max-idle-thread-age-in-minutes-for-peer-replication 15 eureka.server.max-idle-thread-in-minutes-age-for-status-replication 10 eureka.server.max-threads-for-peer-replication 20 eureka.server.max-threads-for-status-replication 1 eureka.server.max-time-for-replication 30000 eureka.server.metrics.enabled false Indicates whether the metrics should be enabled for eureka instances. eureka.server.min-available-instances-for-peer-replication -1 eureka.server.min-threads-for-peer-replication 5 eureka.server.min-threads-for-status-replication 1 eureka.server.my-url eureka.server.number-of-replication-retries 5 eureka.server.peer-eureka-nodes-update-interval-ms 0 eureka.server.peer-eureka-status-refresh-time-interval-ms 0 eureka.server.peer-node-connect-timeout-ms 200 eureka.server.peer-node-connection-idle-timeout-seconds 30 eureka.server.peer-node-read-timeout-ms 200 eureka.server.peer-node-total-connections 1000 eureka.server.peer-node-total-connections-per-host 500 eureka.server.prime-aws-replica-connections true eureka.server.property-resolver eureka.server.rate-limiter-burst-size 10 eureka.server.rate-limiter-enabled false eureka.server.rate-limiter-full-fetch-average-rate 100 eureka.server.rate-limiter-privileged-clients eureka.server.rate-limiter-registry-fetch-average-rate 500 eureka.server.rate-limiter-throttle-standard-clients false eureka.server.registry-sync-retries 0 eureka.server.registry-sync-retry-wait-ms 0 eureka.server.remote-region-app-whitelist eureka.server.remote-region-connect-timeout-ms 1000 eureka.server.remote-region-connection-idle-timeout-seconds 30 eureka.server.remote-region-fetch-thread-pool-size 20 eureka.server.remote-region-read-timeout-ms 1000 eureka.server.remote-region-registry-fetch-interval 30 eureka.server.remote-region-total-connections 1000 eureka.server.remote-region-total-connections-per-host 500 eureka.server.remote-region-trust-store eureka.server.remote-region-trust-store-password changeit eureka.server.remote-region-urls eureka.server.remote-region-urls-with-name eureka.server.renewal-percent-threshold 0.85 eureka.server.renewal-threshold-update-interval-ms 0 eureka.server.response-cache-auto-expiration-in-seconds 180 eureka.server.response-cache-update-interval-ms 0 eureka.server.retention-time-in-m-s-in-delta-queue 0 eureka.server.route53-bind-rebind-retries 3 eureka.server.route53-binding-retry-interval-ms 0 eureka.server.route53-domain-t-t-l 30 eureka.server.sync-when-timestamp-differs true eureka.server.use-read-only-response-cache true eureka.server.wait-time-in-ms-when-sync-empty 0 eureka.server.xml-codec-name spring.cloud.compatibility-verifier.compatible-boot-versions Default accepted versions for the Spring Boot dependency. You can set {@code x} for the patch version if you don’t want to specify a concrete value. Example: {@code 3.4.x} spring.cloud.compatibility-verifier.enabled false Enables creation of Spring Cloud compatibility verification. spring.cloud.config.allow-override true Flag to indicate that {@link #isOverrideSystemProperties() systemPropertiesOverride} can be used. Set to false to prevent users from changing the default accidentally. Default true. spring.cloud.config.initialize-on-context-refresh false Flag to initialize bootstrap configuration on context refresh event. Default false. spring.cloud.config.override-none false Flag to indicate that when {@link #setAllowOverride(boolean) allowOverride} is true, external properties should take lowest priority and should not override any existing property sources (including local config files). Default false. This will only have an effect when using config first bootstrap. spring.cloud.config.override-system-properties true Flag to indicate that the external properties should override system properties. Default true. spring.cloud.decrypt-environment-post-processor.enabled true Enable the DecryptEnvironmentPostProcessor. spring.cloud.discovery.client.composite-indicator.enabled true Enables discovery client composite health indicator. spring.cloud.discovery.client.health-indicator.enabled true spring.cloud.discovery.client.health-indicator.include-description false spring.cloud.discovery.client.health-indicator.use-services-query true Whether or not the indicator should use {@link DiscoveryClient#getServices} to check its health. When set to {@code false} the indicator instead uses the lighter {@link DiscoveryClient#probe()}. This can be helpful in large deployments where the number of services returned makes the operation unnecessarily heavy. spring.cloud.discovery.client.simple.instances spring.cloud.discovery.client.simple.local.host spring.cloud.discovery.client.simple.local.instance-id spring.cloud.discovery.client.simple.local.metadata spring.cloud.discovery.client.simple.local.port 0 spring.cloud.discovery.client.simple.local.secure false spring.cloud.discovery.client.simple.local.service-id spring.cloud.discovery.client.simple.local.uri spring.cloud.discovery.client.simple.order spring.cloud.discovery.enabled true Enables discovery client health indicators. spring.cloud.features.enabled true Enables the features endpoint. spring.cloud.httpclientfactories.apache.enabled true Enables creation of Apache Http Client factory beans. spring.cloud.httpclientfactories.ok.enabled true Enables creation of OK Http Client factory beans. spring.cloud.hypermedia.refresh.fixed-delay 5000 spring.cloud.hypermedia.refresh.initial-delay 10000 spring.cloud.inetutils.default-hostname localhost The default hostname. Used in case of errors. spring.cloud.inetutils.default-ip-address 127.0.0.1 The default IP address. Used in case of errors. spring.cloud.inetutils.ignored-interfaces List of Java regular expressions for network interfaces that will be ignored. spring.cloud.inetutils.preferred-networks List of Java regular expressions for network addresses that will be preferred. spring.cloud.inetutils.timeout-seconds 1 Timeout, in seconds, for calculating hostname. spring.cloud.inetutils.use-only-site-local-interfaces false Whether to use only interfaces with site local addresses. See {@link InetAddress#isSiteLocalAddress()} for more details. spring.cloud.loadbalancer.cache.caffeine.spec The spec to use to create caches. See CaffeineSpec for more details on the spec format. spring.cloud.loadbalancer.cache.capacity 256 Initial cache capacity expressed as int. spring.cloud.loadbalancer.cache.enabled true Enables Spring Cloud LoadBalancer caching mechanism. spring.cloud.loadbalancer.cache.ttl 35s Time To Live - time counted from writing of the record, after which cache entries are expired, expressed as a {@link Duration}. The property {@link String} has to be in keeping with the appropriate syntax as specified in Spring Boot <code>StringToDurationConverter</code>. @see <a href= ""https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/convert/StringToDurationConverter.java"">StringToDurationConverter.java</a> spring.cloud.loadbalancer.call-get-with-request-on-delegates true If this flag is set to {@code true}, {@code ServiceInstanceListSupplier#get(Request request)} method will be implemented to call {@code delegate.get(request)} in classes assignable from {@code DelegatingServiceInstanceListSupplier} that don’t already implement that method, with the exclusion of {@code CachingServiceInstanceListSupplier} and {@code HealthCheckServiceInstanceListSupplier}, which should be placed in the instance supplier hierarchy directly after the supplier performing instance retrieval over the network, before any request-based filtering is done, {@code true} by default. spring.cloud.loadbalancer.clients spring.cloud.loadbalancer.configurations default Enables a predefined LoadBalancer configuration. spring.cloud.loadbalancer.eager-load.clients Names of the clients. spring.cloud.loadbalancer.enabled true Enables Spring Cloud LoadBalancer. spring.cloud.loadbalancer.eureka.approximate-zone-from-hostname false Used to determine whether we should try to get the zone value from host name. spring.cloud.loadbalancer.health-check.initial-delay 0 Initial delay value for the HealthCheck scheduler. spring.cloud.loadbalancer.health-check.interval 25s Interval for rerunning the HealthCheck scheduler. spring.cloud.loadbalancer.health-check.interval 25s Interval for rerunning the HealthCheck scheduler. spring.cloud.loadbalancer.health-check.path Path at which the health-check request should be made. Can be set up per serviceId . A default value can be set up as well. If none is set up, /actuator/health will be used. spring.cloud.loadbalancer.health-check.port Path at which the health-check request should be made. If none is set, the port under which the requested service is available at the service instance. spring.cloud.loadbalancer.health-check.refetch-instances false Indicates whether the instances should be refetched by the HealthCheckServiceInstanceListSupplier . This can be used if the instances can be updated and the underlying delegate does not provide an ongoing flux. spring.cloud.loadbalancer.health-check.refetch-instances-interval 25s Interval for refetching available service instances. spring.cloud.loadbalancer.health-check.repeat-health-check true Indicates whether health checks should keep repeating. It might be useful to set it to false if periodically refetching the instances, as every refetch will also trigger a healthcheck. spring.cloud.loadbalancer.health-check.update-results-list true Indicates whether the {@code healthCheckFlux} should emit on each alive {@link ServiceInstance} that has been retrieved. If set to {@code false}, the entire alive instances sequence is first collected into a list and only then emitted. spring.cloud.loadbalancer.hint Allows setting the value of <code>hint</code> that is passed on to the LoadBalancer request and can subsequently be used in {@link ReactiveLoadBalancer} implementations. spring.cloud.loadbalancer.hint-header-name X-SC-LB-Hint Allows setting the name of the header used for passing the hint for hint-based service instance filtering. spring.cloud.loadbalancer.retry.avoid-previous-instance true Enables wrapping ServiceInstanceListSupplier beans with RetryAwareServiceInstanceListSupplier if Spring-Retry is in the classpath. spring.cloud.loadbalancer.retry.backoff.enabled false Indicates whether Reactor Retry backoffs should be applied. spring.cloud.loadbalancer.retry.backoff.jitter 0.5 Used to set RetryBackoffSpec.jitter . spring.cloud.loadbalancer.retry.backoff.max-backoff Long.MAX ms Used to set RetryBackoffSpec.maxBackoff . spring.cloud.loadbalancer.retry.backoff.min-backoff 5 ms Used to set RetryBackoffSpec#minBackoff . spring.cloud.loadbalancer.retry.enabled true Enables LoadBalancer retries. spring.cloud.loadbalancer.retry.max-retries-on-next-service-instance 1 Number of retries to be executed on the next ServiceInstance . A ServiceInstance is chosen before each retry call. spring.cloud.loadbalancer.retry.max-retries-on-same-service-instance 0 Number of retries to be executed on the same ServiceInstance . spring.cloud.loadbalancer.retry.retry-on-all-exceptions false Indicates retries should be attempted for all exceptions, not only those specified in retryableExceptions . spring.cloud.loadbalancer.retry.retry-on-all-operations false Indicates retries should be attempted on operations other than HttpMethod.GET . spring.cloud.loadbalancer.retry.retryable-exceptions {} A Set of Throwable classes that should trigger a retry. spring.cloud.loadbalancer.retry.retryable-status-codes {} A Set of status codes that should trigger a retry. spring.cloud.loadbalancer.service-discovery.timeout String representation of Duration of the timeout for calls to service discovery. spring.cloud.loadbalancer.stats.micrometer.enabled false Enables Spring Cloud LoadBalancer Micrometer stats. spring.cloud.loadbalancer.sticky-session.add-service-instance-cookie false Indicates whether a cookie with the newly selected instance should be added by LoadBalancer. spring.cloud.loadbalancer.sticky-session.instance-id-cookie-name sc-lb-instance-id The name of the cookie holding the preferred instance id. spring.cloud.loadbalancer.subset.instance-id Instance id of deterministic subsetting. If not set, {@link IdUtils#getDefaultInstanceId(PropertyResolver)} will be used. spring.cloud.loadbalancer.subset.size 100 Max subset size of deterministic subsetting. spring.cloud.loadbalancer.x-forwarded.enabled false To Enable X-Forwarded Headers. spring.cloud.loadbalancer.zone Spring Cloud LoadBalancer zone. spring.cloud.refresh.additional-property-sources-to-retain Additional property sources to retain during a refresh. Typically only system property sources are retained. This property allows property sources, such as property sources created by EnvironmentPostProcessors to be retained as well. spring.cloud.refresh.enabled true Enables autoconfiguration for the refresh scope and associated features. spring.cloud.refresh.extra-refreshable true Additional class names for beans to post process into refresh scope. spring.cloud.refresh.never-refreshable true Comma separated list of class names for beans to never be refreshed or rebound. spring.cloud.refresh.on-restart.enabled true Enable refreshing context on start. spring.cloud.service-registry.auto-registration.enabled true Whether service auto-registration is enabled. Defaults to true. spring.cloud.service-registry.auto-registration.fail-fast false Whether startup fails if there is no AutoServiceRegistration. Defaults to false. spring.cloud.service-registry.auto-registration.register-management true Whether to register the management as a service. Defaults to true. spring.cloud.util.enabled true Enables creation of Spring Cloud utility beans."
