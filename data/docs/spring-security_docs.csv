"url","content"
"https://docs.spring.io/spring-security/reference/6.3/index.html","Spring Security: Spring Security is a framework that provides authentication(features/authentication/index.html) , authorization(features/authorization/index.html) , and protection against common attacks(features/exploits/index.html) . With first class support for securing both imperative(servlet/index.html) and reactive(reactive/index.html) applications, it is the de-facto standard for securing Spring-based applications. For a complete list of features, see the Features(features/index.html) section of the reference. Getting Started: If you are ready to start securing an application see the Getting Started sections for servlet(servlet/getting-started.html) and reactive(reactive/getting-started.html) . These sections will walk you through creating your first Spring Security applications. If you want to understand how Spring Security works, you can refer to the Architecture(servlet/architecture.html) section. If you have any questions, there is a wonderful community(community.html) that would love to help you!"
"https://docs.spring.io/spring-security/reference/6.3/prerequisites.html","Prerequisites: Spring Security requires a Java 17 or higher Runtime Environment. As Spring Security aims to operate in a self-contained manner, you do not need to place any special configuration files in your Java Runtime Environment. In particular, you need not configure a special Java Authentication and Authorization Service (JAAS) policy file or place Spring Security into common classpath locations. Similarly, if you use an EJB Container or Servlet Container, you need not put any special configuration files anywhere nor include Spring Security in a server classloader. All the required files are contained within your application. This design offers maximum deployment time flexibility, as you can copy your target artifact (be it a JAR, WAR, or EAR) from one system to another and it immediately works."
"https://docs.spring.io/spring-security/reference/6.3/community.html","Spring Security Community: Welcome to the Spring Security Community! This section discusses how you can make the most of our vast community. Getting Help: If you need help with Spring Security, we are here to help. The following are some of the best ways to get help: Read through this documentation. Try one of our many sample applications(samples.html#samples) . Ask a question on https://stackoverflow.com(https://stackoverflow.com/questions/tagged/spring-security) with the spring-security tag. Report bugs and enhancement requests at github.com/spring-projects/spring-security/issues(https://github.com/spring-projects/spring-security/issues) Becoming Involved: We welcome your involvement in the Spring Security project. There are many ways to contribute, including answering questions on Stack Overflow, writing new code, improving existing code, assisting with documentation, developing samples or tutorials, reporting bugs, or simply making suggestions. For more information, see our Contributing(https://github.com/spring-projects/spring-security/blob/main/CONTRIBUTING.adoc) documentation. Source Code: You can find Spring Security’s source code on GitHub at github.com/spring-projects/spring-security/(https://github.com/spring-projects/spring-security/) Apache 2 License: Spring Security is Open Source software released under the Apache 2.0 license(https://www.apache.org/licenses/LICENSE-2.0.html) . Social Media: You can follow @SpringSecurity(https://twitter.com/SpringSecurity) and the Spring Security team(https://twitter.com/SpringSecurity/lists/team) on Twitter to stay up to date with the latest news. You can also follow @SpringCentral(https://twitter.com/SpringCentral) to keep up to date with the entire Spring portfolio."
"https://docs.spring.io/spring-security/reference/6.3/whats-new.html","What’s New in Spring Security 6.3: Spring Security 6.3 provides a number of new features. Below are the highlights of the release, or you can view the release notes(https://github.com/spring-projects/spring-security/releases) for a detailed listing of each feature and bug fix. Passive JDK Serialization Support: When it comes to its support for JDK-serialized security components, Spring Security has historically been quite aggressive, supporting each serialization version for only one Spring Security minor version. This meant that if you had JDK-serialized security components, then they would need to be evacuated before upgrading to the next Spring Security version since they would no longer be deserializable. Now that Spring Security performs a minor release every six months, this became a much larger pain point. To address that, Spring Security now will maintain passivity with JDK serialization(https://spring.io/blog/2024/01/19/spring-security-6-3-adds-passive-jdk-serialization-deserialization-for) , like it does with JSON serialization, making for more seamless upgrades. Authorization: An ongoing theme for the last several releases has been to refactor and improve Spring Security’s authorization subsystem. Starting with replacing the AccessDecisionManager API with AuthorizationManager it’s now come to the point where we are able to add several exciting new features. Annotation Parameters - #14480: The first 6.3 feature is support for annotation parameters(https://github.com/spring-projects/spring-security/issues/14480) . Consider Spring Security’s support for meta-annotations(servlet/authorization/method-security.html#meta-annotations) like this one: Java Kotlin @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @PreAuthorize(""hasAuthority('SCOPE_message:read')"") public @interface HasMessageRead {} Kotlin @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @PreAuthorize(""hasAuthority('SCOPE_message:read')"") annotation class HasMessageRead Before this release, something like this is only helpful when it is used widely across the codebase. But now, you can add parameters(servlet/authorization/method-security.html#_templating_meta_annotation_expressions) like so: Java Kotlin @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @PreAuthorize(""hasAuthority('SCOPE_{scope}')"") public @interface HasScope { String scope(); } @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @PreAuthorize(""hasAuthority('SCOPE_{scope}')"") annotation class HasScope (val scope:String) making it possible to do things like this: Java Kotlin @HasScope(""message:read"") public String method() { ... } @HasScope(""message:read"") fun method(): String { ... } and apply your SpEL expression in several more places. Secure Return Values - #14596, #14597: Since the early days of Spring Security, you’ve been able to annotate Spring beans with @PreAuthorize and @PostAuthorize(servlet/authorization/method-security.html#use-preauthorize) . But controllers, services, and repositories are not the only things you care to secure. For example, what about a domain object Order where only admins should be able to call the Order#getPayment method? Now in 6.3, you can annotate those methods(https://github.com/spring-projects/spring-security/issues/14597) , too. First, annotate the getPayment method like you would a Spring bean: Java Kotlin public class Order { @HasScope(""payment:read"") Payment getPayment() { ... } } class Order { @HasScope(""payment:read"") fun getPayment(): Payment { ... } } And then annotate your Spring Data repository with @AuthorizeReturnObject(servlet/authorization/method-security.html#authorize-object) like so: Java Kotlin public interface OrderRepository implements CrudRepository<Order, String> { @AuthorizeReturnObject Optional<Order> findOrderById(String id); } interface OrderRepository : CrudRepository<Order, String> { @AuthorizeReturnObject fun findOrderById(id: String?): Optional<Order?>? } At that point, Spring Security will protect any Order returned from findOrderById by way of proxying the Order instance(https://github.com/spring-projects/spring-security/issues/14596) . Error Handling - #14598, #14600, #14601: In this release, you can also intercept and handle failure at the method level(https://github.com/spring-projects/spring-security/issues/14601) with its last new method security annotation. When you annotate a method with @HandleAuthorizationDenied(servlet/authorization/method-security.html#fallback-values-authorization-denied) like so: Java Kotlin public class Payment { @HandleAuthorizationDenied(handlerClass=Mask.class) @PreAuthorize(""hasAuthority('card:read')"") public String getCreditCardNumber() { ... } } class Payment { @HandleAuthorizationDenied(handlerClass=Mask.class) @PreAuthorize(""hasAuthority('card:read')"") fun getCreditCardNumber(): String { ... } } and publish a Mask bean: Java Kotlin @Component public class Mask implements MethodAuthorizationDeniedHandler { @Override public Object handleDeniedInvocation(MethodInvocation invocation, AuthorizationResult result) { return ""***""; } } @Component class Mask : MethodAuthorizationDeniedHandler { fun handleDeniedInvocation(invocation: MethodInvocation?, result: AuthorizationResult?): Any = ""***"" } then any unauthorized call to Payment#getCreditCardNumber will return *** instead of the number. You can see all these features at work together in the latest Spring Security Data sample(https://github.com/spring-projects/spring-security-samples/tree/main/servlet/spring-boot/java/data) . Compromised Password Checking - #7395: If you are going to let users pick passwords, it’s critical to ensure that such a password isn’t already compromised. Spring Security 6.3 makes this as simple as publishing a CompromisedPasswordChecker bean(features/authentication/password-storage.html#authentication-compromised-password-check) : Java Kotlin @Bean public CompromisedPasswordChecker compromisedPasswordChecker() { return new HaveIBeenPwnedRestApiPasswordChecker(); } @Bean fun compromisedPasswordChecker(): CompromisedPasswordChecker = HaveIBeenPwnedRestApiPasswordChecker() spring-security-rsa is now part of Spring Security - #14202: Since 2017, Spring Security has been undergoing a long-standing initiative to fold various Spring Security extensions into Spring Security proper. In 6.3, spring-security-rsa becomes the latest of these projects which will help the team maintain and add features to it, long-term. spring-security-rsa provides a number of handy BytesEncryptor(https://github.com/spring-projects/spring-security/blob/main/crypto/src/main/java/org/springframework/security/crypto/encrypt/RsaSecretEncryptor.java) implementations(https://github.com/spring-projects/spring-security/blob/main/crypto/src/main/java/org/springframework/security/crypto/encrypt/RsaRawEncryptor.java) as well as a simpler API for working with KeyStores(https://github.com/spring-projects/spring-security/blob/main/crypto/src/main/java/org/springframework/security/crypto/encrypt/KeyStoreKeyFactory.java) . OAuth 2.0 Token Exchange Grant - #5199: One of the most highly-voted OAuth 2.0 features(https://github.com/spring-projects/spring-security/issues/5199) in Spring Security is now in place in 6.3, which is the support for the OAuth 2.0 Token Exchange grant(https://datatracker.ietf.org/doc/html/rfc8693#section-2) . For any client configured for token exchange(servlet/oauth2/client/authorization-grants.html#token-exchange-grant-access-token) , you can activate it in Spring Security by adding a TokenExchangeAuthorizedClientProvider instance to your OAuth2AuthorizedClientManager like so: Java Kotlin @Bean public OAuth2AuthorizedClientProvider tokenExchange() { return new TokenExchangeOAuth2AuthorizedClientProvider(); } @Bean fun tokenExchange(): OAuth2AuthorizedClientProvider = TokenExchangeOAuth2AuthorizedClientProvider() and then use the @RegisteredOAuth2AuthorizedClient annotation(servlet/oauth2/client/authorized-clients.html#oauth2Client-registered-authorized-client) as per usual to retrieve the appropriate token with the expanded privileges your resource server needs. Additional Highlights: gh-14655(https://github.com/spring-projects/spring-security/pull/14655) - Add DelegatingAuthenticationConverter gh-6192(https://github.com/spring-projects/spring-security/issues/6192) - Add Concurrent Sessions Control on WebFlux ( docs(reactive/authentication/concurrent-sessions-control.html) ) gh-14193(https://github.com/spring-projects/spring-security/pull/14193) - Added support for CAS Gateway Authentication gh-13259(https://github.com/spring-projects/spring-security/issues/13259) - Customize when UserInfo is called gh-14168(https://github.com/spring-projects/spring-security/pull/14168) - Introduce Customizable AuthorizationFailureHandler in OAuth2AuthorizationRequestRedirectFilter gh-14672(https://github.com/spring-projects/spring-security/issues/14672) - Customize mapping the OidcUser from OidcUserRequest and OidcUserInfo gh-13763(https://github.com/spring-projects/spring-security/issues/13763) - Simplify configuration of reactive OAuth2 Client component model gh-14758(https://github.com/spring-projects/spring-security/issues/14758) - Update reactive OAuth2 docs landing page with examples ( docs(reactive/oauth2/index.html) ) gh-10538(https://github.com/spring-projects/spring-security/issues/10538) - Support Certificate-Bound JWT Access Token Validation gh-14265(https://github.com/spring-projects/spring-security/pull/14265) - Support Nested username in UserInfo response gh-14449(https://github.com/spring-projects/spring-security/pull/14265) - Add SecurityContext argument resolver gh-11440(https://github.com/spring-projects/spring-security/issues/11440) - Simplify Disabling application/x-www-form-urlencoded Encoding Client ID and Secret ( servlet docs(servlet/oauth2/client/client-authentication.html#_authenticate_using_client_secret_basic) , reactive docs(reactive/oauth2/client/client-authentication.html#_authenticate_using_client_secret_basic) ) And for an exhaustive list, please see the release notes for 6.3.0-RC1(https://github.com/spring-projects/spring-security/releases/tag/6.3.0-RC1) , 6.3.0-M3(https://github.com/spring-projects/spring-security/releases/tag/6.3.0-M3) , 6.3.0-M2(https://github.com/spring-projects/spring-security/releases/tag/6.3.0-M2) , and 6.3.0-M1(https://github.com/spring-projects/spring-security/releases/tag/6.3.0-M1) ."
"https://docs.spring.io/spring-security/reference/6.3/migration-7/index.html","Preparing for 7.0: While Spring Security 7.0 does not have a release date yet, it is important to start preparing for it now. This preparation guide is designed to summarize the biggest changes in Spring Security 7.0 and provide steps to prepare for them. It is important to keep your application up to date with the latest Spring Security 6 and Spring Boot 3 releases."
"https://docs.spring.io/spring-security/reference/6.3/migration-7/configuration.html","Configuration Migrations: The following steps relate to changes around how to configure HttpSecurity , WebSecurity and related components. Use the Lambda DSL: The Lambda DSL is present in Spring Security since version 5.2, and it allows HTTP security to be configured using lambdas. You may have seen this style of configuration in the Spring Security documentation or samples. Let us take a look at how a lambda configuration of HTTP security compares to the previous configuration style. Configuration using lambdas @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .requestMatchers(""/blog/**"").permitAll() .anyRequest().authenticated() ) .formLogin(formLogin -> formLogin .loginPage(""/login"") .permitAll() ) .rememberMe(Customizer.withDefaults()); return http.build(); } } Equivalent configuration without using lambdas @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests() .requestMatchers(""/blog/**"").permitAll() .anyRequest().authenticated() .and() .formLogin() .loginPage(""/login"") .permitAll() .and() .rememberMe(); return http.build(); } } The Lambda DSL is the preferred way to configure Spring Security, the prior configuration style will not be valid in Spring Security 7 where the usage of the Lambda DSL will be required. This has been done mainly for a couple of reasons: The previous way it was not clear what object was getting configured without knowing what the return type was. The deeper the nesting the more confusing it became. Even experienced users would think that their configuration was doing one thing when in fact, it was doing something else. Consistency. Many code bases switched between the two styles which caused inconsistencies that made understanding the configuration difficult and often led to misconfigurations. Lambda DSL Configuration Tips: When comparing the two samples above, you will notice some key differences: In the Lambda DSL there is no need to chain configuration options using the .and() method. The HttpSecurity instance is automatically returned for further configuration after the call to the lambda method. Customizer.withDefaults() enables a security feature using the defaults provided by Spring Security. This is a shortcut for the lambda expression it → {} . WebFlux Security: You may also configure WebFlux security using lambdas in a similar manner. Below is an example configuration using lambdas. WebFlux configuration using lambdas @Configuration @EnableWebFluxSecurity public class SecurityConfig { @Bean public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .pathMatchers(""/blog/**"").permitAll() .anyExchange().authenticated() ) .httpBasic(Customizer.withDefaults()) .formLogin(formLogin -> formLogin .loginPage(""/login"") ); return http.build(); } } Goals of the Lambda DSL: The Lambda DSL was created to accomplish to following goals: Automatic indentation makes the configuration more readable. There is no need to chain configuration options using .and() The Spring Security DSL has a similar configuration style to other Spring DSLs such as Spring Integration and Spring Cloud Gateway. Use .with() instead of .apply() for Custom DSLs: In versions prior to 6.2, if you had a custom DSL(../servlet/configuration/java.html#jc-custom-dsls) , you would apply it to the HttpSecurity using the HttpSecurity#apply(…​) method. However, starting from version 6.2, this method is deprecated and will be removed in 7.0 because it will no longer be possible to chain configurations using .and() once .and() is removed (see github.com/spring-projects/spring-security/issues/13067(https://github.com/spring-projects/spring-security/issues/13067) ). Instead, it is recommended to use the new .with(…​) method. For more information about how to use .with(…​) please refer to the Custom DSLs section(../servlet/configuration/java.html#jc-custom-dsls) ."
"https://docs.spring.io/spring-security/reference/6.3/migration-7/ldap.html","LDAP Migrations: The following steps relate to changes around how to configure the LDAP components and how to use an embedded LDAP server. Use UnboundId instead of ApacheDS: ApacheDS has not had a GA release for a considerable period, and its classes in Spring Security were deprecated in version 5.2(https://github.com/spring-projects/spring-security/pull/6376) . Consequently, support for ApacheDS will be discontinued in version 7.0. If you are currently using ApacheDS as an embedded LDAP server, we recommend migrating to UnboundId(https://ldap.com/unboundid-ldap-sdk-for-java/) . You can find instructions in this section(../servlet/authentication/passwords/ldap.html#servlet-authentication-ldap-embedded) that describe how to set up an embedded UnboundId LDAP server."
"https://docs.spring.io/spring-security/reference/6.3/migration/index.html","Migrating to 6.2: This guide provides instructions for migrating from Spring Security 6.1 to Spring Security 6.2. Update to Spring Security 6.2: When updating to a new minor version, it is important that you are already using the latest patch release of the previous minor version. For example, if you are upgrading to Spring Security 6.2, you should already be using the latest patch release of Spring Security 6.1. This makes it easier to identify any changes that may have been introduced in the new minor version. Therefore, the first step is to ensure you are on the latest patch release of Spring Boot 3.1. Next, you should ensure you are on the latest patch release of Spring Security 6.1. Typically, the latest patch release of Spring Boot uses the latest patch release of Spring Security. With those two steps complete, you can now update to Spring Security 6.2. Quick Reference: The following list provide a quick reference for the changes that are described in this guide. You are using method parameter names in @PreAuthorize, @PostAuthorize, or any other method security annotations(authorization.html#compile-with-parameters)"
"https://docs.spring.io/spring-security/reference/6.3/migration/authorization.html","Authorization Changes: The following sections relate to how to adapt to changes in the authorization support. Method Security: Compile With -parameters: Spring Framework 6.1 removes LocalVariableTableParameterNameDiscoverer(https://github.com/spring-projects/spring-framework/issues/29559) . This affects how @PreAuthorize and other method security(../servlet/authorization/method-security.html) annotations will process parameter names. If you are using method security annotations with parameter names, for example: Method security annotation using id parameter name @PreAuthorize(""@authz.checkPermission(#id, authentication)"") public void doSomething(Long id) { // ... } You must compile with -parameters to ensure that the parameter names are available at runtime. For more information about this, please visit the Upgrading to Spring Framework 6.1 page(https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-6.x#core-container) ."
"https://docs.spring.io/spring-security/reference/6.3/getting-spring-security.html","Getting Spring Security: This section describes how to get the Spring Security binaries. See Source Code(community.html#community-source) for how to obtain the source code. Release Numbering: Spring Security versions are formatted as MAJOR.MINOR.PATCH such that: MAJOR versions may contain breaking changes. Typically, these are done to provide improved security to match modern security practices. MINOR versions contain enhancements but are considered passive updates. PATCH level should be perfectly compatible, forwards and backwards, with the possible exception of changes that fix bugs. Usage with Maven: As most open source projects, Spring Security deploys its dependencies as Maven artifacts. The topics in this section describe how to consume Spring Security when using Maven. Spring Boot with Maven: Spring Boot provides a spring-boot-starter-security starter that aggregates Spring Security-related dependencies. The simplest and preferred way to use the starter is to use Spring Initializr(https://docs.spring.io/initializr/docs/current/reference/html/) by using an IDE integration in ( Eclipse(https://joshlong.com/jl/blogPost/tech_tip_geting_started_with_spring_boot.html) or IntelliJ(https://www.jetbrains.com/help/idea/spring-boot.html#d1489567e2) , NetBeans(https://github.com/AlexFalappa/nb-springboot/wiki/Quick-Tour) ) or through start.spring.io(https://start.spring.io) . Alternatively, you can manually add the starter, as the following example shows: pom.xml <dependencies> <!-- ... other dependency elements ... --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-security</artifactId> </dependency> </dependencies> Since Spring Boot provides a Maven BOM to manage dependency versions, you do not need to specify a version. If you wish to override the Spring Security version, you can do so by providing a Maven property: pom.xml <properties> <!-- ... --> <spring-security.version>6.3.3</spring-security.version> </properties> Since Spring Security makes breaking changes only in major releases, you can safely use a newer version of Spring Security with Spring Boot. However, at times, you may need to update the version of Spring Framework as well. You can do so by adding a Maven property: pom.xml <properties> <!-- ... --> <spring.version>6.1.12</spring.version> </properties> If you use additional features (such as LDAP, OAuth 2, and others), you need to also include the appropriate Project Modules and Dependencies(modules.html#modules) . Maven Without Spring Boot: When you use Spring Security without Spring Boot, the preferred way is to use Spring Security’s BOM to ensure that a consistent version of Spring Security is used throughout the entire project. The following example shows how to do so: pom.xml <dependencyManagement> <dependencies> <!-- ... other dependency elements ... --> <dependency> <groupId>org.springframework.security</groupId> <artifactId>spring-security-bom</artifactId> <version>{spring-security-version}</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> A minimal Spring Security Maven set of dependencies typically looks like the following example: pom.xml <dependencies> <!-- ... other dependency elements ... --> <dependency> <groupId>org.springframework.security</groupId> <artifactId>spring-security-web</artifactId> </dependency> <dependency> <groupId>org.springframework.security</groupId> <artifactId>spring-security-config</artifactId> </dependency> </dependencies> If you use additional features (such as LDAP, OAuth 2, and others), you need to also include the appropriate Project Modules and Dependencies(modules.html#modules) . Spring Security builds against Spring Framework 6.1.12 but should generally work with any newer version of Spring Framework 5.x. Many users are likely to run afoul of the fact that Spring Security’s transitive dependencies resolve Spring Framework 6.1.12, which can cause strange classpath problems. The easiest way to resolve this is to use the spring-framework-bom within the <dependencyManagement> section of your pom.xml : pom.xml <dependencyManagement> <dependencies> <!-- ... other dependency elements ... --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-framework-bom</artifactId> <version>6.1.12</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> The preceding example ensures that all the transitive dependencies of Spring Security use the Spring 6.1.12 modules. This approach uses Maven’s “bill of materials” (BOM) concept and is only available in Maven 2.0.9+. For additional details about how dependencies are resolved, see Maven’s Introduction to the Dependency Mechanism documentation(https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html) . Maven Repositories: All GA releases (that is, versions ending in .RELEASE) are deployed to Maven Central, so you need not declare additional Maven repositories in your pom. If you use a SNAPSHOT version, you need to ensure that you have the Spring Snapshot repository defined: pom.xml <repositories> <!-- ... possibly other repository elements ... --> <repository> <id>spring-snapshot</id> <name>Spring Snapshot Repository</name> <url>https://repo.spring.io/snapshot</url> </repository> </repositories> If you use a milestone or release candidate version, you need to ensure that you have the Spring Milestone repository defined, as the following example shows: pom.xml <repositories> <!-- ... possibly other repository elements ... --> <repository> <id>spring-milestone</id> <name>Spring Milestone Repository</name> <url>https://repo.spring.io/milestone</url> </repository> </repositories> Gradle: As most open source projects, Spring Security deploys its dependencies as Maven artifacts, which allows for first-class Gradle support. The following topics describe how to consume Spring Security when using Gradle. Spring Boot with Gradle: Spring Boot provides a spring-boot-starter-security starter that aggregates Spring Security related dependencies. The simplest and preferred method to use the starter is to use Spring Initializr(https://docs.spring.io/initializr/docs/current/reference/html/) by using an IDE integration in ( Eclipse(https://joshlong.com/jl/blogPost/tech_tip_geting_started_with_spring_boot.html) or IntelliJ(https://www.jetbrains.com/help/idea/spring-boot.html#d1489567e2) , NetBeans(https://github.com/AlexFalappa/nb-springboot/wiki/Quick-Tour) ) or through start.spring.io(https://start.spring.io) . Alternatively, you can manually add the starter: build.gradle dependencies { implementation ""org.springframework.boot:spring-boot-starter-security"" } Since Spring Boot provides a Maven BOM to manage dependency versions, you need not specify a version. If you wish to override the Spring Security version, you can do so by providing a Gradle property: build.gradle ext['spring-security.version']='6.3.3' Since Spring Security makes breaking changes only in major releases, you can safely use a newer version of Spring Security with Spring Boot. However, at times, you may need to update the version of Spring Framework as well. You can do so by adding a Gradle property: build.gradle ext['spring.version']='6.1.12' If you use additional features (such as LDAP, OAuth 2, and others), you need to also include the appropriate Project Modules and Dependencies(modules.html#modules) . Gradle Without Spring Boot: When you use Spring Security without Spring Boot, the preferred way is to use Spring Security’s BOM to ensure a consistent version of Spring Security is used throughout the entire project. You can do so by using the Dependency Management Plugin(https://github.com/spring-gradle-plugins/dependency-management-plugin) : build.gradle plugins { id ""io.spring.dependency-management"" version ""1.0.6.RELEASE"" } dependencyManagement { imports { mavenBom 'org.springframework.security:spring-security-bom:6.3.3' } } A minimal Spring Security Maven set of dependencies typically looks like the following: build.gradle dependencies { implementation ""org.springframework.security:spring-security-web"" implementation ""org.springframework.security:spring-security-config"" } If you use additional features (such as LDAP, OAuth 2, and others), you need to also include the appropriate Project Modules and Dependencies(modules.html#modules) . Spring Security builds against Spring Framework 6.1.12 but should generally work with any newer version of Spring Framework 5.x. Many users are likely to run afoul of the fact that Spring Security’s transitive dependencies resolve Spring Framework 6.1.12, which can cause strange classpath problems. The easiest way to resolve this is to use the spring-framework-bom within your dependencyManagement section of your build.gradle . You can do so by using the Dependency Management Plugin(https://github.com/spring-gradle-plugins/dependency-management-plugin) : build.gradle plugins { id ""io.spring.dependency-management"" version ""1.0.6.RELEASE"" } dependencyManagement { imports { mavenBom 'org.springframework:spring-framework-bom:6.1.12' } } The preceding example ensures that all the transitive dependencies of Spring Security use the Spring 6.1.12 modules. Gradle Repositories: All GA releases (that is, versions ending in .RELEASE) are deployed to Maven Central, so using the mavenCentral() repository is sufficient for GA releases. The following example shows how to do so: build.gradle repositories { mavenCentral() } If you use a SNAPSHOT version, you need to ensure that you have the Spring Snapshot repository defined: build.gradle repositories { maven { url 'https://repo.spring.io/snapshot' } } If you use a milestone or release candidate version, you need to ensure that you have the Spring Milestone repository defined: build.gradle repositories { maven { url 'https://repo.spring.io/milestone' } }"
"https://docs.spring.io/spring-security/reference/6.3/features/index.html","Features: Spring Security provides comprehensive support for authentication(authentication/index.html) , authorization(authorization/index.html) , and protection against common exploits(exploits/index.html#exploits) . It also provides integration with other libraries to simplify its usage. Section Summary: Authentication(authentication/index.html) Authorization(authorization/index.html) Protection Against Exploits(exploits/index.html) Integrations(integrations/index.html)"
"https://docs.spring.io/spring-security/reference/6.3/features/authentication/index.html","Authentication: Spring Security provides comprehensive support for authentication(https://en.wikipedia.org/wiki/Authentication) . Authentication is how we verify the identity of who is trying to access a particular resource. A common way to authenticate users is by requiring the user to enter a username and password. Once authentication is performed we know the identity and can perform authorization. Spring Security provides built-in support for authenticating users. This section is dedicated to generic authentication support that applies in both Servlet and WebFlux environments. Refer to the sections on authentication for Servlet(../../servlet/authentication/index.html#servlet-authentication) and WebFlux(../../servlet/authentication/index.html) for details on what is supported for each stack."
"https://docs.spring.io/spring-security/reference/6.3/features/authentication/password-storage.html","Password Storage: Spring Security’s PasswordEncoder interface is used to perform a one-way transformation of a password to let the password be stored securely. Given PasswordEncoder is a one-way transformation, it is not useful when the password transformation needs to be two-way (such as storing credentials used to authenticate to a database). Typically, PasswordEncoder is used for storing a password that needs to be compared to a user-provided password at the time of authentication. Password Storage History: Throughout the years, the standard mechanism for storing passwords has evolved. In the beginning, passwords were stored in plaintext. The passwords were assumed to be safe because the data store the passwords were saved in required credentials to access it. However, malicious users were able to find ways to get large “data dumps” of usernames and passwords by using attacks such as SQL Injection. As more and more user credentials became public, security experts realized that we needed to do more to protect users' passwords. Developers were then encouraged to store passwords after running them through a one way hash, such as SHA-256. When a user tried to authenticate, the hashed password would be compared to the hash of the password that they typed. This meant that the system only needed to store the one-way hash of the password. If a breach occurred, only the one-way hashes of the passwords were exposed. Since the hashes were one-way and it was computationally difficult to guess the passwords given the hash, it would not be worth the effort to figure out each password in the system. To defeat this new system, malicious users decided to create lookup tables known as Rainbow Tables(https://en.wikipedia.org/wiki/Rainbow_table) . Rather than doing the work of guessing each password every time, they computed the password once and stored it in a lookup table. To mitigate the effectiveness of Rainbow Tables, developers were encouraged to use salted passwords. Instead of using just the password as input to the hash function, random bytes (known as salt) would be generated for every user’s password. The salt and the user’s password would be run through the hash function to produce a unique hash. The salt would be stored alongside the user’s password in clear text. Then when a user tried to authenticate, the hashed password would be compared to the hash of the stored salt and the password that they typed. The unique salt meant that Rainbow Tables were no longer effective because the hash was different for every salt and password combination. In modern times, we realize that cryptographic hashes (like SHA-256) are no longer secure. The reason is that with modern hardware we can perform billions of hash calculations a second. This means that we can crack each password individually with ease. Developers are now encouraged to leverage adaptive one-way functions to store a password. Validation of passwords with adaptive one-way functions are intentionally resource-intensive (they intentionally use a lot of CPU, memory, or other resources). An adaptive one-way function allows configuring a “work factor” that can grow as hardware gets better. We recommend that the “work factor” be tuned to take about one second to verify a password on your system. This trade off is to make it difficult for attackers to crack the password, but not so costly that it puts excessive burden on your own system or irritates users. Spring Security has attempted to provide a good starting point for the “work factor”, but we encourage users to customize the “work factor” for their own system, since the performance varies drastically from system to system. Examples of adaptive one-way functions that should be used include bcrypt(#authentication-password-storage-bcrypt) , PBKDF2(#authentication-password-storage-pbkdf2) , scrypt(#authentication-password-storage-scrypt) , and argon2(#authentication-password-storage-argon2) . Because adaptive one-way functions are intentionally resource intensive, validating a username and password for every request can significantly degrade the performance of an application. There is nothing Spring Security (or any other library) can do to speed up the validation of the password, since security is gained by making the validation resource intensive. Users are encouraged to exchange the long term credentials (that is, username and password) for a short term credential (such as a session, and OAuth Token, and so on). The short term credential can be validated quickly without any loss in security. DelegatingPasswordEncoder: Prior to Spring Security 5.0, the default PasswordEncoder was NoOpPasswordEncoder , which required plain-text passwords. Based on the Password History(#authentication-password-storage-history) section, you might expect that the default PasswordEncoder would now be something like BCryptPasswordEncoder . However, this ignores three real world problems: Many applications use old password encodings that cannot easily migrate. The best practice for password storage will change again. As a framework, Spring Security cannot make breaking changes frequently. Instead Spring Security introduces DelegatingPasswordEncoder , which solves all of the problems by: Ensuring that passwords are encoded by using the current password storage recommendations Allowing for validating passwords in modern and legacy formats Allowing for upgrading the encoding in the future You can easily construct an instance of DelegatingPasswordEncoder by using PasswordEncoderFactories : Create Default DelegatingPasswordEncoder Java Kotlin PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder(); val passwordEncoder: PasswordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder() Alternatively, you can create your own custom instance: Create Custom DelegatingPasswordEncoder Java Kotlin String idForEncode = ""bcrypt""; Map encoders = new HashMap<>(); encoders.put(idForEncode, new BCryptPasswordEncoder()); encoders.put(""noop"", NoOpPasswordEncoder.getInstance()); encoders.put(""pbkdf2"", Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_5()); encoders.put(""pbkdf2@SpringSecurity_v5_8"", Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8()); encoders.put(""scrypt"", SCryptPasswordEncoder.defaultsForSpringSecurity_v4_1()); encoders.put(""scrypt@SpringSecurity_v5_8"", SCryptPasswordEncoder.defaultsForSpringSecurity_v5_8()); encoders.put(""argon2"", Argon2PasswordEncoder.defaultsForSpringSecurity_v5_2()); encoders.put(""argon2@SpringSecurity_v5_8"", Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8()); encoders.put(""sha256"", new StandardPasswordEncoder()); PasswordEncoder passwordEncoder = new DelegatingPasswordEncoder(idForEncode, encoders); val idForEncode = ""bcrypt"" val encoders: MutableMap<String, PasswordEncoder> = mutableMapOf() encoders[idForEncode] = BCryptPasswordEncoder() encoders[""noop""] = NoOpPasswordEncoder.getInstance() encoders[""pbkdf2""] = Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_5() encoders[""pbkdf2@SpringSecurity_v5_8""] = Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8() encoders[""scrypt""] = SCryptPasswordEncoder.defaultsForSpringSecurity_v4_1() encoders[""scrypt@SpringSecurity_v5_8""] = SCryptPasswordEncoder.defaultsForSpringSecurity_v5_8() encoders[""argon2""] = Argon2PasswordEncoder.defaultsForSpringSecurity_v5_2() encoders[""argon2@SpringSecurity_v5_8""] = Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8() encoders[""sha256""] = StandardPasswordEncoder() val passwordEncoder: PasswordEncoder = DelegatingPasswordEncoder(idForEncode, encoders) Password Storage Format: The general format for a password is: DelegatingPasswordEncoder Storage Format {id}encodedPassword id is an identifier that is used to look up which PasswordEncoder should be used and encodedPassword is the original encoded password for the selected PasswordEncoder . The id must be at the beginning of the password, start with { , and end with } . If the id cannot be found, the id is set to null. For example, the following might be a list of passwords encoded using different id values. All of the original passwords are password . DelegatingPasswordEncoder Encoded Passwords Example {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG (1) {noop}password (2) {pbkdf2}5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc (3) {scrypt}$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc= (4) {sha256}97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0 (5) 1 The first password has a PasswordEncoder id of bcrypt and an encodedPassword value of $2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG . When matching, it would delegate to BCryptPasswordEncoder 2 The second password has a PasswordEncoder id of noop and encodedPassword value of password . When matching, it would delegate to NoOpPasswordEncoder 3 The third password has a PasswordEncoder id of pbkdf2 and encodedPassword value of 5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc . When matching, it would delegate to Pbkdf2PasswordEncoder 4 The fourth password has a PasswordEncoder id of scrypt and encodedPassword value of $e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc= When matching, it would delegate to SCryptPasswordEncoder 5 The final password has a PasswordEncoder id of sha256 and encodedPassword value of 97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0 . When matching, it would delegate to StandardPasswordEncoder Some users might be concerned that the storage format is provided for a potential hacker. This is not a concern because the storage of the password does not rely on the algorithm being a secret. Additionally, most formats are easy for an attacker to figure out without the prefix. For example, BCrypt passwords often start with $2a$ . Password Encoding: The idForEncode passed into the constructor determines which PasswordEncoder is used for encoding passwords. In the DelegatingPasswordEncoder we constructed earlier, that means that the result of encoding password is delegated to BCryptPasswordEncoder and be prefixed with {bcrypt} . The end result looks like the following example: DelegatingPasswordEncoder Encode Example {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG Password Matching: Matching is based upon the {id} and the mapping of the id to the PasswordEncoder provided in the constructor. Our example in Password Storage Format(#authentication-password-storage-dpe-format) provides a working example of how this is done. By default, the result of invoking matches(CharSequence, String) with a password and an id that is not mapped (including a null id) results in an IllegalArgumentException . This behavior can be customized by using DelegatingPasswordEncoder.setDefaultPasswordEncoderForMatches(PasswordEncoder) . By using the id , we can match on any password encoding but encode passwords by using the most modern password encoding. This is important, because unlike encryption, password hashes are designed so that there is no simple way to recover the plaintext. Since there is no way to recover the plaintext, it is difficult to migrate the passwords. While it is simple for users to migrate NoOpPasswordEncoder , we chose to include it by default to make it simple for the getting-started experience. Getting Started Experience: If you are putting together a demo or a sample, it is a bit cumbersome to take time to hash the passwords of your users. There are convenience mechanisms to make this easier, but this is still not intended for production. withDefaultPasswordEncoder Example Java Kotlin UserDetails user = User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .roles(""user"") .build(); System.out.println(user.getPassword()); // {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG val user = User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .roles(""user"") .build() println(user.password) // {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG If you are creating multiple users, you can also reuse the builder: withDefaultPasswordEncoder Reusing the Builder Java Kotlin UserBuilder users = User.withDefaultPasswordEncoder(); UserDetails user = users .username(""user"") .password(""password"") .roles(""USER"") .build(); UserDetails admin = users .username(""admin"") .password(""password"") .roles(""USER"",""ADMIN"") .build(); val users = User.withDefaultPasswordEncoder() val user = users .username(""user"") .password(""password"") .roles(""USER"") .build() val admin = users .username(""admin"") .password(""password"") .roles(""USER"", ""ADMIN"") .build() This does hash the password that is stored, but the passwords are still exposed in memory and in the compiled source code. Therefore, it is still not considered secure for a production environment. For production, you should hash your passwords externally(#authentication-password-storage-boot-cli) . Encode with Spring Boot CLI: The easiest way to properly encode your password is to use the Spring Boot CLI(https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-cli.html) . For example, the following example encodes the password of password for use with DelegatingPasswordEncoder(#authentication-password-storage-dpe) : Spring Boot CLI encodepassword Example spring encodepassword password {bcrypt}$2a$10$X5wFBtLrL/kHcmrOGGTrGufsBX8CJ0WpQpF3pgeuxBB/H73BK1DW6 Troubleshooting: The following error occurs when one of the passwords that are stored has no id , as described in Password Storage Format(#authentication-password-storage-dpe-format) . java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id ""null"" at org.springframework.security.crypto.password.DelegatingPasswordEncoder$UnmappedIdPasswordEncoder.matches(DelegatingPasswordEncoder.java:233) at org.springframework.security.crypto.password.DelegatingPasswordEncoder.matches(DelegatingPasswordEncoder.java:196) The easiest way to resolve it is to figure out how your passwords are currently being stored and explicitly provide the correct PasswordEncoder . If you are migrating from Spring Security 4.2.x, you can revert to the previous behavior by exposing a NoOpPasswordEncoder bean(#authentication-password-storage-configuration) . Alternatively, you can prefix all of your passwords with the correct id and continue to use DelegatingPasswordEncoder . For example, if you are using BCrypt, you would migrate your password from something like: $2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG to {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG For a complete listing of the mappings, see the Javadoc for PasswordEncoderFactories(https://docs.spring.io/spring-security/site/docs/5.0.x/api/org/springframework/security/crypto/factory/PasswordEncoderFactories.html) . BCryptPasswordEncoder: The BCryptPasswordEncoder implementation uses the widely supported bcrypt(https://en.wikipedia.org/wiki/Bcrypt) algorithm to hash the passwords. To make it more resistant to password cracking, bcrypt is deliberately slow. Like other adaptive one-way functions, it should be tuned to take about 1 second to verify a password on your system. The default implementation of BCryptPasswordEncoder uses strength 10 as mentioned in the Javadoc of BCryptPasswordEncoder(https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/crypto/bcrypt/BCryptPasswordEncoder.html) . You are encouraged to tune and test the strength parameter on your own system so that it takes roughly 1 second to verify a password. BCryptPasswordEncoder Java Kotlin // Create an encoder with strength 16 BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16); String result = encoder.encode(""myPassword""); assertTrue(encoder.matches(""myPassword"", result)); // Create an encoder with strength 16 val encoder = BCryptPasswordEncoder(16) val result: String = encoder.encode(""myPassword"") assertTrue(encoder.matches(""myPassword"", result)) Argon2PasswordEncoder: The Argon2PasswordEncoder implementation uses the Argon2(https://en.wikipedia.org/wiki/Argon2) algorithm to hash the passwords. Argon2 is the winner of the Password Hashing Competition(https://en.wikipedia.org/wiki/Password_Hashing_Competition) . To defeat password cracking on custom hardware, Argon2 is a deliberately slow algorithm that requires large amounts of memory. Like other adaptive one-way functions, it should be tuned to take about 1 second to verify a password on your system. The current implementation of the Argon2PasswordEncoder requires BouncyCastle. Argon2PasswordEncoder Java Kotlin // Create an encoder with all the defaults Argon2PasswordEncoder encoder = Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8(); String result = encoder.encode(""myPassword""); assertTrue(encoder.matches(""myPassword"", result)); // Create an encoder with all the defaults val encoder = Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8() val result: String = encoder.encode(""myPassword"") assertTrue(encoder.matches(""myPassword"", result)) Pbkdf2PasswordEncoder: The Pbkdf2PasswordEncoder implementation uses the PBKDF2(https://en.wikipedia.org/wiki/PBKDF2) algorithm to hash the passwords. To defeat password cracking PBKDF2 is a deliberately slow algorithm. Like other adaptive one-way functions, it should be tuned to take about 1 second to verify a password on your system. This algorithm is a good choice when FIPS certification is required. Pbkdf2PasswordEncoder Java Kotlin // Create an encoder with all the defaults Pbkdf2PasswordEncoder encoder = Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8(); String result = encoder.encode(""myPassword""); assertTrue(encoder.matches(""myPassword"", result)); // Create an encoder with all the defaults val encoder = Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8() val result: String = encoder.encode(""myPassword"") assertTrue(encoder.matches(""myPassword"", result)) SCryptPasswordEncoder: The SCryptPasswordEncoder implementation uses the scrypt(https://en.wikipedia.org/wiki/Scrypt) algorithm to hash the passwords. To defeat password cracking on custom hardware, scrypt is a deliberately slow algorithm that requires large amounts of memory. Like other adaptive one-way functions, it should be tuned to take about 1 second to verify a password on your system. SCryptPasswordEncoder Java Kotlin // Create an encoder with all the defaults SCryptPasswordEncoder encoder = SCryptPasswordEncoder.defaultsForSpringSecurity_v5_8(); String result = encoder.encode(""myPassword""); assertTrue(encoder.matches(""myPassword"", result)); // Create an encoder with all the defaults val encoder = SCryptPasswordEncoder.defaultsForSpringSecurity_v5_8() val result: String = encoder.encode(""myPassword"") assertTrue(encoder.matches(""myPassword"", result)) Other PasswordEncoders: There are a significant number of other PasswordEncoder implementations that exist entirely for backward compatibility. They are all deprecated to indicate that they are no longer considered secure. However, there are no plans to remove them, since it is difficult to migrate existing legacy systems. Password Storage Configuration: Spring Security uses DelegatingPasswordEncoder(#authentication-password-storage-dpe) by default. However, you can customize this by exposing a PasswordEncoder as a Spring bean. If you are migrating from Spring Security 4.2.x, you can revert to the previous behavior by exposing a NoOpPasswordEncoder bean. Reverting to NoOpPasswordEncoder is not considered to be secure. You should instead migrate to using DelegatingPasswordEncoder to support secure password encoding. NoOpPasswordEncoder Java XML Kotlin @Bean public static NoOpPasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } <b:bean id=""passwordEncoder"" class=""org.springframework.security.crypto.password.NoOpPasswordEncoder"" factory-method=""getInstance""/> @Bean fun passwordEncoder(): PasswordEncoder { return NoOpPasswordEncoder.getInstance(); } XML Configuration requires the NoOpPasswordEncoder bean name to be passwordEncoder . Change Password Configuration: Most applications that allow a user to specify a password also require a feature for updating that password. A Well-Known URL for Changing Passwords(https://w3c.github.io/webappsec-change-password-url/) indicates a mechanism by which password managers can discover the password update endpoint for a given application. You can configure Spring Security to provide this discovery endpoint. For example, if the change password endpoint in your application is /change-password , then you can configure Spring Security like so: Default Change Password Endpoint Java XML Kotlin http .passwordManagement(Customizer.withDefaults()) <sec:password-management/> http { passwordManagement { } } Then, when a password manager navigates to /.well-known/change-password then Spring Security will redirect your endpoint, /change-password . Or, if your endpoint is something other than /change-password , you can also specify that like so: Change Password Endpoint Java XML Kotlin http .passwordManagement((management) -> management .changePasswordPage(""/update-password"") ) <sec:password-management change-password-page=""/update-password""/> http { passwordManagement { changePasswordPage = ""/update-password"" } } With the above configuration, when a password manager navigates to /.well-known/change-password , then Spring Security will redirect to /update-password . Compromised Password Checking: There are some scenarios where you need to check whether a password has been compromised, for example, if you are creating an application that deals with sensitive data, it is often needed that you perform some check on user’s passwords in order to assert its reliability. One of these checks can be if the password has been compromised, usually because it has been found in a data breach(https://wikipedia.org/wiki/Data_breach) . To facilitate that, Spring Security provides integration with the Have I Been Pwned API(https://haveibeenpwned.com/API/v3#PwnedPasswords) via the HaveIBeenPwnedRestApiPasswordChecker implementation(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/core/password/HaveIBeenPwnedRestApiPasswordChecker.html) of the CompromisedPasswordChecker interface(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/core/password/CompromisedPasswordChecker.html) . You can either use the CompromisedPasswordChecker API by yourself or, if you are using the DaoAuthenticationProvider(../../servlet/authentication/passwords/dao-authentication-provider.html) via Spring Security authentication mechanisms(../../servlet/authentication/passwords/index.html) , you can provide a CompromisedPasswordChecker bean, and it will be automatically picked up by Spring Security configuration. By doing that, when you try to authenticate via Form Login using a weak password, let’s say 123456 , you will receive a 401 or be redirected to the /login?error page (depending on your user-agent). However, just a 401 or the redirect is not so useful in that case, it will cause some confusion because the user provided the right password and still was not allowed to log in. In such cases, you can handle the CompromisedPasswordException via the AuthenticationFailureHandler to perform your desired logic, like redirecting the user-agent to /reset-password , for example: Using CompromisedPasswordChecker Java Kotlin @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .formLogin((login) -> login .failureHandler(new CompromisedPasswordAuthenticationFailureHandler()) ); return http.build(); } @Bean public CompromisedPasswordChecker compromisedPasswordChecker() { return new HaveIBeenPwnedRestApiPasswordChecker(); } static class CompromisedPasswordAuthenticationFailureHandler implements AuthenticationFailureHandler { private final SimpleUrlAuthenticationFailureHandler defaultFailureHandler = new SimpleUrlAuthenticationFailureHandler( ""/login?error""); private final RedirectStrategy redirectStrategy = new DefaultRedirectStrategy(); @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException { if (exception instanceof CompromisedPasswordException) { this.redirectStrategy.sendRedirect(request, response, ""/reset-password""); return; } this.defaultFailureHandler.onAuthenticationFailure(request, response, exception); } } @Bean open fun filterChain(http:HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(anyRequest, authenticated) } formLogin { failureHandler = CompromisedPasswordAuthenticationFailureHandler() } } return http.build() } @Bean open fun compromisedPasswordChecker(): CompromisedPasswordChecker { return HaveIBeenPwnedRestApiPasswordChecker() } class CompromisedPasswordAuthenticationFailureHandler : AuthenticationFailureHandler { private val defaultFailureHandler = SimpleUrlAuthenticationFailureHandler(""/login?error"") private val redirectStrategy = DefaultRedirectStrategy() override fun onAuthenticationFailure( request: HttpServletRequest, response: HttpServletResponse, exception: AuthenticationException ) { if (exception is CompromisedPasswordException) { redirectStrategy.sendRedirect(request, response, ""/reset-password"") return } defaultFailureHandler.onAuthenticationFailure(request, response, exception) } }"
"https://docs.spring.io/spring-security/reference/6.3/features/authorization/index.html","Authorization: Spring Security provides comprehensive support for authorization(https://en.wikipedia.org/wiki/Authorization) . Authorization is determining who is allowed to access a particular resource. Spring Security provides defense in depth(https://en.wikipedia.org/wiki/Defense_in_depth_(computing)) by allowing for request based authorization and method based authorization. Request Based Authorization: Spring Security provides authorization based upon the request for both Servlet(../../servlet/authorization/authorize-http-requests.html) and WebFlux(../../reactive/authorization/authorize-http-requests.html) environments. Method Based Authorization: Spring Security provides authorization based on the method invocation for both Servlet(../../servlet/authorization/method-security.html) and WebFlux(../../reactive/authorization/method.html) environments."
"https://docs.spring.io/spring-security/reference/6.3/features/exploits/index.html","Protection Against Exploits: Spring Security provides protection against common exploits. Whenever possible, the protection is enabled by default. This section describes the various exploits that Spring Security protects against. Section Summary: CSRF(csrf.html) HTTP Headers(headers.html) HTTP Requests(http.html)"
"https://docs.spring.io/spring-security/reference/6.3/features/exploits/csrf.html","Cross Site Request Forgery (CSRF): Spring provides comprehensive support for protecting against Cross Site Request Forgery (CSRF)(https://en.wikipedia.org/wiki/Cross-site_request_forgery) attacks. In the following sections, we explore: What is a CSRF Attack?(#csrf-explained) Protecting Against CSRF Attacks(#csrf-protection) CSRF Considerations(#csrf-considerations) This portion of the documentation discusses the general topic of CSRF protection. See the relevant sections for specific information on CSRF protection for servlet(../../servlet/exploits/csrf.html#servlet-csrf) and WebFlux(../../reactive/exploits/csrf.html#webflux-csrf) based applications. What is a CSRF Attack?: The best way to understand a CSRF attack is by taking a look at a concrete example. Assume that your bank’s website provides a form that allows transferring money from the currently logged in user to another bank account. For example, the transfer form might look like: Transfer form <form method=""post"" action=""/transfer""> <input type=""text"" name=""amount""/> <input type=""text"" name=""routingNumber""/> <input type=""text"" name=""account""/> <input type=""submit"" value=""Transfer""/> </form> The corresponding HTTP request might look like: Transfer HTTP request POST /transfer HTTP/1.1 Host: bank.example.com Cookie: JSESSIONID=randomid Content-Type: application/x-www-form-urlencoded amount=100.00&routingNumber=1234&account=9876 Now pretend you authenticate to your bank’s website and then, without logging out, visit an evil website. The evil website contains an HTML page with the following form: Evil transfer form <form method=""post"" action=""https://bank.example.com/transfer""> <input type=""hidden"" name=""amount"" value=""100.00""/> <input type=""hidden"" name=""routingNumber"" value=""evilsRoutingNumber""/> <input type=""hidden"" name=""account"" value=""evilsAccountNumber""/> <input type=""submit"" value=""Win Money!""/> </form> You like to win money, so you click on the submit button. In the process, you have unintentionally transferred $100 to a malicious user. This happens because, while the evil website cannot see your cookies, the cookies associated with your bank are still sent along with the request. Worse yet, this whole process could have been automated by using JavaScript. This means you did not even need to click on the button. Furthermore, it could just as easily happen when visiting an honest site that is a victim of a XSS attack(https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)) . So how do we protect our users from such attacks? Protecting Against CSRF Attacks: The reason that a CSRF attack is possible is that the HTTP request from the victim’s website and the request from the attacker’s website are exactly the same. This means there is no way to reject requests coming from the evil website and allow only requests coming from the bank’s website. To protect against CSRF attacks, we need to ensure there is something in the request that the evil site is unable to provide so we can differentiate the two requests. Spring provides two mechanisms to protect against CSRF attacks: The Synchronizer Token Pattern(#csrf-protection-stp) Specifying the SameSite Attribute(#csrf-protection-ssa) on your session cookie Both protections require that Safe Methods be Read-only(#csrf-protection-read-only) . Safe Methods Must be Read-only: For either protection(#csrf-protection) against CSRF to work, the application must ensure that ""safe"" HTTP methods are read-only(https://tools.ietf.org/html/rfc7231#section-4.2.1) . This means that requests with the HTTP GET , HEAD , OPTIONS , and TRACE methods should not change the state of the application. Synchronizer Token Pattern: The predominant and most comprehensive way to protect against CSRF attacks is to use the Synchronizer Token Pattern(https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) . This solution is to ensure that each HTTP request requires, in addition to our session cookie, a secure random generated value called a CSRF token be present in the HTTP request. When an HTTP request is submitted, the server must look up the expected CSRF token and compare it against the actual CSRF token in the HTTP request. If the values do not match, the HTTP request should be rejected. The key to this working is that the actual CSRF token should be in a part of the HTTP request that is not automatically included by the browser. For example, requiring the actual CSRF token in an HTTP parameter or an HTTP header will protect against CSRF attacks. Requiring the actual CSRF token in a cookie does not work because cookies are automatically included in the HTTP request by the browser. We can relax the expectations to require only the actual CSRF token for each HTTP request that updates the state of the application. For that to work, our application must ensure that safe HTTP methods are read-only(#csrf-protection-read-only) . This improves usability, since we want to allow linking to our website from external sites. Additionally, we do not want to include the random token in HTTP GET, as this can cause the tokens to be leaked. Consider how our example(#csrf-explained) would change when we use the Synchronizer Token Pattern. Assume that the actual CSRF token is required to be in an HTTP parameter named _csrf . Our application’s transfer form would look like: Synchronizer Token Form <form method=""post"" action=""/transfer""> <input type=""hidden"" name=""_csrf"" value=""4bfd1575-3ad1-4d21-96c7-4ef2d9f86721""/> <input type=""text"" name=""amount""/> <input type=""text"" name=""routingNumber""/> <input type=""hidden"" name=""account""/> <input type=""submit"" value=""Transfer""/> </form> The form now contains a hidden input with the value of the CSRF token. External sites cannot read the CSRF token since the same origin policy ensures the evil site cannot read the response. The corresponding HTTP request to transfer money would look like this: Synchronizer Token request POST /transfer HTTP/1.1 Host: bank.example.com Cookie: JSESSIONID=randomid Content-Type: application/x-www-form-urlencoded amount=100.00&routingNumber=1234&account=9876&_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721 You will notice that the HTTP request now contains the _csrf parameter with a secure random value. The evil website will not be able to provide the correct value for the _csrf parameter (which must be explicitly provided on the evil website) and the transfer will fail when the server compares the actual CSRF token to the expected CSRF token. SameSite Attribute: An emerging way to protect against CSRF Attacks(#csrf) is to specify the SameSite Attribute(https://tools.ietf.org/html/draft-west-first-party-cookies) on cookies. A server can specify the SameSite attribute when setting a cookie to indicate that the cookie should not be sent when coming from external sites. Spring Security does not directly control the creation of the session cookie, so it does not provide support for the SameSite attribute. Spring Session(https://spring.io/projects/spring-session) provides support for the SameSite attribute in servlet-based applications. Spring Framework’s CookieWebSessionIdResolver(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/server/session/CookieWebSessionIdResolver.html) provides out of the box support for the SameSite attribute in WebFlux-based applications. An example, of an HTTP response header with the SameSite attribute might look like: SameSite HTTP response Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax Valid values for the SameSite attribute are: Strict : When specified, any request coming from the same-site(https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1) includes the cookie. Otherwise, the cookie is not included in the HTTP request. Lax : When specified, cookies are sent when coming from the same-site(https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1) or when the request comes from top-level navigations and the method is read-only(#csrf-protection-read-only) . Otherwise, the cookie is not included in the HTTP request. Consider how our example(#csrf-explained) could be protected using the SameSite attribute. The bank application can protect against CSRF by specifying the SameSite attribute on the session cookie. With the SameSite attribute set on our session cookie, the browser continues to send the JSESSIONID cookie with requests coming from the banking website. However, the browser no longer sends the JSESSIONID cookie with a transfer request coming from the evil website. Since the session is no longer present in the transfer request coming from the evil website, the application is protected from the CSRF attack. There are some important considerations(https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-5) to be aware of when using SameSite attribute to protect against CSRF attacks. Setting the SameSite attribute to Strict provides a stronger defense but can confuse users. Consider a user who stays logged into a social media site hosted at social.example.com(https://social.example.com) . The user receives an email at email.example.org(https://email.example.org) that includes a link to the social media site. If the user clicks on the link, they would rightfully expect to be authenticated to the social media site. However, if the SameSite attribute is Strict , the cookie would not be sent and so the user would not be authenticated. We could improve the protection and usability of SameSite protection against CSRF attacks by implementing gh-7537(https://github.com/spring-projects/spring-security/issues/7537) . Another obvious consideration is that, in order for the SameSite attribute to protect users, the browser must support the SameSite attribute. Most modern browsers do support the SameSite attribute(https://developer.mozilla.org/en-US/docs/Web/HTTP/headers/Set-Cookie#Browser_compatibility) . However, older browsers that are still in use may not. For this reason, we generally recommend using the SameSite attribute as a defense in depth rather than the sole protection against CSRF attacks. When to use CSRF protection: When should you use CSRF protection? Our recommendation is to use CSRF protection for any request that could be processed by a browser by normal users. If you are creating a service that is used only by non-browser clients, you likely want to disable CSRF protection. CSRF protection and JSON: A common question is “do I need to protect JSON requests made by JavaScript?” The short answer is: It depends. However, you must be very careful, as there are CSRF exploits that can impact JSON requests. For example, a malicious user can create a CSRF with JSON by using the following form(http://blog.opensecurityresearch.com/2012/02/json-csrf-with-parameter-padding.html) : CSRF with JSON form <form action=""https://bank.example.com/transfer"" method=""post"" enctype=""text/plain""> <input name='{""amount"":100,""routingNumber"":""evilsRoutingNumber"",""account"":""evilsAccountNumber"", ""ignore_me"":""' value='test""}' type='hidden'> <input type=""submit"" value=""Win Money!""/> </form> This produces the following JSON structure CSRF with JSON request { ""amount"": 100, ""routingNumber"": ""evilsRoutingNumber"", ""account"": ""evilsAccountNumber"", ""ignore_me"": ""=test"" } If an application were not validating the Content-Type header, it would be exposed to this exploit. Depending on the setup, a Spring MVC application that validates the Content-Type could still be exploited by updating the URL suffix to end with .json , as follows: CSRF with JSON Spring MVC form <form action=""https://bank.example.com/transfer.json"" method=""post"" enctype=""text/plain""> <input name='{""amount"":100,""routingNumber"":""evilsRoutingNumber"",""account"":""evilsAccountNumber"", ""ignore_me"":""' value='test""}' type='hidden'> <input type=""submit"" value=""Win Money!""/> </form> CSRF and Stateless Browser Applications: What if my application is stateless? That does not necessarily mean you are protected. In fact, if a user does not need to perform any actions in the web browser for a given request, they are likely still vulnerable to CSRF attacks. For example, consider an application that uses a custom cookie that contains all the state within it for authentication (instead of the JSESSIONID). When the CSRF attack is made, the custom cookie is sent with the request in the same manner that the JSESSIONID cookie was sent in our previous example. This application is vulnerable to CSRF attacks. Applications that use basic authentication are also vulnerable to CSRF attacks. The application is vulnerable since the browser automatically includes the username and password in any requests in the same manner that the JSESSIONID cookie was sent in our previous example. CSRF Considerations: There are a few special considerations to consider when implementing protection against CSRF attacks. Logging In: To protect against forging login requests(https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests) , the login HTTP request should be protected against CSRF attacks. Protecting against forging login requests is necessary so that a malicious user cannot read a victim’s sensitive information. The attack is performed as follows: A malicious user performs a CSRF login with the malicious user’s credentials. The victim is now authenticated as the malicious user. The malicious user then tricks the victim into visiting the compromised website and entering sensitive information. The information is associated to the malicious user’s account so the malicious user can log in with their own credentials and view the victim’s sensitive information. A possible complication to ensuring login HTTP requests are protected against CSRF attacks is that the user might experience a session timeout that causes the request to be rejected. A session timeout is surprising to users who do not expect to need to have a session to log in. For more information refer to CSRF and Session Timeouts(#csrf-considerations-timeouts) . Logging Out: To protect against forging logout requests, the logout HTTP request should be protected against CSRF attacks. Protecting against forging logout requests is necessary so that a malicious user cannot read a victim’s sensitive information. For details on the attack, see this blog post(https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/) . A possible complication to ensuring logout HTTP requests are protected against CSRF attacks is that the user might experience a session timeout that causes the request to be rejected. A session timeout is surprising to users who do not expect to have a session to log out. For more information, see CSRF and Session Timeouts(#csrf-considerations-timeouts) . CSRF and Session Timeouts: More often than not, the expected CSRF token is stored in the session. This means that, as soon as the session expires, the server does not find an expected CSRF token and rejects the HTTP request. There are a number of options (each of which come with trade offs) to solve timeouts: The best way to mitigate the timeout is by using JavaScript to request a CSRF token on form submission. The form is then updated with the CSRF token and submitted. Another option is to have some JavaScript that lets the user know their session is about to expire. The user can click a button to continue and refresh the session. Finally, the expected CSRF token could be stored in a cookie. This lets the expected CSRF token outlive the session. One might ask why the expected CSRF token is not stored in a cookie by default. This is because there are known exploits in which headers (for example, to specify the cookies) can be set by another domain. This is the same reason Ruby on Rails no longer skips a CSRF checks when the header X-Requested-With is present(https://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/) . See this webappsec.org thread(https://web.archive.org/web/20210221120355/https://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html) for details on how to perform the exploit. Another disadvantage is that by removing the state (that is, the timeout), you lose the ability to forcibly invalidate the token if it is compromised. Multipart (file upload): Protecting multipart requests (file uploads) from CSRF attacks causes a chicken or the egg(https://en.wikipedia.org/wiki/Chicken_or_the_egg) problem. To prevent a CSRF attack from occurring, the body of the HTTP request must be read to obtain the actual CSRF token. However, reading the body means that the file is uploaded, which means an external site can upload a file. There are two options to using CSRF protection with multipart/form-data: Place CSRF Token in the Body(#csrf-considerations-multipart-body) Place CSRF Token in the URL(#csrf-considerations-multipart-url) Each option has its trade-offs. Before you integrate Spring Security’s CSRF protection with multipart file upload, you should first ensure that you can upload without the CSRF protection. More information about using multipart forms with Spring, see the 1.1.11. Multipart Resolver(https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart) section of the Spring reference and the MultipartFilter Javadoc(https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html) . Place CSRF Token in the Body: The first option is to include the actual CSRF token in the body of the request. By placing the CSRF token in the body, the body is read before authorization is performed. This means that anyone can place temporary files on your server. However, only authorized users can submit a file that is processed by your application. In general, this is the recommended approach, because the temporary file upload should have a negligible impact on most servers. Include CSRF Token in URL: If letting unauthorized users upload temporary files is not acceptable, an alternative is to include the expected CSRF token as a query parameter in the action attribute of the form. The disadvantage to this approach is that query parameters can be leaked. More generally, it is considered best practice to place sensitive data within the body or headers to ensure it is not leaked. You can find additional information in RFC 2616 Section 15.1.3 Encoding Sensitive Information in URI’s(https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3) . HiddenHttpMethodFilter: Some applications can use a form parameter to override the HTTP method. For example, the following form can treat the HTTP method as a delete rather than a post . CSRF Hidden HTTP Method Form <form action=""/process"" method=""post""> <!-- ... --> <input type=""hidden"" name=""_method"" value=""delete""/> </form> Overriding the HTTP method occurs in a filter. That filter must be placed before Spring Security’s support. Note that overriding happens only on a post , so this is actually unlikely to cause any real problems. However, it is still best practice to ensure that it is placed before Spring Security’s filters."
"https://docs.spring.io/spring-security/reference/6.3/features/exploits/headers.html","Security HTTP Response Headers: This portion of the documentation discusses the general topic of Security HTTP Response Headers. See the relevant sections for specific information on Security HTTP Response Headers in servlet(../../servlet/exploits/headers.html#servlet-headers) - and WebFlux(../../reactive/exploits/headers.html#webflux-headers) -based applications. You can use HTTP response headers(https://owasp.org/www-project-secure-headers/#div-headers) in many ways to increase the security of web applications. This section is dedicated to the various HTTP response headers for which Spring Security provides explicit support for. If necessary, you can also configure Spring Security to provide custom headers(#headers-custom) . Default Security Headers: See the relevant sections for how to customize the defaults for both servlet(../../servlet/exploits/headers.html#servlet-headers-default) - and webflux(../../reactive/exploits/headers.html#webflux-headers-default) -based applications. Spring Security provides a default set of security related HTTP response headers to provide secure defaults. The default for Spring Security is to include the following headers: Default Security HTTP Response Headers Cache-Control: no-cache, no-store, max-age=0, must-revalidate Pragma: no-cache Expires: 0 X-Content-Type-Options: nosniff Strict-Transport-Security: max-age=31536000 ; includeSubDomains X-Frame-Options: DENY X-XSS-Protection: 0 Strict-Transport-Security is added only on HTTPS requests If the defaults do not meet your needs, you can easily remove, modify, or add headers from these defaults. For additional details on each of these headers, see the corresponding sections: Cache Control(#headers-cache-control) Content Type Options(#headers-content-type-options) HTTP Strict Transport Security(#headers-hsts) X-Frame-Options(#headers-frame-options) X-XSS-Protection(#headers-xss-protection) Cache Control: See to the relevant sections for how to customize the defaults for both servlet(../../servlet/exploits/headers.html#servlet-headers-cache-control) - and webflux(../../reactive/exploits/headers.html#webflux-headers-cache-control) -based applications. Spring Security’s default is to disable caching to protect the user’s content. If a user authenticates to view sensitive information and then logs out, we do not want a malicious user to be able to click the back button to view the sensitive information. The cache control headers that are sent by default are: Default Cache Control HTTP Response Headers Cache-Control: no-cache, no-store, max-age=0, must-revalidate Pragma: no-cache Expires: 0 To be secure by default, Spring Security adds these headers by default. However, if your application provides its own cache control headers, Spring Security backs out of the way. This allows for applications to ensure that static resources (such as CSS and JavaScript) can be cached. Content Type Options: Refer to the relevant sections to see how to customize the defaults for both servlet(../../servlet/exploits/headers.html#servlet-headers-content-type-options) and webflux(../../reactive/exploits/headers.html#webflux-headers-content-type-options) based applications. Historically, browsers, including Internet Explorer, would try to guess the content type of a request by using content sniffing(https://en.wikipedia.org/wiki/Content_sniffing) . This allowed browsers to improve the user experience by guessing the content type on resources that had not specified the content type. For example, if a browser encountered a JavaScript file that did not have the content type specified, it would be able to guess the content type and then run it. There are many additional things one should do (such as only display the document in a distinct domain, ensure Content-Type header is set, sanitize the document, and others) when allowing content to be uploaded. However, these measures are out of the scope of what Spring Security provides. It is also important to point out that, when disabling content sniffing, you must specify the content type in order for things to work properly. The problem with content sniffing is that this allowed malicious users to use polyglots (that is, a file that is valid as multiple content types) to perform XSS attacks. For example, some sites may allow users to submit a valid postscript document to a website and view it. A malicious user might create a postscript document that is also a valid JavaScript file(http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf) and perform an XSS attack with it. By default, Spring Security disables content sniffing by adding the following header to HTTP responses: nosniff HTTP Response Header X-Content-Type-Options: nosniff HTTP Strict Transport Security (HSTS): Refer to the relevant sections to see how to customize the defaults for both servlet(../../servlet/exploits/headers.html#servlet-headers-hsts) and webflux(../../reactive/exploits/headers.html#webflux-headers-hsts) based applications. When you type in your bank’s website, do you enter mybank.example.com or do you enter https://mybank.example.com ? If you omit the https protocol, you are potentially vulnerable to Man-in-the-Middle attacks(https://en.wikipedia.org/wiki/Man-in-the-middle_attack) . Even if the website performs a redirect to https://mybank.example.com , a malicious user could intercept the initial HTTP request and manipulate the response (for example, redirect to https://mibank.example.com and steal their credentials). Many users omit the https protocol, and this is why HTTP Strict Transport Security (HSTS)(https://tools.ietf.org/html/rfc6797) was created. Once mybank.example.com is added as a HSTS host(https://tools.ietf.org/html/rfc6797#section-5.1) , a browser can know ahead of time that any request to mybank.example.com should be interpreted as https://mybank.example.com . This greatly reduces the possibility of a Man-in-the-Middle attack occurring. In accordance with RFC6797(https://tools.ietf.org/html/rfc6797#section-7.2) , the HSTS header is injected only into HTTPS responses. For the browser to acknowledge the header, the browser must first trust the CA that signed the SSL certificate used to make the connection (not just the SSL certificate). One way for a site to be marked as a HSTS host is to have the host preloaded into the browser. Another way is to add the Strict-Transport-Security header to the response. For example, Spring Security’s default behavior is to add the following header, which instructs the browser to treat the domain as an HSTS host for a year (there are 31536000 seconds in a non-leap year): Strict Transport Security HTTP Response Header Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload The optional includeSubDomains directive instructs the browser that subdomains (such as secure.mybank.example.com ) should also be treated as an HSTS domain. The optional preload directive instructs the browser that the domain should be preloaded in browser as an HSTS domain. For more details on HSTS preload, see hstspreload.org(https://hstspreload.org) . HTTP Public Key Pinning (HPKP): To remain passive, Spring Security still provides support for HPKP in servlet environments(../../servlet/exploits/headers.html#servlet-headers-hpkp) . However, for the reasons listed earlier, HPKP is no longer recommended by the Spring Security team. HTTP Public Key Pinning (HPKP)(https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning) specifies to a web client which public key to use with a certain web server to prevent Man-in-the-Middle (MITM) attacks with forged certificates. When used correctly, HPKP could add additional layers of protection against compromised certificates. However, due to the complexity of HPKP, many experts no longer recommend using it and Chrome has even removed support(https://www.chromestatus.com/feature/5903385005916160) for it. For additional details around why HPKP is no longer recommended, read Is HTTP Public Key Pinning Dead?(https://blog.qualys.com/ssllabs/2016/09/06/is-http-public-key-pinning-dead) and I’m giving up on HPKP(https://scotthelme.co.uk/im-giving-up-on-hpkp/) . X-Frame-Options: See the relevant sections to see how to customize the defaults for both servlet(../../servlet/exploits/headers.html#servlet-headers-frame-options) and webflux(../../reactive/exploits/headers.html#webflux-headers-frame-options) based applications. Letting your website be added to a frame can be a security issue. For example, by using clever CSS styling, users could be tricked into clicking on something that they were not intending. For example, a user that is logged into their bank might click a button that grants access to other users. This sort of attack is known as Clickjacking(https://en.wikipedia.org/wiki/Clickjacking) . Another modern approach to dealing with clickjacking is to use Content Security Policy (CSP)(#headers-csp) . There are a number ways to mitigate clickjacking attacks. For example, to protect legacy browsers from clickjacking attacks, you can use frame breaking code(https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script) . While not perfect, the frame breaking code is the best you can do for the legacy browsers. A more modern approach to address clickjacking is to use X-Frame-Options(https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options) header. By default, Spring Security disables rendering pages within an iframe by using with the following header: X-Frame-Options: DENY X-XSS-Protection: See the relevant sections to see how to customize the defaults for both servlet(../../servlet/exploits/headers.html#servlet-headers-xss-protection) - and webflux(../../reactive/exploits/headers.html#webflux-headers-xss-protection) -based applications. Some browsers have built-in support for filtering out reflected XSS attacks(https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OWASP-DV-001)) . The filter has been deprecated in major browsers, and current OWASP recommendation(https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#x-xss-protection) is to explicitly set the header to 0. By default, Spring Security blocks the content by using the following header: X-XSS-Protection: 0 Content Security Policy (CSP): See the relevant sections to see how to configure both servlet(../../servlet/exploits/headers.html#servlet-headers-csp) - and webflux(../../reactive/exploits/headers.html#webflux-headers-csp) -based applications. Content Security Policy (CSP)(https://www.w3.org/TR/CSP2/) is a mechanism that web applications can use to mitigate content injection vulnerabilities, such as cross-site scripting (XSS). CSP is a declarative policy that provides a facility for web application authors to declare and ultimately inform the client (user-agent) about the sources from which the web application expects to load resources. Content Security Policy is not intended to solve all content injection vulnerabilities. Instead, you can use CSP to help reduce the harm caused by content injection attacks. As a first line of defense, web application authors should validate their input and encode their output. A web application can use CSP by including one of the following HTTP headers in the response: Content-Security-Policy Content-Security-Policy-Report-Only Each of these headers are used as a mechanism to deliver a security policy to the client. A security policy contains a set of security policy directives, each responsible for declaring the restrictions for a particular resource representation. For example, a web application can declare that it expects to load scripts from specific, trusted sources by including the following header in the response: Content Security Policy Example Content-Security-Policy: script-src https://trustedscripts.example.com An attempt to load a script from another source other than what is declared in the script-src directive is blocked by the user-agent. Additionally, if the report-uri(https://www.w3.org/TR/CSP2/#directive-report-uri) directive is declared in the security policy, the violation will be reported by the user-agent to the declared URL. For example, if a web application violates the declared security policy, the following response header instructs the user-agent to send violation reports to the URL specified in the policy’s report-uri directive. Content Security Policy with report-uri Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/ Violation reports(https://www.w3.org/TR/CSP2/#violation-reports) are standard JSON structures that can be captured either by the web application’s own API or by a publicly hosted CSP violation reporting service, such as report-uri.io/(https://report-uri.io/) . The Content-Security-Policy-Report-Only header provides the capability for web application authors and administrators to monitor security policies rather than enforce them. This header is typically used when experimenting or developing security policies for a site. When a policy is deemed effective, it can be enforced by using the Content-Security-Policy header field instead. Given the following response header, the policy declares that scripts can be loaded from one of two possible sources. Content Security Policy Report Only Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/ If the site violates this policy, by attempting to load a script from evil.example.com , the user-agent sends a violation report to the declared URL specified by the report-uri directive but still lets the violating resource load. Applying Content Security Policy to a web application is often a non-trivial undertaking. The following resources may provide further assistance in developing effective security policies for your site: An Introduction to Content Security Policy(https://www.html5rocks.com/en/tutorials/security/content-security-policy/) CSP Guide - Mozilla Developer Network(https://developer.mozilla.org/en-US/docs/Web/Security/CSP) W3C Candidate Recommendation(https://www.w3.org/TR/CSP2/) Referrer Policy: See the relevant sections to see how to configure both servlet(../../servlet/exploits/headers.html#servlet-headers-referrer) - and webflux(../../reactive/exploits/headers.html#webflux-headers-referrer) -based applications. Referrer Policy(https://www.w3.org/TR/referrer-policy) is a mechanism that web applications can use to manage the referrer field, which contains the last page the user was on. Spring Security’s approach is to use the Referrer Policy(https://www.w3.org/TR/referrer-policy/) header, which provides different policies(https://www.w3.org/TR/referrer-policy/#referrer-policies) : Referrer Policy Example Referrer-Policy: same-origin The Referrer-Policy response header instructs the browser to let the destination knows the source where the user was previously. Feature Policy: See the relevant sections to see how to configure both servlet(../../servlet/exploits/headers.html#servlet-headers-feature) - and webflux(../../reactive/exploits/headers.html#webflux-headers-feature) -based applications. Feature Policy(https://wicg.github.io/feature-policy/) is a mechanism that lets web developers to selectively enable, disable, and modify the behavior of certain APIs and web features in the browser. Feature Policy Example Feature-Policy: geolocation 'self' With Feature Policy, developers can opt-in to a set of “policies” for the browser to enforce on specific features used throughout your site. These policies restrict what APIs the site can access or modify the browser’s default behavior for certain features. Permissions Policy: See the relevant sections to see how to configure both servlet(../../servlet/exploits/headers.html#servlet-headers-permissions) - and webflux(../../reactive/exploits/headers.html#webflux-headers-permissions) -based applications. Permissions Policy(https://w3c.github.io/webappsec-permissions-policy/) is a mechanism that lets web developers selectively enable, disable, and modify the behavior of certain APIs and web features in the browser. Permissions Policy Example Permissions-Policy: geolocation=(self) With Permissions Policy, developers can opt-in to a set of ""policies"" for the browser to enforce on specific features used throughout your site. These policies restrict what APIs the site can access or modify the browser’s default behavior for certain features. Clear Site Data: See the relevant sections to see how to configure both servlet(../../servlet/exploits/headers.html#servlet-headers-clear-site-data) - and webflux(../../reactive/exploits/headers.html#webflux-headers-clear-site-data) - based applications. Clear Site Data(https://www.w3.org/TR/clear-site-data/) is a mechanism by which any browser-side data (cookies, local storage, and the like) can be removed when an HTTP response contains this header: Clear-Site-Data: ""cache"", ""cookies"", ""storage"", ""executionContexts"" This is a nice clean-up action to perform on logout. Custom Headers: See the relevant section to see how to configure servlet(../../servlet/exploits/headers.html#servlet-headers-custom) based applications. Spring Security has mechanisms to make it convenient to add the more common security headers to your application. However, it also provides hooks to enable adding custom headers."
"https://docs.spring.io/spring-security/reference/6.3/features/exploits/http.html","HTTP: All HTTP-based communication, including static resources(https://www.troyhunt.com/heres-why-your-static-website-needs-https/) , should be protected by using TLS(https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html) . As a framework, Spring Security does not handle HTTP connections and thus does not provide support for HTTPS directly. However, it does provide a number of features that help with HTTPS usage. Redirect to HTTPS: When a client uses HTTP, you can configure Spring Security to redirect to HTTPS in both Servlet(../../servlet/exploits/http.html#servlet-http-redirect) and WebFlux(../../reactive/exploits/http.html#webflux-http-redirect) environments. Strict Transport Security: Spring Security provides support for Strict Transport Security(headers.html#headers-hsts) and enables it by default. Proxy Server Configuration: When using a proxy server, it is important to ensure that you have configured your application properly. For example, many applications have a load balancer that responds to request for https://example.com/ by forwarding the request to an application server at https://192.168.0.107 Without proper configuration, the application server can not know that the load balancer exists and treats the request as though https://192.168.0.107:8080 was requested by the client. To fix this, you can use RFC 7239(https://tools.ietf.org/html/rfc7239) to specify that a load balancer is being used. To make the application aware of this, you need to configure your application server to be aware of the X-Forwarded headers. For example, Tomcat uses RemoteIpValve(https://tomcat.apache.org/tomcat-10.1-doc/api/org/apache/catalina/valves/RemoteIpValve.html) and Jetty uses ForwardedRequestCustomizer(https://eclipse.dev/jetty/javadoc/jetty-11/org/eclipse/jetty/server/ForwardedRequestCustomizer.html) . Alternatively, Spring users can use ForwardedHeaderFilter(https://docs.spring.io/spring-framework/reference/web/webmvc/filters.html#filters-forwarded-headers) with the Servlet stack or ForwardedHeaderTransformer(https://docs.spring.io/spring-framework/reference/web/webflux/reactive-spring.html#webflux-forwarded-headers) with the Reactive stack. Spring Boot users can use the server.forward-headers-strategy property to configure the application. See the Spring Boot documentation(https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto.webserver.use-behind-a-proxy-server) for further details."
"https://docs.spring.io/spring-security/reference/6.3/features/integrations/index.html","Integrations: Spring Security provides integrations with numerous frameworks and APIs. In this section, we discuss generic integrations that are not specific to Servlet or Reactive environments. To see specific integrations, refer to the Servlet(../../servlet/integrations/index.html) and Reactive(../../reactive/integrations/cors.html) Integrations sections. Section Summary: Cryptography(cryptography.html) Spring Data(data.html) Java’s Concurrency APIs(concurrency.html) Jackson(jackson.html) Localization(localization.html)"
"https://docs.spring.io/spring-security/reference/6.3/features/integrations/cryptography.html","Spring Security Crypto Module: The Spring Security Crypto module provides support for symmetric encryption, key generation, and password encoding. The code is distributed as part of the core module but has no dependencies on any other Spring Security (or Spring) code. Encryptors: The Encryptors(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/crypto/encrypt/Encryptors.html) class provides factory methods for constructing symmetric encryptors. This class lets you create BytesEncryptor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/crypto/encrypt/BytesEncryptor.html) instances to encrypt data in raw byte[] form. You can also construct TextEncryptor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/crypto/encrypt/TextEncryptor.html) instances to encrypt text strings. Encryptors are thread-safe. Both BytesEncryptor and TextEncryptor are interfaces. BytesEncryptor has multiple implementations. BytesEncryptor: You can use the Encryptors.stronger factory method to construct a BytesEncryptor : BytesEncryptor Java Kotlin Encryptors.stronger(""password"", ""salt""); Encryptors.stronger(""password"", ""salt"") The stronger encryption method creates an encryptor by using 256-bit AES encryption with Galois Counter Mode (GCM). It derives the secret key by using PKCS #5’s PBKDF2 (Password-Based Key Derivation Function #2). This method requires Java 6. The password used to generate the SecretKey should be kept in a secure place and should not be shared. The salt is used to prevent dictionary attacks against the key in the event that your encrypted data is compromised. A 16-byte random initialization vector is also applied so that each encrypted message is unique. The provided salt should be in hex-encoded String form, be random, and be at least 8 bytes in length. You can generate such a salt by using a KeyGenerator : Generating a key Java Kotlin String salt = KeyGenerators.string().generateKey(); // generates a random 8-byte salt that is then hex-encoded val salt = KeyGenerators.string().generateKey() // generates a random 8-byte salt that is then hex-encoded You can also use the standard encryption method, which is 256-bit AES in Cipher Block Chaining (CBC) Mode. This mode is not authenticated(https://en.wikipedia.org/wiki/Authenticated_encryption) and does not provide any guarantees about the authenticity of the data. For a more secure alternative, use Encryptors.stronger . TextEncryptor: You can use the Encryptors.text factory method to construct a standard TextEncryptor: TextEncryptor Java Kotlin Encryptors.text(""password"", ""salt""); Encryptors.text(""password"", ""salt"") A TextEncryptor uses a standard BytesEncryptor to encrypt text data. Encrypted results are returned as hex-encoded strings for easy storage on the filesystem or in a database. Key Generators: The KeyGenerators(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/crypto/keygen/KeyGenerators.html) class provides a number of convenience factory methods for constructing different types of key generators. By using this class, you can create a BytesKeyGenerator(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/crypto/keygen/BytesKeyGenerator.html) to generate byte[] keys. You can also construct a StringKeyGenerator(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/crypto/keygen/StringKeyGenerator.html`) ` to generate string keys. KeyGenerators is a thread-safe class. BytesKeyGenerator: You can use the KeyGenerators.secureRandom factory methods to generate a BytesKeyGenerator backed by a SecureRandom instance: BytesKeyGenerator Java Kotlin BytesKeyGenerator generator = KeyGenerators.secureRandom(); byte[] key = generator.generateKey(); val generator = KeyGenerators.secureRandom() val key = generator.generateKey() The default key length is 8 bytes. A KeyGenerators.secureRandom variant provides control over the key length: KeyGenerators.secureRandom Java Kotlin KeyGenerators.secureRandom(16); KeyGenerators.secureRandom(16) Use the KeyGenerators.shared factory method to construct a BytesKeyGenerator that always returns the same key on every invocation: KeyGenerators.shared Java Kotlin KeyGenerators.shared(16); KeyGenerators.shared(16) StringKeyGenerator: You can use the KeyGenerators.string factory method to construct an 8-byte, SecureRandom KeyGenerator that hex-encodes each key as a String : StringKeyGenerator Java Kotlin KeyGenerators.string(); KeyGenerators.string() Password Encoding: The password package of the spring-security-crypto module provides support for encoding passwords. PasswordEncoder is the central service interface and has the following signature: public interface PasswordEncoder { String encode(CharSequence rawPassword); boolean matches(CharSequence rawPassword, String encodedPassword); default boolean upgradeEncoding(String encodedPassword) { return false; } } The matches method returns true if the rawPassword , once encoded, equals the encodedPassword . This method is designed to support password-based authentication schemes. The BCryptPasswordEncoder implementation uses the widely supported “bcrypt” algorithm to hash the passwords. Bcrypt uses a random 16-byte salt value and is a deliberately slow algorithm, to hinder password crackers. You can tune the amount of work it does by using the strength parameter, which takes a value from 4 to 31. The higher the value, the more work has to be done to calculate the hash. The default value is 10 . You can change this value in your deployed system without affecting existing passwords, as the value is also stored in the encoded hash. The following example uses the BCryptPasswordEncoder : BCryptPasswordEncoder Java Kotlin // Create an encoder with strength 16 BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16); String result = encoder.encode(""myPassword""); assertTrue(encoder.matches(""myPassword"", result)); // Create an encoder with strength 16 val encoder = BCryptPasswordEncoder(16) val result: String = encoder.encode(""myPassword"") assertTrue(encoder.matches(""myPassword"", result)) The Pbkdf2PasswordEncoder implementation uses PBKDF2 algorithm to hash the passwords. To defeat password cracking, PBKDF2 is a deliberately slow algorithm and should be tuned to take about .5 seconds to verify a password on your system. The following system uses the Pbkdf2PasswordEncoder : Pbkdf2PasswordEncoder Java Kotlin // Create an encoder with all the defaults Pbkdf2PasswordEncoder encoder = Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8(); String result = encoder.encode(""myPassword""); assertTrue(encoder.matches(""myPassword"", result)); // Create an encoder with all the defaults val encoder = Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8() val result: String = encoder.encode(""myPassword"") assertTrue(encoder.matches(""myPassword"", result))"
"https://docs.spring.io/spring-security/reference/6.3/features/integrations/data.html","Spring Data Integration: Spring Security provides Spring Data integration that allows referring to the current user within your queries. It is not only useful but necessary to include the user in the queries to support paged results since filtering the results afterwards would not scale. Spring Data & Spring Security Configuration: To use this support, add org.springframework.security:spring-security-data dependency and provide a bean of type SecurityEvaluationContextExtension . In Java Configuration, this would look like: Java Kotlin @Bean public SecurityEvaluationContextExtension securityEvaluationContextExtension() { return new SecurityEvaluationContextExtension(); } @Bean fun securityEvaluationContextExtension(): SecurityEvaluationContextExtension { return SecurityEvaluationContextExtension() } In XML Configuration, this would look like: <bean class=""org.springframework.security.data.repository.query.SecurityEvaluationContextExtension""/> Security Expressions within @Query: Now Spring Security can be used within your queries. For example: Java Kotlin @Repository public interface MessageRepository extends PagingAndSortingRepository<Message,Long> { @Query(""select m from Message m where m.to.id = ?#{ principal?.id }"") Page<Message> findInbox(Pageable pageable); } @Repository interface MessageRepository : PagingAndSortingRepository<Message?, Long?> { @Query(""select m from Message m where m.to.id = ?#{ principal?.id }"") fun findInbox(pageable: Pageable?): Page<Message?>? } This checks to see if the Authentication.getPrincipal().getId() is equal to the recipient of the Message . Note that this example assumes you have customized the principal to be an Object that has an id property. By exposing the SecurityEvaluationContextExtension bean, all of the Common Security Expressions(../../servlet/authorization/method-security.html#authorization-expressions) are available within the Query."
"https://docs.spring.io/spring-security/reference/6.3/features/integrations/concurrency.html","Concurrency Support: In most environments, Security is stored on a per Thread basis. This means that when work is done on a new Thread , the SecurityContext is lost. Spring Security provides some infrastructure to help make this much easier for users. Spring Security provides low level abstractions for working with Spring Security in multi-threaded environments. In fact, this is what Spring Security builds on to integration with AsyncContext.start(Runnable)(../../servlet/integrations/servlet-api.html#servletapi-start-runnable) and Spring MVC Async Integration(../../servlet/integrations/mvc.html#mvc-async) . DelegatingSecurityContextRunnable: One of the most fundamental building blocks within Spring Security’s concurrency support is the DelegatingSecurityContextRunnable . It wraps a delegate Runnable in order to initialize the SecurityContextHolder with a specified SecurityContext for the delegate. It then invokes the delegate Runnable ensuring to clear the SecurityContextHolder afterwards. The DelegatingSecurityContextRunnable looks something like this: Java Kotlin public void run() { try { SecurityContextHolder.setContext(securityContext); delegate.run(); } finally { SecurityContextHolder.clearContext(); } } fun run() { try { SecurityContextHolder.setContext(securityContext) delegate.run() } finally { SecurityContextHolder.clearContext() } } While very simple, it makes it seamless to transfer the SecurityContext from one Thread to another. This is important since, in most cases, the SecurityContextHolder acts on a per Thread basis. For example, you might have used Spring Security’s <global-method-security>(../../servlet/appendix/namespace/method-security.html#nsa-global-method-security) support to secure one of your services. You can now easily transfer the SecurityContext of the current Thread to the Thread that invokes the secured service. An example of how you might do this can be found below: Java Kotlin Runnable originalRunnable = new Runnable() { public void run() { // invoke secured service } }; SecurityContext context = SecurityContextHolder.getContext(); DelegatingSecurityContextRunnable wrappedRunnable = new DelegatingSecurityContextRunnable(originalRunnable, context); new Thread(wrappedRunnable).start(); val originalRunnable = Runnable { // invoke secured service } val context: SecurityContext = SecurityContextHolder.getContext() val wrappedRunnable = DelegatingSecurityContextRunnable(originalRunnable, context) Thread(wrappedRunnable).start() The code above performs the following steps: Creates a Runnable that will be invoking our secured service. Notice that it is not aware of Spring Security Obtains the SecurityContext that we wish to use from the SecurityContextHolder and initializes the DelegatingSecurityContextRunnable Use the DelegatingSecurityContextRunnable to create a Thread Start the Thread we created Since it is quite common to create a DelegatingSecurityContextRunnable with the SecurityContext from the SecurityContextHolder there is a shortcut constructor for it. The following code is the same as the code above: Java Kotlin Runnable originalRunnable = new Runnable() { public void run() { // invoke secured service } }; DelegatingSecurityContextRunnable wrappedRunnable = new DelegatingSecurityContextRunnable(originalRunnable); new Thread(wrappedRunnable).start(); val originalRunnable = Runnable { // invoke secured service } val wrappedRunnable = DelegatingSecurityContextRunnable(originalRunnable) Thread(wrappedRunnable).start() The code we have is simple to use, but it still requires knowledge that we are using Spring Security. In the next section we will take a look at how we can utilize DelegatingSecurityContextExecutor to hide the fact that we are using Spring Security. DelegatingSecurityContextExecutor: In the previous section we found that it was easy to use the DelegatingSecurityContextRunnable , but it was not ideal since we had to be aware of Spring Security in order to use it. Let’s take a look at how DelegatingSecurityContextExecutor can shield our code from any knowledge that we are using Spring Security. The design of DelegatingSecurityContextExecutor is very similar to that of DelegatingSecurityContextRunnable except it accepts a delegate Executor instead of a delegate Runnable . You can see an example of how it might be used below: Java Kotlin SecurityContext context = SecurityContextHolder.createEmptyContext(); Authentication authentication = UsernamePasswordAuthenticationToken.authenticated(""user"",""doesnotmatter"", AuthorityUtils.createAuthorityList(""ROLE_USER"")); context.setAuthentication(authentication); SimpleAsyncTaskExecutor delegateExecutor = new SimpleAsyncTaskExecutor(); DelegatingSecurityContextExecutor executor = new DelegatingSecurityContextExecutor(delegateExecutor, context); Runnable originalRunnable = new Runnable() { public void run() { // invoke secured service } }; executor.execute(originalRunnable); val context: SecurityContext = SecurityContextHolder.createEmptyContext() val authentication: Authentication = UsernamePasswordAuthenticationToken(""user"", ""doesnotmatter"", AuthorityUtils.createAuthorityList(""ROLE_USER"")) context.authentication = authentication val delegateExecutor = SimpleAsyncTaskExecutor() val executor = DelegatingSecurityContextExecutor(delegateExecutor, context) val originalRunnable = Runnable { // invoke secured service } executor.execute(originalRunnable) The code performs the following steps: Creates the SecurityContext to be used for our DelegatingSecurityContextExecutor . Note that in this example we simply create the SecurityContext by hand. However, it does not matter where or how we get the SecurityContext (i.e. we could obtain it from the SecurityContextHolder if we wanted). Creates a delegateExecutor that is in charge of executing submitted Runnable s Finally we create a DelegatingSecurityContextExecutor which is in charge of wrapping any Runnable that is passed into the execute method with a DelegatingSecurityContextRunnable . It then passes the wrapped Runnable to the delegateExecutor. In this instance, the same SecurityContext will be used for every Runnable submitted to our DelegatingSecurityContextExecutor . This is nice if we are running background tasks that need to be run by a user with elevated privileges. At this point you may be asking yourself ""How does this shield my code of any knowledge of Spring Security?"" Instead of creating the SecurityContext and the DelegatingSecurityContextExecutor in our own code, we can inject an already initialized instance of DelegatingSecurityContextExecutor . Java Kotlin @Autowired private Executor executor; // becomes an instance of our DelegatingSecurityContextExecutor public void submitRunnable() { Runnable originalRunnable = new Runnable() { public void run() { // invoke secured service } }; executor.execute(originalRunnable); } @Autowired lateinit var executor: Executor // becomes an instance of our DelegatingSecurityContextExecutor fun submitRunnable() { val originalRunnable = Runnable { // invoke secured service } executor.execute(originalRunnable) } Now our code is unaware that the SecurityContext is being propagated to the Thread , then the originalRunnable is run, and then the SecurityContextHolder is cleared out. In this example, the same user is being used to run each thread. What if we wanted to use the user from SecurityContextHolder at the time we invoked executor.execute(Runnable) (i.e. the currently logged in user) to process originalRunnable ? This can be done by removing the SecurityContext argument from our DelegatingSecurityContextExecutor constructor. For example: Java Kotlin SimpleAsyncTaskExecutor delegateExecutor = new SimpleAsyncTaskExecutor(); DelegatingSecurityContextExecutor executor = new DelegatingSecurityContextExecutor(delegateExecutor); val delegateExecutor = SimpleAsyncTaskExecutor() val executor = DelegatingSecurityContextExecutor(delegateExecutor) Now anytime executor.execute(Runnable) is executed the SecurityContext is first obtained by the SecurityContextHolder and then that SecurityContext is used to create our DelegatingSecurityContextRunnable . This means that we are running our Runnable with the same user that was used to invoke the executor.execute(Runnable) code. Spring Security Concurrency Classes: Refer to the Javadoc for additional integrations with both the Java concurrent APIs and the Spring Task abstractions. They are quite self-explanatory once you understand the previous code. DelegatingSecurityContextCallable DelegatingSecurityContextExecutor DelegatingSecurityContextExecutorService DelegatingSecurityContextRunnable DelegatingSecurityContextScheduledExecutorService DelegatingSecurityContextSchedulingTaskExecutor DelegatingSecurityContextAsyncTaskExecutor DelegatingSecurityContextTaskExecutor DelegatingSecurityContextTaskScheduler"
"https://docs.spring.io/spring-security/reference/6.3/features/integrations/jackson.html","Jackson Support: Spring Security provides Jackson support for persisting Spring Security related classes. This can improve the performance of serializing Spring Security related classes when working with distributed sessions (i.e. session replication, Spring Session, etc). To use it, register the SecurityJackson2Modules.getModules(ClassLoader) with ObjectMapper ( jackson-databind(https://github.com/FasterXML/jackson-databind) ): Java Kotlin ObjectMapper mapper = new ObjectMapper(); ClassLoader loader = getClass().getClassLoader(); List<Module> modules = SecurityJackson2Modules.getModules(loader); mapper.registerModules(modules); // ... use ObjectMapper as normally ... SecurityContext context = new SecurityContextImpl(); // ... String json = mapper.writeValueAsString(context); val mapper = ObjectMapper() val loader = javaClass.classLoader val modules: MutableList<Module> = SecurityJackson2Modules.getModules(loader) mapper.registerModules(modules) // ... use ObjectMapper as normally ... val context: SecurityContext = SecurityContextImpl() // ... val json: String = mapper.writeValueAsString(context) The following Spring Security modules provide Jackson support: spring-security-core ( CoreJackson2Module ) spring-security-web ( WebJackson2Module , WebServletJackson2Module , WebServerJackson2Module ) spring-security-oauth2-client(../../servlet/oauth2/client/index.html#oauth2client) ( OAuth2ClientJackson2Module ) spring-security-cas ( CasJackson2Module )"
"https://docs.spring.io/spring-security/reference/6.3/features/integrations/localization.html","Localization: If you need to support other locales, everything you need to know is contained in this section. All exception messages can be localized, including messages related to authentication failures and access being denied (authorization failures). Exceptions and logging messages that are focused on developers or system deplopers (including incorrect attributes, interface contract violations, using incorrect constructors, startup time validation, debug-level logging) are not localized and instead are hard-coded in English within Spring Security’s code. Shipping in the spring-security-core-xx.jar you will find an org.springframework.security package that in turn contains a messages.properties file, as well as localized versions for some common languages. This should be referred to by your ApplicationContext , as Spring Security classes implement Spring’s MessageSourceAware interface and expect the message resolver to be dependency injected at application context startup time. Usually all you need to do is register a bean inside your application context to refer to the messages. An example is shown below: <bean id=""messageSource"" class=""org.springframework.context.support.ReloadableResourceBundleMessageSource""> <property name=""basename"" value=""classpath:org/springframework/security/messages""/> </bean> The messages.properties is named in accordance with standard resource bundles and represents the default language supported by Spring Security messages. This default file is in English. If you wish to customize the messages.properties file, or support other languages, you should copy the file, rename it accordingly, and register it inside the above bean definition. There are not a large number of message keys inside this file, so localization should not be considered a major initiative. If you do perform localization of this file, please consider sharing your work with the community by logging a JIRA task and attaching your appropriately-named localized version of messages.properties . Spring Security relies on Spring’s localization support in order to actually lookup the appropriate message. In order for this to work, you have to make sure that the locale from the incoming request is stored in Spring’s org.springframework.context.i18n.LocaleContextHolder . Spring MVC’s DispatcherServlet does this for your application automatically, but since Spring Security’s filters are invoked before this, the LocaleContextHolder needs to be set up to contain the correct Locale before the filters are called. You can either do this in a filter yourself (which must come before the Spring Security filters in web.xml ) or you can use Spring’s RequestContextFilter . Please refer to the Spring Framework documentation for further details on using localization with Spring. The ""contacts"" sample application is set up to use localized messages."
"https://docs.spring.io/spring-security/reference/6.3/modules.html","Project Modules and Dependencies: Even if you do not use Maven, we recommend that you consult the pom.xml files to get an idea of third-party dependencies and versions. Another good idea is to examine the libraries that are included in the sample applications. This section provides a reference of the modules in Spring Security and the additional dependencies that they require in order to function in a running application. We do not include dependencies that are used only when building or testing Spring Security itself. Nor do we include transitive dependencies that are required by external dependencies. The version of Spring required is listed on the project website, so the specific versions are omitted for Spring dependencies in the examples. Note that some of the dependencies listed as “optional” in the examples may still be required for other non-security functionality in a Spring application Also dependencies listed as “optional” may not actually be marked as such in the project’s Maven POM files if they are used in most applications. They are “optional” only in the sense that you do not need them unless you use the specified functionality. Where a module depends on another Spring Security module, the non-optional dependencies of the module it depends on are also assumed to be required and are not listed separately. Core — spring-security-core.jar: This module contains core authentication and access-control classes and interfaces, remoting support, and basic provisioning APIs. It is required by any application that uses Spring Security. It supports standalone applications, remote clients, method (service layer) security, and JDBC user provisioning. It contains the following top-level packages: org.springframework.security.core org.springframework.security.access org.springframework.security.authentication org.springframework.security.provisioning Table 1. Core Dependencies Dependency Version Description ehcache 1.6.2 Required if the Ehcache-based user cache implementation is used (optional). spring-aop Method security is based on Spring AOP spring-beans Required for Spring configuration spring-expression Required for expression-based method security (optional) spring-jdbc Required if using a database to store user data (optional). spring-tx Required if using a database to store user data (optional). aspectjrt 1.6.10 Required if using AspectJ support (optional). jsr250-api 1.0 Required if you are using JSR-250 method-security annotations (optional). Remoting — spring-security-remoting.jar: This module provides integration with Spring Remoting. You do not need this unless you are writing a remote client that uses Spring Remoting. The main package is org.springframework.security.remoting . Table 2. Remoting Dependencies Dependency Version Description spring-security-core spring-web Required for clients which use HTTP remoting support. Web — spring-security-web.jar: This module contains filters and related web-security infrastructure code. It contains anything with a servlet API dependency. You need it if you require Spring Security web authentication services and URL-based access-control. The main package is org.springframework.security.web . Table 3. Web Dependencies Dependency Version Description spring-security-core spring-web Required for clients that use HTTP remoting support. spring-jdbc Required for a JDBC-based persistent remember-me token repository (optional). spring-tx Required by remember-me persistent token repository implementations (optional). Config — spring-security-config.jar: This module contains the security namespace parsing code and Java configuration code. You need it if you use the Spring Security XML namespace for configuration or Spring Security’s Java Configuration support. The main package is org.springframework.security.config . None of the classes are intended for direct use in an application. Table 4. Config Dependencies Dependency Version Description spring-security-core spring-security-web Required if you are using any web-related namespace configuration (optional). spring-security-ldap Required if you are using the LDAP namespace options (optional). aspectjweaver 1.6.10 Required if using the protect-pointcut namespace syntax (optional). LDAP — spring-security-ldap.jar: This module provides LDAP authentication and provisioning code. It is required if you need to use LDAP authentication or manage LDAP user entries. The top-level package is org.springframework.security.ldap . Table 5. LDAP Dependencies Dependency Version Description spring-security-core spring-ldap-core 1.3.0 LDAP support is based on Spring LDAP. spring-tx Data exception classes are required. apache-ds 1.5.5 Required if you are using an embedded LDAP server (optional). If you use apache-ds , the apacheds-core , apacheds-core-entry , apacheds-protocol-shared , apacheds-protocol-ldap and apacheds-server-jndi modules are required. shared-ldap 0.9.15 Required if you are using an embedded LDAP server (optional). ldapsdk 4.1 Mozilla LdapSDK. Used for decoding LDAP password policy controls if you are using password-policy functionality with OpenLDAP, for example. OAuth 2.0 Core — spring-security-oauth2-core.jar: spring-security-oauth2-core.jar contains core classes and interfaces that provide support for the OAuth 2.0 Authorization Framework and for OpenID Connect Core 1.0. It is required by applications that use OAuth 2.0 or OpenID Connect Core 1.0, such as client, resource server, and authorization server. The top-level package is org.springframework.security.oauth2.core . OAuth 2.0 Client — spring-security-oauth2-client.jar: spring-security-oauth2-client.jar contains Spring Security’s client support for OAuth 2.0 Authorization Framework and OpenID Connect Core 1.0. It is required by applications that use OAuth 2.0 or OpenID Connect Core 1.0, such as the client, the resource server, and the authorization server. The top-level package is org.springframework.security.oauth2.core . OAuth 2.0 JOSE — spring-security-oauth2-jose.jar: spring-security-oauth2-jose.jar contains Spring Security’s support for the JOSE (Javascript Object Signing and Encryption) framework. The JOSE framework is intended to provide a method to securely transfer claims between parties. It is built from a collection of specifications: JSON Web Token (JWT) JSON Web Signature (JWS) JSON Web Encryption (JWE) JSON Web Key (JWK) It contains the following top-level packages: org.springframework.security.oauth2.jwt org.springframework.security.oauth2.jose OAuth 2.0 Resource Server — spring-security-oauth2-resource-server.jar: spring-security-oauth2-resource-server.jar contains Spring Security’s support for OAuth 2.0 Resource Servers. It is used to protect APIs by using OAuth 2.0 Bearer Tokens. The top-level package is org.springframework.security.oauth2.server.resource . ACL — spring-security-acl.jar: This module contains a specialized domain object ACL implementation. It is used to apply security to specific domain object instances within your application. The top-level package is org.springframework.security.acls . Table 6. ACL Dependencies Dependency Version Description spring-security-core ehcache 1.6.2 Required if the Ehcache-based ACL cache implementation is used (optional if you use your own implementation). spring-jdbc Required if you are using the default JDBC-based AclService (optional if you implement your own). spring-tx Required if you are using the default JDBC-based AclService (optional if you implement your own). CAS — spring-security-cas.jar: This module contains Spring Security’s CAS client integration. You should use it if you want to use Spring Security web authentication with a CAS single sign-on server. The top-level package is org.springframework.security.cas . Table 7. CAS Dependencies Dependency Version Description spring-security-core spring-security-web cas-client-core 3.1.12 The JA-SIG CAS Client. This is the basis of the Spring Security integration. ehcache 1.6.2 Required if you are using the Ehcache-based ticket cache (optional). Test — spring-security-test.jar: This module contains support for testing with Spring Security. Taglibs — spring-security-taglibs.jar: Provides Spring Security’s JSP tag implementations. Table 8. Taglib Dependencies Dependency Version Description spring-security-core spring-security-web spring-security-acl Required if you are using the accesscontrollist tag or hasPermission() expressions with ACLs (optional). spring-expression Required if you are using SPEL expressions in your tag access constraints."
"https://docs.spring.io/spring-security/reference/6.3/samples.html","Samples: Spring Security includes many samples(https://github.com/spring-projects/spring-security-samples/tree/6.3.x) applications. These samples are being migrated to a separate project, however, you can still find the not migrated samples in an older branch of the Spring Security repository(https://github.com/spring-projects/spring-security/tree/5.4.x/samples) ."
"https://docs.spring.io/spring-security/reference/6.3/servlet/index.html","Servlet Applications: Spring Security integrates with the Servlet Container by using a standard Servlet Filter . This means it works with any application that runs in a Servlet Container. More concretely, you do not need to use Spring in your Servlet-based application to take advantage of Spring Security. Section Summary: Getting Started(getting-started.html) Architecture(architecture.html) Authentication(authentication/index.html) Authorization(authorization/index.html) OAuth2(oauth2/index.html) SAML2(saml2/index.html) Protection Against Exploits(exploits/index.html) Integrations(integrations/index.html) Configuration Testing(test/index.html) Appendix(appendix/index.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/getting-started.html","Hello Spring Security: This section covers the minimum setup for how to use Spring Security with Spring Boot(https://docs.spring.io/spring-boot/docs/3.1.1/reference/html/) and then points you to next steps after that. The completed starter application can be found in our samples repository(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/spring-boot/java/hello-security) . For your convenience, you can download a minimal Spring Boot + Spring Security application prepared by Spring Initializr(https://start.spring.io/starter.zip?type=maven-project&language=java&packaging=jar&jvmVersion=1.8&groupId=example&artifactId=hello-security&name=hello-security&description=Hello%20Security&packageName=example.hello-security&dependencies=web,security) . Updating Dependencies: You first need to add Spring Security to your application’s classpath; two ways to do this are to use Maven(../getting-spring-security.html#getting-maven-boot) or Gradle(../getting-spring-security.html#getting-gradle-boot) . Starting Hello Spring Security Boot: With Spring Security on the classpath(#servlet-hello-dependencies) , you can now run the Spring Boot application(https://docs.spring.io/spring-boot/docs/3.1.1/reference/html/#using.running-your-application) . The following snippet shows some of the output that indicates that Spring Security is enabled in your application: Running Spring Boot Application Maven Gradle Jar $ ./mvnw spring-boot:run ... INFO 23689 --- [ restartedMain] .s.s.UserDetailsServiceAutoConfiguration : Using generated security password: 8e557245-73e2-4286-969a-ff57fe326336 ... $ ./gradlew :bootRun ... INFO 23689 --- [ restartedMain] .s.s.UserDetailsServiceAutoConfiguration : Using generated security password: 8e557245-73e2-4286-969a-ff57fe326336 ... $ java -jar target/myapplication-0.0.1.jar ... INFO 23689 --- [ restartedMain] .s.s.UserDetailsServiceAutoConfiguration : Using generated security password: 8e557245-73e2-4286-969a-ff57fe326336 ... Now that you have it running, you might try hitting an endpoint to see what happens. If you hit an endpoint without credentials like so: Querying a Secured Boot Application $ curl -i http://localhost:8080/some/path HTTP/1.1 401 ... then Spring Security denies access with a 401 Unauthorized . If you provide the same URL in a browser, it will redirect to a default login page. And if you hit an endpoint with credentials (found in the console output) as follows: Querying with Credentials $ curl -i -u user:8e557245-73e2-4286-969a-ff57fe326336 http://localhost:8080/some/path HTTP/1.1 404 ... then Spring Boot will service the request, returning a 404 Not Found in this case since /some/path doesn’t exist. From here, you can: Better understand what Spring Boot enables in Spring Security by default(#servlet-hello-auto-configuration) Read about common use cases(#security-use-cases) that Spring Security helps with Start configuring authentication(authentication/index.html) Runtime Expectations: The default arrangement of Spring Boot and Spring Security affords the following behaviors at runtime: Requires an authenticated user for any endpoint(authorization/authorize-http-requests.html) (including Boot’s /error endpoint) Registers a default user(authentication/passwords/user-details-service.html) with a generated password at startup (the password is logged to the console; in the preceding example, the password is 8e557245-73e2-4286-969a-ff57fe326336 ) Protects password storage with BCrypt(authentication/passwords/password-encoder.html) as well as others Provides form-based login(authentication/passwords/form.html) and logout(authentication/logout.html) flows Authenticates form-based login(authentication/passwords/form.html) as well as HTTP Basic(authentication/passwords/basic.html) Provides content negotiation; for web requests, redirects to the login page; for service requests, returns a 401 Unauthorized Mitigates CSRF(exploits/csrf.html) attacks Mitigates Session Fixation(authentication/session-management.html#ns-session-fixation) attacks Writes Strict-Transport-Security(exploits/headers.html#servlet-headers-hsts) to ensure HTTPS(https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security) Writes X-Content-Type-Options(exploits/headers.html#servlet-headers-content-type-options) to mitigate sniffing attacks(https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#x-content-type-options) Writes Cache Control headers(exploits/headers.html#servlet-headers-cache-control) that protect authenticated resources Writes X-Frame-Options(exploits/headers.html#servlet-headers-frame-options) to mitigate Clickjacking(https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#x-frame-options) Integrates with HttpServletRequest's authentication methods(integrations/servlet-api.html) Publishes authentication success and failure events(authentication/events.html) It can be helpful to understand how Spring Boot is coordinating with Spring Security to achieve this. Taking a look at Boot’s security auto configuration(https://docs.spring.io/spring-boot/docs/3.1.1/api/org/springframework/boot/autoconfigure/security/servlet/SecurityAutoConfiguration.html) , it does the following (simplified for illustration): Spring Boot Security Auto Configuration @EnableWebSecurity (1) @Configuration public class DefaultSecurityConfig { @Bean @ConditionalOnMissingBean(UserDetailsService.class) InMemoryUserDetailsManager inMemoryUserDetailsManager() { (2) String generatedPassword = // ...; return new InMemoryUserDetailsManager(User.withUsername(""user"") .password(generatedPassword).roles(""USER"").build()); } @Bean @ConditionalOnMissingBean(AuthenticationEventPublisher.class) DefaultAuthenticationEventPublisher defaultAuthenticationEventPublisher(ApplicationEventPublisher delegate) { (3) return new DefaultAuthenticationEventPublisher(delegate); } } Adds the @EnableWebSecurity annotation. (Among other things, this publishes Spring Security’s default Filter chain(architecture.html#servlet-securityfilterchain) as a @Bean ) Publishes a UserDetailsService(authentication/passwords/user-details-service.html) @Bean with a username of user and a randomly generated password that is logged to the console Publishes an AuthenticationEventPublisher(authentication/events.html) @Bean for publishing authentication events Spring Boot adds any Filter published as a @Bean to the application’s filter chain. This means that using @EnableWebSecurity in conjunction with Spring Boot automatically registers Spring Security’s filter chain for every request. Security Use Cases: There are a number of places that you may want to go from here. To figure out what’s next for you and your application, consider these common use cases that Spring Security is built to address: I am building a REST API, and I need to authenticate a JWT(oauth2/resource-server/jwt.html) or other bearer token(oauth2/resource-server/opaque-token.html) I am building a Web Application, API Gateway, or BFF and I need to login using OAuth 2.0 or OIDC(oauth2/login/core.html) I need to login using SAML 2.0(saml2/login/index.html) I need to login using CAS(authentication/cas.html) I need to manage Users in LDAP(authentication/passwords/ldap.html) or Active Directory(authentication/passwords/ldap.html#_active_directory) , with Spring Data(integrations/data.html) , or with JDBC(authentication/passwords/jdbc.html) Passwords(authentication/passwords/storage.html) In case none of those match what you are looking for, consider thinking about your application in the following order: Protocol : First, consider the protocol your application will use to communicate. For servlet-based applications, Spring Security supports HTTP as well as Websockets(integrations/websocket.html) . Authentication : Next, consider how users will authenticate(authentication/index.html) and if that authentication will be stateful or stateless Authorization : Then, consider how you will determine what a user is authorized to do(authorization/index.html) Defense : Finally, integrate with Spring Security’s default protections(exploits/csrf.html#csrf-considerations) and consider which additional protections you need(exploits/headers.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/architecture.html","Architecture: This section discusses Spring Security’s high-level architecture within Servlet based applications. We build on this high-level understanding within the Authentication(authentication/index.html#servlet-authentication) , Authorization(authorization/index.html#servlet-authorization) , and Protection Against Exploits(exploits/index.html#servlet-exploits) sections of the reference. A Review of Filters: Spring Security’s Servlet support is based on Servlet Filters, so it is helpful to look at the role of Filters generally first. The following image shows the typical layering of the handlers for a single HTTP request. Figure 1. FilterChain The client sends a request to the application, and the container creates a FilterChain , which contains the Filter instances and Servlet that should process the HttpServletRequest , based on the path of the request URI. In a Spring MVC application, the Servlet is an instance of DispatcherServlet(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html/web.html#mvc-servlet) . At most, one Servlet can handle a single HttpServletRequest and HttpServletResponse . However, more than one Filter can be used to: Prevent downstream Filter instances or the Servlet from being invoked. In this case, the Filter typically writes the HttpServletResponse . Modify the HttpServletRequest or HttpServletResponse used by the downstream Filter instances and the Servlet . The power of the Filter comes from the FilterChain that is passed into it. FilterChain Usage Example Java Kotlin public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) { // do something before the rest of the application chain.doFilter(request, response); // invoke the rest of the application // do something after the rest of the application } fun doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) { // do something before the rest of the application chain.doFilter(request, response) // invoke the rest of the application // do something after the rest of the application } Since a Filter impacts only downstream Filter instances and the Servlet , the order in which each Filter is invoked is extremely important. DelegatingFilterProxy: Spring provides a Filter implementation named DelegatingFilterProxy(https://docs.spring.io/spring-framework/docs/6.1.12/javadoc-api/org/springframework/web/filter/DelegatingFilterProxy.html) that allows bridging between the Servlet container’s lifecycle and Spring’s ApplicationContext . The Servlet container allows registering Filter instances by using its own standards, but it is not aware of Spring-defined Beans. You can register DelegatingFilterProxy through the standard Servlet container mechanisms but delegate all the work to a Spring Bean that implements Filter . Here is a picture of how DelegatingFilterProxy fits into the Filter instances and the FilterChain(#servlet-filters-review) . Figure 2. DelegatingFilterProxy DelegatingFilterProxy looks up Bean Filter 0 from the ApplicationContext and then invokes Bean Filter 0 . The following listing shows pseudo code of DelegatingFilterProxy : DelegatingFilterProxy Pseudo Code Java Kotlin public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) { Filter delegate = getFilterBean(someBeanName); (1) delegate.doFilter(request, response); (2) } fun doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) { val delegate: Filter = getFilterBean(someBeanName) (1) delegate.doFilter(request, response) (2) } 1 Lazily get Filter that was registered as a Spring Bean. For the example in DelegatingFilterProxy(#servlet-delegatingfilterproxy-figure) delegate is an instance of Bean Filter 0 . 2 Delegate work to the Spring Bean. Another benefit of DelegatingFilterProxy is that it allows delaying looking up Filter bean instances. This is important because the container needs to register the Filter instances before the container can start up. However, Spring typically uses a ContextLoaderListener to load the Spring Beans, which is not done until after the Filter instances need to be registered. FilterChainProxy: Spring Security’s Servlet support is contained within FilterChainProxy . FilterChainProxy is a special Filter provided by Spring Security that allows delegating to many Filter instances through SecurityFilterChain(#servlet-securityfilterchain) . Since FilterChainProxy is a Bean, it is typically wrapped in a DelegatingFilterProxy(#servlet-delegatingfilterproxy) . The following image shows the role of FilterChainProxy . Figure 3. FilterChainProxy SecurityFilterChain: SecurityFilterChain(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/SecurityFilterChain.html) is used by FilterChainProxy(#servlet-filterchainproxy) to determine which Spring Security Filter instances should be invoked for the current request. The following image shows the role of SecurityFilterChain . Figure 4. SecurityFilterChain The Security Filters(#servlet-security-filters) in SecurityFilterChain are typically Beans, but they are registered with FilterChainProxy instead of DelegatingFilterProxy(#servlet-delegatingfilterproxy) . FilterChainProxy provides a number of advantages to registering directly with the Servlet container or DelegatingFilterProxy(#servlet-delegatingfilterproxy) . First, it provides a starting point for all of Spring Security’s Servlet support. For that reason, if you try to troubleshoot Spring Security’s Servlet support, adding a debug point in FilterChainProxy is a great place to start. Second, since FilterChainProxy is central to Spring Security usage, it can perform tasks that are not viewed as optional. For example, it clears out the SecurityContext to avoid memory leaks. It also applies Spring Security’s HttpFirewall(exploits/firewall.html#servlet-httpfirewall) to protect applications against certain types of attacks. In addition, it provides more flexibility in determining when a SecurityFilterChain should be invoked. In a Servlet container, Filter instances are invoked based upon the URL alone. However, FilterChainProxy can determine invocation based upon anything in the HttpServletRequest by using the RequestMatcher interface. The following image shows multiple SecurityFilterChain instances: Figure 5. Multiple SecurityFilterChain In the Multiple SecurityFilterChain(#servlet-multi-securityfilterchain-figure) figure, FilterChainProxy decides which SecurityFilterChain should be used. Only the first SecurityFilterChain that matches is invoked. If a URL of /api/messages/ is requested, it first matches on the SecurityFilterChain 0 pattern of /api/** , so only SecurityFilterChain 0 is invoked, even though it also matches on SecurityFilterChain n . If a URL of /messages/ is requested, it does not match on the SecurityFilterChain 0 pattern of /api/** , so FilterChainProxy continues trying each SecurityFilterChain . Assuming that no other SecurityFilterChain instances match, SecurityFilterChain n is invoked. Notice that SecurityFilterChain 0 has only three security Filter instances configured. However, SecurityFilterChain n has four security Filter instances configured. It is important to note that each SecurityFilterChain can be unique and can be configured in isolation. In fact, a SecurityFilterChain might have zero security Filter instances if the application wants Spring Security to ignore certain requests. Security Filters: The Security Filters are inserted into the FilterChainProxy(#servlet-filterchainproxy) with the SecurityFilterChain(#servlet-securityfilterchain) API. Those filters can be used for a number of different purposes, like authentication(authentication/index.html) , authorization(authorization/index.html) , exploit protection(exploits/index.html) , and more. The filters are executed in a specific order to guarantee that they are invoked at the right time, for example, the Filter that performs authentication should be invoked before the Filter that performs authorization. It is typically not necessary to know the ordering of Spring Security’s Filter s. However, there are times that it is beneficial to know the ordering, if you want to know them, you can check the FilterOrderRegistration code(https://github.com/spring-projects/spring-security/tree/6.3.3/config/src/main/java/org/springframework/security/config/annotation/web/builders/FilterOrderRegistration.java) . To exemplify the above paragraph, let’s consider the following security configuration: Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .csrf(Customizer.withDefaults()) .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .httpBasic(Customizer.withDefaults()) .formLogin(Customizer.withDefaults()); return http.build(); } } import org.springframework.security.config.web.servlet.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun filterChain(http: HttpSecurity): SecurityFilterChain { http { csrf { } authorizeHttpRequests { authorize(anyRequest, authenticated) } httpBasic { } formLogin { } } return http.build() } } The above configuration will result in the following Filter ordering: Filter Added by CsrfFilter(exploits/csrf.html) HttpSecurity#csrf UsernamePasswordAuthenticationFilter(authentication/passwords/form.html#servlet-authentication-form) HttpSecurity#formLogin BasicAuthenticationFilter(authentication/passwords/basic.html) HttpSecurity#httpBasic AuthorizationFilter(authorization/authorize-http-requests.html) HttpSecurity#authorizeHttpRequests First, the CsrfFilter is invoked to protect against CSRF attacks(exploits/csrf.html) . Second, the authentication filters are invoked to authenticate the request. Third, the AuthorizationFilter is invoked to authorize the request. There might be other Filter instances that are not listed above. If you want to see the list of filters invoked for a particular request, you can print them(#servlet-print-filters) . Printing the Security Filters: Often times, it is useful to see the list of security Filter s that are invoked for a particular request. For example, you want to make sure that the filter you have added(#adding-custom-filter) is in the list of the security filters. The list of filters is printed at INFO level on the application startup, so you can see something like the following on the console output for example: 2023-06-14T08:55:22.321-03:00 INFO 76975 --- [ main] o.s.s.web.DefaultSecurityFilterChain : Will secure any request with [ org.springframework.security.web.session.DisableEncodeUrlFilter@404db674, org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@50f097b5, org.springframework.security.web.context.SecurityContextHolderFilter@6fc6deb7, org.springframework.security.web.header.HeaderWriterFilter@6f76c2cc, org.springframework.security.web.csrf.CsrfFilter@c29fe36, org.springframework.security.web.authentication.logout.LogoutFilter@ef60710, org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@7c2dfa2, org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter@4397a639, org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@7add838c, org.springframework.security.web.authentication.www.BasicAuthenticationFilter@5cc9d3d0, org.springframework.security.web.savedrequest.RequestCacheAwareFilter@7da39774, org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@32b0876c, org.springframework.security.web.authentication.AnonymousAuthenticationFilter@3662bdff, org.springframework.security.web.access.ExceptionTranslationFilter@77681ce4, org.springframework.security.web.access.intercept.AuthorizationFilter@169268a7] And that will give a pretty good idea of the security filters that are configured for each filter chain(#servlet-securityfilterchain) . But that is not all, you can also configure your application to print the invocation of each individual filter for each request. That is helpful to see if the filter you have added is invoked for a particular request or to check where an exception is coming from. To do that, you can configure your application to log the security events(#servlet-logging) . Adding a Custom Filter to the Filter Chain: Most of the time, the default security filters are enough to provide security to your application. However, there might be times that you want to add a custom Filter to the security filter chain. For example, let’s say that you want to add a Filter that gets a tenant id header and check if the current user has access to that tenant. The previous description already gives us a clue on where to add the filter, since we need to know the current user, we need to add it after the authentication filters. First, let’s create the Filter : import java.io.IOException; import jakarta.servlet.Filter; import jakarta.servlet.FilterChain; import jakarta.servlet.ServletException; import jakarta.servlet.ServletRequest; import jakarta.servlet.ServletResponse; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.springframework.security.access.AccessDeniedException; public class TenantFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; String tenantId = request.getHeader(""X-Tenant-Id""); (1) boolean hasAccess = isUserAllowed(tenantId); (2) if (hasAccess) { filterChain.doFilter(request, response); (3) return; } throw new AccessDeniedException(""Access denied""); (4) } } The sample code above does the following: 1 Get the tenant id from the request header. 2 Check if the current user has access to the tenant id. 3 If the user has access, then invoke the rest of the filters in the chain. 4 If the user does not have access, then throw an AccessDeniedException . Instead of implementing Filter , you can extend from OncePerRequestFilter(https://docs.spring.io/spring-framework/docs/6.1.12/javadoc-api/org/springframework/web/filter/OncePerRequestFilter.html) which is a base class for filters that are only invoked once per request and provides a doFilterInternal method with the HttpServletRequest and HttpServletResponse parameters. Now, we need to add the filter to the security filter chain. Java Kotlin @Bean SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .addFilterBefore(new TenantFilter(), AuthorizationFilter.class); (1) return http.build(); } @Bean fun filterChain(http: HttpSecurity): SecurityFilterChain { http // ... .addFilterBefore(TenantFilter(), AuthorizationFilter::class.java) (1) return http.build() } 1 Use HttpSecurity#addFilterBefore to add the TenantFilter before the AuthorizationFilter . By adding the filter before the AuthorizationFilter we are making sure that the TenantFilter is invoked after the authentication filters. You can also use HttpSecurity#addFilterAfter to add the filter after a particular filter or HttpSecurity#addFilterAt to add the filter at a particular filter position in the filter chain. And that’s it, now the TenantFilter will be invoked in the filter chain and will check if the current user has access to the tenant id. Be careful when you declare your filter as a Spring bean, either by annotating it with @Component or by declaring it as a bean in your configuration, because Spring Boot will automatically register it with the embedded container(https://docs.spring.io/spring-boot/docs/3.1.1/reference/html/web.html#web.servlet.embedded-container.servlets-filters-listeners.beans) . That may cause the filter to be invoked twice, once by the container and once by Spring Security and in a different order. If you still want to declare your filter as a Spring bean to take advantage of dependency injection for example, and avoid the duplicate invocation, you can tell Spring Boot to not register it with the container by declaring a FilterRegistrationBean bean and setting its enabled property to false : @Bean public FilterRegistrationBean<TenantFilter> tenantFilterRegistration(TenantFilter filter) { FilterRegistrationBean<TenantFilter> registration = new FilterRegistrationBean<>(filter); registration.setEnabled(false); return registration; } Handling Security Exceptions: The ExceptionTranslationFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/access/ExceptionTranslationFilter.html) allows translation of AccessDeniedException(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/access/AccessDeniedException.html) and AuthenticationException(https://docs.spring.io/spring-security/site/docs/6.3.3/api//org/springframework/security/core/AuthenticationException.html) into HTTP responses. ExceptionTranslationFilter is inserted into the FilterChainProxy(#servlet-filterchainproxy) as one of the Security Filters(#servlet-security-filters) . The following image shows the relationship of ExceptionTranslationFilter to other components: First, the ExceptionTranslationFilter invokes FilterChain.doFilter(request, response) to invoke the rest of the application. If the user is not authenticated or it is an AuthenticationException , then Start Authentication . The SecurityContextHolder(authentication/architecture.html#servlet-authentication-securitycontextholder) is cleared out. The HttpServletRequest is saved(#savedrequests) so that it can be used to replay the original request once authentication is successful. The AuthenticationEntryPoint is used to request credentials from the client. For example, it might redirect to a log in page or send a WWW-Authenticate header. Otherwise, if it is an AccessDeniedException , then Access Denied . The AccessDeniedHandler is invoked to handle access denied. If the application does not throw an AccessDeniedException or an AuthenticationException , then ExceptionTranslationFilter does not do anything. The pseudocode for ExceptionTranslationFilter looks something like this: ExceptionTranslationFilter pseudocode try { filterChain.doFilter(request, response); (1) } catch (AccessDeniedException | AuthenticationException ex) { if (!authenticated || ex instanceof AuthenticationException) { startAuthentication(); (2) } else { accessDenied(); (3) } } 1 As described in A Review of Filters(#servlet-filters-review) , invoking FilterChain.doFilter(request, response) is the equivalent of invoking the rest of the application. This means that if another part of the application, ( FilterSecurityInterceptor(#servlet-authorization-filtersecurityinterceptor) or method security) throws an AuthenticationException or AccessDeniedException it is caught and handled here. 2 If the user is not authenticated or it is an AuthenticationException , Start Authentication . 3 Otherwise, Access Denied Saving Requests Between Authentication: As illustrated in Handling Security Exceptions(#servlet-exceptiontranslationfilter) , when a request has no authentication and is for a resource that requires authentication, there is a need to save the request for the authenticated resource to re-request after authentication is successful. In Spring Security this is done by saving the HttpServletRequest using a RequestCache(#requestcache) implementation. RequestCache: The HttpServletRequest is saved in the RequestCache(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/savedrequest/RequestCache.html) . When the user successfully authenticates, the RequestCache is used to replay the original request. The RequestCacheAwareFilter(#requestcacheawarefilter) uses the RequestCache to get the saved HttpServletRequest after the user authenticates, while the ExceptionTranslationFilter uses the RequestCache to save the HttpServletRequest after it detects AuthenticationException , before redirecting the user to the login endpoint. By default, an HttpSessionRequestCache is used. The code below demonstrates how to customize the RequestCache implementation that is used to check the HttpSession for a saved request if the parameter named continue is present. RequestCache Only Checks for Saved Requests if continue Parameter Present Java Kotlin XML @Bean DefaultSecurityFilterChain springSecurity(HttpSecurity http) throws Exception { HttpSessionRequestCache requestCache = new HttpSessionRequestCache(); requestCache.setMatchingRequestParameterName(""continue""); http // ... .requestCache((cache) -> cache .requestCache(requestCache) ); return http.build(); } @Bean open fun springSecurity(http: HttpSecurity): SecurityFilterChain { val httpRequestCache = HttpSessionRequestCache() httpRequestCache.setMatchingRequestParameterName(""continue"") http { requestCache { requestCache = httpRequestCache } } return http.build() } <http auto-config=""true""> <!-- ... --> <request-cache ref=""requestCache""/> </http> <b:bean id=""requestCache"" class=""org.springframework.security.web.savedrequest.HttpSessionRequestCache"" p:matchingRequestParameterName=""continue""/> Prevent the Request From Being Saved: There are a number of reasons you may want to not store the user’s unauthenticated request in the session. You may want to offload that storage onto the user’s browser or store it in a database. Or you may want to shut off this feature since you always want to redirect the user to the home page instead of the page they tried to visit before login. To do that, you can use the NullRequestCache implementation(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/savedrequest/NullRequestCache.html) . Prevent the Request From Being Saved Java Kotlin XML @Bean SecurityFilterChain springSecurity(HttpSecurity http) throws Exception { RequestCache nullRequestCache = new NullRequestCache(); http // ... .requestCache((cache) -> cache .requestCache(nullRequestCache) ); return http.build(); } @Bean open fun springSecurity(http: HttpSecurity): SecurityFilterChain { val nullRequestCache = NullRequestCache() http { requestCache { requestCache = nullRequestCache } } return http.build() } <http auto-config=""true""> <!-- ... --> <request-cache ref=""nullRequestCache""/> </http> <b:bean id=""nullRequestCache"" class=""org.springframework.security.web.savedrequest.NullRequestCache""/> RequestCacheAwareFilter: The RequestCacheAwareFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/savedrequest/RequestCacheAwareFilter.html) uses the RequestCache(#requestcache) to replay the original request. Logging: Spring Security provides comprehensive logging of all security related events at the DEBUG and TRACE level. This can be very useful when debugging your application because for security measures Spring Security does not add any detail of why a request has been rejected to the response body. If you come across a 401 or 403 error, it is very likely that you will find a log message that will help you understand what is going on. Let’s consider an example where a user tries to make a POST request to a resource that has CSRF protection(exploits/csrf.html) enabled without the CSRF token. With no logs, the user will see a 403 error with no explanation of why the request was rejected. However, if you enable logging for Spring Security, you will see a log message like this: 2023-06-14T09:44:25.797-03:00 DEBUG 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy : Securing POST /hello 2023-06-14T09:44:25.797-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy : Invoking DisableEncodeUrlFilter (1/15) 2023-06-14T09:44:25.798-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy : Invoking WebAsyncManagerIntegrationFilter (2/15) 2023-06-14T09:44:25.800-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy : Invoking SecurityContextHolderFilter (3/15) 2023-06-14T09:44:25.801-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy : Invoking HeaderWriterFilter (4/15) 2023-06-14T09:44:25.802-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy : Invoking CsrfFilter (5/15) 2023-06-14T09:44:25.814-03:00 DEBUG 76975 --- [nio-8080-exec-1] o.s.security.web.csrf.CsrfFilter : Invalid CSRF token found for http://localhost:8080/hello 2023-06-14T09:44:25.814-03:00 DEBUG 76975 --- [nio-8080-exec-1] o.s.s.w.access.AccessDeniedHandlerImpl : Responding with 403 status code 2023-06-14T09:44:25.814-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.s.w.header.writers.HstsHeaderWriter : Not injecting HSTS header since it did not match request to [Is Secure] It becomes clear that the CSRF token is missing and that is why the request is being denied. To configure your application to log all the security events, you can add the following to your application: application.properties in Spring Boot logging.level.org.springframework.security=TRACE logback.xml <configuration> <appender name=""STDOUT"" class=""ch.qos.logback.core.ConsoleAppender""> <!-- ... --> </appender> <!-- ... --> <logger name=""org.springframework.security"" level=""trace"" additivity=""false""> <appender-ref ref=""Console"" /> </logger> </configuration>"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/index.html","Authentication: Spring Security provides comprehensive support for Authentication(../../features/authentication/index.html#authentication) . We start by discussing the overall Servlet Authentication Architecture(architecture.html) . As you might expect, this section is more abstract describing the architecture without much discussion on how it applies to concrete flows. If you prefer, you can refer to Authentication Mechanisms(#servlet-authentication-mechanisms) for concrete ways in which users can authenticate. These sections focus on specific ways you may want to authenticate and point back at the architecture sections to describe how the specific flows work. Authentication Mechanisms: Username and Password(passwords/index.html#servlet-authentication-unpwd) - how to authenticate with a username/password OAuth 2.0 Login(../oauth2/login/index.html#oauth2login) - OAuth 2.0 Log In with OpenID Connect and non-standard OAuth 2.0 Login (i.e. GitHub) SAML 2.0 Login(../saml2/index.html#servlet-saml2) - SAML 2.0 Log In Central Authentication Server (CAS)(cas.html#servlet-cas) - Central Authentication Server (CAS) Support Remember Me(rememberme.html#servlet-rememberme) - how to remember a user past session expiration JAAS Authentication(jaas.html#servlet-jaas) - authenticate with JAAS Pre-Authentication Scenarios(preauth.html#servlet-preauth) - authenticate with an external mechanism such as SiteMinder(https://www.siteminder.com/) or Java EE security but still use Spring Security for authorization and protection against common exploits. X509 Authentication(x509.html#servlet-x509) - X509 Authentication"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/architecture.html","Servlet Authentication Architecture: This discussion expands on Servlet Security: The Big Picture(../architecture.html#servlet-architecture) to describe the main architectural components of Spring Security’s used in Servlet authentication. If you need concrete flows that explain how these pieces fit together, look at the Authentication Mechanism(index.html#servlet-authentication-mechanisms) specific sections. SecurityContextHolder(#servlet-authentication-securitycontextholder) - The SecurityContextHolder is where Spring Security stores the details of who is authenticated(../../features/authentication/index.html#authentication) . SecurityContext(#servlet-authentication-securitycontext) - is obtained from the SecurityContextHolder and contains the Authentication of the currently authenticated user. Authentication(#servlet-authentication-authentication) - Can be the input to AuthenticationManager to provide the credentials a user has provided to authenticate or the current user from the SecurityContext . GrantedAuthority(#servlet-authentication-granted-authority) - An authority that is granted to the principal on the Authentication (i.e. roles, scopes, etc.) AuthenticationManager(#servlet-authentication-authenticationmanager) - the API that defines how Spring Security’s Filters perform authentication(../../features/authentication/index.html#authentication) . ProviderManager(#servlet-authentication-providermanager) - the most common implementation of AuthenticationManager . AuthenticationProvider(#servlet-authentication-authenticationprovider) - used by ProviderManager to perform a specific type of authentication. Request Credentials with AuthenticationEntryPoint(#servlet-authentication-authenticationentrypoint) - used for requesting credentials from a client (i.e. redirecting to a log in page, sending a WWW-Authenticate response, etc.) AbstractAuthenticationProcessingFilter(#servlet-authentication-abstractprocessingfilter) - a base Filter used for authentication. This also gives a good idea of the high level flow of authentication and how pieces work together. SecurityContextHolder: At the heart of Spring Security’s authentication model is the SecurityContextHolder . It contains the SecurityContext(#servlet-authentication-securitycontext) . The SecurityContextHolder is where Spring Security stores the details of who is authenticated(../../features/authentication/index.html#authentication) . Spring Security does not care how the SecurityContextHolder is populated. If it contains a value, it is used as the currently authenticated user. The simplest way to indicate a user is authenticated is to set the SecurityContextHolder directly: Setting SecurityContextHolder Java Kotlin SecurityContext context = SecurityContextHolder.createEmptyContext(); (1) Authentication authentication = new TestingAuthenticationToken(""username"", ""password"", ""ROLE_USER""); (2) context.setAuthentication(authentication); SecurityContextHolder.setContext(context); (3) val context: SecurityContext = SecurityContextHolder.createEmptyContext() (1) val authentication: Authentication = TestingAuthenticationToken(""username"", ""password"", ""ROLE_USER"") (2) context.authentication = authentication SecurityContextHolder.setContext(context) (3) 1 We start by creating an empty SecurityContext . You should create a new SecurityContext instance instead of using SecurityContextHolder.getContext().setAuthentication(authentication) to avoid race conditions across multiple threads. 2 Next, we create a new Authentication(#servlet-authentication-authentication) object. Spring Security does not care what type of Authentication implementation is set on the SecurityContext . Here, we use TestingAuthenticationToken , because it is very simple. A more common production scenario is UsernamePasswordAuthenticationToken(userDetails, password, authorities) . 3 Finally, we set the SecurityContext on the SecurityContextHolder . Spring Security uses this information for authorization(../authorization/index.html#servlet-authorization) . To obtain information about the authenticated principal, access the SecurityContextHolder . Access Currently Authenticated User Java Kotlin SecurityContext context = SecurityContextHolder.getContext(); Authentication authentication = context.getAuthentication(); String username = authentication.getName(); Object principal = authentication.getPrincipal(); Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities(); val context = SecurityContextHolder.getContext() val authentication = context.authentication val username = authentication.name val principal = authentication.principal val authorities = authentication.authorities By default, SecurityContextHolder uses a ThreadLocal to store these details, which means that the SecurityContext is always available to methods in the same thread, even if the SecurityContext is not explicitly passed around as an argument to those methods. Using a ThreadLocal in this way is quite safe if you take care to clear the thread after the present principal’s request is processed. Spring Security’s FilterChainProxy(../architecture.html#servlet-filterchainproxy) ensures that the SecurityContext is always cleared. Some applications are not entirely suitable for using a ThreadLocal , because of the specific way they work with threads. For example, a Swing client might want all threads in a Java Virtual Machine to use the same security context. You can configure SecurityContextHolder with a strategy on startup to specify how you would like the context to be stored. For a standalone application, you would use the SecurityContextHolder.MODE_GLOBAL strategy. Other applications might want to have threads spawned by the secure thread also assume the same security identity. You can achieve this by using SecurityContextHolder.MODE_INHERITABLETHREADLOCAL . You can change the mode from the default SecurityContextHolder.MODE_THREADLOCAL in two ways. The first is to set a system property. The second is to call a static method on SecurityContextHolder . Most applications need not change from the default. However, if you do, take a look at the JavaDoc for SecurityContextHolder to learn more. SecurityContext: The SecurityContext(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/core/context/SecurityContext.html) is obtained from the SecurityContextHolder(#servlet-authentication-securitycontextholder) . The SecurityContext contains an Authentication(#servlet-authentication-authentication) object. Authentication: The Authentication(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/core/Authentication.html) interface serves two main purposes within Spring Security: An input to AuthenticationManager(#servlet-authentication-authenticationmanager) to provide the credentials a user has provided to authenticate. When used in this scenario, isAuthenticated() returns false . Represent the currently authenticated user. You can obtain the current Authentication from the SecurityContext(#servlet-authentication-securitycontext) . The Authentication contains: principal : Identifies the user. When authenticating with a username/password this is often an instance of UserDetails(passwords/user-details.html#servlet-authentication-userdetails) . credentials : Often a password. In many cases, this is cleared after the user is authenticated, to ensure that it is not leaked. authorities : The GrantedAuthority(#servlet-authentication-granted-authority) instances are high-level permissions the user is granted. Two examples are roles and scopes. GrantedAuthority: GrantedAuthority(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/core/GrantedAuthority.html) instances are high-level permissions that the user is granted. Two examples are roles and scopes. You can obtain GrantedAuthority instances from the Authentication.getAuthorities()(#servlet-authentication-authentication) method. This method provides a Collection of GrantedAuthority objects. A GrantedAuthority is, not surprisingly, an authority that is granted to the principal. Such authorities are usually “roles”, such as ROLE_ADMINISTRATOR or ROLE_HR_SUPERVISOR . These roles are later configured for web authorization, method authorization, and domain object authorization. Other parts of Spring Security interpret these authorities and expect them to be present. When using username/password based authentication GrantedAuthority instances are usually loaded by the UserDetailsService(passwords/user-details-service.html#servlet-authentication-userdetailsservice) . Usually, the GrantedAuthority objects are application-wide permissions. They are not specific to a given domain object. Thus, you would not likely have a GrantedAuthority to represent a permission to Employee object number 54, because if there are thousands of such authorities you would quickly run out of memory (or, at the very least, cause the application to take a long time to authenticate a user). Of course, Spring Security is expressly designed to handle this common requirement, but you should instead use the project’s domain object security capabilities for this purpose. AuthenticationManager: AuthenticationManager(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authentication/AuthenticationManager.html) is the API that defines how Spring Security’s Filters perform authentication(../../features/authentication/index.html#authentication) . The Authentication(#servlet-authentication-authentication) that is returned is then set on the SecurityContextHolder(#servlet-authentication-securitycontextholder) by the controller (that is, by Spring Security’s Filters instances(../architecture.html#servlet-security-filters) ) that invoked the AuthenticationManager . If you are not integrating with Spring Security’s Filters instances, you can set the SecurityContextHolder directly and are not required to use an AuthenticationManager . While the implementation of AuthenticationManager could be anything, the most common implementation is ProviderManager(#servlet-authentication-providermanager) . ProviderManager: ProviderManager(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authentication/ProviderManager.html) is the most commonly used implementation of AuthenticationManager(#servlet-authentication-authenticationmanager) . ProviderManager delegates to a List of AuthenticationProvider(#servlet-authentication-authenticationprovider) instances. Each AuthenticationProvider has an opportunity to indicate that authentication should be successful, fail, or indicate it cannot make a decision and allow a downstream AuthenticationProvider to decide. If none of the configured AuthenticationProvider instances can authenticate, authentication fails with a ProviderNotFoundException , which is a special AuthenticationException that indicates that the ProviderManager was not configured to support the type of Authentication that was passed into it. In practice each AuthenticationProvider knows how to perform a specific type of authentication. For example, one AuthenticationProvider might be able to validate a username/password, while another might be able to authenticate a SAML assertion. This lets each AuthenticationProvider do a very specific type of authentication while supporting multiple types of authentication and expose only a single AuthenticationManager bean. ProviderManager also allows configuring an optional parent AuthenticationManager , which is consulted in the event that no AuthenticationProvider can perform authentication. The parent can be any type of AuthenticationManager , but it is often an instance of ProviderManager . In fact, multiple ProviderManager instances might share the same parent AuthenticationManager . This is somewhat common in scenarios where there are multiple SecurityFilterChain(../architecture.html#servlet-securityfilterchain) instances that have some authentication in common (the shared parent AuthenticationManager ), but also different authentication mechanisms (the different ProviderManager instances). By default, ProviderManager tries to clear any sensitive credentials information from the Authentication object that is returned by a successful authentication request. This prevents information, such as passwords, being retained longer than necessary in the HttpSession . This may cause issues when you use a cache of user objects, for example, to improve performance in a stateless application. If the Authentication contains a reference to an object in the cache (such as a UserDetails instance) and this has its credentials removed, it is no longer possible to authenticate against the cached value. You need to take this into account if you use a cache. An obvious solution is to first make a copy of the object, either in the cache implementation or in the AuthenticationProvider that creates the returned Authentication object. Alternatively, you can disable the eraseCredentialsAfterAuthentication property on ProviderManager . See the Javadoc for the ProviderManager(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authentication/ProviderManager.html) class. AuthenticationProvider: You can inject multiple AuthenticationProviders(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authentication/AuthenticationProvider.html) instances into ProviderManager(#servlet-authentication-providermanager) . Each AuthenticationProvider performs a specific type of authentication. For example, DaoAuthenticationProvider(passwords/dao-authentication-provider.html#servlet-authentication-daoauthenticationprovider) supports username/password-based authentication, while JwtAuthenticationProvider supports authenticating a JWT token. Request Credentials with AuthenticationEntryPoint: AuthenticationEntryPoint(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/AuthenticationEntryPoint.html) is used to send an HTTP response that requests credentials from a client. Sometimes, a client proactively includes credentials (such as a username and password) to request a resource. In these cases, Spring Security does not need to provide an HTTP response that requests credentials from the client, since they are already included. In other cases, a client makes an unauthenticated request to a resource that they are not authorized to access. In this case, an implementation of AuthenticationEntryPoint is used to request credentials from the client. The AuthenticationEntryPoint implementation might perform a redirect to a log in page(passwords/form.html#servlet-authentication-form) , respond with an WWW-Authenticate(passwords/basic.html#servlet-authentication-basic) header, or take other action. AbstractAuthenticationProcessingFilter: AbstractAuthenticationProcessingFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/AbstractAuthenticationProcessingFilter.html) is used as a base Filter for authenticating a user’s credentials. Before the credentials can be authenticated, Spring Security typically requests the credentials by using AuthenticationEntryPoint(#servlet-authentication-authenticationentrypoint) . Next, the AbstractAuthenticationProcessingFilter can authenticate any authentication requests that are submitted to it. When the user submits their credentials, the AbstractAuthenticationProcessingFilter creates an Authentication(#servlet-authentication-authentication) from the HttpServletRequest to be authenticated. The type of Authentication created depends on the subclass of AbstractAuthenticationProcessingFilter . For example, UsernamePasswordAuthenticationFilter(passwords/form.html#servlet-authentication-usernamepasswordauthenticationfilter) creates a UsernamePasswordAuthenticationToken from a username and password that are submitted in the HttpServletRequest . Next, the Authentication(#servlet-authentication-authentication) is passed into the AuthenticationManager(#servlet-authentication-authenticationmanager) to be authenticated. If authentication fails, then Failure . The SecurityContextHolder(#servlet-authentication-securitycontextholder) is cleared out. RememberMeServices.loginFail is invoked. If remember me is not configured, this is a no-op. See the rememberme(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/rememberme/package-frame.html) package. AuthenticationFailureHandler is invoked. See the AuthenticationFailureHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/AuthenticationFailureHandler.html) interface. If authentication is successful, then Success . SessionAuthenticationStrategy is notified of a new login. See the SessionAuthenticationStrategy(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/session/SessionAuthenticationStrategy.html) interface. The Authentication(#servlet-authentication-authentication) is set on the SecurityContextHolder(#servlet-authentication-securitycontextholder) . Later, if you need to save the SecurityContext so that it can be automatically set on future requests, SecurityContextRepository#saveContext must be explicitly invoked. See the SecurityContextHolderFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/context/SecurityContextHolderFilter.html) class. RememberMeServices.loginSuccess is invoked. If remember me is not configured, this is a no-op. See the rememberme(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/rememberme/package-frame.html) package. ApplicationEventPublisher publishes an InteractiveAuthenticationSuccessEvent . AuthenticationSuccessHandler is invoked. See the AuthenticationSuccessHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/AuthenticationSuccessHandler.html) interface."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/index.html","Username/Password Authentication: One of the most common ways to authenticate a user is by validating a username and password. Spring Security provides comprehensive support for authenticating with a username and password. You can configure username and password authentication using the following: Simple Username/Password Example Java XML Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) .httpBasic(Customizer.withDefaults()) .formLogin(Customizer.withDefaults()); return http.build(); } @Bean public UserDetailsService userDetailsService() { UserDetails userDetails = User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .roles(""USER"") .build(); return new InMemoryUserDetailsManager(userDetails); } } <http> <intercept-url pattern=""/**"" access=""authenticated""/> <form-login /> <http-basic /> <user-service> <user name=""user"" password=""{noop}password"" authorities=""ROLE_USER"" /> </user-service> </http> import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(anyRequest, authenticated) } formLogin { } httpBasic { } } return http.build() } @Bean fun userDetailsService(): UserDetailsService { val user = User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .roles(""USER"") .build() return InMemoryUserDetailsManager(user) } } The preceding configuration automatically registers an in-memory UserDetailsService(in-memory.html) with the SecurityFilterChain , registers the DaoAuthenticationProvider(dao-authentication-provider.html) with the default AuthenticationManager(../architecture.html#servlet-authentication-authenticationmanager) , and enables Form Login(form.html) and HTTP Basic(basic.html) authentication. To learn more about username/password authentication, consider the following use cases: I want to learn how Form Login works(form.html) I want to learn how HTTP Basic authentication works(basic.html) I want to learn how DaoAuthenticationProvider works(dao-authentication-provider.html) I want to manage users in memory(in-memory.html) I want to manage users in a database(jdbc.html) I want to manage users in LDAP(ldap.html#servlet-authentication-ldap-authentication) I want to publish an AuthenticationManager bean(#publish-authentication-manager-bean) for custom authentication I want to customize the global AuthenticationManager(#customize-global-authentication-manager) Publish an AuthenticationManager bean: A fairly common requirement is publishing an AuthenticationManager bean to allow for custom authentication, such as in a @Service or Spring MVC @Controller . For example, you may want to authenticate users via a REST API instead of using Form Login(form.html) . You can publish such an AuthenticationManager for custom authentication scenarios using the following configuration: Publish AuthenticationManager bean for Custom Authentication Java XML Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(""/login"").permitAll() .anyRequest().authenticated() ); return http.build(); } @Bean public AuthenticationManager authenticationManager( UserDetailsService userDetailsService, PasswordEncoder passwordEncoder) { DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider(); authenticationProvider.setUserDetailsService(userDetailsService); authenticationProvider.setPasswordEncoder(passwordEncoder); return new ProviderManager(authenticationProvider); } @Bean public UserDetailsService userDetailsService() { UserDetails userDetails = User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .roles(""USER"") .build(); return new InMemoryUserDetailsManager(userDetails); } @Bean public PasswordEncoder passwordEncoder() { return PasswordEncoderFactories.createDelegatingPasswordEncoder(); } } <http> <intercept-url pattern=""/login"" access=""permitAll""/> <intercept-url pattern=""/**"" access=""authenticated""/> <bean id=""authenticationManager"" class=""org.springframework.security.authentication.ProviderManager""> <constructor-arg> <bean class=""org.springframework.security.authentication.dao.DaoAuthenticationProvider""> <property name=""userDetailsService"" ref=""userDetailsService"" /> <property name=""passwordEncoder"" ref=""passwordEncoder"" /> </bean> </constructor-arg> </bean> <user-service id=""userDetailsService""> <user name=""user"" password=""{noop}password"" authorities=""ROLE_USER"" /> </user-service> <bean id=""passwordEncoder"" class=""org.springframework.security.crypto.factory.PasswordEncoderFactories"" factory-method=""createDelegatingPasswordEncoder""/> </http> import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(""/login"", permitAll) authorize(anyRequest, authenticated) } } return http.build() } @Bean fun authenticationManager( userDetailsService: UserDetailsService, passwordEncoder: PasswordEncoder): AuthenticationManager { val authenticationProvider = DaoAuthenticationProvider() authenticationProvider.setUserDetailsService(userDetailsService) authenticationProvider.setPasswordEncoder(passwordEncoder) return ProviderManager(authenticationProvider) } @Bean fun userDetailsService(): UserDetailsService { val user = User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .roles(""USER"") .build() return InMemoryUserDetailsManager(user) } @Bean fun passwordEncoder(): PasswordEncoder { return PasswordEncoderFactories.createDelegatingPasswordEncoder() } } With the preceding configuration in place, you can create a @RestController that uses the AuthenticationManager as follows: Create a @RestController for Authentication Java Kotlin @RestController public class LoginController { private final AuthenticationManager authenticationManager; public LoginController(AuthenticationManager authenticationManager) { this.authenticationManager = authenticationManager; } @PostMapping(""/login"") public ResponseEntity<Void> login(@RequestBody LoginRequest loginRequest) { Authentication authenticationRequest = UsernamePasswordAuthenticationToken.unauthenticated(loginRequest.username(), loginRequest.password()); Authentication authenticationResponse = this.authenticationManager.authenticate(authenticationRequest); // ... } public record LoginRequest(String username, String password) { } } @RestController class LoginController(val authenticationManager: AuthenticationManager) { @PostMapping(""/login"") fun login(@RequestBody loginRequest: LoginRequest): ResponseEntity<Void> { val authenticationRequest = UsernamePasswordAuthenticationToken.unauthenticated( loginRequest.username, loginRequest.password) val authenticationResponse = authenticationManager.authenticate(authenticationRequest) // ... } data class LoginRequest(val username: String, val password: String) } In this example, it is your responsibility to save the authenticated user in the SecurityContextRepository if needed. For example, if using the HttpSession to persist the SecurityContext between requests, you can use HttpSessionSecurityContextRepository(../persistence.html#httpsecuritycontextrepository) . Customize the AuthenticationManager: Normally, Spring Security builds an AuthenticationManager internally composed of a DaoAuthenticationProvider for username/password authentication. In certain cases, it may still be desired to customize the instance of AuthenticationManager used by Spring Security. For example, you may need to simply disable credential erasure(../architecture.html#servlet-authentication-providermanager-erasing-credentials) for cached users. The recommended way to do this is to simply publish your own AuthenticationManager bean, and Spring Security will use it. You can publish an AuthenticationManager using the following configuration: Publish AuthenticationManager bean for Spring Security Java XML Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(""/login"").permitAll() .anyRequest().authenticated() ) .httpBasic(Customizer.withDefaults()) .formLogin(Customizer.withDefaults()); return http.build(); } @Bean public AuthenticationManager authenticationManager( UserDetailsService userDetailsService, PasswordEncoder passwordEncoder) { DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider(); authenticationProvider.setUserDetailsService(userDetailsService); authenticationProvider.setPasswordEncoder(passwordEncoder); ProviderManager providerManager = new ProviderManager(authenticationProvider); providerManager.setEraseCredentialsAfterAuthentication(false); return providerManager; } @Bean public UserDetailsService userDetailsService() { UserDetails userDetails = User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .roles(""USER"") .build(); return new InMemoryUserDetailsManager(userDetails); } @Bean public PasswordEncoder passwordEncoder() { return PasswordEncoderFactories.createDelegatingPasswordEncoder(); } } <http> <intercept-url pattern=""/login"" access=""permitAll""/> <intercept-url pattern=""/**"" access=""authenticated""/> <form-login /> <http-basic /> <bean id=""authenticationManager"" class=""org.springframework.security.authentication.ProviderManager""> <constructor-arg> <bean class=""org.springframework.security.authentication.dao.DaoAuthenticationProvider""> <property name=""userDetailsService"" ref=""userDetailsService"" /> <property name=""passwordEncoder"" ref=""passwordEncoder"" /> </bean> </constructor-arg> </bean> <user-service id=""userDetailsService""> <user name=""user"" password=""{noop}password"" authorities=""ROLE_USER"" /> </user-service> <bean id=""passwordEncoder"" class=""org.springframework.security.crypto.factory.PasswordEncoderFactories"" factory-method=""createDelegatingPasswordEncoder""/> </http> import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(""/login"", permitAll) authorize(anyRequest, authenticated) } formLogin { } httpBasic { } } return http.build() } @Bean fun authenticationManager( userDetailsService: UserDetailsService, passwordEncoder: PasswordEncoder): AuthenticationManager { val authenticationProvider = DaoAuthenticationProvider() authenticationProvider.setUserDetailsService(userDetailsService) authenticationProvider.setPasswordEncoder(passwordEncoder) val providerManager = ProviderManager(authenticationProvider) providerManager.eraseCredentialsAfterAuthentication = false return providerManager } @Bean fun userDetailsService(): UserDetailsService { val user = User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .roles(""USER"") .build() return InMemoryUserDetailsManager(user) } @Bean fun passwordEncoder(): PasswordEncoder { return PasswordEncoderFactories.createDelegatingPasswordEncoder() } } Alternatively, you can take advantage of the fact that the AuthenticationManagerBuilder used to build Spring Security’s global AuthenticationManager is published as a bean. You can configure the builder as follows: Configure global AuthenticationManagerBuilder Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { // ... return http.build(); } @Bean public UserDetailsService userDetailsService() { // Return a UserDetailsService that caches users // ... } @Autowired public void configure(AuthenticationManagerBuilder builder) { builder.eraseCredentials(false); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { // ... return http.build() } @Bean fun userDetailsService(): UserDetailsService { // Return a UserDetailsService that caches users // ... } @Autowired fun configure(builder: AuthenticationManagerBuilder) { builder.eraseCredentials(false) } } Section Summary: Reading Username/Password(input.html) Password Storage(storage.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/input.html","Reading the Username & Password: Spring Security provides the following built-in mechanisms for reading a username and password from HttpServletRequest : Section Summary: Form(form.html) Basic(basic.html) Digest(digest.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/form.html","Form Login: Spring Security provides support for username and password being provided through an HTML form. This section provides details on how form based authentication works within Spring Security. This section examines how form-based login works within Spring Security. First, we see how the user is redirected to the login form: Figure 1. Redirecting to the Login Page The preceding figure builds off our SecurityFilterChain(../../architecture.html#servlet-securityfilterchain) diagram. First, a user makes an unauthenticated request to the resource ( /private ) for which it is not authorized. Spring Security’s AuthorizationFilter(../../authorization/authorize-http-requests.html) indicates that the unauthenticated request is Denied by throwing an AccessDeniedException . Since the user is not authenticated, ExceptionTranslationFilter(../../architecture.html#servlet-exceptiontranslationfilter) initiates Start Authentication and sends a redirect to the login page with the configured AuthenticationEntryPoint(../architecture.html#servlet-authentication-authenticationentrypoint) . In most cases, the AuthenticationEntryPoint is an instance of LoginUrlAuthenticationEntryPoint(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/LoginUrlAuthenticationEntryPoint.html) . The browser requests the login page to which it was redirected. Something within the application, must render the login page(#servlet-authentication-form-custom) . When the username and password are submitted, the UsernamePasswordAuthenticationFilter authenticates the username and password. The UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter(../architecture.html#servlet-authentication-abstractprocessingfilter) , so the following diagram should look pretty similar: Figure 2. Authenticating Username and Password The figure builds off our SecurityFilterChain(../../architecture.html#servlet-securityfilterchain) diagram. When the user submits their username and password, the UsernamePasswordAuthenticationFilter creates a UsernamePasswordAuthenticationToken , which is a type of Authentication(../architecture.html#servlet-authentication-authentication) , by extracting the username and password from the HttpServletRequest instance. Next, the UsernamePasswordAuthenticationToken is passed into the AuthenticationManager instance to be authenticated. The details of what AuthenticationManager looks like depend on how the user information is stored(index.html#servlet-authentication-unpwd-storage) . If authentication fails, then Failure . The SecurityContextHolder(../architecture.html#servlet-authentication-securitycontextholder) is cleared out. RememberMeServices.loginFail is invoked. If remember me is not configured, this is a no-op. See the RememberMeServices(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/RememberMeServices.html) interface in the Javadoc. AuthenticationFailureHandler is invoked. See the AuthenticationFailureHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/AuthenticationFailureHandler.html) class in the Javadoc If authentication is successful, then Success . SessionAuthenticationStrategy is notified of a new login. See the SessionAuthenticationStrategy(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/session/SessionAuthenticationStrategy.html) interface in the Javadoc. The Authentication(../architecture.html#servlet-authentication-authentication) is set on the SecurityContextHolder(../architecture.html#servlet-authentication-securitycontextholder) . See the SecurityContextPersistenceFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/context/SecurityContextPersistenceFilter.html) class in the Javadoc. RememberMeServices.loginSuccess is invoked. If remember me is not configured, this is a no-op. See the RememberMeServices(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/RememberMeServices.html) interface in the Javadoc. ApplicationEventPublisher publishes an InteractiveAuthenticationSuccessEvent . The AuthenticationSuccessHandler is invoked. Typically, this is a SimpleUrlAuthenticationSuccessHandler , which redirects to a request saved by ExceptionTranslationFilter(../../architecture.html#servlet-exceptiontranslationfilter) when we redirect to the login page. By default, Spring Security form login is enabled. However, as soon as any servlet-based configuration is provided, form based login must be explicitly provided. The following example shows a minimal, explicit Java configuration: Form Login Java XML Kotlin public SecurityFilterChain filterChain(HttpSecurity http) { http .formLogin(withDefaults()); // ... } <http> <!-- ... --> <form-login /> </http> open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { formLogin { } } // ... } In the preceding configuration, Spring Security renders a default login page. Most production applications require a custom login form. The following configuration demonstrates how to provide a custom login form. Custom Login Form Configuration Java XML Kotlin public SecurityFilterChain filterChain(HttpSecurity http) { http .formLogin(form -> form .loginPage(""/login"") .permitAll() ); // ... } <http> <!-- ... --> <intercept-url pattern=""/login"" access=""permitAll"" /> <form-login login-page=""/login"" /> </http> open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { formLogin { loginPage = ""/login"" permitAll() } } // ... } When the login page is specified in the Spring Security configuration, you are responsible for rendering the page. The following Thymeleaf(https://www.thymeleaf.org/) template produces an HTML login form that complies with a login page of /login .: Login Form - src/main/resources/templates/login.html <!DOCTYPE html> <html xmlns=""http://www.w3.org/1999/xhtml"" xmlns:th=""https://www.thymeleaf.org""> <head> <title>Please Log In</title> </head> <body> <h1>Please Log In</h1> <div th:if=""${param.error}""> Invalid username and password.</div> <div th:if=""${param.logout}""> You have been logged out.</div> <form th:action=""@{/login}"" method=""post""> <div> <input type=""text"" name=""username"" placeholder=""Username""/> </div> <div> <input type=""password"" name=""password"" placeholder=""Password""/> </div> <input type=""submit"" value=""Log in"" /> </form> </body> </html> There are a few key points about the default HTML form: The form should perform a post to /login . The form needs to include a CSRF Token(../../exploits/csrf.html#servlet-csrf) , which is automatically included(../../exploits/csrf.html#csrf-integration-form) by Thymeleaf. The form should specify the username in a parameter named username . The form should specify the password in a parameter named password . If the HTTP parameter named error is found, it indicates the user failed to provide a valid username or password. If the HTTP parameter named logout is found, it indicates the user has logged out successfully. Many users do not need much more than to customize the login page. However, if needed, you can customize everything shown earlier with additional configuration. If you use Spring MVC, you need a controller that maps GET /login to the login template we created. The following example shows a minimal LoginController : LoginController Java Kotlin @Controller class LoginController { @GetMapping(""/login"") String login() { return ""login""; } } @Controller class LoginController { @GetMapping(""/login"") fun login(): String { return ""login"" } }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/basic.html","Basic Authentication: This section provides details on how Spring Security provides support for Basic HTTP Authentication(https://tools.ietf.org/html/rfc7617) for servlet-based applications. This section describes how HTTP Basic Authentication works within Spring Security. First, we see the WWW-Authenticate(https://tools.ietf.org/html/rfc7235#section-4.1) header is sent back to an unauthenticated client: Figure 1. Sending WWW-Authenticate Header The preceding figure builds off our SecurityFilterChain(../../architecture.html#servlet-securityfilterchain) diagram. First, a user makes an unauthenticated request to the resource /private for which it is not authorized. Spring Security’s AuthorizationFilter(../../authorization/authorize-http-requests.html) indicates that the unauthenticated request is Denied by throwing an AccessDeniedException . Since the user is not authenticated, ExceptionTranslationFilter(../../architecture.html#servlet-exceptiontranslationfilter) initiates Start Authentication . The configured AuthenticationEntryPoint(../architecture.html#servlet-authentication-authenticationentrypoint) is an instance of BasicAuthenticationEntryPoint(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/www/BasicAuthenticationEntryPoint.html) , which sends a WWW-Authenticate header. The RequestCache is typically a NullRequestCache that does not save the request since the client is capable of replaying the requests it originally requested. When a client receives the WWW-Authenticate header, it knows it should retry with a username and password. The following image shows the flow for the username and password being processed: Figure 2. Authenticating Username and Password The preceding figure builds off our SecurityFilterChain(../../architecture.html#servlet-securityfilterchain) diagram. When the user submits their username and password, the BasicAuthenticationFilter creates a UsernamePasswordAuthenticationToken , which is a type of Authentication(../architecture.html#servlet-authentication-authentication) by extracting the username and password from the HttpServletRequest . Next, the UsernamePasswordAuthenticationToken is passed into the AuthenticationManager to be authenticated. The details of what AuthenticationManager looks like depend on how the user information is stored(index.html#servlet-authentication-unpwd-storage) . If authentication fails, then Failure . The SecurityContextHolder(../architecture.html#servlet-authentication-securitycontextholder) is cleared out. RememberMeServices.loginFail is invoked. If remember me is not configured, this is a no-op. See the RememberMeServices(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/RememberMeServices.html) interface in the Javadoc. AuthenticationEntryPoint is invoked to trigger the WWW-Authenticate to be sent again. See the AuthenticationEntryPoint(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/AuthenticationEntryPoint.html) interface in the Javadoc. If authentication is successful, then Success . The Authentication(../architecture.html#servlet-authentication-authentication) is set on the SecurityContextHolder(../architecture.html#servlet-authentication-securitycontextholder) . RememberMeServices.loginSuccess is invoked. If remember me is not configured, this is a no-op. See the RememberMeServices(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/RememberMeServices.html) interface in the Javadoc. The BasicAuthenticationFilter invokes FilterChain.doFilter(request,response) to continue with the rest of the application logic. See the BasicAuthenticationFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/www/BasicAuthenticationFilter.html) Class in the Javadoc By default, Spring Security’s HTTP Basic Authentication support is enabled. However, as soon as any servlet based configuration is provided, HTTP Basic must be explicitly provided. The following example shows a minimal, explicit configuration: Explicit HTTP Basic Configuration Java XML Kotlin @Bean public SecurityFilterChain filterChain(HttpSecurity http) { http // ... .httpBasic(withDefaults()); return http.build(); } <http> <!-- ... --> <http-basic /> </http> @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... httpBasic { } } return http.build() }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/digest.html","Digest Authentication: This section provides details on how Spring Security provides support for Digest Authentication(https://tools.ietf.org/html/rfc2617) , which is provided DigestAuthenticationFilter . You should not use Digest Authentication in modern applications, because it is not considered to be secure. The most obvious problem is that you must store your passwords in plaintext or an encrypted or MD5 format. All of these storage formats are considered insecure. Instead, you should store credentials by using a one way adaptive password hash (bCrypt, PBKDF2, SCrypt, and others), which is not supported by Digest Authentication. Digest Authentication tries to solve many of the weaknesses of Basic authentication(basic.html#servlet-authentication-basic) , specifically by ensuring credentials are never sent in clear text across the wire. Many browsers support Digest Authentication(https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Digest#Browser_compatibility) . The standard governing HTTP Digest Authentication is defined by RFC 2617(https://tools.ietf.org/html/rfc2617) , which updates an earlier version of the Digest Authentication standard prescribed by RFC 2069(https://tools.ietf.org/html/rfc2069) . Most user agents implement RFC 2617. Spring Security’s Digest Authentication support is compatible with the “auth” quality of protection ( qop ) prescribed by RFC 2617, which also provides backward compatibility with RFC 2069. Digest Authentication was seen as a more attractive option if you need to use unencrypted HTTP (no TLS or HTTPS) and wish to maximize security of the authentication process. However, everyone should use HTTPS(../../../features/exploits/http.html#http) . Central to Digest Authentication is a “nonce”. This is a value the server generates. Spring Security’s nonce adopts the following format: Digest Syntax base64(expirationTime + "":"" + md5Hex(expirationTime + "":"" + key)) expirationTime: The date and time when the nonce expires, expressed in milliseconds key: A private key to prevent modification of the nonce token You need to ensure that you configure(../../../features/authentication/password-storage.html#authentication-password-storage-configuration) insecure plain text Password Storage(../../../features/authentication/password-storage.html#authentication-password-storage) using NoOpPasswordEncoder . (See the NoOpPasswordEncoder(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/crypto/password/NoOpPasswordEncoder.html) class in the Javadoc.) The following provides an example of configuring Digest Authentication with Java Configuration: Digest Authentication Java XML @Autowired UserDetailsService userDetailsService; DigestAuthenticationEntryPoint authenticationEntryPoint() { DigestAuthenticationEntryPoint result = new DigestAuthenticationEntryPoint(); result.setRealmName(""My App Realm""); result.setKey(""3028472b-da34-4501-bfd8-a355c42bdf92""); return result; } DigestAuthenticationFilter digestAuthenticationFilter() { DigestAuthenticationFilter result = new DigestAuthenticationFilter(); result.setUserDetailsService(userDetailsService); result.setAuthenticationEntryPoint(authenticationEntryPoint()); return result; } @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .exceptionHandling(e -> e.authenticationEntryPoint(authenticationEntryPoint())) .addFilter(digestAuthenticationFilter()); return http.build(); } <b:bean id=""digestFilter"" class=""org.springframework.security.web.authentication.www.DigestAuthenticationFilter"" p:userDetailsService-ref=""jdbcDaoImpl"" p:authenticationEntryPoint-ref=""digestEntryPoint"" /> <b:bean id=""digestEntryPoint"" class=""org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint"" p:realmName=""My App Realm"" p:key=""3028472b-da34-4501-bfd8-a355c42bdf92"" /> <http> <!-- ... --> <custom-filter ref=""userFilter"" position=""DIGEST_AUTH_FILTER""/> </http>"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/storage.html","Storage Mechanisms: Each of the supported mechanisms for reading a username and password can use any of the supported storage mechanisms: Simple Storage with In-Memory Authentication(in-memory.html#servlet-authentication-inmemory) Relational Databases with JDBC Authentication(jdbc.html#servlet-authentication-jdbc) Custom data stores with UserDetailsService(user-details-service.html#servlet-authentication-userdetailsservice) LDAP storage with LDAP Authentication(ldap.html#servlet-authentication-ldap) Section Summary: In Memory(in-memory.html) JDBC(jdbc.html) UserDetails(user-details.html) CredentialsContainer(credentials-container.html) UserDetailsService(user-details-service.html) PasswordEncoder(password-encoder.html) DaoAuthenticationProvider(dao-authentication-provider.html) LDAP(ldap.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/in-memory.html","In-Memory Authentication: Spring Security’s InMemoryUserDetailsManager implements UserDetailsService(user-details-service.html#servlet-authentication-userdetailsservice) to provide support for username/password based authentication that is stored in memory. InMemoryUserDetailsManager provides management of UserDetails by implementing the UserDetailsManager interface. UserDetails -based authentication is used by Spring Security when it is configured to accept a username and password(#servlet-authentication-unpwd-input) for authentication. In the following sample, we use Spring Boot CLI(../../../features/authentication/password-storage.html#authentication-password-storage-boot-cli) to encode a password value of password and get the encoded password of {bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW : InMemoryUserDetailsManager Java Configuration Java XML Kotlin @Bean public UserDetailsService users() { UserDetails user = User.builder() .username(""user"") .password(""{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"") .roles(""USER"") .build(); UserDetails admin = User.builder() .username(""admin"") .password(""{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"") .roles(""USER"", ""ADMIN"") .build(); return new InMemoryUserDetailsManager(user, admin); } <user-service> <user name=""user"" password=""{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"" authorities=""ROLE_USER"" /> <user name=""admin"" password=""{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"" authorities=""ROLE_USER,ROLE_ADMIN"" /> </user-service> @Bean fun users(): UserDetailsService { val user = User.builder() .username(""user"") .password(""{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"") .roles(""USER"") .build() val admin = User.builder() .username(""admin"") .password(""{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"") .roles(""USER"", ""ADMIN"") .build() return InMemoryUserDetailsManager(user, admin) } The preceding samples store the passwords in a secure format but leave a lot to be desired in terms of a getting started experience. In the following sample, we use User.withDefaultPasswordEncoder(../../../features/authentication/password-storage.html#authentication-password-storage-dep-getting-started) to ensure that the password stored in memory is protected. However, it does not protect against obtaining the password by decompiling the source code. For this reason, User.withDefaultPasswordEncoder should only be used for “getting started” and is not intended for production. InMemoryUserDetailsManager with User.withDefaultPasswordEncoder Java Kotlin @Bean public UserDetailsService users() { // The builder will ensure the passwords are encoded before saving in memory UserBuilder users = User.withDefaultPasswordEncoder(); UserDetails user = users .username(""user"") .password(""password"") .roles(""USER"") .build(); UserDetails admin = users .username(""admin"") .password(""password"") .roles(""USER"", ""ADMIN"") .build(); return new InMemoryUserDetailsManager(user, admin); } @Bean fun users(): UserDetailsService { // The builder will ensure the passwords are encoded before saving in memory val users = User.withDefaultPasswordEncoder() val user = users .username(""user"") .password(""password"") .roles(""USER"") .build() val admin = users .username(""admin"") .password(""password"") .roles(""USER"", ""ADMIN"") .build() return InMemoryUserDetailsManager(user, admin) } There is no simple way to use User.withDefaultPasswordEncoder with XML-based configuration. For demos or just getting started, you can choose to prefix the password with {noop} to indicate no encoding should be used(../../../features/authentication/password-storage.html#authentication-password-storage-dpe-format) : <user-service> {noop} XML Configuration <user-service> <user name=""user"" password=""{noop}password"" authorities=""ROLE_USER"" /> <user name=""admin"" password=""{noop}password"" authorities=""ROLE_USER,ROLE_ADMIN"" /> </user-service>"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/jdbc.html","JDBC Authentication: Spring Security’s JdbcDaoImpl implements UserDetailsService(user-details-service.html#servlet-authentication-userdetailsservice) to provide support for username-and-password-based authentication that is retrieved by using JDBC. JdbcUserDetailsManager extends JdbcDaoImpl to provide management of UserDetails through the UserDetailsManager interface. UserDetails -based authentication is used by Spring Security when it is configured to accept a username/password(index.html#servlet-authentication-unpwd-input) for authentication. In the following sections, we discuss: The Default Schema(#servlet-authentication-jdbc-schema) used by Spring Security JDBC Authentication Setting up a DataSource(#servlet-authentication-jdbc-datasource) JdbcUserDetailsManager Bean(#servlet-authentication-jdbc-bean) Default Schema: Spring Security provides default queries for JDBC-based authentication. This section provides the corresponding default schemas used with the default queries. You need to adjust the schema to match any customizations to the queries and the database dialect you use. User Schema: JdbcDaoImpl requires tables to load the password, account status (enabled or disabled) and a list of authorities (roles) for the user. The default schema is also exposed as a classpath resource named org/springframework/security/core/userdetails/jdbc/users.ddl . Default User Schema create table users( username varchar_ignorecase(50) not null primary key, password varchar_ignorecase(500) not null, enabled boolean not null ); create table authorities ( username varchar_ignorecase(50) not null, authority varchar_ignorecase(50) not null, constraint fk_authorities_users foreign key(username) references users(username) ); create unique index ix_auth_username on authorities (username,authority); Oracle is a popular database choice but requires a slightly different schema: Default User Schema for Oracle Databases CREATE TABLE USERS ( USERNAME NVARCHAR2(128) PRIMARY KEY, PASSWORD NVARCHAR2(128) NOT NULL, ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL ); CREATE TABLE AUTHORITIES ( USERNAME NVARCHAR2(128) NOT NULL, AUTHORITY NVARCHAR2(128) NOT NULL ); ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY); ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE; Group Schema: If your application uses groups, you need to provide the groups schema: Default Group Schema create table groups ( id bigint generated by default as identity(start with 0) primary key, group_name varchar_ignorecase(50) not null ); create table group_authorities ( group_id bigint not null, authority varchar(50) not null, constraint fk_group_authorities_group foreign key(group_id) references groups(id) ); create table group_members ( id bigint generated by default as identity(start with 0) primary key, username varchar(50) not null, group_id bigint not null, constraint fk_group_members_group foreign key(group_id) references groups(id) ); Setting up a DataSource: Before we configure JdbcUserDetailsManager , we must create a DataSource . In our example, we set up an embedded DataSource(https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#jdbc-embedded-database-support) that is initialized with the default user schema(#servlet-authentication-jdbc-schema) . Embedded Data Source Java XML Kotlin @Bean DataSource dataSource() { return new EmbeddedDatabaseBuilder() .setType(H2) .addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION) .build(); } <jdbc:embedded-database> <jdbc:script location=""classpath:org/springframework/security/core/userdetails/jdbc/users.ddl""/> </jdbc:embedded-database> @Bean fun dataSource(): DataSource { return EmbeddedDatabaseBuilder() .setType(H2) .addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION) .build() } In a production environment, you want to ensure that you set up a connection to an external database. JdbcUserDetailsManager Bean: In this sample, we use Spring Boot CLI(../../../features/authentication/password-storage.html#authentication-password-storage-boot-cli) to encode a password value of password and get the encoded password of {bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW . See the PasswordEncoder(../../../features/authentication/password-storage.html#authentication-password-storage) section for more details about how to store passwords. JdbcUserDetailsManager Java XML Kotlin @Bean UserDetailsManager users(DataSource dataSource) { UserDetails user = User.builder() .username(""user"") .password(""{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"") .roles(""USER"") .build(); UserDetails admin = User.builder() .username(""admin"") .password(""{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"") .roles(""USER"", ""ADMIN"") .build(); JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource); users.createUser(user); users.createUser(admin); return users; } <jdbc-user-service> <user name=""user"" password=""{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"" authorities=""ROLE_USER"" /> <user name=""admin"" password=""{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"" authorities=""ROLE_USER,ROLE_ADMIN"" /> </jdbc-user-service> @Bean fun users(dataSource: DataSource): UserDetailsManager { val user = User.builder() .username(""user"") .password(""{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"") .roles(""USER"") .build(); val admin = User.builder() .username(""admin"") .password(""{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"") .roles(""USER"", ""ADMIN"") .build(); val users = JdbcUserDetailsManager(dataSource) users.createUser(user) users.createUser(admin) return users }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/user-details.html","UserDetails: UserDetails(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/core/userdetails/UserDetails.html) is returned by the UserDetailsService(user-details-service.html#servlet-authentication-userdetailsservice) . The DaoAuthenticationProvider(dao-authentication-provider.html#servlet-authentication-daoauthenticationprovider) validates the UserDetails and then returns an Authentication(../architecture.html#servlet-authentication-authentication) that has a principal that is the UserDetails returned by the configured UserDetailsService ."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/credentials-container.html","CredentialsContainer: The CredentialsContainer(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/core/CredentialsContainer.html) interface indicates that the implementing object contains sensitive data, and is used internally by Spring Security to erase the authentication credentials after a successful authentication. This interface is implemented by most of Spring Security internal domain classes, like User(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/core/userdetails/User.html) and UsernamePasswordAuthenticationToken(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authentication/UsernamePasswordAuthenticationToken.html) . The ProviderManager manager checks whether the returned Authentication implements this interface. If so, it calls the eraseCredentials method(../architecture.html#servlet-authentication-providermanager-erasing-credentials) to remove the credentials from the object. If you want your custom authentication objects to have their credentials erased after authentication, you should ensure that the classes implement the CredentialsContainer interface. Users who are writing their own AuthenticationProvider implementations should create and return an appropriate Authentication object there, minus any sensitive data, rather than using this interface."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/user-details-service.html","UserDetailsService: UserDetailsService(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/core/userdetails/UserDetailsService.html) is used by DaoAuthenticationProvider(dao-authentication-provider.html#servlet-authentication-daoauthenticationprovider) for retrieving a username, a password, and other attributes for authenticating with a username and password. Spring Security provides in-memory(in-memory.html#servlet-authentication-inmemory) , JDBC(jdbc.html#servlet-authentication-jdbc) , and caching(caching.html#servlet-authentication-caching-user-details) implementations of UserDetailsService . You can define custom authentication by exposing a custom UserDetailsService as a bean. For example, the following listing customizes authentication, assuming that CustomUserDetailsService implements UserDetailsService : This is only used if the AuthenticationManagerBuilder has not been populated and no AuthenticationProviderBean is defined. Custom UserDetailsService Bean Java XML Kotlin @Bean CustomUserDetailsService customUserDetailsService() { return new CustomUserDetailsService(); } <b:bean class=""example.CustomUserDetailsService""/> @Bean fun customUserDetailsService() = CustomUserDetailsService()"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/password-encoder.html","PasswordEncoder: Spring Security’s servlet support includes storing passwords securely by integrating with PasswordEncoder(../../../features/authentication/password-storage.html#authentication-password-storage) . You can customize the PasswordEncoder implementation used by Spring Security by exposing a PasswordEncoder Bean(../../../features/authentication/password-storage.html#authentication-password-storage-configuration) ."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/dao-authentication-provider.html","DaoAuthenticationProvider: DaoAuthenticationProvider(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authentication/dao/DaoAuthenticationProvider.html) is an AuthenticationProvider(../architecture.html#servlet-authentication-authenticationprovider) implementation that uses a UserDetailsService(user-details-service.html#servlet-authentication-userdetailsservice) and PasswordEncoder(password-encoder.html#servlet-authentication-password-storage) to authenticate a username and password. This section examines how DaoAuthenticationProvider works within Spring Security. The following figure explains the workings of the AuthenticationManager(../architecture.html#servlet-authentication-authenticationmanager) in figures from the Reading the Username & Password(index.html#servlet-authentication-unpwd-input) section. Figure 1. DaoAuthenticationProvider Usage The authentication Filter from the Reading the Username & Password(index.html#servlet-authentication-unpwd-input) section passes a UsernamePasswordAuthenticationToken to the AuthenticationManager , which is implemented by ProviderManager(../architecture.html#servlet-authentication-providermanager) . The ProviderManager is configured to use an AuthenticationProvider(../architecture.html#servlet-authentication-authenticationprovider) of type DaoAuthenticationProvider . DaoAuthenticationProvider looks up the UserDetails from the UserDetailsService . DaoAuthenticationProvider uses the PasswordEncoder(password-encoder.html#servlet-authentication-password-storage) to validate the password on the UserDetails returned in the previous step. When authentication is successful, the Authentication(../architecture.html#servlet-authentication-authentication) that is returned is of type UsernamePasswordAuthenticationToken and has a principal that is the UserDetails returned by the configured UserDetailsService . Ultimately, the returned UsernamePasswordAuthenticationToken is set on the SecurityContextHolder(../architecture.html#servlet-authentication-securitycontextholder) by the authentication Filter ."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/passwords/ldap.html","LDAP Authentication: LDAP (Lightweight Directory Access Protocol) is often used by organizations as a central repository for user information and as an authentication service. It can also be used to store the role information for application users. Spring Security’s LDAP-based authentication is used by Spring Security when it is configured to accept a username/password(index.html#servlet-authentication-unpwd-input) for authentication. However, despite using a username and password for authentication, it does not use UserDetailsService , because, in bind authentication(#servlet-authentication-ldap-bind) , the LDAP server does not return the password, so the application cannot perform validation of the password. There are many different scenarios for how an LDAP server can be configured, so Spring Security’s LDAP provider is fully configurable. It uses separate strategy interfaces for authentication and role retrieval and provides default implementations, which can be configured to handle a wide range of situations. Required Dependencies: To get started, add the spring-security-ldap dependency to your project. When using Spring Boot, add the following dependencies: Spring Security LDAP Dependencies Maven Gradle <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-ldap</artifactId> </dependency> <dependency> <groupId>org.springframework.security</groupId> <artifactId>spring-security-ldap</artifactId> </dependency> depenendencies { implementation ""org.springframework.boot:spring-boot-starter-data-ldap"" implementation ""org.springframework.security:spring-security-ldap"" } Prerequisites: You should be familiar with LDAP before trying to use it with Spring Security. The following link provides a good introduction to the concepts involved and a guide to setting up a directory using the free LDAP server, OpenLDAP: www.zytrax.com/books/ldap/(https://www.zytrax.com/books/ldap/) . Some familiarity with the JNDI APIs used to access LDAP from Java can also be useful. We do not use any third-party LDAP libraries (Mozilla, JLDAP, or others) in the LDAP provider, but extensive use is made of Spring LDAP, so some familiarity with that project may be useful if you plan on adding your own customizations. When using LDAP authentication, you should ensure that you properly configure LDAP connection pooling. If you are unfamiliar with how to do so, see the Java LDAP documentation(https://docs.oracle.com/javase/jndi/tutorial/ldap/connect/config.html) . Setting up an Embedded LDAP Server: The first thing you need to do is to ensure that you have an LDAP Server to which to point your configuration. For simplicity, it is often best to start with an embedded LDAP Server. Spring Security supports using either: Embedded UnboundID Server(#servlet-authentication-ldap-unboundid) Embedded ApacheDS Server(#servlet-authentication-ldap-apacheds) In the following samples, we expose users.ldif as a classpath resource to initialize the embedded LDAP server with two users, user and admin , both of which have a password of password : users.ldif dn: ou=groups,dc=springframework,dc=org objectclass: top objectclass: organizationalUnit ou: groups dn: ou=people,dc=springframework,dc=org objectclass: top objectclass: organizationalUnit ou: people dn: uid=admin,ou=people,dc=springframework,dc=org objectclass: top objectclass: person objectclass: organizationalPerson objectclass: inetOrgPerson cn: Rod Johnson sn: Johnson uid: admin userPassword: password dn: uid=user,ou=people,dc=springframework,dc=org objectclass: top objectclass: person objectclass: organizationalPerson objectclass: inetOrgPerson cn: Dianne Emu sn: Emu uid: user userPassword: password dn: cn=user,ou=groups,dc=springframework,dc=org objectclass: top objectclass: groupOfNames cn: user member: uid=admin,ou=people,dc=springframework,dc=org member: uid=user,ou=people,dc=springframework,dc=org dn: cn=admin,ou=groups,dc=springframework,dc=org objectclass: top objectclass: groupOfNames cn: admin member: uid=admin,ou=people,dc=springframework,dc=org Embedded UnboundID Server: If you wish to use UnboundID(https://ldap.com/unboundid-ldap-sdk-for-java/) , specify the following dependencies: UnboundID Dependencies Maven Gradle <dependency> <groupId>com.unboundid</groupId> <artifactId>unboundid-ldapsdk</artifactId> <version>6.0.11</version> <scope>runtime</scope> </dependency> depenendencies { runtimeOnly ""com.unboundid:unboundid-ldapsdk:6.0.11"" } You can then configure the Embedded LDAP Server using an EmbeddedLdapServerContextSourceFactoryBean . This will instruct Spring Security to start an in-memory LDAP server: Embedded LDAP Server Configuration Java Kotlin @Bean public EmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean() { return EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer(); } @Bean fun contextSourceFactoryBean(): EmbeddedLdapServerContextSourceFactoryBean { return EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer() } Alternatively, you can manually configure the Embedded LDAP Server. If you choose this approach, you will be responsible for managing the lifecycle of the Embedded LDAP Server. Explicit Embedded LDAP Server Configuration Java XML Kotlin @Bean UnboundIdContainer ldapContainer() { return new UnboundIdContainer(""dc=springframework,dc=org"", ""classpath:users.ldif""); } <b:bean class=""org.springframework.security.ldap.server.UnboundIdContainer"" c:defaultPartitionSuffix=""dc=springframework,dc=org"" c:ldif=""classpath:users.ldif""/> @Bean fun ldapContainer(): UnboundIdContainer { return UnboundIdContainer(""dc=springframework,dc=org"",""classpath:users.ldif"") } Embedded ApacheDS Server: Spring Security uses ApacheDS 1.x, which is no longer maintained. Unfortunately, ApacheDS 2.x has only released milestone versions with no stable release. Once a stable release of ApacheDS 2.x is available, we will consider updating. If you wish to use Apache DS(https://directory.apache.org/apacheds/) , specify the following dependencies: ApacheDS Dependencies Maven Gradle <dependency> <groupId>org.apache.directory.server</groupId> <artifactId>apacheds-core</artifactId> <version>1.5.5</version> <scope>runtime</scope> </dependency> <dependency> <groupId>org.apache.directory.server</groupId> <artifactId>apacheds-server-jndi</artifactId> <version>1.5.5</version> <scope>runtime</scope> </dependency> depenendencies { runtimeOnly ""org.apache.directory.server:apacheds-core:1.5.5"" runtimeOnly ""org.apache.directory.server:apacheds-server-jndi:1.5.5"" } You can then configure the Embedded LDAP Server: Embedded LDAP Server Configuration Java XML Kotlin @Bean ApacheDSContainer ldapContainer() { return new ApacheDSContainer(""dc=springframework,dc=org"", ""classpath:users.ldif""); } <b:bean class=""org.springframework.security.ldap.server.ApacheDSContainer"" c:defaultPartitionSuffix=""dc=springframework,dc=org"" c:ldif=""classpath:users.ldif""/> @Bean fun ldapContainer(): ApacheDSContainer { return ApacheDSContainer(""dc=springframework,dc=org"", ""classpath:users.ldif"") } LDAP ContextSource: Once you have an LDAP Server to which to point your configuration, you need to configure Spring Security to point to an LDAP server that should be used to authenticate users. To do so, create an LDAP ContextSource (which is the equivalent of a JDBC DataSource ). If you have already configured an EmbeddedLdapServerContextSourceFactoryBean , Spring Security will create an LDAP ContextSource that points to the embedded LDAP server. LDAP Context Source with Embedded LDAP Server Java Kotlin @Bean public EmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean() { EmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean = EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer(); contextSourceFactoryBean.setPort(0); return contextSourceFactoryBean; } @Bean fun contextSourceFactoryBean(): EmbeddedLdapServerContextSourceFactoryBean { val contextSourceFactoryBean = EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer() contextSourceFactoryBean.setPort(0) return contextSourceFactoryBean } Alternatively, you can explicitly configure the LDAP ContextSource to connect to the supplied LDAP server: LDAP Context Source Java XML Kotlin ContextSource contextSource(UnboundIdContainer container) { return new DefaultSpringSecurityContextSource(""ldap://localhost:53389/dc=springframework,dc=org""); } <ldap-server url=""ldap://localhost:53389/dc=springframework,dc=org"" /> fun contextSource(container: UnboundIdContainer): ContextSource { return DefaultSpringSecurityContextSource(""ldap://localhost:53389/dc=springframework,dc=org"") } Authentication: Spring Security’s LDAP support does not use the UserDetailsService(user-details-service.html#servlet-authentication-userdetailsservice) because LDAP bind authentication does not let clients read the password or even a hashed version of the password. This means there is no way for a password to be read and then authenticated by Spring Security. For this reason, LDAP support is implemented through the LdapAuthenticator interface. The LdapAuthenticator interface is also responsible for retrieving any required user attributes. This is because the permissions on the attributes may depend on the type of authentication being used. For example, if binding as the user, it may be necessary to read the attributes with the user’s own permissions. Spring Security supplies two LdapAuthenticator implementations: Using Bind Authentication(#servlet-authentication-ldap-bind) Using Password Authentication(#servlet-authentication-ldap-pwd) Using Bind Authentication: Bind Authentication(https://ldap.com/the-ldap-bind-operation/) is the most common mechanism for authenticating users with LDAP. In bind authentication, the user’s credentials (username and password) are submitted to the LDAP server, which authenticates them. The advantage to using bind authentication is that the user’s secrets (the password) do not need to be exposed to clients, which helps to protect them from leaking. The following example shows bind authentication configuration: Bind Authentication Java XML Kotlin @Bean AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource) { LdapBindAuthenticationManagerFactory factory = new LdapBindAuthenticationManagerFactory(contextSource); factory.setUserDnPatterns(""uid={0},ou=people""); return factory.createAuthenticationManager(); } <ldap-authentication-provider user-dn-pattern=""uid={0},ou=people""/> @Bean fun authenticationManager(contextSource: BaseLdapPathContextSource): AuthenticationManager { val factory = LdapBindAuthenticationManagerFactory(contextSource) factory.setUserDnPatterns(""uid={0},ou=people"") return factory.createAuthenticationManager() } The preceding simple example would obtain the DN for the user by substituting the user login name in the supplied pattern and attempting to bind as that user with the login password. This is OK if all your users are stored under a single node in the directory. If, instead, you wish to configure an LDAP search filter to locate the user, you could use the following: Bind Authentication with Search Filter Java XML Kotlin @Bean AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource) { LdapBindAuthenticationManagerFactory factory = new LdapBindAuthenticationManagerFactory(contextSource); factory.setUserSearchFilter(""(uid={0})""); factory.setUserSearchBase(""ou=people""); return factory.createAuthenticationManager(); } <ldap-authentication-provider user-search-filter=""(uid={0})"" user-search-base=""ou=people""/> @Bean fun authenticationManager(contextSource: BaseLdapPathContextSource): AuthenticationManager { val factory = LdapBindAuthenticationManagerFactory(contextSource) factory.setUserSearchFilter(""(uid={0})"") factory.setUserSearchBase(""ou=people"") return factory.createAuthenticationManager() } If used with the ContextSource definition shown earlier(#servlet-authentication-ldap-contextsource) , this would perform a search under the DN ou=people,dc=springframework,dc=org by using (uid={0}) as a filter. Again, the user login name is substituted for the parameter in the filter name, so it searches for an entry with the uid attribute equal to the user name. If a user search base is not supplied, the search is performed from the root. Using Password Authentication: Password comparison is when the password supplied by the user is compared with the one stored in the repository. This can either be done by retrieving the value of the password attribute and checking it locally or by performing an LDAP “compare” operation, where the supplied password is passed to the server for comparison and the real password value is never retrieved. An LDAP compare cannot be done when the password is properly hashed with a random salt. Minimal Password Compare Configuration Java XML Kotlin @Bean AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource) { LdapPasswordComparisonAuthenticationManagerFactory factory = new LdapPasswordComparisonAuthenticationManagerFactory( contextSource, NoOpPasswordEncoder.getInstance()); factory.setUserDnPatterns(""uid={0},ou=people""); return factory.createAuthenticationManager(); } <ldap-authentication-provider user-dn-pattern=""uid={0},ou=people""> <password-compare /> </ldap-authentication-provider> @Bean fun authenticationManager(contextSource: BaseLdapPathContextSource?): AuthenticationManager? { val factory = LdapPasswordComparisonAuthenticationManagerFactory( contextSource, NoOpPasswordEncoder.getInstance() ) factory.setUserDnPatterns(""uid={0},ou=people"") return factory.createAuthenticationManager() } The following example shows a more advanced configuration with some customizations: Password Compare Configuration Java XML Kotlin @Bean AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource) { LdapPasswordComparisonAuthenticationManagerFactory factory = new LdapPasswordComparisonAuthenticationManagerFactory( contextSource, new BCryptPasswordEncoder()); factory.setUserDnPatterns(""uid={0},ou=people""); factory.setPasswordAttribute(""pwd""); (1) return factory.createAuthenticationManager(); } <ldap-authentication-provider user-dn-pattern=""uid={0},ou=people""> <password-compare password-attribute=""pwd""> (1) <password-encoder ref=""passwordEncoder"" /> (2) </password-compare> </ldap-authentication-provider> <b:bean id=""passwordEncoder"" class=""org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"" /> @Bean fun authenticationManager(contextSource: BaseLdapPathContextSource): AuthenticationManager { val factory = LdapPasswordComparisonAuthenticationManagerFactory( contextSource, BCryptPasswordEncoder() ) factory.setUserDnPatterns(""uid={0},ou=people"") factory.setPasswordAttribute(""pwd"") (1) return factory.createAuthenticationManager() } 1 Specify the password attribute as pwd . LdapAuthoritiesPopulator: Spring Security’s LdapAuthoritiesPopulator is used to determine what authorities are returned for the user. The following example shows how configure LdapAuthoritiesPopulator : LdapAuthoritiesPopulator Configuration Java XML Kotlin @Bean LdapAuthoritiesPopulator authorities(BaseLdapPathContextSource contextSource) { String groupSearchBase = """"; DefaultLdapAuthoritiesPopulator authorities = new DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase); authorities.setGroupSearchFilter(""member={0}""); return authorities; } @Bean AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource, LdapAuthoritiesPopulator authorities) { LdapBindAuthenticationManagerFactory factory = new LdapBindAuthenticationManagerFactory(contextSource); factory.setUserDnPatterns(""uid={0},ou=people""); factory.setLdapAuthoritiesPopulator(authorities); return factory.createAuthenticationManager(); } <ldap-authentication-provider user-dn-pattern=""uid={0},ou=people"" group-search-filter=""member={0}""/> @Bean fun authorities(contextSource: BaseLdapPathContextSource): LdapAuthoritiesPopulator { val groupSearchBase = """" val authorities = DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase) authorities.setGroupSearchFilter(""member={0}"") return authorities } @Bean fun authenticationManager( contextSource: BaseLdapPathContextSource, authorities: LdapAuthoritiesPopulator): AuthenticationManager { val factory = LdapBindAuthenticationManagerFactory(contextSource) factory.setUserDnPatterns(""uid={0},ou=people"") factory.setLdapAuthoritiesPopulator(authorities) return factory.createAuthenticationManager() } Active Directory: Active Directory supports its own non-standard authentication options, and the normal usage pattern does not fit too cleanly with the standard LdapAuthenticationProvider . Typically, authentication is performed by using the domain username (in the form of user@domain ), rather than using an LDAP distinguished name. To make this easier, Spring Security has an authentication provider, which is customized for a typical Active Directory setup. Configuring ActiveDirectoryLdapAuthenticationProvider is quite straightforward. You need only supply the domain name and an LDAP URL that supplies the address of the server. It is also possible to obtain the server’s IP address by using a DNS lookup. This is not currently supported, but hopefully will be in a future version. The following example configures Active Directory: Example Active Directory Configuration Java XML Kotlin @Bean ActiveDirectoryLdapAuthenticationProvider authenticationProvider() { return new ActiveDirectoryLdapAuthenticationProvider(""example.com"", ""ldap://company.example.com/""); } <bean id=""authenticationProvider"" class=""org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider""> <constructor-arg value=""example.com"" /> <constructor-arg value=""ldap://company.example.com/"" /> </bean> @Bean fun authenticationProvider(): ActiveDirectoryLdapAuthenticationProvider { return ActiveDirectoryLdapAuthenticationProvider(""example.com"", ""ldap://company.example.com/"") }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/persistence.html","Persisting Authentication: The first time a user requests a protected resource, they are prompted for credentials(architecture.html#servlet-authentication-authenticationentrypoint) . One of the most common ways to prompt for credentials is to redirect the user to a log in page(passwords/form.html) . A summarized HTTP exchange for an unauthenticated user requesting a protected resource might look like this: Example 1. Unauthenticated User Requests Protected Resource GET / HTTP/1.1 Host: example.com Cookie: SESSION=91470ce0-3f3c-455b-b7ad-079b02290f7b HTTP/1.1 302 Found Location: /login The user submits their username and password. Username and Password Submitted POST /login HTTP/1.1 Host: example.com Cookie: SESSION=91470ce0-3f3c-455b-b7ad-079b02290f7b username=user&password=password&_csrf=35942e65-a172-4cd4-a1d4-d16a51147b3e Upon authenticating the user, the user is associated to a new session id to prevent session fixation attacks(session-management.html#ns-session-fixation) . Authenticated User is Associated to New Session HTTP/1.1 302 Found Location: / Set-Cookie: SESSION=4c66e474-3f5a-43ed-8e48-cc1d8cb1d1c8; Path=/; HttpOnly; SameSite=Lax Subsequent requests include the session cookie which is used to authenticate the user for the remainder of the session. Authenticated Session Provided as Credentials GET / HTTP/1.1 Host: example.com Cookie: SESSION=4c66e474-3f5a-43ed-8e48-cc1d8cb1d1c8 SecurityContextRepository: In Spring Security the association of the user to future requests is made using SecurityContextRepository(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/context/SecurityContextRepository.html) . The default implementation of SecurityContextRepository is DelegatingSecurityContextRepository(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/context/DelegatingSecurityContextRepository.html) which delegates to the following: HttpSessionSecurityContextRepository(#httpsecuritycontextrepository) RequestAttributeSecurityContextRepository(#requestattributesecuritycontextrepository) HttpSessionSecurityContextRepository: The HttpSessionSecurityContextRepository(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/context/HttpSessionSecurityContextRepository.html) associates the SecurityContext(architecture.html#servlet-authentication-securitycontext) to the HttpSession . Users can replace HttpSessionSecurityContextRepository with another implementation of SecurityContextRepository if they wish to associate the user with subsequent requests in another way or not at all. NullSecurityContextRepository: If it is not desirable to associate the SecurityContext to an HttpSession (i.e. when authenticating with OAuth) the NullSecurityContextRepository(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/context/NullSecurityContextRepository.html) is an implementation of SecurityContextRepository that does nothing. RequestAttributeSecurityContextRepository: The RequestAttributeSecurityContextRepository(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/context/RequestAttributeSecurityContextRepository.html) saves the SecurityContext as a request attribute to make sure the SecurityContext is available for a single request that occurs across dispatch types that may clear out the SecurityContext . For example, assume that a client makes a request, is authenticated, and then an error occurs. Depending on the servlet container implementation, the error means that any SecurityContext that was established is cleared out and then the error dispatch is made. When the error dispatch is made, there is no SecurityContext established. This means that the error page cannot use the SecurityContext for authorization or displaying the current user unless the SecurityContext is persisted somehow. Use RequestAttributeSecurityContextRepository Java XML public SecurityFilterChain filterChain(HttpSecurity http) { http // ... .securityContext((securityContext) -> securityContext .securityContextRepository(new RequestAttributeSecurityContextRepository()) ); return http.build(); } <http security-context-repository-ref=""contextRepository""> <!-- ... --> </http> <b:bean name=""contextRepository"" class=""org.springframework.security.web.context.RequestAttributeSecurityContextRepository"" /> DelegatingSecurityContextRepository: The DelegatingSecurityContextRepository(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/context/DelegatingSecurityContextRepository.html) saves the SecurityContext to multiple SecurityContextRepository delegates and allows retrieval from any of the delegates in a specified order. The most useful arrangement for this is configured with the following example, which allows the use of both RequestAttributeSecurityContextRepository(#requestattributesecuritycontextrepository) and HttpSessionSecurityContextRepository(#httpsecuritycontextrepository) simultaneously. Configure DelegatingSecurityContextRepository Java Kotlin XML @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .securityContext((securityContext) -> securityContext .securityContextRepository(new DelegatingSecurityContextRepository( new RequestAttributeSecurityContextRepository(), new HttpSessionSecurityContextRepository() )) ); return http.build(); } @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... securityContext { securityContextRepository = DelegatingSecurityContextRepository( RequestAttributeSecurityContextRepository(), HttpSessionSecurityContextRepository() ) } } return http.build() } <http security-context-repository-ref=""contextRepository""> <!-- ... --> </http> <bean name=""contextRepository"" class=""org.springframework.security.web.context.DelegatingSecurityContextRepository""> <constructor-arg> <bean class=""org.springframework.security.web.context.RequestAttributeSecurityContextRepository"" /> </constructor-arg> <constructor-arg> <bean class=""org.springframework.security.web.context.HttpSessionSecurityContextRepository"" /> </constructor-arg> </bean> In Spring Security 6, the example shown above is the default configuration. SecurityContextPersistenceFilter: The SecurityContextPersistenceFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/context/SecurityContextPersistenceFilter.html) is responsible for persisting the SecurityContext between requests using the SecurityContextRepository(#securitycontextrepository) . Before running the rest of the application, SecurityContextPersistenceFilter loads the SecurityContext from the SecurityContextRepository and sets it on the SecurityContextHolder . Next, the application is ran. Finally, if the SecurityContext has changed, we save the SecurityContext using the SecurityContextPersistenceRepository . This means that when using SecurityContextPersistenceFilter , just setting the SecurityContextHolder will ensure that the SecurityContext is persisted using SecurityContextRepository . In some cases a response is committed and written to the client before the SecurityContextPersistenceFilter method completes. For example, if a redirect is sent to the client the response is immediately written back to the client. This means that establishing an HttpSession would not be possible in step 3 because the session id could not be included in the already written response. Another situation that can happen is that if a client authenticates successfully, the response is committed before SecurityContextPersistenceFilter completes, and the client makes a second request before the SecurityContextPersistenceFilter completes the wrong authentication could be present in the second request. To avoid these problems, the SecurityContextPersistenceFilter wraps both the HttpServletRequest and the HttpServletResponse to detect if the SecurityContext has changed and if so save the SecurityContext just before the response is committed. SecurityContextHolderFilter: The SecurityContextHolderFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/context/SecurityContextHolderFilter.html) is responsible for loading the SecurityContext between requests using the SecurityContextRepository(#securitycontextrepository) . Before running the rest of the application, SecurityContextHolderFilter loads the SecurityContext from the SecurityContextRepository and sets it on the SecurityContextHolder . Next, the application is ran. Unlike, SecurityContextPersistenceFilter(#securitycontextpersistencefilter) , SecurityContextHolderFilter only loads the SecurityContext it does not save the SecurityContext . This means that when using SecurityContextHolderFilter , it is required that the SecurityContext is explicitly saved. Explicit Saving of SecurityContext Java Kotlin XML public SecurityFilterChain filterChain(HttpSecurity http) { http // ... .securityContext((securityContext) -> securityContext .requireExplicitSave(true) ); return http.build(); } @Bean open fun springSecurity(http: HttpSecurity): SecurityFilterChain { http { securityContext { requireExplicitSave = true } } return http.build() } <http security-context-explicit-save=""true""> <!-- ... --> </http> Upon using the configuration, it is important that any code that sets the SecurityContextHolder with a SecurityContext also saves the SecurityContext to the SecurityContextRepository if it should be persisted between requests. For example, the following code: Setting SecurityContextHolder with SecurityContextPersistenceFilter Java Kotlin SecurityContextHolder.setContext(securityContext); SecurityContextHolder.setContext(securityContext) should be replaced with Setting SecurityContextHolder with SecurityContextHolderFilter Java Kotlin SecurityContextHolder.setContext(securityContext); securityContextRepository.saveContext(securityContext, httpServletRequest, httpServletResponse); SecurityContextHolder.setContext(securityContext) securityContextRepository.saveContext(securityContext, httpServletRequest, httpServletResponse)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/session-management.html","Authentication Persistence and Session Management: Once you have got an application that is authenticating requests(index.html) , it is important to consider how that resulting authentication will be persisted and restored on future requests. This is done automatically by default, so no additional code is necessary, though it is important to know what requireExplicitSave means in HttpSecurity . If you like, you can read more about what requireExplicitSave is doing(#how-it-works-requireexplicitsave) or why it’s important(#requireexplicitsave) . Otherwise, in most cases you are done with this section. But before you leave, consider if any of these use cases fit your application: I want to Understand Session Management’s components(#understanding-session-management-components) I want to restrict the number of times(#ns-concurrent-sessions) a user can be logged in concurrently I want to store the authentication directly(#store-authentication-manually) myself instead of Spring Security doing it for me I am storing the authentication manually and I want to remove it(#properly-clearing-authentication) I am using SessionManagementFilter(#the-sessionmanagementfilter) and I need guidance on moving away from that(#moving-away-from-sessionmanagementfilter) I want to store the authentication in something other than the session(#customizing-where-authentication-is-stored) I am using a stateless authentication(#stateless-authentication) , but I’d still like to store it in the session(#storing-stateless-authentication-in-the-session) I am using SessionCreationPolicy.NEVER but the application is still creating sessions(#never-policy-session-still-created) . Understanding Session Management’s Components: The Session Management support is composed of a few components that work together to provide the functionality. Those components are, the SecurityContextHolderFilter(persistence.html#securitycontextholderfilter) , the SecurityContextPersistenceFilter(persistence.html#securitycontextpersistencefilter) and the SessionManagementFilter(#the-sessionmanagementfilter) . In Spring Security 6, the SecurityContextPersistenceFilter and SessionManagementFilter are not set by default. In addition to that, any application should only have either SecurityContextHolderFilter or SecurityContextPersistenceFilter set, never both. The SessionManagementFilter: The SessionManagementFilter checks the contents of the SecurityContextRepository against the current contents of the SecurityContextHolder to determine whether a user has been authenticated during the current request, typically by a non-interactive authentication mechanism, such as pre-authentication or remember-me [ 1(#_footnotedef_1) ] . If the repository contains a security context, the filter does nothing. If it doesn’t, and the thread-local SecurityContext contains a (non-anonymous) Authentication object, the filter assumes they have been authenticated by a previous filter in the stack. It will then invoke the configured SessionAuthenticationStrategy . If the user is not currently authenticated, the filter will check whether an invalid session ID has been requested (because of a timeout, for example) and will invoke the configured InvalidSessionStrategy , if one is set. The most common behaviour is just to redirect to a fixed URL and this is encapsulated in the standard implementation SimpleRedirectInvalidSessionStrategy . The latter is also used when configuring an invalid session URL through the namespace, as described earlier(#session-mgmt) . Moving Away From SessionManagementFilter: In Spring Security 5, the default configuration relies on SessionManagementFilter to detect if a user just authenticated and invoke the SessionAuthenticationStrategy(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/session/SessionAuthenticationStrategy.html) . The problem with this is that it means that in a typical setup, the HttpSession must be read for every request. In Spring Security 6, the default is that authentication mechanisms themselves must invoke the SessionAuthenticationStrategy . This means that there is no need to detect when Authentication is done and thus the HttpSession does not need to be read for every request. Things To Consider When Moving Away From SessionManagementFilter: In Spring Security 6, the SessionManagementFilter is not used by default, therefore, some methods from the sessionManagement DSL will not have any effect. Method Replacement sessionAuthenticationErrorUrl Configure an AuthenticationFailureHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api//org/springframework/security/web/authentication/AuthenticationFailureHandler.html) in your authentication mechanism sessionAuthenticationFailureHandler Configure an AuthenticationFailureHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api//org/springframework/security/web/authentication/AuthenticationFailureHandler.html) in your authentication mechanism sessionAuthenticationStrategy Configure an SessionAuthenticationStrategy in your authentication mechanism as discussed above(#moving-away-from-sessionmanagementfilter) If you try to use any of these methods, an exception will be thrown. Customizing Where the Authentication Is Stored: By default, Spring Security stores the security context for you in the HTTP session. However, here are several reasons you may want to customize that: You may want to call individual setters on the HttpSessionSecurityContextRepository instance You may want to store the security context in a cache or database to enable horizontal scaling First, you need to create an implementation of SecurityContextRepository or use an existing implementation like HttpSessionSecurityContextRepository , then you can set it in HttpSecurity . Customizing the SecurityContextRepository Java Kotlin XML @Bean public SecurityFilterChain filterChain(HttpSecurity http) { SecurityContextRepository repo = new MyCustomSecurityContextRepository(); http // ... .securityContext((context) -> context .securityContextRepository(repo) ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { val repo = MyCustomSecurityContextRepository() http { // ... securityContext { securityContextRepository = repo } } return http.build() } <http security-context-repository-ref=""repo""> <!-- ... --> </http> <bean name=""repo"" class=""com.example.MyCustomSecurityContextRepository"" /> The above configuration sets the SecurityContextRepository on the SecurityContextHolderFilter and participating authentication filters, like UsernamePasswordAuthenticationFilter . To also set it in stateless filters, please see how to customize the SecurityContextRepository for Stateless Authentication(#storing-stateless-authentication-in-the-session) . If you are using a custom authentication mechanism, you might want to store the Authentication by yourself(#store-authentication-manually) . Storing the Authentication manually: In some cases, for example, you might be authenticating a user manually instead of relying on Spring Security filters. You can use a custom filters or a Spring MVC controller(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html//web.html#mvc-controller) endpoint to do that. If you want to save the authentication between requests, in the HttpSession , for example, you have to do so: Java private SecurityContextRepository securityContextRepository = new HttpSessionSecurityContextRepository(); (1) @PostMapping(""/login"") public void login(@RequestBody LoginRequest loginRequest, HttpServletRequest request, HttpServletResponse response) { (2) UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated( loginRequest.getUsername(), loginRequest.getPassword()); (3) Authentication authentication = authenticationManager.authenticate(token); (4) SecurityContext context = securityContextHolderStrategy.createEmptyContext(); context.setAuthentication(authentication); (5) securityContextHolderStrategy.setContext(context); securityContextRepository.saveContext(context, request, response); (6) } class LoginRequest { private String username; private String password; // getters and setters } 1 Add the SecurityContextRepository to the controller 2 Inject the HttpServletRequest and HttpServletResponse to be able to save the SecurityContext 3 Create an unauthenticated UsernamePasswordAuthenticationToken using the provided credentials 4 Call AuthenticationManager#authenticate to authenticate the user 5 Create a SecurityContext and set the Authentication in it 6 Save the SecurityContext in the SecurityContextRepository And that’s it. If you are not sure what securityContextHolderStrategy is in the above example, you can read more about it in the Using SecurityContextStrategy section(#use-securitycontextholderstrategy) . Properly Clearing an Authentication: If you are using Spring Security’s Logout Support(logout.html) then it handles a lot of stuff for you including clearing and saving the context. But, let’s say you need to manually log users out of your app. In that case, you’ll need to make sure you’re clearing and saving the context properly(logout.html#creating-custom-logout-endpoint) . Configuring Persistence for Stateless Authentication: Sometimes there is no need to create and maintain a HttpSession for example, to persist the authentication across requests. Some authentication mechanisms like HTTP Basic(passwords/basic.html) are stateless and, therefore, re-authenticates the user on every request. If you do not wish to create sessions, you can use SessionCreationPolicy.STATELESS , like so: Java Kotlin XML @Bean public SecurityFilterChain filterChain(HttpSecurity http) { http // ... .sessionManagement((session) -> session .sessionCreationPolicy(SessionCreationPolicy.STATELESS) ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... sessionManagement { sessionCreationPolicy = SessionCreationPolicy.STATELESS } } return http.build() } <http create-session=""stateless""> <!-- ... --> </http> The above configuration is configuring the SecurityContextRepository(#customizing-where-authentication-is-stored) to use a NullSecurityContextRepository and is also preventing the request from being saved in the session(../architecture.html#requestcache-prevent-saved-request) . If you are using SessionCreationPolicy.NEVER , you might notice that the application is still creating a HttpSession . In most cases, this happens because the request is saved in the session(../architecture.html#savedrequests) for the authenticated resource to re-request after authentication is successful. To avoid that, please refer to how to prevent the request of being saved(../architecture.html#requestcache-prevent-saved-request) section. Storing Stateless Authentication in the Session: If, for some reason, you are using a stateless authentication mechanism, but you still want to store the authentication in the session you can use the HttpSessionSecurityContextRepository instead of the NullSecurityContextRepository . For the HTTP Basic(passwords/basic.html) , you can add a ObjectPostProcessor(../configuration/java.html#post-processing-configured-objects) that changes the SecurityContextRepository used by the BasicAuthenticationFilter : Store HTTP Basic authentication in the HttpSession Java @Bean SecurityFilterChain web(HttpSecurity http) throws Exception { http // ... .httpBasic((basic) -> basic .addObjectPostProcessor(new ObjectPostProcessor<BasicAuthenticationFilter>() { @Override public <O extends BasicAuthenticationFilter> O postProcess(O filter) { filter.setSecurityContextRepository(new HttpSessionSecurityContextRepository()); return filter; } }) ); return http.build(); } The above also applies to others authentication mechanisms, like Bearer Token Authentication(../oauth2/resource-server/index.html) . Understanding Require Explicit Save: In Spring Security 5, the default behavior is for the SecurityContext(architecture.html#servlet-authentication-securitycontext) to automatically be saved to the SecurityContextRepository(persistence.html#securitycontextrepository) using the SecurityContextPersistenceFilter(#securitycontextpersistencefilter) . Saving must be done just prior to the HttpServletResponse being committed and just before SecurityContextPersistenceFilter . Unfortunately, automatic persistence of the SecurityContext can surprise users when it is done prior to the request completing (i.e. just prior to committing the HttpServletResponse ). It also is complex to keep track of the state to determine if a save is necessary causing unnecessary writes to the SecurityContextRepository (i.e. HttpSession ) at times. For these reasons, the SecurityContextPersistenceFilter has been deprecated to be replaced with the SecurityContextHolderFilter . In Spring Security 6, the default behavior is that the SecurityContextHolderFilter(persistence.html#securitycontextholderfilter) will only read the SecurityContext from SecurityContextRepository and populate it in the SecurityContextHolder . Users now must explicitly save the SecurityContext with the SecurityContextRepository if they want the SecurityContext to persist between requests. This removes ambiguity and improves performance by only requiring writing to the SecurityContextRepository (i.e. HttpSession ) when it is necessary. How it works: In summary, when requireExplicitSave is true , Spring Security sets up the SecurityContextHolderFilter(persistence.html#securitycontextholderfilter) instead of the SecurityContextPersistenceFilter(persistence.html#securitycontextpersistencefilter) Configuring Concurrent Session Control: If you wish to place constraints on a single user’s ability to log in to your application, Spring Security supports this out of the box with the following simple additions. First, you need to add the following listener to your configuration to keep Spring Security updated about session lifecycle events: Java Kotlin web.xml @Bean public HttpSessionEventPublisher httpSessionEventPublisher() { return new HttpSessionEventPublisher(); } @Bean open fun httpSessionEventPublisher(): HttpSessionEventPublisher { return HttpSessionEventPublisher() } <listener> <listener-class> org.springframework.security.web.session.HttpSessionEventPublisher </listener-class> </listener> Then add the following lines to your security configuration: Java Kotlin XML @Bean public SecurityFilterChain filterChain(HttpSecurity http) { http .sessionManagement(session -> session .maximumSessions(1) ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { sessionManagement { sessionConcurrency { maximumSessions = 1 } } } return http.build() } <http> ... <session-management> <concurrency-control max-sessions=""1"" /> </session-management> </http> This will prevent a user from logging in multiple times - a second login will cause the first to be invalidated. Using Spring Boot, you can test the above configuration scenario the following way: Java @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @AutoConfigureMockMvc public class MaximumSessionsTests { @Autowired private MockMvc mvc; @Test void loginOnSecondLoginThenFirstSessionTerminated() throws Exception { MvcResult mvcResult = this.mvc.perform(formLogin()) .andExpect(authenticated()) .andReturn(); MockHttpSession firstLoginSession = (MockHttpSession) mvcResult.getRequest().getSession(); this.mvc.perform(get(""/"").session(firstLoginSession)) .andExpect(authenticated()); this.mvc.perform(formLogin()).andExpect(authenticated()); // first session is terminated by second login this.mvc.perform(get(""/"").session(firstLoginSession)) .andExpect(unauthenticated()); } } You can try it using the Maximum Sessions sample(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/spring-boot/java/session-management/maximum-sessions) . It is also common that you would prefer to prevent a second login, in which case you can use: Java Kotlin XML @Bean public SecurityFilterChain filterChain(HttpSecurity http) { http .sessionManagement(session -> session .maximumSessions(1) .maxSessionsPreventsLogin(true) ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { sessionManagement { sessionConcurrency { maximumSessions = 1 maxSessionsPreventsLogin = true } } } return http.build() } <http> <session-management> <concurrency-control max-sessions=""1"" error-if-maximum-exceeded=""true"" /> </session-management> </http> The second login will then be rejected. By ""rejected"", we mean that the user will be sent to the authentication-failure-url if form-based login is being used. If the second authentication takes place through another non-interactive mechanism, such as ""remember-me"", an ""unauthorized"" (401) error will be sent to the client. If instead you want to use an error page, you can add the attribute session-authentication-error-url to the session-management element. Using Spring Boot, you can test the above configuration the following way: Java @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @AutoConfigureMockMvc public class MaximumSessionsPreventLoginTests { @Autowired private MockMvc mvc; @Test void loginOnSecondLoginThenPreventLogin() throws Exception { MvcResult mvcResult = this.mvc.perform(formLogin()) .andExpect(authenticated()) .andReturn(); MockHttpSession firstLoginSession = (MockHttpSession) mvcResult.getRequest().getSession(); this.mvc.perform(get(""/"").session(firstLoginSession)) .andExpect(authenticated()); // second login is prevented this.mvc.perform(formLogin()).andExpect(unauthenticated()); // first session is still valid this.mvc.perform(get(""/"").session(firstLoginSession)) .andExpect(authenticated()); } } If you are using a customized authentication filter for form-based login, then you have to configure concurrent session control support explicitly. You can try it using the Maximum Sessions Prevent Login sample(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/spring-boot/java/session-management/maximum-sessions-prevent-login) . Detecting Timeouts: Sessions expire on their own, and there is nothing that needs to be done to ensure that a security context gets removed. That said, Spring Security can detect when a session has expired and take specific actions that you indicate. For example, you may want to redirect to a specific endpoint when a user makes a request with an already-expired session. This is achieved through the invalidSessionUrl in HttpSecurity : Java Kotlin XML @Bean public SecurityFilterChain filterChain(HttpSecurity http) { http .sessionManagement(session -> session .invalidSessionUrl(""/invalidSession"") ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { sessionManagement { invalidSessionUrl = ""/invalidSession"" } } return http.build() } <http> ... <session-management invalid-session-url=""/invalidSession"" /> </http> Note that if you use this mechanism to detect session timeouts, it may falsely report an error if the user logs out and then logs back in without closing the browser. This is because the session cookie is not cleared when you invalidate the session and will be resubmitted even if the user has logged out. If that is your case, you might want to configure logout to clear the session cookie(#clearing-session-cookie-on-logout) . Customizing the Invalid Session Strategy: The invalidSessionUrl is a convenience method for setting the InvalidSessionStrategy using the SimpleRedirectInvalidSessionStrategy implementation(https://docs.spring.io/spring-security/site/docs/6.3.3/api//org/springframework/security/web/session/SimpleRedirectInvalidSessionStrategy.html) . If you want to customize the behavior, you can implement the InvalidSessionStrategy(https://docs.spring.io/spring-security/site/docs/6.3.3/api//org/springframework/security/web/session/InvalidSessionStrategy.html) interface and configure it using the invalidSessionStrategy method: Java Kotlin XML @Bean public SecurityFilterChain filterChain(HttpSecurity http) { http .sessionManagement(session -> session .invalidSessionStrategy(new MyCustomInvalidSessionStrategy()) ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { sessionManagement { invalidSessionStrategy = MyCustomInvalidSessionStrategy() } } return http.build() } <http> ... <session-management invalid-session-strategy-ref=""myCustomInvalidSessionStrategy"" /> <bean name=""myCustomInvalidSessionStrategy"" class=""com.example.MyCustomInvalidSessionStrategy"" /> </http> Clearing Session Cookies on Logout: You can explicitly delete the JSESSIONID cookie on logging out, for example by using the Clear-Site-Data header(https://w3c.github.io/webappsec-clear-site-data/) in the logout handler: Java Kotlin XML @Bean public SecurityFilterChain filterChain(HttpSecurity http) { http .logout((logout) -> logout .addLogoutHandler(new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(COOKIES))) ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { logout { addLogoutHandler(HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter(COOKIES))) } } return http.build() } <http> <logout success-handler-ref=""clearSiteDataHandler"" /> <b:bean id=""clearSiteDataHandler"" class=""org.springframework.security.web.authentication.logout.HeaderWriterLogoutHandler""> <b:constructor-arg> <b:bean class=""org.springframework.security.web.header.writers.ClearSiteDataHeaderWriter""> <b:constructor-arg> <b:list> <b:value>COOKIES</b:value> </b:list> </b:constructor-arg> </b:bean> </b:constructor-arg> </b:bean> </http> This has the advantage of being container agnostic and will work with any container that supports the Clear-Site-Data header. As an alternative, you can also use the following syntax in the logout handler: Java Kotlin XML @Bean public SecurityFilterChain filterChain(HttpSecurity http) { http .logout(logout -> logout .deleteCookies(""JSESSIONID"") ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { logout { deleteCookies(""JSESSIONID"") } } return http.build() } <http> <logout delete-cookies=""JSESSIONID"" /> </http> Unfortunately, this cannot be guaranteed to work with every servlet container, so you need to test it in your environment. If you run your application behind a proxy, you may also be able to remove the session cookie by configuring the proxy server. For example, by using Apache HTTPD’s mod_headers , the following directive deletes the JSESSIONID cookie by expiring it in the response to a logout request (assuming the application is deployed under the /tutorial path): <LocationMatch ""/tutorial/logout""> Header always set Set-Cookie ""JSESSIONID=;Path=/tutorial;Expires=Thu, 01 Jan 1970 00:00:00 GMT"" </LocationMatch> More details on the Clear Site Data(../exploits/headers.html#servlet-headers-clear-site-data) and Logout sections(logout.html) . Understanding Session Fixation Attack Protection: Session fixation(https://en.wikipedia.org/wiki/Session_fixation) attacks are a potential risk where it is possible for a malicious attacker to create a session by accessing a site, then persuade another user to log in with the same session (by sending them a link containing the session identifier as a parameter, for example). Spring Security protects against this automatically by creating a new session or otherwise changing the session ID when a user logs in. Configuring Session Fixation Protection: You can control the strategy for Session Fixation Protection by choosing between three recommended options: changeSessionId - Do not create a new session. Instead, use the session fixation protection provided by the Servlet container ( HttpServletRequest#changeSessionId() ). This option is only available in Servlet 3.1 (Java EE 7) and newer containers. Specifying it in older containers will result in an exception. This is the default in Servlet 3.1 and newer containers. newSession - Create a new ""clean"" session, without copying the existing session data (Spring Security-related attributes will still be copied). migrateSession - Create a new session and copy all existing session attributes to the new session. This is the default in Servlet 3.0 or older containers. You can configure the session fixation protection by doing: Java Kotlin XML @Bean public SecurityFilterChain filterChain(HttpSecurity http) { http .sessionManagement((session) -> session .sessionFixation((sessionFixation) -> sessionFixation .newSession() ) ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { sessionManagement { sessionFixation { newSession() } } } return http.build() } <http> <session-management session-fixation-protection=""newSession"" /> </http> When session fixation protection occurs, it results in a SessionFixationProtectionEvent being published in the application context. If you use changeSessionId , this protection will also result in any jakarta.servlet.http.HttpSessionIdListener s being notified, so use caution if your code listens for both events. You can also set the session fixation protection to none to disable it, but this is not recommended as it leaves your application vulnerable. Using SecurityContextHolderStrategy: Consider the following block of code: Java UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken( loginRequest.getUsername(), loginRequest.getPassword()); Authentication authentication = this.authenticationManager.authenticate(token); // ... SecurityContext context = SecurityContextHolder.createEmptyContext(); (1) context.setAuthentication(authentication); (2) SecurityContextHolder.setContext(context); (3) Creates an empty SecurityContext instance by accessing the SecurityContextHolder statically. Sets the Authentication object in the SecurityContext instance. Sets the SecurityContext instance in the SecurityContextHolder statically. While the above code works fine, it can produce some undesired effects: when components access the SecurityContext statically through SecurityContextHolder , this can create race conditions when there are multiple application contexts that want to specify the SecurityContextHolderStrategy . This is because in SecurityContextHolder there is one strategy per classloader instead of one per application context. To address this, components can wire SecurityContextHolderStrategy from the application context. By default, they will still look up the strategy from SecurityContextHolder . These changes are largely internal, but they present the opportunity for applications to autowire the SecurityContextHolderStrategy instead of accessing the SecurityContext statically. To do so, you should change the code to the following: Java public class SomeClass { private final SecurityContextHolderStrategy securityContextHolderStrategy = SecurityContextHolder.getContextHolderStrategy(); public void someMethod() { UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated( loginRequest.getUsername(), loginRequest.getPassword()); Authentication authentication = this.authenticationManager.authenticate(token); // ... SecurityContext context = this.securityContextHolderStrategy.createEmptyContext(); (1) context.setAuthentication(authentication); (2) this.securityContextHolderStrategy.setContext(context); (3) } } Creates an empty SecurityContext instance using the configured SecurityContextHolderStrategy . Sets the Authentication object in the SecurityContext instance. Sets the SecurityContext instance in the SecurityContextHolderStrategy . Forcing Eager Session Creation: At times, it can be valuable to eagerly create sessions. This can be done by using the ForceEagerSessionCreationFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/session/ForceEagerSessionCreationFilter.html) which can be configured using: Java Kotlin XML @Bean public SecurityFilterChain filterChain(HttpSecurity http) { http .sessionManagement(session -> session .sessionCreationPolicy(SessionCreationPolicy.ALWAYS) ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { sessionManagement { sessionCreationPolicy = SessionCreationPolicy.ALWAYS } } return http.build() } <http create-session=""ALWAYS""> </http> What to read next: Clustered sessions with Spring Session(https://docs.spring.io/spring-session/reference/index.html) 1(#_footnoteref_1) . Authentication by mechanisms which perform a redirect after authenticating (such as form-login) will not be detected by SessionManagementFilter , as the filter will not be invoked during the authenticating request. Session-management functionality has to be handled separately in these cases."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/rememberme.html","Remember-Me Authentication: Remember-me or persistent-login authentication refers to web sites being able to remember the identity of a principal between sessions. This is typically accomplished by sending a cookie to the browser, with the cookie being detected during future sessions and causing automated login to take place. Spring Security provides the necessary hooks for these operations to take place and has two concrete remember-me implementations. One uses hashing to preserve the security of cookie-based tokens and the other uses a database or other persistent storage mechanism to store the generated tokens. Note that both implementations require a UserDetailsService . If you use an authentication provider that does not use a UserDetailsService (for example, the LDAP provider), it does not work unless you also have a UserDetailsService bean in your application context. Simple Hash-Based Token Approach: This approach uses hashing to achieve a useful remember-me strategy. In essence, a cookie is sent to the browser upon successful interactive authentication, with the cookie being composed as follows: base64(username + "":"" + expirationTime + "":"" + algorithmName + "":"" algorithmHex(username + "":"" + expirationTime + "":"" password + "":"" + key)) username: As identifiable to the UserDetailsService password: That matches the one in the retrieved UserDetails expirationTime: The date and time when the remember-me token expires, expressed in milliseconds key: A private key to prevent modification of the remember-me token algorithmName: The algorithm used to generate and to verify the remember-me token signature The remember-me token is valid only for the period specified and only if the username, password, and key do not change. Notably, this has a potential security issue, in that a captured remember-me token is usable from any user agent until such time as the token expires. This is the same issue as with digest authentication. If a principal is aware that a token has been captured, they can easily change their password and immediately invalidate all remember-me tokens on issue. If more significant security is needed, you should use the approach described in the next section. Alternatively, remember-me services should not be used at all. If you are familiar with the topics discussed in the chapter on namespace configuration(../configuration/xml-namespace.html#ns-config) , you can enable remember-me authentication by adding the <remember-me> element: <http> ... <remember-me key=""myAppKey""/> </http> The UserDetailsService is normally selected automatically. If you have more than one in your application context, you need to specify which one should be used with the user-service-ref attribute, where the value is the name of your UserDetailsService bean. Persistent Token Approach: This approach is based on the article Improved Persistent Login Cookie Best Practice(https://web.archive.org/web/20180819014446/http://jaspan.com/improved_persistent_login_cookie_best_practice) with some minor modifications [ 1(#_footnotedef_1) ] . To use this approach with namespace configuration, you would supply a datasource reference: <http> ... <remember-me data-source-ref=""someDataSource""/> </http> The database should contain a persistent_logins table, created by using the following SQL (or equivalent): create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null) Remember-Me Interfaces and Implementations: Remember-me is used with UsernamePasswordAuthenticationFilter and is implemented through hooks in the AbstractAuthenticationProcessingFilter superclass. It is also used within BasicAuthenticationFilter . The hooks invoke a concrete RememberMeServices at the appropriate times. The following listing shows the interface: Authentication autoLogin(HttpServletRequest request, HttpServletResponse response); void loginFail(HttpServletRequest request, HttpServletResponse response); void loginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication); See the Javadoc for RememberMeServices(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/RememberMeServices.html) for a fuller discussion on what the methods do, although note that, at this stage, AbstractAuthenticationProcessingFilter calls only the loginFail() and loginSuccess() methods. The autoLogin() method is called by RememberMeAuthenticationFilter whenever the SecurityContextHolder does not contain an Authentication . This interface, therefore, provides the underlying remember-me implementation with sufficient notification of authentication-related events and delegates to the implementation whenever a candidate web request might contain a cookie and wish to be remembered. This design allows any number of remember-me implementation strategies. We have seen earlier that Spring Security provides two implementations. We look at each of these in turn. TokenBasedRememberMeServices: This implementation supports the simpler approach described in Simple Hash-Based Token Approach(#remember-me-hash-token) . TokenBasedRememberMeServices generates a RememberMeAuthenticationToken , which is processed by RememberMeAuthenticationProvider . A key is shared between this authentication provider and the TokenBasedRememberMeServices . In addition, TokenBasedRememberMeServices requires a UserDetailsService , from which it can retrieve the username and password for signature comparison purposes and generate the RememberMeAuthenticationToken to contain the correct GrantedAuthority instances. TokenBasedRememberMeServices also implements Spring Security’s LogoutHandler interface so that it can be used with LogoutFilter to have the cookie cleared automatically. By default, this implementation uses the SHA-256 algorithm to encode the token signature. To verify the token signature, the algorithm retrieved from algorithmName is parsed and used. If no algorithmName is present, the default matching algorithm will be used, which is SHA-256. You can specify different algorithms for signature encoding and for signature matching, this allows users to safely upgrade to a different encoding algorithm while still able to verify old ones if there is no algorithmName present. To do that you can specify your customized TokenBasedRememberMeServices as a Bean and use it in the configuration. Java XML @Bean SecurityFilterChain securityFilterChain(HttpSecurity http, RememberMeServices rememberMeServices) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) .rememberMe((remember) -> remember .rememberMeServices(rememberMeServices) ); return http.build(); } @Bean RememberMeServices rememberMeServices(UserDetailsService userDetailsService) { RememberMeTokenAlgorithm encodingAlgorithm = RememberMeTokenAlgorithm.SHA256; TokenBasedRememberMeServices rememberMe = new TokenBasedRememberMeServices(myKey, userDetailsService, encodingAlgorithm); rememberMe.setMatchingAlgorithm(RememberMeTokenAlgorithm.MD5); return rememberMe; } <http> <remember-me services-ref=""rememberMeServices""/> </http> <bean id=""rememberMeServices"" class= ""org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices""> <property name=""userDetailsService"" ref=""myUserDetailsService""/> <property name=""key"" value=""springRocks""/> <property name=""matchingAlgorithm"" value=""MD5""/> <property name=""encodingAlgorithm"" value=""SHA256""/> </bean> The following beans are required in an application context to enable remember-me services: Java XML @Bean RememberMeAuthenticationFilter rememberMeFilter() { RememberMeAuthenticationFilter rememberMeFilter = new RememberMeAuthenticationFilter(); rememberMeFilter.setRememberMeServices(rememberMeServices()); rememberMeFilter.setAuthenticationManager(theAuthenticationManager); return rememberMeFilter; } @Bean TokenBasedRememberMeServices rememberMeServices() { TokenBasedRememberMeServices rememberMeServices = new TokenBasedRememberMeServices(); rememberMeServices.setUserDetailsService(myUserDetailsService); rememberMeServices.setKey(""springRocks""); return rememberMeServices; } @Bean RememberMeAuthenticationProvider rememberMeAuthenticationProvider() { RememberMeAuthenticationProvider rememberMeAuthenticationProvider = new RememberMeAuthenticationProvider(); rememberMeAuthenticationProvider.setKey(""springRocks""); return rememberMeAuthenticationProvider; } <bean id=""rememberMeFilter"" class= ""org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter""> <property name=""rememberMeServices"" ref=""rememberMeServices""/> <property name=""authenticationManager"" ref=""theAuthenticationManager"" /> </bean> <bean id=""rememberMeServices"" class= ""org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices""> <property name=""userDetailsService"" ref=""myUserDetailsService""/> <property name=""key"" value=""springRocks""/> </bean> <bean id=""rememberMeAuthenticationProvider"" class= ""org.springframework.security.authentication.RememberMeAuthenticationProvider""> <property name=""key"" value=""springRocks""/> </bean> Remember to add your RememberMeServices implementation to your UsernamePasswordAuthenticationFilter.setRememberMeServices() property, include the RememberMeAuthenticationProvider in your AuthenticationManager.setProviders() list, and add RememberMeAuthenticationFilter into your FilterChainProxy (typically immediately after your UsernamePasswordAuthenticationFilter ). PersistentTokenBasedRememberMeServices: You can use this class in the same way as TokenBasedRememberMeServices , but it additionally needs to be configured with a PersistentTokenRepository to store the tokens. InMemoryTokenRepositoryImpl which is intended for testing only. JdbcTokenRepositoryImpl which stores the tokens in a database. See Persistent Token Approach(#remember-me-persistent-token) for the database schema. 1(#_footnoteref_1) . Essentially, the username is not included in the cookie, to prevent exposing a valid login name unecessarily. There is a discussion on this in the comments section of this article."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/anonymous.html","Anonymous Authentication: Overview: It is generally considered good security practice to adopt a “deny-by-default” stance, where you explicitly specify what is allowed and disallow everything else. Defining what is accessible to unauthenticated users is a similar situation, particularly for web applications. Many sites require that users must be authenticated for anything other than a few URLs (for example the home and login pages). In that case, it is easiest to define access configuration attributes for these specific URLs rather than for every secured resource. Put differently, sometimes it is nice to say ROLE_SOMETHING is required by default and allow only certain exceptions to this rule, such as for login, logout, and home pages of an application. You could also omit these pages from the filter chain entirely, thus bypassing the access control checks, but this may be undesirable for other reasons, particularly if the pages behave differently for authenticated users. This is what we mean by anonymous authentication. Note that there is no real conceptual difference between a user who is “anonymously authenticated” and an unauthenticated user. Spring Security’s anonymous authentication just gives you a more convenient way to configure your access-control attributes. Calls to servlet API calls, such as getCallerPrincipal , still return null, even though there is actually an anonymous authentication object in the SecurityContextHolder . There are other situations where anonymous authentication is useful, such as when an auditing interceptor queries the SecurityContextHolder to identify which principal was responsible for a given operation. Classes can be authored more robustly if they know the SecurityContextHolder always contains an Authentication object and never contains null . Configuration: Anonymous authentication support is provided automatically when you use the HTTP configuration (introduced in Spring Security 3.0). You can customize (or disable) it by using the <anonymous> element. You need not configure the beans described here unless you are using traditional bean configuration. Three classes work together to provide the anonymous authentication feature. AnonymousAuthenticationToken is an implementation of Authentication and stores the GrantedAuthority instances that apply to the anonymous principal. There is a corresponding AnonymousAuthenticationProvider , which is chained into the ProviderManager so that AnonymousAuthenticationToken instances are accepted. Finally, an AnonymousAuthenticationFilter is chained after the normal authentication mechanisms and automatically adds an AnonymousAuthenticationToken to the SecurityContextHolder if there is no existing Authentication held there. The filter and authentication provider is defined as follows: <bean id=""anonymousAuthFilter"" class=""org.springframework.security.web.authentication.AnonymousAuthenticationFilter""> <property name=""key"" value=""foobar""/> <property name=""userAttribute"" value=""anonymousUser,ROLE_ANONYMOUS""/> </bean> <bean id=""anonymousAuthenticationProvider"" class=""org.springframework.security.authentication.AnonymousAuthenticationProvider""> <property name=""key"" value=""foobar""/> </bean> The key is shared between the filter and authentication provider, so that tokens created by the former are accepted by the latter The use of the key property should not be regarded as providing any real security here. It is merely a book-keeping exercise. If you share a ProviderManager that contains an AnonymousAuthenticationProvider in a scenario where it is possible for an authenticating client to construct the Authentication object (such as with RMI invocations), then a malicious client could submit an AnonymousAuthenticationToken that it had created itself (with the chosen username and authority list). If the key is guessable or can be found out, the token would be accepted by the anonymous provider. This is not a problem with normal usage. However, if you use RMI, you should use a customized ProviderManager that omits the anonymous provider rather than sharing the one you use for your HTTP authentication mechanisms. The userAttribute is expressed in the form of usernameInTheAuthenticationToken,grantedAuthority[,grantedAuthority] . The same syntax is used after the equals sign for the userMap property of InMemoryDaoImpl . As explained earlier, the benefit of anonymous authentication is that all URI patterns can have security applied to them, as the following example shows: <bean id=""filterSecurityInterceptor"" class=""org.springframework.security.web.access.intercept.FilterSecurityInterceptor""> <property name=""authenticationManager"" ref=""authenticationManager""/> <property name=""accessDecisionManager"" ref=""httpRequestAccessDecisionManager""/> <property name=""securityMetadata""> <security:filter-security-metadata-source> <security:intercept-url pattern='/index.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/> <security:intercept-url pattern='/hello.htm' access='ROLE_ANONYMOUS,ROLE_USER'/> <security:intercept-url pattern='/logoff.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/> <security:intercept-url pattern='/login.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/> <security:intercept-url pattern='/**' access='ROLE_USER'/> </security:filter-security-metadata-source>"" + </property> </bean> AuthenticationTrustResolver: Rounding out the anonymous authentication discussion is the AuthenticationTrustResolver interface, with its corresponding AuthenticationTrustResolverImpl implementation. This interface provides an isAnonymous(Authentication) method, which allows interested classes to take into account this special type of authentication status. The ExceptionTranslationFilter uses this interface in processing AccessDeniedException instances. If an AccessDeniedException is thrown and the authentication is of an anonymous type, instead of throwing a 403 (forbidden) response, the filter, instead, commences the AuthenticationEntryPoint so that the principal can authenticate properly. This is a necessary distinction. Otherwise, principals would always be deemed “authenticated” and never be given an opportunity to login through form, basic, digest, or some other normal authentication mechanism. We often see the ROLE_ANONYMOUS attribute in the earlier interceptor configuration replaced with IS_AUTHENTICATED_ANONYMOUSLY , which is effectively the same thing when defining access controls. This is an example of the use of the AuthenticatedVoter , which we cover in the authorization chapter(../authorization/architecture.html#authz-authenticated-voter) . It uses an AuthenticationTrustResolver to process this particular configuration attribute and grant access to anonymous users. The AuthenticatedVoter approach is more powerful, since it lets you differentiate between anonymous, remember-me, and fully authenticated users. If you do not need this functionality, though, you can stick with ROLE_ANONYMOUS , which is processed by Spring Security’s standard RoleVoter . Getting Anonymous Authentications with Spring MVC: Spring MVC resolves parameters of type Principal(https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments) using its own argument resolver. This means that a construct like this one: Java Kotlin @GetMapping(""/"") public String method(Authentication authentication) { if (authentication instanceof AnonymousAuthenticationToken) { return ""anonymous""; } else { return ""not anonymous""; } } @GetMapping(""/"") fun method(authentication: Authentication?): String { return if (authentication is AnonymousAuthenticationToken) { ""anonymous"" } else { ""not anonymous"" } } will always return ""not anonymous"", even for anonymous requests. The reason is that Spring MVC resolves the parameter using HttpServletRequest#getPrincipal , which is null when the request is anonymous. If you’d like to obtain the Authentication in anonymous requests, use @CurrentSecurityContext instead: Use CurrentSecurityContext for Anonymous requests Java Kotlin @GetMapping(""/"") public String method(@CurrentSecurityContext SecurityContext context) { return context.getAuthentication().getName(); } @GetMapping(""/"") fun method(@CurrentSecurityContext context : SecurityContext) : String = context!!.authentication!!.name"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/preauth.html","Pre-Authentication Scenarios: Examples include X.509, Siteminder, and authentication by the Java EE container in which the application runs. When using pre-authentication, Spring Security has to: Identify the user making the request. Obtain the authorities for the user. The details depend on the external authentication mechanism. A user might be identified by their certificate information in the case of X.509, or by an HTTP request header in the case of Siteminder. If relying on container authentication, the user is identified by calling the getUserPrincipal() method on the incoming HTTP request. In some cases, the external mechanism may supply role and authority information for the user. However, in other cases, you must obtain the authorities from a separate source, such as a UserDetailsService . Pre-Authentication Framework Classes: Because most pre-authentication mechanisms follow the same pattern, Spring Security has a set of classes that provide an internal framework for implementing pre-authenticated authentication providers. This removes duplication and lets new implementations be added in a structured fashion, without having to write everything from scratch. You need not know about these classes if you want to use something like X.509 authentication(x509.html#servlet-x509) , as it already has a namespace configuration option which is simpler to use and get started with. If you need to use explicit bean configuration or are planning on writing your own implementation, you need an understanding of how the provided implementations work. You can find the classes under the org.springframework.security.web.authentication.preauth . We provide only an outline here, so you should consult the Javadoc and source where appropriate. AbstractPreAuthenticatedProcessingFilter: This class checks the current contents of the security context and, if it is empty, tries to extract user information from the HTTP request and submit it to the AuthenticationManager . Subclasses override the following methods to obtain this information. Override AbstractPreAuthenticatedProcessingFilter Java Kotlin protected abstract Object getPreAuthenticatedPrincipal(HttpServletRequest request); protected abstract Object getPreAuthenticatedCredentials(HttpServletRequest request); protected abstract fun getPreAuthenticatedPrincipal(request: HttpServletRequest): Any? protected abstract fun getPreAuthenticatedCredentials(request: HttpServletRequest): Any? After calling these, the filter creates a PreAuthenticatedAuthenticationToken that contains the returned data and submits it for authentication. By “authentication” here, we really just mean further processing to perhaps load the user’s authorities, but the standard Spring Security authentication architecture is followed. As other Spring Security authentication filters, the pre-authentication filter has an authenticationDetailsSource property, which, by default, creates a WebAuthenticationDetails object to store additional information, such as the session identifier and the originating IP address in the details property of the Authentication object. In cases where user role information can be obtained from the pre-authentication mechanism, the data is also stored in this property, with the details implementing the GrantedAuthoritiesContainer interface. This enables the authentication provider to read the authorities which were externally allocated to the user. We look at a concrete example next. J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource: If the filter is configured with an authenticationDetailsSource , which is an instance of this class, the authority information is obtained by calling the isUserInRole(String role) method for each of a pre-determined set of “mappable roles”. The class gets these from a configured MappableAttributesRetriever . Possible implementations include hard-coding a list in the application context and reading the role information from the <security-role> information in a web.xml file. The pre-authentication sample application uses the latter approach. There is an additional stage where the roles (or attributes) are mapped to Spring Security GrantedAuthority objects by using a configured Attributes2GrantedAuthoritiesMapper . The default just adds the usual ROLE_ prefix to the names, but it gives you full control over the behavior. PreAuthenticatedAuthenticationProvider: The pre-authenticated provider has little more to do than load the UserDetails object for the user. It does this by delegating to an AuthenticationUserDetailsService . The latter is similar to the standard UserDetailsService but takes an Authentication object rather than just user name: public interface AuthenticationUserDetailsService { UserDetails loadUserDetails(Authentication token) throws UsernameNotFoundException; } This interface may also have other uses, but, with pre-authentication, it allows access to the authorities that were packaged in the Authentication object, as we saw in the previous section. The PreAuthenticatedGrantedAuthoritiesUserDetailsService class does this. Alternatively, it may delegate to a standard UserDetailsService through the UserDetailsByNameServiceWrapper implementation. Http403ForbiddenEntryPoint: The AuthenticationEntryPoint(architecture.html#servlet-authentication-authenticationentrypoint) is responsible for kick-starting the authentication process for an unauthenticated user (when they try to access a protected resource). However, in the pre-authenticated case, this does not apply. You would only configure the ExceptionTranslationFilter with an instance of this class if you do not use pre-authentication in combination with other authentication mechanisms. It is called if the user is rejected by the AbstractPreAuthenticatedProcessingFilter , resulting in a null authentication. It always returns a 403 -forbidden response code if called. Concrete Implementations: X.509 authentication is covered in its own chapter(x509.html#servlet-x509) . Here, we look at some classes which provide support for other pre-authenticated scenarios. Request-Header Authentication (Siteminder): An external authentication system may supply information to the application by setting specific headers on the HTTP request. A well-known example of this is Siteminder, which passes the username in a header called SM_USER . This mechanism is supported by the RequestHeaderAuthenticationFilter class, which only extracts the username from the header. It defaults to using a name of SM_USER as the header name. See the Javadoc for more details. When using a system like this, the framework performs no authentication checks at all, and it is extremely important that the external system is configured properly and protects all access to the application. If an attacker is able to forge the headers in their original request without this being detected, they could potentially choose any username they wished. Siteminder Example Configuration: The following example shows a typical configuration that uses this filter: <security:http> <!-- Additional http configuration omitted --> <security:custom-filter position=""PRE_AUTH_FILTER"" ref=""siteminderFilter"" /> </security:http> <bean id=""siteminderFilter"" class=""org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter""> <property name=""principalRequestHeader"" value=""SM_USER""/> <property name=""authenticationManager"" ref=""authenticationManager"" /> </bean> <bean id=""preauthAuthProvider"" class=""org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider""> <property name=""preAuthenticatedUserDetailsService""> <bean id=""userDetailsServiceWrapper"" class=""org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper""> <property name=""userDetailsService"" ref=""userDetailsService""/> </bean> </property> </bean> <security:authentication-manager alias=""authenticationManager""> <security:authentication-provider ref=""preauthAuthProvider"" /> </security:authentication-manager> We’ve assumed here that the security namespace(../configuration/xml-namespace.html#ns-config) is being used for configuration. It’s also assumed that you have added a UserDetailsService (called ""userDetailsService"") to your configuration to load the user’s roles. Java EE Container Authentication: The J2eePreAuthenticatedProcessingFilter class extracts the username from the userPrincipal property of the HttpServletRequest . Use of this filter would usually be combined with the use of Java EE roles, as described earlier in J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource(#j2ee-preauth-details) . There is a sample application(https://github.com/spring-projects/spring-security/tree/5.4.x/samples/xml/preauth) that uses this approach in the codebase, so get hold of the code from Github and have a look at the application context file if you are interested."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/jaas.html","Java Authentication and Authorization Service (JAAS) Provider: Spring Security provides a package to delegate authentication requests to the Java Authentication and Authorization Service (JAAS). This section discusses that package. AbstractJaasAuthenticationProvider: The AbstractJaasAuthenticationProvider class is the basis for the provided JAAS AuthenticationProvider implementations. Subclasses must implement a method that creates the LoginContext . The AbstractJaasAuthenticationProvider has a number of dependencies that can be injected into it, as discussed in the remainder of this section. JAAS CallbackHandler: Most JAAS LoginModule instances require a callback of some sort. These callbacks are usually used to obtain the username and password from the user. In a Spring Security deployment, Spring Security is responsible for this user interaction (through the authentication mechanism). Thus, by the time the authentication request is delegated through to JAAS, Spring Security’s authentication mechanism has already fully populated an Authentication object that contains all the information required by the JAAS LoginModule . Therefore, the JAAS package for Spring Security provides two default callback handlers: JaasNameCallbackHandler and JaasPasswordCallbackHandler . Each of these callback handlers implements JaasAuthenticationCallbackHandler . In most cases, these callback handlers can be used without understanding the internal mechanics. For those needing full control over the callback behavior, AbstractJaasAuthenticationProvider internally wraps these JaasAuthenticationCallbackHandler instances with an InternalCallbackHandler . The InternalCallbackHandler is the class that actually implements the JAAS normal CallbackHandler interface. Any time that the JAAS LoginModule is used, it is passed a list of application contexts configured InternalCallbackHandler instances. If the LoginModule requests a callback against the InternalCallbackHandler instances, the callback is, in turn, passed to the JaasAuthenticationCallbackHandler instances being wrapped. JAAS AuthorityGranter: JAAS works with principals. Even “roles” are represented as principals in JAAS. Spring Security, on the other hand, works with Authentication objects. Each Authentication object contains a single principal and multiple GrantedAuthority instances. To facilitate mapping between these different concepts, Spring Security’s JAAS package includes an AuthorityGranter interface. An AuthorityGranter is responsible for inspecting a JAAS principal and returning a set of String objects that represent the authorities assigned to the principal. For each returned authority string, the AbstractJaasAuthenticationProvider creates a JaasGrantedAuthority (which implements Spring Security’s GrantedAuthority interface) that contains the authority string and the JAAS principal that the AuthorityGranter was passed. The AbstractJaasAuthenticationProvider obtains the JAAS principals by first successfully authenticating the user’s credentials by using the JAAS LoginModule and then accessing the LoginContext it returns. A call to LoginContext.getSubject().getPrincipals() is made, with each resulting principal passed to each AuthorityGranter defined against the AbstractJaasAuthenticationProvider.setAuthorityGranters(List) property. Spring Security does not include any production AuthorityGranter instances, given that every JAAS principal has an implementation-specific meaning. However, there is a TestAuthorityGranter in the unit tests that demonstrates a simple AuthorityGranter implementation. DefaultJaasAuthenticationProvider: The DefaultJaasAuthenticationProvider lets a JAAS Configuration object be injected into it as a dependency. It then creates a LoginContext by using the injected JAAS Configuration . This means that DefaultJaasAuthenticationProvider is not bound to any particular implementation of Configuration , as JaasAuthenticationProvider is. InMemoryConfiguration: To make it easy to inject a Configuration into DefaultJaasAuthenticationProvider , a default in-memory implementation named InMemoryConfiguration is provided. The implementation constructor accepts a Map where each key represents a login configuration name, and the value represents an Array of AppConfigurationEntry instances. InMemoryConfiguration also supports a default Array of AppConfigurationEntry objects that is used if no mapping is found within the provided Map . For details, see the Javadoc of InMemoryConfiguration(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authentication/jaas/memory/InMemoryConfiguration.html) . DefaultJaasAuthenticationProvider Example Configuration: While the Spring configuration for InMemoryConfiguration can be more verbose than the standard JAAS configuration files, using it in conjunction with DefaultJaasAuthenticationProvider is more flexible than JaasAuthenticationProvider , since it not dependent on the default Configuration implementation. The next example provides a configuration of DefaultJaasAuthenticationProvider that uses InMemoryConfiguration . Note that custom implementations of Configuration can easily be injected into DefaultJaasAuthenticationProvider as well. <bean id=""jaasAuthProvider"" class=""org.springframework.security.authentication.jaas.DefaultJaasAuthenticationProvider""> <property name=""configuration""> <bean class=""org.springframework.security.authentication.jaas.memory.InMemoryConfiguration""> <constructor-arg> <map> <!-- SPRINGSECURITY is the default loginContextName for AbstractJaasAuthenticationProvider --> <entry key=""SPRINGSECURITY""> <array> <bean class=""javax.security.auth.login.AppConfigurationEntry""> <constructor-arg value=""sample.SampleLoginModule"" /> <constructor-arg> <util:constant static-field= ""javax.security.auth.login.AppConfigurationEntry$LoginModuleControlFlag.REQUIRED""/> </constructor-arg> <constructor-arg> <map></map> </constructor-arg> </bean> </array> </entry> </map> </constructor-arg> </bean> </property> <property name=""authorityGranters""> <list> <!-- You will need to write your own implementation of AuthorityGranter --> <bean class=""org.springframework.security.authentication.jaas.TestAuthorityGranter""/> </list> </property> </bean> JaasAuthenticationProvider: The JaasAuthenticationProvider assumes that the default Configuration is an instance of ConfigFile(https://docs.oracle.com/javase/8/docs/jre/api/security/jaas/spec/com/sun/security/auth/login/ConfigFile.html) . This assumption is made in order to try to update the Configuration . The JaasAuthenticationProvider then uses the default Configuration to create the LoginContext . Assume that we have a JAAS login configuration file, /WEB-INF/login.conf , with the following contents: JAASTest { sample.SampleLoginModule required; }; Like all Spring Security beans, the JaasAuthenticationProvider is configured through the application context. The following definitions would correspond to the above JAAS login configuration file: <bean id=""jaasAuthenticationProvider"" class=""org.springframework.security.authentication.jaas.JaasAuthenticationProvider""> <property name=""loginConfig"" value=""/WEB-INF/login.conf""/> <property name=""loginContextName"" value=""JAASTest""/> <property name=""callbackHandlers""> <list> <bean class=""org.springframework.security.authentication.jaas.JaasNameCallbackHandler""/> <bean class=""org.springframework.security.authentication.jaas.JaasPasswordCallbackHandler""/> </list> </property> <property name=""authorityGranters""> <list> <bean class=""org.springframework.security.authentication.jaas.TestAuthorityGranter""/> </list> </property> </bean> Running as a Subject: If configured, the JaasApiIntegrationFilter tries to run as the Subject on the JaasAuthenticationToken . This means that the Subject can be accessed using: Subject subject = Subject.getSubject(AccessController.getContext()); You can configure this integration by using the jaas-api-provision(../appendix/namespace/http.html#nsa-http-jaas-api-provision) attribute. This feature is useful when integrating with legacy or external API’s that rely on the JAAS Subject being populated."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/cas.html","CAS Authentication: Overview: JA-SIG produces an enterprise-wide single sign on system known as CAS. Unlike other initiatives, JA-SIG’s Central Authentication Service is open source, widely used, simple to understand, platform independent, and supports proxy capabilities. Spring Security fully supports CAS, and provides an easy migration path from single-application deployments of Spring Security through to multiple-application deployments secured by an enterprise-wide CAS server. You can learn more about CAS at www.apereo.org(https://www.apereo.org) . You will also need to visit this site to download the CAS Server files. How CAS Works: Whilst the CAS web site contains documents that detail the architecture of CAS, we present the general overview again here within the context of Spring Security. Spring Security 3.x supports CAS 3. At the time of writing, the CAS server was at version 3.4. Somewhere in your enterprise you will need to setup a CAS server. The CAS server is simply a standard WAR file, so there isn’t anything difficult about setting up your server. Inside the WAR file you will customise the login and other single sign on pages displayed to users. When deploying a CAS 3.4 server, you will also need to specify an AuthenticationHandler in the deployerConfigContext.xml included with CAS. The AuthenticationHandler has a simple method that returns a boolean as to whether a given set of Credentials is valid. Your AuthenticationHandler implementation will need to link into some type of backend authentication repository, such as an LDAP server or database. CAS itself includes numerous AuthenticationHandler s out of the box to assist with this. When you download and deploy the server war file, it is set up to successfully authenticate users who enter a password matching their username, which is useful for testing. Apart from the CAS server itself, the other key players are of course the secure web applications deployed throughout your enterprise. These web applications are known as ""services"". There are three types of services. Those that authenticate service tickets, those that can obtain proxy tickets, and those that authenticate proxy tickets. Authenticating a proxy ticket differs because the list of proxies must be validated and often times a proxy ticket can be reused. Spring Security and CAS Interaction Sequence: The basic interaction between a web browser, CAS server and a Spring Security-secured service is as follows: The web user is browsing the service’s public pages. CAS or Spring Security is not involved. The user eventually requests a page that is either secure or one of the beans it uses is secure. Spring Security’s ExceptionTranslationFilter will detect the AccessDeniedException or AuthenticationException . Because the user’s Authentication object (or lack thereof) caused an AuthenticationException , the ExceptionTranslationFilter will call the configured AuthenticationEntryPoint . If using CAS, this will be the CasAuthenticationEntryPoint class. The CasAuthenticationEntryPoint will redirect the user’s browser to the CAS server. It will also indicate a service parameter, which is the callback URL for the Spring Security service (your application). For example, the URL to which the browser is redirected might be my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas(https://my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas) . After the user’s browser redirects to CAS, they will be prompted for their username and password. If the user presents a session cookie which indicates they’ve previously logged on, they will not be prompted to login again (there is an exception to this procedure, which we’ll cover later). CAS will use the PasswordHandler (or AuthenticationHandler if using CAS 3.0) discussed above to decide whether the username and password is valid. Upon successful login, CAS will redirect the user’s browser back to the original service. It will also include a ticket parameter, which is an opaque string representing the ""service ticket"". Continuing our earlier example, the URL the browser is redirected to might be server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ(https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ) . Back in the service web application, the CasAuthenticationFilter is always listening for requests to /login/cas (this is configurable, but we’ll use the defaults in this introduction). The processing filter will construct a UsernamePasswordAuthenticationToken representing the service ticket. The principal will be equal to CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER , whilst the credentials will be the service ticket opaque value. This authentication request will then be handed to the configured AuthenticationManager . The AuthenticationManager implementation will be the ProviderManager , which is in turn configured with the CasAuthenticationProvider . The CasAuthenticationProvider only responds to UsernamePasswordAuthenticationToken s containing the CAS-specific principal (such as CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER ) and CasAuthenticationToken s (discussed later). CasAuthenticationProvider will validate the service ticket using a TicketValidator implementation. This will typically be a Cas20ServiceTicketValidator which is one of the classes included in the CAS client library. In the event the application needs to validate proxy tickets, the Cas20ProxyTicketValidator is used. The TicketValidator makes an HTTPS request to the CAS server in order to validate the service ticket. It may also include a proxy callback URL, which is included in this example: my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&ticket=ST-0-ER94xMJmn6pha35CQRoZ&pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor(https://my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&ticket=ST-0-ER94xMJmn6pha35CQRoZ&pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor) . Back on the CAS server, the validation request will be received. If the presented service ticket matches the service URL the ticket was issued to, CAS will provide an affirmative response in XML indicating the username. If any proxy was involved in the authentication (discussed below), the list of proxies is also included in the XML response. [OPTIONAL] If the request to the CAS validation service included the proxy callback URL (in the pgtUrl parameter), CAS will include a pgtIou string in the XML response. This pgtIou represents a proxy-granting ticket IOU. The CAS server will then create its own HTTPS connection back to the pgtUrl . This is to mutually authenticate the CAS server and the claimed service URL. The HTTPS connection will be used to send a proxy granting ticket to the original web application. For example, server3.company.com/webapp/login/cas/proxyreceptor?pgtIou=PGTIOU-0-R0zlgrl4pdAQwBvJWO3vnNpevwqStbSGcq3vKB2SqSFFRnjPHt&pgtId=PGT-1-si9YkkHLrtACBo64rmsi3v2nf7cpCResXg5MpESZFArbaZiOKH(https://server3.company.com/webapp/login/cas/proxyreceptor?pgtIou=PGTIOU-0-R0zlgrl4pdAQwBvJWO3vnNpevwqStbSGcq3vKB2SqSFFRnjPHt&pgtId=PGT-1-si9YkkHLrtACBo64rmsi3v2nf7cpCResXg5MpESZFArbaZiOKH) . The Cas20TicketValidator will parse the XML received from the CAS server. It will return to the CasAuthenticationProvider a TicketResponse , which includes the username (mandatory), proxy list (if any were involved), and proxy-granting ticket IOU (if the proxy callback was requested). Next CasAuthenticationProvider will call a configured CasProxyDecider . The CasProxyDecider indicates whether the proxy list in the TicketResponse is acceptable to the service. Several implementations are provided with Spring Security: RejectProxyTickets , AcceptAnyCasProxy and NamedCasProxyDecider . These names are largely self-explanatory, except NamedCasProxyDecider which allows a List of trusted proxies to be provided. CasAuthenticationProvider will next request a AuthenticationUserDetailsService to load the GrantedAuthority objects that apply to the user contained in the Assertion . If there were no problems, CasAuthenticationProvider constructs a CasAuthenticationToken including the details contained in the TicketResponse and the GrantedAuthority s. Control then returns to CasAuthenticationFilter , which places the created CasAuthenticationToken in the security context. The user’s browser is redirected to the original page that caused the AuthenticationException (or a custom destination depending on the configuration). It’s good that you’re still here! Let’s now look at how this is configured Configuration of CAS Client: The web application side of CAS is made easy due to Spring Security. It is assumed you already know the basics of using Spring Security, so these are not covered again below. We’ll assume a namespace based configuration is being used and add in the CAS beans as required. Each section builds upon the previous section. A full CAS sample application can be found in the Spring Security Samples(../../samples.html#samples) . Service Ticket Authentication: This section describes how to setup Spring Security to authenticate Service Tickets. Often times this is all a web application requires. You will need to add a ServiceProperties bean to your application context. This represents your CAS service: <bean id=""serviceProperties"" class=""org.springframework.security.cas.ServiceProperties""> <property name=""service"" value=""https://localhost:8443/cas-sample/login/cas""/> <property name=""sendRenew"" value=""false""/> </bean> The service must equal a URL that will be monitored by the CasAuthenticationFilter . The sendRenew defaults to false, but should be set to true if your application is particularly sensitive. What this parameter does is tell the CAS login service that a single sign on login is unacceptable. Instead, the user will need to re-enter their username and password in order to gain access to the service. The following beans should be configured to commence the CAS authentication process (assuming you’re using a namespace configuration): <security:http entry-point-ref=""casEntryPoint""> ... <security:custom-filter position=""CAS_FILTER"" ref=""casFilter"" /> </security:http> <bean id=""casFilter"" class=""org.springframework.security.cas.web.CasAuthenticationFilter""> <property name=""authenticationManager"" ref=""authenticationManager""/> </bean> <bean id=""casEntryPoint"" class=""org.springframework.security.cas.web.CasAuthenticationEntryPoint""> <property name=""loginUrl"" value=""https://localhost:9443/cas/login""/> <property name=""serviceProperties"" ref=""serviceProperties""/> </bean> For CAS to operate, the ExceptionTranslationFilter must have its authenticationEntryPoint property set to the CasAuthenticationEntryPoint bean. This can easily be done using entry-point-ref(../appendix/namespace/http.html#nsa-http-entry-point-ref) as is done in the example above. The CasAuthenticationEntryPoint must refer to the ServiceProperties bean (discussed above), which provides the URL to the enterprise’s CAS login server. This is where the user’s browser will be redirected. The CasAuthenticationFilter has very similar properties to the UsernamePasswordAuthenticationFilter (used for form-based logins). You can use these properties to customize things like behavior for authentication success and failure. Next you need to add a CasAuthenticationProvider and its collaborators: <security:authentication-manager alias=""authenticationManager""> <security:authentication-provider ref=""casAuthenticationProvider"" /> </security:authentication-manager> <bean id=""casAuthenticationProvider"" class=""org.springframework.security.cas.authentication.CasAuthenticationProvider""> <property name=""authenticationUserDetailsService""> <bean class=""org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper""> <constructor-arg ref=""userService"" /> </bean> </property> <property name=""serviceProperties"" ref=""serviceProperties"" /> <property name=""ticketValidator""> <bean class=""org.apereo.cas.client.validation.Cas20ServiceTicketValidator""> <constructor-arg index=""0"" value=""https://localhost:9443/cas"" /> </bean> </property> <property name=""key"" value=""an_id_for_this_auth_provider_only""/> </bean> <security:user-service id=""userService""> <!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that NoOpPasswordEncoder should be used. This is not safe for production, but makes reading in samples easier. Normally passwords should be hashed using BCrypt --> <security:user name=""joe"" password=""{noop}joe"" authorities=""ROLE_USER"" /> ... </security:user-service> The CasAuthenticationProvider uses a UserDetailsService instance to load the authorities for a user, once they have been authenticated by CAS. We’ve shown a simple in-memory setup here. Note that the CasAuthenticationProvider does not actually use the password for authentication, but it does use the authorities. The beans are all reasonably self-explanatory if you refer back to the How CAS Works(#cas-how-it-works) section. This completes the most basic configuration for CAS. If you haven’t made any mistakes, your web application should happily work within the framework of CAS single sign on. No other parts of Spring Security need to be concerned about the fact CAS handled authentication. In the following sections we will discuss some (optional) more advanced configurations. Single Logout: The CAS protocol supports Single Logout and can be easily added to your Spring Security configuration. Below are updates to the Spring Security configuration that handle Single Logout <security:http entry-point-ref=""casEntryPoint""> ... <security:logout logout-success-url=""/cas-logout.jsp""/> <security:custom-filter ref=""requestSingleLogoutFilter"" before=""LOGOUT_FILTER""/> <security:custom-filter ref=""singleLogoutFilter"" before=""CAS_FILTER""/> </security:http> <!-- This filter handles a Single Logout Request from the CAS Server --> <bean id=""singleLogoutFilter"" class=""org.apereo.cas.client.session.SingleSignOutFilter""/> <!-- This filter redirects to the CAS Server to signal Single Logout should be performed --> <bean id=""requestSingleLogoutFilter"" class=""org.springframework.security.web.authentication.logout.LogoutFilter""> <constructor-arg value=""https://localhost:9443/cas/logout""/> <constructor-arg> <bean class= ""org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler""/> </constructor-arg> <property name=""filterProcessesUrl"" value=""/logout/cas""/> </bean> The logout element logs the user out of the local application, but does not end the session with the CAS server or any other applications that have been logged into. The requestSingleLogoutFilter filter will allow the URL of /spring_security_cas_logout to be requested to redirect the application to the configured CAS Server logout URL. Then the CAS Server will send a Single Logout request to all the services that were signed into. The singleLogoutFilter handles the Single Logout request by looking up the HttpSession in a static Map and then invalidating it. It might be confusing why both the logout element and the singleLogoutFilter are needed. It is considered best practice to logout locally first since the SingleSignOutFilter just stores the HttpSession in a static Map in order to call invalidate on it. With the configuration above, the flow of logout would be: The user requests /logout which would log the user out of the local application and send the user to the logout success page. The logout success page, /cas-logout.jsp , should instruct the user to click a link pointing to /logout/cas in order to logout out of all applications. When the user clicks the link, the user is redirected to the CAS single logout URL ( localhost:9443/cas/logout(https://localhost:9443/cas/logout) ). On the CAS Server side, the CAS single logout URL then submits single logout requests to all the CAS Services. On the CAS Service side, Apereo’s SingleSignOutFilter processes the logout request by invalidating the original session. The next step is to add the following to your web.xml <filter> <filter-name>characterEncodingFilter</filter-name> <filter-class> org.springframework.web.filter.CharacterEncodingFilter </filter-class> <init-param> <param-name>encoding</param-name> <param-value>UTF-8</param-value> </init-param> </filter> <filter-mapping> <filter-name>characterEncodingFilter</filter-name> <url-pattern>/*</url-pattern> </filter-mapping> <listener> <listener-class> org.apereo.cas.client.session.SingleSignOutHttpSessionListener </listener-class> </listener> When using the SingleSignOutFilter you might encounter some encoding issues. Therefore it is recommended to add the CharacterEncodingFilter to ensure that the character encoding is correct when using the SingleSignOutFilter . Again, refer to Apereo CAS’s documentation for details. The SingleSignOutHttpSessionListener ensures that when an HttpSession expires, the mapping used for single logout is removed. Authenticating to a Stateless Service with CAS: This section describes how to authenticate to a service using CAS. In other words, this section discusses how to setup a client that uses a service that authenticates with CAS. The next section describes how to setup a stateless service to Authenticate using CAS. Configuring CAS to Obtain Proxy Granting Tickets: In order to authenticate to a stateless service, the application needs to obtain a proxy granting ticket (PGT). This section describes how to configure Spring Security to obtain a PGT building upon thencas-st[Service Ticket Authentication] configuration. The first step is to include a ProxyGrantingTicketStorage in your Spring Security configuration. This is used to store PGT’s that are obtained by the CasAuthenticationFilter so that they can be used to obtain proxy tickets. An example configuration is shown below <!-- NOTE: In a real application you should not use an in memory implementation. You will also want to ensure to clean up expired tickets by calling ProxyGrantingTicketStorage.cleanup() --> <bean id=""pgtStorage"" class=""org.apereo.cas.client.proxy.ProxyGrantingTicketStorageImpl""/> The next step is to update the CasAuthenticationProvider to be able to obtain proxy tickets. To do this replace the Cas20ServiceTicketValidator with a Cas20ProxyTicketValidator . The proxyCallbackUrl should be set to a URL that the application will receive PGT’s at. Last, the configuration should also reference the ProxyGrantingTicketStorage so it can use a PGT to obtain proxy tickets. You can find an example of the configuration changes that should be made below. <bean id=""casAuthenticationProvider"" class=""org.springframework.security.cas.authentication.CasAuthenticationProvider""> ... <property name=""ticketValidator""> <bean class=""org.apereo.cas.client.validation.Cas20ProxyTicketValidator""> <constructor-arg value=""https://localhost:9443/cas""/> <property name=""proxyCallbackUrl"" value=""https://localhost:8443/cas-sample/login/cas/proxyreceptor""/> <property name=""proxyGrantingTicketStorage"" ref=""pgtStorage""/> </bean> </property> </bean> The last step is to update the CasAuthenticationFilter to accept PGT and to store them in the ProxyGrantingTicketStorage . It is important the proxyReceptorUrl matches the proxyCallbackUrl of the Cas20ProxyTicketValidator . An example configuration is shown below. <bean id=""casFilter"" class=""org.springframework.security.cas.web.CasAuthenticationFilter""> ... <property name=""proxyGrantingTicketStorage"" ref=""pgtStorage""/> <property name=""proxyReceptorUrl"" value=""/login/cas/proxyreceptor""/> </bean> Calling a Stateless Service Using a Proxy Ticket: Now that Spring Security obtains PGTs, you can use them to create proxy tickets which can be used to authenticate to a stateless service. The CAS sample application(../../samples.html#samples) contains a working example in the ProxyTicketSampleServlet . Example code can be found below: Java Kotlin protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // NOTE: The CasAuthenticationToken can also be obtained using // SecurityContextHolder.getContext().getAuthentication() final CasAuthenticationToken token = (CasAuthenticationToken) request.getUserPrincipal(); // proxyTicket could be reused to make calls to the CAS service even if the // target url differs final String proxyTicket = token.getAssertion().getPrincipal().getProxyTicketFor(targetUrl); // Make a remote call using the proxy ticket final String serviceUrl = targetUrl+""?ticket=""+URLEncoder.encode(proxyTicket, ""UTF-8""); String proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, ""UTF-8""); ... } protected fun doGet(request: HttpServletRequest, response: HttpServletResponse?) { // NOTE: The CasAuthenticationToken can also be obtained using // SecurityContextHolder.getContext().getAuthentication() val token = request.userPrincipal as CasAuthenticationToken // proxyTicket could be reused to make calls to the CAS service even if the // target url differs val proxyTicket = token.assertion.principal.getProxyTicketFor(targetUrl) // Make a remote call using the proxy ticket val serviceUrl: String = targetUrl + ""?ticket="" + URLEncoder.encode(proxyTicket, ""UTF-8"") val proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, ""UTF-8"") } Proxy Ticket Authentication: The CasAuthenticationProvider distinguishes between stateful and stateless clients. A stateful client is considered any that submits to the filterProcessesUrl of the CasAuthenticationFilter . A stateless client is any that presents an authentication request to CasAuthenticationFilter on a URL other than the filterProcessesUrl . Because remoting protocols have no way of presenting themselves within the context of an HttpSession , it isn’t possible to rely on the default practice of storing the security context in the session between requests. Furthermore, because the CAS server invalidates a ticket after it has been validated by the TicketValidator , presenting the same proxy ticket on subsequent requests will not work. One obvious option is to not use CAS at all for remoting protocol clients. However, this would eliminate many of the desirable features of CAS. As a middle-ground, the CasAuthenticationProvider uses a StatelessTicketCache . This is used solely for stateless clients which use a principal equal to CasAuthenticationFilter.CAS_STATELESS_IDENTIFIER . What happens is the CasAuthenticationProvider will store the resulting CasAuthenticationToken in the StatelessTicketCache , keyed on the proxy ticket. Accordingly, remoting protocol clients can present the same proxy ticket and the CasAuthenticationProvider will not need to contact the CAS server for validation (aside from the first request). Once authenticated, the proxy ticket could be used for URLs other than the original target service. This section builds upon the previous sections to accommodate proxy ticket authentication. The first step is to specify to authenticate all artifacts as shown below. <bean id=""serviceProperties"" class=""org.springframework.security.cas.ServiceProperties""> ... <property name=""authenticateAllArtifacts"" value=""true""/> </bean> The next step is to specify serviceProperties and the authenticationDetailsSource for the CasAuthenticationFilter . The serviceProperties property instructs the CasAuthenticationFilter to attempt to authenticate all artifacts instead of only ones present on the filterProcessesUrl . The ServiceAuthenticationDetailsSource creates a ServiceAuthenticationDetails that ensures the current URL, based upon the HttpServletRequest , is used as the service URL when validating the ticket. The method for generating the service URL can be customized by injecting a custom AuthenticationDetailsSource that returns a custom ServiceAuthenticationDetails . <bean id=""casFilter"" class=""org.springframework.security.cas.web.CasAuthenticationFilter""> ... <property name=""serviceProperties"" ref=""serviceProperties""/> <property name=""authenticationDetailsSource""> <bean class= ""org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource""> <constructor-arg ref=""serviceProperties""/> </bean> </property> </bean> You will also need to update the CasAuthenticationProvider to handle proxy tickets. To do this replace the Cas20ServiceTicketValidator with a Cas20ProxyTicketValidator . You will need to configure the statelessTicketCache and which proxies you want to accept. You can find an example of the updates required to accept all proxies below. <bean id=""casAuthenticationProvider"" class=""org.springframework.security.cas.authentication.CasAuthenticationProvider""> ... <property name=""ticketValidator""> <bean class=""org.apereo.cas.client.validation.Cas20ProxyTicketValidator""> <constructor-arg value=""https://localhost:9443/cas""/> <property name=""acceptAnyProxy"" value=""true""/> </bean> </property> <property name=""statelessTicketCache""> <bean class=""org.springframework.security.cas.authentication.EhCacheBasedTicketCache""> <property name=""cache""> <bean class=""net.sf.ehcache.Cache"" init-method=""initialise"" destroy-method=""dispose""> <constructor-arg value=""casTickets""/> <constructor-arg value=""50""/> <constructor-arg value=""true""/> <constructor-arg value=""false""/> <constructor-arg value=""3600""/> <constructor-arg value=""900""/> </bean> </property> </bean> </property> </bean>"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/x509.html","X.509 Authentication: The most common use of X.509 certificate authentication is in verifying the identity of a server when using SSL, most commonly when using HTTPS from a browser. The browser automatically checks that the certificate presented by a server has been issued (digitally signed) by one of a list of trusted certificate authorities that it maintains. You can also use SSL with “mutual authentication”. The server then requests a valid certificate from the client as part of the SSL handshake. The server authenticates the client by checking that its certificate is signed by an acceptable authority. If a valid certificate has been provided, it can be obtained through the servlet API in an application. The Spring Security X.509 module extracts the certificate by using a filter. It maps the certificate to an application user and loads that user’s set of granted authorities for use with the standard Spring Security infrastructure. You can also use SSL with “mutual authentication”. The server then requests a valid certificate from the client as part of the SSL handshake. The server authenticates the client by checking that its certificate is signed by an acceptable authority. For example, if you use Tomcat, you should read the Tomcat SSL instructions(https://tomcat.apache.org/tomcat-10.1-doc/ssl-howto.html) . You should get this working before trying it out with Spring Security. Adding X.509 Authentication to Your Web Application: Enabling X.509 client authentication is very straightforward. To do so, add the <x509/> element to your http security namespace configuration: <http> ... <x509 subject-principal-regex=""CN=(.*?),"" user-service-ref=""userService""/>; </http> The element has two optional attributes: subject-principal-regex . The regular expression used to extract a username from the certificate’s subject name. The default value is shown in the preceding listing. This is the username that is passed to the UserDetailsService to load the authorities for the user. user-service-ref . This is the bean ID of the UserDetailsService to be used with X.509. It is not needed if there is only one defined in your application context. The subject-principal-regex should contain a single group. For example, the default expression ( CN=(.*?) ) matches the common name field. So, if the subject name in the certificate is ""CN=Jimi Hendrix, OU=…​"", this gives a user name of ""Jimi Hendrix"". The matches are case insensitive. So ""emailAddress=(.*?),"" matches ""EMAILADDRESS= [email protected](/cdn-cgi/l/email-protection#e78d8e8a8ea78f828983958e9fc9889580) ,CN=…​"", giving a user name "" [email protected](/cdn-cgi/l/email-protection#e18b888c88a189848f85938899cf8e9386) "". If the client presents a certificate and a valid username is successfully extracted, there should be a valid Authentication object in the security context. If no certificate is found or no corresponding user could be found, the security context remains empty. This means that you can use X.509 authentication with other options, such as a form-based login. Setting up SSL in Tomcat: There are some pre-generated certificates in the Spring Security Samples repository(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/java-configuration/authentication/x509/server) . You can use these to enable SSL for testing if you do not want to generate your own. The server.jks file contains the server certificate, the private key, and the issuing authority certificate. There are also some client certificate files for the users from the sample applications. You can install these in your browser to enable SSL client authentication. To run tomcat with SSL support, drop the server.jks file into the tomcat conf directory and add the following connector to the server.xml file: <Connector port=""8443"" protocol=""HTTP/1.1"" SSLEnabled=""true"" scheme=""https"" secure=""true"" clientAuth=""true"" sslProtocol=""TLS"" keystoreFile=""${catalina.home}/conf/server.jks"" keystoreType=""JKS"" keystorePass=""password"" truststoreFile=""${catalina.home}/conf/server.jks"" truststoreType=""JKS"" truststorePass=""password"" /> clientAuth can also be set to want if you still want SSL connections to succeed even if the client does not provide a certificate. Clients that do not present a certificate cannot access any objects secured by Spring Security unless you use a non-X.509 authentication mechanism, such as form authentication."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/runas.html","Run-As Authentication Replacement: The AbstractSecurityInterceptor is able to temporarily replace the Authentication object in the SecurityContext and SecurityContextHolder during the secure object callback phase. This only occurs if the original Authentication object was successfully processed by the AuthenticationManager and AccessDecisionManager . The RunAsManager indicates the replacement Authentication object, if any, that should be used during the SecurityInterceptorCallback . By temporarily replacing the Authentication object during the secure object callback phase, the secured invocation can call other objects that require different authentication and authorization credentials. It can also perform any internal security checks for specific GrantedAuthority objects. Because Spring Security provides a number of helper classes that automatically configure remoting protocols based on the contents of the SecurityContextHolder , these run-as replacements are particularly useful when calling remote web services. Configuration: Spring Security provices a RunAsManager interface: Authentication buildRunAs(Authentication authentication, Object object, List<ConfigAttribute> config); boolean supports(ConfigAttribute attribute); boolean supports(Class clazz); The first method returns the Authentication object that should replace the existing Authentication object for the duration of the method invocation. If the method returns null , it indicates no replacement should be made. The second method is used by the AbstractSecurityInterceptor as part of its startup validation of configuration attributes. The supports(Class) method is called by a security interceptor implementation to ensure that the configured RunAsManager supports the type of secure object that the security interceptor presents. Spring Security provides one concrete implementation of RunAsManager . The RunAsManagerImpl class returns a replacement RunAsUserToken if any ConfigAttribute starts with RUN_AS_ . If any such ConfigAttribute is found, the replacement RunAsUserToken contains the same principal, credentials, and granted authorities as the original Authentication object, along with a new SimpleGrantedAuthority for each RUN_AS_ ConfigAttribute . Each new SimpleGrantedAuthority is prefixed with ROLE_ , followed by the RUN_AS ConfigAttribute . For example, a RUN_AS_SERVER results in the replacement RunAsUserToken containing a ROLE_RUN_AS_SERVER granted authority. The replacement RunAsUserToken is like any other Authentication object. It needs to be authenticated by the AuthenticationManager , probably through delegation to a suitable AuthenticationProvider . The RunAsImplAuthenticationProvider performs such authentication. It accepts as valid any RunAsUserToken presented. To ensure malicious code does not create a RunAsUserToken and present it for guaranteed acceptance by the RunAsImplAuthenticationProvider , the hash of a key is stored in all generated tokens. The RunAsManagerImpl and RunAsImplAuthenticationProvider is created in the bean context with the same key: <bean id=""runAsManager"" class=""org.springframework.security.access.intercept.RunAsManagerImpl""> <property name=""key"" value=""my_run_as_password""/> </bean> <bean id=""runAsAuthenticationProvider"" class=""org.springframework.security.access.intercept.RunAsImplAuthenticationProvider""> <property name=""key"" value=""my_run_as_password""/> </bean> By using the same key, each RunAsUserToken can be validated because it was created by an approved RunAsManagerImpl . The RunAsUserToken is immutable after creation, for security reasons."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/logout.html","Handling Logouts: In an application where end users can login(index.html) , they should also be able to logout. By default, Spring Security stands up a /logout endpoint, so no additional code is necessary. The rest of this section covers a number of use cases for you to consider: I want to understand logout’s architecture(#logout-java-configuration) I want to customize the logout or logout success URI(#customizing-logout-uris) I want to know when I need to explicitly permit the /logout endpoint(#permit-logout-endpoints) I want to clear cookies, storage, and/or cache(#clear-all-site-data) when the user logs out I am using OAuth 2.0 and I want to coordinate logout with an Authorization Server(../oauth2/login/advanced.html#oauth2login-advanced-oidc-logout) I am using SAML 2.0 and I want to coordinate logout with an Identity Provider(../saml2/logout.html) I am using CAS and I want to coordinate logout with an Identity Provider(cas.html#cas-singlelogout) Understanding Logout’s Architecture: When you include the spring-boot-starter-security dependency(https://docs.spring.io/spring-boot/docs/3.1.1/reference/html/using.html#using.build-systems.starters) or use the @EnableWebSecurity annotation, Spring Security will add its logout support and by default respond both to GET /logout and POST /logout . If you request GET /logout , then Spring Security displays a logout confirmation page. Aside from providing a valuable double-checking mechanism for the user, it also provides a simple way to provide the needed CSRF token(../exploits/csrf.html) to POST /logout . Please note that if CSRF protection(../exploits/csrf.html) is disabled in configuration, no logout confirmation page is shown to the user and the logout is performed directly. In your application it is not necessary to use GET /logout to perform a logout. So long as the needed CSRF token(../exploits/csrf.html) is present in the request, your application can simply POST /logout to induce a logout. If you request POST /logout , then it will perform the following default operations using a series of LogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/logout/LogoutHandler.html) s: Invalidate the HTTP session ( SecurityContextLogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html) ) Clear the SecurityContextHolderStrategy(session-management.html#use-securitycontextholderstrategy) ( SecurityContextLogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html) ) Clear the SecurityContextRepository(persistence.html#securitycontextrepository) ( SecurityContextLogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html) ) Clean up any RememberMe authentication(rememberme.html) ( TokenRememberMeServices / PersistentTokenRememberMeServices ) Clear out any saved CSRF token(../exploits/csrf.html) ( CsrfLogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/csrf/CsrfLogoutHandler.html) ) Fire(events.html) a LogoutSuccessEvent ( LogoutSuccessEventPublishingLogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/logout/LogoutSuccessEventPublishingLogoutHandler.html) ) Once completed, then it will exercise its default LogoutSuccessHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html) which redirects to /login?logout . Customizing Logout URIs: Since the LogoutFilter appears before the AuthorizationFilter(../authorization/authorize-http-requests.html) in the filter chain(../architecture.html#servlet-filterchain-figure) , it is not necessary by default to explicitly permit the /logout endpoint. Thus, only custom logout endpoints(#permit-logout-endpoints) that you create yourself generally require a permitAll configuration to be reachable. For example, if you want to simply change the URI that Spring Security is matching, you can do so in the logout DSL in following way: Custom Logout Uri Java Kotlin Xml http .logout((logout) -> logout.logoutUrl(""/my/logout/uri"")) http { logout { logoutUrl = ""/my/logout/uri"" } } <logout logout-url=""/my/logout/uri""/> and no authorization changes are necessary since it simply adjusts the LogoutFilter . However, if you stand up your own logout success endpoint (or in a rare case, your own logout endpoint(#creating-custom-logout-endpoint) ), say using Spring MVC(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html/web.html#spring-web) , you will need to permit it in Spring Security. This is because Spring MVC processes your request after Spring Security does. You can do this using authorizeHttpRequests or <intercept-url> like so: Custom Logout Endpoint Java Kotlin Xml http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(""/my/success/endpoint"").permitAll() // ... ) .logout((logout) -> logout.logoutSuccessUrl(""/my/success/endpoint"")) http { authorizeHttpRequests { authorize(""/my/success/endpoint"", permitAll) } logout { logoutSuccessUrl = ""/my/success/endpoint"" } } <http> <filter-url pattern=""/my/success/endpoint"" access=""permitAll""/> <logout logout-success-url=""/my/success/endpoint""/> </http> In this example, you tell the LogoutFilter to redirect to /my/success/endpoint when it is done. And, you explicitly permit the /my/success/endpoint endpoint in the AuthorizationFilter(../authorization/authorize-http-requests.html) . Specifying it twice can be cumbersome, though. If you are using Java configuration, you can instead set the permitAll property in the logout DSL like so: Permitting Custom Logout Endpoints Java Kotlin http .authorizeHttpRequests((authorize) -> authorize // ... ) .logout((logout) -> logout .logoutSuccessUrl(""/my/success/endpoint"") .permitAll() ) http authorizeHttpRequests { // ... } logout { logoutSuccessUrl = ""/my/success/endpoint"" permitAll = true } which will add all logout URIs to the permit list for you. Adding Clean-up Actions: If you are using Java configuration, you can add clean up actions of your own by calling the addLogoutHandler method in the logout DSL, like so: Custom Logout Handler Java Kotlin CookieClearingLogoutHandler cookies = new CookieClearingLogoutHandler(""our-custom-cookie""); http .logout((logout) -> logout.addLogoutHandler(cookies)) http { logout { addLogoutHandler(CookieClearingLogoutHandler(""our-custom-cookie"")) } } Because LogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/logout/LogoutHandler.html) s are for the purposes of cleanup, they should not throw exceptions. Since LogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/logout/LogoutHandler.html) is a functional interface, you can provide a custom one as a lambda. Some logout handler configurations are common enough that they are exposed directly in the logout DSL and <logout> element. One example is configuring session invalidation and another is which additional cookies should be deleted. For example, you can configure the CookieClearingLogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/logout/CookieClearingLogoutHandler.html) as seen above. Or you can instead set the appropriate configuration value like so: Java Kotlin Xml http .logout((logout) -> logout.deleteCookies(""our-custom-cookie"")) http { logout { deleteCookies = ""our-custom-cookie"" } } <http> <logout delete-cookies=""our-custom-cookie""/> </http> Specifying that the JSESSIONID cookie is not necessary since SecurityContextLogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api//org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html) removes it by virtue of invalidating the session. Using Clear-Site-Data to Log Out the User: The Clear-Site-Data HTTP header is one that browsers support as an instruction to clear cookies, storage, and cache that belong to the owning website. This is a handy and secure way to ensure that everything, including the session cookie, is cleaned up on logout. You can add configure Spring Security to write the Clear-Site-Data header on logout like so: Using Clear-Site-Data Java Kotlin HeaderWriterLogoutHandler clearSiteData = new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter()); http .logout((logout) -> logout.addLogoutHandler(clearSiteData)) val clearSiteData = HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter()) http { logout { addLogoutHandler(clearSiteData) } } You give the ClearSiteDataHeaderWriter constructor the list of things that you want to be cleared out. The above configuration clears out all site data, but you can also configure it to remove just cookies like so: Using Clear-Site-Data to Clear Cookies Java Kotlin HeaderWriterLogoutHandler clearSiteData = new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(Directive.COOKIES)); http .logout((logout) -> logout.addLogoutHandler(clearSiteData)) val clearSiteData = HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter(Directive.COOKIES)) http { logout { addLogoutHandler(clearSiteData) } } Customizing Logout Success: While using logoutSuccessUrl will suffice for most cases, you may need to do something different from redirecting to a URL once logout is complete. LogoutSuccessHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html) is the Spring Security component for customizing logout success actions. For example, instead of redirecting, you may want to only return a status code. In this case, you can provide a success handler instance, like so: Using Clear-Site-Data to Clear Cookies Java Kotlin Xml http .logout((logout) -> logout.logoutSuccessHandler(new HttpStatusReturningLogoutSuccessHandler())) http { logout { logoutSuccessHandler = HttpStatusReturningLogoutSuccessHandler() } } <bean name=""mySuccessHandlerBean"" class=""org.springframework.security.web.authentication.logout.HttpStatusReturningLogoutSuccessHandler""/> <http> <logout success-handler-ref=""mySuccessHandlerBean""/> </http> Since LogoutSuccessHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html) is a functional interface, you can provide a custom one as a lambda. Creating a Custom Logout Endpoint: It is strongly recommended that you use the provided logout DSL to configure logout. One reason is that its easy to forget to call the needed Spring Security components to ensure a proper and complete logout. In fact, it is often simpler to register a custom LogoutHandler(#add-logout-handler) than create a Spring MVC(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html/web.html#spring-web) endpoint for performing logout. That said, if you find yourself in a circumstance where a custom logout endpoint is needed, like the following one: Custom Logout Endpoint Java Kotlin @PostMapping(""/my/logout"") public String performLogout() { // .. perform logout return ""redirect:/home""; } @PostMapping(""/my/logout"") fun performLogout(): String { // .. perform logout return ""redirect:/home"" } then you will need to have that endpoint invoke Spring Security’s SecurityContextLogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api//org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html) to ensure a secure and complete logout. Something like the following is needed at a minimum: Custom Logout Endpoint Java Kotlin SecurityContextLogoutHandler logoutHandler = new SecurityContextLogoutHandler(); @PostMapping(""/my/logout"") public String performLogout(Authentication authentication, HttpServletRequest request, HttpServletResponse response) { // .. perform logout this.logoutHandler.doLogout(request, response, authentication); return ""redirect:/home""; } val logoutHandler = SecurityContextLogoutHandler() @PostMapping(""/my/logout"") fun performLogout(val authentication: Authentication, val request: HttpServletRequest, val response: HttpServletResponse): String { // .. perform logout this.logoutHandler.doLogout(request, response, authentication) return ""redirect:/home"" } Such will clear out the SecurityContextHolderStrategy(https://docs.spring.io/spring-security/site/docs/6.3.3/api//org/springframework/security/core/context/SecurityContextHolderStrategy.html) and SecurityContextRepository(https://docs.spring.io/spring-security/site/docs/6.3.3/api//org/springframework/security/web/context/SecurityContextRepository.html) as needed. Also, you’ll need to explicitly permit the endpoint(#permit-logout-endpoints) . Failing to call SecurityContextLogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api//org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html) means that the SecurityContext(architecture.html#servlet-authentication-securitycontext) could still be available on subsequent requests, meaning that the user is not actually logged out. Testing Logout: Once you have logout configured you can test it using Spring Security’s MockMvc support(../test/mockmvc/logout.html) . Further Logout-Related References: Testing Logout(../test/mockmvc/logout.html#test-logout) HttpServletRequest.logout()(../integrations/servlet-api.html#servletapi-logout) Remember-Me Interfaces and Implementations(rememberme.html#remember-me-impls) Logging Out(../exploits/csrf.html#csrf-considerations-logout) in section CSRF Caveats Section Single Logout(cas.html#cas-singlelogout) (CAS protocol) Documentation for the logout element(../appendix/namespace/http.html#nsa-logout) in the Spring Security XML Namespace section"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/events.html","Authentication Events: For each authentication that succeeds or fails, a AuthenticationSuccessEvent or AuthenticationFailureEvent , respectively, is fired. To listen for these events, you must first publish an AuthenticationEventPublisher . Spring Security’s DefaultAuthenticationEventPublisher works fine for this purpose: Java Kotlin @Bean public AuthenticationEventPublisher authenticationEventPublisher (ApplicationEventPublisher applicationEventPublisher) { return new DefaultAuthenticationEventPublisher(applicationEventPublisher); } @Bean fun authenticationEventPublisher (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher { return DefaultAuthenticationEventPublisher(applicationEventPublisher) } Then you can use Spring’s @EventListener support: Java Kotlin @Component public class AuthenticationEvents { @EventListener public void onSuccess(AuthenticationSuccessEvent success) { // ... } @EventListener public void onFailure(AbstractAuthenticationFailureEvent failures) { // ... } } @Component class AuthenticationEvents { @EventListener fun onSuccess(success: AuthenticationSuccessEvent?) { // ... } @EventListener fun onFailure(failures: AbstractAuthenticationFailureEvent?) { // ... } } While similar to AuthenticationSuccessHandler and AuthenticationFailureHandler , these are nice in that they can be used independently from the servlet API. Adding Exception Mappings: By default, DefaultAuthenticationEventPublisher publishes an AuthenticationFailureEvent for the following events: Exception Event BadCredentialsException AuthenticationFailureBadCredentialsEvent UsernameNotFoundException AuthenticationFailureBadCredentialsEvent AccountExpiredException AuthenticationFailureExpiredEvent ProviderNotFoundException AuthenticationFailureProviderNotFoundEvent DisabledException AuthenticationFailureDisabledEvent LockedException AuthenticationFailureLockedEvent AuthenticationServiceException AuthenticationFailureServiceExceptionEvent CredentialsExpiredException AuthenticationFailureCredentialsExpiredEvent InvalidBearerTokenException AuthenticationFailureBadCredentialsEvent The publisher does an exact Exception match, which means that sub-classes of these exceptions do not also produce events. To that end, you may want to supply additional mappings to the publisher through the setAdditionalExceptionMappings method: Java Kotlin @Bean public AuthenticationEventPublisher authenticationEventPublisher (ApplicationEventPublisher applicationEventPublisher) { Map<Class<? extends AuthenticationException>, Class<? extends AbstractAuthenticationFailureEvent>> mapping = Collections.singletonMap(FooException.class, FooEvent.class); AuthenticationEventPublisher authenticationEventPublisher = new DefaultAuthenticationEventPublisher(applicationEventPublisher); authenticationEventPublisher.setAdditionalExceptionMappings(mapping); return authenticationEventPublisher; } @Bean fun authenticationEventPublisher (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher { val mapping: Map<Class<out AuthenticationException>, Class<out AbstractAuthenticationFailureEvent>> = mapOf(Pair(FooException::class.java, FooEvent::class.java)) val authenticationEventPublisher = DefaultAuthenticationEventPublisher(applicationEventPublisher) authenticationEventPublisher.setAdditionalExceptionMappings(mapping) return authenticationEventPublisher } Default Event: You can also supply a catch-all event to fire in the case of any AuthenticationException : Java Kotlin @Bean public AuthenticationEventPublisher authenticationEventPublisher (ApplicationEventPublisher applicationEventPublisher) { AuthenticationEventPublisher authenticationEventPublisher = new DefaultAuthenticationEventPublisher(applicationEventPublisher); authenticationEventPublisher.setDefaultAuthenticationFailureEvent (GenericAuthenticationFailureEvent.class); return authenticationEventPublisher; } @Bean fun authenticationEventPublisher (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher { val authenticationEventPublisher = DefaultAuthenticationEventPublisher(applicationEventPublisher) authenticationEventPublisher.setDefaultAuthenticationFailureEvent(GenericAuthenticationFailureEvent::class.java) return authenticationEventPublisher }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authorization/index.html","Authorization: Having established how users will authenticate(../authentication/index.html) , you also need to configure your application’s authorization rules. The advanced authorization capabilities within Spring Security represent one of the most compelling reasons for its popularity. Irrespective of how you choose to authenticate (whether using a Spring Security-provided mechanism and provider or integrating with a container or other non-Spring Security authentication authority), the authorization services can be used within your application in a consistent and simple way. You should consider attaching authorization rules to request URIs(authorize-http-requests.html) and methods(method-security.html) to begin. In either case, you can listen and react to authorization events(events.html) that each authorization check publishes. Below there is also wealth of detail about how Spring Security authorization works(architecture.html) and how, having established a basic model, it can be fine-tuned. Section Summary: Authorization Architecture(architecture.html) Authorize HTTP Requests(authorize-http-requests.html) Method Security(method-security.html) Domain Object Security ACLs(acls.html) Authorization Events(events.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/authorization/architecture.html","Authorization Architecture: This section describes the Spring Security architecture that applies to authorization. Authorities: Authentication(../authentication/architecture.html#servlet-authentication-authentication) discusses how all Authentication implementations store a list of GrantedAuthority objects. These represent the authorities that have been granted to the principal. The GrantedAuthority objects are inserted into the Authentication object by the AuthenticationManager and are later read by AccessDecisionManager instances when making authorization decisions. The GrantedAuthority interface has only one method: String getAuthority(); This method is used by an AuthorizationManager instance to obtain a precise String representation of the GrantedAuthority . By returning a representation as a String , a GrantedAuthority can be easily ""read"" by most AuthorizationManager implementations. If a GrantedAuthority cannot be precisely represented as a String , the GrantedAuthority is considered ""complex"" and getAuthority() must return null . An example of a complex GrantedAuthority would be an implementation that stores a list of operations and authority thresholds that apply to different customer account numbers. Representing this complex GrantedAuthority as a String would be quite difficult. As a result, the getAuthority() method should return null . This indicates to any AuthorizationManager that it needs to support the specific GrantedAuthority implementation to understand its contents. Spring Security includes one concrete GrantedAuthority implementation: SimpleGrantedAuthority . This implementation lets any user-specified String be converted into a GrantedAuthority . All AuthenticationProvider instances included with the security architecture use SimpleGrantedAuthority to populate the Authentication object. By default, role-based authorization rules include ROLE_ as a prefix. This means that if there is an authorization rule that requires a security context to have a role of ""USER"", Spring Security will by default look for a GrantedAuthority#getAuthority that returns ""ROLE_USER"". You can customize this with GrantedAuthorityDefaults . GrantedAuthorityDefaults exists to allow customizing the prefix to use for role-based authorization rules. You can configure the authorization rules to use a different prefix by exposing a GrantedAuthorityDefaults bean, like so: Custom MethodSecurityExpressionHandler Java Kotlin Xml @Bean static GrantedAuthorityDefaults grantedAuthorityDefaults() { return new GrantedAuthorityDefaults(""MYPREFIX_""); } companion object { @Bean fun grantedAuthorityDefaults() : GrantedAuthorityDefaults { return GrantedAuthorityDefaults(""MYPREFIX_""); } } <bean id=""grantedAuthorityDefaults"" class=""org.springframework.security.config.core.GrantedAuthorityDefaults""> <constructor-arg value=""MYPREFIX_""/> </bean> You expose GrantedAuthorityDefaults using a static method to ensure that Spring publishes it before it initializes Spring Security’s method security @Configuration classes Invocation Handling: Spring Security provides interceptors that control access to secure objects, such as method invocations or web requests. A pre-invocation decision on whether the invocation is allowed to proceed is made by AuthorizationManager instances. Also post-invocation decisions on whether a given value may be returned is made by AuthorizationManager instances. The AuthorizationManager: AuthorizationManager supersedes both AccessDecisionManager and AccessDecisionVoter(#authz-legacy-note) . Applications that customize an AccessDecisionManager or AccessDecisionVoter are encouraged to change to using AuthorizationManager(#authz-voter-adaptation) . AuthorizationManager s are called by Spring Security’s request-based(authorize-http-requests.html) , method-based(method-security.html) , and message-based(../integrations/websocket.html) authorization components and are responsible for making final access control decisions. The AuthorizationManager interface contains two methods: AuthorizationDecision check(Supplier<Authentication> authentication, Object secureObject); default AuthorizationDecision verify(Supplier<Authentication> authentication, Object secureObject) throws AccessDeniedException { // ... } The AuthorizationManager 's check method is passed all the relevant information it needs in order to make an authorization decision. In particular, passing the secure Object enables those arguments contained in the actual secure object invocation to be inspected. For example, let’s assume the secure object was a MethodInvocation . It would be easy to query the MethodInvocation for any Customer argument, and then implement some sort of security logic in the AuthorizationManager to ensure the principal is permitted to operate on that customer. Implementations are expected to return a positive AuthorizationDecision if access is granted, negative AuthorizationDecision if access is denied, and a null AuthorizationDecision when abstaining from making a decision. verify calls check and subsequently throws an AccessDeniedException in the case of a negative AuthorizationDecision . Delegate-based AuthorizationManager Implementations: Whilst users can implement their own AuthorizationManager to control all aspects of authorization, Spring Security ships with a delegating AuthorizationManager that can collaborate with individual AuthorizationManager s. RequestMatcherDelegatingAuthorizationManager will match the request with the most appropriate delegate AuthorizationManager . For method security, you can use AuthorizationManagerBeforeMethodInterceptor and AuthorizationManagerAfterMethodInterceptor . Authorization Manager Implementations(#authz-authorization-manager-implementations) illustrates the relevant classes. Figure 1. Authorization Manager Implementations Using this approach, a composition of AuthorizationManager implementations can be polled on an authorization decision. AuthorityAuthorizationManager: The most common AuthorizationManager provided with Spring Security is AuthorityAuthorizationManager . It is configured with a given set of authorities to look for on the current Authentication . It will return positive AuthorizationDecision should the Authentication contain any of the configured authorities. It will return a negative AuthorizationDecision otherwise. AuthenticatedAuthorizationManager: Another manager is the AuthenticatedAuthorizationManager . It can be used to differentiate between anonymous, fully-authenticated and remember-me authenticated users. Many sites allow certain limited access under remember-me authentication, but require a user to confirm their identity by logging in for full access. AuthorizationManagers: There are also helpful static factories in AuthorizationManagers(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/AuthorizationManagers.html) for composing individual AuthorizationManager s into more sophisticated expressions. Custom Authorization Managers: Obviously, you can also implement a custom AuthorizationManager and you can put just about any access-control logic you want in it. It might be specific to your application (business-logic related) or it might implement some security administration logic. For example, you can create an implementation that can query Open Policy Agent or your own authorization database. You’ll find a blog article(https://spring.io/blog/2009/01/03/spring-security-customization-part-2-adjusting-secured-session-in-real-time) on the Spring web site which describes how to use the legacy AccessDecisionVoter to deny access in real-time to users whose accounts have been suspended. You can achieve the same outcome by implementing AuthorizationManager instead. Adapting AccessDecisionManager and AccessDecisionVoters: Previous to AuthorizationManager , Spring Security published AccessDecisionManager and AccessDecisionVoter(#authz-legacy-note) . In some cases, like migrating an older application, it may be desirable to introduce an AuthorizationManager that invokes an AccessDecisionManager or AccessDecisionVoter . To call an existing AccessDecisionManager , you can do: Adapting an AccessDecisionManager Java @Component public class AccessDecisionManagerAuthorizationManagerAdapter implements AuthorizationManager { private final AccessDecisionManager accessDecisionManager; private final SecurityMetadataSource securityMetadataSource; @Override public AuthorizationDecision check(Supplier<Authentication> authentication, Object object) { try { Collection<ConfigAttribute> attributes = this.securityMetadataSource.getAttributes(object); this.accessDecisionManager.decide(authentication.get(), object, attributes); return new AuthorizationDecision(true); } catch (AccessDeniedException ex) { return new AuthorizationDecision(false); } } @Override public void verify(Supplier<Authentication> authentication, Object object) { Collection<ConfigAttribute> attributes = this.securityMetadataSource.getAttributes(object); this.accessDecisionManager.decide(authentication.get(), object, attributes); } } And then wire it into your SecurityFilterChain . Or to only call an AccessDecisionVoter , you can do: Adapting an AccessDecisionVoter Java @Component public class AccessDecisionVoterAuthorizationManagerAdapter implements AuthorizationManager { private final AccessDecisionVoter accessDecisionVoter; private final SecurityMetadataSource securityMetadataSource; @Override public AuthorizationDecision check(Supplier<Authentication> authentication, Object object) { Collection<ConfigAttribute> attributes = this.securityMetadataSource.getAttributes(object); int decision = this.accessDecisionVoter.vote(authentication.get(), object, attributes); switch (decision) { case ACCESS_GRANTED: return new AuthorizationDecision(true); case ACCESS_DENIED: return new AuthorizationDecision(false); } return null; } } And then wire it into your SecurityFilterChain . Hierarchical Roles: It is a common requirement that a particular role in an application should automatically ""include"" other roles. For example, in an application which has the concept of an ""admin"" and a ""user"" role, you may want an admin to be able to do everything a normal user can. To achieve this, you can either make sure that all admin users are also assigned the ""user"" role. Alternatively, you can modify every access constraint which requires the ""user"" role to also include the ""admin"" role. This can get quite complicated if you have a lot of different roles in your application. The use of a role-hierarchy allows you to configure which roles (or authorities) should include others. This is supported for filter-based authorization in HttpSecurity#authorizeHttpRequests and for method-based authorization through DefaultMethodSecurityExpressionHandler for pre-post annotations, SecuredAuthorizationManager for @Secured , and Jsr250AuthorizationManager for JSR-250 annotations. You can configure the behavior for all of them at once in the following way: Hierarchical Roles Configuration Java Xml @Bean static RoleHierarchy roleHierarchy() { return RoleHierarchyImpl.withDefaultRolePrefix() .role(""ADMIN"").implies(""STAFF"") .role(""STAFF"").implies(""USER"") .role(""USER"").implies(""GUEST"") .build(); } // and, if using pre-post method security also add @Bean static MethodSecurityExpressionHandler methodSecurityExpressionHandler(RoleHierarchy roleHierarchy) { DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler(); expressionHandler.setRoleHierarchy(roleHierarchy); return expressionHandler; } <bean id=""roleHierarchy"" class=""org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl"" factory-method=""fromHierarchy""> <constructor-arg> <value> ROLE_ADMIN > ROLE_STAFF ROLE_STAFF > ROLE_USER ROLE_USER > ROLE_GUEST </value> </constructor-arg> </bean> <!-- and, if using method security also add --> <bean id=""methodSecurityExpressionHandler"" class=""org.springframework.security.access.expression.method.MethodSecurityExpressionHandler""> <property ref=""roleHierarchy""/> </bean> Here we have four roles in a hierarchy ROLE_ADMIN ⇒ ROLE_STAFF ⇒ ROLE_USER ⇒ ROLE_GUEST . A user who is authenticated with ROLE_ADMIN , will behave as if they have all four roles when security constraints are evaluated against any filter- or method-based rules. The > symbol can be thought of as meaning ""includes"". Role hierarchies offer a convenient means of simplifying the access-control configuration data for your application and/or reducing the number of authorities which you need to assign to a user. For more complex requirements you may wish to define a logical mapping between the specific access-rights your application requires and the roles that are assigned to users, translating between the two when loading the user information. Legacy Authorization Components: Spring Security contains some legacy components. Since they are not yet removed, documentation is included for historical purposes. Their recommended replacements are above. The AccessDecisionManager: The AccessDecisionManager is called by the AbstractSecurityInterceptor and is responsible for making final access control decisions. The AccessDecisionManager interface contains three methods: void decide(Authentication authentication, Object secureObject, Collection<ConfigAttribute> attrs) throws AccessDeniedException; boolean supports(ConfigAttribute attribute); boolean supports(Class clazz); The decide method of the AccessDecisionManager is passed all the relevant information it needs to make an authorization decision. In particular, passing the secure Object lets those arguments contained in the actual secure object invocation be inspected. For example, assume the secure object is a MethodInvocation . You can query the MethodInvocation for any Customer argument and then implement some sort of security logic in the AccessDecisionManager to ensure the principal is permitted to operate on that customer. Implementations are expected to throw an AccessDeniedException if access is denied. The supports(ConfigAttribute) method is called by the AbstractSecurityInterceptor at startup time to determine if the AccessDecisionManager can process the passed ConfigAttribute . The supports(Class) method is called by a security interceptor implementation to ensure the configured AccessDecisionManager supports the type of secure object that the security interceptor presents. Voting-Based AccessDecisionManager Implementations: While users can implement their own AccessDecisionManager to control all aspects of authorization, Spring Security includes several AccessDecisionManager implementations that are based on voting. Voting Decision Manager(#authz-access-voting) describes the relevant classes. The following image shows the AccessDecisionManager interface: Figure 2. Voting Decision Manager By using this approach, a series of AccessDecisionVoter implementations are polled on an authorization decision. The AccessDecisionManager then decides whether or not to throw an AccessDeniedException based on its assessment of the votes. The AccessDecisionVoter interface has three methods: int vote(Authentication authentication, Object object, Collection<ConfigAttribute> attrs); boolean supports(ConfigAttribute attribute); boolean supports(Class clazz); Concrete implementations return an int , with possible values being reflected in the AccessDecisionVoter static fields named ACCESS_ABSTAIN , ACCESS_DENIED and ACCESS_GRANTED . A voting implementation returns ACCESS_ABSTAIN if it has no opinion on an authorization decision. If it does have an opinion, it must return either ACCESS_DENIED or ACCESS_GRANTED . There are three concrete AccessDecisionManager implementations provided with Spring Security to tally the votes. The ConsensusBased implementation grants or denies access based on the consensus of non-abstain votes. Properties are provided to control behavior in the event of an equality of votes or if all votes are abstain. The AffirmativeBased implementation grants access if one or more ACCESS_GRANTED votes were received (in other words, a deny vote will be ignored, provided there was at least one grant vote). Like the ConsensusBased implementation, there is a parameter that controls the behavior if all voters abstain. The UnanimousBased provider expects unanimous ACCESS_GRANTED votes in order to grant access, ignoring abstains. It denies access if there is any ACCESS_DENIED vote. Like the other implementations, there is a parameter that controls the behavior if all voters abstain. You can implement a custom AccessDecisionManager that tallies votes differently. For example, votes from a particular AccessDecisionVoter might receive additional weighting, while a deny vote from a particular voter may have a veto effect. RoleVoter: The most commonly used AccessDecisionVoter provided with Spring Security is the RoleVoter , which treats configuration attributes as role names and votes to grant access if the user has been assigned that role. It votes if any ConfigAttribute begins with the ROLE_ prefix. It votes to grant access if there is a GrantedAuthority that returns a String representation (from the getAuthority() method) exactly equal to one or more ConfigAttributes that start with the ROLE_ prefix. If there is no exact match of any ConfigAttribute starting with ROLE_ , RoleVoter votes to deny access. If no ConfigAttribute begins with ROLE_ , the voter abstains. AuthenticatedVoter: Another voter which we have implicitly seen is the AuthenticatedVoter , which can be used to differentiate between anonymous, fully-authenticated, and remember-me authenticated users. Many sites allow certain limited access under remember-me authentication but require a user to confirm their identity by logging in for full access. When we have used the IS_AUTHENTICATED_ANONYMOUSLY attribute to grant anonymous access, this attribute was being processed by the AuthenticatedVoter . For more information, see AuthenticatedVoter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/access/vote/AuthenticatedVoter.html) . Custom Voters: You can also implement a custom AccessDecisionVoter and put just about any access-control logic you want in it. It might be specific to your application (business-logic related) or it might implement some security administration logic. For example, on the Spring web site, you can find a blog article(https://spring.io/blog/2009/01/03/spring-security-customization-part-2-adjusting-secured-session-in-real-time) that describes how to use a voter to deny access in real-time to users whose accounts have been suspended. Figure 3. After Invocation Implementation Like many other parts of Spring Security, AfterInvocationManager has a single concrete implementation, AfterInvocationProviderManager , which polls a list of AfterInvocationProvider s. Each AfterInvocationProvider is allowed to modify the return object or throw an AccessDeniedException . Indeed multiple providers can modify the object, as the result of the previous provider is passed to the next in the list. Please be aware that if you’re using AfterInvocationManager , you will still need configuration attributes that allow the MethodSecurityInterceptor 's AccessDecisionManager to allow an operation. If you’re using the typical Spring Security included AccessDecisionManager implementations, having no configuration attributes defined for a particular secure method invocation will cause each AccessDecisionVoter to abstain from voting. In turn, if the AccessDecisionManager property “allowIfAllAbstainDecisions” is false , an AccessDeniedException will be thrown. You may avoid this potential issue by either (i) setting “allowIfAllAbstainDecisions” to true (although this is generally not recommended) or (ii) simply ensure that there is at least one configuration attribute that an AccessDecisionVoter will vote to grant access for. This latter (recommended) approach is usually achieved through a ROLE_USER or ROLE_AUTHENTICATED configuration attribute."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authorization/authorize-http-requests.html","Authorize HttpServletRequests: Spring Security allows you to model your authorization(index.html) at the request level. For example, with Spring Security you can say that all pages under /admin require one authority while all other pages simply require authentication. By default, Spring Security requires that every request be authenticated. That said, any time you use an HttpSecurity instance(../configuration/java.html#jc-httpsecurity) , it’s necessary to declare your authorization rules. Whenever you have an HttpSecurity instance, you should at least do: Use authorizeHttpRequests Java Kotlin Xml http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) http { authorizeHttpRequests { authorize(anyRequest, authenticated) } } <http> <intercept-url pattern=""/**"" access=""authenticated""/> </http> This tells Spring Security that any endpoint in your application requires that the security context at a minimum be authenticated in order to allow it. In many cases, your authorization rules will be more sophisticated than that, so please consider the following use cases: I have an app that uses authorizeRequests and I want to migrate it to authorizeHttpRequests(#migrate-authorize-requests) I want to understand how the AuthorizationFilter components work(#request-authorization-architecture) I want to match requests(#match-requests) based on a pattern; specifically regex(#match-by-regex) I want to match request, and I map Spring MVC to something other than the default servlet(#mvc-not-default-servlet) I want to authorize requests(#authorize-requests) I want to match a request programmatically(#match-by-custom) I want to authorize a request programmatically(#authorize-requests) I want to delegate request authorization(#remote-authorization-manager) to a policy agent Understanding How Request Authorization Components Work: This section builds on Servlet Architecture and Implementation(../architecture.html#servlet-architecture) by digging deeper into how authorization(index.html#servlet-authorization) works at the request level in Servlet-based applications. Figure 1. Authorize HttpServletRequest First, the AuthorizationFilter constructs a Supplier that retrieves an Authentication(../authentication/architecture.html#servlet-authentication-authentication) from the SecurityContextHolder(../authentication/architecture.html#servlet-authentication-securitycontextholder) . Second, it passes the Supplier<Authentication> and the HttpServletRequest to the AuthorizationManager(../architecture.html#authz-authorization-manager) . The AuthorizationManager matches the request to the patterns in authorizeHttpRequests , and runs the corresponding rule. If authorization is denied, an AuthorizationDeniedEvent is published(events.html) , and an AccessDeniedException is thrown. In this case the ExceptionTranslationFilter(../architecture.html#servlet-exceptiontranslationfilter) handles the AccessDeniedException . If access is granted, an AuthorizationGrantedEvent is published(events.html) and AuthorizationFilter continues with the FilterChain(../architecture.html#servlet-filters-review) which allows the application to process normally. AuthorizationFilter Is Last By Default: The AuthorizationFilter is last in the Spring Security filter chain(../architecture.html#servlet-filterchain-figure) by default. This means that Spring Security’s authentication filters(../authentication/index.html) , exploit protections(../exploits/index.html) , and other filter integrations do not require authorization. If you add filters of your own before the AuthorizationFilter , they will also not require authorization; otherwise, they will. A place where this typically becomes important is when you are adding Spring MVC(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html/web.html#spring-web) endpoints. Because they are executed by the DispatcherServlet(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html/web.html#mvc-servlet) and this comes after the AuthorizationFilter , your endpoints need to be included in authorizeHttpRequests to be permitted(#authorizing-endpoints) . All Dispatches Are Authorized: The AuthorizationFilter runs not just on every request, but on every dispatch. This means that the REQUEST dispatch needs authorization, but also FORWARD s, ERROR s, and INCLUDE s. For example, Spring MVC(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html/web.html#spring-web) can FORWARD the request to a view resolver that renders a Thymeleaf template, like so: Sample Forwarding Spring MVC Controller Java Kotlin @Controller public class MyController { @GetMapping(""/endpoint"") public String endpoint() { return ""endpoint""; } } @Controller class MyController { @GetMapping(""/endpoint"") fun endpoint(): String { return ""endpoint"" } } In this case, authorization happens twice; once for authorizing /endpoint and once for forwarding to Thymeleaf to render the ""endpoint"" template. For that reason, you may want to permit all FORWARD dispatches(#match-by-dispatcher-type) . Another example of this principle is how Spring Boot handles errors(https://docs.spring.io/spring-boot/docs/3.1.1/reference/html/web.html#web.servlet.spring-mvc.error-handling) . If the container catches an exception, say like the following: Sample Erroring Spring MVC Controller Java Kotlin @Controller public class MyController { @GetMapping(""/endpoint"") public String endpoint() { throw new UnsupportedOperationException(""unsupported""); } } @Controller class MyController { @GetMapping(""/endpoint"") fun endpoint(): String { throw UnsupportedOperationException(""unsupported"") } } then Boot will dispatch it to the ERROR dispatch. In that case, authorization also happens twice; once for authorizing /endpoint and once for dispatching the error. For that reason, you may want to permit all ERROR dispatches(#match-by-dispatcher-type) . Authentication Lookup is Deferred: Remember that the AuthorizationManager API uses a Supplier<Authentication>(architecture.html#_the_authorizationmanager) . This matters with authorizeHttpRequests when requests are always permitted or always denied(#authorize-requests) . In those cases, the Authentication(../authentication/architecture.html#servlet-authentication-authentication) is not queried, making for a faster request. Authorizing an Endpoint: You can configure Spring Security to have different rules by adding more rules in order of precedence. If you want to require that /endpoint only be accessible by end users with the USER authority, then you can do: Authorize an Endpoint Java Kotlin Xml @Bean public SecurityFilterChain web(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(""/endpoint"").hasAuthority(""USER"") .anyRequest().authenticated() ) // ... return http.build(); } @Bean fun web(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(""/endpoint"", hasAuthority(""USER"")) authorize(anyRequest, authenticated) } } return http.build() } <http> <intercept-url pattern=""/endpoint"" access=""hasAuthority('USER')""/> <intercept-url pattern=""/**"" access=""authenticated""/> </http> As you can see, the declaration can be broken up in to pattern/rule pairs. AuthorizationFilter processes these pairs in the order listed, applying only the first match to the request. This means that even though /** would also match for /endpoint the above rules are not a problem. The way to read the above rules is ""if the request is /endpoint , then require the USER authority; else, only require authentication"". Spring Security supports several patterns and several rules; you can also programmatically create your own of each. Once authorized, you can test it using Security’s test support(../test/method.html#test-method-withmockuser) in the following way: Test Endpoint Authorization Java @WithMockUser(authorities=""USER"") @Test void endpointWhenUserAuthorityThenAuthorized() { this.mvc.perform(get(""/endpoint"")) .andExpect(status().isOk()); } @WithMockUser @Test void endpointWhenNotUserAuthorityThenForbidden() { this.mvc.perform(get(""/endpoint"")) .andExpect(status().isForbidden()); } @Test void anyWhenUnauthenticatedThenUnauthorized() { this.mvc.perform(get(""/any"")) .andExpect(status().isUnauthorized()); } Matching Requests: Above you’ve already seen two ways to match requests(#authorizing-endpoints) . The first you saw was the simplest, which is to match any request. The second is to match by a URI pattern. Spring Security supports two languages for URI pattern-matching: Ant(#match-by-ant) (as seen above) and Regular Expressions(#match-by-regex) . Matching Using Ant: Ant is the default language that Spring Security uses to match requests. You can use it to match a single endpoint or a directory, and you can even capture placeholders for later use. You can also refine it to match a specific set of HTTP methods. Let’s say that you instead of wanting to match the /endpoint endpoint, you want to match all endpoints under the /resource directory. In that case, you can do something like the following: Match with Ant Java Kotlin Xml http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(""/resource/**"").hasAuthority(""USER"") .anyRequest().authenticated() ) http { authorizeHttpRequests { authorize(""/resource/**"", hasAuthority(""USER"")) authorize(anyRequest, authenticated) } } <http> <intercept-url pattern=""/resource/**"" access=""hasAuthority('USER')""/> <intercept-url pattern=""/**"" access=""authenticated""/> </http> The way to read this is ""if the request is /resource or some subdirectory, require the USER authority; otherwise, only require authentication"" You can also extract path values from the request, as seen below: Authorize and Extract Java Kotlin Xml http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(""/resource/{name}"").access(new WebExpressionAuthorizationManager(""#name == authentication.name"")) .anyRequest().authenticated() ) http { authorizeHttpRequests { authorize(""/resource/{name}"", WebExpressionAuthorizationManager(""#name == authentication.name"")) authorize(anyRequest, authenticated) } } <http> <intercept-url pattern=""/resource/{name}"" access=""#name == authentication.name""/> <intercept-url pattern=""/**"" access=""authenticated""/> </http> Once authorized, you can test it using Security’s test support(../test/method.html#test-method-withmockuser) in the following way: Test Directory Authorization Java @WithMockUser(authorities=""USER"") @Test void endpointWhenUserAuthorityThenAuthorized() { this.mvc.perform(get(""/endpoint/jon"")) .andExpect(status().isOk()); } @WithMockUser @Test void endpointWhenNotUserAuthorityThenForbidden() { this.mvc.perform(get(""/endpoint/jon"")) .andExpect(status().isForbidden()); } @Test void anyWhenUnauthenticatedThenUnauthorized() { this.mvc.perform(get(""/any"")) .andExpect(status().isUnauthorized()); } Spring Security only matches paths. If you want to match query parameters, you will need a custom request matcher. Matching Using Regular Expressions: Spring Security supports matching requests against a regular expression. This can come in handy if you want to apply more strict matching criteria than ** on a subdirectory. For example, consider a path that contains the username and the rule that all usernames must be alphanumeric. You can use RegexRequestMatcher(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/util/matcher/RegexRequestMatcher.html) to respect this rule, like so: Match with Regex Java Kotlin Xml http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(RegexRequestMatcher.regexMatcher(""/resource/[A-Za-z0-9]+"")).hasAuthority(""USER"") .anyRequest().denyAll() ) http { authorizeHttpRequests { authorize(RegexRequestMatcher.regexMatcher(""/resource/[A-Za-z0-9]+""), hasAuthority(""USER"")) authorize(anyRequest, denyAll) } } <http> <intercept-url request-matcher=""regex"" pattern=""/resource/[A-Za-z0-9]+"" access=""hasAuthority('USER')""/> <intercept-url pattern=""/**"" access=""denyAll""/> </http> Matching By Http Method: You can also match rules by HTTP method. One place where this is handy is when authorizing by permissions granted, like being granted a read or write privilege. To require all GET s to have the read permission and all POST s to have the write permission, you can do something like this: Match by HTTP Method Java Kotlin Xml http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(HttpMethod.GET).hasAuthority(""read"") .requestMatchers(HttpMethod.POST).hasAuthority(""write"") .anyRequest().denyAll() ) http { authorizeHttpRequests { authorize(HttpMethod.GET, hasAuthority(""read"")) authorize(HttpMethod.POST, hasAuthority(""write"")) authorize(anyRequest, denyAll) } } <http> <intercept-url http-method=""GET"" pattern=""/**"" access=""hasAuthority('read')""/> <intercept-url http-method=""POST"" pattern=""/**"" access=""hasAuthority('write')""/> <intercept-url pattern=""/**"" access=""denyAll""/> </http> These authorization rules should read as: ""if the request is a GET, then require read permission; else, if the request is a POST, then require write permission; else, deny the request"" Denying the request by default is a healthy security practice since it turns the set of rules into an allow list. Once authorized, you can test it using Security’s test support(../test/method.html#test-method-withmockuser) in the following way: Test Http Method Authorization Java @WithMockUser(authorities=""read"") @Test void getWhenReadAuthorityThenAuthorized() { this.mvc.perform(get(""/any"")) .andExpect(status().isOk()); } @WithMockUser @Test void getWhenNoReadAuthorityThenForbidden() { this.mvc.perform(get(""/any"")) .andExpect(status().isForbidden()); } @WithMockUser(authorities=""write"") @Test void postWhenWriteAuthorityThenAuthorized() { this.mvc.perform(post(""/any"").with(csrf())) .andExpect(status().isOk()); } @WithMockUser(authorities=""read"") @Test void postWhenNoWriteAuthorityThenForbidden() { this.mvc.perform(get(""/any"").with(csrf())) .andExpect(status().isForbidden()); } Matching By Dispatcher Type: This feature is not currently supported in XML As stated earlier, Spring Security authorizes all dispatcher types by default(#_all_dispatches_are_authorized) . And even though the security context(../authentication/architecture.html#servlet-authentication-securitycontext) established on the REQUEST dispatch carries over to subsequent dispatches, subtle mismatches can sometimes cause an unexpected AccessDeniedException . To address that, you can configure Spring Security Java configuration to allow dispatcher types like FORWARD and ERROR , like so: Example 1. Match by Dispatcher Type Java http .authorizeHttpRequests((authorize) -> authorize .dispatcherTypeMatchers(DispatcherType.FORWARD, DispatcherType.ERROR).permitAll() .requestMatchers(""/endpoint"").permitAll() .anyRequest().denyAll() ) Kotlin http { authorizeHttpRequests { authorize(DispatcherTypeRequestMatcher(DispatcherType.FORWARD), permitAll) authorize(DispatcherTypeRequestMatcher(DispatcherType.ERROR), permitAll) authorize(""/endpoint"", permitAll) authorize(anyRequest, denyAll) } } Using an MvcRequestMatcher: Generally speaking, you can use requestMatchers(String) as demonstrated above. However, if you map Spring MVC to a different servlet path, then you need to account for that in your security configuration. For example, if Spring MVC is mapped to /spring-mvc instead of / (the default), then you may have an endpoint like /spring-mvc/my/controller that you want to authorize. You need to use MvcRequestMatcher to split the servlet path and the controller path in your configuration like so: Example 2. Match by MvcRequestMatcher Java @Bean MvcRequestMatcher.Builder mvc(HandlerMappingIntrospector introspector) { return new MvcRequestMatcher.Builder(introspector).servletPath(""/spring-mvc""); } @Bean SecurityFilterChain appEndpoints(HttpSecurity http, MvcRequestMatcher.Builder mvc) { http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(mvc.pattern(""/my/controller/**"")).hasAuthority(""controller"") .anyRequest().authenticated() ); return http.build(); } Kotlin @Bean fun mvc(introspector: HandlerMappingIntrospector): MvcRequestMatcher.Builder = MvcRequestMatcher.Builder(introspector).servletPath(""/spring-mvc""); @Bean fun appEndpoints(http: HttpSecurity, mvc: MvcRequestMatcher.Builder): SecurityFilterChain = http { authorizeHttpRequests { authorize(mvc.pattern(""/my/controller/**""), hasAuthority(""controller"")) authorize(anyRequest, authenticated) } } Xml <http> <intercept-url servlet-path=""/spring-mvc"" pattern=""/my/controller/**"" access=""hasAuthority('controller')""/> <intercept-url pattern=""/**"" access=""authenticated""/> </http> This need can arise in at least two different ways: If you use the spring.mvc.servlet.path Boot property to change the default path ( / ) to something else If you register more than one Spring MVC DispatcherServlet (thus requiring that one of them not be the default path) Using a Custom Matcher: This feature is not currently supported in XML In Java configuration, you can create your own RequestMatcher(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/util/matcher/RequestMatcher.html) and supply it to the DSL like so: Example 3. Authorize by Dispatcher Type Java RequestMatcher printview = (request) -> request.getParameter(""print"") != null; http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(printview).hasAuthority(""print"") .anyRequest().authenticated() ) Kotlin val printview: RequestMatcher = { (request) -> request.getParameter(""print"") != null } http { authorizeHttpRequests { authorize(printview, hasAuthority(""print"")) authorize(anyRequest, authenticated) } } Because RequestMatcher(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/util/matcher/RequestMatcher.html) is a functional interface, you can supply it as a lambda in the DSL. However, if you want to extract values from the request, you will need to have a concrete class since that requires overriding a default method. Once authorized, you can test it using Security’s test support(../test/method.html#test-method-withmockuser) in the following way: Test Custom Authorization Java @WithMockUser(authorities=""print"") @Test void printWhenPrintAuthorityThenAuthorized() { this.mvc.perform(get(""/any?print"")) .andExpect(status().isOk()); } @WithMockUser @Test void printWhenNoPrintAuthorityThenForbidden() { this.mvc.perform(get(""/any?print"")) .andExpect(status().isForbidden()); } Authorizing Requests: Once a request is matched, you can authorize it in several ways already seen(#match-requests) like permitAll , denyAll , and hasAuthority . As a quick summary, here are the authorization rules built into the DSL: permitAll - The request requires no authorization and is a public endpoint; note that in this case, the Authentication(../authentication/architecture.html#servlet-authentication-authentication) is never retrieved from the session denyAll - The request is not allowed under any circumstances; note that in this case, the Authentication is never retrieved from the session hasAuthority - The request requires that the Authentication have a GrantedAuthority(architecture.html#authz-authorities) that matches the given value hasRole - A shortcut for hasAuthority that prefixes ROLE_ or whatever is configured as the default prefix hasAnyAuthority - The request requires that the Authentication have a GrantedAuthority that matches any of the given values hasAnyRole - A shortcut for hasAnyAuthority that prefixes ROLE_ or whatever is configured as the default prefix access - The request uses this custom AuthorizationManager to determine access Having now learned the patterns, rules, and how they can be paired together, you should be able to understand what is going on in this more complex example: Authorize Requests Java import static jakarta.servlet.DispatcherType.*; import static org.springframework.security.authorization.AuthorizationManagers.allOf; import static org.springframework.security.authorization.AuthorityAuthorizationManager.hasAuthority; import static org.springframework.security.authorization.AuthorityAuthorizationManager.hasRole; @Bean SecurityFilterChain web(HttpSecurity http) throws Exception { http // ... .authorizeHttpRequests(authorize -> authorize (1) .dispatcherTypeMatchers(FORWARD, ERROR).permitAll() (2) .requestMatchers(""/static/**"", ""/signup"", ""/about"").permitAll() (3) .requestMatchers(""/admin/**"").hasRole(""ADMIN"") (4) .requestMatchers(""/db/**"").access(allOf(hasAuthority(""db""), hasRole(""ADMIN""))) (5) .anyRequest().denyAll() (6) ); return http.build(); } 1 There are multiple authorization rules specified. Each rule is considered in the order they were declared. 2 Dispatches FORWARD and ERROR are permitted to allow Spring MVC(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html/web.html#spring-web) to render views and Spring Boot to render errors 3 We specified multiple URL patterns that any user can access. Specifically, any user can access a request if the URL starts with ""/static/"", equals ""/signup"", or equals ""/about"". 4 Any URL that starts with ""/admin/"" will be restricted to users who have the role ""ROLE_ADMIN"". You will notice that since we are invoking the hasRole method we do not need to specify the ""ROLE_"" prefix. 5 Any URL that starts with ""/db/"" requires the user to have both been granted the ""db"" permission as well as be a ""ROLE_ADMIN"". You will notice that since we are using the hasRole expression we do not need to specify the ""ROLE_"" prefix. 6 Any URL that has not already been matched on is denied access. This is a good strategy if you do not want to accidentally forget to update your authorization rules. Expressing Authorization with SpEL: While using a concrete AuthorizationManager is recommended, there are some cases where an expression is necessary, like with <intercept-url> or with JSP Taglibs. For that reason, this section will focus on examples from those domains. Given that, let’s cover Spring Security’s Web Security Authorization SpEL API a bit more in depth. Spring Security encapsulates all of its authorization fields and methods in a set of root objects. The most generic root object is called SecurityExpressionRoot and it forms the basis for WebSecurityExpressionRoot . Spring Security supplies this root object to StandardEvaluationContext when preparing to evaluate an authorization expression. Using Authorization Expression Fields and Methods: The first thing this provides is an enhanced set of authorization fields and methods to your SpEL expressions. What follows is a quick overview of the most common methods: permitAll - The request requires no authorization to be invoked; note that in this case, the Authentication(../authentication/architecture.html#servlet-authentication-authentication) is never retrieved from the session denyAll - The request is not allowed under any circumstances; note that in this case, the Authentication is never retrieved from the session hasAuthority - The request requires that the Authentication have a GrantedAuthority(architecture.html#authz-authorities) that matches the given value hasRole - A shortcut for hasAuthority that prefixes ROLE_ or whatever is configured as the default prefix hasAnyAuthority - The request requires that the Authentication have a GrantedAuthority that matches any of the given values hasAnyRole - A shortcut for hasAnyAuthority that prefixes ROLE_ or whatever is configured as the default prefix hasPermission - A hook into your PermissionEvaluator instance for doing object-level authorization And here is a brief look at the most common fields: authentication - The Authentication instance associated with this method invocation principal - The Authentication#getPrincipal associated with this method invocation Having now learned the patterns, rules, and how they can be paired together, you should be able to understand what is going on in this more complex example: Authorize Requests Using SpEL Xml <http> <intercept-url pattern=""/static/**"" access=""permitAll""/> (1) <intercept-url pattern=""/admin/**"" access=""hasRole('ADMIN')""/> (2) <intercept-url pattern=""/db/**"" access=""hasAuthority('db') and hasRole('ADMIN')""/> (3) <intercept-url pattern=""/**"" access=""denyAll""/> (4) </http> 1 We specified a URL pattern that any user can access. Specifically, any user can access a request if the URL starts with ""/static/"". 2 Any URL that starts with ""/admin/"" will be restricted to users who have the role ""ROLE_ADMIN"". You will notice that since we are invoking the hasRole method we do not need to specify the ""ROLE_"" prefix. 3 Any URL that starts with ""/db/"" requires the user to have both been granted the ""db"" permission as well as be a ""ROLE_ADMIN"". You will notice that since we are using the hasRole expression we do not need to specify the ""ROLE_"" prefix. 4 Any URL that has not already been matched on is denied access. This is a good strategy if you do not want to accidentally forget to update your authorization rules. Using Path Parameters: Additionally, Spring Security provides a mechanism for discovering path parameters so they can also be accessed in the SpEL expression as well. For example, you can access a path parameter in your SpEL expression in the following way: Authorize Request using SpEL path variable Xml <http> <intercept-url pattern=""/resource/{name}"" access=""#name == authentication.name""/> <intercept-url pattern=""/**"" access=""authenticated""/> </http> This expression refers to the path variable after /resource/ and requires that it is equal to Authentication#getName . Use an Authorization Database, Policy Agent, or Other Service: If you want to configure Spring Security to use a separate service for authorization, you can create your own AuthorizationManager and match it to anyRequest . First, your AuthorizationManager may look something like this: Open Policy Agent Authorization Manager Java @Component public final class OpenPolicyAgentAuthorizationManager implements AuthorizationManager<RequestAuthorizationContext> { @Override public AuthorizationDecision check(Supplier<Authentication> authentication, RequestAuthorizationContext context) { // make request to Open Policy Agent } } Then, you can wire it into Spring Security in the following way: Any Request Goes to Remote Service Java @Bean SecurityFilterChain web(HttpSecurity http, AuthorizationManager<RequestAuthorizationContext> authz) throws Exception { http // ... .authorizeHttpRequests((authorize) -> authorize .anyRequest().access(authz) ); return http.build(); } Favor permitAll over ignoring: When you have static resources it can be tempting to configure the filter chain to ignore these values. A more secure approach is to permit them using permitAll like so: Example 4. Permit Static Resources Java http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(""/css/**"").permitAll() .anyRequest().authenticated() ) Kotlin http { authorizeHttpRequests { authorize(""/css/**"", permitAll) authorize(anyRequest, authenticated) } } It’s more secure because even with static resources it’s important to write secure headers, which Spring Security cannot do if the request is ignored. In this past, this came with a performance tradeoff since the session was consulted by Spring Security on every request. As of Spring Security 6, however, the session is no longer pinged unless required by the authorization rule. Because the performance impact is now addressed, Spring Security recommends using at least permitAll for all requests. Migrating from authorizeRequests: AuthorizationFilter supersedes FilterSecurityInterceptor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/access/intercept/FilterSecurityInterceptor.html) . To remain backward compatible, FilterSecurityInterceptor remains the default. This section discusses how AuthorizationFilter works and how to override the default configuration. The AuthorizationFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/access/intercept/AuthorizationFilter.html) provides authorization(index.html#servlet-authorization) for HttpServletRequest s. It is inserted into the FilterChainProxy(../architecture.html#servlet-filterchainproxy) as one of the Security Filters(../architecture.html#servlet-security-filters) . You can override the default when you declare a SecurityFilterChain . Instead of using authorizeRequests(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/config/annotation/web/builders/HttpSecurity.html#authorizeRequests()) , use authorizeHttpRequests , like so: Use authorizeHttpRequests Java @Bean SecurityFilterChain web(HttpSecurity http) throws AuthenticationException { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated(); ) // ... return http.build(); } This improves on authorizeRequests in a number of ways: Uses the simplified AuthorizationManager API instead of metadata sources, config attributes, decision managers, and voters. This simplifies reuse and customization. Delays Authentication lookup. Instead of the authentication needing to be looked up for every request, it will only look it up in requests where an authorization decision requires authentication. Bean-based configuration support. When authorizeHttpRequests is used instead of authorizeRequests , then AuthorizationFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/access/intercept/AuthorizationFilter.html) is used instead of FilterSecurityInterceptor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/access/intercept/FilterSecurityInterceptor.html) . Migrating Expressions: Where possible, it is recommended that you use type-safe authorization managers instead of SpEL. For Java configuration, WebExpressionAuthorizationManager(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/access/expression/WebExpressionAuthorizationManager.html) is available to help migrate legacy SpEL. To use WebExpressionAuthorizationManager , you can construct one with the expression you are trying to migrate, like so: Java Kotlin .requestMatchers(""/test/**"").access(new WebExpressionAuthorizationManager(""hasRole('ADMIN') && hasRole('USER')"")) .requestMatchers(""/test/**"").access(WebExpressionAuthorizationManager(""hasRole('ADMIN') && hasRole('USER')"")) If you are referring to a bean in your expression like so: @webSecurity.check(authentication, request) , it’s recommended that you instead call the bean directly, which will look something like the following: Java Kotlin .requestMatchers(""/test/**"").access((authentication, context) -> new AuthorizationDecision(webSecurity.check(authentication.get(), context.getRequest()))) .requestMatchers(""/test/**"").access((authentication, context): AuthorizationManager<RequestAuthorizationContext> -> AuthorizationDecision(webSecurity.check(authentication.get(), context.getRequest()))) For complex instructions that include bean references as well as other expressions, it is recommended that you change those to implement AuthorizationManager and refer to them by calling .access(AuthorizationManager) . If you are not able to do that, you can configure a DefaultHttpSecurityExpressionHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/access/expression/DefaultHttpSecurityExpressionHandler.html) with a bean resolver and supply that to WebExpressionAuthorizationManager#setExpressionhandler . Security Matchers: The RequestMatcher(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/util/matcher/RequestMatcher.html) interface is used to determine if a request matches a given rule. We use securityMatchers to determine if a given HttpSecurity(../configuration/java.html#jc-httpsecurity) should be applied to a given request. The same way, we can use requestMatchers to determine the authorization rules that we should apply to a given request. Look at the following example: Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .securityMatcher(""/api/**"") (1) .authorizeHttpRequests(authorize -> authorize .requestMatchers(""/user/**"").hasRole(""USER"") (2) .requestMatchers(""/admin/**"").hasRole(""ADMIN"") (3) .anyRequest().authenticated() (4) ) .formLogin(withDefaults()); return http.build(); } } @Configuration @EnableWebSecurity open class SecurityConfig { @Bean open fun web(http: HttpSecurity): SecurityFilterChain { http { securityMatcher(""/api/**"") (1) authorizeHttpRequests { authorize(""/user/**"", hasRole(""USER"")) (2) authorize(""/admin/**"", hasRole(""ADMIN"")) (3) authorize(anyRequest, authenticated) (4) } } return http.build() } } 1 Configure HttpSecurity to only be applied to URLs that start with /api/ 2 Allow access to URLs that start with /user/ to users with the USER role 3 Allow access to URLs that start with /admin/ to users with the ADMIN role 4 Any other request that doesn’t match the rules above, will require authentication The securityMatcher(s) and requestMatcher(s) methods will decide which RequestMatcher implementation fits best for your application: If Spring MVC(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html/web.html#spring-web) is in the classpath, then MvcRequestMatcher(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/servlet/util/matcher/MvcRequestMatcher.html) will be used, otherwise, AntPathRequestMatcher(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/servlet/util/matcher/AntPathRequestMatcher.html) will be used. You can read more about the Spring MVC integration here(../integrations/mvc.html) . If you want to use a specific RequestMatcher , just pass an implementation to the securityMatcher and/or requestMatcher methods: Java Kotlin import static org.springframework.security.web.util.matcher.AntPathRequestMatcher.antMatcher; (1) import static org.springframework.security.web.util.matcher.RegexRequestMatcher.regexMatcher; @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .securityMatcher(antMatcher(""/api/**"")) (2) .authorizeHttpRequests(authorize -> authorize .requestMatchers(antMatcher(""/user/**"")).hasRole(""USER"") (3) .requestMatchers(regexMatcher(""/admin/.*"")).hasRole(""ADMIN"") (4) .requestMatchers(new MyCustomRequestMatcher()).hasRole(""SUPERVISOR"") (5) .anyRequest().authenticated() ) .formLogin(withDefaults()); return http.build(); } } public class MyCustomRequestMatcher implements RequestMatcher { @Override public boolean matches(HttpServletRequest request) { // ... } } import org.springframework.security.web.util.matcher.AntPathRequestMatcher.antMatcher (1) import org.springframework.security.web.util.matcher.RegexRequestMatcher.regexMatcher @Configuration @EnableWebSecurity open class SecurityConfig { @Bean open fun web(http: HttpSecurity): SecurityFilterChain { http { securityMatcher(antMatcher(""/api/**"")) (2) authorizeHttpRequests { authorize(antMatcher(""/user/**""), hasRole(""USER"")) (3) authorize(regexMatcher(""/admin/**""), hasRole(""ADMIN"")) (4) authorize(MyCustomRequestMatcher(), hasRole(""SUPERVISOR"")) (5) authorize(anyRequest, authenticated) } } return http.build() } } 1 Import the static factory methods from AntPathRequestMatcher and RegexRequestMatcher to create RequestMatcher instances. 2 Configure HttpSecurity to only be applied to URLs that start with /api/ , using AntPathRequestMatcher 3 Allow access to URLs that start with /user/ to users with the USER role, using AntPathRequestMatcher 4 Allow access to URLs that start with /admin/ to users with the ADMIN role, using RegexRequestMatcher 5 Allow access to URLs that match the MyCustomRequestMatcher to users with the SUPERVISOR role, using a custom RequestMatcher Further Reading: Now that you have secured your application’s requests, consider securing its methods(method-security.html) . You can also read further on testing your application(../test/index.html) or on integrating Spring Security with other aspects of you application like the data layer(../integrations/data.html) or tracing and metrics(../integrations/observability.html) ."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authorization/method-security.html","Method Security: In addition to modeling authorization at the request level(authorize-http-requests.html) , Spring Security also supports modeling at the method level. You can activate it in your application by annotating any @Configuration class with @EnableMethodSecurity or adding <method-security> to any XML configuration file, like so: Java Kotlin Xml @EnableMethodSecurity @EnableMethodSecurity <sec:method-security/> Then, you are immediately able to annotate any Spring-managed class or method with @PreAuthorize(#use-preauthorize) , @PostAuthorize(#use-postauthorize) , @PreFilter(#use-prefilter) , and @PostFilter(#use-postfilter) to authorize method invocations, including the input parameters and return values. Spring Boot Starter Security(https://docs.spring.io/spring-boot/docs/3.1.1/reference/html/using.html#using.build-systems.starters) does not activate method-level authorization by default. Method Security supports many other use cases as well including AspectJ support(#use-aspectj) , custom annotations(#use-programmatic-authorization) , and several configuration points. Consider learning about the following use cases: Migrating from @EnableGlobalMethodSecurity(#migration-enableglobalmethodsecurity) Understanding how method security works(#method-security-architecture) and reasons to use it Comparing request-level and method-level authorization(#request-vs-method) Authorizing methods with @PreAuthorize(#use-preauthorize) and @PostAuthorize(#use-postauthorize) Providing fallback values when authorization is denied(#fallback-values-authorization-denied) Filtering methods with @PreFilter(#use-prefilter) and @PostFilter(#use-postfilter) Authorizing methods with JSR-250 annotations(#use-jsr250) Authorizing methods with AspectJ expressions(#use-aspectj) Integrating with AspectJ byte-code weaving(#weave-aspectj) Coordinating with @Transactional and other AOP-based annotations(#changing-the-order) Customizing SpEL expression handling(#customizing-expression-handling) Integrating with custom authorization systems(#custom-authorization-managers) How Method Security Works: Spring Security’s method authorization support is handy for: Extracting fine-grained authorization logic; for example, when the method parameters and return values contribute to the authorization decision. Enforcing security at the service layer Stylistically favoring annotation-based over HttpSecurity -based configuration And since Method Security is built using Spring AOP(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html/core.html#aop-api) , you have access to all its expressive power to override Spring Security’s defaults as needed. As already mentioned, you begin by adding @EnableMethodSecurity to a @Configuration class or <sec:method-security/> in a Spring XML configuration file. This annotation and XML element supercede @EnableGlobalMethodSecurity and <sec:global-method-security/> , respectively. They offer the following improvements: Uses the simplified AuthorizationManager API instead of metadata sources, config attributes, decision managers, and voters. This simplifies reuse and customization. Favors direct bean-based configuration, instead of requiring extending GlobalMethodSecurityConfiguration to customize beans Is built using native Spring AOP, removing abstractions and allowing you to use Spring AOP building blocks to customize Checks for conflicting annotations to ensure an unambiguous security configuration Complies with JSR-250 Enables @PreAuthorize , @PostAuthorize , @PreFilter , and @PostFilter by default If you are using @EnableGlobalMethodSecurity or <global-method-security/> , these are now deprecated, and you are encouraged to migrate. Method authorization is a combination of before- and after-method authorization. Consider a service bean that is annotated in the following way: Java Kotlin @Service public class MyCustomerService { @PreAuthorize(""hasAuthority('permission:read')"") @PostAuthorize(""returnObject.owner == authentication.name"") public Customer readCustomer(String id) { ... } } @Service open class MyCustomerService { @PreAuthorize(""hasAuthority('permission:read')"") @PostAuthorize(""returnObject.owner == authentication.name"") fun readCustomer(val id: String): Customer { ... } } A given invocation to MyCustomerService#readCustomer may look something like this when Method Security is activated(#activate-method-security) : Spring AOP invokes its proxy method for readCustomer . Among the proxy’s other advisors, it invokes an AuthorizationManagerBeforeMethodInterceptor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/AuthorizationManagerBeforeMethodInterceptor.html) that matches the @PreAuthorize pointcut(#annotation-method-pointcuts) The interceptor invokes PreAuthorizeAuthorizationManager#check(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/PreAuthorizeAuthorizationManager.html) The authorization manager uses a MethodSecurityExpressionHandler to parse the annotation’s SpEL expression(#authorization-expressions) and constructs a corresponding EvaluationContext from a MethodSecurityExpressionRoot containing a Supplier<Authentication>(../authentication/architecture.html#servlet-authentication-authentication) and MethodInvocation . The interceptor uses this context to evaluate the expression; specifically, it reads the Authentication(../authentication/architecture.html#servlet-authentication-authentication) from the Supplier and checks whether it has permission:read in its collection of authorities(architecture.html#authz-authorities) If the evaluation passes, then Spring AOP proceeds to invoke the method. If not, the interceptor publishes an AuthorizationDeniedEvent and throws an AccessDeniedException(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/access/AccessDeniedException.html) which the ExceptionTranslationFilter(../architecture.html#servlet-exceptiontranslationfilter) catches and returns a 403 status code to the response After the method returns, Spring AOP invokes an AuthorizationManagerAfterMethodInterceptor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/AuthorizationManagerAfterMethodInterceptor.html) that matches the @PostAuthorize pointcut(#annotation-method-pointcuts) , operating the same as above, but with PostAuthorizeAuthorizationManager(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/PostAuthorizeAuthorizationManager.html) If the evaluation passes (in this case, the return value belongs to the logged-in user), processing continues normally If not, the interceptor publishes an AuthorizationDeniedEvent and throws an AccessDeniedException(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/access/AccessDeniedException.html) , which the ExceptionTranslationFilter(../architecture.html#servlet-exceptiontranslationfilter) catches and returns a 403 status code to the response If the method is not being called in the context of an HTTP request, you will likely need to handle the AccessDeniedException yourself Multiple Annotations Are Computed In Series: As demonstrated above, if a method invocation involves multiple Method Security annotations(#authorizing-with-annotations) , each of those is processed one at a time. This means that they can collectively be thought of as being ""anded"" together. In other words, for an invocation to be authorized, all annotation inspections need to pass authorization. Repeated Annotations Are Not Supported: That said, it is not supported to repeat the same annotation on the same method. For example, you cannot place @PreAuthorize twice on the same method. Instead, use SpEL’s boolean support or its support for delegating to a separate bean. Each Annotation Has Its Own Pointcut: Each annotation has its own pointcut instance that looks for that annotation or its meta-annotation(#meta-annotations) counterparts across the entire object hierarchy, starting at the method and its enclosing class(#class-or-interface-annotations) . You can see the specifics of this in AuthorizationMethodPointcuts(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/AuthorizationMethodPointcuts.html) . Each Annotation Has Its Own Method Interceptor: Each annotation has its own dedicated method interceptor. The reason for this is to make things more composable. For example, if needed, you can disable the Spring Security defaults and publish only the @PostAuthorize method interceptor(#_enabling_certain_annotations) . The method interceptors are as follows: For @PreAuthorize(#use-preauthorize) , Spring Security uses AuthorizationManagerBeforeMethodInterceptor#preAuthorize(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/AuthorizationManagerBeforeMethodInterceptor.html) , which in turn uses PreAuthorizeAuthorizationManager(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/PreAuthorizeAuthorizationManager.html) For @PostAuthorize(#use-postauthorize) , Spring Security uses AuthorizationManagerBeforeMethodInterceptor#postAuthorize(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/AuthorizationManagerAfterMethodInterceptor.html) , which in turn uses PostAuthorizeAuthorizationManager(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/PostAuthorizeAuthorizationManager.html) For @PreFilter(#use-prefilter) , Spring Security uses PreFilterAuthorizationMethodInterceptor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/PreFilterAuthorizationMethodInterceptor.html) For @PostFilter(#use-postfilter) , Spring Security uses PostFilterAuthorizationMethodInterceptor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/PostFilterAuthorizationMethodInterceptor.html) For @Secured(#use-secured) , Spring Security uses AuthorizationManagerBeforeMethodInterceptor#secured(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/AuthorizationManagerBeforeMethodInterceptor.html) , which in turn uses SecuredAuthorizationManager(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/SecuredAuthorizationManager.html) For JSR-250 annotations, Spring Security uses AuthorizationManagerBeforeMethodInterceptor#jsr250(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/AuthorizationManagerBeforeMethodInterceptor.html) , which in turn uses Jsr250AuthorizationManager(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/Jsr250AuthorizationManager.html) Generally speaking, you can consider the following listing as representative of what interceptors Spring Security publishes when you add @EnableMethodSecurity : Java @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) static Advisor preAuthorizeMethodInterceptor() { return AuthorizationManagerBeforeMethodInterceptor.preAuthorize(); } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) static Advisor postAuthorizeMethodInterceptor() { return AuthorizationManagerAfterMethodInterceptor.postAuthorize(); } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) static Advisor preFilterMethodInterceptor() { return AuthorizationManagerBeforeMethodInterceptor.preFilter(); } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) static Advisor postFilterMethodInterceptor() { return AuthorizationManagerAfterMethodInterceptor.postFilter(); } Favor Granting Authorities Over Complicated SpEL Expressions: Quite often it can be tempting to introduce a complicated SpEL expression like the following: Java @PreAuthorize(""hasAuthority('permission:read') || hasRole('ADMIN')"") Kotlin @PreAuthorize(""hasAuthority('permission:read') || hasRole('ADMIN')"") However, you could instead grant permission:read to those with ROLE_ADMIN . One way to do this is with a RoleHierarchy like so: Java Kotlin Xml @Bean static RoleHierarchy roleHierarchy() { return RoleHierarchyImpl.fromHierarchy(""ROLE_ADMIN > permission:read""); } companion object { @Bean fun roleHierarchy(): RoleHierarchy { return RoleHierarchyImpl.fromHierarchy(""ROLE_ADMIN > permission:read"") } } <bean id=""roleHierarchy"" class=""org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl"" factory-method=""fromHierarchy""> <constructor-arg value=""ROLE_ADMIN > permission:read""/> </bean> and then set that in a MethodSecurityExpressionHandler instance(#customizing-expression-handling) . This then allows you to have a simpler @PreAuthorize(#use-preauthorize) expression like this one: Java Kotlin @PreAuthorize(""hasAuthority('permission:read')"") @PreAuthorize(""hasAuthority('permission:read')"") Or, where possible, adapt application-specific authorization logic into granted authorities at login time. Comparing Request-level vs Method-level Authorization: When should you favor method-level authorization over request-level authorization(authorize-http-requests.html) ? Some of it comes down to taste; however, consider the following strengths list of each to help you decide. request-level method-level authorization type coarse-grained fine-grained configuration location declared in a config class local to method declaration configuration style DSL Annotations authorization definitions programmatic SpEL The main tradeoff seems to be where you want your authorization rules to live. It’s important to remember that when you use annotation-based Method Security, then unannotated methods are not secured. To protect against this, declare a catch-all authorization rule(authorize-http-requests.html#activate-request-security) in your HttpSecurity(../configuration/java.html#jc-httpsecurity) instance. Authorizing with Annotations: The primary way Spring Security enables method-level authorization support is through annotations that you can add to methods, classes, and interfaces. Authorizing Method Invocation with @PreAuthorize: When Method Security is active(#activate-method-security) , you can annotate a method with the @PreAuthorize(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/access/prepost/PreAuthorize.html) annotation like so: Java Kotlin @Component public class BankService { @PreAuthorize(""hasRole('ADMIN')"") public Account readAccount(Long id) { // ... is only invoked if the `Authentication` has the `ROLE_ADMIN` authority } } @Component open class BankService { @PreAuthorize(""hasRole('ADMIN')"") fun readAccount(val id: Long): Account { // ... is only invoked if the `Authentication` has the `ROLE_ADMIN` authority } } This is meant to indicate that the method can only be invoked if the provided expression hasRole('ADMIN') passes. You can then test the class(../test/method.html) to confirm it is enforcing the authorization rule like so: Java Kotlin @Autowired BankService bankService; @WithMockUser(roles=""ADMIN"") @Test void readAccountWithAdminRoleThenInvokes() { Account account = this.bankService.readAccount(""12345678""); // ... assertions } @WithMockUser(roles=""WRONG"") @Test void readAccountWithWrongRoleThenAccessDenied() { assertThatExceptionOfType(AccessDeniedException.class).isThrownBy( () -> this.bankService.readAccount(""12345678"")); } @WithMockUser(roles=""ADMIN"") @Test fun readAccountWithAdminRoleThenInvokes() { val account: Account = this.bankService.readAccount(""12345678"") // ... assertions } @WithMockUser(roles=""WRONG"") @Test fun readAccountWithWrongRoleThenAccessDenied() { assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy { this.bankService.readAccount(""12345678"") } } @PreAuthorize also can be a meta-annotation(#meta-annotations) , be defined at the class or interface level(#class-or-interface-annotations) , and use SpEL Authorization Expressions(#authorization-expressions) . While @PreAuthorize is quite helpful for declaring needed authorities, it can also be used to evaluate more complex expressions that involve the method parameters(#using_method_parameters) . Authorization Method Results with @PostAuthorize: When Method Security is active, you can annotate a method with the @PostAuthorize(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/access/prepost/PostAuthorize.html) annotation like so: Java Kotlin @Component public class BankService { @PostAuthorize(""returnObject.owner == authentication.name"") public Account readAccount(Long id) { // ... is only returned if the `Account` belongs to the logged in user } } @Component open class BankService { @PostAuthorize(""returnObject.owner == authentication.name"") fun readAccount(val id: Long): Account { // ... is only returned if the `Account` belongs to the logged in user } } This is meant to indicate that the method can only return the value if the provided expression returnObject.owner == authentication.name passes. returnObject represents the Account object to be returned. You can then test the class(../test/method.html) to confirm it is enforcing the authorization rule: Java Kotlin @Autowired BankService bankService; @WithMockUser(username=""owner"") @Test void readAccountWhenOwnedThenReturns() { Account account = this.bankService.readAccount(""12345678""); // ... assertions } @WithMockUser(username=""wrong"") @Test void readAccountWhenNotOwnedThenAccessDenied() { assertThatExceptionOfType(AccessDeniedException.class).isThrownBy( () -> this.bankService.readAccount(""12345678"")); } @WithMockUser(username=""owner"") @Test fun readAccountWhenOwnedThenReturns() { val account: Account = this.bankService.readAccount(""12345678"") // ... assertions } @WithMockUser(username=""wrong"") @Test fun readAccountWhenNotOwnedThenAccessDenied() { assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy { this.bankService.readAccount(""12345678"") } } @PostAuthorize also can be a meta-annotation(#meta-annotations) , be defined at the class or interface level(#class-or-interface-annotations) , and use SpEL Authorization Expressions(#authorization-expressions) . @PostAuthorize is particularly helpful when defending against Insecure Direct Object Reference(https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html) . In fact, it can be defined as a meta-annotation(#meta-annotations) like so: Java Kotlin @Target({ ElementType.METHOD, ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) @PostAuthorize(""returnObject.owner == authentication.name"") public @interface RequireOwnership {} @Target(ElementType.METHOD, ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @PostAuthorize(""returnObject.owner == authentication.name"") annotation class RequireOwnership Allowing you to instead annotate the service in the following way: Java Kotlin @Component public class BankService { @RequireOwnership public Account readAccount(Long id) { // ... is only returned if the `Account` belongs to the logged in user } } @Component open class BankService { @RequireOwnership fun readAccount(val id: Long): Account { // ... is only returned if the `Account` belongs to the logged in user } } The result is that the above method will only return the Account if its owner attribute matches the logged-in user’s name . If not, Spring Security will throw an AccessDeniedException and return a 403 status code. Filtering Method Parameters with @PreFilter: @PreFilter is not yet supported for Kotlin-specific data types; for that reason, only Java snippets are shown When Method Security is active, you can annotate a method with the @PreFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/access/prepost/PreFilter.html) annotation like so: Java @Component public class BankService { @PreFilter(""filterObject.owner == authentication.name"") public Collection<Account> updateAccounts(Account... accounts) { // ... `accounts` will only contain the accounts owned by the logged-in user return updated; } } This is meant to filter out any values from accounts where the expression filterObject.owner == authentication.name fails. filterObject represents each account in accounts and is used to test each account . You can then test the class in the following way to confirm it is enforcing the authorization rule: Java @Autowired BankService bankService; @WithMockUser(username=""owner"") @Test void updateAccountsWhenOwnedThenReturns() { Account ownedBy = ... Account notOwnedBy = ... Collection<Account> updated = this.bankService.updateAccounts(ownedBy, notOwnedBy); assertThat(updated).containsOnly(ownedBy); } @PreFilter also can be a meta-annotation(#meta-annotations) , be defined at the class or interface level(#class-or-interface-annotations) , and use SpEL Authorization Expressions(#authorization-expressions) . @PreFilter supports arrays, collections, maps, and streams (so long as the stream is still open). For example, the above updateAccounts declaration will function the same way as the following other four: Java @PreFilter(""filterObject.owner == authentication.name"") public Collection<Account> updateAccounts(Account[] accounts) @PreFilter(""filterObject.owner == authentication.name"") public Collection<Account> updateAccounts(Collection<Account> accounts) @PreFilter(""filterObject.value.owner == authentication.name"") public Collection<Account> updateAccounts(Map<String, Account> accounts) @PreFilter(""filterObject.owner == authentication.name"") public Collection<Account> updateAccounts(Stream<Account> accounts) The result is that the above method will only have the Account instances where their owner attribute matches the logged-in user’s name . Filtering Method Results with @PostFilter: @PostFilter is not yet supported for Kotlin-specific data types; for that reason, only Java snippets are shown When Method Security is active, you can annotate a method with the @PostFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/access/prepost/PostFilter.html) annotation like so: Java @Component public class BankService { @PostFilter(""filterObject.owner == authentication.name"") public Collection<Account> readAccounts(String... ids) { // ... the return value will be filtered to only contain the accounts owned by the logged-in user return accounts; } } This is meant to filter out any values from the return value where the expression filterObject.owner == authentication.name fails. filterObject represents each account in accounts and is used to test each account . You can then test the class like so to confirm it is enforcing the authorization rule: Java @Autowired BankService bankService; @WithMockUser(username=""owner"") @Test void readAccountsWhenOwnedThenReturns() { Collection<Account> accounts = this.bankService.updateAccounts(""owner"", ""not-owner""); assertThat(accounts).hasSize(1); assertThat(accounts.get(0).getOwner()).isEqualTo(""owner""); } @PostFilter also can be a meta-annotation(#meta-annotations) , be defined at the class or interface level(#class-or-interface-annotations) , and use SpEL Authorization Expressions(#authorization-expressions) . @PostFilter supports arrays, collections, maps, and streams (so long as the stream is still open). For example, the above readAccounts declaration will function the same way as the following other three: @PostFilter(""filterObject.owner == authentication.name"") public Account[] readAccounts(String... ids) @PostFilter(""filterObject.value.owner == authentication.name"") public Map<String, Account> readAccounts(String... ids) @PostFilter(""filterObject.owner == authentication.name"") public Stream<Account> readAccounts(String... ids) The result is that the above method will return the Account instances where their owner attribute matches the logged-in user’s name . In-memory filtering can obviously be expensive, and so be considerate of whether it is better to filter the data in the data layer(../integrations/data.html) instead. Authorizing Method Invocation with @Secured: @Secured(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/access/annotation/Secured.html) is a legacy option for authorizing invocations. @PreAuthorize(#use-preauthorize) supercedes it and is recommended instead. To use the @Secured annotation, you should first change your Method Security declaration to enable it like so: Java Kotlin Xml @EnableMethodSecurity(securedEnabled = true) @EnableMethodSecurity(securedEnabled = true) <sec:method-security secured-enabled=""true""/> This will cause Spring Security to publish the corresponding method interceptor(#annotation-method-interceptors) that authorizes methods, classes, and interfaces annotated with @Secured . Authorizing Method Invocation with JSR-250 Annotations: In case you would like to use JSR-250(https://jcp.org/en/jsr/detail?id=250) annotations, Spring Security also supports that. @PreAuthorize(#use-preauthorize) has more expressive power and is thus recommended. To use the JSR-250 annotations, you should first change your Method Security declaration to enable them like so: Java Kotlin Xml @EnableMethodSecurity(jsr250Enabled = true) @EnableMethodSecurity(jsr250Enabled = true) <sec:method-security jsr250-enabled=""true""/> This will cause Spring Security to publish the corresponding method interceptor(#annotation-method-interceptors) that authorizes methods, classes, and interfaces annotated with @RolesAllowed , @PermitAll , and @DenyAll . Declaring Annotations at the Class or Interface Level: It’s also supported to have Method Security annotations at the class and interface level. If it is at the class level like so: Java Kotlin @Controller @PreAuthorize(""hasAuthority('ROLE_USER')"") public class MyController { @GetMapping(""/endpoint"") public String endpoint() { ... } } @Controller @PreAuthorize(""hasAuthority('ROLE_USER')"") open class MyController { @GetMapping(""/endpoint"") fun endpoint(): String { ... } } then all methods inherit the class-level behavior. Or, if it’s declared like the following at both the class and method level: Java Kotlin @Controller @PreAuthorize(""hasAuthority('ROLE_USER')"") public class MyController { @GetMapping(""/endpoint"") @PreAuthorize(""hasAuthority('ROLE_ADMIN')"") public String endpoint() { ... } } @Controller @PreAuthorize(""hasAuthority('ROLE_USER')"") open class MyController { @GetMapping(""/endpoint"") @PreAuthorize(""hasAuthority('ROLE_ADMIN')"") fun endpoint(): String { ... } } then methods declaring the annotation override the class-level annotation. The same is true for interfaces, with the exception that if a class inherits the annotation from two different interfaces, then startup will fail. This is because Spring Security has no way to tell which one you want to use. In cases like this, you can resolve the ambiguity by adding the annotation to the concrete method. Using Meta Annotations: Method Security supports meta annotations. This means that you can take any annotation and improve readability based on your application-specific use cases. For example, you can simplify @PreAuthorize(""hasRole('ADMIN')"") to @IsAdmin like so: Java Kotlin @Target({ ElementType.METHOD, ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) @PreAuthorize(""hasRole('ADMIN')"") public @interface IsAdmin {} @Target(ElementType.METHOD, ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @PreAuthorize(""hasRole('ADMIN')"") annotation class IsAdmin And the result is that on your secured methods you can now do the following instead: Java Kotlin @Component public class BankService { @IsAdmin public Account readAccount(Long id) { // ... is only returned if the `Account` belongs to the logged in user } } @Component open class BankService { @IsAdmin fun readAccount(val id: Long): Account { // ... is only returned if the `Account` belongs to the logged in user } } This results in more readable method definitions. Templating Meta-Annotation Expressions: You can also opt into using meta-annotation templates, which allow for much more powerful annotation definitions. First, publish the following bean: Java Kotlin @Bean static PrePostTemplateDefaults prePostTemplateDefaults() { return new PrePostTemplateDefaults(); } companion object { @Bean fun prePostTemplateDefaults(): PrePostTemplateDefaults { return PrePostTemplateDefaults() } } Now instead of @IsAdmin , you can create something more powerful like @HasRole like so: Java Kotlin @Target({ ElementType.METHOD, ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) @PreAuthorize(""hasRole('{value}')"") public @interface HasRole { String value(); } @Target(ElementType.METHOD, ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @PreAuthorize(""hasRole('{value}')"") annotation class HasRole(val value: String) And the result is that on your secured methods you can now do the following instead: Java Kotlin @Component public class BankService { @HasRole(""ADMIN"") public Account readAccount(Long id) { // ... is only returned if the `Account` belongs to the logged in user } } @Component open class BankService { @HasRole(""ADMIN"") fun readAccount(val id: Long): Account { // ... is only returned if the `Account` belongs to the logged in user } } Note that this works with method variables and all annotation types, too, though you will want to be careful to correctly take care of quotation marks so the resulting SpEL expression is correct. For example, consider the following @HasAnyRole annotation: Java Kotlin @Target({ ElementType.METHOD, ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) @PreAuthorize(""hasAnyRole({roles})"") public @interface HasAnyRole { String[] roles(); } @Target(ElementType.METHOD, ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @PreAuthorize(""hasAnyRole({roles})"") annotation class HasAnyRole(val roles: Array<String>) In that case, you’ll notice that you should not use the quotation marks in the expression, but instead in the parameter value like so: Java Kotlin @Component public class BankService { @HasAnyRole(roles = { ""'USER'"", ""'ADMIN'"" }) public Account readAccount(Long id) { // ... is only returned if the `Account` belongs to the logged in user } } @Component open class BankService { @HasAnyRole(roles = arrayOf(""'USER'"", ""'ADMIN'"")) fun readAccount(val id: Long): Account { // ... is only returned if the `Account` belongs to the logged in user } } so that, once replaced, the expression becomes @PreAuthorize(""hasAnyRole('USER', 'ADMIN')"") . Enabling Certain Annotations: You can turn off @EnableMethodSecurity 's pre-configuration and replace it with you own. You may choose to do this if you want to customize the AuthorizationManager(#custom-authorization-managers) or Pointcut . Or you may simply want to only enable a specific annotation, like @PostAuthorize . You can do this in the following way: Only @PostAuthorize Configuration Java Kotlin Xml @Configuration @EnableMethodSecurity(prePostEnabled = false) class MethodSecurityConfig { @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) Advisor postAuthorize() { return AuthorizationManagerAfterMethodInterceptor.postAuthorize(); } } @Configuration @EnableMethodSecurity(prePostEnabled = false) class MethodSecurityConfig { @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) fun postAuthorize() : Advisor { return AuthorizationManagerAfterMethodInterceptor.postAuthorize() } } <sec:method-security pre-post-enabled=""false""/> <aop:config/> <bean id=""postAuthorize"" class=""org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor"" factory-method=""postAuthorize""/> The above snippet achieves this by first disabling Method Security’s pre-configurations and then publishing the @PostAuthorize interceptor(#annotation-method-interceptors) itself. Authorizing with <intercept-methods>: While using Spring Security’s annotation-based support(#authorizing-with-annotations) is preferred for method security, you can also use XML to declare bean authorization rules. If you need to declare it in your XML configuration instead, you can use <intercept-methods>(../appendix/namespace/method-security.html#nsa-intercept-methods) like so: Xml <bean class=""org.mycompany.MyController""> <intercept-methods> <protect method=""get*"" access=""hasAuthority('read')""/> <protect method=""*"" access=""hasAuthority('write')""/> </intercept-methods> </bean> This only supports matching method by prefix or by name. If your needs are more complex than that, use annotation support(#authorizing-with-annotations) instead. Authorizing Methods Programmatically: As you’ve already seen, there are several ways that you can specify non-trivial authorization rules using Method Security SpEL expressions(#authorization-expressions) . There are a number of ways that you can instead allow your logic to be Java-based instead of SpEL-based. This gives use access the entire Java language for increased testability and flow control. Using a Custom Bean in SpEL: The first way to authorize a method programmatically is a two-step process. First, declare a bean that has a method that takes a MethodSecurityExpressionOperations instance like the following: Java Kotlin @Component(""authz"") public class AuthorizationLogic { public boolean decide(MethodSecurityExpressionOperations operations) { // ... authorization logic } } @Component(""authz"") open class AuthorizationLogic { fun decide(val operations: MethodSecurityExpressionOperations): boolean { // ... authorization logic } } Then, reference that bean in your annotations in the following way: Java Kotlin @Controller public class MyController { @PreAuthorize(""@authz.decide(#root)"") @GetMapping(""/endpoint"") public String endpoint() { // ... } } @Controller open class MyController { @PreAuthorize(""@authz.decide(#root)"") @GetMapping(""/endpoint"") fun String endpoint() { // ... } } Spring Security will invoke the given method on that bean for each method invocation. What’s nice about this is all your authorization logic is in a separate class that can be independently unit tested and verified for correctness. It also has access to the full Java language. In addition to returning a Boolean , you can also return null to indicate that the code abstains from making a decision. If you want to include more information about the nature of the decision, you can instead return a custom AuthorizationDecision like this: Java Kotlin @Component(""authz"") public class AuthorizationLogic { public AuthorizationDecision decide(MethodSecurityExpressionOperations operations) { // ... authorization logic return new MyAuthorizationDecision(false, details); } } @Component(""authz"") open class AuthorizationLogic { fun decide(val operations: MethodSecurityExpressionOperations): AuthorizationDecision { // ... authorization logic return MyAuthorizationDecision(false, details) } } Or throw a custom AuthorizationDeniedException instance. Note, though, that returning an object is preferred as this doesn’t incur the expense of generating a stacktrace. Then, you can access the custom details when you customize how the authorization result is handled(#fallback-values-authorization-denied) . Using a Custom Authorization Manager: The second way to authorize a method programmatically is to create a custom AuthorizationManager(architecture.html#_the_authorizationmanager) . First, declare an authorization manager instance, perhaps like this one: Java Kotlin @Component public class MyAuthorizationManager implements AuthorizationManager<MethodInvocation>, AuthorizationManager<MethodInvocationResult> { @Override public AuthorizationDecision check(Supplier<Authentication> authentication, MethodInvocation invocation) { // ... authorization logic } @Override public AuthorizationDecision check(Supplier<Authentication> authentication, MethodInvocationResult invocation) { // ... authorization logic } } @Component class MyAuthorizationManager : AuthorizationManager<MethodInvocation>, AuthorizationManager<MethodInvocationResult> { override fun check(authentication: Supplier<Authentication>, invocation: MethodInvocation): AuthorizationDecision { // ... authorization logic } override fun check(authentication: Supplier<Authentication>, invocation: MethodInvocationResult): AuthorizationDecision { // ... authorization logic } } Then, publish the method interceptor with a pointcut that corresponds to when you want that AuthorizationManager to run. For example, you could replace how @PreAuthorize and @PostAuthorize work like so: Only @PreAuthorize and @PostAuthorize Configuration Java Kotlin Xml @Configuration @EnableMethodSecurity(prePostEnabled = false) class MethodSecurityConfig { @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) Advisor preAuthorize(MyAuthorizationManager manager) { return AuthorizationManagerBeforeMethodInterceptor.preAuthorize(manager); } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) Advisor postAuthorize(MyAuthorizationManager manager) { return AuthorizationManagerAfterMethodInterceptor.postAuthorize(manager); } } @Configuration @EnableMethodSecurity(prePostEnabled = false) class MethodSecurityConfig { @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) fun preAuthorize(val manager: MyAuthorizationManager) : Advisor { return AuthorizationManagerBeforeMethodInterceptor.preAuthorize(manager) } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) fun postAuthorize(val manager: MyAuthorizationManager) : Advisor { return AuthorizationManagerAfterMethodInterceptor.postAuthorize(manager) } } <sec:method-security pre-post-enabled=""false""/> <aop:config/> <bean id=""preAuthorize"" class=""org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor"" factory-method=""preAuthorize""> <constructor-arg ref=""myAuthorizationManager""/> </bean> <bean id=""postAuthorize"" class=""org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor"" factory-method=""postAuthorize""> <constructor-arg ref=""myAuthorizationManager""/> </bean> You can place your interceptor in between Spring Security method interceptors using the order constants specified in AuthorizationInterceptorsOrder . Customizing Expression Handling: Or, third, you can customize how each SpEL expression is handled. To do that, you can expose a custom MethodSecurityExpressionHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org.springframework.security.access.expression.method.MethodSecurityExpressionHandler.html) , like so: Custom MethodSecurityExpressionHandler Java Kotlin Xml @Bean static MethodSecurityExpressionHandler methodSecurityExpressionHandler(RoleHierarchy roleHierarchy) { DefaultMethodSecurityExpressionHandler handler = new DefaultMethodSecurityExpressionHandler(); handler.setRoleHierarchy(roleHierarchy); return handler; } companion object { @Bean fun methodSecurityExpressionHandler(val roleHierarchy: RoleHierarchy) : MethodSecurityExpressionHandler { val handler = DefaultMethodSecurityExpressionHandler() handler.setRoleHierarchy(roleHierarchy) return handler } } <sec:method-security> <sec:expression-handler ref=""myExpressionHandler""/> </sec:method-security> <bean id=""myExpressionHandler"" class=""org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandler""> <property name=""roleHierarchy"" ref=""roleHierarchy""/> </bean> We expose MethodSecurityExpressionHandler using a static method to ensure that Spring publishes it before it initializes Spring Security’s method security @Configuration classes You can also subclass DefaultMessageSecurityExpressionHandler(#subclass-defaultmethodsecurityexpressionhandler) to add your own custom authorization expressions beyond the defaults. Authorizing with AspectJ: Matching Methods with Custom Pointcuts: Being built on Spring AOP, you can declare patterns that are not related to annotations, similar to request-level authorization(authorize-http-requests.html) . This has the potential advantage of centralizing method-level authorization rules. For example, you can use publish your own Advisor or use <protect-pointcut>(../appendix/namespace/method-security.html#nsa-protect-pointcut) to match AOP expressions to authorization rules for your service layer like so: Java Kotlin Xml import static org.springframework.security.authorization.AuthorityAuthorizationManager.hasRole @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) static Advisor protectServicePointcut() { AspectJExpressionPointcut pattern = new AspectJExpressionPointcut() pattern.setExpression(""execution(* com.mycompany.*Service.*(..))"") return new AuthorizationManagerBeforeMethodInterceptor(pattern, hasRole(""USER"")) } import static org.springframework.security.authorization.AuthorityAuthorizationManager.hasRole companion object { @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) fun protectServicePointcut(): Advisor { val pattern = AspectJExpressionPointcut() pattern.setExpression(""execution(* com.mycompany.*Service.*(..))"") return new AuthorizationManagerBeforeMethodInterceptor(pattern, hasRole(""USER"")) } } <sec:method-security> <protect-pointcut expression=""execution(* com.mycompany.*Service.*(..))"" access=""hasRole('USER')""/> </sec:method-security> Integrate with AspectJ Byte-weaving: Performance can at times be enhanced by using AspectJ to weave Spring Security advice into the byte code of your beans. After setting up AspectJ, you can quite simply state in the @EnableMethodSecurity annotation or <method-security> element that you are using AspectJ: Java Kotlin Xml @EnableMethodSecurity(mode=AdviceMode.ASPECTJ) @EnableMethodSecurity(mode=AdviceMode.ASPECTJ) <sec:method-security mode=""aspectj""/> And the result will be that Spring Security will publish its advisors as AspectJ advice so that they can be woven in accordingly. Specifying Order: As already noted, there is a Spring AOP method interceptor for each annotation, and each of these has a location in the Spring AOP advisor chain. Namely, the @PreFilter method interceptor’s order is 100, @PreAuthorize 's is 200, and so on. The reason this is important to note is that there are other AOP-based annotations like @EnableTransactionManagement that have an order of Integer.MAX_VALUE . In other words, they are located at the end of the advisor chain by default. At times, it can be valuable to have other advice execute before Spring Security. For example, if you have a method annotated with @Transactional and @PostAuthorize , you might want the transaction to still be open when @PostAuthorize runs so that an AccessDeniedException will cause a rollback. To get @EnableTransactionManagement to open a transaction before method authorization advice runs, you can set @EnableTransactionManagement 's order like so: Java Kotlin Xml @EnableTransactionManagement(order = 0) @EnableTransactionManagement(order = 0) <tx:annotation-driven ref=""txManager"" order=""0""/> Since the earliest method interceptor ( @PreFilter ) is set to an order of 100, a setting of zero means that the transaction advice will run before all Spring Security advice. Expressing Authorization with SpEL: You’ve already seen several examples using SpEL, so now let’s cover the API a bit more in depth. Spring Security encapsulates all of its authorization fields and methods in a set of root objects. The most generic root object is called SecurityExpressionRoot and it forms the basis for MethodSecurityExpressionRoot . Spring Security supplies this root object to MethodSecurityEvaluationContext when preparing to evaluate an authorization expression. Using Authorization Expression Fields and Methods: The first thing this provides is an enhanced set of authorization fields and methods to your SpEL expressions. What follows is a quick overview of the most common methods: permitAll - The method requires no authorization to be invoked; note that in this case, the Authentication(../authentication/architecture.html#servlet-authentication-authentication) is never retrieved from the session denyAll - The method is not allowed under any circumstances; note that in this case, the Authentication is never retrieved from the session hasAuthority - The method requires that the Authentication have a GrantedAuthority(architecture.html#authz-authorities) that matches the given value hasRole - A shortcut for hasAuthority that prefixes ROLE_ or whatever is configured as the default prefix hasAnyAuthority - The method requires that the Authentication have a GrantedAuthority that matches any of the given values hasAnyRole - A shortcut for hasAnyAuthority that prefixes ROLE_ or whatever is configured as the default prefix hasPermission - A hook into your PermissionEvaluator instance for doing object-level authorization And here is a brief look at the most common fields: authentication - The Authentication instance associated with this method invocation principal - The Authentication#getPrincipal associated with this method invocation Having now learned the patterns, rules, and how they can be paired together, you should be able to understand what is going on in this more complex example: Authorize Requests Java Kotlin Xml @Component public class MyService { @PreAuthorize(""denyAll"") (1) MyResource myDeprecatedMethod(...); @PreAuthorize(""hasRole('ADMIN')"") (2) MyResource writeResource(...) @PreAuthorize(""hasAuthority('db') and hasRole('ADMIN')"") (3) MyResource deleteResource(...) @PreAuthorize(""principal.claims['aud'] == 'my-audience'"") (4) MyResource readResource(...); @PreAuthorize(""@authz.check(authentication, #root)"") MyResource shareResource(...); } @Component open class MyService { @PreAuthorize(""denyAll"") (1) fun myDeprecatedMethod(...): MyResource @PreAuthorize(""hasRole('ADMIN')"") (2) fun writeResource(...): MyResource @PreAuthorize(""hasAuthority('db') and hasRole('ADMIN')"") (3) fun deleteResource(...): MyResource @PreAuthorize(""principal.claims['aud'] == 'my-audience'"") (4) fun readResource(...): MyResource @PreAuthorize(""@authz.check(#root)"") fun shareResource(...): MyResource } <sec:method-security> <protect-pointcut expression=""execution(* com.mycompany.*Service.myDeprecatedMethod(..))"" access=""denyAll""/> (1) <protect-pointcut expression=""execution(* com.mycompany.*Service.writeResource(..))"" access=""hasRole('ADMIN')""/> (2) <protect-pointcut expression=""execution(* com.mycompany.*Service.deleteResource(..))"" access=""hasAuthority('db') and hasRole('ADMIN')""/> (3) <protect-pointcut expression=""execution(* com.mycompany.*Service.readResource(..))"" access=""principal.claims['aud'] == 'my-audience'""/> (4) <protect-pointcut expression=""execution(* com.mycompany.*Service.shareResource(..))"" access=""@authz.check(#root)""/> (5) </sec:method-security> 1 This method may not be invoked by anyone for any reason 2 This method may only be invoked by Authentication s granted the ROLE_ADMIN authority 3 This method may only be invoked by Authentication s granted the db and ROLE_ADMIN authorities 4 This method may only be invoked by Princpal s with an aud claim equal to ""my-audience"" 5 This method may only be invoked if the bean authz 's check method returns true You can use a bean like authz above to add programmatic authorization(#_using_a_custom_bean_in_spel) . Using Method Parameters: Additionally, Spring Security provides a mechanism for discovering method parameters so they can also be accessed in the SpEL expression as well. For a complete reference, Spring Security uses DefaultSecurityParameterNameDiscoverer to discover the parameter names. By default, the following options are tried for a method. If Spring Security’s @P annotation is present on a single argument to the method, the value is used. The following example uses the @P annotation: Java Kotlin import org.springframework.security.access.method.P; ... @PreAuthorize(""hasPermission(#c, 'write')"") public void updateContact(@P(""c"") Contact contact); import org.springframework.security.access.method.P ... @PreAuthorize(""hasPermission(#c, 'write')"") fun doSomething(@P(""c"") contact: Contact?) The intention of this expression is to require that the current Authentication have write permission specifically for this Contact instance. Behind the scenes, this is implemented by using AnnotationParameterNameDiscoverer , which you can customize to support the value attribute of any specified annotation. If Spring Data’s(../integrations/data.html) @Param annotation is present on at least one parameter for the method, the value is used. The following example uses the @Param annotation: Java Kotlin import org.springframework.data.repository.query.Param; ... @PreAuthorize(""#n == authentication.name"") Contact findContactByName(@Param(""n"") String name); import org.springframework.data.repository.query.Param ... @PreAuthorize(""#n == authentication.name"") fun findContactByName(@Param(""n"") name: String?): Contact? The intention of this expression is to require that name be equal to Authentication#getName for the invocation to be authorized. Behind the scenes, this is implemented by using AnnotationParameterNameDiscoverer , which you can customize to support the value attribute of any specified annotation. If you compile your code with the -parameters argument, the standard JDK reflection API is used to discover the parameter names. This works on both classes and interfaces. Finally, if you compile your code with debug symbols, the parameter names are discovered by using the debug symbols. This does not work for interfaces, since they do not have debug information about the parameter names. For interfaces, either annotations or the -parameters approach must be used. Authorizing Arbitrary Objects: Spring Security also supports wrapping any object that is annotated its method security annotations. The simplest way to achieve this is to mark any method that returns the object you wish to authorize with the @AuthorizeReturnObject annotation. For example, consider the following User class: Java Kotlin public class User { private String name; private String email; public User(String name, String email) { this.name = name; this.email = email; } public String getName() { return this.name; } @PreAuthorize(""hasAuthority('user:read')"") public String getEmail() { return this.email; } } class User (val name:String, @get:PreAuthorize(""hasAuthority('user:read')"") val email:String) Given an interface like this one: Java Kotlin public class UserRepository { @AuthorizeReturnObject Optional<User> findByName(String name) { // ... } } class UserRepository { @AuthorizeReturnObject fun findByName(name:String?): Optional<User?>? { // ... } } Then any User that is returned from findById will be secured like other Spring Security-protected components: Java Kotlin @Autowired UserRepository users; @Test void getEmailWhenProxiedThenAuthorizes() { Optional<User> securedUser = users.findByName(""name""); assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(() -> securedUser.get().getEmail()); } import jdk.incubator.vector.VectorOperators.Test import java.nio.file.AccessDeniedException import java.util.* @Autowired var users:UserRepository? = null @Test fun getEmailWhenProxiedThenAuthorizes() { val securedUser: Optional<User> = users.findByName(""name"") assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy{securedUser.get().getEmail()} } Using @AuthorizeReturnObject at the class level: @AuthorizeReturnObject can be placed at the class level. Note, though, that this means Spring Security will attempt to proxy any return object, including String , Integer and other types. This is often not what you want to do. If you want to use @AuthorizeReturnObject on a class or interface whose methods return value types, like int , String , Double or collections of those types, then you should also publish the appropriate AuthorizationAdvisorProxyFactory.TargetVisitor as follows: Java Kotlin @Bean static Customizer<AuthorizationAdvisorProxyFactory> skipValueTypes() { return (factory) -> factory.setTargetVisitor(TargetVisitor.defaultsSkipValueTypes()); } @Bean open fun skipValueTypes() = Customizer<AuthorizationAdvisorProxyFactory> { it.setTargetVisitor(TargetVisitor.defaultsSkipValueTypes()) } You can set your own AuthorizationAdvisorProxyFactory.TargetVisitor to customize the proxying for any set of types Programmatically Proxying: You can also programmatically proxy a given object. To achieve this, you can autowire the provided AuthorizationProxyFactory instance, which is based on which method security interceptors you have configured. If you are using @EnableMethodSecurity , then this means that it will by default have the interceptors for @PreAuthorize , @PostAuthorize , @PreFilter , and @PostFilter . You can proxy an instance of user in the following way: Java Kotlin @Autowired AuthorizationProxyFactory proxyFactory; @Test void getEmailWhenProxiedThenAuthorizes() { User user = new User(""name"", ""email""); assertThat(user.getEmail()).isNotNull(); User securedUser = proxyFactory.proxy(user); assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(securedUser::getEmail); } @Autowired var proxyFactory:AuthorizationProxyFactory? = null @Test fun getEmailWhenProxiedThenAuthorizes() { val user: User = User(""name"", ""email"") assertThat(user.getEmail()).isNotNull() val securedUser: User = proxyFactory.proxy(user) assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy(securedUser::getEmail) } Manual Construction: You can also define your own instance if you need something different from the Spring Security default. For example, if you define an AuthorizationProxyFactory instance like so: Java Kotlin import org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory.TargetVisitor; import static org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor.preAuthorize; // ... AuthorizationProxyFactory proxyFactory = AuthorizationAdvisorProxyFactory.withDefaults(); // and if needing to skip value types proxyFactory.setTargetVisitor(TargetVisitor.defaultsSkipValueTypes()); import org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory.TargetVisitor; import org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor.preAuthorize // ... val proxyFactory: AuthorizationProxyFactory = AuthorizationProxyFactory(preAuthorize()) // and if needing to skip value types proxyFactory.setTargetVisitor(TargetVisitor.defaultsSkipValueTypes()) Then you can wrap any instance of User as follows: Java Kotlin @Test void getEmailWhenProxiedThenAuthorizes() { AuthorizationProxyFactory proxyFactory = AuthorizationAdvisorProxyFactory.withDefaults(); User user = new User(""name"", ""email""); assertThat(user.getEmail()).isNotNull(); User securedUser = proxyFactory.proxy(user); assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(securedUser::getEmail); } @Test fun getEmailWhenProxiedThenAuthorizes() { val proxyFactory: AuthorizationProxyFactory = AuthorizationAdvisorProxyFactory.withDefaults() val user: User = User(""name"", ""email"") assertThat(user.getEmail()).isNotNull() val securedUser: User = proxyFactory.proxy(user) assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy(securedUser::getEmail) } This feature does not yet support Spring AOT Proxying Collections: AuthorizationProxyFactory supports Java collections, streams, arrays, optionals, and iterators by proxying the element type and maps by proxying the value type. This means that when proxying a List of objects, the following also works: Java @Test void getEmailWhenProxiedThenAuthorizes() { AuthorizationProxyFactory proxyFactory = AuthorizationAdvisorProxyFactory.withDefaults(); List<User> users = List.of(ada, albert, marie); List<User> securedUsers = proxyFactory.proxy(users); securedUsers.forEach((securedUser) -> assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(securedUser::getEmail)); } Proxying Classes: In limited circumstances, it may be valuable to proxy a Class itself, and AuthorizationProxyFactory also supports this. This is roughly the equivalent of calling ProxyFactory#getProxyClass in Spring Framework’s support for creating proxies. One place where this is handy is when you need to construct the proxy class ahead-of-time, like with Spring AOT. Support for All Method Security Annotations: AuthorizationProxyFactory supports whichever method security annotations are enabled in your application. It is based off of whatever AuthorizationAdvisor classes are published as a bean. Since @EnableMethodSecurity publishes @PreAuthorize , @PostAuthorize , @PreFilter , and @PostFilter advisors by default, you will typically need to do nothing to activate the ability. SpEL expressions that use returnObject or filterObject sit behind the proxy and so have full access to the object. Custom Advice: If you have security advice that you also want applied, you can publish your own AuthorizationAdvisor like so: Java Kotlin @EnableMethodSecurity class SecurityConfig { @Bean static AuthorizationAdvisor myAuthorizationAdvisor() { return new AuthorizationAdvisor(); } } @EnableMethodSecurity internal class SecurityConfig { @Bean fun myAuthorizationAdvisor(): AuthorizationAdvisor { return AuthorizationAdvisor() } ] And Spring Security will add that advisor into the set of advice that AuthorizationProxyFactory adds when proxying an object. Working with Jackson: One powerful use of this feature is to return a secured value from a controller like so: Java Kotlin @RestController public class UserController { @Autowired AuthorizationProxyFactory proxyFactory; @GetMapping User currentUser(@AuthenticationPrincipal User user) { return this.proxyFactory.proxy(user); } } @RestController class UserController { @Autowired var proxyFactory: AuthorizationProxyFactory? = null @GetMapping fun currentUser(@AuthenticationPrincipal user:User?): User { return proxyFactory.proxy(user) } } If you are using Jackson, though, this may result in a serialization error like the following: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Direct self-reference leading to cycle This is due to how Jackson works with CGLIB proxies. To address this, add the following annotation to the top of the User class: Java Kotlin @JsonSerialize(as = User.class) public class User { } @JsonSerialize(`as` = User::class) class User Finally, you will need to publish a custom interceptor(#custom_advice) to catch the AccessDeniedException thrown for each field, which you can do like so: Java Kotlin @Component public class AccessDeniedExceptionInterceptor implements AuthorizationAdvisor { private final AuthorizationAdvisor advisor = AuthorizationManagerBeforeMethodInterceptor.preAuthorize(); @Override public Object invoke(MethodInvocation invocation) throws Throwable { try { return invocation.proceed(); } catch (AccessDeniedException ex) { return null; } } @Override public Pointcut getPointcut() { return this.advisor.getPointcut(); } @Override public Advice getAdvice() { return this; } @Override public int getOrder() { return this.advisor.getOrder() - 1; } } @Component class AccessDeniedExceptionInterceptor: AuthorizationAdvisor { var advisor: AuthorizationAdvisor = AuthorizationManagerBeforeMethodInterceptor.preAuthorize() @Throws(Throwable::class) fun invoke(invocation: MethodInvocation): Any? { return try { invocation.proceed() } catch (ex:AccessDeniedException) { null } } val pointcut: Pointcut get() = advisor.getPointcut() val advice: Advice get() = this val order: Int get() = advisor.getOrder() - 1 } Then, you’ll see a different JSON serialization based on the authorization level of the user. If they don’t have the user:read authority, then they’ll see: { ""name"" : ""name"", ""email"" : null } And if they do have that authority, they’ll see: { ""name"" : ""name"", ""email"" : ""email"" } You can also add the Spring Boot property spring.jackson.default-property-inclusion=non_null to exclude the null value, if you also don’t want to reveal the JSON key to an unauthorized user. Providing Fallback Values When Authorization is Denied: There are some scenarios where you may not wish to throw an AuthorizationDeniedException when a method is invoked without the required permissions. Instead, you might wish to return a post-processed result, like a masked result, or a default value in cases where authorization denied happened before invoking the method. Spring Security provides support for handling authorization denied on method invocation by using the @HandleAuthorizationDenied(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/HandleAuthorizationDenied.html) . The handler works for denied authorizations that happened in the @PreAuthorize and @PostAuthorize annotations(#authorizing-with-annotations) as well as AuthorizationDeniedException(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/AuthorizationDeniedException.html) thrown from the method invocation itself. Let’s consider the example from the previous section(#authorize-object) , but instead of creating the AccessDeniedExceptionInterceptor to transform an AccessDeniedException to a null return value, we will use the handlerClass attribute from @HandleAuthorizationDenied : Java Kotlin public class NullMethodAuthorizationDeniedHandler implements MethodAuthorizationDeniedHandler { (1) @Override public Object handleDeniedInvocation(MethodInvocation methodInvocation, AuthorizationResult authorizationResult) { return null; } } @Configuration @EnableMethodSecurity public class SecurityConfig { @Bean (2) public NullMethodAuthorizationDeniedHandler nullMethodAuthorizationDeniedHandler() { return new NullMethodAuthorizationDeniedHandler(); } } public class User { // ... @PreAuthorize(value = ""hasAuthority('user:read')"") @HandleAuthorizationDenied(handlerClass = NullMethodAuthorizationDeniedHandler.class) public String getEmail() { return this.email; } } class NullMethodAuthorizationDeniedHandler : MethodAuthorizationDeniedHandler { (1) override fun handleDeniedInvocation(methodInvocation: MethodInvocation, authorizationResult: AuthorizationResult): Any { return null } } @Configuration @EnableMethodSecurity class SecurityConfig { @Bean (2) fun nullMethodAuthorizationDeniedHandler(): NullMethodAuthorizationDeniedHandler { return MaskMethodAuthorizationDeniedHandler() } } class User (val name:String, @PreAuthorize(value = ""hasAuthority('user:read')"") @HandleAuthorizationDenied(handlerClass = NullMethodAuthorizationDeniedHandler::class) val email:String) (3) 1 Create an implementation of MethodAuthorizationDeniedHandler that returns a null value 2 Register the NullMethodAuthorizationDeniedHandler as a bean 3 Annotate the method with @HandleAuthorizationDenied and pass the NullMethodAuthorizationDeniedHandler to the handlerClass attribute And then you can verify that a null value is returned instead of the AccessDeniedException : You can also annotate your class with @Component instead of creating a @Bean method Java Kotlin @Autowired UserRepository users; @Test void getEmailWhenProxiedThenNullEmail() { Optional<User> securedUser = users.findByName(""name""); assertThat(securedUser.get().getEmail()).isNull(); } @Autowired var users:UserRepository? = null @Test fun getEmailWhenProxiedThenNullEmail() { val securedUser: Optional<User> = users.findByName(""name"") assertThat(securedUser.get().getEmail()).isNull() } Using the Denied Result From the Method Invocation: There are some scenarios where you might want to return a secure result derived from the denied result. For example, if a user is not authorized to see email addresses, you might want to apply some masking on the original email address, i.e. [email protected](/cdn-cgi/l/email-protection) would become use******@example.com . For those scenarios, you can override the handleDeniedInvocationResult from the MethodAuthorizationDeniedHandler , which has the MethodInvocationResult(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/authorization/method/MethodInvocationResult.html) as an argument. Let’s continue with the previous example, but instead of returning null , we will return a masked value of the email: Java Kotlin public class EmailMaskingMethodAuthorizationDeniedHandler implements MethodAuthorizationDeniedHandler { (1) @Override public Object handleDeniedInvocation(MethodInvocation methodInvocation, AuthorizationResult authorizationResult) { return ""***""; } @Override public Object handleDeniedInvocationResult(MethodInvocationResult methodInvocationResult, AuthorizationResult authorizationResult) { String email = (String) methodInvocationResult.getResult(); return email.replaceAll(""(^[^@]{3}|(?!^)\\G)[^@]"", ""$1*""); } } @Configuration @EnableMethodSecurity public class SecurityConfig { @Bean (2) public EmailMaskingMethodAuthorizationDeniedHandler emailMaskingMethodAuthorizationDeniedHandler() { return new EmailMaskingMethodAuthorizationDeniedHandler(); } } public class User { // ... @PostAuthorize(value = ""hasAuthority('user:read')"") @HandleAuthorizationDenied(handlerClass = EmailMaskingMethodAuthorizationDeniedHandler.class) public String getEmail() { return this.email; } } class EmailMaskingMethodAuthorizationDeniedHandler : MethodAuthorizationDeniedHandler { override fun handleDeniedInvocation(methodInvocation: MethodInvocation, authorizationResult: AuthorizationResult): Any { return ""***"" } override fun handleDeniedInvocationResult(methodInvocationResult: MethodInvocationResult, authorizationResult: AuthorizationResult): Any { val email = methodInvocationResult.result as String return email.replace(""(^[^@]{3}|(?!^)\\G)[^@]"".toRegex(), ""$1*"") } } @Configuration @EnableMethodSecurity class SecurityConfig { @Bean fun emailMaskingMethodAuthorizationDeniedHandler(): EmailMaskingMethodAuthorizationDeniedHandler { return EmailMaskingMethodAuthorizationDeniedHandler() } } class User (val name:String, @PostAuthorize(value = ""hasAuthority('user:read')"") @HandleAuthorizationDenied(handlerClass = EmailMaskingMethodAuthorizationDeniedHandler::class) val email:String) (3) 1 Create an implementation of MethodAuthorizationDeniedHandler that returns a masked value of the unauthorized result value 2 Register the EmailMaskingMethodAuthorizationDeniedHandler as a bean 3 Annotate the method with @HandleAuthorizationDenied and pass the EmailMaskingMethodAuthorizationDeniedHandler to the handlerClass attribute And then you can verify that a masked email is returned instead of an AccessDeniedException : Since you have access to the original denied value, make sure that you correctly handle it and do not return it to the caller. Java Kotlin @Autowired UserRepository users; @Test void getEmailWhenProxiedThenMaskedEmail() { Optional<User> securedUser = users.findByName(""name""); // email is [email protected](/cdn-cgi/l/email-protection) assertThat(securedUser.get().getEmail()).isEqualTo(""use******@example.com""); } @Autowired var users:UserRepository? = null @Test fun getEmailWhenProxiedThenMaskedEmail() { val securedUser: Optional<User> = users.findByName(""name"") // email is [email protected](/cdn-cgi/l/email-protection) assertThat(securedUser.get().getEmail()).isEqualTo(""use******@example.com"") } When implementing the MethodAuthorizationDeniedHandler you have a few options on what type you can return: A null value. A non-null value, respecting the method’s return type. Throw an exception, usually an instance of AuthorizationDeniedException . This is the default behavior. A Mono type for reactive applications. Note that since the handler must be registered as beans in your application context, you can inject dependencies into them if you need a more complex logic. In addition to that, you have available the MethodInvocation or the MethodInvocationResult , as well as the AuthorizationResult for more details related to the authorization decision. Deciding What to Return Based on Available Parameters: Consider a scenario where there might be multiple mask values for different methods, it would be not so productive if we had to create a handler for each of those methods, although it is perfectly fine to do that. In such cases, we can use the information passed via parameters to decide what to do. For example, we can create a custom @Mask annotation and a handler that detects that annotation to decide what mask value to return: Java Kotlin import org.springframework.core.annotation.AnnotationUtils; @Target({ ElementType.METHOD, ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) public @interface Mask { String value(); } public class MaskAnnotationDeniedHandler implements MethodAuthorizationDeniedHandler { @Override public Object handleDeniedInvocation(MethodInvocation methodInvocation, AuthorizationResult authorizationResult) { Mask mask = AnnotationUtils.getAnnotation(methodInvocation.getMethod(), Mask.class); return mask.value(); } } @Configuration @EnableMethodSecurity public class SecurityConfig { @Bean public MaskAnnotationDeniedHandler maskAnnotationDeniedHandler() { return new MaskAnnotationDeniedHandler(); } } @Component public class MyService { @PreAuthorize(value = ""hasAuthority('user:read')"") @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler.class) @Mask(""***"") public String foo() { return ""foo""; } @PreAuthorize(value = ""hasAuthority('user:read')"") @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler.class) @Mask(""???"") public String bar() { return ""bar""; } } import org.springframework.core.annotation.AnnotationUtils @Target(AnnotationTarget.FUNCTION, AnnotationTarget.CLASS) @Retention(AnnotationRetention.RUNTIME) annotation class Mask(val value: String) class MaskAnnotationDeniedHandler : MethodAuthorizationDeniedHandler { override fun handleDeniedInvocation(methodInvocation: MethodInvocation, authorizationResult: AuthorizationResult): Any { val mask = AnnotationUtils.getAnnotation(methodInvocation.method, Mask::class.java) return mask.value } } @Configuration @EnableMethodSecurity class SecurityConfig { @Bean fun maskAnnotationDeniedHandler(): MaskAnnotationDeniedHandler { return MaskAnnotationDeniedHandler() } } @Component class MyService { @PreAuthorize(value = ""hasAuthority('user:read')"") @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler::class) @Mask(""***"") fun foo(): String { return ""foo"" } @PreAuthorize(value = ""hasAuthority('user:read')"") @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler::class) @Mask(""???"") fun bar(): String { return ""bar"" } } Now the return values when access is denied will be decided based on the @Mask annotation: Java Kotlin @Autowired MyService myService; @Test void fooWhenDeniedThenReturnStars() { String value = this.myService.foo(); assertThat(value).isEqualTo(""***""); } @Test void barWhenDeniedThenReturnQuestionMarks() { String value = this.myService.foo(); assertThat(value).isEqualTo(""???""); } @Autowired var myService: MyService @Test fun fooWhenDeniedThenReturnStars() { val value: String = myService.foo() assertThat(value).isEqualTo(""***"") } @Test fun barWhenDeniedThenReturnQuestionMarks() { val value: String = myService.foo() assertThat(value).isEqualTo(""???"") } Combining with Meta Annotation Support: You can also combine the @HandleAuthorizationDenied with other annotations in order to reduce and simplify the annotations in a method. Let’s consider the example from the previous section(#deciding-return-based-parameters) and merge @HandleAuthorizationDenied with @Mask : Java Kotlin @Target({ ElementType.METHOD, ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler.class) public @interface Mask { String value(); } @Mask(""***"") public String myMethod() { // ... } @Target(AnnotationTarget.FUNCTION, AnnotationTarget.CLASS) @Retention(AnnotationRetention.RUNTIME) @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler::class) annotation class Mask(val value: String) @Mask(""***"") fun myMethod(): String { // ... } Now you do not have to remember to add both annotations when you need a mask behavior in your method. Make sure to read the Meta Annotations Support(#meta-annotations) section for more details on the usage. Migrating from @EnableGlobalMethodSecurity: If you are using @EnableGlobalMethodSecurity , you should migrate to @EnableMethodSecurity . Replace global method security with method security: @EnableGlobalMethodSecurity(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/config/annotation/method/configuration/EnableGlobalMethodSecurity.html) and <global-method-security>(../appendix/namespace/method-security.html#nsa-global-method-security) are deprecated in favor of @EnableMethodSecurity(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/config/annotation/method/configuration/EnableMethodSecurity.html) and <method-security>(../appendix/namespace/method-security.html#nsa-method-security) , respectively. The new annotation and XML element activate Spring’s pre-post annotations(#jc-enable-method-security) by default and use AuthorizationManager internally. This means that the following two listings are functionally equivalent: Java Kotlin Xml @EnableGlobalMethodSecurity(prePostEnabled = true) @EnableGlobalMethodSecurity(prePostEnabled = true) <global-method-security pre-post-enabled=""true""/> and: Java Kotlin Xml @EnableMethodSecurity @EnableMethodSecurity <method-security/> For applications not using the pre-post annotations, make sure to turn it off to avoid activating unwanted behavior. For example, a listing like: Java Kotlin Xml @EnableGlobalMethodSecurity(securedEnabled = true) @EnableGlobalMethodSecurity(securedEnabled = true) <global-method-security secured-enabled=""true""/> should change to: Java Kotlin Xml @EnableMethodSecurity(securedEnabled = true, prePostEnabled = false) @EnableMethodSecurity(securedEnabled = true, prePostEnabled = false) <method-security secured-enabled=""true"" pre-post-enabled=""false""/> Use a Custom @Bean instead of subclassing DefaultMethodSecurityExpressionHandler: As a performance optimization, a new method was introduced to MethodSecurityExpressionHandler that takes a Supplier<Authentication> instead of an Authentication . This allows Spring Security to defer the lookup of the Authentication , and is taken advantage of automatically when you use @EnableMethodSecurity instead of @EnableGlobalMethodSecurity . However, let’s say that your code extends DefaultMethodSecurityExpressionHandler and overrides createSecurityExpressionRoot(Authentication, MethodInvocation) to return a custom SecurityExpressionRoot instance. This will no longer work because the arrangement that @EnableMethodSecurity sets up calls createEvaluationContext(Supplier<Authentication>, MethodInvocation) instead. Happily, such a level of customization is often unnecessary. Instead, you can create a custom bean with the authorization methods that you need. For example, let’s say you are wanting a custom evaluation of @PostAuthorize(""hasAuthority('ADMIN')"") . You can create a custom @Bean like this one: Java Kotlin class MyAuthorizer { boolean isAdmin(MethodSecurityExpressionOperations root) { boolean decision = root.hasAuthority(""ADMIN""); // custom work ... return decision; } } class MyAuthorizer { fun isAdmin(val root: MethodSecurityExpressionOperations): boolean { val decision = root.hasAuthority(""ADMIN""); // custom work ... return decision; } } and then refer to it in the annotation like so: Java Kotlin @PreAuthorize(""@authz.isAdmin(#root)"") @PreAuthorize(""@authz.isAdmin(#root)"") I’d still prefer to subclass DefaultMethodSecurityExpressionHandler: If you must continue subclassing DefaultMethodSecurityExpressionHandler , you can still do so. Instead, override the createEvaluationContext(Supplier<Authentication>, MethodInvocation) method like so: Java Kotlin @Component class MyExpressionHandler extends DefaultMethodSecurityExpressionHandler { @Override public EvaluationContext createEvaluationContext(Supplier<Authentication> authentication, MethodInvocation mi) { StandardEvaluationContext context = (StandardEvaluationContext) super.createEvaluationContext(authentication, mi); MethodSecurityExpressionOperations delegate = (MethodSecurityExpressionOperations) context.getRootObject().getValue(); MySecurityExpressionRoot root = new MySecurityExpressionRoot(delegate); context.setRootObject(root); return context; } } @Component class MyExpressionHandler: DefaultMethodSecurityExpressionHandler { override fun createEvaluationContext(val authentication: Supplier<Authentication>, val mi: MethodInvocation): EvaluationContext { val context = super.createEvaluationContext(authentication, mi) as StandardEvaluationContext val delegate = context.getRootObject().getValue() as MethodSecurityExpressionOperations val root = MySecurityExpressionRoot(delegate) context.setRootObject(root) return context } } Further Reading: Now that you have secured your application’s requests, please secure its requests(authorize-http-requests.html) if you haven’t already. You can also read further on testing your application(../test/index.html) or on integrating Spring Security with other aspects of you application like the data layer(../integrations/data.html) or tracing and metrics(../integrations/observability.html) ."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authorization/acls.html","Domain Object Security (ACLs): This section describes how Spring Security provides domain object security with Access Control Lists (ACLs). Complex applications often need to define access permissions beyond a web request or method invocation level. Instead, security decisions need to comprise who ( Authentication ), where ( MethodInvocation ), and what ( SomeDomainObject ). In other words, authorization decisions also need to consider the actual domain object instance subject of a method invocation. Imagine you are designing an application for a pet clinic. There are two main groups of users of your Spring-based application: staff of the pet clinic and the pet clinic’s customers. The staff should have access to all of the data, while your customers should be able to see only their own customer records. To make it a little more interesting, your customers can let other users see their customer records, such as their “puppy preschool” mentor or the president of their local “Pony Club”. When you use Spring Security as the foundation, you have several possible approaches: Write your business methods to enforce the security. You could consult a collection within the Customer domain object instance to determine which users have access. By using SecurityContextHolder.getContext().getAuthentication() , you can access the Authentication object. Write an AccessDecisionVoter to enforce the security from the GrantedAuthority[] instances stored in the Authentication object. This means that your AuthenticationManager needs to populate the Authentication with custom GrantedAuthority[] objects to represent each of the Customer domain object instances to which the principal has access. Write an AccessDecisionVoter to enforce the security and open the target Customer domain object directly. This would mean your voter needs access to a DAO that lets it retrieve the Customer object. It can then access the Customer object’s collection of approved users and make the appropriate decision. Each one of these approaches is perfectly legitimate. However, the first couples your authorization checking to your business code. The main problems with this include the enhanced difficulty of unit testing and the fact that it would be more difficult to reuse the Customer authorization logic elsewhere. Obtaining the GrantedAuthority[] instances from the Authentication object is also fine but will not scale to large numbers of Customer objects. If a user can access 5,000 Customer objects (unlikely in this case, but imagine if it were a popular vet for a large Pony Club!) the amount of memory consumed and the time required to construct the Authentication object would be undesirable. The final method, opening the Customer directly from external code, is probably the best of the three. It achieves separation of concerns and does not misuse memory or CPU cycles, but it is still inefficient in that both the AccessDecisionVoter and the eventual business method itself perform a call to the DAO responsible for retrieving the Customer object. Two accesses per method invocation is clearly undesirable. In addition, with every approach listed, you need to write your own access control list (ACL) persistence and business logic from scratch. Fortunately, there is another alternative, which we discuss later. Key Concepts: Spring Security’s ACL services are shipped in the spring-security-acl-xxx.jar . You need to add this JAR to your classpath to use Spring Security’s domain object instance security capabilities. Spring Security’s domain object instance security capabilities center on the concept of an access control list (ACL). Every domain object instance in your system has its own ACL, and the ACL records details of who can and cannot work with that domain object. With this in mind, Spring Security provides three main ACL-related capabilities to your application: A way to efficiently retrieve ACL entries for all of your domain objects (and modifying those ACLs) A way to ensure a given principal is permitted to work with your objects before methods are called A way to ensure a given principal is permitted to work with your objects (or something they return) after methods are called As indicated by the first bullet point, one of the main capabilities of the Spring Security ACL module is providing a high-performance way of retrieving ACLs. This ACL repository capability is extremely important, because every domain object instance in your system might have several access control entries, and each ACL might inherit from other ACLs in a tree-like structure (this is supported by Spring Security, and it is very commonly used). Spring Security’s ACL capability has been carefully designed to provide high performance retrieval of ACLs, together with pluggable caching, deadlock-minimizing database updates, independence from ORM frameworks (we use JDBC directly), proper encapsulation, and transparent database updating. Given that databases are central to the operation of the ACL module, we need explore the four main tables used by default in the implementation. The tables are presented in order of size in a typical Spring Security ACL deployment, with the table with the most rows listed last: ACL_SID lets us uniquely identify any principal or authority in the system (“SID” stands for “Security IDentity”). The only columns are the ID, a textual representation of the SID, and a flag to indicate whether the textual representation refers to a principal name or a GrantedAuthority . Thus, there is a single row for each unique principal or GrantedAuthority . When used in the context of receiving a permission, an SID is generally called a “recipient”. ACL_CLASS lets us uniquely identify any domain object class in the system. The only columns are the ID and the Java class name. Thus, there is a single row for each unique Class for which we wish to store ACL permissions. ACL_OBJECT_IDENTITY stores information for each unique domain object instance in the system. Columns include the ID, a foreign key to the ACL_CLASS table, a unique identifier so we know the ACL_CLASS instance for which we provide information, the parent, a foreign key to the ACL_SID table to represent the owner of the domain object instance, and whether we allow ACL entries to inherit from any parent ACL. We have a single row for every domain object instance for which we store ACL permissions. Finally, ACL_ENTRY stores the individual permissions assigned to each recipient. Columns include a foreign key to the ACL_OBJECT_IDENTITY , the recipient (i.e. a foreign key to ACL_SID), whether we’ll be auditing or not, and the integer bit mask that represents the actual permission being granted or denied. We have a single row for every recipient that receives a permission to work with a domain object. As mentioned in the last paragraph, the ACL system uses integer bit masking. However, you need not be aware of the finer points of bit shifting to use the ACL system. Suffice it to say that we have 32 bits we can switch on or off. Each of these bits represents a permission. By default, the permissions are read (bit 0), write (bit 1), create (bit 2), delete (bit 3), and administer (bit 4). You can implement your own Permission instance if you wish to use other permissions, and the remainder of the ACL framework operates without knowledge of your extensions. You should understand that the number of domain objects in your system has absolutely no bearing on the fact that we have chosen to use integer bit masking. While you have 32 bits available for permissions, you could have billions of domain object instances (which means billions of rows in ACL_OBJECT_IDENTITY and, probably, ACL_ENTRY). We make this point because we have found that people sometimes mistakenly that believe they need a bit for each potential domain object, which is not the case. Now that we have provided a basic overview of what the ACL system does, and what it looks like at a table-structure level, we need to explore the key interfaces: Acl : Every domain object has one and only one Acl object, which internally holds the AccessControlEntry objects and knows the owner of the Acl . An Acl does not refer directly to the domain object, but instead to an ObjectIdentity . The Acl is stored in the ACL_OBJECT_IDENTITY table. AccessControlEntry : An Acl holds multiple AccessControlEntry objects, which are often abbreviated as ACEs in the framework. Each ACE refers to a specific tuple of Permission , Sid , and Acl . An ACE can also be granting or non-granting and contain audit settings. The ACE is stored in the ACL_ENTRY table. Permission : A permission represents a particular immutable bit mask and offers convenience functions for bit masking and outputting information. The basic permissions presented above (bits 0 through 4) are contained in the BasePermission class. Sid : The ACL module needs to refer to principals and GrantedAuthority[] instances. A level of indirection is provided by the Sid interface. (“SID” is an abbreviation of “Security IDentity”.) Common classes include PrincipalSid (to represent the principal inside an Authentication object) and GrantedAuthoritySid . The security identity information is stored in the ACL_SID table. ObjectIdentity : Each domain object is represented internally within the ACL module by an ObjectIdentity . The default implementation is called ObjectIdentityImpl . AclService : Retrieves the Acl applicable for a given ObjectIdentity . In the included implementation ( JdbcAclService ), retrieval operations are delegated to a LookupStrategy . The LookupStrategy provides a highly optimized strategy for retrieving ACL information, using batched retrievals ( BasicLookupStrategy ) and supporting custom implementations that use materialized views, hierarchical queries, and similar performance-centric, non-ANSI SQL capabilities. MutableAclService : Lets a modified Acl be presented for persistence. Use of this interface is optional. Note that our AclService and related database classes all use ANSI SQL. This should therefore work with all major databases. At the time of writing, the system had been successfully tested with Hypersonic SQL, PostgreSQL, Microsoft SQL Server, and Oracle. Two samples ship with Spring Security that demonstrate the ACL module. The first is the Contacts Sample(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/xml/java/contacts) , and the other is the Document Management System (DMS) Sample(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/xml/java/dms) . We suggest taking a look at these examples. Getting Started: To get starting with Spring Security’s ACL capability, you need to store your ACL information somewhere. This necessitates the instantiation of a DataSource in Spring. The DataSource is then injected into a JdbcMutableAclService and a BasicLookupStrategy instance. The former provides mutator capabilities, and the latter provides high-performance ACL retrieval capabilities. See one of the samples(https://github.com/spring-projects/spring-security-samples/tree/6.3.x) that ship with Spring Security for an example configuration. You also need to populate the database with the four ACL-specific tables(#acl_tables) listed in the previous section (see the ACL samples for the appropriate SQL statements). Once you have created the required schema and instantiated JdbcMutableAclService , you need to ensure your domain model supports interoperability with the Spring Security ACL package. Hopefully, ObjectIdentityImpl proves sufficient, as it provides a large number of ways in which it can be used. Most people have domain objects that contain a public Serializable getId() method. If the return type is long or compatible with long (such as an int ), you may find that you need not give further consideration to ObjectIdentity issues. Many parts of the ACL module rely on long identifiers. If you do not use long (or an int , byte , and so on), you probably need to reimplement a number of classes. We do not intend to support non-long identifiers in Spring Security’s ACL module, as longs are already compatible with all database sequences, are the most common identifier data type, and are of sufficient length to accommodate all common usage scenarios. The following fragment of code shows how to create an Acl or modify an existing Acl : Java Kotlin // Prepare the information we'd like in our access control entry (ACE) ObjectIdentity oi = new ObjectIdentityImpl(Foo.class, new Long(44)); Sid sid = new PrincipalSid(""Samantha""); Permission p = BasePermission.ADMINISTRATION; // Create or update the relevant ACL MutableAcl acl = null; try { acl = (MutableAcl) aclService.readAclById(oi); } catch (NotFoundException nfe) { acl = aclService.createAcl(oi); } // Now grant some permissions via an access control entry (ACE) acl.insertAce(acl.getEntries().length, p, sid, true); aclService.updateAcl(acl); val oi: ObjectIdentity = ObjectIdentityImpl(Foo::class.java, 44) val sid: Sid = PrincipalSid(""Samantha"") val p: Permission = BasePermission.ADMINISTRATION // Create or update the relevant ACL var acl: MutableAcl? = null acl = try { aclService.readAclById(oi) as MutableAcl } catch (nfe: NotFoundException) { aclService.createAcl(oi) } // Now grant some permissions via an access control entry (ACE) acl!!.insertAce(acl.entries.size, p, sid, true) aclService.updateAcl(acl) In the preceding example, we retrieve the ACL associated with the Foo domain object with identifier number 44. We then add an ACE so that a principal named “Samantha” can “administer” the object. The code fragment is relatively self-explanatory, except for the insertAce method. The first argument to the insertAce method determine position in the Acl at which the new entry is inserted. In the preceding example, we put the new ACE at the end of the existing ACEs. The final argument is a Boolean indicating whether the ACE is granting or denying. Most of the time it grants ( true ). However, if it denies ( false ), the permissions are effectively being blocked. Spring Security does not provide any special integration to automatically create, update, or delete ACLs as part of your DAO or repository operations. Instead, you need to write code similar to that shown in the preceding example for your individual domain objects. You should consider using AOP on your services layer to automatically integrate the ACL information with your services layer operations. We have found this approach to be effective. Once you have used the techniques described here to store some ACL information in the database, the next step is to actually use the ACL information as part of authorization decision logic. You have a number of choices here. You could write your own AccessDecisionVoter or AfterInvocationProvider that (respectively) fires before or after a method invocation. Such classes would use AclService to retrieve the relevant ACL and then call Acl.isGranted(Permission[] permission, Sid[] sids, boolean administrativeMode) to decide whether permission is granted or denied. Alternately, you could use our AclEntryVoter , AclEntryAfterInvocationProvider or AclEntryAfterInvocationCollectionFilteringProvider classes. All of these classes provide a declarative-based approach to evaluating ACL information at runtime, freeing you from needing to write any code. See the sample applications(https://github.com/spring-projects/spring-security-samples) to learn how to use these classes."
"https://docs.spring.io/spring-security/reference/6.3/servlet/authorization/events.html","Authorization Events: For each authorization that is denied, an AuthorizationDeniedEvent is fired. Also, it’s possible to fire an AuthorizationGrantedEvent for authorizations that are granted. To listen for these events, you must first publish an AuthorizationEventPublisher . Spring Security’s SpringAuthorizationEventPublisher will probably do fine. It comes publishes authorization events using Spring’s ApplicationEventPublisher : Java Kotlin @Bean public AuthorizationEventPublisher authorizationEventPublisher (ApplicationEventPublisher applicationEventPublisher) { return new SpringAuthorizationEventPublisher(applicationEventPublisher); } @Bean fun authorizationEventPublisher (applicationEventPublisher: ApplicationEventPublisher?): AuthorizationEventPublisher { return SpringAuthorizationEventPublisher(applicationEventPublisher) } Then, you can use Spring’s @EventListener support: Java Kotlin @Component public class AuthenticationEvents { @EventListener public void onFailure(AuthorizationDeniedEvent failure) { // ... } } @Component class AuthenticationEvents { @EventListener fun onFailure(failure: AuthorizationDeniedEvent?) { // ... } } Authorization Granted Events: Because AuthorizationGrantedEvent s have the potential to be quite noisy, they are not published by default. In fact, publishing these events will likely require some business logic on your part to ensure that your application is not inundated with noisy authorization events. You can create your own event publisher that filters success events. For example, the following publisher only publishes authorization grants where ROLE_ADMIN was required: Java Kotlin @Component public class MyAuthorizationEventPublisher implements AuthorizationEventPublisher { private final ApplicationEventPublisher publisher; private final AuthorizationEventPublisher delegate; public MyAuthorizationEventPublisher(ApplicationEventPublisher publisher) { this.publisher = publisher; this.delegate = new SpringAuthorizationEventPublisher(publisher); } @Override public <T> void publishAuthorizationEvent(Supplier<Authentication> authentication, T object, AuthorizationDecision decision) { if (decision == null) { return; } if (!decision.isGranted()) { this.delegate.publishAuthorizationEvent(authentication, object, decision); return; } if (shouldThisEventBePublished(decision)) { AuthorizationGrantedEvent granted = new AuthorizationGrantedEvent( authentication, object, decision); this.publisher.publishEvent(granted); } } private boolean shouldThisEventBePublished(AuthorizationDecision decision) { if (!(decision instanceof AuthorityAuthorizationDecision)) { return false; } Collection<GrantedAuthority> authorities = ((AuthorityAuthorizationDecision) decision).getAuthorities(); for (GrantedAuthority authority : authorities) { if (""ROLE_ADMIN"".equals(authority.getAuthority())) { return true; } } return false; } } @Component class MyAuthorizationEventPublisher(val publisher: ApplicationEventPublisher, val delegate: SpringAuthorizationEventPublisher = SpringAuthorizationEventPublisher(publisher)): AuthorizationEventPublisher { override fun <T : Any?> publishAuthorizationEvent( authentication: Supplier<Authentication>?, `object`: T, decision: AuthorizationDecision? ) { if (decision == null) { return } if (!decision.isGranted) { this.delegate.publishAuthorizationEvent(authentication, `object`, decision) return } if (shouldThisEventBePublished(decision)) { val granted = AuthorizationGrantedEvent(authentication, `object`, decision) this.publisher.publishEvent(granted) } } private fun shouldThisEventBePublished(decision: AuthorizationDecision): Boolean { if (decision !is AuthorityAuthorizationDecision) { return false } val authorities = decision.authorities for (authority in authorities) { if (""ROLE_ADMIN"" == authority.authority) { return true } } return false } }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/index.html","OAuth2: Spring Security provides comprehensive OAuth 2.0 support. This section discusses how to integrate OAuth 2.0 into your servlet based application. Overview: Spring Security’s OAuth 2.0 support consists of two primary feature sets: OAuth2 Resource Server(#oauth2-resource-server) OAuth2 Client(#oauth2-client) OAuth2 Login(#oauth2-client-log-users-in) is a very powerful OAuth2 Client feature that deserves its own section in the reference documentation. However, it does not exist as a standalone feature and requires OAuth2 Client in order to function. These feature sets cover the resource server and client roles defined in the OAuth 2.0 Authorization Framework(https://tools.ietf.org/html/rfc6749#section-1.1) , while the authorization server role is covered by Spring Authorization Server(https://docs.spring.io/spring-authorization-server/reference/index.html) , which is a separate project built on Spring Security(../../index.html) . The resource server and client roles in OAuth2 are typically represented by one or more server-side applications. Additionally, the authorization server role can be represented by one or more third parties (as is the case when centralizing identity management and/or authentication within an organization) -or- it can be represented by an application (as is the case with Spring Authorization Server). For example, a typical OAuth2-based microservices architecture might consist of a single user-facing client application, several backend resource servers providing REST APIs and a third party authorization server for managing users and authentication concerns. It is also common to have a single application representing only one of these roles with the need to integrate with one or more third parties that are providing the other roles. Spring Security handles these scenarios and more. The following sections cover the roles provided by Spring Security and contain examples for common scenarios. OAuth2 Resource Server: This section contains a summary of OAuth2 Resource Server features with examples. See OAuth 2.0 Resource Server(resource-server/index.html) for complete reference documentation. To get started, add the spring-security-oauth2-resource-server dependency to your project. When using Spring Boot, add the following starter: OAuth2 Client with Spring Boot Gradle Maven implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server' <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-oauth2-resource-server</artifactId> </dependency> See Getting Spring Security(../../getting-spring-security.html) for additional options when not using Spring Boot. Consider the following use cases for OAuth2 Resource Server: I want to protect access to the API using OAuth2(#oauth2-resource-server-access-token) (authorization server provides JWT or opaque access token) I want to protect access to the API using a JWT(#oauth2-resource-server-custom-jwt) (custom token) Protect Access with an OAuth2 Access Token: It is very common to protect access to an API using OAuth2 access tokens. In most cases, Spring Security requires only minimal configuration to secure an application with OAuth2. There are two types of Bearer tokens supported by Spring Security which each use a different component for validation: JWT support(#oauth2-resource-server-access-token-jwt) uses a JwtDecoder bean to validate signatures and decode tokens Opaque token support(#oauth2-resource-server-access-token-opaque) uses an OpaqueTokenIntrospector bean to introspect tokens JWT Support: The following example configures a JwtDecoder bean using Spring Boot configuration properties: spring: security: oauth2: resourceserver: jwt: issuer-uri: https://my-auth-server.com When using Spring Boot, this is all that is required. The default arrangement provided by Spring Boot is equivalent to the following: Configure Resource Server with JWTs Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer((oauth2) -> oauth2 .jwt(Customizer.withDefaults()) ); return http.build(); } @Bean public JwtDecoder jwtDecoder() { return JwtDecoders.fromIssuerLocation(""https://my-auth-server.com""); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { jwt { } } } return http.build() } @Bean fun jwtDecoder(): JwtDecoder { return JwtDecoders.fromIssuerLocation(""https://my-auth-server.com"") } } Opaque Token Support: The following example configures an OpaqueTokenIntrospector bean using Spring Boot configuration properties: spring: security: oauth2: resourceserver: opaquetoken: introspection-uri: https://my-auth-server.com/oauth2/introspect client-id: my-client-id client-secret: my-client-secret When using Spring Boot, this is all that is required. The default arrangement provided by Spring Boot is equivalent to the following: Configure Resource Server with Opaque Tokens Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer((oauth2) -> oauth2 .opaqueToken(Customizer.withDefaults()) ); return http.build(); } @Bean public OpaqueTokenIntrospector opaqueTokenIntrospector() { return new SpringOpaqueTokenIntrospector( ""https://my-auth-server.com/oauth2/introspect"", ""my-client-id"", ""my-client-secret""); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { opaqueToken { } } } return http.build() } @Bean fun opaqueTokenIntrospector(): OpaqueTokenIntrospector { return SpringOpaqueTokenIntrospector( ""https://my-auth-server.com/oauth2/introspect"", ""my-client-id"", ""my-client-secret"" ) } } Protect Access with a custom JWT: It is a fairly common goal to protect access to an API using JWTs, particularly when the frontend is developed as a single-page application. The OAuth2 Resource Server support in Spring Security can be used for any type of Bearer token, including a custom JWT. All that is required to protect an API using JWTs is a JwtDecoder bean, which is used to validate signatures and decode tokens. Spring Security will automatically use the provided bean to configure protection within the SecurityFilterChain . The following example configures a JwtDecoder bean using Spring Boot configuration properties: spring: security: oauth2: resourceserver: jwt: public-key-location: classpath:my-public-key.pub You can provide the public key as a classpath resource (called my-public-key.pub in this example). When using Spring Boot, this is all that is required. The default arrangement provided by Spring Boot is equivalent to the following: Configure Resource Server with Custom JWTs Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer((oauth2) -> oauth2 .jwt(Customizer.withDefaults()) ); return http.build(); } @Bean public JwtDecoder jwtDecoder() { return NimbusJwtDecoder.withPublicKey(publicKey()).build(); } private RSAPublicKey publicKey() { // ... } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { jwt { } } } return http.build() } @Bean fun jwtDecoder(): JwtDecoder { return NimbusJwtDecoder.withPublicKey(publicKey()).build() } private fun publicKey(): RSAPublicKey { // ... } } Spring Security does not provide an endpoint for minting tokens. However, Spring Security does provide the JwtEncoder interface along with one implementation, which is NimbusJwtEncoder . OAuth2 Client: This section contains a summary of OAuth2 Client features with examples. See OAuth 2.0 Client(client/index.html) and OAuth 2.0 Login(login/index.html) for complete reference documentation. To get started, add the spring-security-oauth2-client dependency to your project. When using Spring Boot, add the following starter: OAuth2 Client with Spring Boot Gradle Maven implementation 'org.springframework.boot:spring-boot-starter-oauth2-client' <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-oauth2-client</artifactId> </dependency> See Getting Spring Security(../../getting-spring-security.html) for additional options when not using Spring Boot. Consider the following use cases for OAuth2 Client: I want to log users in using OAuth 2.0 or OpenID Connect 1.0(#oauth2-client-log-users-in) I want to obtain an access token for users in order to access a third-party API(#oauth2-client-access-protected-resources) I want to do both(#oauth2-client-access-protected-resources-current-user) (log users in and access a third-party API) I want to enable an extension grant type(#oauth2-client-enable-extension-grant-type) I want to customize an existing grant type(#oauth2-client-customize-existing-grant-type) I want to customize token request parameters(#oauth2-client-customize-request-parameters) I want to customize the RestOperations used by OAuth2 Client components(#oauth2-client-customize-rest-operations) Log Users In with OAuth2: It is very common to require users to log in via OAuth2. OpenID Connect 1.0(https://openid.net/specs/openid-connect-core-1_0.html) provides a special token called the id_token which is designed to provide an OAuth2 Client with the ability to perform user identity verification and log users in. In certain cases, OAuth2 can be used directly to log users in (as is the case with popular social login providers that do not implement OpenID Connect such as GitHub and Facebook). The following example configures the application to act as an OAuth2 Client capable of logging users in with OAuth2 or OpenID Connect: Configure OAuth2 Login Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .oauth2Login(Customizer.withDefaults()); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... oauth2Login { } } return http.build() } } In addition to the above configuration, the application requires at least one ClientRegistration to be configured through the use of a ClientRegistrationRepository bean. The following example configures an InMemoryClientRegistrationRepository bean using Spring Boot configuration properties: spring: security: oauth2: client: registration: my-oidc-client: provider: my-oidc-provider client-id: my-client-id client-secret: my-client-secret authorization-grant-type: authorization_code scope: openid,profile provider: my-oidc-provider: issuer-uri: https://my-oidc-provider.com With the above configuration, the application now supports two additional endpoints: The login endpoint (e.g. /oauth2/authorization/my-oidc-client ) is used to initiate login and perform a redirect to the third party authorization server. The redirection endpoint (e.g. /login/oauth2/code/my-oidc-client ) is used by the authorization server to redirect back to the client application, and will contain a code parameter used to obtain an id_token and/or access_token via the access token request. The presence of the openid scope in the above configuration indicates that OpenID Connect 1.0 should be used. This instructs Spring Security to use OIDC-specific components (such as OidcUserService ) during request processing. Without this scope, Spring Security will use OAuth2-specific components (such as DefaultOAuth2UserService ) instead. Access Protected Resources: Making requests to a third party API that is protected by OAuth2 is a core use case of OAuth2 Client. This is accomplished by authorizing a client (represented by the OAuth2AuthorizedClient class in Spring Security) and accessing protected resources by placing a Bearer token in the Authorization header of an outbound request. The following example configures the application to act as an OAuth2 Client capable of requesting protected resources from a third party API: Configure OAuth2 Client Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .oauth2Client(Customizer.withDefaults()); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... oauth2Client { } } return http.build() } } The above example does not provide a way to log users in. You can use any other login mechanism (such as formLogin() ). See the next section(#oauth2-client-access-protected-resources-current-user) for an example combining oauth2Client() with oauth2Login() . In addition to the above configuration, the application requires at least one ClientRegistration to be configured through the use of a ClientRegistrationRepository bean. The following example configures an InMemoryClientRegistrationRepository bean using Spring Boot configuration properties: spring: security: oauth2: client: registration: my-oauth2-client: provider: my-auth-server client-id: my-client-id client-secret: my-client-secret authorization-grant-type: authorization_code scope: message.read,message.write provider: my-auth-server: issuer-uri: https://my-auth-server.com In addition to configuring Spring Security to support OAuth2 Client features, you will also need to decide how you will be accessing protected resources and configure your application accordingly. Spring Security provides implementations of OAuth2AuthorizedClientManager for obtaining access tokens that can be used to access protected resources. Spring Security registers a default OAuth2AuthorizedClientManager bean for you when one does not exist. The easiest way to use an OAuth2AuthorizedClientManager is via an ExchangeFilterFunction that intercepts requests through a WebClient . To use WebClient , you will need to add the spring-webflux dependency along with a reactive client implementation: Add Spring WebFlux Dependency Gradle Maven implementation 'org.springframework:spring-webflux' implementation 'io.projectreactor.netty:reactor-netty' <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webflux</artifactId> </dependency> <dependency> <groupId>io.projectreactor.netty</groupId> <artifactId>reactor-netty</artifactId> </dependency> The following example uses the default OAuth2AuthorizedClientManager to configure a WebClient capable of accessing protected resources by placing Bearer tokens in the Authorization header of each request: Configure WebClient with ExchangeFilterFunction Java Kotlin @Configuration public class WebClientConfig { @Bean public WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) { ServletOAuth2AuthorizedClientExchangeFilterFunction filter = new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); return WebClient.builder() .apply(filter.oauth2Configuration()) .build(); } } @Configuration class WebClientConfig { @Bean fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager): WebClient { val filter = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager) return WebClient.builder() .apply(filter.oauth2Configuration()) .build() } } This configured WebClient can be used as in the following example: Use WebClient to Access Protected Resources Java Kotlin import static org.springframework.security.oauth2.client.web.reactive.function.client.ServletOAuth2AuthorizedClientExchangeFilterFunction.clientRegistrationId; @RestController public class MessagesController { private final WebClient webClient; public MessagesController(WebClient webClient) { this.webClient = webClient; } @GetMapping(""/messages"") public ResponseEntity<List<Message>> messages() { return this.webClient.get() .uri(""http://localhost:8090/messages"") .attributes(clientRegistrationId(""my-oauth2-client"")) .retrieve() .toEntityList(Message.class) .block(); } public record Message(String message) { } } import org.springframework.security.oauth2.client.web.reactive.function.client.ServletOAuth2AuthorizedClientExchangeFilterFunction.clientRegistrationId @RestController class MessagesController(private val webClient: WebClient) { @GetMapping(""/messages"") fun messages(): ResponseEntity<List<Message>> { return webClient.get() .uri(""http://localhost:8090/messages"") .attributes(clientRegistrationId(""my-oauth2-client"")) .retrieve() .toEntityList<Message>() .block()!! } data class Message(val message: String) } Access Protected Resources for the Current User: When a user is logged in via OAuth2 or OpenID Connect, the authorization server may provide an access token that can be used directly to access protected resources. This is convenient because it only requires a single ClientRegistration to be configured for both use cases simultaneously. This section combines Log Users In with OAuth2(#oauth2-client-log-users-in) and Access Protected Resources(#oauth2-client-access-protected-resources) into a single configuration. Other advanced scenarios exist, such as configuring one ClientRegistration for login and another for accessing protected resources. All such scenarios would use the same basic configuration. The following example configures the application to act as an OAuth2 Client capable of logging the user in and requesting protected resources from a third party API: Configure OAuth2 Login and OAuth2 Client Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .oauth2Login(Customizer.withDefaults()) .oauth2Client(Customizer.withDefaults()); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... oauth2Login { } oauth2Client { } } return http.build() } } In addition to the above configuration, the application requires at least one ClientRegistration to be configured through the use of a ClientRegistrationRepository bean. The following example configures an InMemoryClientRegistrationRepository bean using Spring Boot configuration properties: spring: security: oauth2: client: registration: my-combined-client: provider: my-auth-server client-id: my-client-id client-secret: my-client-secret authorization-grant-type: authorization_code scope: openid,profile,message.read,message.write provider: my-auth-server: issuer-uri: https://my-auth-server.com The main difference between the previous examples ( Log Users In with OAuth2(#oauth2-client-log-users-in) , Access Protected Resources(#oauth2-client-access-protected-resources) ) and this one is what is configured via the scope property, which combines the standard scopes openid and profile with the custom scopes message.read and message.write . In addition to configuring Spring Security to support OAuth2 Client features, you will also need to decide how you will be accessing protected resources and configure your application accordingly. Spring Security provides implementations of OAuth2AuthorizedClientManager for obtaining access tokens that can be used to access protected resources. Spring Security registers a default OAuth2AuthorizedClientManager bean for you when one does not exist. The easiest way to use an OAuth2AuthorizedClientManager is via an ExchangeFilterFunction that intercepts requests through a WebClient . To use WebClient , you will need to add the spring-webflux dependency along with a reactive client implementation: Add Spring WebFlux Dependency Gradle Maven implementation 'org.springframework:spring-webflux' implementation 'io.projectreactor.netty:reactor-netty' <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webflux</artifactId> </dependency> <dependency> <groupId>io.projectreactor.netty</groupId> <artifactId>reactor-netty</artifactId> </dependency> The following example uses the default OAuth2AuthorizedClientManager to configure a WebClient capable of accessing protected resources by placing Bearer tokens in the Authorization header of each request: Configure WebClient with ExchangeFilterFunction Java Kotlin @Configuration public class WebClientConfig { @Bean public WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) { ServletOAuth2AuthorizedClientExchangeFilterFunction filter = new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); return WebClient.builder() .apply(filter.oauth2Configuration()) .build(); } } @Configuration class WebClientConfig { @Bean fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager): WebClient { val filter = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager) return WebClient.builder() .apply(filter.oauth2Configuration()) .build() } } This configured WebClient can be used as in the following example: Use WebClient to Access Protected Resources (Current User) Java Kotlin @RestController public class MessagesController { private final WebClient webClient; public MessagesController(WebClient webClient) { this.webClient = webClient; } @GetMapping(""/messages"") public ResponseEntity<List<Message>> messages() { return this.webClient.get() .uri(""http://localhost:8090/messages"") .retrieve() .toEntityList(Message.class) .block(); } public record Message(String message) { } } @RestController class MessagesController(private val webClient: WebClient) { @GetMapping(""/messages"") fun messages(): ResponseEntity<List<Message>> { return webClient.get() .uri(""http://localhost:8090/messages"") .retrieve() .toEntityList<Message>() .block()!! } data class Message(val message: String) } Unlike the previous example(#oauth2-client-accessing-protected-resources-example) , notice that we do not need to tell Spring Security about the clientRegistrationId we’d like to use. This is because it can be derived from the currently logged in user. Enable an Extension Grant Type: A common use case involves enabling and/or configuring an extension grant type. For example, Spring Security provides support for the jwt-bearer and token-exchange grant types, but does not enable them by default because they are not part of the core OAuth 2.0 specification. With Spring Security 6.2 and later, we can simply publish a bean for one or more OAuth2AuthorizedClientProvider and they will be picked up automatically. The following example simply enables the jwt-bearer grant type: Enable jwt-bearer Grant Type Java Kotlin @Configuration public class SecurityConfig { @Bean public OAuth2AuthorizedClientProvider jwtBearer() { return new JwtBearerOAuth2AuthorizedClientProvider(); } } @Configuration class SecurityConfig { @Bean fun jwtBearer(): OAuth2AuthorizedClientProvider { return JwtBearerOAuth2AuthorizedClientProvider() } } A default OAuth2AuthorizedClientManager will be published automatically by Spring Security when one is not already provided. Any custom OAuth2AuthorizedClientProvider bean will also be picked up and applied to the provided OAuth2AuthorizedClientManager after the default grant types. In order to achieve the above configuration prior to Spring Security 6.2, we had to publish this bean ourselves and ensure we re-enabled default grant types as well. To understand what is being configured behind the scenes, here’s what the configuration might have looked like: Enable jwt-bearer Grant Type (prior to 6.2) Java Kotlin @Configuration public class SecurityConfig { @Bean public OAuth2AuthorizedClientManager authorizedClientManager( ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientRepository authorizedClientRepository) { OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken() .clientCredentials() .password() .provider(new JwtBearerOAuth2AuthorizedClientProvider()) .build(); DefaultOAuth2AuthorizedClientManager authorizedClientManager = new DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } } @Configuration class SecurityConfig { @Bean fun authorizedClientManager( clientRegistrationRepository: ClientRegistrationRepository, authorizedClientRepository: OAuth2AuthorizedClientRepository ): OAuth2AuthorizedClientManager { val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken() .clientCredentials() .password() .provider(JwtBearerOAuth2AuthorizedClientProvider()) .build() val authorizedClientManager = DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository ) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } } Customize an Existing Grant Type: The ability to enable extension grant types(#oauth2-client-enable-extension-grant-type) by publishing a bean also provides the opportunity for customizing an existing grant type without the need to re-define the defaults. For example, if we want to customize the clock skew of the OAuth2AuthorizedClientProvider for the client_credentials grant, we can simply publish a bean like so: Customize Client Credentials Grant Type Java Kotlin @Configuration public class SecurityConfig { @Bean public OAuth2AuthorizedClientProvider clientCredentials() { ClientCredentialsOAuth2AuthorizedClientProvider authorizedClientProvider = new ClientCredentialsOAuth2AuthorizedClientProvider(); authorizedClientProvider.setClockSkew(Duration.ofMinutes(5)); return authorizedClientProvider; } } @Configuration class SecurityConfig { @Bean fun clientCredentials(): OAuth2AuthorizedClientProvider { val authorizedClientProvider = ClientCredentialsOAuth2AuthorizedClientProvider() authorizedClientProvider.setClockSkew(Duration.ofMinutes(5)) return authorizedClientProvider } } Customize Token Request Parameters: The need to customize request parameters when obtaining an access token is fairly common. For example, let’s say we want to add a custom audience parameter to the token request because the provider requires this parameter for the authorization_code grant. With Spring Security 6.2 and later, we can simply publish a bean of type OAuth2AccessTokenResponseClient with the generic type OAuth2AuthorizationCodeGrantRequest and it will be used by Spring Security to configure OAuth2 Client components. The following example customizes token request parameters for the authorization_code grant without the DSL: Customize Token Request Parameters for Authorization Code Grant Java Kotlin @Configuration public class SecurityConfig { @Bean public OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() { OAuth2AuthorizationCodeGrantRequestEntityConverter requestEntityConverter = new OAuth2AuthorizationCodeGrantRequestEntityConverter(); requestEntityConverter.addParametersConverter(parametersConverter()); DefaultAuthorizationCodeTokenResponseClient accessTokenResponseClient = new DefaultAuthorizationCodeTokenResponseClient(); accessTokenResponseClient.setRequestEntityConverter(requestEntityConverter); return accessTokenResponseClient; } private static Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> parametersConverter() { return (grantRequest) -> { MultiValueMap<String, String> parameters = new LinkedMultiValueMap<>(); parameters.set(""audience"", ""xyz_value""); return parameters; }; } } @Configuration class SecurityConfig { @Bean fun authorizationCodeAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> { val requestEntityConverter = OAuth2AuthorizationCodeGrantRequestEntityConverter() requestEntityConverter.addParametersConverter(parametersConverter()) val accessTokenResponseClient = DefaultAuthorizationCodeTokenResponseClient() accessTokenResponseClient.setRequestEntityConverter(requestEntityConverter) return accessTokenResponseClient } private fun parametersConverter(): Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> { return Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> { grantRequest -> LinkedMultiValueMap<String, String>().also { parameters -> parameters[""audience""] = ""xyz_value"" } } } } Notice that we don’t need to customize the SecurityFilterChain bean in this case, and can stick with the defaults. If using Spring Boot with no additional customizations, we can actually omit the SecurityFilterChain bean entirely. Prior to Spring Security 6.2, we had to ensure that this customization was applied for both OAuth2 Login (if we are using this feature) and OAuth2 Client components using the Spring Security DSL. To understand what is being configured behind the scenes, here’s what the configuration might have looked like: Customize Token Request Parameters for Authorization Code Grant (prior to 6.2) Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { OAuth2AuthorizationCodeGrantRequestEntityConverter requestEntityConverter = new OAuth2AuthorizationCodeGrantRequestEntityConverter(); requestEntityConverter.addParametersConverter(parametersConverter()); DefaultAuthorizationCodeTokenResponseClient accessTokenResponseClient = new DefaultAuthorizationCodeTokenResponseClient(); accessTokenResponseClient.setRequestEntityConverter(requestEntityConverter); http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) .oauth2Login((oauth2Login) -> oauth2Login .tokenEndpoint((tokenEndpoint) -> tokenEndpoint .accessTokenResponseClient(accessTokenResponseClient) ) ) .oauth2Client((oauth2Client) -> oauth2Client .authorizationCodeGrant((authorizationCode) -> authorizationCode .accessTokenResponseClient(accessTokenResponseClient) ) ); return http.build(); } private static Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> parametersConverter() { // ... } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { val requestEntityConverter = OAuth2AuthorizationCodeGrantRequestEntityConverter() requestEntityConverter.addParametersConverter(parametersConverter()) val tokenResponseClient = DefaultAuthorizationCodeTokenResponseClient() tokenResponseClient.setRequestEntityConverter(requestEntityConverter) http { authorizeHttpRequests { authorize(anyRequest, authenticated) } oauth2Login { tokenEndpoint { accessTokenResponseClient = tokenResponseClient } } oauth2Client { authorizationCodeGrant { accessTokenResponseClient = tokenResponseClient } } } return http.build() } private fun parametersConverter(): Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> { // ... } } For other grant types we can publish additional OAuth2AccessTokenResponseClient beans to override the defaults. For example, to customize token requests for the client_credentials grant we can publish the following bean: Customize Token Request Parameters for Client Credentials Grant Java Kotlin @Configuration public class SecurityConfig { @Bean public OAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsAccessTokenResponseClient() { OAuth2ClientCredentialsGrantRequestEntityConverter requestEntityConverter = new OAuth2ClientCredentialsGrantRequestEntityConverter(); requestEntityConverter.addParametersConverter(parametersConverter()); DefaultClientCredentialsTokenResponseClient accessTokenResponseClient = new DefaultClientCredentialsTokenResponseClient(); accessTokenResponseClient.setRequestEntityConverter(requestEntityConverter); return accessTokenResponseClient; } private static Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> parametersConverter() { // ... } } @Configuration class SecurityConfig { @Bean fun clientCredentialsAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> { val requestEntityConverter = OAuth2ClientCredentialsGrantRequestEntityConverter() requestEntityConverter.addParametersConverter(parametersConverter()) val accessTokenResponseClient = DefaultClientCredentialsTokenResponseClient() accessTokenResponseClient.setRequestEntityConverter(requestEntityConverter) return accessTokenResponseClient } private fun parametersConverter(): Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> { // ... } } Spring Security automatically resolves the following generic types of OAuth2AccessTokenResponseClient beans: OAuth2AuthorizationCodeGrantRequest (see DefaultAuthorizationCodeTokenResponseClient ) OAuth2RefreshTokenGrantRequest (see DefaultRefreshTokenTokenResponseClient ) OAuth2ClientCredentialsGrantRequest (see DefaultClientCredentialsTokenResponseClient ) OAuth2PasswordGrantRequest (see DefaultPasswordTokenResponseClient ) JwtBearerGrantRequest (see DefaultJwtBearerTokenResponseClient ) TokenExchangeGrantRequest (see DefaultTokenExchangeTokenResponseClient ) Publishing a bean of type OAuth2AccessTokenResponseClient<JwtBearerGrantRequest> will automatically enable the jwt-bearer grant type without the need to configure it separately(#oauth2-client-enable-extension-grant-type) . Publishing a bean of type OAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> will automatically enable the token-exchange grant type without the need to configure it separately(#oauth2-client-enable-extension-grant-type) . Customize the RestOperations used by OAuth2 Client Components: Another common use case is the need to customize the RestOperations used when obtaining an access token. We might need to do this to customize processing of the response (via a custom HttpMessageConverter ) or to apply proxy settings for a corporate network (via a customized ClientHttpRequestFactory ). With Spring Security 6.2 and later, we can simply publish beans of type OAuth2AccessTokenResponseClient and Spring Security will configure and publish an OAuth2AuthorizedClientManager bean for us. The following example customizes the RestOperations for all of the supported grant types: Customize RestOperations for OAuth2 Client Java Kotlin @Configuration public class SecurityConfig { @Bean public OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() { DefaultAuthorizationCodeTokenResponseClient accessTokenResponseClient = new DefaultAuthorizationCodeTokenResponseClient(); accessTokenResponseClient.setRestOperations(restTemplate()); return accessTokenResponseClient; } @Bean public OAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> refreshTokenAccessTokenResponseClient() { DefaultRefreshTokenTokenResponseClient accessTokenResponseClient = new DefaultRefreshTokenTokenResponseClient(); accessTokenResponseClient.setRestOperations(restTemplate()); return accessTokenResponseClient; } @Bean public OAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsAccessTokenResponseClient() { DefaultClientCredentialsTokenResponseClient accessTokenResponseClient = new DefaultClientCredentialsTokenResponseClient(); accessTokenResponseClient.setRestOperations(restTemplate()); return accessTokenResponseClient; } @Bean public OAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> passwordAccessTokenResponseClient() { DefaultPasswordTokenResponseClient accessTokenResponseClient = new DefaultPasswordTokenResponseClient(); accessTokenResponseClient.setRestOperations(restTemplate()); return accessTokenResponseClient; } @Bean public OAuth2AccessTokenResponseClient<JwtBearerGrantRequest> jwtBearerAccessTokenResponseClient() { DefaultJwtBearerTokenResponseClient accessTokenResponseClient = new DefaultJwtBearerTokenResponseClient(); accessTokenResponseClient.setRestOperations(restTemplate()); return accessTokenResponseClient; } @Bean public OAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> tokenExchangeAccessTokenResponseClient() { DefaultTokenExchangeTokenResponseClient accessTokenResponseClient = new DefaultTokenExchangeTokenResponseClient(); accessTokenResponseClient.setRestOperations(restTemplate()); return accessTokenResponseClient; } @Bean public RestTemplate restTemplate() { // ... } } @Configuration class SecurityConfig { @Bean fun authorizationCodeAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> { val accessTokenResponseClient = DefaultAuthorizationCodeTokenResponseClient() accessTokenResponseClient.setRestOperations(restTemplate()) return accessTokenResponseClient } @Bean fun refreshTokenAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> { val accessTokenResponseClient = DefaultRefreshTokenTokenResponseClient() accessTokenResponseClient.setRestOperations(restTemplate()) return accessTokenResponseClient } @Bean fun clientCredentialsAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> { val accessTokenResponseClient = DefaultClientCredentialsTokenResponseClient() accessTokenResponseClient.setRestOperations(restTemplate()) return accessTokenResponseClient } @Bean fun passwordAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> { val accessTokenResponseClient = DefaultPasswordTokenResponseClient() accessTokenResponseClient.setRestOperations(restTemplate()) return accessTokenResponseClient } @Bean fun jwtBearerAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<JwtBearerGrantRequest> { val accessTokenResponseClient = DefaultJwtBearerTokenResponseClient() accessTokenResponseClient.setRestOperations(restTemplate()) return accessTokenResponseClient } @Bean fun tokenExchangeAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> { val accessTokenResponseClient = DefaultTokenExchangeTokenResponseClient() accessTokenResponseClient.setRestOperations(restTemplate()) return accessTokenResponseClient } @Bean fun restTemplate(): RestTemplate { // ... } } A default OAuth2AuthorizedClientManager will be published automatically by Spring Security when one is not already provided. Notice that we don’t need to customize the SecurityFilterChain bean in this case, and can stick with the defaults. If using Spring Boot with no additional customizations, we can actually omit the SecurityFilterChain bean entirely. Prior to Spring Security 6.2, we had to ensure this customization was applied to both OAuth2 Login (if we are using this feature) and OAuth2 Client components. We had to use both the Spring Security DSL (for the authorization_code grant) and publish a bean of type OAuth2AuthorizedClientManager for other grant types. To understand what is being configured behind the scenes, here’s what the configuration might have looked like: Customize RestOperations for OAuth2 Client (prior to 6.2) Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { DefaultAuthorizationCodeTokenResponseClient accessTokenResponseClient = new DefaultAuthorizationCodeTokenResponseClient(); accessTokenResponseClient.setRestOperations(restTemplate()); http // ... .oauth2Login((oauth2Login) -> oauth2Login .tokenEndpoint((tokenEndpoint) -> tokenEndpoint .accessTokenResponseClient(accessTokenResponseClient) ) ) .oauth2Client((oauth2Client) -> oauth2Client .authorizationCodeGrant((authorizationCode) -> authorizationCode .accessTokenResponseClient(accessTokenResponseClient) ) ); return http.build(); } @Bean public OAuth2AuthorizedClientManager authorizedClientManager( ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientRepository authorizedClientRepository) { DefaultRefreshTokenTokenResponseClient refreshTokenAccessTokenResponseClient = new DefaultRefreshTokenTokenResponseClient(); refreshTokenAccessTokenResponseClient.setRestOperations(restTemplate()); DefaultClientCredentialsTokenResponseClient clientCredentialsAccessTokenResponseClient = new DefaultClientCredentialsTokenResponseClient(); clientCredentialsAccessTokenResponseClient.setRestOperations(restTemplate()); DefaultPasswordTokenResponseClient passwordAccessTokenResponseClient = new DefaultPasswordTokenResponseClient(); passwordAccessTokenResponseClient.setRestOperations(restTemplate()); DefaultJwtBearerTokenResponseClient jwtBearerAccessTokenResponseClient = new DefaultJwtBearerTokenResponseClient(); jwtBearerAccessTokenResponseClient.setRestOperations(restTemplate()); JwtBearerOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider = new JwtBearerOAuth2AuthorizedClientProvider(); jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerAccessTokenResponseClient); DefaultTokenExchangeTokenResponseClient tokenExchangeAccessTokenResponseClient = new DefaultTokenExchangeTokenResponseClient(); tokenExchangeAccessTokenResponseClient.setRestOperations(restTemplate()); TokenExchangeOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider = new TokenExchangeOAuth2AuthorizedClientProvider(); tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeAccessTokenResponseClient); OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken((refreshToken) -> refreshToken .accessTokenResponseClient(refreshTokenAccessTokenResponseClient) ) .clientCredentials((clientCredentials) -> clientCredentials .accessTokenResponseClient(clientCredentialsAccessTokenResponseClient) ) .password((password) -> password .accessTokenResponseClient(passwordAccessTokenResponseClient) ) .provider(jwtBearerAuthorizedClientProvider) .provider(tokenExchangeAuthorizedClientProvider) .build(); DefaultOAuth2AuthorizedClientManager authorizedClientManager = new DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean public RestTemplate restTemplate() { // ... } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { val tokenResponseClient = DefaultAuthorizationCodeTokenResponseClient() tokenResponseClient.setRestOperations(restTemplate()) http { // ... oauth2Login { tokenEndpoint { accessTokenResponseClient = tokenResponseClient } } oauth2Client { authorizationCodeGrant { accessTokenResponseClient = tokenResponseClient } } } return http.build() } @Bean fun authorizedClientManager( clientRegistrationRepository: ClientRegistrationRepository?, authorizedClientRepository: OAuth2AuthorizedClientRepository? ): OAuth2AuthorizedClientManager { val refreshTokenAccessTokenResponseClient = DefaultRefreshTokenTokenResponseClient() refreshTokenAccessTokenResponseClient.setRestOperations(restTemplate()) val clientCredentialsAccessTokenResponseClient = DefaultClientCredentialsTokenResponseClient() clientCredentialsAccessTokenResponseClient.setRestOperations(restTemplate()) val passwordAccessTokenResponseClient = DefaultPasswordTokenResponseClient() passwordAccessTokenResponseClient.setRestOperations(restTemplate()) val jwtBearerAccessTokenResponseClient = DefaultJwtBearerTokenResponseClient() jwtBearerAccessTokenResponseClient.setRestOperations(restTemplate()) val jwtBearerAuthorizedClientProvider = JwtBearerOAuth2AuthorizedClientProvider() jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerAccessTokenResponseClient) val tokenExchangeAccessTokenResponseClient = DefaultTokenExchangeTokenResponseClient() tokenExchangeAccessTokenResponseClient.setRestOperations(restTemplate()) val tokenExchangeAuthorizedClientProvider = TokenExchangeOAuth2AuthorizedClientProvider() tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeAccessTokenResponseClient) val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken { refreshToken -> refreshToken.accessTokenResponseClient(refreshTokenAccessTokenResponseClient) } .clientCredentials { clientCredentials -> clientCredentials.accessTokenResponseClient(clientCredentialsAccessTokenResponseClient) } .password { password -> password.accessTokenResponseClient(passwordAccessTokenResponseClient) } .provider(jwtBearerAuthorizedClientProvider) .provider(tokenExchangeAuthorizedClientProvider) .build() val authorizedClientManager = DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository ) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } @Bean fun restTemplate(): RestTemplate { // ... } } Further Reading: This preceding sections introduced Spring Security’s support for OAuth2 with examples for common scenarios. You can read more about OAuth2 Client and Resource Server in the following sections of the reference documentation: OAuth 2.0 Login(login/index.html) OAuth 2.0 Client(client/index.html) OAuth 2.0 Resource Server(resource-server/index.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/login/index.html","OAuth 2.0 Login: The OAuth 2.0 Login feature lets an application have users log in to the application by using their existing account at an OAuth 2.0 Provider (such as GitHub) or OpenID Connect 1.0 Provider (such as Google). OAuth 2.0 Login implements two use cases: “Login with Google” or “Login with GitHub”. OAuth 2.0 Login is implemented by using the Authorization Code Grant , as specified in the OAuth 2.0 Authorization Framework(https://tools.ietf.org/html/rfc6749#section-4.1) and OpenID Connect Core 1.0(https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth) . Section Summary: Core Configuration(core.html) Advanced Configuration(advanced.html) OIDC Logout(logout.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/login/core.html","Core Configuration: Spring Boot Sample: Spring Boot brings full auto-configuration capabilities for OAuth 2.0 Login. This section shows how to configure the OAuth 2.0 Login sample(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/spring-boot/java/oauth2/login) by using Google as the Authentication Provider and covers the following topics: Initial Setup(#oauth2login-sample-initial-setup) Setting the Redirect URI(#oauth2login-sample-redirect-uri) Configure application.yml(#oauth2login-sample-application-config) Boot up the Application(#oauth2login-sample-boot-application) Initial Setup: To use Google’s OAuth 2.0 authentication system for login, you must set up a project in the Google API Console to obtain OAuth 2.0 credentials. Google’s OAuth 2.0 implementation(https://developers.google.com/identity/protocols/OpenIDConnect) for authentication conforms to the OpenID Connect 1.0(https://openid.net/connect/) specification and is OpenID certified(https://openid.net/certification/) . Follow the instructions on the OpenID Connect(https://developers.google.com/identity/protocols/OpenIDConnect) page, starting in the “Setting up OAuth 2.0” section. After completing the “Obtain OAuth 2.0 credentials” instructions, you should have new OAuth Client with credentials consisting of a Client ID and a Client Secret. Setting the Redirect URI: The redirect URI is the path in the application that the end-user’s user-agent is redirected back to after they have authenticated with Google and have granted access to the OAuth Client ( created in the previous step(#oauth2login-sample-initial-setup) ) on the Consent page. In the “Set a redirect URI” subsection, ensure that the Authorized redirect URIs field is set to localhost:8080/login/oauth2/code/google(http://localhost:8080/login/oauth2/code/google) . The default redirect URI template is {baseUrl}/login/oauth2/code/{registrationId} . The registrationId is a unique identifier for the ClientRegistration(../client/index.html#oauth2Client-client-registration) . If the OAuth Client runs behind a proxy server, you should check the Proxy Server Configuration(../../../features/exploits/http.html#http-proxy-server) to ensure the application is correctly configured. Also, see the supported URI template variables(../client/authorization-grants.html#oauth2Client-auth-code-redirect-uri) for redirect-uri . Configure application.yml: Now that you have a new OAuth Client with Google, you need to configure the application to use the OAuth Client for the authentication flow . To do so: Go to application.yml and set the following configuration: spring: security: oauth2: client: registration: (1) google: (2) client-id: google-client-id client-secret: google-client-secret OAuth Client properties 1 spring.security.oauth2.client.registration is the base property prefix for OAuth Client properties. 2 Following the base property prefix is the ID for the ClientRegistration(../client/index.html#oauth2Client-client-registration) , such as Google. Replace the values in the client-id and client-secret property with the OAuth 2.0 credentials you created earlier. Boot up the Application: Launch the Spring Boot sample and go to localhost:8080(http://localhost:8080) . You are then redirected to the default auto-generated login page, which displays a link for Google. Click on the Google link, and you are then redirected to Google for authentication. After authenticating with your Google account credentials, you see the Consent screen. The Consent screen asks you to either allow or deny access to the OAuth Client you created earlier. Click Allow to authorize the OAuth Client to access your email address and basic profile information. At this point, the OAuth Client retrieves your email address and basic profile information from the UserInfo Endpoint(https://openid.net/specs/openid-connect-core-1_0.html#UserInfo) and establishes an authenticated session. Spring Boot Property Mappings: The following table outlines the mapping of the Spring Boot OAuth Client properties to the ClientRegistration(../client/index.html#oauth2Client-client-registration) properties. Spring Boot ClientRegistration spring.security.oauth2.client.registration. [registrationId] registrationId spring.security.oauth2.client.registration. [registrationId] .client-id clientId spring.security.oauth2.client.registration. [registrationId] .client-secret clientSecret spring.security.oauth2.client.registration. [registrationId] .client-authentication-method clientAuthenticationMethod spring.security.oauth2.client.registration. [registrationId] .authorization-grant-type authorizationGrantType spring.security.oauth2.client.registration. [registrationId] .redirect-uri redirectUri spring.security.oauth2.client.registration. [registrationId] .scope scopes spring.security.oauth2.client.registration. [registrationId] .client-name clientName spring.security.oauth2.client.provider. [providerId] .authorization-uri providerDetails.authorizationUri spring.security.oauth2.client.provider. [providerId] .token-uri providerDetails.tokenUri spring.security.oauth2.client.provider. [providerId] .jwk-set-uri providerDetails.jwkSetUri spring.security.oauth2.client.provider. [providerId] .issuer-uri providerDetails.issuerUri spring.security.oauth2.client.provider. [providerId] .user-info-uri providerDetails.userInfoEndpoint.uri spring.security.oauth2.client.provider. [providerId] .user-info-authentication-method providerDetails.userInfoEndpoint.authenticationMethod spring.security.oauth2.client.provider. [providerId] .user-name-attribute providerDetails.userInfoEndpoint.userNameAttributeName You can initially configure a ClientRegistration by using discovery of an OpenID Connect Provider’s Configuration endpoint(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) or an Authorization Server’s Metadata endpoint(https://tools.ietf.org/html/rfc8414#section-3) , by specifying the spring.security.oauth2.client.provider. [providerId] .issuer-uri property. CommonOAuth2Provider: CommonOAuth2Provider pre-defines a set of default client properties for a number of well known providers: Google, GitHub, Facebook, and Okta. For example, the authorization-uri , token-uri , and user-info-uri do not change often for a provider. Therefore, it makes sense to provide default values, to reduce the required configuration. As demonstrated previously, when we configured a Google client(#oauth2login-sample-application-config) , only the client-id and client-secret properties are required. The following listing shows an example: spring: security: oauth2: client: registration: google: client-id: google-client-id client-secret: google-client-secret The auto-defaulting of client properties works seamlessly here because the registrationId ( google ) matches the GOOGLE enum (case-insensitive) in CommonOAuth2Provider . For cases where you may want to specify a different registrationId , such as google-login , you can still leverage auto-defaulting of client properties by configuring the provider property. The following listing shows an example: spring: security: oauth2: client: registration: google-login: (1) provider: google (2) client-id: google-client-id client-secret: google-client-secret 1 The registrationId is set to google-login . 2 The provider property is set to google , which will leverage the auto-defaulting of client properties set in CommonOAuth2Provider.GOOGLE.getBuilder() . Configuring Custom Provider Properties: There are some OAuth 2.0 Providers that support multi-tenancy, which results in different protocol endpoints for each tenant (or sub-domain). For example, an OAuth Client registered with Okta is assigned to a specific sub-domain and have their own protocol endpoints. For these cases, Spring Boot provides the following base property for configuring custom provider properties: spring.security.oauth2.client.provider. [providerId] . The following listing shows an example: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret provider: okta: (1) authorization-uri: https://your-subdomain.oktapreview.com/oauth2/v1/authorize token-uri: https://your-subdomain.oktapreview.com/oauth2/v1/token user-info-uri: https://your-subdomain.oktapreview.com/oauth2/v1/userinfo user-name-attribute: sub jwk-set-uri: https://your-subdomain.oktapreview.com/oauth2/v1/keys 1 The base property ( spring.security.oauth2.client.provider.okta ) allows for custom configuration of protocol endpoint locations. Overriding Spring Boot Auto-configuration: The Spring Boot auto-configuration class for OAuth Client support is OAuth2ClientAutoConfiguration . It performs the following tasks: Registers a ClientRegistrationRepository @Bean composed of ClientRegistration (s) from the configured OAuth Client properties. Registers a SecurityFilterChain @Bean and enables OAuth 2.0 Login through httpSecurity.oauth2Login() . If you need to override the auto-configuration based on your specific requirements, you may do so in the following ways: Register a ClientRegistrationRepository @Bean(#oauth2login-register-clientregistrationrepository-bean) Register a SecurityFilterChain @Bean(#oauth2login-provide-securityfilterchain-bean) Completely Override the Auto-configuration(#oauth2login-completely-override-autoconfiguration) Register a ClientRegistrationRepository @Bean: The following example shows how to register a ClientRegistrationRepository @Bean : Java Kotlin @Configuration public class OAuth2LoginConfig { @Bean public ClientRegistrationRepository clientRegistrationRepository() { return new InMemoryClientRegistrationRepository(this.googleClientRegistration()); } private ClientRegistration googleClientRegistration() { return ClientRegistration.withRegistrationId(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .redirectUri(""{baseUrl}/login/oauth2/code/{registrationId}"") .scope(""openid"", ""profile"", ""email"", ""address"", ""phone"") .authorizationUri(""https://accounts.google.com/o/oauth2/v2/auth"") .tokenUri(""https://www.googleapis.com/oauth2/v4/token"") .userInfoUri(""https://www.googleapis.com/oauth2/v3/userinfo"") .userNameAttributeName(IdTokenClaimNames.SUB) .jwkSetUri(""https://www.googleapis.com/oauth2/v3/certs"") .clientName(""Google"") .build(); } } @Configuration class OAuth2LoginConfig { @Bean fun clientRegistrationRepository(): ClientRegistrationRepository { return InMemoryClientRegistrationRepository(googleClientRegistration()) } private fun googleClientRegistration(): ClientRegistration { return ClientRegistration.withRegistrationId(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .redirectUri(""{baseUrl}/login/oauth2/code/{registrationId}"") .scope(""openid"", ""profile"", ""email"", ""address"", ""phone"") .authorizationUri(""https://accounts.google.com/o/oauth2/v2/auth"") .tokenUri(""https://www.googleapis.com/oauth2/v4/token"") .userInfoUri(""https://www.googleapis.com/oauth2/v3/userinfo"") .userNameAttributeName(IdTokenClaimNames.SUB) .jwkSetUri(""https://www.googleapis.com/oauth2/v3/certs"") .clientName(""Google"") .build() } } Register a SecurityFilterChain @Bean: The following example shows how to register a SecurityFilterChain @Bean with @EnableWebSecurity and enable OAuth 2.0 login through httpSecurity.oauth2Login() : OAuth2 Login Configuration Java Kotlin @Configuration @EnableWebSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2Login(withDefaults()); return http.build(); } } @Configuration @EnableWebSecurity class OAuth2LoginSecurityConfig { open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2Login { } } return http.build() } } Completely Override the Auto-configuration: The following example shows how to completely override the auto-configuration by registering a ClientRegistrationRepository @Bean and a SecurityFilterChain @Bean . Overriding the auto-configuration Java Kotlin @Configuration public class OAuth2LoginConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2Login(withDefaults()); return http.build(); } @Bean public ClientRegistrationRepository clientRegistrationRepository() { return new InMemoryClientRegistrationRepository(this.googleClientRegistration()); } private ClientRegistration googleClientRegistration() { return ClientRegistration.withRegistrationId(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .redirectUri(""{baseUrl}/login/oauth2/code/{registrationId}"") .scope(""openid"", ""profile"", ""email"", ""address"", ""phone"") .authorizationUri(""https://accounts.google.com/o/oauth2/v2/auth"") .tokenUri(""https://www.googleapis.com/oauth2/v4/token"") .userInfoUri(""https://www.googleapis.com/oauth2/v3/userinfo"") .userNameAttributeName(IdTokenClaimNames.SUB) .jwkSetUri(""https://www.googleapis.com/oauth2/v3/certs"") .clientName(""Google"") .build(); } } @Configuration class OAuth2LoginConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2Login { } } return http.build() } @Bean fun clientRegistrationRepository(): ClientRegistrationRepository { return InMemoryClientRegistrationRepository(googleClientRegistration()) } private fun googleClientRegistration(): ClientRegistration { return ClientRegistration.withRegistrationId(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .redirectUri(""{baseUrl}/login/oauth2/code/{registrationId}"") .scope(""openid"", ""profile"", ""email"", ""address"", ""phone"") .authorizationUri(""https://accounts.google.com/o/oauth2/v2/auth"") .tokenUri(""https://www.googleapis.com/oauth2/v4/token"") .userInfoUri(""https://www.googleapis.com/oauth2/v3/userinfo"") .userNameAttributeName(IdTokenClaimNames.SUB) .jwkSetUri(""https://www.googleapis.com/oauth2/v3/certs"") .clientName(""Google"") .build() } } Java Configuration without Spring Boot: If you are not able to use Spring Boot and would like to configure one of the pre-defined providers in CommonOAuth2Provider (for example, Google), apply the following configuration: OAuth2 Login Configuration Java Kotlin Xml @Configuration @EnableWebSecurity public class OAuth2LoginConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2Login(withDefaults()); return http.build(); } @Bean public ClientRegistrationRepository clientRegistrationRepository() { return new InMemoryClientRegistrationRepository(this.googleClientRegistration()); } @Bean public OAuth2AuthorizedClientService authorizedClientService( ClientRegistrationRepository clientRegistrationRepository) { return new InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository); } @Bean public OAuth2AuthorizedClientRepository authorizedClientRepository( OAuth2AuthorizedClientService authorizedClientService) { return new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService); } private ClientRegistration googleClientRegistration() { return CommonOAuth2Provider.GOOGLE.getBuilder(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .build(); } } @Configuration @EnableWebSecurity open class OAuth2LoginConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2Login { } } return http.build() } @Bean open fun clientRegistrationRepository(): ClientRegistrationRepository { return InMemoryClientRegistrationRepository(googleClientRegistration()) } @Bean open fun authorizedClientService( clientRegistrationRepository: ClientRegistrationRepository? ): OAuth2AuthorizedClientService { return InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository) } @Bean open fun authorizedClientRepository( authorizedClientService: OAuth2AuthorizedClientService? ): OAuth2AuthorizedClientRepository { return AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService) } private fun googleClientRegistration(): ClientRegistration { return CommonOAuth2Provider.GOOGLE.getBuilder(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .build() } } <http auto-config=""true""> <intercept-url pattern=""/**"" access=""authenticated""/> <oauth2-login authorized-client-repository-ref=""authorizedClientRepository""/> </http> <client-registrations> <client-registration registration-id=""google"" client-id=""google-client-id"" client-secret=""google-client-secret"" provider-id=""google""/> </client-registrations> <b:bean id=""authorizedClientService"" class=""org.springframework.security.oauth2.client.InMemoryOAuth2AuthorizedClientService"" autowire=""constructor""/> <b:bean id=""authorizedClientRepository"" class=""org.springframework.security.oauth2.client.web.AuthenticatedPrincipalOAuth2AuthorizedClientRepository""> <b:constructor-arg ref=""authorizedClientService""/> </b:bean>"
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/login/advanced.html","Advanced Configuration: HttpSecurity.oauth2Login() provides a number of configuration options for customizing OAuth 2.0 Login. The main configuration options are grouped into their protocol endpoint counterparts. For example, oauth2Login().authorizationEndpoint() allows configuring the Authorization Endpoint , whereas oauth2Login().tokenEndpoint() allows configuring the Token Endpoint . The following code shows an example: Advanced OAuth2 Login Configuration Java Kotlin @Configuration @EnableWebSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .oauth2Login(oauth2 -> oauth2 .authorizationEndpoint(authorization -> authorization ... ) .redirectionEndpoint(redirection -> redirection ... ) .tokenEndpoint(token -> token ... ) .userInfoEndpoint(userInfo -> userInfo ... ) ); return http.build(); } } @Configuration @EnableWebSecurity class OAuth2LoginSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { oauth2Login { authorizationEndpoint { ... } redirectionEndpoint { ... } tokenEndpoint { ... } userInfoEndpoint { ... } } } return http.build() } } The main goal of the oauth2Login() DSL was to closely align with the naming, as defined in the specifications. The OAuth 2.0 Authorization Framework defines the Protocol Endpoints(https://tools.ietf.org/html/rfc6749#section-3) as follows: The authorization process uses two authorization server endpoints (HTTP resources): Authorization Endpoint: Used by the client to obtain authorization from the resource owner through user-agent redirection. Token Endpoint: Used by the client to exchange an authorization grant for an access token, typically with client authentication. The authorization process also uses one client endpoint: Redirection Endpoint: Used by the authorization server to return responses that contain authorization credentials to the client through the resource owner user-agent. The OpenID Connect Core 1.0 specification defines the UserInfo Endpoint(https://openid.net/specs/openid-connect-core-1_0.html#UserInfo) as follows: The UserInfo Endpoint is an OAuth 2.0 Protected Resource that returns claims about the authenticated end-user. To obtain the requested claims about the end-user, the client makes a request to the UserInfo Endpoint by using an access token obtained through OpenID Connect Authentication. These claims are normally represented by a JSON object that contains a collection of name-value pairs for the claims. The following code shows the complete configuration options available for the oauth2Login() DSL: OAuth2 Login Configuration Options Java Kotlin @Configuration @EnableWebSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .oauth2Login(oauth2 -> oauth2 .clientRegistrationRepository(this.clientRegistrationRepository()) .authorizedClientRepository(this.authorizedClientRepository()) .authorizedClientService(this.authorizedClientService()) .loginPage(""/login"") .authorizationEndpoint(authorization -> authorization .baseUri(this.authorizationRequestBaseUri()) .authorizationRequestRepository(this.authorizationRequestRepository()) .authorizationRequestResolver(this.authorizationRequestResolver()) ) .redirectionEndpoint(redirection -> redirection .baseUri(this.authorizationResponseBaseUri()) ) .tokenEndpoint(token -> token .accessTokenResponseClient(this.accessTokenResponseClient()) ) .userInfoEndpoint(userInfo -> userInfo .userAuthoritiesMapper(this.userAuthoritiesMapper()) .userService(this.oauth2UserService()) .oidcUserService(this.oidcUserService()) ) ); return http.build(); } } @Configuration @EnableWebSecurity class OAuth2LoginSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { oauth2Login { clientRegistrationRepository = clientRegistrationRepository() authorizedClientRepository = authorizedClientRepository() authorizedClientService = authorizedClientService() loginPage = ""/login"" authorizationEndpoint { baseUri = authorizationRequestBaseUri() authorizationRequestRepository = authorizationRequestRepository() authorizationRequestResolver = authorizationRequestResolver() } redirectionEndpoint { baseUri = authorizationResponseBaseUri() } tokenEndpoint { accessTokenResponseClient = accessTokenResponseClient() } userInfoEndpoint { userAuthoritiesMapper = userAuthoritiesMapper() userService = oauth2UserService() oidcUserService = oidcUserService() } } } return http.build() } } In addition to the oauth2Login() DSL, XML configuration is also supported. The following code shows the complete configuration options available in the security namespace(../../appendix/namespace/http.html#nsa-oauth2-login) : OAuth2 Login XML Configuration Options <http> <oauth2-login client-registration-repository-ref=""clientRegistrationRepository"" authorized-client-repository-ref=""authorizedClientRepository"" authorized-client-service-ref=""authorizedClientService"" authorization-request-repository-ref=""authorizationRequestRepository"" authorization-request-resolver-ref=""authorizationRequestResolver"" access-token-response-client-ref=""accessTokenResponseClient"" user-authorities-mapper-ref=""userAuthoritiesMapper"" user-service-ref=""oauth2UserService"" oidc-user-service-ref=""oidcUserService"" login-processing-url=""/login/oauth2/code/*"" login-page=""/login"" authentication-success-handler-ref=""authenticationSuccessHandler"" authentication-failure-handler-ref=""authenticationFailureHandler"" jwt-decoder-factory-ref=""jwtDecoderFactory""/> </http> The following sections go into more detail on each of the configuration options available: OAuth 2.0 Login Page(#oauth2login-advanced-login-page) Redirection Endpoint(#oauth2login-advanced-redirection-endpoint) UserInfo Endpoint(#oauth2login-advanced-userinfo-endpoint) ID Token Signature Verification(#oauth2login-advanced-idtoken-verify) [oauth2login-advanced-oidc-logout](#oauth2login-advanced-oidc-logout) OAuth 2.0 Login Page: By default, the OAuth 2.0 Login Page is auto-generated by the DefaultLoginPageGeneratingFilter . The default login page shows each configured OAuth Client with its ClientRegistration.clientName as a link, which is capable of initiating the Authorization Request (or OAuth 2.0 Login). For DefaultLoginPageGeneratingFilter to show links for configured OAuth Clients, the registered ClientRegistrationRepository needs to also implement Iterable<ClientRegistration> . See InMemoryClientRegistrationRepository for reference. The link’s destination for each OAuth Client defaults to the following: OAuth2AuthorizationRequestRedirectFilter.DEFAULT_AUTHORIZATION_REQUEST_BASE_URI + ""/{registrationId}"" The following line shows an example: <a href=""/oauth2/authorization/google"">Google</a> To override the default login page, configure oauth2Login().loginPage() and (optionally) oauth2Login().authorizationEndpoint().baseUri() . The following listing shows an example: OAuth2 Login Page Configuration Java Kotlin Xml @Configuration @EnableWebSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .oauth2Login(oauth2 -> oauth2 .loginPage(""/login/oauth2"") ... .authorizationEndpoint(authorization -> authorization .baseUri(""/login/oauth2/authorization"") ... ) ); return http.build(); } } @Configuration @EnableWebSecurity class OAuth2LoginSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { oauth2Login { loginPage = ""/login/oauth2"" authorizationEndpoint { baseUri = ""/login/oauth2/authorization"" } } } return http.build() } } <http> <oauth2-login login-page=""/login/oauth2"" ... /> </http> You need to provide a @Controller with a @RequestMapping(""/login/oauth2"") that is capable of rendering the custom login page. As noted earlier, configuring oauth2Login().authorizationEndpoint().baseUri() is optional. However, if you choose to customize it, ensure the link to each OAuth Client matches the authorizationEndpoint().baseUri() . The following line shows an example: <a href=""/login/oauth2/authorization/google"">Google</a> Redirection Endpoint: The Redirection Endpoint is used by the Authorization Server for returning the Authorization Response (which contains the authorization credentials) to the client through the Resource Owner user-agent. OAuth 2.0 Login leverages the Authorization Code Grant. Therefore, the authorization credential is the authorization code. The default Authorization Response baseUri (redirection endpoint) is /login/oauth2/code/ * , which is defined in OAuth2LoginAuthenticationFilter.DEFAULT_FILTER_PROCESSES_URI . If you would like to customize the Authorization Response baseUri , configure it as follows: Redirection Endpoint Configuration Java Kotlin Xml @Configuration @EnableWebSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .oauth2Login(oauth2 -> oauth2 .redirectionEndpoint(redirection -> redirection .baseUri(""/login/oauth2/callback/*"") ... ) ); return http.build(); } } @Configuration @EnableWebSecurity class OAuth2LoginSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { oauth2Login { redirectionEndpoint { baseUri = ""/login/oauth2/callback/*"" } } } return http.build() } } <http> <oauth2-login login-processing-url=""/login/oauth2/callback/*"" ... /> </http> You also need to ensure the ClientRegistration.redirectUri matches the custom Authorization Response baseUri . The following listing shows an example: Java Kotlin return CommonOAuth2Provider.GOOGLE.getBuilder(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .redirectUri(""{baseUrl}/login/oauth2/callback/{registrationId}"") .build(); return CommonOAuth2Provider.GOOGLE.getBuilder(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .redirectUri(""{baseUrl}/login/oauth2/callback/{registrationId}"") .build() UserInfo Endpoint: The UserInfo Endpoint includes a number of configuration options, as described in the following sub-sections: Mapping User Authorities(#oauth2login-advanced-map-authorities) OAuth 2.0 UserService(#oauth2login-advanced-oauth2-user-service) OpenID Connect 1.0 UserService(#oauth2login-advanced-oidc-user-service) Mapping User Authorities: After the user successfully authenticates with the OAuth 2.0 Provider, the OAuth2User.getAuthorities() (or OidcUser.getAuthorities() ) contains a list of granted authorities populated from OAuth2UserRequest.getAccessToken().getScopes() and prefixed with SCOPE_ . These granted authorities can be mapped to a new set of GrantedAuthority instances, which are supplied to OAuth2AuthenticationToken when completing the authentication. OAuth2AuthenticationToken.getAuthorities() is used for authorizing requests, such as in hasRole('USER') or hasRole('ADMIN') . There are a couple of options to choose from when mapping user authorities: Using a GrantedAuthoritiesMapper(#oauth2login-advanced-map-authorities-grantedauthoritiesmapper) Delegation-based Strategy with OAuth2UserService(#oauth2login-advanced-map-authorities-oauth2userservice) Using a GrantedAuthoritiesMapper: The GrantedAuthoritiesMapper is given a list of granted authorities which contains a special authority of type OAuth2UserAuthority and the authority string OAUTH2_USER (or OidcUserAuthority and the authority string OIDC_USER ). Provide an implementation of GrantedAuthoritiesMapper and configure it, as follows: Granted Authorities Mapper Configuration Java Kotlin Xml @Configuration @EnableWebSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .oauth2Login(oauth2 -> oauth2 .userInfoEndpoint(userInfo -> userInfo .userAuthoritiesMapper(this.userAuthoritiesMapper()) ... ) ); return http.build(); } private GrantedAuthoritiesMapper userAuthoritiesMapper() { return (authorities) -> { Set<GrantedAuthority> mappedAuthorities = new HashSet<>(); authorities.forEach(authority -> { if (OidcUserAuthority.class.isInstance(authority)) { OidcUserAuthority oidcUserAuthority = (OidcUserAuthority)authority; OidcIdToken idToken = oidcUserAuthority.getIdToken(); OidcUserInfo userInfo = oidcUserAuthority.getUserInfo(); // Map the claims found in idToken and/or userInfo // to one or more GrantedAuthority's and add it to mappedAuthorities } else if (OAuth2UserAuthority.class.isInstance(authority)) { OAuth2UserAuthority oauth2UserAuthority = (OAuth2UserAuthority)authority; Map<String, Object> userAttributes = oauth2UserAuthority.getAttributes(); // Map the attributes found in userAttributes // to one or more GrantedAuthority's and add it to mappedAuthorities } }); return mappedAuthorities; }; } } @Configuration @EnableWebSecurity class OAuth2LoginSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { oauth2Login { userInfoEndpoint { userAuthoritiesMapper = userAuthoritiesMapper() } } } return http.build() } private fun userAuthoritiesMapper(): GrantedAuthoritiesMapper = GrantedAuthoritiesMapper { authorities: Collection<GrantedAuthority> -> val mappedAuthorities = emptySet<GrantedAuthority>() authorities.forEach { authority -> if (authority is OidcUserAuthority) { val idToken = authority.idToken val userInfo = authority.userInfo // Map the claims found in idToken and/or userInfo // to one or more GrantedAuthority's and add it to mappedAuthorities } else if (authority is OAuth2UserAuthority) { val userAttributes = authority.attributes // Map the attributes found in userAttributes // to one or more GrantedAuthority's and add it to mappedAuthorities } } mappedAuthorities } } <http> <oauth2-login user-authorities-mapper-ref=""userAuthoritiesMapper"" ... /> </http> Alternatively, you can register a GrantedAuthoritiesMapper @Bean to have it automatically applied to the configuration, as follows: Granted Authorities Mapper Bean Configuration Java Kotlin @Configuration @EnableWebSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .oauth2Login(withDefaults()); return http.build(); } @Bean public GrantedAuthoritiesMapper userAuthoritiesMapper() { ... } } @Configuration @EnableWebSecurity class OAuth2LoginSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { oauth2Login { } } return http.build() } @Bean fun userAuthoritiesMapper(): GrantedAuthoritiesMapper { ... } } Delegation-based Strategy with OAuth2UserService: This strategy is advanced compared to using a GrantedAuthoritiesMapper . However, it is also more flexible, as it gives you access to the OAuth2UserRequest and OAuth2User (when using an OAuth 2.0 UserService) or OidcUserRequest and OidcUser (when using an OpenID Connect 1.0 UserService). The OAuth2UserRequest (and OidcUserRequest ) provides you access to the associated OAuth2AccessToken , which is very useful in cases where the delegator needs to fetch authority information from a protected resource before it can map the custom authorities for the user. The following example shows how to implement and configure a delegation-based strategy using an OpenID Connect 1.0 UserService: OAuth2UserService Configuration Java Kotlin Xml @Configuration @EnableWebSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .oauth2Login(oauth2 -> oauth2 .userInfoEndpoint(userInfo -> userInfo .oidcUserService(this.oidcUserService()) ... ) ); return http.build(); } private OAuth2UserService<OidcUserRequest, OidcUser> oidcUserService() { final OidcUserService delegate = new OidcUserService(); return (userRequest) -> { // Delegate to the default implementation for loading a user OidcUser oidcUser = delegate.loadUser(userRequest); OAuth2AccessToken accessToken = userRequest.getAccessToken(); Set<GrantedAuthority> mappedAuthorities = new HashSet<>(); // TODO // 1) Fetch the authority information from the protected resource using accessToken // 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities // 3) Create a copy of oidcUser but use the mappedAuthorities instead ProviderDetails providerDetails = userRequest.getClientRegistration().getProviderDetails(); String userNameAttributeName = providerDetails.getUserInfoEndpoint().getUserNameAttributeName(); if (StringUtils.hasText(userNameAttributeName)) { oidcUser = new DefaultOidcUser(mappedAuthorities, oidcUser.getIdToken(), oidcUser.getUserInfo(), userNameAttributeName); } else { oidcUser = new DefaultOidcUser(mappedAuthorities, oidcUser.getIdToken(), oidcUser.getUserInfo()); } return oidcUser; }; } } @Configuration @EnableWebSecurity class OAuth2LoginSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { oauth2Login { userInfoEndpoint { oidcUserService = oidcUserService() } } } return http.build() } @Bean fun oidcUserService(): OAuth2UserService<OidcUserRequest, OidcUser> { val delegate = OidcUserService() return OAuth2UserService { userRequest -> // Delegate to the default implementation for loading a user val oidcUser = delegate.loadUser(userRequest) val accessToken = userRequest.accessToken val mappedAuthorities = HashSet<GrantedAuthority>() // TODO // 1) Fetch the authority information from the protected resource using accessToken // 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities // 3) Create a copy of oidcUser but use the mappedAuthorities instead val providerDetails = userRequest.getClientRegistration().getProviderDetails() val userNameAttributeName = providerDetails.getUserInfoEndpoint().getUserNameAttributeName() if (StringUtils.hasText(userNameAttributeName)) { DefaultOidcUser(mappedAuthorities, oidcUser.idToken, oidcUser.userInfo, userNameAttributeName) } else { DefaultOidcUser(mappedAuthorities, oidcUser.idToken, oidcUser.userInfo) } } } } <http> <oauth2-login oidc-user-service-ref=""oidcUserService"" ... /> </http> OAuth 2.0 UserService: DefaultOAuth2UserService is an implementation of an OAuth2UserService that supports standard OAuth 2.0 Provider’s. OAuth2UserService obtains the user attributes of the end-user (the resource owner) from the UserInfo Endpoint (by using the access token granted to the client during the authorization flow) and returns an AuthenticatedPrincipal in the form of an OAuth2User . DefaultOAuth2UserService uses a RestOperations instance when requesting the user attributes at the UserInfo Endpoint. If you need to customize the pre-processing of the UserInfo Request, you can provide DefaultOAuth2UserService.setRequestEntityConverter() with a custom Converter<OAuth2UserRequest, RequestEntity<?>> . The default implementation OAuth2UserRequestEntityConverter builds a RequestEntity representation of a UserInfo Request that sets the OAuth2AccessToken in the Authorization header by default. On the other end, if you need to customize the post-handling of the UserInfo Response, you need to provide DefaultOAuth2UserService.setRestOperations() with a custom configured RestOperations . The default RestOperations is configured as follows: RestTemplate restTemplate = new RestTemplate(); restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler()); OAuth2ErrorResponseErrorHandler is a ResponseErrorHandler that can handle an OAuth 2.0 Error (400 Bad Request). It uses an OAuth2ErrorHttpMessageConverter for converting the OAuth 2.0 Error parameters to an OAuth2Error . Whether you customize DefaultOAuth2UserService or provide your own implementation of OAuth2UserService , you need to configure it as follows: Java Kotlin @Configuration @EnableWebSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .oauth2Login(oauth2 -> oauth2 .userInfoEndpoint(userInfo -> userInfo .userService(this.oauth2UserService()) ... ) ); return http.build(); } private OAuth2UserService<OAuth2UserRequest, OAuth2User> oauth2UserService() { ... } } @Configuration @EnableWebSecurity class OAuth2LoginSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { oauth2Login { userInfoEndpoint { userService = oauth2UserService() // ... } } } return http.build() } private fun oauth2UserService(): OAuth2UserService<OAuth2UserRequest, OAuth2User> { // ... } } OpenID Connect 1.0 UserService: OidcUserService is an implementation of an OAuth2UserService that supports OpenID Connect 1.0 Provider’s. The OidcUserService leverages the DefaultOAuth2UserService when requesting the user attributes at the UserInfo Endpoint. If you need to customize the pre-processing of the UserInfo Request or the post-handling of the UserInfo Response, you need to provide OidcUserService.setOauth2UserService() with a custom configured DefaultOAuth2UserService . Whether you customize OidcUserService or provide your own implementation of OAuth2UserService for OpenID Connect 1.0 Provider’s, you need to configure it as follows: Java Kotlin @Configuration @EnableWebSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .oauth2Login(oauth2 -> oauth2 .userInfoEndpoint(userInfo -> userInfo .oidcUserService(this.oidcUserService()) ... ) ); return http.build(); } private OAuth2UserService<OidcUserRequest, OidcUser> oidcUserService() { ... } } @Configuration @EnableWebSecurity class OAuth2LoginSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { oauth2Login { userInfoEndpoint { oidcUserService = oidcUserService() // ... } } } return http.build() } private fun oidcUserService(): OAuth2UserService<OidcUserRequest, OidcUser> { // ... } } ID Token Signature Verification: OpenID Connect 1.0 Authentication introduces the ID Token(https://openid.net/specs/openid-connect-core-1_0.html#IDToken) , which is a security token that contains Claims about the Authentication of an End-User by an Authorization Server when used by a Client. The ID Token is represented as a JSON Web Token(https://tools.ietf.org/html/rfc7519) (JWT) and MUST be signed by using JSON Web Signature(https://tools.ietf.org/html/rfc7515) (JWS). The OidcIdTokenDecoderFactory provides a JwtDecoder used for OidcIdToken signature verification. The default algorithm is RS256 but may be different when assigned during client registration. For these cases, you can configure a resolver to return the expected JWS algorithm assigned for a specific client. The JWS algorithm resolver is a Function that accepts a ClientRegistration and returns the expected JwsAlgorithm for the client, such as SignatureAlgorithm.RS256 or MacAlgorithm.HS256 The following code shows how to configure the OidcIdTokenDecoderFactory @Bean to default to MacAlgorithm.HS256 for all ClientRegistration instances: Java Kotlin @Bean public JwtDecoderFactory<ClientRegistration> idTokenDecoderFactory() { OidcIdTokenDecoderFactory idTokenDecoderFactory = new OidcIdTokenDecoderFactory(); idTokenDecoderFactory.setJwsAlgorithmResolver(clientRegistration -> MacAlgorithm.HS256); return idTokenDecoderFactory; } @Bean fun idTokenDecoderFactory(): JwtDecoderFactory<ClientRegistration?> { val idTokenDecoderFactory = OidcIdTokenDecoderFactory() idTokenDecoderFactory.setJwsAlgorithmResolver { MacAlgorithm.HS256 } return idTokenDecoderFactory } For MAC-based algorithms (such as HS256 , HS384 , or HS512 ), the client-secret that corresponds to the client-id is used as the symmetric key for signature verification. If more than one ClientRegistration is configured for OpenID Connect 1.0 Authentication, the JWS algorithm resolver may evaluate the provided ClientRegistration to determine which algorithm to return. Then, you can proceed to configure logout(logout.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/login/logout.html","OIDC Logout: Once an end user is able to login to your application, it’s important to consider how they will log out. Generally speaking, there are three use cases for you to consider: I want to perform only a local logout I want to log out both my application and the OIDC Provider, initiated by my application I want to log out both my application and the OIDC Provider, initiated by the OIDC Provider Local Logout: To perform a local logout, no special OIDC configuration is needed. Spring Security automatically stands up a local logout endpoint, which you can configure through the logout() DSL(../../authentication/logout.html) . OpenID Connect 1.0 Client-Initiated Logout: OpenID Connect Session Management 1.0 allows the ability to log out the end user at the Provider by using the Client. One of the strategies available is RP-Initiated Logout(https://openid.net/specs/openid-connect-rpinitiated-1_0.html) . If the OpenID Provider supports both Session Management and Discovery(https://openid.net/specs/openid-connect-discovery-1_0.html) , the client can obtain the end_session_endpoint URL from the OpenID Provider’s Discovery Metadata(https://openid.net/specs/openid-connect-session-1_0.html#OPMetadata) . You can do so by configuring the ClientRegistration with the issuer-uri , as follows: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret ... provider: okta: issuer-uri: https://dev-1234.oktapreview.com Also, you should configure OidcClientInitiatedLogoutSuccessHandler , which implements RP-Initiated Logout, as follows: Java Kotlin @Configuration @EnableWebSecurity public class OAuth2LoginSecurityConfig { @Autowired private ClientRegistrationRepository clientRegistrationRepository; @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2Login(withDefaults()) .logout(logout -> logout .logoutSuccessHandler(oidcLogoutSuccessHandler()) ); return http.build(); } private LogoutSuccessHandler oidcLogoutSuccessHandler() { OidcClientInitiatedLogoutSuccessHandler oidcLogoutSuccessHandler = new OidcClientInitiatedLogoutSuccessHandler(this.clientRegistrationRepository); // Sets the location that the End-User's User Agent will be redirected to // after the logout has been performed at the Provider oidcLogoutSuccessHandler.setPostLogoutRedirectUri(""{baseUrl}""); return oidcLogoutSuccessHandler; } } @Configuration @EnableWebSecurity class OAuth2LoginSecurityConfig { @Autowired private lateinit var clientRegistrationRepository: ClientRegistrationRepository @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(anyRequest, authenticated) } oauth2Login { } logout { logoutSuccessHandler = oidcLogoutSuccessHandler() } } return http.build() } private fun oidcLogoutSuccessHandler(): LogoutSuccessHandler { val oidcLogoutSuccessHandler = OidcClientInitiatedLogoutSuccessHandler(clientRegistrationRepository) // Sets the location that the End-User's User Agent will be redirected to // after the logout has been performed at the Provider oidcLogoutSuccessHandler.setPostLogoutRedirectUri(""{baseUrl}"") return oidcLogoutSuccessHandler } } OidcClientInitiatedLogoutSuccessHandler supports the {baseUrl} placeholder. If used, the application’s base URL, such as app.example.org(https://app.example.org) , replaces it at request time. OpenID Connect 1.0 Back-Channel Logout: OpenID Connect Session Management 1.0 allows the ability to log out the end user at the Client by having the Provider make an API call to the Client. This is referred to as OIDC Back-Channel Logout(https://openid.net/specs/openid-connect-backchannel-1_0.html) . To enable this, you can stand up the Back-Channel Logout endpoint in the DSL like so: Java Kotlin @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) .oauth2Login(withDefaults()) .oidcLogout((logout) -> logout .backChannel(Customizer.withDefaults()) ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2Login { } oidcLogout { backChannel { } } } return http.build() } Then, you need a way listen to events published by Spring Security to remove old OidcSessionInformation entries, like so: Java Kotlin @Bean public HttpSessionEventPublisher sessionEventPublisher() { return new HttpSessionEventPublisher(); } @Bean open fun sessionEventPublisher(): HttpSessionEventPublisher { return HttpSessionEventPublisher() } This will make so that if HttpSession#invalidate is called, then the session is also removed from memory. And that’s it! This will stand up the endpoint /logout/connect/back-channel/{registrationId} which the OIDC Provider can request to invalidate a given session of an end user in your application. oidcLogout requires that oauth2Login also be configured. oidcLogout requires that the session cookie be called JSESSIONID in order to correctly log out each session through a backchannel. Back-Channel Logout Architecture: Consider a ClientRegistration whose identifier is registrationId . The overall flow for a Back-Channel logout is like this: At login time, Spring Security correlates the ID Token, CSRF Token, and Provider Session ID (if any) to your application’s session id in its OidcSessionStrategy implementation. Then at logout time, your OIDC Provider makes an API call to /logout/connect/back-channel/registrationId including a Logout Token that indicates either the sub (the End User) or the sid (the Provider Session ID) to logout. Spring Security validates the token’s signature and claims. If the token contains a sid claim, then only the Client’s session that correlates to that provider session is terminated. Otherwise, if the token contains a sub claim, then all that Client’s sessions for that End User are terminated. Remember that Spring Security’s OIDC support is multi-tenant. This means that it will only terminate sessions whose Client matches the aud claim in the Logout Token. Customizing the OIDC Provider Session Strategy: By default, Spring Security stores in-memory all links between the OIDC Provider session and the Client session. There are a number of circumstances, like a clustered application, where it would be nice to store this instead in a separate location, like a database. You can achieve this by configuring a custom OidcSessionStrategy , like so: Java Kotlin @Component public final class MySpringDataOidcSessionStrategy implements OidcSessionStrategy { private final OidcProviderSessionRepository sessions; // ... @Override public void saveSessionInformation(OidcSessionInformation info) { this.sessions.save(info); } @Override public OidcSessionInformation(String clientSessionId) { return this.sessions.removeByClientSessionId(clientSessionId); } @Override public Iterable<OidcSessionInformation> removeSessionInformation(OidcLogoutToken token) { return token.getSessionId() != null ? this.sessions.removeBySessionIdAndIssuerAndAudience(...) : this.sessions.removeBySubjectAndIssuerAndAudience(...); } } @Component class MySpringDataOidcSessionStrategy: OidcSessionStrategy { val sessions: OidcProviderSessionRepository // ... @Override fun saveSessionInformation(info: OidcSessionInformation) { this.sessions.save(info) } @Override fun removeSessionInformation(clientSessionId: String): OidcSessionInformation { return this.sessions.removeByClientSessionId(clientSessionId); } @Override fun removeSessionInformation(token: OidcLogoutToken): Iterable<OidcSessionInformation> { return token.getSessionId() != null ? this.sessions.removeBySessionIdAndIssuerAndAudience(...) : this.sessions.removeBySubjectAndIssuerAndAudience(...); } }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/client/index.html","OAuth 2.0 Client: The OAuth 2.0 Client features provide support for the Client role as defined in the OAuth 2.0 Authorization Framework(https://tools.ietf.org/html/rfc6749#section-1.1) . At a high-level, the core features available are: Authorization Grant support Authorization Code(https://tools.ietf.org/html/rfc6749#section-1.3.1) Refresh Token(https://tools.ietf.org/html/rfc6749#section-6) Client Credentials(https://tools.ietf.org/html/rfc6749#section-1.3.4) Resource Owner Password Credentials(https://tools.ietf.org/html/rfc6749#section-1.3.3) JWT Bearer(https://datatracker.ietf.org/doc/html/rfc7523#section-2.1) Token Exchange(https://datatracker.ietf.org/doc/html/rfc8693#section-2.1) Client Authentication support JWT Bearer(https://datatracker.ietf.org/doc/html/rfc7523#section-2.2) HTTP Client support WebClient integration for Servlet Environments(authorized-clients.html#oauth2Client-webclient-servlet) (for requesting protected resources) The HttpSecurity.oauth2Client() DSL provides a number of configuration options for customizing the core components used by OAuth 2.0 Client. In addition, HttpSecurity.oauth2Client().authorizationCodeGrant() enables the customization of the Authorization Code grant. The following code shows the complete configuration options provided by the HttpSecurity.oauth2Client() DSL: OAuth2 Client Configuration Options Java Kotlin @Configuration @EnableWebSecurity public class OAuth2ClientSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .oauth2Client(oauth2 -> oauth2 .clientRegistrationRepository(this.clientRegistrationRepository()) .authorizedClientRepository(this.authorizedClientRepository()) .authorizedClientService(this.authorizedClientService()) .authorizationCodeGrant(codeGrant -> codeGrant .authorizationRequestRepository(this.authorizationRequestRepository()) .authorizationRequestResolver(this.authorizationRequestResolver()) .accessTokenResponseClient(this.accessTokenResponseClient()) ) ); return http.build(); } } @Configuration @EnableWebSecurity class OAuth2ClientSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { oauth2Client { clientRegistrationRepository = clientRegistrationRepository() authorizedClientRepository = authorizedClientRepository() authorizedClientService = authorizedClientService() authorizationCodeGrant { authorizationRequestRepository = authorizationRequestRepository() authorizationRequestResolver = authorizationRequestResolver() accessTokenResponseClient = accessTokenResponseClient() } } } return http.build() } } In addition to the HttpSecurity.oauth2Client() DSL, XML configuration is also supported. The following code shows the complete configuration options available in the security namespace(../../appendix/namespace/http.html#nsa-oauth2-client) : OAuth2 Client XML Configuration Options <http> <oauth2-client client-registration-repository-ref=""clientRegistrationRepository"" authorized-client-repository-ref=""authorizedClientRepository"" authorized-client-service-ref=""authorizedClientService""> <authorization-code-grant authorization-request-repository-ref=""authorizationRequestRepository"" authorization-request-resolver-ref=""authorizationRequestResolver"" access-token-response-client-ref=""accessTokenResponseClient""/> </oauth2-client> </http> The OAuth2AuthorizedClientManager is responsible for managing the authorization (or re-authorization) of an OAuth 2.0 Client, in collaboration with one or more OAuth2AuthorizedClientProvider (s). The following code shows an example of how to register an OAuth2AuthorizedClientManager @Bean and associate it with an OAuth2AuthorizedClientProvider composite that provides support for the authorization_code , refresh_token , client_credentials , and password authorization grant types: Java Kotlin @Bean public OAuth2AuthorizedClientManager authorizedClientManager( ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientRepository authorizedClientRepository) { OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken() .clientCredentials() .password() .build(); DefaultOAuth2AuthorizedClientManager authorizedClientManager = new DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean fun authorizedClientManager( clientRegistrationRepository: ClientRegistrationRepository, authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager { val authorizedClientProvider: OAuth2AuthorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken() .clientCredentials() .password() .build() val authorizedClientManager = DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } Section Summary: Core Interfaces and Classes(core.html) OAuth2 Authorization Grants(authorization-grants.html) OAuth2 Client Authentication(client-authentication.html) OAuth2 Authorized Clients(authorized-clients.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/client/core.html","Core Interfaces and Classes: This section describes the OAuth2 core interfaces and classes that Spring Security offers. ClientRegistration: ClientRegistration is a representation of a client registered with an OAuth 2.0 or OpenID Connect 1.0 Provider. A ClientRegistration object holds information, such as client id, client secret, authorization grant type, redirect URI, scope(s), authorization URI, token URI, and other details. ClientRegistration and its properties are defined as follows: public final class ClientRegistration { private String registrationId; (1) private String clientId; (2) private String clientSecret; (3) private ClientAuthenticationMethod clientAuthenticationMethod; (4) private AuthorizationGrantType authorizationGrantType; (5) private String redirectUri; (6) private Set<String> scopes; (7) private ProviderDetails providerDetails; private String clientName; (8) public class ProviderDetails { private String authorizationUri; (9) private String tokenUri; (10) private UserInfoEndpoint userInfoEndpoint; private String jwkSetUri; (11) private String issuerUri; (12) private Map<String, Object> configurationMetadata; (13) public class UserInfoEndpoint { private String uri; (14) private AuthenticationMethod authenticationMethod; (15) private String userNameAttributeName; (16) } } } 1 registrationId : The ID that uniquely identifies the ClientRegistration . 2 clientId : The client identifier. 3 clientSecret : The client secret. 4 clientAuthenticationMethod : The method used to authenticate the Client with the Provider. The supported values are client_secret_basic , client_secret_post , private_key_jwt , client_secret_jwt and none (public clients)(https://tools.ietf.org/html/rfc6749#section-2.1) . 5 authorizationGrantType : The OAuth 2.0 Authorization Framework defines four Authorization Grant(https://tools.ietf.org/html/rfc6749#section-1.3) types. The supported values are authorization_code , client_credentials , password , as well as, extension grant type urn:ietf:params:oauth:grant-type:jwt-bearer . 6 redirectUri : The client’s registered redirect URI that the Authorization Server redirects the end-user’s user-agent to after the end-user has authenticated and authorized access to the client. 7 scopes : The scope(s) requested by the client during the Authorization Request flow, such as openid, email, or profile. 8 clientName : A descriptive name used for the client. The name may be used in certain scenarios, such as when displaying the name of the client in the auto-generated login page. 9 authorizationUri : The Authorization Endpoint URI for the Authorization Server. 10 tokenUri : The Token Endpoint URI for the Authorization Server. 11 jwkSetUri : The URI used to retrieve the JSON Web Key (JWK)(https://tools.ietf.org/html/rfc7517) Set from the Authorization Server, which contains the cryptographic key(s) used to verify the JSON Web Signature (JWS)(https://tools.ietf.org/html/rfc7515) of the ID Token and (optionally) the UserInfo Response. 12 issuerUri : Returns the issuer identifier URI for the OpenID Connect 1.0 provider or the OAuth 2.0 Authorization Server. 13 configurationMetadata : The OpenID Provider Configuration Information(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) . This information is available only if the Spring Boot property spring.security.oauth2.client.provider.[providerId].issuerUri is configured. 14 (userInfoEndpoint)uri : The UserInfo Endpoint URI used to access the claims and attributes of the authenticated end-user. 15 (userInfoEndpoint)authenticationMethod : The authentication method used when sending the access token to the UserInfo Endpoint. The supported values are header , form , and query . 16 userNameAttributeName : The name of the attribute returned in the UserInfo Response that references the Name or Identifier of the end-user. You can initially configure a ClientRegistration by using discovery of an OpenID Connect Provider’s Configuration endpoint(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) or an Authorization Server’s Metadata endpoint(https://tools.ietf.org/html/rfc8414#section-3) . ClientRegistrations provides convenience methods for configuring a ClientRegistration in this way, as follows: Java Kotlin ClientRegistration clientRegistration = ClientRegistrations.fromIssuerLocation(""https://idp.example.com/issuer"").build(); val clientRegistration = ClientRegistrations.fromIssuerLocation(""https://idp.example.com/issuer"").build() The preceding code queries, in series, idp.example.com/issuer/.well-known/openid-configuration(https://idp.example.com/issuer/.well-known/openid-configuration) , idp.example.com/.well-known/openid-configuration/issuer(https://idp.example.com/.well-known/openid-configuration/issuer) , and idp.example.com/.well-known/oauth-authorization-server/issuer(https://idp.example.com/.well-known/oauth-authorization-server/issuer) , stopping at the first to return a 200 response. As an alternative, you can use ClientRegistrations.fromOidcIssuerLocation() to query only the OpenID Connect Provider’s Configuration endpoint. ClientRegistrationRepository: The ClientRegistrationRepository serves as a repository for OAuth 2.0 / OpenID Connect 1.0 ClientRegistration (s). Client registration information is ultimately stored and owned by the associated Authorization Server. This repository provides the ability to retrieve a subset of the primary client registration information, which is stored with the Authorization Server. Spring Boot auto-configuration binds each of the properties under spring.security.oauth2.client.registration. [registrationId] to an instance of ClientRegistration and then composes each of the ClientRegistration instance(s) within a ClientRegistrationRepository . The default implementation of ClientRegistrationRepository is InMemoryClientRegistrationRepository . The auto-configuration also registers the ClientRegistrationRepository as a @Bean in the ApplicationContext so that it is available for dependency injection, if needed by the application. The following listing shows an example: Java Kotlin @Controller public class OAuth2ClientController { @Autowired private ClientRegistrationRepository clientRegistrationRepository; @GetMapping(""/"") public String index() { ClientRegistration oktaRegistration = this.clientRegistrationRepository.findByRegistrationId(""okta""); ... return ""index""; } } @Controller class OAuth2ClientController { @Autowired private lateinit var clientRegistrationRepository: ClientRegistrationRepository @GetMapping(""/"") fun index(): String { val oktaRegistration = this.clientRegistrationRepository.findByRegistrationId(""okta"") //... return ""index""; } } OAuth2AuthorizedClient: OAuth2AuthorizedClient is a representation of an Authorized Client. A client is considered to be authorized when the end-user (the Resource Owner) has granted authorization to the client to access its protected resources. OAuth2AuthorizedClient serves the purpose of associating an OAuth2AccessToken (and optional OAuth2RefreshToken ) to a ClientRegistration (client) and resource owner, who is the Principal end-user that granted the authorization. OAuth2AuthorizedClientRepository and OAuth2AuthorizedClientService: OAuth2AuthorizedClientRepository is responsible for persisting OAuth2AuthorizedClient (s) between web requests, whereas the primary role of OAuth2AuthorizedClientService is to manage OAuth2AuthorizedClient (s) at the application-level. From a developer perspective, the OAuth2AuthorizedClientRepository or OAuth2AuthorizedClientService provides the ability to look up an OAuth2AccessToken associated with a client so that it can be used to initiate a protected resource request. The following listing shows an example: Java Kotlin @Controller public class OAuth2ClientController { @Autowired private OAuth2AuthorizedClientService authorizedClientService; @GetMapping(""/"") public String index(Authentication authentication) { OAuth2AuthorizedClient authorizedClient = this.authorizedClientService.loadAuthorizedClient(""okta"", authentication.getName()); OAuth2AccessToken accessToken = authorizedClient.getAccessToken(); ... return ""index""; } } @Controller class OAuth2ClientController { @Autowired private lateinit var authorizedClientService: OAuth2AuthorizedClientService @GetMapping(""/"") fun index(authentication: Authentication): String { val authorizedClient: OAuth2AuthorizedClient = this.authorizedClientService.loadAuthorizedClient(""okta"", authentication.getName()); val accessToken = authorizedClient.accessToken ... return ""index""; } } Spring Boot auto-configuration registers an OAuth2AuthorizedClientRepository or an OAuth2AuthorizedClientService @Bean in the ApplicationContext . However, the application can override and register a custom OAuth2AuthorizedClientRepository or OAuth2AuthorizedClientService @Bean . The default implementation of OAuth2AuthorizedClientService is InMemoryOAuth2AuthorizedClientService , which stores OAuth2AuthorizedClient objects in-memory. Alternatively, you can configure the JDBC implementation JdbcOAuth2AuthorizedClientService to persist OAuth2AuthorizedClient instances in a database. JdbcOAuth2AuthorizedClientService depends on the table definition described in OAuth 2.0 Client Schema(../../appendix/database-schema.html#dbschema-oauth2-client) . OAuth2AuthorizedClientManager and OAuth2AuthorizedClientProvider: The OAuth2AuthorizedClientManager is responsible for the overall management of OAuth2AuthorizedClient (s). The primary responsibilities include: Authorizing (or re-authorizing) an OAuth 2.0 Client, by using an OAuth2AuthorizedClientProvider . Delegating the persistence of an OAuth2AuthorizedClient , typically by using an OAuth2AuthorizedClientService or OAuth2AuthorizedClientRepository . Delegating to an OAuth2AuthorizationSuccessHandler when an OAuth 2.0 Client has been successfully authorized (or re-authorized). Delegating to an OAuth2AuthorizationFailureHandler when an OAuth 2.0 Client fails to authorize (or re-authorize). An OAuth2AuthorizedClientProvider implements a strategy for authorizing (or re-authorizing) an OAuth 2.0 Client. Implementations typically implement an authorization grant type, such as authorization_code , client_credentials , and others. The default implementation of OAuth2AuthorizedClientManager is DefaultOAuth2AuthorizedClientManager , which is associated with an OAuth2AuthorizedClientProvider that may support multiple authorization grant types using a delegation-based composite. You can use OAuth2AuthorizedClientProviderBuilder to configure and build the delegation-based composite. The following code shows an example of how to configure and build an OAuth2AuthorizedClientProvider composite that provides support for the authorization_code , refresh_token , client_credentials , and password authorization grant types: Java Kotlin @Bean public OAuth2AuthorizedClientManager authorizedClientManager( ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientRepository authorizedClientRepository) { OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken() .clientCredentials() .password() .build(); DefaultOAuth2AuthorizedClientManager authorizedClientManager = new DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean fun authorizedClientManager( clientRegistrationRepository: ClientRegistrationRepository, authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager { val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken() .clientCredentials() .password() .build() val authorizedClientManager = DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } When an authorization attempt succeeds, the DefaultOAuth2AuthorizedClientManager delegates to the OAuth2AuthorizationSuccessHandler , which (by default) saves the OAuth2AuthorizedClient through the OAuth2AuthorizedClientRepository . In the case of a re-authorization failure (for example, a refresh token is no longer valid), the previously saved OAuth2AuthorizedClient is removed from the OAuth2AuthorizedClientRepository through the RemoveAuthorizedClientOAuth2AuthorizationFailureHandler . You can customize the default behavior through setAuthorizationSuccessHandler(OAuth2AuthorizationSuccessHandler) and setAuthorizationFailureHandler(OAuth2AuthorizationFailureHandler) . The DefaultOAuth2AuthorizedClientManager is also associated with a contextAttributesMapper of type Function<OAuth2AuthorizeRequest, Map<String, Object>> , which is responsible for mapping attribute(s) from the OAuth2AuthorizeRequest to a Map of attributes to be associated to the OAuth2AuthorizationContext . This can be useful when you need to supply an OAuth2AuthorizedClientProvider with required (supported) attribute(s), eg. the PasswordOAuth2AuthorizedClientProvider requires the resource owner’s username and password to be available in OAuth2AuthorizationContext.getAttributes() . The following code shows an example of the contextAttributesMapper : Java Kotlin @Bean public OAuth2AuthorizedClientManager authorizedClientManager( ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientRepository authorizedClientRepository) { OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .password() .refreshToken() .build(); DefaultOAuth2AuthorizedClientManager authorizedClientManager = new DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); // Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters, // map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()` authorizedClientManager.setContextAttributesMapper(contextAttributesMapper()); return authorizedClientManager; } private Function<OAuth2AuthorizeRequest, Map<String, Object>> contextAttributesMapper() { return authorizeRequest -> { Map<String, Object> contextAttributes = Collections.emptyMap(); HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName()); String username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME); String password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD); if (StringUtils.hasText(username) && StringUtils.hasText(password)) { contextAttributes = new HashMap<>(); // `PasswordOAuth2AuthorizedClientProvider` requires both attributes contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username); contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password); } return contextAttributes; }; } @Bean fun authorizedClientManager( clientRegistrationRepository: ClientRegistrationRepository, authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager { val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .password() .refreshToken() .build() val authorizedClientManager = DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) // Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters, // map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()` authorizedClientManager.setContextAttributesMapper(contextAttributesMapper()) return authorizedClientManager } private fun contextAttributesMapper(): Function<OAuth2AuthorizeRequest, MutableMap<String, Any>> { return Function { authorizeRequest -> var contextAttributes: MutableMap<String, Any> = mutableMapOf() val servletRequest: HttpServletRequest = authorizeRequest.getAttribute(HttpServletRequest::class.java.name) val username: String = servletRequest.getParameter(OAuth2ParameterNames.USERNAME) val password: String = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD) if (StringUtils.hasText(username) && StringUtils.hasText(password)) { contextAttributes = hashMapOf() // `PasswordOAuth2AuthorizedClientProvider` requires both attributes contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password } contextAttributes } } The DefaultOAuth2AuthorizedClientManager is designed to be used within the context of a HttpServletRequest . When operating outside of a HttpServletRequest context, use AuthorizedClientServiceOAuth2AuthorizedClientManager instead. A service application is a common use case for when to use an AuthorizedClientServiceOAuth2AuthorizedClientManager . Service applications often run in the background, without any user interaction, and typically run under a system-level account instead of a user account. An OAuth 2.0 Client configured with the client_credentials grant type can be considered a type of service application. The following code shows an example of how to configure an AuthorizedClientServiceOAuth2AuthorizedClientManager that provides support for the client_credentials grant type: Java Kotlin @Bean public OAuth2AuthorizedClientManager authorizedClientManager( ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientService authorizedClientService) { OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .clientCredentials() .build(); AuthorizedClientServiceOAuth2AuthorizedClientManager authorizedClientManager = new AuthorizedClientServiceOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientService); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean fun authorizedClientManager( clientRegistrationRepository: ClientRegistrationRepository, authorizedClientService: OAuth2AuthorizedClientService): OAuth2AuthorizedClientManager { val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .clientCredentials() .build() val authorizedClientManager = AuthorizedClientServiceOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientService) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/client/authorization-grants.html","Authorization Grant Support: This section describes Spring Security’s support for authorization grants. Authorization Code: See the OAuth 2.0 Authorization Framework for further details on the Authorization Code(https://tools.ietf.org/html/rfc6749#section-1.3.1) grant. Obtaining Authorization: See the Authorization Request/Response(https://tools.ietf.org/html/rfc6749#section-4.1.1) protocol flow for the Authorization Code grant. Initiating the Authorization Request: The OAuth2AuthorizationRequestRedirectFilter uses an OAuth2AuthorizationRequestResolver to resolve an OAuth2AuthorizationRequest and initiate the Authorization Code grant flow by redirecting the end-user’s user-agent to the Authorization Server’s Authorization Endpoint. The primary role of the OAuth2AuthorizationRequestResolver is to resolve an OAuth2AuthorizationRequest from the provided web request. The default implementation DefaultOAuth2AuthorizationRequestResolver matches on the (default) path /oauth2/authorization/{registrationId} , extracting the registrationId , and using it to build the OAuth2AuthorizationRequest for the associated ClientRegistration . Consider the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret authorization-grant-type: authorization_code redirect-uri: ""{baseUrl}/authorized/okta"" scope: read, write provider: okta: authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token Given the preceding properties, a request with the base path /oauth2/authorization/okta initiates the Authorization Request redirect by the OAuth2AuthorizationRequestRedirectFilter and ultimately starts the Authorization Code grant flow. The AuthorizationCodeOAuth2AuthorizedClientProvider is an implementation of OAuth2AuthorizedClientProvider for the Authorization Code grant, which also initiates the Authorization Request redirect by the OAuth2AuthorizationRequestRedirectFilter . If the OAuth 2.0 Client is a Public Client(https://tools.ietf.org/html/rfc6749#section-2.1) , configure the OAuth 2.0 Client registration as follows: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-authentication-method: none authorization-grant-type: authorization_code redirect-uri: ""{baseUrl}/authorized/okta"" ... Public Clients are supported by using Proof Key for Code Exchange(https://tools.ietf.org/html/rfc7636) (PKCE). If the client is running in an untrusted environment (such as a native application or web browser-based application) and is therefore incapable of maintaining the confidentiality of its credentials, PKCE is automatically used when the following conditions are true: client-secret is omitted (or empty) client-authentication-method is set to none ( ClientAuthenticationMethod.NONE ) If the OAuth 2.0 Provider supports PKCE for Confidential Clients(https://tools.ietf.org/html/rfc6749#section-2.1) , you may (optionally) configure it using DefaultOAuth2AuthorizationRequestResolver.setAuthorizationRequestCustomizer(OAuth2AuthorizationRequestCustomizers.withPkce()) . The DefaultOAuth2AuthorizationRequestResolver also supports URI template variables for the redirect-uri by using UriComponentsBuilder . The following configuration uses all the supported URI template variables: spring: security: oauth2: client: registration: okta: ... redirect-uri: ""{baseScheme}://{baseHost}{basePort}{basePath}/authorized/{registrationId}"" ... {baseUrl} resolves to {baseScheme}://{baseHost}{basePort}{basePath} Configuring the redirect-uri with URI template variables is especially useful when the OAuth 2.0 Client is running behind a Proxy Server(../../../features/exploits/http.html#http-proxy-server) . Doing so ensures that the X-Forwarded-* headers are used when expanding the redirect-uri . Customizing the Authorization Request: One of the primary use cases an OAuth2AuthorizationRequestResolver can realize is the ability to customize the Authorization Request with additional parameters above the standard parameters defined in the OAuth 2.0 Authorization Framework. For example, OpenID Connect defines additional OAuth 2.0 request parameters for the Authorization Code Flow(https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) extending from the standard parameters defined in the OAuth 2.0 Authorization Framework(https://tools.ietf.org/html/rfc6749#section-4.1.1) . One of those extended parameters is the prompt parameter. The prompt parameter is optional. Space delimited, case sensitive list of ASCII string values that specifies whether the Authorization Server prompts the End-User for re-authentication and consent. The defined values are: none , login , consent , and select_account . The following example shows how to configure the DefaultOAuth2AuthorizationRequestResolver with a Consumer<OAuth2AuthorizationRequest.Builder> that customizes the Authorization Request for oauth2Login() , by including the request parameter prompt=consent . Java Kotlin @Configuration @EnableWebSecurity public class OAuth2LoginSecurityConfig { @Autowired private ClientRegistrationRepository clientRegistrationRepository; @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2Login(oauth2 -> oauth2 .authorizationEndpoint(authorization -> authorization .authorizationRequestResolver( authorizationRequestResolver(this.clientRegistrationRepository) ) ) ); return http.build(); } private OAuth2AuthorizationRequestResolver authorizationRequestResolver( ClientRegistrationRepository clientRegistrationRepository) { DefaultOAuth2AuthorizationRequestResolver authorizationRequestResolver = new DefaultOAuth2AuthorizationRequestResolver( clientRegistrationRepository, ""/oauth2/authorization""); authorizationRequestResolver.setAuthorizationRequestCustomizer( authorizationRequestCustomizer()); return authorizationRequestResolver; } private Consumer<OAuth2AuthorizationRequest.Builder> authorizationRequestCustomizer() { return customizer -> customizer .additionalParameters(params -> params.put(""prompt"", ""consent"")); } } @Configuration @EnableWebSecurity class SecurityConfig { @Autowired private lateinit var customClientRegistrationRepository: ClientRegistrationRepository @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2Login { authorizationEndpoint { authorizationRequestResolver = authorizationRequestResolver(customClientRegistrationRepository) } } } return http.build() } private fun authorizationRequestResolver( clientRegistrationRepository: ClientRegistrationRepository?): OAuth2AuthorizationRequestResolver? { val authorizationRequestResolver = DefaultOAuth2AuthorizationRequestResolver( clientRegistrationRepository, ""/oauth2/authorization"") authorizationRequestResolver.setAuthorizationRequestCustomizer( authorizationRequestCustomizer()) return authorizationRequestResolver } private fun authorizationRequestCustomizer(): Consumer<OAuth2AuthorizationRequest.Builder> { return Consumer { customizer -> customizer .additionalParameters { params -> params[""prompt""] = ""consent"" } } } } For the simple use case where the additional request parameter is always the same for a specific provider, you can add it directly in the authorization-uri property. For example, if the value for the request parameter prompt is always consent for the provider okta , you can configure it as follows: spring: security: oauth2: client: provider: okta: authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize?prompt=consent The preceding example shows the common use case of adding a custom parameter on top of the standard parameters. Alternatively, if your requirements are more advanced, you can take full control in building the Authorization Request URI by overriding the OAuth2AuthorizationRequest.authorizationRequestUri property. OAuth2AuthorizationRequest.Builder.build() constructs the OAuth2AuthorizationRequest.authorizationRequestUri , which represents the Authorization Request URI including all query parameters using the application/x-www-form-urlencoded format. The following example shows a variation of authorizationRequestCustomizer() from the preceding example and instead overrides the OAuth2AuthorizationRequest.authorizationRequestUri property: Java Kotlin private Consumer<OAuth2AuthorizationRequest.Builder> authorizationRequestCustomizer() { return customizer -> customizer .authorizationRequestUri(uriBuilder -> uriBuilder .queryParam(""prompt"", ""consent"").build()); } private fun authorizationRequestCustomizer(): Consumer<OAuth2AuthorizationRequest.Builder> { return Consumer { customizer: OAuth2AuthorizationRequest.Builder -> customizer .authorizationRequestUri { uriBuilder: UriBuilder -> uriBuilder .queryParam(""prompt"", ""consent"").build() } } } Storing the Authorization Request: The AuthorizationRequestRepository is responsible for the persistence of the OAuth2AuthorizationRequest from the time the Authorization Request is initiated to the time the Authorization Response is received (the callback). The OAuth2AuthorizationRequest is used to correlate and validate the Authorization Response. The default implementation of AuthorizationRequestRepository is HttpSessionOAuth2AuthorizationRequestRepository , which stores the OAuth2AuthorizationRequest in the HttpSession . If you have a custom implementation of AuthorizationRequestRepository , you can configure it as follows: AuthorizationRequestRepository Configuration Java Kotlin Xml @Configuration @EnableWebSecurity public class OAuth2ClientSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .oauth2Client(oauth2 -> oauth2 .authorizationCodeGrant(codeGrant -> codeGrant .authorizationRequestRepository(this.authorizationRequestRepository()) ... ) .oauth2Login(oauth2 -> oauth2 .authorizationEndpoint(endpoint -> endpoint .authorizationRequestRepository(this.authorizationRequestRepository()) ... ) ).build(); } @Bean public AuthorizationRequestRepository<OAuth2AuthorizationRequest> authorizationRequestRepository() { return new CustomOAuth2AuthorizationRequestRepository(); } } @Configuration @EnableWebSecurity class OAuth2ClientSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { oauth2Client { authorizationCodeGrant { authorizationRequestRepository = authorizationRequestRepository() } } } return http.build() } } <http> <oauth2-client> <authorization-code-grant authorization-request-repository-ref=""authorizationRequestRepository""/> </oauth2-client> </http> Requesting an Access Token: See the Access Token Request/Response(https://tools.ietf.org/html/rfc6749#section-4.1.3) protocol flow for the Authorization Code grant. The default implementation of OAuth2AccessTokenResponseClient for the Authorization Code grant is DefaultAuthorizationCodeTokenResponseClient , which uses a RestOperations instance to exchange an authorization code for an access token at the Authorization Server’s Token Endpoint. The DefaultAuthorizationCodeTokenResponseClient is flexible, as it lets you customize the pre-processing of the Token Request and/or post-handling of the Token Response. Customizing the Access Token Request: If you need to customize the pre-processing of the Token Request, you can provide DefaultAuthorizationCodeTokenResponseClient.setRequestEntityConverter() with a custom Converter<OAuth2AuthorizationCodeGrantRequest, RequestEntity<?>> . The default implementation ( OAuth2AuthorizationCodeGrantRequestEntityConverter ) builds a RequestEntity representation of a standard OAuth 2.0 Access Token Request(https://tools.ietf.org/html/rfc6749#section-4.1.3) . However, providing a custom Converter would let you extend the standard Token Request and add custom parameter(s). To customize only the parameters of the request, you can provide OAuth2AuthorizationCodeGrantRequestEntityConverter.setParametersConverter() with a custom Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> to completely override the parameters sent with the request. This is often simpler than constructing a RequestEntity directly. If you prefer to only add additional parameters, you can provide OAuth2AuthorizationCodeGrantRequestEntityConverter.addParametersConverter() with a custom Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> which constructs an aggregate Converter . The custom Converter must return a valid RequestEntity representation of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider. Customizing the Access Token Response: On the other end, if you need to customize the post-handling of the Token Response, you need to provide DefaultAuthorizationCodeTokenResponseClient.setRestOperations() with a custom configured RestOperations . The default RestOperations is configured as follows: Java Kotlin RestTemplate restTemplate = new RestTemplate(Arrays.asList( new FormHttpMessageConverter(), new OAuth2AccessTokenResponseHttpMessageConverter())); restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler()); val restTemplate = RestTemplate(listOf( FormHttpMessageConverter(), OAuth2AccessTokenResponseHttpMessageConverter())) restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler() Spring MVC FormHttpMessageConverter is required, as it is used when sending the OAuth 2.0 Access Token Request. OAuth2AccessTokenResponseHttpMessageConverter is an HttpMessageConverter for an OAuth 2.0 Access Token Response. You can provide OAuth2AccessTokenResponseHttpMessageConverter.setAccessTokenResponseConverter() with a custom Converter<Map<String, Object>, OAuth2AccessTokenResponse> that is used for converting the OAuth 2.0 Access Token Response parameters to an OAuth2AccessTokenResponse . OAuth2ErrorResponseErrorHandler is a ResponseErrorHandler that can handle an OAuth 2.0 Error, such as 400 Bad Request . It uses an OAuth2ErrorHttpMessageConverter for converting the OAuth 2.0 Error parameters to an OAuth2Error . Whether you customize DefaultAuthorizationCodeTokenResponseClient or provide your own implementation of OAuth2AccessTokenResponseClient , you need to configure it as follows: Access Token Response Configuration Java Kotlin Xml @Configuration @EnableWebSecurity public class OAuth2ClientSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .oauth2Client(oauth2 -> oauth2 .authorizationCodeGrant(codeGrant -> codeGrant .accessTokenResponseClient(this.accessTokenResponseClient()) ... ) ); return http.build(); } } @Configuration @EnableWebSecurity class OAuth2ClientSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { oauth2Client { authorizationCodeGrant { accessTokenResponseClient = accessTokenResponseClient() } } } return http.build() } } <http> <oauth2-client> <authorization-code-grant access-token-response-client-ref=""accessTokenResponseClient""/> </oauth2-client> </http> Refresh Token: See the OAuth 2.0 Authorization Framework for further details on the Refresh Token(https://tools.ietf.org/html/rfc6749#section-1.5) . Refreshing an Access Token: See the Access Token Request/Response(https://tools.ietf.org/html/rfc6749#section-6) protocol flow for the Refresh Token grant. The default implementation of OAuth2AccessTokenResponseClient for the Refresh Token grant is DefaultRefreshTokenTokenResponseClient , which uses a RestOperations when refreshing an access token at the Authorization Server’s Token Endpoint. The DefaultRefreshTokenTokenResponseClient is flexible, as it lets you customize the pre-processing of the Token Request or post-handling of the Token Response. Customizing the Access Token Request: If you need to customize the pre-processing of the Token Request, you can provide DefaultRefreshTokenTokenResponseClient.setRequestEntityConverter() with a custom Converter<OAuth2RefreshTokenGrantRequest, RequestEntity<?>> . The default implementation ( OAuth2RefreshTokenGrantRequestEntityConverter ) builds a RequestEntity representation of a standard OAuth 2.0 Access Token Request(https://tools.ietf.org/html/rfc6749#section-6) . However, providing a custom Converter would let you extend the standard Token Request and add custom parameter(s). To customize only the parameters of the request, you can provide OAuth2RefreshTokenGrantRequestEntityConverter.setParametersConverter() with a custom Converter<OAuth2RefreshTokenGrantRequest, MultiValueMap<String, String>> to completely override the parameters sent with the request. This is often simpler than constructing a RequestEntity directly. If you prefer to only add additional parameters, you can provide OAuth2RefreshTokenGrantRequestEntityConverter.addParametersConverter() with a custom Converter<OAuth2RefreshTokenGrantRequest, MultiValueMap<String, String>> which constructs an aggregate Converter . The custom Converter must return a valid RequestEntity representation of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider. Customizing the Access Token Response: On the other end, if you need to customize the post-handling of the Token Response, you need to provide DefaultRefreshTokenTokenResponseClient.setRestOperations() with a custom configured RestOperations . The default RestOperations is configured as follows: Java Kotlin RestTemplate restTemplate = new RestTemplate(Arrays.asList( new FormHttpMessageConverter(), new OAuth2AccessTokenResponseHttpMessageConverter())); restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler()); val restTemplate = RestTemplate(listOf( FormHttpMessageConverter(), OAuth2AccessTokenResponseHttpMessageConverter())) restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler() Spring MVC FormHttpMessageConverter is required, as it is used when sending the OAuth 2.0 Access Token Request. OAuth2AccessTokenResponseHttpMessageConverter is a HttpMessageConverter for an OAuth 2.0 Access Token Response. You can provide OAuth2AccessTokenResponseHttpMessageConverter.setAccessTokenResponseConverter() with a custom Converter<Map<String, Object>, OAuth2AccessTokenResponse> that is used for converting the OAuth 2.0 Access Token Response parameters to an OAuth2AccessTokenResponse . OAuth2ErrorResponseErrorHandler is a ResponseErrorHandler that can handle an OAuth 2.0 Error, such as 400 Bad Request . It uses an OAuth2ErrorHttpMessageConverter for converting the OAuth 2.0 Error parameters to an OAuth2Error . Whether you customize DefaultRefreshTokenTokenResponseClient or provide your own implementation of OAuth2AccessTokenResponseClient , you need to configure it as follows: Java Kotlin // Customize OAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> refreshTokenTokenResponseClient = ... OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken(configurer -> configurer.accessTokenResponseClient(refreshTokenTokenResponseClient)) .build(); ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); // Customize val refreshTokenTokenResponseClient: OAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> = ... val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken { it.accessTokenResponseClient(refreshTokenTokenResponseClient) } .build() ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) OAuth2AuthorizedClientProviderBuilder.builder().refreshToken() configures a RefreshTokenOAuth2AuthorizedClientProvider , which is an implementation of an OAuth2AuthorizedClientProvider for the Refresh Token grant. The OAuth2RefreshToken can optionally be returned in the Access Token Response for the authorization_code and password grant types. If the OAuth2AuthorizedClient.getRefreshToken() is available and the OAuth2AuthorizedClient.getAccessToken() is expired, it is automatically refreshed by the RefreshTokenOAuth2AuthorizedClientProvider . Client Credentials: Please refer to the OAuth 2.0 Authorization Framework for further details on the Client Credentials(https://tools.ietf.org/html/rfc6749#section-1.3.4) grant. Requesting an Access Token: See the OAuth 2.0 Authorization Framework for further details on the Client Credentials(https://tools.ietf.org/html/rfc6749#section-1.3.4) grant. The default implementation of OAuth2AccessTokenResponseClient for the Client Credentials grant is DefaultClientCredentialsTokenResponseClient , which uses a RestOperations when requesting an access token at the Authorization Server’s Token Endpoint. The DefaultClientCredentialsTokenResponseClient is flexible, as it lets you customize the pre-processing of the Token Request or post-handling of the Token Response. Customizing the Access Token Request: If you need to customize the pre-processing of the Token Request, you can provide DefaultClientCredentialsTokenResponseClient.setRequestEntityConverter() with a custom Converter<OAuth2ClientCredentialsGrantRequest, RequestEntity<?>> . The default implementation ( OAuth2ClientCredentialsGrantRequestEntityConverter ) builds a RequestEntity representation of a standard OAuth 2.0 Access Token Request(https://tools.ietf.org/html/rfc6749#section-4.4.2) . However, providing a custom Converter would let you extend the standard Token Request and add custom parameter(s). To customize only the parameters of the request, you can provide OAuth2ClientCredentialsGrantRequestEntityConverter.setParametersConverter() with a custom Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> to completely override the parameters sent with the request. This is often simpler than constructing a RequestEntity directly. If you prefer to only add additional parameters, you can provide OAuth2ClientCredentialsGrantRequestEntityConverter.addParametersConverter() with a custom Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> which constructs an aggregate Converter . The custom Converter must return a valid RequestEntity representation of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider. Customizing the Access Token Response: On the other end, if you need to customize the post-handling of the Token Response, you need to provide DefaultClientCredentialsTokenResponseClient.setRestOperations() with a custom configured RestOperations . The default RestOperations is configured as follows: Java Kotlin RestTemplate restTemplate = new RestTemplate(Arrays.asList( new FormHttpMessageConverter(), new OAuth2AccessTokenResponseHttpMessageConverter())); restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler()); val restTemplate = RestTemplate(listOf( FormHttpMessageConverter(), OAuth2AccessTokenResponseHttpMessageConverter())) restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler() Spring MVC FormHttpMessageConverter is required, as it is used when sending the OAuth 2.0 Access Token Request. OAuth2AccessTokenResponseHttpMessageConverter is a HttpMessageConverter for an OAuth 2.0 Access Token Response. You can provide OAuth2AccessTokenResponseHttpMessageConverter.setAccessTokenResponseConverter() with a custom Converter<Map<String, Object>, OAuth2AccessTokenResponse> that is used for converting the OAuth 2.0 Access Token Response parameters to an OAuth2AccessTokenResponse . OAuth2ErrorResponseErrorHandler is a ResponseErrorHandler that can handle an OAuth 2.0 Error, such as 400 Bad Request . It uses an OAuth2ErrorHttpMessageConverter to convert the OAuth 2.0 Error parameters to an OAuth2Error . Whether you customize DefaultClientCredentialsTokenResponseClient or provide your own implementation of OAuth2AccessTokenResponseClient , you need to configure it as follows: Java Kotlin // Customize OAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsTokenResponseClient = ... OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .clientCredentials(configurer -> configurer.accessTokenResponseClient(clientCredentialsTokenResponseClient)) .build(); ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); // Customize val clientCredentialsTokenResponseClient: OAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> = ... val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .clientCredentials { it.accessTokenResponseClient(clientCredentialsTokenResponseClient) } .build() ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) OAuth2AuthorizedClientProviderBuilder.builder().clientCredentials() configures a ClientCredentialsOAuth2AuthorizedClientProvider , which is an implementation of an OAuth2AuthorizedClientProvider for the Client Credentials grant. Using the Access Token: Consider the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret authorization-grant-type: client_credentials scope: read, write provider: okta: token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token Further consider the following OAuth2AuthorizedClientManager @Bean : Java Kotlin @Bean public OAuth2AuthorizedClientManager authorizedClientManager( ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientRepository authorizedClientRepository) { OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .clientCredentials() .build(); DefaultOAuth2AuthorizedClientManager authorizedClientManager = new DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean fun authorizedClientManager( clientRegistrationRepository: ClientRegistrationRepository, authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager { val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .clientCredentials() .build() val authorizedClientManager = DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } Given the preceding properties and bean, you can obtain the OAuth2AccessToken as follows: Java Kotlin @Controller public class OAuth2ClientController { @Autowired private OAuth2AuthorizedClientManager authorizedClientManager; @GetMapping(""/"") public String index(Authentication authentication, HttpServletRequest servletRequest, HttpServletResponse servletResponse) { OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(authentication) .attributes(attrs -> { attrs.put(HttpServletRequest.class.getName(), servletRequest); attrs.put(HttpServletResponse.class.getName(), servletResponse); }) .build(); OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest); OAuth2AccessToken accessToken = authorizedClient.getAccessToken(); ... return ""index""; } } class OAuth2ClientController { @Autowired private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager @GetMapping(""/"") fun index(authentication: Authentication?, servletRequest: HttpServletRequest, servletResponse: HttpServletResponse): String { val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(authentication) .attributes(Consumer { attrs: MutableMap<String, Any> -> attrs[HttpServletRequest::class.java.name] = servletRequest attrs[HttpServletResponse::class.java.name] = servletResponse }) .build() val authorizedClient = authorizedClientManager.authorize(authorizeRequest) val accessToken: OAuth2AccessToken = authorizedClient.accessToken ... return ""index"" } } HttpServletRequest and HttpServletResponse are both OPTIONAL attributes. If not provided, they default to ServletRequestAttributes by using RequestContextHolder.getRequestAttributes() . Resource Owner Password Credentials: See the OAuth 2.0 Authorization Framework for further details on the Resource Owner Password Credentials(https://tools.ietf.org/html/rfc6749#section-1.3.3) grant. Requesting an Access Token: See the Access Token Request/Response(https://tools.ietf.org/html/rfc6749#section-4.3.2) protocol flow for the Resource Owner Password Credentials grant. The default implementation of OAuth2AccessTokenResponseClient for the Resource Owner Password Credentials grant is DefaultPasswordTokenResponseClient , which uses a RestOperations when requesting an access token at the Authorization Server’s Token Endpoint. The DefaultPasswordTokenResponseClient is flexible, as it lets you customize the pre-processing of the Token Request or post-handling of the Token Response. Customizing the Access Token Request: If you need to customize the pre-processing of the Token Request, you can provide DefaultPasswordTokenResponseClient.setRequestEntityConverter() with a custom Converter<OAuth2PasswordGrantRequest, RequestEntity<?>> . The default implementation ( OAuth2PasswordGrantRequestEntityConverter ) builds a RequestEntity representation of a standard OAuth 2.0 Access Token Request(https://tools.ietf.org/html/rfc6749#section-4.3.2) . However, providing a custom Converter would let you extend the standard Token Request and add custom parameter(s). To customize only the parameters of the request, you can provide OAuth2PasswordGrantRequestEntityConverter.setParametersConverter() with a custom Converter<OAuth2PasswordGrantRequest, MultiValueMap<String, String>> to completely override the parameters sent with the request. This is often simpler than constructing a RequestEntity directly. If you prefer to only add additional parameters, you can provide OAuth2PasswordGrantRequestEntityConverter.addParametersConverter() with a custom Converter<OAuth2PasswordGrantRequest, MultiValueMap<String, String>> which constructs an aggregate Converter . The custom Converter must return a valid RequestEntity representation of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider. Customizing the Access Token Response: On the other end, if you need to customize the post-handling of the Token Response, you need to provide DefaultPasswordTokenResponseClient.setRestOperations() with a custom configured RestOperations . The default RestOperations is configured as follows: Java Kotlin RestTemplate restTemplate = new RestTemplate(Arrays.asList( new FormHttpMessageConverter(), new OAuth2AccessTokenResponseHttpMessageConverter())); restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler()); val restTemplate = RestTemplate(listOf( FormHttpMessageConverter(), OAuth2AccessTokenResponseHttpMessageConverter())) restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler() Spring MVC FormHttpMessageConverter is required, as it is used when sending the OAuth 2.0 Access Token Request. OAuth2AccessTokenResponseHttpMessageConverter is a HttpMessageConverter for an OAuth 2.0 Access Token Response. You can provide OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter() with a custom Converter<Map<String, String>, OAuth2AccessTokenResponse> that is used to convert the OAuth 2.0 Access Token Response parameters to an OAuth2AccessTokenResponse . OAuth2ErrorResponseErrorHandler is a ResponseErrorHandler that can handle an OAuth 2.0 Error, such as 400 Bad Request . It uses an OAuth2ErrorHttpMessageConverter to convert the OAuth 2.0 Error parameters to an OAuth2Error . Whether you customize DefaultPasswordTokenResponseClient or provide your own implementation of OAuth2AccessTokenResponseClient , you need to configure it as follows: Java Kotlin // Customize OAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> passwordTokenResponseClient = ... OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .password(configurer -> configurer.accessTokenResponseClient(passwordTokenResponseClient)) .refreshToken() .build(); ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); val passwordTokenResponseClient: OAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> = ... val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .password { it.accessTokenResponseClient(passwordTokenResponseClient) } .refreshToken() .build() ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) OAuth2AuthorizedClientProviderBuilder.builder().password() configures a PasswordOAuth2AuthorizedClientProvider , which is an implementation of an OAuth2AuthorizedClientProvider for the Resource Owner Password Credentials grant. Using the Access Token: Consider the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret authorization-grant-type: password scope: read, write provider: okta: token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token Further consider the OAuth2AuthorizedClientManager @Bean : Java Kotlin @Bean public OAuth2AuthorizedClientManager authorizedClientManager( ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientRepository authorizedClientRepository) { OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .password() .refreshToken() .build(); DefaultOAuth2AuthorizedClientManager authorizedClientManager = new DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); // Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters, // map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()` authorizedClientManager.setContextAttributesMapper(contextAttributesMapper()); return authorizedClientManager; } private Function<OAuth2AuthorizeRequest, Map<String, Object>> contextAttributesMapper() { return authorizeRequest -> { Map<String, Object> contextAttributes = Collections.emptyMap(); HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName()); String username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME); String password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD); if (StringUtils.hasText(username) && StringUtils.hasText(password)) { contextAttributes = new HashMap<>(); // `PasswordOAuth2AuthorizedClientProvider` requires both attributes contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username); contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password); } return contextAttributes; }; } @Bean fun authorizedClientManager( clientRegistrationRepository: ClientRegistrationRepository, authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager { val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .password() .refreshToken() .build() val authorizedClientManager = DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) // Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters, // map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()` authorizedClientManager.setContextAttributesMapper(contextAttributesMapper()) return authorizedClientManager } private fun contextAttributesMapper(): Function<OAuth2AuthorizeRequest, MutableMap<String, Any>> { return Function { authorizeRequest -> var contextAttributes: MutableMap<String, Any> = mutableMapOf() val servletRequest: HttpServletRequest = authorizeRequest.getAttribute(HttpServletRequest::class.java.name) val username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME) val password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD) if (StringUtils.hasText(username) && StringUtils.hasText(password)) { contextAttributes = hashMapOf() // `PasswordOAuth2AuthorizedClientProvider` requires both attributes contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password } contextAttributes } } Given the preceding properties and bean, you can obtain the OAuth2AccessToken as follows: Java Kotlin @Controller public class OAuth2ClientController { @Autowired private OAuth2AuthorizedClientManager authorizedClientManager; @GetMapping(""/"") public String index(Authentication authentication, HttpServletRequest servletRequest, HttpServletResponse servletResponse) { OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(authentication) .attributes(attrs -> { attrs.put(HttpServletRequest.class.getName(), servletRequest); attrs.put(HttpServletResponse.class.getName(), servletResponse); }) .build(); OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest); OAuth2AccessToken accessToken = authorizedClient.getAccessToken(); ... return ""index""; } } @Controller class OAuth2ClientController { @Autowired private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager @GetMapping(""/"") fun index(authentication: Authentication?, servletRequest: HttpServletRequest, servletResponse: HttpServletResponse): String { val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(authentication) .attributes(Consumer { it[HttpServletRequest::class.java.name] = servletRequest it[HttpServletResponse::class.java.name] = servletResponse }) .build() val authorizedClient = authorizedClientManager.authorize(authorizeRequest) val accessToken: OAuth2AccessToken = authorizedClient.accessToken ... return ""index"" } } HttpServletRequest and HttpServletResponse are both OPTIONAL attributes. If not provided, they default to ServletRequestAttributes using RequestContextHolder.getRequestAttributes() . JWT Bearer: Please refer to JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants for further details on the JWT Bearer(https://datatracker.ietf.org/doc/html/rfc7523) grant. Requesting an Access Token: Please refer to the Access Token Request/Response(https://datatracker.ietf.org/doc/html/rfc7523#section-2.1) protocol flow for the JWT Bearer grant. The default implementation of OAuth2AccessTokenResponseClient for the JWT Bearer grant is DefaultJwtBearerTokenResponseClient , which uses a RestOperations when requesting an access token at the Authorization Server’s Token Endpoint. The DefaultJwtBearerTokenResponseClient is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response. Customizing the Access Token Request: If you need to customize the pre-processing of the Token Request, you can provide DefaultJwtBearerTokenResponseClient.setRequestEntityConverter() with a custom Converter<JwtBearerGrantRequest, RequestEntity<?>> . The default implementation JwtBearerGrantRequestEntityConverter builds a RequestEntity representation of a OAuth 2.0 Access Token Request(https://datatracker.ietf.org/doc/html/rfc7523#section-2.1) . However, providing a custom Converter , would allow you to extend the Token Request and add custom parameter(s). To customize only the parameters of the request, you can provide JwtBearerGrantRequestEntityConverter.setParametersConverter() with a custom Converter<JwtBearerGrantRequest, MultiValueMap<String, String>> to completely override the parameters sent with the request. This is often simpler than constructing a RequestEntity directly. If you prefer to only add additional parameters, you can provide JwtBearerGrantRequestEntityConverter.addParametersConverter() with a custom Converter<JwtBearerGrantRequest, MultiValueMap<String, String>> which constructs an aggregate Converter . Customizing the Access Token Response: On the other end, if you need to customize the post-handling of the Token Response, you will need to provide DefaultJwtBearerTokenResponseClient.setRestOperations() with a custom configured RestOperations . The default RestOperations is configured as follows: Java Kotlin RestTemplate restTemplate = new RestTemplate(Arrays.asList( new FormHttpMessageConverter(), new OAuth2AccessTokenResponseHttpMessageConverter())); restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler()); val restTemplate = RestTemplate(listOf( FormHttpMessageConverter(), OAuth2AccessTokenResponseHttpMessageConverter())) restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler() Spring MVC FormHttpMessageConverter is required as it’s used when sending the OAuth 2.0 Access Token Request. OAuth2AccessTokenResponseHttpMessageConverter is a HttpMessageConverter for an OAuth 2.0 Access Token Response. You can provide OAuth2AccessTokenResponseHttpMessageConverter.setAccessTokenResponseConverter() with a custom Converter<Map<String, Object>, OAuth2AccessTokenResponse> that is used for converting the OAuth 2.0 Access Token Response parameters to an OAuth2AccessTokenResponse . OAuth2ErrorResponseErrorHandler is a ResponseErrorHandler that can handle an OAuth 2.0 Error, eg. 400 Bad Request. It uses an OAuth2ErrorHttpMessageConverter for converting the OAuth 2.0 Error parameters to an OAuth2Error . Whether you customize DefaultJwtBearerTokenResponseClient or provide your own implementation of OAuth2AccessTokenResponseClient , you’ll need to configure it as shown in the following example: Java Kotlin // Customize OAuth2AccessTokenResponseClient<JwtBearerGrantRequest> jwtBearerTokenResponseClient = ... JwtBearerOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider = new JwtBearerOAuth2AuthorizedClientProvider(); jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient); OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .provider(jwtBearerAuthorizedClientProvider) .build(); ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); // Customize val jwtBearerTokenResponseClient: OAuth2AccessTokenResponseClient<JwtBearerGrantRequest> = ... val jwtBearerAuthorizedClientProvider = JwtBearerOAuth2AuthorizedClientProvider() jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient); val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .provider(jwtBearerAuthorizedClientProvider) .build() ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) Using the Access Token: Given the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret authorization-grant-type: urn:ietf:params:oauth:grant-type:jwt-bearer scope: read provider: okta: token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token …​and the OAuth2AuthorizedClientManager @Bean : Java Kotlin @Bean public OAuth2AuthorizedClientManager authorizedClientManager( ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientRepository authorizedClientRepository) { JwtBearerOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider = new JwtBearerOAuth2AuthorizedClientProvider(); OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .provider(jwtBearerAuthorizedClientProvider) .build(); DefaultOAuth2AuthorizedClientManager authorizedClientManager = new DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean fun authorizedClientManager( clientRegistrationRepository: ClientRegistrationRepository, authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager { val jwtBearerAuthorizedClientProvider = JwtBearerOAuth2AuthorizedClientProvider() val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .provider(jwtBearerAuthorizedClientProvider) .build() val authorizedClientManager = DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } You may obtain the OAuth2AccessToken as follows: Java Kotlin @RestController public class OAuth2ResourceServerController { @Autowired private OAuth2AuthorizedClientManager authorizedClientManager; @GetMapping(""/resource"") public String resource(JwtAuthenticationToken jwtAuthentication) { OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(jwtAuthentication) .build(); OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest); OAuth2AccessToken accessToken = authorizedClient.getAccessToken(); ... } } class OAuth2ResourceServerController { @Autowired private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager @GetMapping(""/resource"") fun resource(jwtAuthentication: JwtAuthenticationToken?): String { val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(jwtAuthentication) .build() val authorizedClient = authorizedClientManager.authorize(authorizeRequest) val accessToken: OAuth2AccessToken = authorizedClient.accessToken ... } } JwtBearerOAuth2AuthorizedClientProvider resolves the Jwt assertion via OAuth2AuthorizationContext.getPrincipal().getPrincipal() by default, hence the use of JwtAuthenticationToken in the preceding example. If you need to resolve the Jwt assertion from a different source, you can provide JwtBearerOAuth2AuthorizedClientProvider.setJwtAssertionResolver() with a custom Function<OAuth2AuthorizationContext, Jwt> . Token Exchange: Please refer to OAuth 2.0 Token Exchange for further details on the Token Exchange(https://datatracker.ietf.org/doc/html/rfc8693) grant. Requesting an Access Token: Please refer to the Token Exchange Request and Response(https://datatracker.ietf.org/doc/html/rfc8693#section-2) protocol flow for the Token Exchange grant. The default implementation of OAuth2AccessTokenResponseClient for the Token Exchange grant is DefaultTokenExchangeTokenResponseClient , which uses a RestOperations when requesting an access token at the Authorization Server’s Token Endpoint. The DefaultTokenExchangeTokenResponseClient is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response. Customizing the Access Token Request: If you need to customize the pre-processing of the Token Request, you can provide DefaultTokenExchangeTokenResponseClient.setRequestEntityConverter() with a custom Converter<TokenExchangeGrantRequest, RequestEntity<?>> . The default implementation TokenExchangeGrantRequestEntityConverter builds a RequestEntity representation of a OAuth 2.0 Access Token Request(https://datatracker.ietf.org/doc/html/rfc8693#section-2.1) . However, providing a custom Converter , would allow you to extend the Token Request and add custom parameter(s). To customize only the parameters of the request, you can provide TokenExchangeGrantRequestEntityConverter.setParametersConverter() with a custom Converter<TokenExchangeGrantRequest, MultiValueMap<String, String>> to completely override the parameters sent with the request. This is often simpler than constructing a RequestEntity directly. If you prefer to only add additional parameters, you can provide TokenExchangeGrantRequestEntityConverter.addParametersConverter() with a custom Converter<TokenExchangeGrantRequest, MultiValueMap<String, String>> which constructs an aggregate Converter . Customizing the Access Token Response: On the other end, if you need to customize the post-handling of the Token Response, you will need to provide DefaultTokenExchangeTokenResponseClient.setRestOperations() with a custom configured RestOperations . The default RestOperations is configured as follows: Java Kotlin RestTemplate restTemplate = new RestTemplate(Arrays.asList( new FormHttpMessageConverter(), new OAuth2AccessTokenResponseHttpMessageConverter())); restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler()); val restTemplate = RestTemplate(listOf( FormHttpMessageConverter(), OAuth2AccessTokenResponseHttpMessageConverter())) restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler() Spring MVC FormHttpMessageConverter is required as it’s used when sending the OAuth 2.0 Access Token Request. OAuth2AccessTokenResponseHttpMessageConverter is a HttpMessageConverter for an OAuth 2.0 Access Token Response. You can provide OAuth2AccessTokenResponseHttpMessageConverter.setAccessTokenResponseConverter() with a custom Converter<Map<String, Object>, OAuth2AccessTokenResponse> that is used for converting the OAuth 2.0 Access Token Response parameters to an OAuth2AccessTokenResponse . OAuth2ErrorResponseErrorHandler is a ResponseErrorHandler that can handle an OAuth 2.0 Error, eg. 400 Bad Request. It uses an OAuth2ErrorHttpMessageConverter for converting the OAuth 2.0 Error parameters to an OAuth2Error . Whether you customize DefaultTokenExchangeTokenResponseClient or provide your own implementation of OAuth2AccessTokenResponseClient , you’ll need to configure it as shown in the following example: Java Kotlin // Customize OAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> tokenExchangeTokenResponseClient = ... TokenExchangeOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider = new TokenExchangeOAuth2AuthorizedClientProvider(); tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeTokenResponseClient); OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .provider(tokenExchangeAuthorizedClientProvider) .build(); ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); // Customize val tokenExchangeTokenResponseClient: OAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> = ... val tokenExchangeAuthorizedClientProvider = TokenExchangeOAuth2AuthorizedClientProvider() tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeTokenResponseClient) val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .provider(tokenExchangeAuthorizedClientProvider) .build() ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) Using the Access Token: Given the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret authorization-grant-type: urn:ietf:params:oauth:grant-type:token-exchange scope: read provider: okta: token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token …​and the OAuth2AuthorizedClientManager @Bean : Java Kotlin @Bean public OAuth2AuthorizedClientManager authorizedClientManager( ClientRegistrationRepository clientRegistrationRepository, OAuth2AuthorizedClientRepository authorizedClientRepository) { TokenExchangeOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider = new TokenExchangeOAuth2AuthorizedClientProvider(); OAuth2AuthorizedClientProvider authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .provider(tokenExchangeAuthorizedClientProvider) .build(); DefaultOAuth2AuthorizedClientManager authorizedClientManager = new DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean fun authorizedClientManager( clientRegistrationRepository: ClientRegistrationRepository, authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager { val tokenExchangeAuthorizedClientProvider = TokenExchangeOAuth2AuthorizedClientProvider() val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .provider(tokenExchangeAuthorizedClientProvider) .build() val authorizedClientManager = DefaultOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } You may obtain the OAuth2AccessToken as follows: Java Kotlin @RestController public class OAuth2ResourceServerController { @Autowired private OAuth2AuthorizedClientManager authorizedClientManager; @GetMapping(""/resource"") public String resource(JwtAuthenticationToken jwtAuthentication) { OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(jwtAuthentication) .build(); OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest); OAuth2AccessToken accessToken = authorizedClient.getAccessToken(); ... } } class OAuth2ResourceServerController { @Autowired private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager @GetMapping(""/resource"") fun resource(jwtAuthentication: JwtAuthenticationToken?): String { val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(jwtAuthentication) .build() val authorizedClient = authorizedClientManager.authorize(authorizeRequest) val accessToken: OAuth2AccessToken = authorizedClient.accessToken ... } } TokenExchangeOAuth2AuthorizedClientProvider resolves the subject token (as an OAuth2Token ) via OAuth2AuthorizationContext.getPrincipal().getPrincipal() by default, hence the use of JwtAuthenticationToken in the preceding example. An actor token is not resolved by default. If you need to resolve the subject token from a different source, you can provide TokenExchangeOAuth2AuthorizedClientProvider.setSubjectTokenResolver() with a custom Function<OAuth2AuthorizationContext, OAuth2Token> . If you need to resolve an actor token, you can provide TokenExchangeOAuth2AuthorizedClientProvider.setActorTokenResolver() with a custom Function<OAuth2AuthorizationContext, OAuth2Token> ."
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/client/client-authentication.html","Client Authentication Support: Client Credentials: Authenticate using client_secret_basic: Client Authentication with HTTP Basic is supported out of the box and no customization is necessary to enable it. The default implementation is provided by DefaultOAuth2TokenRequestHeadersConverter . Given the following Spring Boot properties for an OAuth 2.0 client registration: spring: security: oauth2: client: registration: okta: client-id: client-id client-secret: client-secret client-authentication-method: client_secret_basic authorization-grant-type: authorization_code ... The following example shows how to configure DefaultAuthorizationCodeTokenResponseClient to disable URL encoding of the client credentials: Java Kotlin DefaultOAuth2TokenRequestHeadersConverter<OAuth2AuthorizationCodeGrantRequest> headersConverter = new DefaultOAuth2TokenRequestHeadersConverter<>(); headersConverter.setEncodeClientCredentials(false); OAuth2AuthorizationCodeGrantRequestEntityConverter requestEntityConverter = new OAuth2AuthorizationCodeGrantRequestEntityConverter(); requestEntityConverter.setHeadersConverter(headersConverter); DefaultAuthorizationCodeTokenResponseClient tokenResponseClient = new DefaultAuthorizationCodeTokenResponseClient(); tokenResponseClient.setRequestEntityConverter(requestEntityConverter); val headersConverter = DefaultOAuth2TokenRequestHeadersConverter<OAuth2AuthorizationCodeGrantRequest>() headersConverter.setEncodeClientCredentials(false) val requestEntityConverter = OAuth2AuthorizationCodeGrantRequestEntityConverter() requestEntityConverter.setHeadersConverter(headersConverter) val tokenResponseClient = DefaultAuthorizationCodeTokenResponseClient() tokenResponseClient.setRequestEntityConverter(requestEntityConverter) Authenticate using client_secret_post: Client Authentication with client credentials included in the request-body is supported out of the box and no customization is necessary to enable it. The following Spring Boot properties for an OAuth 2.0 client registration demonstrate the configuration: spring: security: oauth2: client: registration: okta: client-id: client-id client-secret: client-secret client-authentication-method: client_secret_post authorization-grant-type: authorization_code ... JWT Bearer: Please refer to JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants for further details on JWT Bearer(https://datatracker.ietf.org/doc/html/rfc7523#section-2.2) Client Authentication. The default implementation for JWT Bearer Client Authentication is NimbusJwtClientAuthenticationParametersConverter , which is a Converter that customizes the Token Request parameters by adding a signed JSON Web Token (JWS) in the client_assertion parameter. The java.security.PrivateKey or javax.crypto.SecretKey used for signing the JWS is supplied by the com.nimbusds.jose.jwk.JWK resolver associated with NimbusJwtClientAuthenticationParametersConverter . Authenticate using private_key_jwt: Given the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-authentication-method: private_key_jwt authorization-grant-type: authorization_code ... The following example shows how to configure DefaultAuthorizationCodeTokenResponseClient : Java Kotlin Function<ClientRegistration, JWK> jwkResolver = (clientRegistration) -> { if (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) { // Assuming RSA key type RSAPublicKey publicKey = ... RSAPrivateKey privateKey = ... return new RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build(); } return null; }; OAuth2AuthorizationCodeGrantRequestEntityConverter requestEntityConverter = new OAuth2AuthorizationCodeGrantRequestEntityConverter(); requestEntityConverter.addParametersConverter( new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver)); DefaultAuthorizationCodeTokenResponseClient tokenResponseClient = new DefaultAuthorizationCodeTokenResponseClient(); tokenResponseClient.setRequestEntityConverter(requestEntityConverter); val jwkResolver: Function<ClientRegistration, JWK> = Function<ClientRegistration, JWK> { clientRegistration -> if (clientRegistration.clientAuthenticationMethod.equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) { // Assuming RSA key type var publicKey: RSAPublicKey var privateKey: RSAPrivateKey RSAKey.Builder(publicKey) = //... .privateKey(privateKey) = //... .keyID(UUID.randomUUID().toString()) .build() } null } val requestEntityConverter = OAuth2AuthorizationCodeGrantRequestEntityConverter() requestEntityConverter.addParametersConverter( NimbusJwtClientAuthenticationParametersConverter(jwkResolver) ) val tokenResponseClient = DefaultAuthorizationCodeTokenResponseClient() tokenResponseClient.setRequestEntityConverter(requestEntityConverter) Authenticate using client_secret_jwt: Given the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret client-authentication-method: client_secret_jwt authorization-grant-type: client_credentials ... The following example shows how to configure DefaultClientCredentialsTokenResponseClient : Java Kotlin Function<ClientRegistration, JWK> jwkResolver = (clientRegistration) -> { if (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.CLIENT_SECRET_JWT)) { SecretKeySpec secretKey = new SecretKeySpec( clientRegistration.getClientSecret().getBytes(StandardCharsets.UTF_8), ""HmacSHA256""); return new OctetSequenceKey.Builder(secretKey) .keyID(UUID.randomUUID().toString()) .build(); } return null; }; OAuth2ClientCredentialsGrantRequestEntityConverter requestEntityConverter = new OAuth2ClientCredentialsGrantRequestEntityConverter(); requestEntityConverter.addParametersConverter( new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver)); DefaultClientCredentialsTokenResponseClient tokenResponseClient = new DefaultClientCredentialsTokenResponseClient(); tokenResponseClient.setRequestEntityConverter(requestEntityConverter); val jwkResolver = Function<ClientRegistration, JWK?> { clientRegistration: ClientRegistration -> if (clientRegistration.clientAuthenticationMethod == ClientAuthenticationMethod.CLIENT_SECRET_JWT) { val secretKey = SecretKeySpec( clientRegistration.clientSecret.toByteArray(StandardCharsets.UTF_8), ""HmacSHA256"" ) OctetSequenceKey.Builder(secretKey) .keyID(UUID.randomUUID().toString()) .build() } null } val requestEntityConverter = OAuth2ClientCredentialsGrantRequestEntityConverter() requestEntityConverter.addParametersConverter( NimbusJwtClientAuthenticationParametersConverter(jwkResolver) ) val tokenResponseClient = DefaultClientCredentialsTokenResponseClient() tokenResponseClient.setRequestEntityConverter(requestEntityConverter) Customizing the JWT assertion: The JWT produced by NimbusJwtClientAuthenticationParametersConverter contains the iss , sub , aud , jti , iat and exp claims by default. You can customize the headers and/or claims by providing a Consumer<NimbusJwtClientAuthenticationParametersConverter.JwtClientAuthenticationContext<T>> to setJwtClientAssertionCustomizer() . The following example shows how to customize claims of the JWT: Java Kotlin Function<ClientRegistration, JWK> jwkResolver = ... NimbusJwtClientAuthenticationParametersConverter<OAuth2ClientCredentialsGrantRequest> converter = new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver); converter.setJwtClientAssertionCustomizer((context) -> { context.getHeaders().header(""custom-header"", ""header-value""); context.getClaims().claim(""custom-claim"", ""claim-value""); }); val jwkResolver = ... val converter: NimbusJwtClientAuthenticationParametersConverter<OAuth2ClientCredentialsGrantRequest> = NimbusJwtClientAuthenticationParametersConverter(jwkResolver) converter.setJwtClientAssertionCustomizer { context -> context.headers.header(""custom-header"", ""header-value"") context.claims.claim(""custom-claim"", ""claim-value"") } Public Authentication: Public Client Authentication is supported out of the box and no customization is necessary to enable it. The following Spring Boot properties for an OAuth 2.0 client registration demonstrate the configuration: spring: security: oauth2: client: registration: okta: client-id: client-id client-authentication-method: none authorization-grant-type: authorization_code ... Public Clients are supported using Proof Key for Code Exchange(https://tools.ietf.org/html/rfc7636) (PKCE). PKCE will automatically be used when client-authentication-method is set to ""none"" ( ClientAuthenticationMethod.NONE )."
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/client/authorized-clients.html","Authorized Client Features: This section covers additional features provided by Spring Security for the OAuth2 client. Resolving an Authorized Client: The @RegisteredOAuth2AuthorizedClient annotation provides the ability to resolve a method parameter to an argument value of type OAuth2AuthorizedClient . This is a convenient alternative compared to accessing the OAuth2AuthorizedClient by using the OAuth2AuthorizedClientManager or OAuth2AuthorizedClientService . The following example shows how to use @RegisteredOAuth2AuthorizedClient : Java Kotlin @Controller public class OAuth2ClientController { @GetMapping(""/"") public String index(@RegisteredOAuth2AuthorizedClient(""okta"") OAuth2AuthorizedClient authorizedClient) { OAuth2AccessToken accessToken = authorizedClient.getAccessToken(); ... return ""index""; } } @Controller class OAuth2ClientController { @GetMapping(""/"") fun index(@RegisteredOAuth2AuthorizedClient(""okta"") authorizedClient: OAuth2AuthorizedClient): String { val accessToken = authorizedClient.accessToken ... return ""index"" } } The @RegisteredOAuth2AuthorizedClient annotation is handled by OAuth2AuthorizedClientArgumentResolver , which directly uses an OAuth2AuthorizedClientManager(core.html#oauth2Client-authorized-manager-provider) and, therefore, inherits its capabilities. WebClient Integration for Servlet Environments: The OAuth 2.0 Client support integrates with WebClient by using an ExchangeFilterFunction . The ServletOAuth2AuthorizedClientExchangeFilterFunction provides a mechanism for requesting protected resources by using an OAuth2AuthorizedClient and including the associated OAuth2AccessToken as a Bearer Token. It directly uses an OAuth2AuthorizedClientManager(core.html#oauth2Client-authorized-manager-provider) and, therefore, inherits the following capabilities: An OAuth2AccessToken is requested if the client has not yet been authorized. authorization_code : Triggers the Authorization Request redirect to initiate the flow. client_credentials : The access token is obtained directly from the Token Endpoint. password : The access token is obtained directly from the Token Endpoint. If the OAuth2AccessToken is expired, it is refreshed (or renewed) if an OAuth2AuthorizedClientProvider is available to perform the authorization The following code shows an example of how to configure WebClient with OAuth 2.0 Client support: Java Kotlin @Bean WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) { ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client = new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); return WebClient.builder() .apply(oauth2Client.oauth2Configuration()) .build(); } @Bean fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient { val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager) return WebClient.builder() .apply(oauth2Client.oauth2Configuration()) .build() } Providing the Authorized Client: The ServletOAuth2AuthorizedClientExchangeFilterFunction determines the client to use (for a request) by resolving the OAuth2AuthorizedClient from the ClientRequest.attributes() (request attributes). The following code shows how to set an OAuth2AuthorizedClient as a request attribute: Java Kotlin @GetMapping(""/"") public String index(@RegisteredOAuth2AuthorizedClient(""okta"") OAuth2AuthorizedClient authorizedClient) { String resourceUri = ... String body = webClient .get() .uri(resourceUri) .attributes(oauth2AuthorizedClient(authorizedClient)) (1) .retrieve() .bodyToMono(String.class) .block(); ... return ""index""; } @GetMapping(""/"") fun index(@RegisteredOAuth2AuthorizedClient(""okta"") authorizedClient: OAuth2AuthorizedClient): String { val resourceUri: String = ... val body: String = webClient .get() .uri(resourceUri) .attributes(oauth2AuthorizedClient(authorizedClient)) (1) .retrieve() .bodyToMono() .block() ... return ""index"" } 1 oauth2AuthorizedClient() is a static method in ServletOAuth2AuthorizedClientExchangeFilterFunction . The following code shows how to set the ClientRegistration.getRegistrationId() as a request attribute: Java Kotlin @GetMapping(""/"") public String index() { String resourceUri = ... String body = webClient .get() .uri(resourceUri) .attributes(clientRegistrationId(""okta"")) (1) .retrieve() .bodyToMono(String.class) .block(); ... return ""index""; } @GetMapping(""/"") fun index(): String { val resourceUri: String = ... val body: String = webClient .get() .uri(resourceUri) .attributes(clientRegistrationId(""okta"")) (1) .retrieve() .bodyToMono() .block() ... return ""index"" } 1 clientRegistrationId() is a static method in ServletOAuth2AuthorizedClientExchangeFilterFunction . The following code shows how to set an Authentication as a request attribute: Java Kotlin @GetMapping(""/"") public String index() { String resourceUri = ... Authentication anonymousAuthentication = new AnonymousAuthenticationToken( ""anonymous"", ""anonymousUser"", AuthorityUtils.createAuthorityList(""ROLE_ANONYMOUS"")); String body = webClient .get() .uri(resourceUri) .attributes(authentication(anonymousAuthentication)) (1) .retrieve() .bodyToMono(String.class) .block(); ... return ""index""; } @GetMapping(""/"") fun index(): String { val resourceUri: String = ... val anonymousAuthentication: Authentication = AnonymousAuthenticationToken( ""anonymous"", ""anonymousUser"", AuthorityUtils.createAuthorityList(""ROLE_ANONYMOUS"")) val body: String = webClient .get() .uri(resourceUri) .attributes(authentication(anonymousAuthentication)) (1) .retrieve() .bodyToMono() .block() ... return ""index"" } 1 authentication() is a static method in ServletOAuth2AuthorizedClientExchangeFilterFunction . It is recommended to be cautious with this feature since all HTTP requests will receive an access token bound to the provided principal. Defaulting the Authorized Client: If neither OAuth2AuthorizedClient or ClientRegistration.getRegistrationId() is provided as a request attribute, the ServletOAuth2AuthorizedClientExchangeFilterFunction can determine the default client to use, depending on its configuration. If setDefaultOAuth2AuthorizedClient(true) is configured and the user has authenticated by using HttpSecurity.oauth2Login() , the OAuth2AccessToken associated with the current OAuth2AuthenticationToken is used. The following code shows the specific configuration: Java Kotlin @Bean WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) { ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client = new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); oauth2Client.setDefaultOAuth2AuthorizedClient(true); return WebClient.builder() .apply(oauth2Client.oauth2Configuration()) .build(); } @Bean fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient { val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager) oauth2Client.setDefaultOAuth2AuthorizedClient(true) return WebClient.builder() .apply(oauth2Client.oauth2Configuration()) .build() } Be cautious with this feature, since all HTTP requests receive the access token. Alternatively, if setDefaultClientRegistrationId(""okta"") is configured with a valid ClientRegistration , the OAuth2AccessToken associated with the OAuth2AuthorizedClient is used. The following code shows the specific configuration: Java Kotlin @Bean WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) { ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client = new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); oauth2Client.setDefaultClientRegistrationId(""okta""); return WebClient.builder() .apply(oauth2Client.oauth2Configuration()) .build(); } @Bean fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient { val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager) oauth2Client.setDefaultClientRegistrationId(""okta"") return WebClient.builder() .apply(oauth2Client.oauth2Configuration()) .build() } Be cautious with this feature, since all HTTP requests receive the access token."
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/resource-server/index.html","OAuth 2.0 Resource Server: Spring Security supports protecting endpoints by using two forms of OAuth 2.0 Bearer Tokens(https://tools.ietf.org/html/rfc6750.html) : JWT(https://tools.ietf.org/html/rfc7519) Opaque Tokens This is handy in circumstances where an application has delegated its authority management to an authorization server(https://tools.ietf.org/html/rfc6749) (for example, Okta or Ping Identity). This authorization server can be consulted by resource servers to authorize requests. This section details how Spring Security provides support for OAuth 2.0 Bearer Tokens(https://tools.ietf.org/html/rfc6750.html) . Working samples for both JWTs(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/spring-boot/java/oauth2/resource-server/jwe) and Opaque Tokens(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/spring-boot/java/oauth2/resource-server/opaque) are available in the Spring Security Samples repository(https://github.com/spring-projects/spring-security-samples/tree/6.3.x) . Now we can consider how Bearer Token Authentication works within Spring Security. First, we see that, as with Basic Authentication(../../authentication/passwords/basic.html#servlet-authentication-basic) , the WWW-Authenticate(https://tools.ietf.org/html/rfc7235#section-4.1) header is sent back to an unauthenticated client: Figure 1. Sending WWW-Authenticate Header The figure above builds off our SecurityFilterChain(../../architecture.html#servlet-securityfilterchain) diagram. First, a user makes an unauthenticated request to the /private resource for which the user is not authorized. Spring Security’s AuthorizationFilter(../../authorization/authorize-http-requests.html) indicates that the unauthenticated request is Denied by throwing an AccessDeniedException . Since the user is not authenticated, ExceptionTranslationFilter(../../architecture.html#servlet-exceptiontranslationfilter) initiates Start Authentication . The configured AuthenticationEntryPoint(../../authentication/architecture.html#servlet-authentication-authenticationentrypoint) is an instance of BearerTokenAuthenticationEntryPoint(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/server/resource/authentication/BearerTokenAuthenticationEntryPoint.html) , which sends a WWW-Authenticate header. The RequestCache is typically a NullRequestCache that does not save the request, since the client is capable of replaying the requests it originally requested. When a client receives the WWW-Authenticate: Bearer header, it knows it should retry with a bearer token. The following image shows the flow for the bearer token being processed: Figure 2. Authenticating Bearer Token The figure builds off our SecurityFilterChain(../../architecture.html#servlet-securityfilterchain) diagram. When the user submits their bearer token, the BearerTokenAuthenticationFilter creates a BearerTokenAuthenticationToken which is a type of Authentication(../../authentication/architecture.html#servlet-authentication-authentication) by extracting the token from the HttpServletRequest . Next, the HttpServletRequest is passed to the AuthenticationManagerResolver , which selects the AuthenticationManager . The BearerTokenAuthenticationToken is passed into the AuthenticationManager to be authenticated. The details of what AuthenticationManager looks like depends on whether you’re configured for JWT(jwt.html#oauth2resourceserver-jwt-minimalconfiguration) or opaque token(opaque-token.html#oauth2resourceserver-opaque-minimalconfiguration) . If authentication fails, then Failure The SecurityContextHolder(../../authentication/architecture.html#servlet-authentication-securitycontextholder) is cleared out. The AuthenticationEntryPoint is invoked to trigger the WWW-Authenticate header to be sent again. If authentication is successful, then Success . The Authentication(../../authentication/architecture.html#servlet-authentication-authentication) is set on the SecurityContextHolder(../../authentication/architecture.html#servlet-authentication-securitycontextholder) . The BearerTokenAuthenticationFilter invokes FilterChain.doFilter(request,response) to continue with the rest of the application logic."
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/resource-server/jwt.html","OAuth 2.0 Resource Server JWT: Minimal Dependencies for JWT: Most Resource Server support is collected into spring-security-oauth2-resource-server . However, the support for decoding and verifying JWTs is in spring-security-oauth2-jose , meaning that both are necessary in order to have a working resource server that supports JWT-encoded Bearer Tokens. Minimal Configuration for JWTs: When using Spring Boot(https://spring.io/projects/spring-boot) , configuring an application as a resource server consists of two basic steps. First, include the needed dependencies and second, indicate the location of the authorization server. Specifying the Authorization Server: In a Spring Boot application, to specify which authorization server to use, simply do: spring: security: oauth2: resourceserver: jwt: issuer-uri: https://idp.example.com/issuer Where idp.example.com/issuer(https://idp.example.com/issuer) is the value contained in the iss claim for JWT tokens that the authorization server will issue. Resource Server will use this property to further self-configure, discover the authorization server’s public keys, and subsequently validate incoming JWTs. To use the issuer-uri property, it must also be true that one of idp.example.com/issuer/.well-known/openid-configuration(https://idp.example.com/issuer/.well-known/openid-configuration) , idp.example.com/.well-known/openid-configuration/issuer(https://idp.example.com/.well-known/openid-configuration/issuer) , or idp.example.com/.well-known/oauth-authorization-server/issuer(https://idp.example.com/.well-known/oauth-authorization-server/issuer) is a supported endpoint for the authorization server. This endpoint is referred to as a Provider Configuration(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) endpoint or a Authorization Server Metadata(https://tools.ietf.org/html/rfc8414#section-3) endpoint. And that’s it! Startup Expectations: When this property and these dependencies are used, Resource Server will automatically configure itself to validate JWT-encoded Bearer Tokens. It achieves this through a deterministic startup process: Query the Provider Configuration or Authorization Server Metadata endpoint for the jwks_url property Query the jwks_url endpoint for supported algorithms Configure the validation strategy to query jwks_url for valid public keys of the algorithms found Configure the validation strategy to validate each JWTs iss claim against idp.example.com(https://idp.example.com) . A consequence of this process is that the authorization server must be up and receiving requests in order for Resource Server to successfully start up. If the authorization server is down when Resource Server queries it (given appropriate timeouts), then startup will fail. Runtime Expectations: Once the application is started up, Resource Server will attempt to process any request containing an Authorization: Bearer header: GET / HTTP/1.1 Authorization: Bearer some-token-value # Resource Server will process this So long as this scheme is indicated, Resource Server will attempt to process the request according to the Bearer Token specification. Given a well-formed JWT, Resource Server will: Validate its signature against a public key obtained from the jwks_url endpoint during startup and matched against the JWT Validate the JWT’s exp and nbf timestamps and the JWT’s iss claim, and Map each scope to an authority with the prefix SCOPE_ . As the authorization server makes available new keys, Spring Security will automatically rotate the keys used to validate JWTs. The resulting Authentication#getPrincipal , by default, is a Spring Security Jwt object, and Authentication#getName maps to the JWT’s sub property, if one is present. From here, consider jumping to: How JWT Authentication Works(#oauth2resourceserver-jwt-architecture) How to Configure without tying Resource Server startup to an authorization server’s availability(#oauth2resourceserver-jwt-jwkseturi) How to Configure without Spring Boot(#oauth2resourceserver-jwt-sansboot) How JWT Authentication Works: Next, let’s see the architectural components that Spring Security uses to support JWT(https://tools.ietf.org/html/rfc7519) Authentication in servlet-based applications, like the one we just saw. JwtAuthenticationProvider(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/server/resource/authentication/JwtAuthenticationProvider.html) is an AuthenticationProvider(../../authentication/architecture.html#servlet-authentication-authenticationprovider) implementation that leverages a JwtDecoder(#oauth2resourceserver-jwt-decoder) and JwtAuthenticationConverter(#oauth2resourceserver-jwt-authorization-extraction) to authenticate a JWT. Let’s take a look at how JwtAuthenticationProvider works within Spring Security. The figure explains details of how the AuthenticationManager(../../authentication/architecture.html#servlet-authentication-authenticationmanager) in figures from Reading the Bearer Token(#oauth2resourceserver-authentication-bearertokenauthenticationfilter) works. Figure 1. JwtAuthenticationProvider Usage The authentication Filter from Reading the Bearer Token(#oauth2resourceserver-authentication-bearertokenauthenticationfilter) passes a BearerTokenAuthenticationToken to the AuthenticationManager which is implemented by ProviderManager(../../authentication/architecture.html#servlet-authentication-providermanager) . The ProviderManager is configured to use an AuthenticationProvider(../../authentication/architecture.html#servlet-authentication-authenticationprovider) of type JwtAuthenticationProvider . JwtAuthenticationProvider decodes, verifies, and validates the Jwt using a JwtDecoder(#oauth2resourceserver-jwt-decoder) . JwtAuthenticationProvider then uses the JwtAuthenticationConverter(#oauth2resourceserver-jwt-authorization-extraction) to convert the Jwt into a Collection of granted authorities. When authentication is successful, the Authentication(../../authentication/architecture.html#servlet-authentication-authentication) that is returned is of type JwtAuthenticationToken and has a principal that is the Jwt returned by the configured JwtDecoder . Ultimately, the returned JwtAuthenticationToken will be set on the SecurityContextHolder(../../authentication/architecture.html#servlet-authentication-securitycontextholder) by the authentication Filter . Specifying the Authorization Server JWK Set Uri Directly: If the authorization server doesn’t support any configuration endpoints, or if Resource Server must be able to start up independently from the authorization server, then the jwk-set-uri can be supplied as well: spring: security: oauth2: resourceserver: jwt: issuer-uri: https://idp.example.com jwk-set-uri: https://idp.example.com/.well-known/jwks.json The JWK Set uri is not standardized, but can typically be found in the authorization server’s documentation Consequently, Resource Server will not ping the authorization server at startup. We still specify the issuer-uri so that Resource Server still validates the iss claim on incoming JWTs. This property can also be supplied directly on the DSL(#oauth2resourceserver-jwt-jwkseturi-dsl) . Supplying Audiences: As already seen, the issuer-uri property validates the iss claim(#_specifying_the_authorization_server) ; this is who sent the JWT. Boot also has the audiences property for validating the aud claim; this is who the JWT was sent to. A resource server’s audience can be indicated like so: spring: security: oauth2: resourceserver: jwt: issuer-uri: https://idp.example.com audiences: https://my-resource-server.example.com You can also add the aud validation programmatically(#oauth2resourceserver-jwt-validation-custom) , if needed. The result will be that if the JWT’s iss claim is not idp.example.com(https://idp.example.com) , and its aud claim does not contain my-resource-server.example.com(https://my-resource-server.example.com) in its list, then validation will fail. Overriding or Replacing Boot Auto Configuration: There are two @Bean s that Spring Boot generates on Resource Server’s behalf. The first is a SecurityFilterChain that configures the app as a resource server. When including spring-security-oauth2-jose , this SecurityFilterChain looks like: Default JWT Configuration Java Kotlin @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer((oauth2) -> oauth2.jwt(Customizer.withDefaults())); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { jwt { } } } return http.build() } If the application doesn’t expose a SecurityFilterChain bean, then Spring Boot will expose the above default one. Replacing this is as simple as exposing the bean within the application: Custom JWT Configuration Java Kotlin import static org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope; @Configuration @EnableWebSecurity public class MyCustomSecurityConfiguration { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .requestMatchers(""/messages/**"").access(hasScope(""message:read"")) .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .jwt(jwt -> jwt .jwtAuthenticationConverter(myConverter()) ) ); return http.build(); } } import org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope @Configuration @EnableWebSecurity class MyCustomSecurityConfiguration { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(""/messages/**"", hasScope(""message:read"")) authorize(anyRequest, authenticated) } oauth2ResourceServer { jwt { jwtAuthenticationConverter = myConverter() } } } return http.build() } } The above requires the scope of message:read for any URL that starts with /messages/ . Methods on the oauth2ResourceServer DSL will also override or replace auto configuration. For example, the second @Bean Spring Boot creates is a JwtDecoder , which decodes String tokens into validated instances of Jwt(#oauth2resourceserver-jwt-architecture-jwtdecoder) : JWT Decoder Java Kotlin @Bean public JwtDecoder jwtDecoder() { return JwtDecoders.fromIssuerLocation(issuerUri); } @Bean fun jwtDecoder(): JwtDecoder { return JwtDecoders.fromIssuerLocation(issuerUri) } Calling JwtDecoders#fromIssuerLocation(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/jwt/JwtDecoders.html#fromIssuerLocation-java.lang.String-) is what invokes the Provider Configuration or Authorization Server Metadata endpoint in order to derive the JWK Set Uri. If the application doesn’t expose a JwtDecoder bean, then Spring Boot will expose the above default one. And its configuration can be overridden using jwkSetUri() or replaced using decoder() . Or, if you’re not using Spring Boot at all, then both of these components - the filter chain and a JwtDecoder can be specified in XML. The filter chain is specified like so: Default JWT Configuration Xml <http> <intercept-uri pattern=""/**"" access=""authenticated""/> <oauth2-resource-server> <jwt decoder-ref=""jwtDecoder""/> </oauth2-resource-server> </http> And the JwtDecoder like so: JWT Decoder Xml <bean id=""jwtDecoder"" class=""org.springframework.security.oauth2.jwt.JwtDecoders"" factory-method=""fromIssuerLocation""> <constructor-arg value=""${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}""/> </bean> Using jwkSetUri(): An authorization server’s JWK Set Uri can be configured as a configuration property(#oauth2resourceserver-jwt-jwkseturi) or it can be supplied in the DSL: JWK Set Uri Configuration Java Kotlin Xml @Configuration @EnableWebSecurity public class DirectlyConfiguredJwkSetUri { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .jwt(jwt -> jwt .jwkSetUri(""https://idp.example.com/.well-known/jwks.json"") ) ); return http.build(); } } @Configuration @EnableWebSecurity class DirectlyConfiguredJwkSetUri { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { jwt { jwkSetUri = ""https://idp.example.com/.well-known/jwks.json"" } } } return http.build() } } <http> <intercept-uri pattern=""/**"" access=""authenticated""/> <oauth2-resource-server> <jwt jwk-set-uri=""https://idp.example.com/.well-known/jwks.json""/> </oauth2-resource-server> </http> Using jwkSetUri() takes precedence over any configuration property. Using decoder(): More powerful than jwkSetUri() is decoder() , which will completely replace any Boot auto configuration of JwtDecoder(#oauth2resourceserver-jwt-architecture-jwtdecoder) : JWT Decoder Configuration Java Kotlin Xml @Configuration @EnableWebSecurity public class DirectlyConfiguredJwtDecoder { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .jwt(jwt -> jwt .decoder(myCustomDecoder()) ) ); return http.build(); } } @Configuration @EnableWebSecurity class DirectlyConfiguredJwtDecoder { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { jwt { jwtDecoder = myCustomDecoder() } } } return http.build() } } <http> <intercept-uri pattern=""/**"" access=""authenticated""/> <oauth2-resource-server> <jwt decoder-ref=""myCustomDecoder""/> </oauth2-resource-server> </http> This is handy when deeper configuration, like validation(#oauth2resourceserver-jwt-validation) , mapping(#oauth2resourceserver-jwt-claimsetmapping) , or request timeouts(#oauth2resourceserver-jwt-timeouts) , is necessary. Exposing a JwtDecoder @Bean: Or, exposing a JwtDecoder(#oauth2resourceserver-jwt-architecture-jwtdecoder) @Bean has the same effect as decoder() . You can construct one with a jwkSetUri like so: Java Kotlin @Bean public JwtDecoder jwtDecoder() { return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build(); } @Bean fun jwtDecoder(): JwtDecoder { return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build() } or you can use the issuer and have NimbusJwtDecoder look up the jwkSetUri when build() is invoked, like the following: Java Kotlin @Bean public JwtDecoder jwtDecoder() { return NimbusJwtDecoder.withIssuerLocation(issuer).build(); } @Bean fun jwtDecoder(): JwtDecoder { return NimbusJwtDecoder.withIssuerLocation(issuer).build() } Or, if the defaults work for you, you can also use JwtDecoders , which does the above in addition to configuring the decoder’s validator: Java Kotlin @Bean public JwtDecoders jwtDecoder() { return JwtDecoders.fromIssuerLocation(issuer); } @Bean fun jwtDecoder(): JwtDecoders { return JwtDecoders.fromIssuerLocation(issuer) } Configuring Trusted Algorithms: By default, NimbusJwtDecoder , and hence Resource Server, will only trust and verify tokens using RS256 . You can customize this via Spring Boot(#oauth2resourceserver-jwt-boot-algorithm) , the NimbusJwtDecoder builder(#oauth2resourceserver-jwt-decoder-builder) , or from the JWK Set response(#oauth2resourceserver-jwt-decoder-jwk-response) . Via Spring Boot: The simplest way to set the algorithm is as a property: spring: security: oauth2: resourceserver: jwt: jws-algorithms: RS512 jwk-set-uri: https://idp.example.org/.well-known/jwks.json Using a Builder: For greater power, though, we can use a builder that ships with NimbusJwtDecoder : Java Kotlin @Bean JwtDecoder jwtDecoder() { return NimbusJwtDecoder.withIssuerLocation(this.issuer) .jwsAlgorithm(RS512).build(); } @Bean fun jwtDecoder(): JwtDecoder { return NimbusJwtDecoder.withIssuerLocation(this.issuer) .jwsAlgorithm(RS512).build() } Calling jwsAlgorithm more than once will configure NimbusJwtDecoder to trust more than one algorithm, like so: Java Kotlin @Bean JwtDecoder jwtDecoder() { return NimbusJwtDecoder.withIssuerLocation(this.issuer) .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build(); } @Bean fun jwtDecoder(): JwtDecoder { return NimbusJwtDecoder.withIssuerLocation(this.issuer) .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build() } Or, you can call jwsAlgorithms : Java Kotlin @Bean JwtDecoder jwtDecoder() { return NimbusJwtDecoder.withIssuerLocation(this.issuer) .jwsAlgorithms(algorithms -> { algorithms.add(RS512); algorithms.add(ES512); }).build(); } @Bean fun jwtDecoder(): JwtDecoder { return NimbusJwtDecoder.withIssuerLocation(this.issuer) .jwsAlgorithms { it.add(RS512) it.add(ES512) }.build() } From JWK Set response: Since Spring Security’s JWT support is based off of Nimbus, you can use all it’s great features as well. For example, Nimbus has a JWSKeySelector implementation that will select the set of algorithms based on the JWK Set URI response. You can use it to generate a NimbusJwtDecoder like so: Java Kotlin @Bean public JwtDecoder jwtDecoder() { // makes a request to the JWK Set endpoint JWSKeySelector<SecurityContext> jwsKeySelector = JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(this.jwkSetUrl); DefaultJWTProcessor<SecurityContext> jwtProcessor = new DefaultJWTProcessor<>(); jwtProcessor.setJWSKeySelector(jwsKeySelector); return new NimbusJwtDecoder(jwtProcessor); } @Bean fun jwtDecoder(): JwtDecoder { // makes a request to the JWK Set endpoint val jwsKeySelector: JWSKeySelector<SecurityContext> = JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL<SecurityContext>(this.jwkSetUrl) val jwtProcessor: DefaultJWTProcessor<SecurityContext> = DefaultJWTProcessor() jwtProcessor.jwsKeySelector = jwsKeySelector return NimbusJwtDecoder(jwtProcessor) } Trusting a Single Asymmetric Key: Simpler than backing a Resource Server with a JWK Set endpoint is to hard-code an RSA public key. The public key can be provided via Spring Boot(#oauth2resourceserver-jwt-decoder-public-key-boot) or by Using a Builder(#oauth2resourceserver-jwt-decoder-public-key-builder) . Via Spring Boot: Specifying a key via Spring Boot is quite simple. The key’s location can be specified like so: spring: security: oauth2: resourceserver: jwt: public-key-location: classpath:my-key.pub Or, to allow for a more sophisticated lookup, you can post-process the RsaKeyConversionServicePostProcessor : Java Kotlin @Bean BeanFactoryPostProcessor conversionServiceCustomizer() { return beanFactory -> beanFactory.getBean(RsaKeyConversionServicePostProcessor.class) .setResourceLoader(new CustomResourceLoader()); } @Bean fun conversionServiceCustomizer(): BeanFactoryPostProcessor { return BeanFactoryPostProcessor { beanFactory -> beanFactory.getBean<RsaKeyConversionServicePostProcessor>() .setResourceLoader(CustomResourceLoader()) } } Specify your key’s location: key.location: hfds://my-key.pub And then autowire the value: Java Kotlin @Value(""${key.location}"") RSAPublicKey key; @Value(""\${key.location}"") val key: RSAPublicKey? = null Using a Builder: To wire an RSAPublicKey directly, you can simply use the appropriate NimbusJwtDecoder builder, like so: Java Kotlin @Bean public JwtDecoder jwtDecoder() { return NimbusJwtDecoder.withPublicKey(this.key).build(); } @Bean fun jwtDecoder(): JwtDecoder { return NimbusJwtDecoder.withPublicKey(this.key).build() } Trusting a Single Symmetric Key: Using a single symmetric key is also simple. You can simply load in your SecretKey and use the appropriate NimbusJwtDecoder builder, like so: Java Kotlin @Bean public JwtDecoder jwtDecoder() { return NimbusJwtDecoder.withSecretKey(this.key).build(); } @Bean fun jwtDecoder(): JwtDecoder { return NimbusJwtDecoder.withSecretKey(key).build() } Configuring Authorization: A JWT that is issued from an OAuth 2.0 Authorization Server will typically either have a scope or scp attribute, indicating the scopes (or authorities) it’s been granted, for example: { …​, ""scope"" : ""messages contacts""} When this is the case, Resource Server will attempt to coerce these scopes into a list of granted authorities, prefixing each scope with the string ""SCOPE_"". This means that to protect an endpoint or method with a scope derived from a JWT, the corresponding expressions should include this prefix: Authorization Configuration Java Kotlin Xml import static org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope; @Configuration @EnableWebSecurity public class DirectlyConfiguredJwkSetUri { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .requestMatchers(""/contacts/**"").access(hasScope(""contacts"")) .requestMatchers(""/messages/**"").access(hasScope(""messages"")) .anyRequest().authenticated() ) .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt); return http.build(); } } import org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope; @Configuration @EnableWebSecurity class DirectlyConfiguredJwkSetUri { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(""/contacts/**"", hasScope(""contacts"")) authorize(""/messages/**"", hasScope(""messages"")) authorize(anyRequest, authenticated) } oauth2ResourceServer { jwt { } } } return http.build() } } <http> <intercept-uri pattern=""/contacts/**"" access=""hasAuthority('SCOPE_contacts')""/> <intercept-uri pattern=""/messages/**"" access=""hasAuthority('SCOPE_messages')""/> <oauth2-resource-server> <jwt jwk-set-uri=""https://idp.example.org/.well-known/jwks.json""/> </oauth2-resource-server> </http> Or similarly with method security: Java Kotlin @PreAuthorize(""hasAuthority('SCOPE_messages')"") public List<Message> getMessages(...) {} @PreAuthorize(""hasAuthority('SCOPE_messages')"") fun getMessages(): List<Message> { } Extracting Authorities Manually: However, there are a number of circumstances where this default is insufficient. For example, some authorization servers don’t use the scope attribute, but instead have their own custom attribute. Or, at other times, the resource server may need to adapt the attribute or a composition of attributes into internalized authorities. To this end, Spring Security ships with JwtAuthenticationConverter , which is responsible for converting a Jwt into an Authentication(#oauth2resourceserver-jwt-architecture-jwtauthenticationconverter) . By default, Spring Security will wire the JwtAuthenticationProvider with a default instance of JwtAuthenticationConverter . As part of configuring a JwtAuthenticationConverter , you can supply a subsidiary converter to go from Jwt to a Collection of granted authorities. Let’s say that that your authorization server communicates authorities in a custom claim called authorities . In that case, you can configure the claim that JwtAuthenticationConverter(#oauth2resourceserver-jwt-architecture-jwtauthenticationconverter) should inspect, like so: Authorities Claim Configuration Java Kotlin Xml @Bean public JwtAuthenticationConverter jwtAuthenticationConverter() { JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter(); grantedAuthoritiesConverter.setAuthoritiesClaimName(""authorities""); JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter(); jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter); return jwtAuthenticationConverter; } @Bean fun jwtAuthenticationConverter(): JwtAuthenticationConverter { val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter() grantedAuthoritiesConverter.setAuthoritiesClaimName(""authorities"") val jwtAuthenticationConverter = JwtAuthenticationConverter() jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter) return jwtAuthenticationConverter } <http> <intercept-uri pattern=""/contacts/**"" access=""hasAuthority('SCOPE_contacts')""/> <intercept-uri pattern=""/messages/**"" access=""hasAuthority('SCOPE_messages')""/> <oauth2-resource-server> <jwt jwk-set-uri=""https://idp.example.org/.well-known/jwks.json"" jwt-authentication-converter-ref=""jwtAuthenticationConverter""/> </oauth2-resource-server> </http> <bean id=""jwtAuthenticationConverter"" class=""org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter""> <property name=""jwtGrantedAuthoritiesConverter"" ref=""jwtGrantedAuthoritiesConverter""/> </bean> <bean id=""jwtGrantedAuthoritiesConverter"" class=""org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter""> <property name=""authoritiesClaimName"" value=""authorities""/> </bean> You can also configure the authority prefix to be different as well. Instead of prefixing each authority with SCOPE_ , you can change it to ROLE_ like so: Authorities Prefix Configuration Java Kotlin Xml @Bean public JwtAuthenticationConverter jwtAuthenticationConverter() { JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter(); grantedAuthoritiesConverter.setAuthorityPrefix(""ROLE_""); JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter(); jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter); return jwtAuthenticationConverter; } @Bean fun jwtAuthenticationConverter(): JwtAuthenticationConverter { val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter() grantedAuthoritiesConverter.setAuthorityPrefix(""ROLE_"") val jwtAuthenticationConverter = JwtAuthenticationConverter() jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter) return jwtAuthenticationConverter } <http> <intercept-uri pattern=""/contacts/**"" access=""hasAuthority('SCOPE_contacts')""/> <intercept-uri pattern=""/messages/**"" access=""hasAuthority('SCOPE_messages')""/> <oauth2-resource-server> <jwt jwk-set-uri=""https://idp.example.org/.well-known/jwks.json"" jwt-authentication-converter-ref=""jwtAuthenticationConverter""/> </oauth2-resource-server> </http> <bean id=""jwtAuthenticationConverter"" class=""org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter""> <property name=""jwtGrantedAuthoritiesConverter"" ref=""jwtGrantedAuthoritiesConverter""/> </bean> <bean id=""jwtGrantedAuthoritiesConverter"" class=""org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter""> <property name=""authorityPrefix"" value=""ROLE_""/> </bean> Or, you can remove the prefix altogether by calling JwtGrantedAuthoritiesConverter#setAuthorityPrefix("""") . For more flexibility, the DSL supports entirely replacing the converter with any class that implements Converter<Jwt, AbstractAuthenticationToken> : Java Kotlin static class CustomAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken> { public AbstractAuthenticationToken convert(Jwt jwt) { return new CustomAuthenticationToken(jwt); } } // ... @Configuration @EnableWebSecurity public class CustomAuthenticationConverterConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .jwt(jwt -> jwt .jwtAuthenticationConverter(new CustomAuthenticationConverter()) ) ); return http.build(); } } internal class CustomAuthenticationConverter : Converter<Jwt, AbstractAuthenticationToken> { override fun convert(jwt: Jwt): AbstractAuthenticationToken { return CustomAuthenticationToken(jwt) } } // ... @Configuration @EnableWebSecurity class CustomAuthenticationConverterConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { jwt { jwtAuthenticationConverter = CustomAuthenticationConverter() } } } return http.build() } } Configuring Validation: Using minimal Spring Boot configuration(#oauth2resourceserver-jwt-minimalconfiguration) , indicating the authorization server’s issuer uri, Resource Server will default to verifying the iss claim as well as the exp and nbf timestamp claims. In circumstances where validation needs to be customized, Resource Server ships with two standard validators and also accepts custom OAuth2TokenValidator instances. Customizing Timestamp Validation: JWT’s typically have a window of validity, with the start of the window indicated in the nbf claim and the end indicated in the exp claim. However, every server can experience clock drift, which can cause tokens to appear expired to one server, but not to another. This can cause some implementation heartburn as the number of collaborating servers increases in a distributed system. Resource Server uses JwtTimestampValidator to verify a token’s validity window, and it can be configured with a clockSkew to alleviate the above problem: Java Kotlin @Bean JwtDecoder jwtDecoder() { NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder) JwtDecoders.fromIssuerLocation(issuerUri); OAuth2TokenValidator<Jwt> withClockSkew = new DelegatingOAuth2TokenValidator<>( new JwtTimestampValidator(Duration.ofSeconds(60)), new JwtIssuerValidator(issuerUri)); jwtDecoder.setJwtValidator(withClockSkew); return jwtDecoder; } @Bean fun jwtDecoder(): JwtDecoder { val jwtDecoder: NimbusJwtDecoder = JwtDecoders.fromIssuerLocation(issuerUri) as NimbusJwtDecoder val withClockSkew: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator( JwtTimestampValidator(Duration.ofSeconds(60)), JwtIssuerValidator(issuerUri)) jwtDecoder.setJwtValidator(withClockSkew) return jwtDecoder } By default, Resource Server configures a clock skew of 60 seconds. Configuring a Custom Validator: Adding a check for the aud claim(#_supplying_audiences) is simple with the OAuth2TokenValidator API: Java Kotlin OAuth2TokenValidator<Jwt> audienceValidator() { return new JwtClaimValidator<List<String>>(AUD, aud -> aud.contains(""messaging"")); } fun audienceValidator(): OAuth2TokenValidator<Jwt?> { return JwtClaimValidator<List<String>>(AUD) { aud -> aud.contains(""messaging"") } } Or, for more control you can implement your own OAuth2TokenValidator : Java Kotlin static class AudienceValidator implements OAuth2TokenValidator<Jwt> { OAuth2Error error = new OAuth2Error(""custom_code"", ""Custom error message"", null); @Override public OAuth2TokenValidatorResult validate(Jwt jwt) { if (jwt.getAudience().contains(""messaging"")) { return OAuth2TokenValidatorResult.success(); } else { return OAuth2TokenValidatorResult.failure(error); } } } // ... OAuth2TokenValidator<Jwt> audienceValidator() { return new AudienceValidator(); } internal class AudienceValidator : OAuth2TokenValidator<Jwt> { var error: OAuth2Error = OAuth2Error(""custom_code"", ""Custom error message"", null) override fun validate(jwt: Jwt): OAuth2TokenValidatorResult { return if (jwt.audience.contains(""messaging"")) { OAuth2TokenValidatorResult.success() } else { OAuth2TokenValidatorResult.failure(error) } } } // ... fun audienceValidator(): OAuth2TokenValidator<Jwt> { return AudienceValidator() } Then, to add into a resource server, it’s a matter of specifying the JwtDecoder(#oauth2resourceserver-jwt-architecture-jwtdecoder) instance: Java Kotlin @Bean JwtDecoder jwtDecoder() { NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder) JwtDecoders.fromIssuerLocation(issuerUri); OAuth2TokenValidator<Jwt> audienceValidator = audienceValidator(); OAuth2TokenValidator<Jwt> withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri); OAuth2TokenValidator<Jwt> withAudience = new DelegatingOAuth2TokenValidator<>(withIssuer, audienceValidator); jwtDecoder.setJwtValidator(withAudience); return jwtDecoder; } @Bean fun jwtDecoder(): JwtDecoder { val jwtDecoder: NimbusJwtDecoder = JwtDecoders.fromIssuerLocation(issuerUri) as NimbusJwtDecoder val audienceValidator = audienceValidator() val withIssuer: OAuth2TokenValidator<Jwt> = JwtValidators.createDefaultWithIssuer(issuerUri) val withAudience: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(withIssuer, audienceValidator) jwtDecoder.setJwtValidator(withAudience) return jwtDecoder } As stated earlier, you can instead configure aud validation in Boot(#_supplying_audiences) . Configuring Claim Set Mapping: Spring Security uses the Nimbus(https://bitbucket.org/connect2id/nimbus-jose-jwt/wiki/Home) library for parsing JWTs and validating their signatures. Consequently, Spring Security is subject to Nimbus’s interpretation of each field value and how to coerce each into a Java type. For example, because Nimbus remains Java 7 compatible, it doesn’t use Instant to represent timestamp fields. And it’s entirely possible to use a different library or for JWT processing, which may make its own coercion decisions that need adjustment. Or, quite simply, a resource server may want to add or remove claims from a JWT for domain-specific reasons. For these purposes, Resource Server supports mapping the JWT claim set with MappedJwtClaimSetConverter . Customizing the Conversion of a Single Claim: By default, MappedJwtClaimSetConverter will attempt to coerce claims into the following types: Claim Java Type aud Collection<String> exp Instant iat Instant iss String jti String nbf Instant sub String An individual claim’s conversion strategy can be configured using MappedJwtClaimSetConverter.withDefaults : Java Kotlin @Bean JwtDecoder jwtDecoder() { NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withIssuerLocation(issuer).build(); MappedJwtClaimSetConverter converter = MappedJwtClaimSetConverter .withDefaults(Collections.singletonMap(""sub"", this::lookupUserIdBySub)); jwtDecoder.setClaimSetConverter(converter); return jwtDecoder; } @Bean fun jwtDecoder(): JwtDecoder { val jwtDecoder = NimbusJwtDecoder.withIssuerLocation(issuer).build() val converter = MappedJwtClaimSetConverter .withDefaults(mapOf(""sub"" to this::lookupUserIdBySub)) jwtDecoder.setClaimSetConverter(converter) return jwtDecoder } This will keep all the defaults, except it will override the default claim converter for sub . Adding a Claim: MappedJwtClaimSetConverter can also be used to add a custom claim, for example, to adapt to an existing system: Java Kotlin MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap(""custom"", custom -> ""value"")); MappedJwtClaimSetConverter.withDefaults(mapOf(""custom"" to Converter<Any, String> { ""value"" })) Removing a Claim: And removing a claim is also simple, using the same API: Java Kotlin MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap(""legacyclaim"", legacy -> null)); MappedJwtClaimSetConverter.withDefaults(mapOf(""legacyclaim"" to Converter<Any, Any> { null })) Renaming a Claim: In more sophisticated scenarios, like consulting multiple claims at once or renaming a claim, Resource Server accepts any class that implements Converter<Map<String, Object>, Map<String,Object>> : Java Kotlin public class UsernameSubClaimAdapter implements Converter<Map<String, Object>, Map<String, Object>> { private final MappedJwtClaimSetConverter delegate = MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap()); public Map<String, Object> convert(Map<String, Object> claims) { Map<String, Object> convertedClaims = this.delegate.convert(claims); String username = (String) convertedClaims.get(""user_name""); convertedClaims.put(""sub"", username); return convertedClaims; } } class UsernameSubClaimAdapter : Converter<Map<String, Any?>, Map<String, Any?>> { private val delegate = MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap()) override fun convert(claims: Map<String, Any?>): Map<String, Any?> { val convertedClaims = delegate.convert(claims) val username = convertedClaims[""user_name""] as String convertedClaims[""sub""] = username return convertedClaims } } And then, the instance can be supplied like normal: Java Kotlin @Bean JwtDecoder jwtDecoder() { NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withIssuerLocation(issuer).build(); jwtDecoder.setClaimSetConverter(new UsernameSubClaimAdapter()); return jwtDecoder; } @Bean fun jwtDecoder(): JwtDecoder { val jwtDecoder: NimbusJwtDecoder = NimbusJwtDecoder.withIssuerLocation(issuer).build() jwtDecoder.setClaimSetConverter(UsernameSubClaimAdapter()) return jwtDecoder } Configuring Timeouts: By default, Resource Server uses connection and socket timeouts of 30 seconds each for coordinating with the authorization server. This may be too short in some scenarios. Further, it doesn’t take into account more sophisticated patterns like back-off and discovery. To adjust the way in which Resource Server connects to the authorization server, NimbusJwtDecoder accepts an instance of RestOperations : Java Kotlin @Bean public JwtDecoder jwtDecoder(RestTemplateBuilder builder) { RestOperations rest = builder .setConnectTimeout(Duration.ofSeconds(60)) .setReadTimeout(Duration.ofSeconds(60)) .build(); NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withIssuerLocation(issuer).restOperations(rest).build(); return jwtDecoder; } @Bean fun jwtDecoder(builder: RestTemplateBuilder): JwtDecoder { val rest: RestOperations = builder .setConnectTimeout(Duration.ofSeconds(60)) .setReadTimeout(Duration.ofSeconds(60)) .build() return NimbusJwtDecoder.withIssuerLocation(issuer).restOperations(rest).build() } Also by default, Resource Server caches in-memory the authorization server’s JWK set for 5 minutes, which you may want to adjust. Further, it doesn’t take into account more sophisticated caching patterns like eviction or using a shared cache. To adjust the way in which Resource Server caches the JWK set, NimbusJwtDecoder accepts an instance of Cache : Java Kotlin @Bean public JwtDecoder jwtDecoder(CacheManager cacheManager) { return NimbusJwtDecoder.withIssuerLocation(issuer) .cache(cacheManager.getCache(""jwks"")) .build(); } @Bean fun jwtDecoder(cacheManager: CacheManager): JwtDecoder { return NimbusJwtDecoder.withIssuerLocation(issuer) .cache(cacheManager.getCache(""jwks"")) .build() } When given a Cache , Resource Server will use the JWK Set Uri as the key and the JWK Set JSON as the value. Spring isn’t a cache provider, so you’ll need to make sure to include the appropriate dependencies, like spring-boot-starter-cache and your favorite caching provider. Whether it’s socket or cache timeouts, you may instead want to work with Nimbus directly. To do so, remember that NimbusJwtDecoder ships with a constructor that takes Nimbus’s JWTProcessor ."
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/resource-server/opaque-token.html","OAuth 2.0 Resource Server Opaque Token: Minimal Dependencies for Introspection: As described in Minimal Dependencies for JWT(jwt.html#oauth2resourceserver-jwt-minimaldependencies) most of Resource Server support is collected in spring-security-oauth2-resource-server . However unless a custom OpaqueTokenIntrospector(#oauth2resourceserver-opaque-introspector) is provided, the Resource Server will fallback to NimbusOpaqueTokenIntrospector. Meaning that both spring-security-oauth2-resource-server and oauth2-oidc-sdk are necessary in order to have a working minimal Resource Server that supports opaque Bearer Tokens. Please refer to spring-security-oauth2-resource-server in order to determine the correct version for oauth2-oidc-sdk . Minimal Configuration for Introspection: Typically, an opaque token can be verified via an OAuth 2.0 Introspection Endpoint(https://tools.ietf.org/html/rfc7662) , hosted by the authorization server. This can be handy when revocation is a requirement. When using Spring Boot(https://spring.io/projects/spring-boot) , configuring an application as a resource server that uses introspection consists of two basic steps. First, include the needed dependencies and second, indicate the introspection endpoint details. Specifying the Authorization Server: To specify where the introspection endpoint is, simply do: spring: security: oauth2: resourceserver: opaque-token: introspection-uri: https://idp.example.com/introspect client-id: client client-secret: secret Where idp.example.com/introspect(https://idp.example.com/introspect) is the introspection endpoint hosted by your authorization server and client-id and client-secret are the credentials needed to hit that endpoint. Resource Server will use these properties to further self-configure and subsequently validate incoming JWTs. When using introspection, the authorization server’s word is the law. If the authorization server responses that the token is valid, then it is. And that’s it! Startup Expectations: When this property and these dependencies are used, Resource Server will automatically configure itself to validate Opaque Bearer Tokens. This startup process is quite a bit simpler than for JWTs since no endpoints need to be discovered and no additional validation rules get added. Runtime Expectations: Once the application is started up, Resource Server will attempt to process any request containing an Authorization: Bearer header: GET / HTTP/1.1 Authorization: Bearer some-token-value # Resource Server will process this So long as this scheme is indicated, Resource Server will attempt to process the request according to the Bearer Token specification. Given an Opaque Token, Resource Server will Query the provided introspection endpoint using the provided credentials and the token Inspect the response for an { 'active' : true } attribute Map each scope to an authority with the prefix SCOPE_ The resulting Authentication#getPrincipal , by default, is a Spring Security OAuth2AuthenticatedPrincipal(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/core/OAuth2AuthenticatedPrincipal.html) object, and Authentication#getName maps to the token’s sub property, if one is present. From here, you may want to jump to: How Opaque Token Authentication Works(#oauth2resourceserver-opaque-architecture) Looking Up Attributes Post-Authentication(#oauth2resourceserver-opaque-attributes) Extracting Authorities Manually(#oauth2resourceserver-opaque-authorization-extraction) Using Introspection with JWTs(#oauth2resourceserver-opaque-jwt-introspector) How Opaque Token Authentication Works: Next, let’s see the architectural components that Spring Security uses to support opaque token(https://tools.ietf.org/html/rfc7662) Authentication in servlet-based applications, like the one we just saw. OpaqueTokenAuthenticationProvider(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/server/resource/authentication/OpaqueTokenAuthenticationProvider.html) is an AuthenticationProvider(../../authentication/architecture.html#servlet-authentication-authenticationprovider) implementation that leverages a OpaqueTokenIntrospector(#oauth2resourceserver-opaque-introspector) to authenticate an opaque token. Let’s take a look at how OpaqueTokenAuthenticationProvider works within Spring Security. The figure explains details of how the AuthenticationManager(../../authentication/architecture.html#servlet-authentication-authenticationmanager) in figures from Reading the Bearer Token(#oauth2resourceserver-authentication-bearertokenauthenticationfilter) works. Figure 1. OpaqueTokenAuthenticationProvider Usage The authentication Filter from Reading the Bearer Token(#oauth2resourceserver-authentication-bearertokenauthenticationfilter) passes a BearerTokenAuthenticationToken to the AuthenticationManager which is implemented by ProviderManager(../../authentication/architecture.html#servlet-authentication-providermanager) . The ProviderManager is configured to use an AuthenticationProvider(../../authentication/architecture.html#servlet-authentication-authenticationprovider) of type OpaqueTokenAuthenticationProvider . OpaqueTokenAuthenticationProvider introspects the opaque token and adds granted authorities using an OpaqueTokenIntrospector(#oauth2resourceserver-opaque-introspector) . When authentication is successful, the Authentication(../../authentication/architecture.html#servlet-authentication-authentication) that is returned is of type BearerTokenAuthentication and has a principal that is the OAuth2AuthenticatedPrincipal returned by the configured OpaqueTokenIntrospector(#oauth2resourceserver-opaque-introspector) . Ultimately, the returned BearerTokenAuthentication will be set on the SecurityContextHolder(../../authentication/architecture.html#servlet-authentication-securitycontextholder) by the authentication Filter . Looking Up Attributes Post-Authentication: Once a token is authenticated, an instance of BearerTokenAuthentication is set in the SecurityContext . This means that it’s available in @Controller methods when using @EnableWebMvc in your configuration: Java Kotlin @GetMapping(""/foo"") public String foo(BearerTokenAuthentication authentication) { return authentication.getTokenAttributes().get(""sub"") + "" is the subject""; } @GetMapping(""/foo"") fun foo(authentication: BearerTokenAuthentication): String { return authentication.tokenAttributes[""sub""].toString() + "" is the subject"" } Since BearerTokenAuthentication holds an OAuth2AuthenticatedPrincipal , that also means that it’s available to controller methods, too: Java Kotlin @GetMapping(""/foo"") public String foo(@AuthenticationPrincipal OAuth2AuthenticatedPrincipal principal) { return principal.getAttribute(""sub"") + "" is the subject""; } @GetMapping(""/foo"") fun foo(@AuthenticationPrincipal principal: OAuth2AuthenticatedPrincipal): String { return principal.getAttribute<Any>(""sub"").toString() + "" is the subject"" } Looking Up Attributes Via SpEL: Of course, this also means that attributes can be accessed via SpEL. For example, if using @EnableGlobalMethodSecurity so that you can use @PreAuthorize annotations, you can do: Java Kotlin @PreAuthorize(""principal?.attributes['sub'] == 'foo'"") public String forFoosEyesOnly() { return ""foo""; } @PreAuthorize(""principal?.attributes['sub'] == 'foo'"") fun forFoosEyesOnly(): String { return ""foo"" } Overriding or Replacing Boot Auto Configuration: There are two @Bean s that Spring Boot generates on Resource Server’s behalf. The first is a SecurityFilterChain that configures the app as a resource server. When use Opaque Token, this SecurityFilterChain looks like: Default Opaque Token Configuration Java Kotlin @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { opaqueToken { } } } return http.build() } If the application doesn’t expose a SecurityFilterChain bean, then Spring Boot will expose the above default one. Replacing this is as simple as exposing the bean within the application: Custom Opaque Token Configuration Java Kotlin import static org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope; @Configuration @EnableWebSecurity public class MyCustomSecurityConfiguration { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .requestMatchers(""/messages/**"").access(hasScope(""message:read"")) .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .opaqueToken(opaqueToken -> opaqueToken .introspector(myIntrospector()) ) ); return http.build(); } } import org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope; @Configuration @EnableWebSecurity class MyCustomSecurityConfiguration { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(""/messages/**"", hasScope(""SCOPE_message:read"")) authorize(anyRequest, authenticated) } oauth2ResourceServer { opaqueToken { introspector = myIntrospector() } } } return http.build() } } The above requires the scope of message:read for any URL that starts with /messages/ . Methods on the oauth2ResourceServer DSL will also override or replace auto configuration. For example, the second @Bean Spring Boot creates is an OpaqueTokenIntrospector , which decodes String tokens into validated instances of OAuth2AuthenticatedPrincipal(#oauth2resourceserver-opaque-architecture-introspector) : Java Kotlin @Bean public OpaqueTokenIntrospector introspector() { return new NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret); } @Bean fun introspector(): OpaqueTokenIntrospector { return NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret) } If the application doesn’t expose an OpaqueTokenIntrospector(#oauth2resourceserver-opaque-architecture-introspector) bean, then Spring Boot will expose the above default one. And its configuration can be overridden using introspectionUri() and introspectionClientCredentials() or replaced using introspector() . If the application doesn’t expose an OpaqueTokenAuthenticationConverter bean, then spring-security will build BearerTokenAuthentication . Or, if you’re not using Spring Boot at all, then all of these components - the filter chain, an OpaqueTokenIntrospector(#oauth2resourceserver-opaque-architecture-introspector) and an OpaqueTokenAuthenticationConverter can be specified in XML. The filter chain is specified like so: Default Opaque Token Configuration Xml <http> <intercept-uri pattern=""/**"" access=""authenticated""/> <oauth2-resource-server> <opaque-token introspector-ref=""opaqueTokenIntrospector"" authentication-converter-ref=""opaqueTokenAuthenticationConverter""/> </oauth2-resource-server> </http> And the OpaqueTokenIntrospector(#oauth2resourceserver-opaque-architecture-introspector) like so: Opaque Token Introspector Xml <bean id=""opaqueTokenIntrospector"" class=""org.springframework.security.oauth2.server.resource.introspection.NimbusOpaqueTokenIntrospector""> <constructor-arg value=""${spring.security.oauth2.resourceserver.opaquetoken.introspection_uri}""/> <constructor-arg value=""${spring.security.oauth2.resourceserver.opaquetoken.client_id}""/> <constructor-arg value=""${spring.security.oauth2.resourceserver.opaquetoken.client_secret}""/> </bean> And the OpaqueTokenAuthenticationConverter like so: Opaque Token Authentication Converter Xml <bean id=""opaqueTokenAuthenticationConverter"" class=""com.example.CustomOpaqueTokenAuthenticationConverter""/> Using introspectionUri(): An authorization server’s Introspection Uri can be configured as a configuration property(#oauth2resourceserver-opaque-introspectionuri) or it can be supplied in the DSL: Introspection URI Configuration Java Kotlin Xml @Configuration @EnableWebSecurity public class DirectlyConfiguredIntrospectionUri { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .opaqueToken(opaqueToken -> opaqueToken .introspectionUri(""https://idp.example.com/introspect"") .introspectionClientCredentials(""client"", ""secret"") ) ); return http.build(); } } @Configuration @EnableWebSecurity class DirectlyConfiguredIntrospectionUri { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { opaqueToken { introspectionUri = ""https://idp.example.com/introspect"" introspectionClientCredentials(""client"", ""secret"") } } } return http.build() } } <bean id=""opaqueTokenIntrospector"" class=""org.springframework.security.oauth2.server.resource.introspection.NimbusOpaqueTokenIntrospector""> <constructor-arg value=""https://idp.example.com/introspect""/> <constructor-arg value=""client""/> <constructor-arg value=""secret""/> </bean> Using introspectionUri() takes precedence over any configuration property. Using introspector(): More powerful than introspectionUri() is introspector() , which will completely replace any Boot auto configuration of OpaqueTokenIntrospector(#oauth2resourceserver-opaque-architecture-introspector) : Introspector Configuration Java Kotlin Xml @Configuration @EnableWebSecurity public class DirectlyConfiguredIntrospector { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .opaqueToken(opaqueToken -> opaqueToken .introspector(myCustomIntrospector()) ) ); return http.build(); } } @Configuration @EnableWebSecurity class DirectlyConfiguredIntrospector { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { opaqueToken { introspector = myCustomIntrospector() } } } return http.build() } } <http> <intercept-uri pattern=""/**"" access=""authenticated""/> <oauth2-resource-server> <opaque-token introspector-ref=""myCustomIntrospector""/> </oauth2-resource-server> </http> This is handy when deeper configuration, like authority mapping(#oauth2resourceserver-opaque-authorization-extraction) , JWT revocation(#oauth2resourceserver-opaque-jwt-introspector) , or request timeouts(#oauth2resourceserver-opaque-timeouts) , is necessary. Exposing a OpaqueTokenIntrospector @Bean: Or, exposing a OpaqueTokenIntrospector(#oauth2resourceserver-opaque-architecture-introspector) @Bean has the same effect as introspector() : @Bean public OpaqueTokenIntrospector introspector() { return new NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret); } Configuring Authorization: An OAuth 2.0 Introspection endpoint will typically return a scope attribute, indicating the scopes (or authorities) it’s been granted, for example: { …​, ""scope"" : ""messages contacts""} When this is the case, Resource Server will attempt to coerce these scopes into a list of granted authorities, prefixing each scope with the string ""SCOPE_"". This means that to protect an endpoint or method with a scope derived from an Opaque Token, the corresponding expressions should include this prefix: Authorization Opaque Token Configuration Java Kotlin Xml import static org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope; @Configuration @EnableWebSecurity public class MappedAuthorities { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorizeRequests -> authorizeRequests .requestMatchers(""/contacts/**"").access(hasScope(""contacts"")) .requestMatchers(""/messages/**"").access(hasScope(""messages"")) .anyRequest().authenticated() ) .oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken); return http.build(); } } import org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope @Configuration @EnableWebSecurity class MappedAuthorities { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(""/contacts/**"", hasScope(""contacts"")) authorize(""/messages/**"", hasScope(""messages"")) authorize(anyRequest, authenticated) } oauth2ResourceServer { opaqueToken { } } } return http.build() } } <http> <intercept-uri pattern=""/contacts/**"" access=""hasAuthority('SCOPE_contacts')""/> <intercept-uri pattern=""/messages/**"" access=""hasAuthority('SCOPE_messages')""/> <oauth2-resource-server> <opaque-token introspector-ref=""opaqueTokenIntrospector""/> </oauth2-resource-server> </http> Or similarly with method security: Java Kotlin @PreAuthorize(""hasAuthority('SCOPE_messages')"") public List<Message> getMessages(...) {} @PreAuthorize(""hasAuthority('SCOPE_messages')"") fun getMessages(): List<Message?> {} Extracting Authorities Manually: By default, Opaque Token support will extract the scope claim from an introspection response and parse it into individual GrantedAuthority instances. For example, if the introspection response were: { ""active"" : true, ""scope"" : ""message:read message:write"" } Then Resource Server would generate an Authentication with two authorities, one for message:read and the other for message:write . This can, of course, be customized using a custom OpaqueTokenIntrospector(#oauth2resourceserver-opaque-architecture-introspector) that takes a look at the attribute set and converts in its own way: Java Kotlin public class CustomAuthoritiesOpaqueTokenIntrospector implements OpaqueTokenIntrospector { private OpaqueTokenIntrospector delegate = new NimbusOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret""); public OAuth2AuthenticatedPrincipal introspect(String token) { OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token); return new DefaultOAuth2AuthenticatedPrincipal( principal.getName(), principal.getAttributes(), extractAuthorities(principal)); } private Collection<GrantedAuthority> extractAuthorities(OAuth2AuthenticatedPrincipal principal) { List<String> scopes = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE); return scopes.stream() .map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); } } class CustomAuthoritiesOpaqueTokenIntrospector : OpaqueTokenIntrospector { private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret"") override fun introspect(token: String): OAuth2AuthenticatedPrincipal { val principal: OAuth2AuthenticatedPrincipal = delegate.introspect(token) return DefaultOAuth2AuthenticatedPrincipal( principal.name, principal.attributes, extractAuthorities(principal)) } private fun extractAuthorities(principal: OAuth2AuthenticatedPrincipal): Collection<GrantedAuthority> { val scopes: List<String> = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE) return scopes .map { SimpleGrantedAuthority(it) } } } Thereafter, this custom introspector can be configured simply by exposing it as a @Bean : Java Kotlin @Bean public OpaqueTokenIntrospector introspector() { return new CustomAuthoritiesOpaqueTokenIntrospector(); } @Bean fun introspector(): OpaqueTokenIntrospector { return CustomAuthoritiesOpaqueTokenIntrospector() } Configuring Timeouts: By default, Resource Server uses connection and socket timeouts of 30 seconds each for coordinating with the authorization server. This may be too short in some scenarios. Further, it doesn’t take into account more sophisticated patterns like back-off and discovery. To adjust the way in which Resource Server connects to the authorization server, NimbusOpaqueTokenIntrospector accepts an instance of RestOperations : Java Kotlin @Bean public OpaqueTokenIntrospector introspector(RestTemplateBuilder builder, OAuth2ResourceServerProperties properties) { RestOperations rest = builder .basicAuthentication(properties.getOpaquetoken().getClientId(), properties.getOpaquetoken().getClientSecret()) .setConnectTimeout(Duration.ofSeconds(60)) .setReadTimeout(Duration.ofSeconds(60)) .build(); return new NimbusOpaqueTokenIntrospector(introspectionUri, rest); } @Bean fun introspector(builder: RestTemplateBuilder, properties: OAuth2ResourceServerProperties): OpaqueTokenIntrospector? { val rest: RestOperations = builder .basicAuthentication(properties.opaquetoken.clientId, properties.opaquetoken.clientSecret) .setConnectTimeout(Duration.ofSeconds(60)) .setReadTimeout(Duration.ofSeconds(60)) .build() return NimbusOpaqueTokenIntrospector(introspectionUri, rest) } Using Introspection with JWTs: A common question is whether or not introspection is compatible with JWTs. Spring Security’s Opaque Token support has been designed to not care about the format of the token — it will gladly pass any token to the introspection endpoint provided. So, let’s say that you’ve got a requirement that requires you to check with the authorization server on each request, in case the JWT has been revoked. Even though you are using the JWT format for the token, your validation method is introspection, meaning you’d want to do: spring: security: oauth2: resourceserver: opaque-token: introspection-uri: https://idp.example.org/introspection client-id: client client-secret: secret In this case, the resulting Authentication would be BearerTokenAuthentication . Any attributes in the corresponding OAuth2AuthenticatedPrincipal would be whatever was returned by the introspection endpoint. But, let’s say that, oddly enough, the introspection endpoint only returns whether or not the token is active. Now what? In this case, you can create a custom OpaqueTokenIntrospector(#oauth2resourceserver-opaque-architecture-introspector) that still hits the endpoint, but then updates the returned principal to have the JWTs claims as the attributes: Java Kotlin public class JwtOpaqueTokenIntrospector implements OpaqueTokenIntrospector { private OpaqueTokenIntrospector delegate = new NimbusOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret""); private JwtDecoder jwtDecoder = new NimbusJwtDecoder(new ParseOnlyJWTProcessor()); public OAuth2AuthenticatedPrincipal introspect(String token) { OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token); try { Jwt jwt = this.jwtDecoder.decode(token); return new DefaultOAuth2AuthenticatedPrincipal(jwt.getClaims(), NO_AUTHORITIES); } catch (JwtException ex) { throw new OAuth2IntrospectionException(ex); } } private static class ParseOnlyJWTProcessor extends DefaultJWTProcessor<SecurityContext> { JWTClaimsSet process(SignedJWT jwt, SecurityContext context) throws JOSEException { return jwt.getJWTClaimsSet(); } } } class JwtOpaqueTokenIntrospector : OpaqueTokenIntrospector { private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret"") private val jwtDecoder: JwtDecoder = NimbusJwtDecoder(ParseOnlyJWTProcessor()) override fun introspect(token: String): OAuth2AuthenticatedPrincipal { val principal = delegate.introspect(token) return try { val jwt: Jwt = jwtDecoder.decode(token) DefaultOAuth2AuthenticatedPrincipal(jwt.claims, NO_AUTHORITIES) } catch (ex: JwtException) { throw OAuth2IntrospectionException(ex.message) } } private class ParseOnlyJWTProcessor : DefaultJWTProcessor<SecurityContext>() { override fun process(jwt: SignedJWT, context: SecurityContext): JWTClaimsSet { return jwt.jwtClaimsSet } } } Thereafter, this custom introspector can be configured simply by exposing it as a @Bean : Java Kotlin @Bean public OpaqueTokenIntrospector introspector() { return new JwtOpaqueTokenIntrospector(); } @Bean fun introspector(): OpaqueTokenIntrospector { return JwtOpaqueTokenIntrospector() } Calling a /userinfo Endpoint: Generally speaking, a Resource Server doesn’t care about the underlying user, but instead about the authorities that have been granted. That said, at times it can be valuable to tie the authorization statement back to a user. If an application is also using spring-security-oauth2-client , having set up the appropriate ClientRegistrationRepository , then this is quite simple with a custom OpaqueTokenIntrospector(#oauth2resourceserver-opaque-architecture-introspector) . This implementation below does three things: Delegates to the introspection endpoint, to affirm the token’s validity Looks up the appropriate client registration associated with the /userinfo endpoint Invokes and returns the response from the /userinfo endpoint Java Kotlin public class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector { private final OpaqueTokenIntrospector delegate = new NimbusOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret""); private final OAuth2UserService oauth2UserService = new DefaultOAuth2UserService(); private final ClientRegistrationRepository repository; // ... constructor @Override public OAuth2AuthenticatedPrincipal introspect(String token) { OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token); Instant issuedAt = authorized.getAttribute(ISSUED_AT); Instant expiresAt = authorized.getAttribute(EXPIRES_AT); ClientRegistration clientRegistration = this.repository.findByRegistrationId(""registration-id""); OAuth2AccessToken token = new OAuth2AccessToken(BEARER, token, issuedAt, expiresAt); OAuth2UserRequest oauth2UserRequest = new OAuth2UserRequest(clientRegistration, token); return this.oauth2UserService.loadUser(oauth2UserRequest); } } class UserInfoOpaqueTokenIntrospector : OpaqueTokenIntrospector { private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret"") private val oauth2UserService = DefaultOAuth2UserService() private val repository: ClientRegistrationRepository? = null // ... constructor override fun introspect(token: String): OAuth2AuthenticatedPrincipal { val authorized = delegate.introspect(token) val issuedAt: Instant? = authorized.getAttribute(ISSUED_AT) val expiresAt: Instant? = authorized.getAttribute(EXPIRES_AT) val clientRegistration: ClientRegistration = repository!!.findByRegistrationId(""registration-id"") val accessToken = OAuth2AccessToken(BEARER, token, issuedAt, expiresAt) val oauth2UserRequest = OAuth2UserRequest(clientRegistration, accessToken) return oauth2UserService.loadUser(oauth2UserRequest) } } If you aren’t using spring-security-oauth2-client , it’s still quite simple. You will simply need to invoke the /userinfo with your own instance of WebClient : Java Kotlin public class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector { private final OpaqueTokenIntrospector delegate = new NimbusOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret""); private final WebClient rest = WebClient.create(); @Override public OAuth2AuthenticatedPrincipal introspect(String token) { OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token); return makeUserInfoRequest(authorized); } } class UserInfoOpaqueTokenIntrospector : OpaqueTokenIntrospector { private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret"") private val rest: WebClient = WebClient.create() override fun introspect(token: String): OAuth2AuthenticatedPrincipal { val authorized = delegate.introspect(token) return makeUserInfoRequest(authorized) } } Either way, having created your OpaqueTokenIntrospector(#oauth2resourceserver-opaque-architecture-introspector) , you should publish it as a @Bean to override the defaults: Java Kotlin @Bean OpaqueTokenIntrospector introspector() { return new UserInfoOpaqueTokenIntrospector(...); } @Bean fun introspector(): OpaqueTokenIntrospector { return UserInfoOpaqueTokenIntrospector(...) }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/resource-server/multitenancy.html","OAuth 2.0 Resource Server Multi-tenancy: Supporting both JWT and Opaque Token: In some cases, you may have a need to access both kinds of tokens. For example, you may support more than one tenant where one tenant issues JWTs and the other issues opaque tokens. If this decision must be made at request-time, then you can use an AuthenticationManagerResolver to achieve it, like so: Java Kotlin @Bean AuthenticationManagerResolver<HttpServletRequest> tokenAuthenticationManagerResolver (JwtDecoder jwtDecoder, OpaqueTokenIntrospector opaqueTokenIntrospector) { AuthenticationManager jwt = new ProviderManager(new JwtAuthenticationProvider(jwtDecoder)); AuthenticationManager opaqueToken = new ProviderManager( new OpaqueTokenAuthenticationProvider(opaqueTokenIntrospector)); return (request) -> useJwt(request) ? jwt : opaqueToken; } @Bean fun tokenAuthenticationManagerResolver (jwtDecoder: JwtDecoder, opaqueTokenIntrospector: OpaqueTokenIntrospector): AuthenticationManagerResolver<HttpServletRequest> { val jwt = ProviderManager(JwtAuthenticationProvider(jwtDecoder)) val opaqueToken = ProviderManager(OpaqueTokenAuthenticationProvider(opaqueTokenIntrospector)); return AuthenticationManagerResolver { request -> if (useJwt(request)) { jwt } else { opaqueToken } } } The implementation of useJwt(HttpServletRequest) will likely depend on custom request material like the path. And then specify this AuthenticationManagerResolver in the DSL: Authentication Manager Resolver Java Kotlin Xml http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .authenticationManagerResolver(this.tokenAuthenticationManagerResolver) ); http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { authenticationManagerResolver = tokenAuthenticationManagerResolver() } } <http> <oauth2-resource-server authentication-manager-resolver-ref=""tokenAuthenticationManagerResolver""/> </http> Multi-tenancy: A resource server is considered multi-tenant when there are multiple strategies for verifying a bearer token, keyed by some tenant identifier. For example, your resource server may accept bearer tokens from two different authorization servers. Or, your authorization server may represent a multiplicity of issuers. In each case, there are two things that need to be done and trade-offs associated with how you choose to do them: Resolve the tenant Propagate the tenant Resolving the Tenant By Claim: One way to differentiate tenants is by the issuer claim. Since the issuer claim accompanies signed JWTs, this can be done with the JwtIssuerAuthenticationManagerResolver , like so: Multi-tenancy Tenant by JWT Claim Java Kotlin Xml JwtIssuerAuthenticationManagerResolver authenticationManagerResolver = JwtIssuerAuthenticationManagerResolver .fromTrustedIssuers(""https://idp.example.org/issuerOne"", ""https://idp.example.org/issuerTwo""); http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .authenticationManagerResolver(authenticationManagerResolver) ); val customAuthenticationManagerResolver = JwtIssuerAuthenticationManagerResolver .fromTrustedIssuers(""https://idp.example.org/issuerOne"", ""https://idp.example.org/issuerTwo"") http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { authenticationManagerResolver = customAuthenticationManagerResolver } } <http> <oauth2-resource-server authentication-manager-resolver-ref=""authenticationManagerResolver""/> </http> <bean id=""authenticationManagerResolver"" class=""org.springframework.security.oauth2.server.resource.authentication.JwtIssuerAuthenticationManagerResolver""> <constructor-arg> <list> <value>https://idp.example.org/issuerOne</value> <value>https://idp.example.org/issuerTwo</value> </list> </constructor-arg> </bean> This is nice because the issuer endpoints are loaded lazily. In fact, the corresponding JwtAuthenticationProvider is instantiated only when the first request with the corresponding issuer is sent. This allows for an application startup that is independent from those authorization servers being up and available. Dynamic Tenants: Of course, you may not want to restart the application each time a new tenant is added. In this case, you can configure the JwtIssuerAuthenticationManagerResolver with a repository of AuthenticationManager instances, which you can edit at runtime, like so: Java Kotlin private void addManager(Map<String, AuthenticationManager> authenticationManagers, String issuer) { JwtAuthenticationProvider authenticationProvider = new JwtAuthenticationProvider (JwtDecoders.fromIssuerLocation(issuer)); authenticationManagers.put(issuer, authenticationProvider::authenticate); } // ... JwtIssuerAuthenticationManagerResolver authenticationManagerResolver = new JwtIssuerAuthenticationManagerResolver(authenticationManagers::get); http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .authenticationManagerResolver(authenticationManagerResolver) ); private fun addManager(authenticationManagers: MutableMap<String, AuthenticationManager>, issuer: String) { val authenticationProvider = JwtAuthenticationProvider(JwtDecoders.fromIssuerLocation(issuer)) authenticationManagers[issuer] = AuthenticationManager { authentication: Authentication? -> authenticationProvider.authenticate(authentication) } } // ... val customAuthenticationManagerResolver: JwtIssuerAuthenticationManagerResolver = JwtIssuerAuthenticationManagerResolver(authenticationManagers::get) http { authorizeRequests { authorize(anyRequest, authenticated) } oauth2ResourceServer { authenticationManagerResolver = customAuthenticationManagerResolver } } In this case, you construct JwtIssuerAuthenticationManagerResolver with a strategy for obtaining the AuthenticationManager given the issuer. This approach allows us to add and remove elements from the repository (shown as a Map in the snippet) at runtime. It would be unsafe to simply take any issuer and construct an AuthenticationManager from it. The issuer should be one that the code can verify from a trusted source like a list of allowed issuers. Parsing the Claim Only Once: You may have observed that this strategy, while simple, comes with the trade-off that the JWT is parsed once by the AuthenticationManagerResolver and then again by the JwtDecoder(jwt.html#oauth2resourceserver-jwt-architecture-jwtdecoder) later on in the request. This extra parsing can be alleviated by configuring the JwtDecoder(jwt.html#oauth2resourceserver-jwt-architecture-jwtdecoder) directly with a JWTClaimsSetAwareJWSKeySelector from Nimbus: Java Kotlin @Component public class TenantJWSKeySelector implements JWTClaimsSetAwareJWSKeySelector<SecurityContext> { private final TenantRepository tenants; (1) private final Map<String, JWSKeySelector<SecurityContext>> selectors = new ConcurrentHashMap<>(); (2) public TenantJWSKeySelector(TenantRepository tenants) { this.tenants = tenants; } @Override public List<? extends Key> selectKeys(JWSHeader jwsHeader, JWTClaimsSet jwtClaimsSet, SecurityContext securityContext) throws KeySourceException { return this.selectors.computeIfAbsent(toTenant(jwtClaimsSet), this::fromTenant) .selectJWSKeys(jwsHeader, securityContext); } private String toTenant(JWTClaimsSet claimSet) { return (String) claimSet.getClaim(""iss""); } private JWSKeySelector<SecurityContext> fromTenant(String tenant) { return Optional.ofNullable(this.tenants.findById(tenant)) (3) .map(t -> t.getAttrbute(""jwks_uri"")) .map(this::fromUri) .orElseThrow(() -> new IllegalArgumentException(""unknown tenant"")); } private JWSKeySelector<SecurityContext> fromUri(String uri) { try { return JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(new URL(uri)); (4) } catch (Exception ex) { throw new IllegalArgumentException(ex); } } } @Component class TenantJWSKeySelector(tenants: TenantRepository) : JWTClaimsSetAwareJWSKeySelector<SecurityContext> { private val tenants: TenantRepository (1) private val selectors: MutableMap<String, JWSKeySelector<SecurityContext>> = ConcurrentHashMap() (2) init { this.tenants = tenants } fun selectKeys(jwsHeader: JWSHeader?, jwtClaimsSet: JWTClaimsSet, securityContext: SecurityContext): List<Key?> { return selectors.computeIfAbsent(toTenant(jwtClaimsSet)) { tenant: String -> fromTenant(tenant) } .selectJWSKeys(jwsHeader, securityContext) } private fun toTenant(claimSet: JWTClaimsSet): String { return claimSet.getClaim(""iss"") as String } private fun fromTenant(tenant: String): JWSKeySelector<SecurityContext> { return Optional.ofNullable(this.tenants.findById(tenant)) (3) .map { t -> t.getAttrbute(""jwks_uri"") } .map { uri: String -> fromUri(uri) } .orElseThrow { IllegalArgumentException(""unknown tenant"") } } private fun fromUri(uri: String): JWSKeySelector<SecurityContext?> { return try { JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(URL(uri)) (4) } catch (ex: Exception) { throw IllegalArgumentException(ex) } } } 1 A hypothetical source for tenant information 2 A cache for `JWKKeySelector`s, keyed by tenant identifier 3 Looking up the tenant is more secure than simply calculating the JWK Set endpoint on the fly - the lookup acts as a list of allowed tenants 4 Create a JWSKeySelector via the types of keys that come back from the JWK Set endpoint - the lazy lookup here means that you don’t need to configure all tenants at startup The above key selector is a composition of many key selectors. It chooses which key selector to use based on the iss claim in the JWT. To use this approach, make sure that the authorization server is configured to include the claim set as part of the token’s signature. Without this, you have no guarantee that the issuer hasn’t been altered by a bad actor. Next, we can construct a JWTProcessor : Java Kotlin @Bean JWTProcessor jwtProcessor(JWTClaimsSetAwareJWSKeySelector keySelector) { ConfigurableJWTProcessor<SecurityContext> jwtProcessor = new DefaultJWTProcessor(); jwtProcessor.setJWTClaimSetJWSKeySelector(keySelector); return jwtProcessor; } @Bean fun jwtProcessor(keySelector: JWTClaimsSetAwareJWSKeySelector<SecurityContext>): JWTProcessor<SecurityContext> { val jwtProcessor = DefaultJWTProcessor<SecurityContext>() jwtProcessor.jwtClaimsSetAwareJWSKeySelector = keySelector return jwtProcessor } As you are already seeing, the trade-off for moving tenant-awareness down to this level is more configuration. We have just a bit more. Next, we still want to make sure you are validating the issuer. But, since the issuer may be different per JWT, then you’ll need a tenant-aware validator, too: Java Kotlin @Component public class TenantJwtIssuerValidator implements OAuth2TokenValidator<Jwt> { private final TenantRepository tenants; private final OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.INVALID_TOKEN, ""The iss claim is not valid"", ""https://tools.ietf.org/html/rfc6750#section-3.1""); public TenantJwtIssuerValidator(TenantRepository tenants) { this.tenants = tenants; } @Override public OAuth2TokenValidatorResult validate(Jwt token) { if(this.tenants.findById(token.getIssuer()) != null) { return OAuth2TokenValidatorResult.success(); } return OAuth2TokenValidatorResult.failure(this.error); } } @Component class TenantJwtIssuerValidator(private val tenants: TenantRepository) : OAuth2TokenValidator<Jwt> { private val error: OAuth2Error = OAuth2Error(OAuth2ErrorCodes.INVALID_TOKEN, ""The iss claim is not valid"", ""https://tools.ietf.org/html/rfc6750#section-3.1"") override fun validate(token: Jwt): OAuth2TokenValidatorResult { return if (tenants.findById(token.issuer) != null) OAuth2TokenValidatorResult.success() else OAuth2TokenValidatorResult.failure(error) } } Now that we have a tenant-aware processor and a tenant-aware validator, we can proceed with creating our JwtDecoder(jwt.html#oauth2resourceserver-jwt-architecture-jwtdecoder) : Java Kotlin @Bean JwtDecoder jwtDecoder(JWTProcessor jwtProcessor, OAuth2TokenValidator<Jwt> jwtValidator) { NimbusJwtDecoder decoder = new NimbusJwtDecoder(processor); OAuth2TokenValidator<Jwt> validator = new DelegatingOAuth2TokenValidator<> (JwtValidators.createDefault(), jwtValidator); decoder.setJwtValidator(validator); return decoder; } @Bean fun jwtDecoder(jwtProcessor: JWTProcessor<SecurityContext>?, jwtValidator: OAuth2TokenValidator<Jwt>?): JwtDecoder { val decoder = NimbusJwtDecoder(jwtProcessor) val validator: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(JwtValidators.createDefault(), jwtValidator) decoder.setJwtValidator(validator) return decoder } We’ve finished talking about resolving the tenant. If you’ve chosen to resolve the tenant by something other than a JWT claim, then you’ll need to make sure you address your downstream resource servers in the same way. For example, if you are resolving it by subdomain, you may need to address the downstream resource server using the same subdomain. However, if you resolve it by a claim in the bearer token, read on to learn about Spring Security’s support for bearer token propagation(bearer-tokens.html#oauth2resourceserver-bearertoken-resolver) ."
"https://docs.spring.io/spring-security/reference/6.3/servlet/oauth2/resource-server/bearer-tokens.html","OAuth 2.0 Bearer Tokens: Bearer Token Resolution: By default, Resource Server looks for a bearer token in the Authorization header. This, however, can be customized in a handful of ways. Reading the Bearer Token from a Custom Header: For example, you may have a need to read the bearer token from a custom header. To achieve this, you can expose a DefaultBearerTokenResolver as a bean, or wire an instance into the DSL, as you can see in the following example: Custom Bearer Token Header Java Kotlin Xml @Bean BearerTokenResolver bearerTokenResolver() { DefaultBearerTokenResolver bearerTokenResolver = new DefaultBearerTokenResolver(); bearerTokenResolver.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION); return bearerTokenResolver; } @Bean fun bearerTokenResolver(): BearerTokenResolver { val bearerTokenResolver = DefaultBearerTokenResolver() bearerTokenResolver.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION) return bearerTokenResolver } <http> <oauth2-resource-server bearer-token-resolver-ref=""bearerTokenResolver""/> </http> <bean id=""bearerTokenResolver"" class=""org.springframework.security.oauth2.server.resource.web.DefaultBearerTokenResolver""> <property name=""bearerTokenHeaderName"" value=""Proxy-Authorization""/> </bean> Or, in circumstances where a provider is using both a custom header and value, you can use HeaderBearerTokenResolver instead. Reading the Bearer Token from a Form Parameter: Or, you may wish to read the token from a form parameter, which you can do by configuring the DefaultBearerTokenResolver , as you can see below: Form Parameter Bearer Token Java Kotlin Xml DefaultBearerTokenResolver resolver = new DefaultBearerTokenResolver(); resolver.setAllowFormEncodedBodyParameter(true); http .oauth2ResourceServer(oauth2 -> oauth2 .bearerTokenResolver(resolver) ); val resolver = DefaultBearerTokenResolver() resolver.setAllowFormEncodedBodyParameter(true) http { oauth2ResourceServer { bearerTokenResolver = resolver } } <http> <oauth2-resource-server bearer-token-resolver-ref=""bearerTokenResolver""/> </http> <bean id=""bearerTokenResolver"" class=""org.springframework.security.oauth2.server.resource.web.HeaderBearerTokenResolver""> <property name=""allowFormEncodedBodyParameter"" value=""true""/> </bean> Bearer Token Propagation: Now that your resource server has validated the token, it might be handy to pass it to downstream services. This is quite simple with ServletBearerExchangeFilterFunction(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/server/resource/web/reactive/function/client/ServletBearerExchangeFilterFunction.html) , which you can see in the following example: Java Kotlin @Bean public WebClient rest() { return WebClient.builder() .filter(new ServletBearerExchangeFilterFunction()) .build(); } @Bean fun rest(): WebClient { return WebClient.builder() .filter(ServletBearerExchangeFilterFunction()) .build() } When the above WebClient is used to perform requests, Spring Security will look up the current Authentication and extract any AbstractOAuth2Token(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/core/AbstractOAuth2Token.html) credential. Then, it will propagate that token in the Authorization header. For example: Java Kotlin this.rest.get() .uri(""https://other-service.example.com/endpoint"") .retrieve() .bodyToMono(String.class) .block() this.rest.get() .uri(""https://other-service.example.com/endpoint"") .retrieve() .bodyToMono<String>() .block() Will invoke the other-service.example.com/endpoint(https://other-service.example.com/endpoint) , adding the bearer token Authorization header for you. In places where you need to override this behavior, it’s a simple matter of supplying the header yourself, like so: Java Kotlin this.rest.get() .uri(""https://other-service.example.com/endpoint"") .headers(headers -> headers.setBearerAuth(overridingToken)) .retrieve() .bodyToMono(String.class) .block() this.rest.get() .uri(""https://other-service.example.com/endpoint"") .headers{ headers -> headers.setBearerAuth(overridingToken)} .retrieve() .bodyToMono<String>() .block() In this case, the filter will fall back and simply forward the request onto the rest of the web filter chain. Unlike the OAuth 2.0 Client filter function(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/client/web/reactive/function/client/ServletOAuth2AuthorizedClientExchangeFilterFunction.html) , this filter function makes no attempt to renew the token, should it be expired. To obtain this level of support, please use the OAuth 2.0 Client filter. RestTemplate support: There is no RestTemplate equivalent for ServletBearerExchangeFilterFunction at the moment, but you can propagate the request’s bearer token quite simply with your own interceptor: Java Kotlin @Bean RestTemplate rest() { RestTemplate rest = new RestTemplate(); rest.getInterceptors().add((request, body, execution) -> { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authentication == null) { return execution.execute(request, body); } if (!(authentication.getCredentials() instanceof AbstractOAuth2Token)) { return execution.execute(request, body); } AbstractOAuth2Token token = (AbstractOAuth2Token) authentication.getCredentials(); request.getHeaders().setBearerAuth(token.getTokenValue()); return execution.execute(request, body); }); return rest; } @Bean fun rest(): RestTemplate { val rest = RestTemplate() rest.interceptors.add(ClientHttpRequestInterceptor { request, body, execution -> val authentication: Authentication? = SecurityContextHolder.getContext().authentication if (authentication == null) { return execution.execute(request, body) } if (authentication.credentials !is AbstractOAuth2Token) { return execution.execute(request, body) } request.headers.setBearerAuth(authentication.credentials.tokenValue) execution.execute(request, body) }) return rest } Unlike the OAuth 2.0 Authorized Client Manager(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/client/OAuth2AuthorizedClientManager.html) , this filter interceptor makes no attempt to renew the token, should it be expired. To obtain this level of support, please create an interceptor using the OAuth 2.0 Authorized Client Manager(../client/index.html#oauth2client) . Bearer Token Failure: A bearer token may be invalid for a number of reasons. For example, the token may no longer be active. In these circumstances, Resource Server throws an InvalidBearerTokenException . Like other exceptions, this results in an OAuth 2.0 Bearer Token error response: HTTP/1.1 401 Unauthorized WWW-Authenticate: Bearer error_code=""invalid_token"", error_description=""Unsupported algorithm of none"", error_uri=""https://tools.ietf.org/html/rfc6750#section-3.1"" Additionally, it is published as an AuthenticationFailureBadCredentialsEvent , which you can listen for in your application(../../authentication/events.html#servlet-events) like so: Java Kotlin @Component public class FailureEvents { @EventListener public void onFailure(AuthenticationFailureBadCredentialsEvent badCredentials) { if (badCredentials.getAuthentication() instanceof BearerTokenAuthenticationToken) { // ... handle } } } @Component class FailureEvents { @EventListener fun onFailure(badCredentials: AuthenticationFailureBadCredentialsEvent) { if (badCredentials.authentication is BearerTokenAuthenticationToken) { // ... handle } } }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/saml2/index.html","SAML2: Spring Security provides comprehensive SAML 2 support. This section discusses how to integrate SAML 2 into your servlet based application. Section Summary: SAML2 Log In(login/index.html) SAML2 Logout(logout.html) SAML2 Metadata(metadata.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/saml2/login/index.html","SAML 2.0 Login: The SAML 2.0 Login feature provides an application with the ability to act as a SAML 2.0 relying party, having users log in(https://wiki.shibboleth.net/confluence/display/CONCEPT/FlowsAndConfig) to the application by using their existing account at a SAML 2.0 Asserting Party (Okta, ADFS, and others). SAML 2.0 Login is implemented by using the Web Browser SSO Profile , as specified in SAML 2 Profiles(https://www.oasis-open.org/committees/download.php/35389/sstc-saml-profiles-errata-2.0-wd-06-diff.pdf#page=15) . Since 2009, support for relying parties has existed as an extension project(https://github.com/spring-projects/spring-security-saml/tree/1e013b07a7772defd6a26fcfae187c9bf661ee8f#spring-saml) . In 2019, the process began to port that into Spring Security(https://github.com/spring-projects/spring-security) proper. This process is similar to the one started in 2017 for Spring Security’s OAuth 2.0 support(../../oauth2/index.html) . A working sample for SAML 2.0 Login(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/spring-boot/java/saml2/login) is available in the Spring Security Samples repository(https://github.com/spring-projects/spring-security-samples/tree/6.3.x) . Section Summary: SAML2 Log In Overview(overview.html) SAML2 Authentication Requests(authentication-requests.html) SAML2 Authentication Responses(authentication.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/saml2/login/overview.html","SAML 2.0 Login Overview: We start by examining how SAML 2.0 Relying Party Authentication works within Spring Security. First, we see that, like OAuth 2.0 Login(#oauth2login) , Spring Security takes the user to a third party for performing authentication. It does this through a series of redirects: Figure 1. Redirecting to Asserting Party Authentication The figure above builds off our SecurityFilterChain(../../architecture.html#servlet-securityfilterchain) and AbstractAuthenticationProcessingFilter(../../authentication/architecture.html#servlet-authentication-abstractprocessingfilter) diagrams: First, a user makes an unauthenticated request to the /private resource, for which it is not authorized. Spring Security’s AuthorizationFilter(../../authorization/authorize-http-requests.html) indicates that the unauthenticated request is Denied by throwing an AccessDeniedException . Since the user lacks authorization, the ExceptionTranslationFilter(../../architecture.html#servlet-exceptiontranslationfilter) initiates Start Authentication . The configured AuthenticationEntryPoint(../../authentication/architecture.html#servlet-authentication-authenticationentrypoint) is an instance of LoginUrlAuthenticationEntryPoint(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/authentication/LoginUrlAuthenticationEntryPoint.html) , which redirects to the <saml2:AuthnRequest> generating endpoint(#servlet-saml2login-sp-initiated-factory) , Saml2WebSsoAuthenticationRequestFilter . Alternatively, if you have configured more than one asserting party(#servlet-saml2login-relyingpartyregistrationrepository) , it first redirects to a picker page. Next, the Saml2WebSsoAuthenticationRequestFilter creates, signs, serializes, and encodes a <saml2:AuthnRequest> using its configured Saml2AuthenticationRequestFactory(#servlet-saml2login-sp-initiated-factory) . Then the browser takes this <saml2:AuthnRequest> and presents it to the asserting party. The asserting party tries to authentication the user. If successful, it returns a <saml2:Response> back to the browser. The browser then POSTs the <saml2:Response> to the assertion consumer service endpoint. The following image shows how Spring Security authenticates a <saml2:Response> . Figure 2. Authenticating a <saml2:Response> The figure builds off our SecurityFilterChain(../../architecture.html#servlet-securityfilterchain) diagram. When the browser submits a <saml2:Response> to the application, it delegates to Saml2WebSsoAuthenticationFilter(authentication.html#servlet-saml2login-authenticate-responses) . This filter calls its configured AuthenticationConverter to create a Saml2AuthenticationToken by extracting the response from the HttpServletRequest . This converter additionally resolves the RelyingPartyRegistration(#servlet-saml2login-relyingpartyregistration) and supplies it to Saml2AuthenticationToken . Next, the filter passes the token to its configured AuthenticationManager(../../authentication/architecture.html#servlet-authentication-providermanager) . By default, it uses the OpenSamlAuthenticationProvider(#servlet-saml2login-architecture) . If authentication fails, then Failure . The SecurityContextHolder(../../authentication/architecture.html#servlet-authentication-securitycontextholder) is cleared out. The AuthenticationEntryPoint(../../authentication/architecture.html#servlet-authentication-authenticationentrypoint) is invoked to restart the authentication process. If authentication is successful, then Success . The Authentication(../../authentication/architecture.html#servlet-authentication-authentication) is set on the SecurityContextHolder(../../authentication/architecture.html#servlet-authentication-securitycontextholder) . The Saml2WebSsoAuthenticationFilter invokes FilterChain#doFilter(request,response) to continue with the rest of the application logic. Minimal Dependencies: SAML 2.0 service provider support resides in spring-security-saml2-service-provider . It builds off of the OpenSAML library, and, for that reason, you must also include the Shibboleth Maven repository in your build configuration. Check this link(https://shibboleth.atlassian.net/wiki/spaces/DEV/pages/1123844333/Use+of+Maven+Central#Publishing-to-Maven-Central) for more details about why a separate repository is needed. Maven Gradle <repositories> <!-- ... --> <repository> <id>shibboleth-releases</id> <url>https://build.shibboleth.net/nexus/content/repositories/releases/</url> </repository> </repositories> <dependency> <groupId>org.springframework.security</groupId> <artifactId>spring-security-saml2-service-provider</artifactId> </dependency> repositories { // ... maven { url ""https://build.shibboleth.net/nexus/content/repositories/releases/"" } } dependencies { // ... implementation 'org.springframework.security:spring-security-saml2-service-provider' } Minimal Configuration: When using Spring Boot(https://spring.io/projects/spring-boot) , configuring an application as a service provider consists of two basic steps: . Include the needed dependencies. . Indicate the necessary asserting party metadata. Also, this configuration presupposes that you have already registered the relying party with your asserting party(../metadata.html#servlet-saml2login-metadata) . Specifying Identity Provider Metadata: In a Spring Boot application, to specify an identity provider’s metadata, create configuration similar to the following: spring: security: saml2: relyingparty: registration: adfs: identityprovider: entity-id: https://idp.example.com/issuer verification.credentials: - certificate-location: ""classpath:idp.crt"" singlesignon.url: https://idp.example.com/issuer/sso singlesignon.sign-request: false where: idp.example.com/issuer(https://idp.example.com/issuer) is the value contained in the Issuer attribute of the SAML responses that the identity provider issues. classpath:idp.crt is the location on the classpath for the identity provider’s certificate for verifying SAML responses. idp.example.com/issuer/sso(https://idp.example.com/issuer/sso) is the endpoint where the identity provider is expecting AuthnRequest instances. adfs is an arbitrary identifier you choose(#servlet-saml2login-relyingpartyregistrationid) And that’s it! Identity Provider and Asserting Party are synonymous, as are Service Provider and Relying Party. These are frequently abbreviated as AP and RP, respectively. Runtime Expectations: As configured earlier(#saml2-specifying-identity-provider-metadata) , the application processes any POST /login/saml2/sso/{registrationId} request containing a SAMLResponse parameter: POST /login/saml2/sso/adfs HTTP/1.1 SAMLResponse=PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZ... There are two ways to induce your asserting party to generate a SAMLResponse : You can navigate to your asserting party. It likely has some kind of link or button for each registered relying party that you can click to send the SAMLResponse . You can navigate to a protected page in your application — for example, localhost:8080(http://localhost:8080) . Your application then redirects to the configured asserting party, which then sends the SAMLResponse . From here, consider jumping to: How SAML 2.0 Login Integrates with OpenSAML(#servlet-saml2login-architecture) How to Use the Saml2AuthenticatedPrincipal(authentication.html#servlet-saml2login-authenticatedprincipal) How to Override or Replace Spring Boot’s Auto Configuration(#servlet-saml2login-sansboot) How SAML 2.0 Login Integrates with OpenSAML: Spring Security’s SAML 2.0 support has a couple of design goals: Rely on a library for SAML 2.0 operations and domain objects. To achieve this, Spring Security uses OpenSAML. Ensure that this library is not required when using Spring Security’s SAML support. To achieve this, any interfaces or classes where Spring Security uses OpenSAML in the contract remain encapsulated. This makes it possible for you to switch out OpenSAML for some other library or an unsupported version of OpenSAML. As a natural outcome of these two goals, Spring Security’s SAML API is quite small relative to other modules. Instead, such classes as OpenSamlAuthenticationRequestFactory and OpenSamlAuthenticationProvider expose Converter implementations that customize various steps in the authentication process. For example, once your application receives a SAMLResponse and delegates to Saml2WebSsoAuthenticationFilter , the filter delegates to OpenSamlAuthenticationProvider : Authenticating an OpenSAML Response This figure builds off of the Saml2WebSsoAuthenticationFilter diagram(#servlet-saml2login-authentication-saml2webssoauthenticationfilter) . The Saml2WebSsoAuthenticationFilter formulates the Saml2AuthenticationToken and invokes the AuthenticationManager(../../authentication/architecture.html#servlet-authentication-providermanager) . The AuthenticationManager(../../authentication/architecture.html#servlet-authentication-providermanager) invokes the OpenSAML authentication provider. The authentication provider deserializes the response into an OpenSAML Response and checks its signature. If the signature is invalid, authentication fails. Then the provider decrypts any EncryptedAssertion elements(authentication.html#servlet-saml2login-opensamlauthenticationprovider-decryption) . If any decryptions fail, authentication fails. Next, the provider validates the response’s Issuer and Destination values. If they do not match what’s in the RelyingPartyRegistration , authentication fails. After that, the provider verifies the signature of each Assertion . If any signature is invalid, authentication fails. Also, if neither the response nor the assertions have signatures, authentication fails. Either the response or all the assertions must have signatures. Then, the provider ,(authentication.html#servlet-saml2login-opensamlauthenticationprovider-decryption) decrypts any EncryptedID or EncryptedAttribute elements]. If any decryptions fail, authentication fails. Next, the provider validates each assertion’s ExpiresAt and NotBefore timestamps, the <Subject> and any <AudienceRestriction> conditions. If any validations fail, authentication fails. Following that, the provider takes the first assertion’s AttributeStatement and maps it to a Map<String, List<Object>> . It also grants the ROLE_USER granted authority. And finally, it takes the NameID from the first assertion, the Map of attributes, and the GrantedAuthority and constructs a Saml2AuthenticatedPrincipal . Then, it places that principal and the authorities into a Saml2Authentication . The resulting Authentication#getPrincipal is a Spring Security Saml2AuthenticatedPrincipal object, and Authentication#getName maps to the first assertion’s NameID element. Saml2AuthenticatedPrincipal#getRelyingPartyRegistrationId holds the identifier to the associated RelyingPartyRegistration(#servlet-saml2login-relyingpartyregistrationid) . Customizing OpenSAML Configuration: Any class that uses both Spring Security and OpenSAML should statically initialize OpenSamlInitializationService at the beginning of the class: Java Kotlin static { OpenSamlInitializationService.initialize(); } companion object { init { OpenSamlInitializationService.initialize() } } This replaces OpenSAML’s InitializationService#initialize . Occasionally, it can be valuable to customize how OpenSAML builds, marshalls, and unmarshalls SAML objects. In these circumstances, you may instead want to call OpenSamlInitializationService#requireInitialize(Consumer) that gives you access to OpenSAML’s XMLObjectProviderFactory . For example, when sending an unsigned AuthNRequest, you may want to force reauthentication. In that case, you can register your own AuthnRequestMarshaller , like so: Java Kotlin static { OpenSamlInitializationService.requireInitialize(factory -> { AuthnRequestMarshaller marshaller = new AuthnRequestMarshaller() { @Override public Element marshall(XMLObject object, Element element) throws MarshallingException { configureAuthnRequest((AuthnRequest) object); return super.marshall(object, element); } public Element marshall(XMLObject object, Document document) throws MarshallingException { configureAuthnRequest((AuthnRequest) object); return super.marshall(object, document); } private void configureAuthnRequest(AuthnRequest authnRequest) { authnRequest.setForceAuthn(true); } } factory.getMarshallerFactory().registerMarshaller(AuthnRequest.DEFAULT_ELEMENT_NAME, marshaller); }); } companion object { init { OpenSamlInitializationService.requireInitialize { val marshaller = object : AuthnRequestMarshaller() { override fun marshall(xmlObject: XMLObject, element: Element): Element { configureAuthnRequest(xmlObject as AuthnRequest) return super.marshall(xmlObject, element) } override fun marshall(xmlObject: XMLObject, document: Document): Element { configureAuthnRequest(xmlObject as AuthnRequest) return super.marshall(xmlObject, document) } private fun configureAuthnRequest(authnRequest: AuthnRequest) { authnRequest.isForceAuthn = true } } it.marshallerFactory.registerMarshaller(AuthnRequest.DEFAULT_ELEMENT_NAME, marshaller) } } } The requireInitialize method may be called only once per application instance. Overriding or Replacing Boot Auto Configuration: Spring Boot generates two @Bean objects for a relying party. The first is a SecurityFilterChain that configures the application as a relying party. When including spring-security-saml2-service-provider , the SecurityFilterChain looks like: Default SAML 2.0 Login Configuration Java Kotlin @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .saml2Login(withDefaults()); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(anyRequest, authenticated) } saml2Login { } } return http.build() } If the application does not expose a SecurityFilterChain bean, Spring Boot exposes the preceding default one. You can replace this by exposing the bean within the application: Custom SAML 2.0 Login Configuration Java Kotlin @Configuration @EnableWebSecurity public class MyCustomSecurityConfiguration { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .requestMatchers(""/messages/**"").hasAuthority(""ROLE_USER"") .anyRequest().authenticated() ) .saml2Login(withDefaults()); return http.build(); } } @Configuration @EnableWebSecurity class MyCustomSecurityConfiguration { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(""/messages/**"", hasAuthority(""ROLE_USER"")) authorize(anyRequest, authenticated) } saml2Login { } } return http.build() } } The preceding example requires the role of USER for any URL that starts with /messages/ . The second @Bean Spring Boot creates is a RelyingPartyRegistrationRepository(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/saml2/provider/service/registration/RelyingPartyRegistrationRepository.html) , which represents the asserting party and relying party metadata. This includes such things as the location of the SSO endpoint the relying party should use when requesting authentication from the asserting party. You can override the default by publishing your own RelyingPartyRegistrationRepository bean. For example, you can look up the asserting party’s configuration by hitting its metadata endpoint: Relying Party Registration Repository Java Kotlin @Value(""${metadata.location}"") String assertingPartyMetadataLocation; @Bean public RelyingPartyRegistrationRepository relyingPartyRegistrations() { RelyingPartyRegistration registration = RelyingPartyRegistrations .fromMetadataLocation(assertingPartyMetadataLocation) .registrationId(""example"") .build(); return new InMemoryRelyingPartyRegistrationRepository(registration); } @Value(""\${metadata.location}"") var assertingPartyMetadataLocation: String? = null @Bean open fun relyingPartyRegistrations(): RelyingPartyRegistrationRepository? { val registration = RelyingPartyRegistrations .fromMetadataLocation(assertingPartyMetadataLocation) .registrationId(""example"") .build() return InMemoryRelyingPartyRegistrationRepository(registration) } The registrationId is an arbitrary value that you choose for differentiating between registrations. Alternatively, you can provide each detail manually: Relying Party Registration Repository Manual Configuration Java Kotlin @Value(""${verification.key}"") File verificationKey; @Bean public RelyingPartyRegistrationRepository relyingPartyRegistrations() throws Exception { X509Certificate certificate = X509Support.decodeCertificate(this.verificationKey); Saml2X509Credential credential = Saml2X509Credential.verification(certificate); RelyingPartyRegistration registration = RelyingPartyRegistration .withRegistrationId(""example"") .assertingPartyDetails(party -> party .entityId(""https://idp.example.com/issuer"") .singleSignOnServiceLocation(""https://idp.example.com/SSO.saml2"") .wantAuthnRequestsSigned(false) .verificationX509Credentials(c -> c.add(credential)) ) .build(); return new InMemoryRelyingPartyRegistrationRepository(registration); } @Value(""\${verification.key}"") var verificationKey: File? = null @Bean open fun relyingPartyRegistrations(): RelyingPartyRegistrationRepository { val certificate: X509Certificate? = X509Support.decodeCertificate(verificationKey!!) val credential: Saml2X509Credential = Saml2X509Credential.verification(certificate) val registration = RelyingPartyRegistration .withRegistrationId(""example"") .assertingPartyDetails { party: AssertingPartyDetails.Builder -> party .entityId(""https://idp.example.com/issuer"") .singleSignOnServiceLocation(""https://idp.example.com/SSO.saml2"") .wantAuthnRequestsSigned(false) .verificationX509Credentials { c: MutableCollection<Saml2X509Credential?> -> c.add( credential ) } } .build() return InMemoryRelyingPartyRegistrationRepository(registration) } X509Support is an OpenSAML class, used in the preceding snippet for brevity. Alternatively, you can directly wire up the repository by using the DSL, which also overrides the auto-configured SecurityFilterChain : Custom Relying Party Registration DSL Java Kotlin @Configuration @EnableWebSecurity public class MyCustomSecurityConfiguration { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .requestMatchers(""/messages/**"").hasAuthority(""ROLE_USER"") .anyRequest().authenticated() ) .saml2Login(saml2 -> saml2 .relyingPartyRegistrationRepository(relyingPartyRegistrations()) ); return http.build(); } } @Configuration @EnableWebSecurity class MyCustomSecurityConfiguration { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeRequests { authorize(""/messages/**"", hasAuthority(""ROLE_USER"")) authorize(anyRequest, authenticated) } saml2Login { relyingPartyRegistrationRepository = relyingPartyRegistrations() } } return http.build() } } A relying party can be multi-tenant by registering more than one relying party in the RelyingPartyRegistrationRepository . RelyingPartyRegistration: A RelyingPartyRegistration(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/saml2/provider/service/registration/RelyingPartyRegistration.html) instance represents a link between an relying party and an asserting party’s metadata. In a RelyingPartyRegistration , you can provide relying party metadata like its Issuer value, where it expects SAML Responses to be sent to, and any credentials that it owns for the purposes of signing or decrypting payloads. Also, you can provide asserting party metadata like its Issuer value, where it expects AuthnRequests to be sent to, and any public credentials that it owns for the purposes of the relying party verifying or encrypting payloads. The following RelyingPartyRegistration is the minimum required for most setups: Java Kotlin RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistrations .fromMetadataLocation(""https://ap.example.org/metadata"") .registrationId(""my-id"") .build(); val relyingPartyRegistration = RelyingPartyRegistrations .fromMetadataLocation(""https://ap.example.org/metadata"") .registrationId(""my-id"") .build() Note that you can also create a RelyingPartyRegistration from an arbitrary InputStream source. One such example is when the metadata is stored in a database: String xml = fromDatabase(); try (InputStream source = new ByteArrayInputStream(xml.getBytes())) { RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistrations .fromMetadata(source) .registrationId(""my-id"") .build(); } A more sophisticated setup is also possible: Java Kotlin RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId(""my-id"") .entityId(""{baseUrl}/{registrationId}"") .decryptionX509Credentials(c -> c.add(relyingPartyDecryptingCredential())) .assertionConsumerServiceLocation(""/my-login-endpoint/{registrationId}"") .assertingPartyDetails(party -> party .entityId(""https://ap.example.org"") .verificationX509Credentials(c -> c.add(assertingPartyVerifyingCredential())) .singleSignOnServiceLocation(""https://ap.example.org/SSO.saml2"") ) .build(); val relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId(""my-id"") .entityId(""{baseUrl}/{registrationId}"") .decryptionX509Credentials { c: MutableCollection<Saml2X509Credential?> -> c.add(relyingPartyDecryptingCredential()) } .assertionConsumerServiceLocation(""/my-login-endpoint/{registrationId}"") .assertingPartyDetails { party -> party .entityId(""https://ap.example.org"") .verificationX509Credentials { c -> c.add(assertingPartyVerifyingCredential()) } .singleSignOnServiceLocation(""https://ap.example.org/SSO.saml2"") } .build() The top-level metadata methods are details about the relying party. The methods inside assertingPartyDetails are details about the asserting party. The location where a relying party is expecting SAML Responses is the Assertion Consumer Service Location. The default for the relying party’s entityId is {baseUrl}/saml2/service-provider-metadata/{registrationId} . This is this value needed when configuring the asserting party to know about your relying party. The default for the assertionConsumerServiceLocation is /login/saml2/sso/{registrationId} . By default, it is mapped to Saml2WebSsoAuthenticationFilter(#servlet-saml2login-authentication-saml2webssoauthenticationfilter) in the filter chain. URI Patterns: You probably noticed the {baseUrl} and {registrationId} placeholders in the preceding examples. These are useful for generating URIs. As a result, the relying party’s entityId and assertionConsumerServiceLocation support the following placeholders: baseUrl - the scheme, host, and port of a deployed application registrationId - the registration id for this relying party baseScheme - the scheme of a deployed application baseHost - the host of a deployed application basePort - the port of a deployed application For example, the assertionConsumerServiceLocation defined earlier was: /my-login-endpoint/{registrationId} In a deployed application, it translates to: /my-login-endpoint/adfs The entityId shown earlier was defined as: {baseUrl}/{registrationId} In a deployed application, that translates to: https://rp.example.com/adfs The prevailing URI patterns are as follows: /saml2/authenticate/{registrationId} - The endpoint that generates a <saml2:AuthnRequest>(authentication-requests.html) based on the configurations for that RelyingPartyRegistration and sends it to the asserting party /login/saml2/sso/ - The endpoint that authenticates an asserting party’s <saml2:Response>(authentication.html) ; the RelyingPartyRegistration is looked up from previously authenticated state or the response’s issuer if needed; also supports /login/saml2/sso/{registrationId} /logout/saml2/sso - The endpoint that processes <saml2:LogoutRequest> and <saml2:LogoutResponse> payloads(../logout.html) ; the RelyingPartyRegistration is looked up from previously authenticated state or the request’s issuer if needed; also supports /logout/saml2/slo/{registrationId} /saml2/metadata - The relying party metadata(../metadata.html) for the set of RelyingPartyRegistration s; also supports /saml2/metadata/{registrationId} or /saml2/service-provider-metadata/{registrationId} for a specific RelyingPartyRegistration Since the registrationId is the primary identifier for a RelyingPartyRegistration , it is needed in the URL for unauthenticated scenarios. If you wish to remove the registrationId from the URL for any reason, you can specify a RelyingPartyRegistrationResolver(#servlet-saml2login-rpr-relyingpartyregistrationresolver) to tell Spring Security how to look up the registrationId . Credentials: In the example shown earlier(#servlet-saml2login-relyingpartyregistration) , you also likely noticed the credential that was used. Oftentimes, a relying party uses the same key to sign payloads as well as decrypt them. Alternatively, it can use the same key to verify payloads as well as encrypt them. Because of this, Spring Security ships with Saml2X509Credential , a SAML-specific credential that simplifies configuring the same key for different use cases. At a minimum, you need to have a certificate from the asserting party so that the asserting party’s signed responses can be verified. To construct a Saml2X509Credential that you can use to verify assertions from the asserting party, you can load the file and use the CertificateFactory : Java Kotlin Resource resource = new ClassPathResource(""ap.crt""); try (InputStream is = resource.getInputStream()) { X509Certificate certificate = (X509Certificate) CertificateFactory.getInstance(""X.509"").generateCertificate(is); return Saml2X509Credential.verification(certificate); } val resource = ClassPathResource(""ap.crt"") resource.inputStream.use { return Saml2X509Credential.verification( CertificateFactory.getInstance(""X.509"").generateCertificate(it) as X509Certificate? ) } Suppose that the asserting party is going to also encrypt the assertion. In that case, the relying party needs a private key to decrypt the encrypted value. In that case, you need an RSAPrivateKey as well as its corresponding X509Certificate . You can load the first by using Spring Security’s RsaKeyConverters utility class and the second as you did before: Java Kotlin X509Certificate certificate = relyingPartyDecryptionCertificate(); Resource resource = new ClassPathResource(""rp.crt""); try (InputStream is = resource.getInputStream()) { RSAPrivateKey rsa = RsaKeyConverters.pkcs8().convert(is); return Saml2X509Credential.decryption(rsa, certificate); } val certificate: X509Certificate = relyingPartyDecryptionCertificate() val resource = ClassPathResource(""rp.crt"") resource.inputStream.use { val rsa: RSAPrivateKey = RsaKeyConverters.pkcs8().convert(it) return Saml2X509Credential.decryption(rsa, certificate) } When you specify the locations of these files as the appropriate Spring Boot properties, Spring Boot performs these conversions for you. Duplicated Relying Party Configurations: When an application uses multiple asserting parties, some configuration is duplicated between RelyingPartyRegistration instances: The relying party’s entityId Its assertionConsumerServiceLocation Its credentials — for example, its signing or decryption credentials This setup may let credentials be more easily rotated for some identity providers versus others. The duplication can be alleviated in a few different ways. First, in YAML this can be alleviated with references: spring: security: saml2: relyingparty: okta: signing.credentials: &relying-party-credentials - private-key-location: classpath:rp.key certificate-location: classpath:rp.crt identityprovider: entity-id: ... azure: signing.credentials: *relying-party-credentials identityprovider: entity-id: ... Second, in a database, you need not replicate the model of RelyingPartyRegistration . Third, in Java, you can create a custom configuration method: Java Kotlin private RelyingPartyRegistration.Builder addRelyingPartyDetails(RelyingPartyRegistration.Builder builder) { Saml2X509Credential signingCredential = ... builder.signingX509Credentials(c -> c.addAll(signingCredential)); // ... other relying party configurations } @Bean public RelyingPartyRegistrationRepository relyingPartyRegistrations() { RelyingPartyRegistration okta = addRelyingPartyDetails( RelyingPartyRegistrations .fromMetadataLocation(oktaMetadataUrl) .registrationId(""okta"")).build(); RelyingPartyRegistration azure = addRelyingPartyDetails( RelyingPartyRegistrations .fromMetadataLocation(oktaMetadataUrl) .registrationId(""azure"")).build(); return new InMemoryRelyingPartyRegistrationRepository(okta, azure); } private fun addRelyingPartyDetails(builder: RelyingPartyRegistration.Builder): RelyingPartyRegistration.Builder { val signingCredential: Saml2X509Credential = ... builder.signingX509Credentials { c: MutableCollection<Saml2X509Credential?> -> c.add( signingCredential ) } // ... other relying party configurations } @Bean open fun relyingPartyRegistrations(): RelyingPartyRegistrationRepository? { val okta = addRelyingPartyDetails( RelyingPartyRegistrations .fromMetadataLocation(oktaMetadataUrl) .registrationId(""okta"") ).build() val azure = addRelyingPartyDetails( RelyingPartyRegistrations .fromMetadataLocation(oktaMetadataUrl) .registrationId(""azure"") ).build() return InMemoryRelyingPartyRegistrationRepository(okta, azure) } Resolving the RelyingPartyRegistration from the Request: As seen so far, Spring Security resolves the RelyingPartyRegistration by looking for the registration id in the URI path. Depending on the use case, a number of other strategies are also employed to derive one. For example: For processing <saml2:Response>`s, the `RelyingPartyRegistration is looked up from the associated <saml2:AuthRequest> or from the <saml2:Response#Issuer> element For processing <saml2:LogoutRequest>`s, the `RelyingPartyRegistration is looked up from the currently logged in user or from the <saml2:LogoutRequest#Issuer> element For publishing metadata, the RelyingPartyRegistration`s are looked up from any repository that also implements `Iterable<RelyingPartyRegistration> When this needs adjustment, you can turn to the specific components for each of these endpoints targeted at customizing this: For SAML Responses, customize the AuthenticationConverter For Logout Requests, customize the Saml2LogoutRequestValidatorParametersResolver For Metadata, customize the Saml2MetadataResponseResolver Federating Login: One common arrangement with SAML 2.0 is an identity provider that has multiple asserting parties. In this case, the identity provider’s metadata endpoint returns multiple <md:IDPSSODescriptor> elements. These multiple asserting parties can be accessed in a single call to RelyingPartyRegistrations like so: Java Kotlin Collection<RelyingPartyRegistration> registrations = RelyingPartyRegistrations .collectionFromMetadataLocation(""https://example.org/saml2/idp/metadata.xml"") .stream().map((builder) -> builder .registrationId(UUID.randomUUID().toString()) .entityId(""https://example.org/saml2/sp"") .build() ) .collect(Collectors.toList()); var registrations: Collection<RelyingPartyRegistration> = RelyingPartyRegistrations .collectionFromMetadataLocation(""https://example.org/saml2/idp/metadata.xml"") .stream().map { builder : RelyingPartyRegistration.Builder -> builder .registrationId(UUID.randomUUID().toString()) .entityId(""https://example.org/saml2/sp"") .assertionConsumerServiceLocation(""{baseUrl}/login/saml2/sso"") .build() } .collect(Collectors.toList()) Note that because the registration id is set to a random value, this will change certain SAML 2.0 endpoints to be unpredictable. There are several ways to address this; let’s focus on a way that suits the specific use case of federation. In many federation cases, all the asserting parties share service provider configuration. Given that Spring Security will by default include the registrationId in the service provider metadata, another step is to change corresponding URIs to exclude the registrationId , which you can see has already been done in the above sample where the entityId and assertionConsumerServiceLocation are configured with a static endpoint. You can see a completed example of this in our saml-extension-federation sample(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/spring-boot/java/saml2/saml-extension-federation) . Using Spring Security SAML Extension URIs: In the event that you are migrating from the Spring Security SAML Extension, there may be some benefit to configuring your application to use the SAML Extension URI defaults. For more information on this, please see our custom-urls sample(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/spring-boot/java/saml2/custom-urls) and our saml-extension-federation sample(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/servlet/spring-boot/java/saml2/saml-extension-federation) ."
"https://docs.spring.io/spring-security/reference/6.3/servlet/saml2/login/authentication-requests.html","Producing <saml2:AuthnRequest>s: As stated earlier, Spring Security’s SAML 2.0 support produces a <saml2:AuthnRequest> to commence authentication with the asserting party. Spring Security achieves this in part by registering the Saml2WebSsoAuthenticationRequestFilter in the filter chain. This filter by default responds to endpoint /saml2/authenticate/{registrationId} . For example, if you were deployed to rp.example.com(https://rp.example.com) and you gave your registration an ID of okta , you could navigate to: rp.example.org/saml2/authenticate/okta(https://rp.example.org/saml2/authenticate/okta) and the result would be a redirect that included a SAMLRequest parameter containing the signed, deflated, and encoded <saml2:AuthnRequest> . Changing How the <saml2:AuthnRequest> Gets Stored: Saml2WebSsoAuthenticationRequestFilter uses an Saml2AuthenticationRequestRepository to persist an AbstractSaml2AuthenticationRequest instance before sending the <saml2:AuthnRequest>(#servlet-saml2login-sp-initiated-factory) to the asserting party. Additionally, Saml2WebSsoAuthenticationFilter and Saml2AuthenticationTokenConverter use an Saml2AuthenticationRequestRepository to load any AbstractSaml2AuthenticationRequest as part of authenticating the <saml2:Response>(authentication.html#servlet-saml2login-authenticate-responses) . By default, Spring Security uses an HttpSessionSaml2AuthenticationRequestRepository , which stores the AbstractSaml2AuthenticationRequest in the HttpSession . If you have a custom implementation of Saml2AuthenticationRequestRepository , you may configure it by exposing it as a @Bean as shown in the following example: Java Kotlin @Bean Saml2AuthenticationRequestRepository<AbstractSaml2AuthenticationRequest> authenticationRequestRepository() { return new CustomSaml2AuthenticationRequestRepository(); } @Bean open fun authenticationRequestRepository(): Saml2AuthenticationRequestRepository<AbstractSaml2AuthenticationRequest> { return CustomSaml2AuthenticationRequestRepository() } Changing How the <saml2:AuthnRequest> Gets Sent: By default, Spring Security signs each <saml2:AuthnRequest> and send it as a GET to the asserting party. Many asserting parties don’t require a signed <saml2:AuthnRequest> . This can be configured automatically via RelyingPartyRegistrations , or you can supply it manually, like so: Not Requiring Signed AuthnRequests Boot Java Kotlin spring: security: saml2: relyingparty: okta: identityprovider: entity-id: ... singlesignon.sign-request: false RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId(""okta"") // ... .assertingPartyDetails(party -> party // ... .wantAuthnRequestsSigned(false) ) .build(); var relyingPartyRegistration: RelyingPartyRegistration = RelyingPartyRegistration.withRegistrationId(""okta"") // ... .assertingPartyDetails { party: AssertingPartyDetails.Builder -> party // ... .wantAuthnRequestsSigned(false) } .build() Otherwise, you will need to specify a private key to RelyingPartyRegistration#signingX509Credentials so that Spring Security can sign the <saml2:AuthnRequest> before sending. By default, Spring Security will sign the <saml2:AuthnRequest> using rsa-sha256 , though some asserting parties will require a different algorithm, as indicated in their metadata. You can configure the algorithm based on the asserting party’s metadata using RelyingPartyRegistrations(overview.html#servlet-saml2login-relyingpartyregistrationrepository) . Or, you can provide it manually: Java Kotlin String metadataLocation = ""classpath:asserting-party-metadata.xml""; RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistrations.fromMetadataLocation(metadataLocation) // ... .assertingPartyDetails((party) -> party // ... .signingAlgorithms((sign) -> sign.add(SignatureConstants.ALGO_ID_SIGNATURE_RSA_SHA512)) ) .build(); var metadataLocation = ""classpath:asserting-party-metadata.xml"" var relyingPartyRegistration: RelyingPartyRegistration = RelyingPartyRegistrations.fromMetadataLocation(metadataLocation) // ... .assertingPartyDetails { party: AssertingPartyDetails.Builder -> party // ... .signingAlgorithms { sign: MutableList<String?> -> sign.add( SignatureConstants.ALGO_ID_SIGNATURE_RSA_SHA512 ) } } .build() The snippet above uses the OpenSAML SignatureConstants class to supply the algorithm name. But, that’s just for convenience. Since the datatype is String , you can supply the name of the algorithm directly. Some asserting parties require that the <saml2:AuthnRequest> be POSTed. This can be configured automatically via RelyingPartyRegistrations , or you can supply it manually, like so: Java Kotlin RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId(""okta"") // ... .assertingPartyDetails(party -> party // ... .singleSignOnServiceBinding(Saml2MessageBinding.POST) ) .build(); var relyingPartyRegistration: RelyingPartyRegistration? = RelyingPartyRegistration.withRegistrationId(""okta"") // ... .assertingPartyDetails { party: AssertingPartyDetails.Builder -> party // ... .singleSignOnServiceBinding(Saml2MessageBinding.POST) } .build() Customizing OpenSAML’s AuthnRequest Instance: There are a number of reasons that you may want to adjust an AuthnRequest . For example, you may want ForceAuthN to be set to true , which Spring Security sets to false by default. You can customize elements of OpenSAML’s AuthnRequest by publishing an OpenSaml4AuthenticationRequestResolver as a @Bean , like so: Java Kotlin @Bean Saml2AuthenticationRequestResolver authenticationRequestResolver(RelyingPartyRegistrationRepository registrations) { RelyingPartyRegistrationResolver registrationResolver = new DefaultRelyingPartyRegistrationResolver(registrations); OpenSaml4AuthenticationRequestResolver authenticationRequestResolver = new OpenSaml4AuthenticationRequestResolver(registrationResolver); authenticationRequestResolver.setAuthnRequestCustomizer((context) -> context .getAuthnRequest().setForceAuthn(true)); return authenticationRequestResolver; } @Bean fun authenticationRequestResolver(registrations : RelyingPartyRegistrationRepository) : Saml2AuthenticationRequestResolver { val registrationResolver : RelyingPartyRegistrationResolver = new DefaultRelyingPartyRegistrationResolver(registrations) val authenticationRequestResolver : OpenSaml4AuthenticationRequestResolver = new OpenSaml4AuthenticationRequestResolver(registrationResolver) authenticationRequestResolver.setAuthnRequestCustomizer((context) -> context .getAuthnRequest().setForceAuthn(true)) return authenticationRequestResolver }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/saml2/login/authentication.html","Authenticating <saml2:Response>s: To verify SAML 2.0 Responses, Spring Security uses Saml2AuthenticationTokenConverter(overview.html#servlet-saml2login-authentication-saml2authenticationtokenconverter) to populate the Authentication request and OpenSaml4AuthenticationProvider(overview.html#servlet-saml2login-architecture) to authenticate it. You can configure this in a number of ways including: Changing the way the RelyingPartyRegistration is Looked Up Setting a clock skew to timestamp validation Mapping the response to a list of GrantedAuthority instances Customizing the strategy for validating assertions Customizing the strategy for decrypting response and assertion elements To configure these, you’ll use the saml2Login#authenticationManager method in the DSL. Changing the SAML Response Processing Endpoint: The default endpoint is /login/saml2/sso/{registrationId} . You can change this in the DSL and in the associated metadata like so: Java Kotlin @Bean SecurityFilterChain securityFilters(HttpSecurity http) throws Exception { http // ... .saml2Login((saml2) -> saml2.loginProcessingUrl(""/saml2/login/sso"")) // ... return http.build(); } @Bean fun securityFilters(val http: HttpSecurity): SecurityFilterChain { http { // ... .saml2Login { loginProcessingUrl = ""/saml2/login/sso"" } // ... } return http.build() } and: Java Kotlin relyingPartyRegistrationBuilder.assertionConsumerServiceLocation(""/saml/SSO"") relyingPartyRegistrationBuilder.assertionConsumerServiceLocation(""/saml/SSO"") Changing RelyingPartyRegistration lookup: By default, this converter will match against any associated <saml2:AuthnRequest> or any registrationId it finds in the URL. Or, if it cannot find one in either of those cases, then it attempts to look it up by the <saml2:Response#Issuer> element. There are a number of circumstances where you might need something more sophisticated, like if you are supporting ARTIFACT binding. In those cases, you can customize lookup through a custom AuthenticationConverter , which you can customize like so: Java Kotlin @Bean SecurityFilterChain securityFilters(HttpSecurity http, AuthenticationConverter authenticationConverter) throws Exception { http // ... .saml2Login((saml2) -> saml2.authenticationConverter(authenticationConverter)) // ... return http.build(); } @Bean fun securityFilters(val http: HttpSecurity, val converter: AuthenticationConverter): SecurityFilterChain { http { // ... .saml2Login { authenticationConverter = converter } // ... } return http.build() } Setting a Clock Skew: It’s not uncommon for the asserting and relying parties to have system clocks that aren’t perfectly synchronized. For that reason, you can configure OpenSaml4AuthenticationProvider 's default assertion validator with some tolerance: Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { OpenSaml4AuthenticationProvider authenticationProvider = new OpenSaml4AuthenticationProvider(); authenticationProvider.setAssertionValidator(OpenSaml4AuthenticationProvider .createDefaultAssertionValidator(assertionToken -> { Map<String, Object> params = new HashMap<>(); params.put(CLOCK_SKEW, Duration.ofMinutes(10).toMillis()); // ... other validation parameters return new ValidationContext(params); }) ); http .authorizeHttpRequests(authz -> authz .anyRequest().authenticated() ) .saml2Login(saml2 -> saml2 .authenticationManager(new ProviderManager(authenticationProvider)) ); return http.build(); } } @Configuration @EnableWebSecurity open class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { val authenticationProvider = OpenSaml4AuthenticationProvider() authenticationProvider.setAssertionValidator( OpenSaml4AuthenticationProvider .createDefaultAssertionValidator(Converter<OpenSaml4AuthenticationProvider.AssertionToken, ValidationContext> { val params: MutableMap<String, Any> = HashMap() params[CLOCK_SKEW] = Duration.ofMinutes(10).toMillis() ValidationContext(params) }) ) http { authorizeRequests { authorize(anyRequest, authenticated) } saml2Login { authenticationManager = ProviderManager(authenticationProvider) } } return http.build() } } Coordinating with a UserDetailsService: Or, perhaps you would like to include user details from a legacy UserDetailsService . In that case, the response authentication converter can come in handy, as can be seen below: Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Autowired UserDetailsService userDetailsService; @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { OpenSaml4AuthenticationProvider authenticationProvider = new OpenSaml4AuthenticationProvider(); authenticationProvider.setResponseAuthenticationConverter(responseToken -> { Saml2Authentication authentication = OpenSaml4AuthenticationProvider .createDefaultResponseAuthenticationConverter() (1) .convert(responseToken); Assertion assertion = responseToken.getResponse().getAssertions().get(0); String username = assertion.getSubject().getNameID().getValue(); UserDetails userDetails = this.userDetailsService.loadUserByUsername(username); (2) return MySaml2Authentication(userDetails, authentication); (3) }); http .authorizeHttpRequests(authz -> authz .anyRequest().authenticated() ) .saml2Login(saml2 -> saml2 .authenticationManager(new ProviderManager(authenticationProvider)) ); return http.build(); } } @Configuration @EnableWebSecurity open class SecurityConfig { @Autowired var userDetailsService: UserDetailsService? = null @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { val authenticationProvider = OpenSaml4AuthenticationProvider() authenticationProvider.setResponseAuthenticationConverter { responseToken: OpenSaml4AuthenticationProvider.ResponseToken -> val authentication = OpenSaml4AuthenticationProvider .createDefaultResponseAuthenticationConverter() (1) .convert(responseToken) val assertion: Assertion = responseToken.response.assertions[0] val username: String = assertion.subject.nameID.value val userDetails = userDetailsService!!.loadUserByUsername(username) (2) MySaml2Authentication(userDetails, authentication) (3) } http { authorizeRequests { authorize(anyRequest, authenticated) } saml2Login { authenticationManager = ProviderManager(authenticationProvider) } } return http.build() } } 1 First, call the default converter, which extracts attributes and authorities from the response 2 Second, call the UserDetailsService(../../authentication/passwords/user-details-service.html#servlet-authentication-userdetailsservice) using the relevant information 3 Third, return a custom authentication that includes the user details It’s not required to call OpenSaml4AuthenticationProvider 's default authentication converter. It returns a Saml2AuthenticatedPrincipal containing the attributes it extracted from AttributeStatement s as well as the single ROLE_USER authority. Performing Additional Response Validation: OpenSaml4AuthenticationProvider validates the Issuer and Destination values right after decrypting the Response . You can customize the validation by extending the default validator concatenating with your own response validator, or you can replace it entirely with yours. For example, you can throw a custom exception with any additional information available in the Response object, like so: OpenSaml4AuthenticationProvider provider = new OpenSaml4AuthenticationProvider(); provider.setResponseValidator((responseToken) -> { Saml2ResponseValidatorResult result = OpenSamlAuthenticationProvider .createDefaultResponseValidator() .convert(responseToken) .concat(myCustomValidator.convert(responseToken)); if (!result.getErrors().isEmpty()) { String inResponseTo = responseToken.getInResponseTo(); throw new CustomSaml2AuthenticationException(result, inResponseTo); } return result; }); Performing Additional Assertion Validation: OpenSaml4AuthenticationProvider performs minimal validation on SAML 2.0 Assertions. After verifying the signature, it will: Validate <AudienceRestriction> and <DelegationRestriction> conditions Validate <SubjectConfirmation> s, expect for any IP address information To perform additional validation, you can configure your own assertion validator that delegates to OpenSaml4AuthenticationProvider 's default and then performs its own. For example, you can use OpenSAML’s OneTimeUseConditionValidator to also validate a <OneTimeUse> condition, like so: Java Kotlin OpenSaml4AuthenticationProvider provider = new OpenSaml4AuthenticationProvider(); OneTimeUseConditionValidator validator = ...; provider.setAssertionValidator(assertionToken -> { Saml2ResponseValidatorResult result = OpenSaml4AuthenticationProvider .createDefaultAssertionValidator() .convert(assertionToken); Assertion assertion = assertionToken.getAssertion(); OneTimeUse oneTimeUse = assertion.getConditions().getOneTimeUse(); ValidationContext context = new ValidationContext(); try { if (validator.validate(oneTimeUse, assertion, context) = ValidationResult.VALID) { return result; } } catch (Exception e) { return result.concat(new Saml2Error(INVALID_ASSERTION, e.getMessage())); } return result.concat(new Saml2Error(INVALID_ASSERTION, context.getValidationFailureMessage())); }); var provider = OpenSaml4AuthenticationProvider() var validator: OneTimeUseConditionValidator = ... provider.setAssertionValidator { assertionToken -> val result = OpenSaml4AuthenticationProvider .createDefaultAssertionValidator() .convert(assertionToken) val assertion: Assertion = assertionToken.assertion val oneTimeUse: OneTimeUse = assertion.conditions.oneTimeUse val context = ValidationContext() try { if (validator.validate(oneTimeUse, assertion, context) = ValidationResult.VALID) { return@setAssertionValidator result } } catch (e: Exception) { return@setAssertionValidator result.concat(Saml2Error(INVALID_ASSERTION, e.message)) } result.concat(Saml2Error(INVALID_ASSERTION, context.validationFailureMessage)) } While recommended, it’s not necessary to call OpenSaml4AuthenticationProvider 's default assertion validator. A circumstance where you would skip it would be if you don’t need it to check the <AudienceRestriction> or the <SubjectConfirmation> since you are doing those yourself. Customizing Decryption: Spring Security decrypts <saml2:EncryptedAssertion> , <saml2:EncryptedAttribute> , and <saml2:EncryptedID> elements automatically by using the decryption Saml2X509Credential instances(overview.html#servlet-saml2login-rpr-credentials) registered in the RelyingPartyRegistration(overview.html#servlet-saml2login-relyingpartyregistration) . OpenSaml4AuthenticationProvider exposes two decryption strategies(overview.html#servlet-saml2login-architecture) . The response decrypter is for decrypting encrypted elements of the <saml2:Response> , like <saml2:EncryptedAssertion> . The assertion decrypter is for decrypting encrypted elements of the <saml2:Assertion> , like <saml2:EncryptedAttribute> and <saml2:EncryptedID> . You can replace OpenSaml4AuthenticationProvider 's default decryption strategy with your own. For example, if you have a separate service that decrypts the assertions in a <saml2:Response> , you can use it instead like so: Java Kotlin MyDecryptionService decryptionService = ...; OpenSaml4AuthenticationProvider provider = new OpenSaml4AuthenticationProvider(); provider.setResponseElementsDecrypter((responseToken) -> decryptionService.decrypt(responseToken.getResponse())); val decryptionService: MyDecryptionService = ... val provider = OpenSaml4AuthenticationProvider() provider.setResponseElementsDecrypter { responseToken -> decryptionService.decrypt(responseToken.response) } If you are also decrypting individual elements in a <saml2:Assertion> , you can customize the assertion decrypter, too: Java Kotlin provider.setAssertionElementsDecrypter((assertionToken) -> decryptionService.decrypt(assertionToken.getAssertion())); provider.setAssertionElementsDecrypter { assertionToken -> decryptionService.decrypt(assertionToken.assertion) } There are two separate decrypters since assertions can be signed separately from responses. Trying to decrypt a signed assertion’s elements before signature verification may invalidate the signature. If your asserting party signs the response only, then it’s safe to decrypt all elements using only the response decrypter. Using a Custom Authentication Manager: Of course, the authenticationManager DSL method can be also used to perform a completely custom SAML 2.0 authentication. This authentication manager should expect a Saml2AuthenticationToken object containing the SAML 2.0 Response XML data. Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { AuthenticationManager authenticationManager = new MySaml2AuthenticationManager(...); http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .saml2Login(saml2 -> saml2 .authenticationManager(authenticationManager) ) ; return http.build(); } } @Configuration @EnableWebSecurity open class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { val customAuthenticationManager: AuthenticationManager = MySaml2AuthenticationManager(...) http { authorizeRequests { authorize(anyRequest, authenticated) } saml2Login { authenticationManager = customAuthenticationManager } } return http.build() } } Using Saml2AuthenticatedPrincipal: With the relying party correctly configured for a given asserting party, it’s ready to accept assertions. Once the relying party validates an assertion, the result is a Saml2Authentication with a Saml2AuthenticatedPrincipal . This means that you can access the principal in your controller like so: Java Kotlin @Controller public class MainController { @GetMapping(""/"") public String index(@AuthenticationPrincipal Saml2AuthenticatedPrincipal principal, Model model) { String email = principal.getFirstAttribute(""email""); model.setAttribute(""email"", email); return ""index""; } } @Controller class MainController { @GetMapping(""/"") fun index(@AuthenticationPrincipal principal: Saml2AuthenticatedPrincipal, model: Model): String { val email = principal.getFirstAttribute<String>(""email"") model.setAttribute(""email"", email) return ""index"" } } Because the SAML 2.0 specification allows for each attribute to have multiple values, you can either call getAttribute to get the list of attributes or getFirstAttribute to get the first in the list. getFirstAttribute is quite handy when you know that there is only one value."
"https://docs.spring.io/spring-security/reference/6.3/servlet/saml2/logout.html","Performing Single Logout: Among its other logout mechanisms(../authentication/logout.html) , Spring Security ships with support for RP- and AP-initiated SAML 2.0 Single Logout. Briefly, there are two use cases Spring Security supports: RP-Initiated - Your application has an endpoint that, when POSTed to, will logout the user and send a saml2:LogoutRequest to the asserting party. Thereafter, the asserting party will send back a saml2:LogoutResponse and allow your application to respond AP-Initiated - Your application has an endpoint that will receive a saml2:LogoutRequest from the asserting party. Your application will complete its logout at that point and then send a saml2:LogoutResponse to the asserting party. In the AP-Initiated scenario, any local redirection that your application would do post-logout is rendered moot. Once your application sends a saml2:LogoutResponse , it no longer has control of the browser. Minimal Configuration for Single Logout: To use Spring Security’s SAML 2.0 Single Logout feature, you will need the following things: First, the asserting party must support SAML 2.0 Single Logout Second, the asserting party should be configured to sign and POST saml2:LogoutRequest s and saml2:LogoutResponse s your application’s /logout/saml2/slo endpoint Third, your application must have a PKCS#8 private key and X.509 certificate for signing saml2:LogoutRequest s and saml2:LogoutResponse s You can achieve this in Spring Boot in the following way: spring: security: saml2: relyingparty: registration: metadata: signing.credentials: (3) - private-key-location: classpath:credentials/rp-private.key certificate-location: classpath:credentials/rp-certificate.crt singlelogout.url: ""{baseUrl}/logout/saml2/slo"" (2) assertingparty: metadata-uri: https://ap.example.com/metadata (1) 1 - The metadata URI of the IDP, which will indicate to your application its support of SLO 2 - The SLO endpoint in your application 3 - The signing credentials to sign <saml2:LogoutRequest> s and <saml2:LogoutResponse> s An asserting party supports Single Logout if their metadata includes the `<SingleLogoutService>` element in their metadata. And that’s it! Spring Security’s logout support offers a number of configuration points. Consider the following use cases: Understand how the above minimal configuration works(#_startup_expectations) Get a picture of the overall architecture(#architecture) Allow users to logout out of the app only(#separating-local-saml2-logout) Customize logout endpoints(#_configuring_logout_endpoints) Storing <saml2:LogoutRequests> somewhere other than the session(#_customizing_storage) Startup Expectations: When these properties are used, in addition to login, SAML 2.0 Service Provider will automatically configure itself facilitate logout by way of <saml2:LogoutRequest> s and <saml2:LogoutResponse> s using either RP- or AP-initiated logout. It achieves this through a deterministic startup process: Query the Identity Server Metadata endpoint for the <SingleLogoutService> element Scan the metadata and cache any public signature verification keys Prepare the appropriate endpoints A consequence of this process is that the identity server must be up and receiving requests in order for Service Provider to successfully start up. If the identity server is down when Service Provider queries it (given appropriate timeouts), then startup will fail. Runtime Expectations: Given the above configuration any logged-in user can send a POST /logout to your application to perform RP-initiated SLO. Your application will then do the following: Logout the user and invalidate the session Produce a <saml2:LogoutRequest> and POST it to the associated asserting party’s SLO endpoint Then, if the asserting party responds with a <saml2:LogoutResponse> , the application with verify it and redirect to the configured success endpoint Also, your application can participate in an AP-initiated logout when the asserting party sends a <saml2:LogoutRequest> to /logout/saml2/slo . When this happens, your application will do the following: Verify the <saml2:LogoutRequest> Logout the user and invalidate the session Produce a <saml2:LogoutResponse> and POST it back to the asserting party’s SLO endpoint Minimal Configuration Sans Boot: Instead of Boot properties, you can also achieve the same outcome by publishing the beans directly like so: Java Kotlin @Configuration public class SecurityConfig { @Value(""${private.key}"") RSAPrivateKey key; @Value(""${public.certificate}"") X509Certificate certificate; @Bean RelyingPartyRegistrationRepository registrations() { Saml2X509Credential credential = Saml2X509Credential.signing(key, certificate); RelyingPartyRegistration registration = RelyingPartyRegistrations .fromMetadataLocation(""https://ap.example.org/metadata"") (1) .registrationId(""metadata"") .singleLogoutServiceLocation(""{baseUrl}/logout/saml2/slo"") (2) .signingX509Credentials((signing) -> signing.add(credential)) (3) .build(); return new InMemoryRelyingPartyRegistrationRepository(registration); } @Bean SecurityFilterChain web(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .anyRequest().authenticated() ) .saml2Login(withDefaults()) .saml2Logout(withDefaults()); (4) return http.build(); } } @Configuration class SecurityConfig(@Value(""${private.key}"") val key: RSAPrivateKey, @Value(""${public.certificate}"") val certificate: X509Certificate) { @Bean fun registrations(): RelyingPartyRegistrationRepository { val credential = Saml2X509Credential.signing(key, certificate) val registration = RelyingPartyRegistrations .fromMetadataLocation(""https://ap.example.org/metadata"") (1) .registrationId(""metadata"") .singleLogoutServiceLocation(""{baseUrl}/logout/saml2/slo"") (2) .signingX509Credentials({ signing: List<Saml2X509Credential> -> signing.add(credential) }) (3) .build() return InMemoryRelyingPartyRegistrationRepository(registration) } @Bean fun web(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { anyRequest = authenticated } saml2Login { } saml2Logout { (4) } } return http.build() } } 1 - The metadata URI of the IDP, which will indicate to your application its support of SLO 2 - The SLO endpoint in your application 3 - The signing credentials to sign <saml2:LogoutRequest> s and <saml2:LogoutResponse> s, which you can also add to multiple relying parties(login/overview.html#servlet-saml2login-rpr-duplicated) 4 - Second, indicate that your application wants to use SAML SLO to logout the end user Adding saml2Logout adds the capability for logout to your service provider as a whole. Because it is an optional capability, you need to enable it for each individual RelyingPartyRegistration . You do this by setting the RelyingPartyRegistration.Builder#singleLogoutServiceLocation property as seen above. How Saml 2.0 Logout Works: Next, let’s see the architectural components that Spring Security uses to support SAML 2.0 Logout(https://docs.oasis-open.org/security/saml/v2.0/saml-profiles-2.0-os.pdf#page=37) in servlet-based applications, like the one we just saw. For RP-initiated logout: Spring Security executes its logout flow(../authentication/logout.html#logout-architecture) , calling its LogoutHandler s to invalidate the session and perform other cleanup. It then invokes the Saml2RelyingPartyInitiatedLogoutSuccessHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/saml2/provider/service/web/authentication/logout/Saml2RelyingPartyInitiatedLogoutSuccessHandler.html) . The logout success handler uses an instance of Saml2LogoutRequestResolver(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/saml2/provider/service/web/authentication/logout/Saml2LogoutRequestResolver.html) to create, sign, and serialize a <saml2:LogoutRequest> . It uses the keys and configuration from the RelyingPartyRegistration(login/overview.html#servlet-saml2login-relyingpartyregistration) that is associated with the current Saml2AuthenticatedPrincipal . Then, it redirect-POSTs the <saml2:LogoutRequest> to the asserting party SLO endpoint The browser hands control over to the asserting party. If the asserting party redirects back (which it may not), then the application proceeds to step . The Saml2LogoutResponseFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/saml2/provider/service/web/authentication/logout/Saml2LogoutResponseFilter.html) deserializes, verifies, and processes the <saml2:LogoutResponse> with its Saml2LogoutResponseValidator(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/saml2/provider/service/authentication/logout/Saml2LogoutResponseValidator.html) . If valid, then it completes the local logout flow by redirecting to /login?logout , or whatever has been configured. If invalid, then it responds with a 400. For AP-initiated logout: The Saml2LogoutRequestFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/saml2/provider/service/web/authentication/logout/Saml2LogoutRequestFilter.html) deserializes, verifies, and processes the <saml2:LogoutRequest> with its Saml2LogoutRequestValidator(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/saml2/provider/service/authentication/logout/Saml2LogoutRequestValidator.html) . If valid, then the filter calls the configured LogoutHandler s, invalidating the session and performing other cleanup. It uses a Saml2LogoutResponseResolver(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/saml2/provider/service/web/authentication/logout/Saml2LogoutResponseResolver.html) to create, sign and serialize a <saml2:LogoutResponse> . It uses the keys and configuration from the RelyingPartyRegistration(login/overview.html#servlet-saml2login-relyingpartyregistration) derived from the endpoint or from the contents of the <saml2:LogoutRequest> . Then, it redirect-POSTs the <saml2:LogoutResponse> to the asserting party SLO endpoint. The browser hands control over to the asserting party. If invalid, then it responds with a 400(https://github.com/spring-projects/spring-security/pull/14676) . Configuring Logout Endpoints: There are three behaviors that can be triggered by different endpoints: RP-initiated logout, which allows an authenticated user to POST and trigger the logout process by sending the asserting party a <saml2:LogoutRequest> AP-initiated logout, which allows an asserting party to send a <saml2:LogoutRequest> to the application AP logout response, which allows an asserting party to send a <saml2:LogoutResponse> in response to the RP-initiated <saml2:LogoutRequest> The first is triggered by performing normal POST /logout when the principal is of type Saml2AuthenticatedPrincipal . The second is triggered by POSTing to the /logout/saml2/slo endpoint with a SAMLRequest signed by the asserting party. The third is triggered by POSTing to the /logout/saml2/slo endpoint with a SAMLResponse signed by the asserting party. Because the user is already logged in or the original Logout Request is known, the registrationId is already known. For this reason, {registrationId} is not part of these URLs by default. This URL is customizable in the DSL. For example, if you are migrating your existing relying party over to Spring Security, your asserting party may already be pointing to GET /SLOService.saml2 . To reduce changes in configuration for the asserting party, you can configure the filter in the DSL like so: Java Kotlin http .saml2Logout((saml2) -> saml2 .logoutRequest((request) -> request.logoutUrl(""/SLOService.saml2"")) .logoutResponse((response) -> response.logoutUrl(""/SLOService.saml2"")) ); http { saml2Logout { logoutRequest { logoutUrl = ""/SLOService.saml2"" } logoutResponse { logoutUrl = ""/SLOService.saml2"" } } } You should also configure these endpoints in your RelyingPartyRegistration . Also, you can customize the endpoint for triggering logout locally like so: Java Kotlin http .saml2Logout((saml2) -> saml2.logoutUrl(""/saml2/logout"")); http { saml2Logout { logoutUrl = ""/saml2/logout"" } } Separating Local Logout from SAML 2.0 Logout: In some cases, you may want to expose one logout endpoint for local logout and another for RP-initiated SLO. Like is the case with other logout mechanisms, you can register more than one, so long as they each have a different endpoint. So, for example, you can wire the DSL like so: Java Kotlin http .logout((logout) -> logout.logoutUrl(""/logout"")) .saml2Logout((saml2) -> saml2.logoutUrl(""/saml2/logout"")); http { logout { logoutUrl = ""/logout"" } saml2Logout { logoutUrl = ""/saml2/logout"" } } and now if a client sends a POST /logout , the session will be cleared, but there won’t be a <saml2:LogoutRequest> sent to the asserting party. But, if the client sends a POST /saml2/logout , then the application will initiate SAML 2.0 SLO as normal. Customizing <saml2:LogoutRequest> Resolution: It’s common to need to set other values in the <saml2:LogoutRequest> than the defaults that Spring Security provides. By default, Spring Security will issue a <saml2:LogoutRequest> and supply: The Destination attribute - from RelyingPartyRegistration#getAssertingPartyDetails#getSingleLogoutServiceLocation The ID attribute - a GUID The <Issuer> element - from RelyingPartyRegistration#getEntityId The <NameID> element - from Authentication#getName To add other values, you can use delegation, like so: Java Kotlin @Bean Saml2LogoutRequestResolver logoutRequestResolver(RelyingPartyRegistrationRepository registrations) { OpenSaml4LogoutRequestResolver logoutRequestResolver = new OpenSaml4LogoutRequestResolver(registrations); logoutRequestResolver.setParametersConsumer((parameters) -> { String name = ((Saml2AuthenticatedPrincipal) parameters.getAuthentication().getPrincipal()).getFirstAttribute(""CustomAttribute""); String format = ""urn:oasis:names:tc:SAML:2.0:nameid-format:transient""; LogoutRequest logoutRequest = parameters.getLogoutRequest(); NameID nameId = logoutRequest.getNameID(); nameId.setValue(name); nameId.setFormat(format); }); return logoutRequestResolver; } @Bean open fun logoutRequestResolver(registrations:RelyingPartyRegistrationRepository?): Saml2LogoutRequestResolver { val logoutRequestResolver = OpenSaml4LogoutRequestResolver(registrations) logoutRequestResolver.setParametersConsumer { parameters: LogoutRequestParameters -> val name: String = (parameters.getAuthentication().getPrincipal() as Saml2AuthenticatedPrincipal).getFirstAttribute(""CustomAttribute"") val format = ""urn:oasis:names:tc:SAML:2.0:nameid-format:transient"" val logoutRequest: LogoutRequest = parameters.getLogoutRequest() val nameId: NameID = logoutRequest.getNameID() nameId.setValue(name) nameId.setFormat(format) } return logoutRequestResolver } Then, you can supply your custom Saml2LogoutRequestResolver in the DSL as follows: Java Kotlin http .saml2Logout((saml2) -> saml2 .logoutRequest((request) -> request .logoutRequestResolver(this.logoutRequestResolver) ) ); http { saml2Logout { logoutRequest { logoutRequestResolver = this.logoutRequestResolver } } } Customizing <saml2:LogoutResponse> Resolution: It’s common to need to set other values in the <saml2:LogoutResponse> than the defaults that Spring Security provides. By default, Spring Security will issue a <saml2:LogoutResponse> and supply: The Destination attribute - from RelyingPartyRegistration#getAssertingPartyDetails#getSingleLogoutServiceResponseLocation The ID attribute - a GUID The <Issuer> element - from RelyingPartyRegistration#getEntityId The <Status> element - SUCCESS To add other values, you can use delegation, like so: Java Kotlin @Bean public Saml2LogoutResponseResolver logoutResponseResolver(RelyingPartyRegistrationRepository registrations) { OpenSaml4LogoutResponseResolver logoutRequestResolver = new OpenSaml4LogoutResponseResolver(registrations); logoutRequestResolver.setParametersConsumer((parameters) -> { if (checkOtherPrevailingConditions(parameters.getRequest())) { parameters.getLogoutRequest().getStatus().getStatusCode().setCode(StatusCode.PARTIAL_LOGOUT); } }); return logoutRequestResolver; } @Bean open fun logoutResponseResolver(registrations: RelyingPartyRegistrationRepository?): Saml2LogoutResponseResolver { val logoutRequestResolver = OpenSaml4LogoutResponseResolver(registrations) logoutRequestResolver.setParametersConsumer { LogoutResponseParameters parameters -> if (checkOtherPrevailingConditions(parameters.getRequest())) { parameters.getLogoutRequest().getStatus().getStatusCode().setCode(StatusCode.PARTIAL_LOGOUT) } } return logoutRequestResolver } Then, you can supply your custom Saml2LogoutResponseResolver in the DSL as follows: Java Kotlin http .saml2Logout((saml2) -> saml2 .logoutRequest((request) -> request .logoutRequestResolver(this.logoutRequestResolver) ) ); http { saml2Logout { logoutRequest { logoutRequestResolver = this.logoutRequestResolver } } } Customizing <saml2:LogoutRequest> Authentication: To customize validation, you can implement your own Saml2LogoutRequestValidator . At this point, the validation is minimal, so you may be able to first delegate to the default Saml2LogoutRequestValidator like so: Java Kotlin @Component public class MyOpenSamlLogoutRequestValidator implements Saml2LogoutRequestValidator { private final Saml2LogoutRequestValidator delegate = new OpenSamlLogoutRequestValidator(); @Override public Saml2LogoutRequestValidator logout(Saml2LogoutRequestValidatorParameters parameters) { // verify signature, issuer, destination, and principal name Saml2LogoutValidatorResult result = delegate.authenticate(authentication); LogoutRequest logoutRequest = // ... parse using OpenSAML // perform custom validation } } @Component open class MyOpenSamlLogoutRequestValidator: Saml2LogoutRequestValidator { private val delegate = OpenSamlLogoutRequestValidator() @Override fun logout(parameters: Saml2LogoutRequestValidatorParameters): Saml2LogoutRequestValidator { // verify signature, issuer, destination, and principal name val result = delegate.authenticate(authentication) val logoutRequest: LogoutRequest = // ... parse using OpenSAML // perform custom validation } } Then, you can supply your custom Saml2LogoutRequestValidator in the DSL as follows: Java Kotlin http .saml2Logout((saml2) -> saml2 .logoutRequest((request) -> request .logoutRequestValidator(myOpenSamlLogoutRequestValidator) ) ); http { saml2Logout { logoutRequest { logoutRequestValidator = myOpenSamlLogoutRequestValidator } } } Customizing <saml2:LogoutResponse> Authentication: To customize validation, you can implement your own Saml2LogoutResponseValidator . At this point, the validation is minimal, so you may be able to first delegate to the default Saml2LogoutResponseValidator like so: Java Kotlin @Component public class MyOpenSamlLogoutResponseValidator implements Saml2LogoutResponseValidator { private final Saml2LogoutResponseValidator delegate = new OpenSamlLogoutResponseValidator(); @Override public Saml2LogoutValidatorResult logout(Saml2LogoutResponseValidatorParameters parameters) { // verify signature, issuer, destination, and status Saml2LogoutValidatorResult result = delegate.authenticate(parameters); LogoutResponse logoutResponse = // ... parse using OpenSAML // perform custom validation } } @Component open class MyOpenSamlLogoutResponseValidator: Saml2LogoutResponseValidator { private val delegate = OpenSamlLogoutResponseValidator() @Override fun logout(parameters: Saml2LogoutResponseValidatorParameters): Saml2LogoutResponseValidator { // verify signature, issuer, destination, and status val result = delegate.authenticate(authentication) val logoutResponse: LogoutResponse = // ... parse using OpenSAML // perform custom validation } } Then, you can supply your custom Saml2LogoutResponseValidator in the DSL as follows: Java Kotlin http .saml2Logout((saml2) -> saml2 .logoutResponse((response) -> response .logoutResponseAuthenticator(myOpenSamlLogoutResponseAuthenticator) ) ); http { saml2Logout { logoutResponse { logoutResponseValidator = myOpenSamlLogoutResponseValidator } } } Customizing <saml2:LogoutRequest> storage: When your application sends a <saml2:LogoutRequest> , the value is stored in the session so that the RelayState parameter and the InResponseTo attribute in the <saml2:LogoutResponse> can be verified. If you want to store logout requests in some place other than the session, you can supply your custom implementation in the DSL, like so: Java Kotlin http .saml2Logout((saml2) -> saml2 .logoutRequest((request) -> request .logoutRequestRepository(myCustomLogoutRequestRepository) ) ); http { saml2Logout { logoutRequest { logoutRequestRepository = myCustomLogoutRequestRepository } } } Further Logout-Related References: Testing Logout(../test/mockmvc/logout.html#test-logout) HttpServletRequest.logout()(../integrations/servlet-api.html#servletapi-logout) Logging Out(../exploits/csrf.html#csrf-considerations-logout) in section CSRF Caveats"
"https://docs.spring.io/spring-security/reference/6.3/servlet/saml2/metadata.html","Saml 2.0 Metadata: Spring Security can parse asserting party metadata(#parsing-asserting-party-metadata) to produce an AssertingPartyDetails instance as well as publish relying party metadata(#publishing-relying-party-metadata) from a RelyingPartyRegistration instance. Parsing <saml2:IDPSSODescriptor> metadata: You can parse an asserting party’s metadata using RelyingPartyRegistrations(login/overview.html#servlet-saml2login-relyingpartyregistrationrepository) . When using the OpenSAML vendor support, the resulting AssertingPartyDetails will be of type OpenSamlAssertingPartyDetails . This means you’ll be able to do get the underlying OpenSAML XMLObject by doing the following: Java Kotlin OpenSamlAssertingPartyDetails details = (OpenSamlAssertingPartyDetails) registration.getAssertingPartyDetails(); EntityDescriptor openSamlEntityDescriptor = details.getEntityDescriptor(); val details: OpenSamlAssertingPartyDetails = registration.getAssertingPartyDetails() as OpenSamlAssertingPartyDetails; val openSamlEntityDescriptor: EntityDescriptor = details.getEntityDescriptor(); Producing <saml2:SPSSODescriptor> Metadata: You can publish a metadata endpoint using the saml2Metadata DSL method, as you’ll see below: Java Kotlin http // ... .saml2Login(withDefaults()) .saml2Metadata(withDefaults()); http { //... saml2Login { } saml2Metadata { } } You can use this metadata endpoint to register your relying party with your asserting party. This is often as simple as finding the correct form field to supply the metadata endpoint. By default, the metadata endpoint is /saml2/metadata , though it also responds to /saml2/metadata/{registrationId} and /saml2/service-provider-metadata/{registrationId} . You can change this by calling the metadataUrl method in the DSL: Java Kotlin .saml2Metadata((saml2) -> saml2.metadataUrl(""/saml/metadata"")) saml2Metadata { metadataUrl = ""/saml/metadata"" } Changing the Way a RelyingPartyRegistration Is Looked Up: If you have a different strategy for identifying which RelyingPartyRegistration to use, you can configure your own Saml2MetadataResponseResolver like the one below: Java Kotlin @Bean Saml2MetadataResponseResolver metadataResponseResolver(RelyingPartyRegistrationRepository registrations) { RequestMatcherMetadataResponseResolver metadata = new RequestMatcherMetadataResponseResolver( (id) -> registrations.findByRegistrationId(""relying-party"")); metadata.setMetadataFilename(""metadata.xml""); return metadata; } @Bean fun metadataResponseResolver(val registrations: RelyingPartyRegistrationRepository): Saml2MetadataResponseResolver { val metadata = new RequestMatcherMetadataResponseResolver( id: String -> registrations.findByRegistrationId(""relying-party"")) metadata.setMetadataFilename(""metadata.xml"") return metadata }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/exploits/index.html","Protection Against Exploits: This section discusses Servlet specific support for Spring Security’s protection against common exploits(../../features/exploits/index.html#exploits) . Section Summary: Cross Site Request Forgery (CSRF)(csrf.html) Security HTTP Response Headers(headers.html) HTTP(http.html) HttpFirewall(firewall.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/exploits/csrf.html","Cross Site Request Forgery (CSRF): In an application where end users can log in(../authentication/index.html) , it is important to consider how to protect against Cross Site Request Forgery (CSRF)(../../features/exploits/csrf.html#csrf) . Spring Security protects against CSRF attacks by default for unsafe HTTP methods(../../features/exploits/csrf.html#csrf-protection-read-only) , such as a POST request, so no additional code is necessary. You can specify the default configuration explicitly using the following: Configure CSRF Protection Java Kotlin XML @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .csrf(Customizer.withDefaults()); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... csrf { } } return http.build() } } <http> <!-- ... --> <csrf/> </http> To learn more about CSRF protection for your application, consider the following use cases: I want to understand CSRF protection’s components(#csrf-components) I need to migrate an application from Spring Security 5 to 6(#migrating-to-spring-security-6) I want to store the CsrfToken in a cookie(#csrf-token-repository-cookie) instead of the session(#csrf-token-repository-httpsession) I want to store the CsrfToken in a custom location(#csrf-token-repository-custom) I want to opt-out of deferred tokens(#deferred-csrf-token-opt-out) I want to opt-out of BREACH protection(#csrf-token-request-handler-opt-out-of-breach) I need guidance integrating Thymeleaf, JSPs or another view technology(#csrf-integration-form) with the backend I need guidance integrating Angular or another JavaScript framework(#csrf-integration-javascript) with the backend I need guidance integrating a mobile application or another client(#csrf-integration-mobile) with the backend I need guidance on handling errors(#csrf-access-denied-handler) I want to test CSRF protection(#csrf-testing) I need guidance on disabling CSRF protection(#disable-csrf) Understanding CSRF Protection’s Components: CSRF protection is provided by several components that are composed within the CsrfFilter(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/csrf/CsrfFilter.html) : Figure 1. CsrfFilter Components CSRF protection is divided into two parts: Make the CsrfToken(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/csrf/CsrfToken.html) available to the application by delegating to the CsrfTokenRequestHandler(#csrf-token-request-handler) . Determine if the request requires CSRF protection, load and validate the token, and handle AccessDeniedException(#csrf-access-denied-handler) . Figure 2. CsrfFilter Processing First, the DeferredCsrfToken(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/csrf/DeferredCsrfToken.html) is loaded, which holds a reference to the CsrfTokenRepository(#csrf-token-repository) so that the persisted CsrfToken can be loaded later (in ). Second, a Supplier<CsrfToken> (created from DeferredCsrfToken ) is given to the CsrfTokenRequestHandler(#csrf-token-request-handler) , which is responsible for populating a request attribute to make the CsrfToken available to the rest of the application. Next, the main CSRF protection processing begins and checks if the current request requires CSRF protection. If not required, the filter chain is continued and processing ends. If CSRF protection is required, the persisted CsrfToken is finally loaded from the DeferredCsrfToken . Continuing, the actual CSRF token provided by the client (if any) is resolved using the CsrfTokenRequestHandler(#csrf-token-request-handler) . The actual CSRF token is compared against the persisted CsrfToken . If valid, the filter chain is continued and processing ends. If the actual CSRF token is invalid (or missing), an AccessDeniedException is passed to the AccessDeniedHandler(#csrf-access-denied-handler) and processing ends. Migrating to Spring Security 6: When migrating from Spring Security 5 to 6, there are a few changes that may impact your application. The following is an overview of the aspects of CSRF protection that have changed in Spring Security 6: Loading of the CsrfToken is now deferred by default(#deferred-csrf-token) to improve performance by no longer requiring the session to be loaded on every request. The CsrfToken now includes randomness on every request by default(#csrf-token-request-handler-breach) to protect the CSRF token from a BREACH(https://en.wikipedia.org/wiki/BREACH) attack. The changes in Spring Security 6 require additional configuration for single-page applications, and as such you may find the Single-Page Applications(#csrf-integration-javascript-spa) section particularly useful. See the Exploit Protection(https://docs.spring.io/spring-security/reference/5.8/migration/servlet/exploits.html) section of the Migration(https://docs.spring.io/spring-security/reference/5.8/migration/index.html) chapter for more information on migrating a Spring Security 5 application. Persisting the CsrfToken: The CsrfToken is persisted using a CsrfTokenRepository . By default, the HttpSessionCsrfTokenRepository(#csrf-token-repository-httpsession) is used for storing tokens in a session. Spring Security also provides the CookieCsrfTokenRepository(#csrf-token-repository-cookie) for storing tokens in a cookie. You can also specify your own implementation(#csrf-token-repository-custom) to store tokens wherever you like. Using the HttpSessionCsrfTokenRepository: By default, Spring Security stores the expected CSRF token in the HttpSession by using HttpSessionCsrfTokenRepository(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/csrf/HttpSessionCsrfTokenRepository.html) , so no additional code is necessary. The HttpSessionCsrfTokenRepository reads the token from a session (whether in-memory, cache, or database). If you need to access the session attribute directly, please first configure the session attribute name using HttpSessionCsrfTokenRepository#setSessionAttributeName . You can specify the default configuration explicitly using the following configuration: Configure HttpSessionCsrfTokenRepository Java Kotlin XML @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .csrf((csrf) -> csrf .csrfTokenRepository(new HttpSessionCsrfTokenRepository()) ); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... csrf { csrfTokenRepository = HttpSessionCsrfTokenRepository() } } return http.build() } } <http> <!-- ... --> <csrf token-repository-ref=""tokenRepository""/> </http> <b:bean id=""tokenRepository"" class=""org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository""/> Using the CookieCsrfTokenRepository: You can persist the CsrfToken in a cookie to support a JavaScript-based application(#csrf-integration-javascript) using the CookieCsrfTokenRepository(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/csrf/CookieCsrfTokenRepository.html) . The CookieCsrfTokenRepository writes to a cookie named XSRF-TOKEN and reads it from an HTTP request header named X-XSRF-TOKEN or the request parameter _csrf by default. These defaults come from Angular and its predecessor AngularJS(https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection) . See the Cross-Site Request Forgery (XSRF) protection(https://angular.io/guide/http-security-xsrf-protection) guide and the HttpClientXsrfModule(https://angular.io/api/common/http/HttpClientXsrfModule) for more recent information on this topic. You can configure the CookieCsrfTokenRepository using the following configuration: Configure CookieCsrfTokenRepository Java Kotlin XML @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .csrf((csrf) -> csrf .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) ); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... csrf { csrfTokenRepository = CookieCsrfTokenRepository.withHttpOnlyFalse() } } return http.build() } } <http> <!-- ... --> <csrf token-repository-ref=""tokenRepository""/> </http> <b:bean id=""tokenRepository"" class=""org.springframework.security.web.csrf.CookieCsrfTokenRepository"" p:cookieHttpOnly=""false""/> The example explicitly sets HttpOnly to false . This is necessary to let JavaScript frameworks (such as Angular) read it. If you do not need the ability to read the cookie with JavaScript directly, we recommend omitting HttpOnly (by using new CookieCsrfTokenRepository() instead) to improve security. Customizing the CsrfTokenRepository: There can be cases where you want to implement a custom CsrfTokenRepository(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/csrf/CsrfTokenRepository.html) . Once you’ve implemented the CsrfTokenRepository interface, you can configure Spring Security to use it with the following configuration: Configure Custom CsrfTokenRepository Java Kotlin XML @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .csrf((csrf) -> csrf .csrfTokenRepository(new CustomCsrfTokenRepository()) ); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... csrf { csrfTokenRepository = CustomCsrfTokenRepository() } } return http.build() } } <http> <!-- ... --> <csrf token-repository-ref=""tokenRepository""/> </http> <b:bean id=""tokenRepository"" class=""example.CustomCsrfTokenRepository""/> Handling the CsrfToken: The CsrfToken is made available to an application using a CsrfTokenRequestHandler . This component is also responsible for resolving the CsrfToken from HTTP headers or request parameters. By default, the XorCsrfTokenRequestAttributeHandler(#csrf-token-request-handler-breach) is used for providing BREACH(https://en.wikipedia.org/wiki/BREACH) protection of the CsrfToken . Spring Security also provides the CsrfTokenRequestAttributeHandler(#csrf-token-request-handler-plain) for opting out of BREACH protection. You can also specify your own implementation(#csrf-token-request-handler-custom) to customize the strategy for handling and resolving tokens. Using the XorCsrfTokenRequestAttributeHandler (BREACH): The XorCsrfTokenRequestAttributeHandler makes the CsrfToken available as an HttpServletRequest attribute called _csrf , and additionally provides protection for BREACH(https://en.wikipedia.org/wiki/BREACH) . The CsrfToken is also made available as a request attribute using the name CsrfToken.class.getName() . This name is not configurable, but the name _csrf can be changed using XorCsrfTokenRequestAttributeHandler#setCsrfRequestAttributeName . This implementation also resolves the token value from the request as either a request header (one of X-CSRF-TOKEN(#csrf-token-repository-httpsession) or X-XSRF-TOKEN(#csrf-token-repository-cookie) by default) or a request parameter ( _csrf by default). BREACH protection is provided by encoding randomness into the CSRF token value to ensure the returned CsrfToken changes on every request. When the token is later resolved as a header value or request parameter, it is decoded to obtain the raw token which is then compared to the persisted CsrfToken(#csrf-token-repository) . Spring Security protects the CSRF token from a BREACH attack by default, so no additional code is necessary. You can specify the default configuration explicitly using the following configuration: Configure BREACH protection Java Kotlin XML @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .csrf((csrf) -> csrf .csrfTokenRequestHandler(new XorCsrfTokenRequestAttributeHandler()) ); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... csrf { csrfTokenRequestHandler = XorCsrfTokenRequestAttributeHandler() } } return http.build() } } <http> <!-- ... --> <csrf request-handler-ref=""requestHandler""/> </http> <b:bean id=""requestHandler"" class=""org.springframework.security.web.csrf.XorCsrfTokenRequestAttributeHandler""/> Using the CsrfTokenRequestAttributeHandler: The CsrfTokenRequestAttributeHandler makes the CsrfToken available as an HttpServletRequest attribute called _csrf . The CsrfToken is also made available as a request attribute using the name CsrfToken.class.getName() . This name is not configurable, but the name _csrf can be changed using CsrfTokenRequestAttributeHandler#setCsrfRequestAttributeName . This implementation also resolves the token value from the request as either a request header (one of X-CSRF-TOKEN(#csrf-token-repository-httpsession) or X-XSRF-TOKEN(#csrf-token-repository-cookie) by default) or a request parameter ( _csrf by default). The primary use of CsrfTokenRequestAttributeHandler is to opt-out of BREACH protection of the CsrfToken , which can be configured using the following configuration: Opt-out of BREACH protection Java Kotlin XML @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .csrf((csrf) -> csrf .csrfTokenRequestHandler(new CsrfTokenRequestAttributeHandler()) ); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... csrf { csrfTokenRequestHandler = CsrfTokenRequestAttributeHandler() } } return http.build() } } <http> <!-- ... --> <csrf request-handler-ref=""requestHandler""/> </http> <b:bean id=""requestHandler"" class=""org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler""/> Customizing the CsrfTokenRequestHandler: You can implement the CsrfTokenRequestHandler interface to customize the strategy for handling and resolving tokens. The CsrfTokenRequestHandler interface is a @FunctionalInterface that can be implemented using a lambda expression to customize request handling. You will need to implement the full interface to customize how tokens are resolved from the request. See Configure CSRF for Single-Page Application(#csrf-integration-javascript-spa-configuration) for an example that uses delegation to implement a custom strategy for handling and resolving tokens. Once you’ve implemented the CsrfTokenRequestHandler interface, you can configure Spring Security to use it with the following configuration: Configure Custom CsrfTokenRequestHandler Java Kotlin XML @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .csrf((csrf) -> csrf .csrfTokenRequestHandler(new CustomCsrfTokenRequestHandler()) ); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... csrf { csrfTokenRequestHandler = CustomCsrfTokenRequestHandler() } } return http.build() } } <http> <!-- ... --> <csrf request-handler-ref=""requestHandler""/> </http> <b:bean id=""requestHandler"" class=""example.CustomCsrfTokenRequestHandler""/> Deferred Loading of the CsrfToken: By default, Spring Security defers loading of the CsrfToken until it is needed. The CsrfToken is needed whenever a request is made with an unsafe HTTP method(../../features/exploits/csrf.html#csrf-protection-read-only) , such as a POST. Additionally, it is needed by any request that renders the token to the response, such as a web page with a <form> tag that includes a hidden <input> for the CSRF token. Because Spring Security also stores the CsrfToken in the HttpSession by default, deferred CSRF tokens can improve performance by not requiring the session to be loaded on every request. In the event that you want to opt-out of deferred tokens and cause the CsrfToken to be loaded on every request, you can do so with the following configuration: Opt-out of Deferred CSRF Tokens Java Kotlin XML @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { XorCsrfTokenRequestAttributeHandler requestHandler = new XorCsrfTokenRequestAttributeHandler(); // set the name of the attribute the CsrfToken will be populated on requestHandler.setCsrfRequestAttributeName(null); http // ... .csrf((csrf) -> csrf .csrfTokenRequestHandler(requestHandler) ); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { val requestHandler = XorCsrfTokenRequestAttributeHandler() // set the name of the attribute the CsrfToken will be populated on requestHandler.setCsrfRequestAttributeName(null) http { // ... csrf { csrfTokenRequestHandler = requestHandler } } return http.build() } } <http> <!-- ... --> <csrf request-handler-ref=""requestHandler""/> </http> <b:bean id=""requestHandler"" class=""org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler""> <b:property name=""csrfRequestAttributeName""> <b:null/> </b:property> </b:bean> By setting the csrfRequestAttributeName to null , the CsrfToken must first be loaded to determine what attribute name to use. This causes the CsrfToken to be loaded on every request. Integrating with CSRF Protection: For the synchronizer token pattern(../../features/exploits/csrf.html#csrf-protection-stp) to protect against CSRF attacks, we must include the actual CSRF token in the HTTP request. This must be included in a part of the request (a form parameter, an HTTP header, or other part) that is not automatically included in the HTTP request by the browser. The following sections describe the various ways a frontend or client application can integrate with a CSRF-protected backend application: HTML Forms(#csrf-integration-form) JavaScript Applications(#csrf-integration-javascript) Mobile Applications(#csrf-integration-mobile) HTML Forms: To submit an HTML form, the CSRF token must be included in the form as a hidden input. For example, the rendered HTML might look like: CSRF Token in HTML Form <input type=""hidden"" name=""_csrf"" value=""4bfd1575-3ad1-4d21-96c7-4ef2d9f86721""/> The following view technologies automatically include the actual CSRF token in a form that has an unsafe HTTP method, such as a POST: Spring’s form tag library(https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view-jsp-formtaglib) Thymeleaf(https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor) Any other view technology that integrates with RequestDataValueProcessor(https://docs.spring.io/spring-framework/docs/6.1.12/javadoc-api/org/springframework/web/servlet/support/RequestDataValueProcessor.html) (via CsrfRequestDataValueProcessor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/servlet/support/csrf/CsrfRequestDataValueProcessor.html) ) You can also include the token yourself via the csrfInput(../integrations/jsp-taglibs.html#taglibs-csrfinput) tag If these options are not available, you can take advantage of the fact that the CsrfToken is exposed as an HttpServletRequest attribute named _csrf(#csrf-token-request-handler) . The following example does this with a JSP: CSRF Token in HTML Form with Request Attribute <c:url var=""logoutUrl"" value=""/logout""/> <form action=""${logoutUrl}"" method=""post""> <input type=""submit"" value=""Log out"" /> <input type=""hidden"" name=""${_csrf.parameterName}"" value=""${_csrf.token}""/> </form> JavaScript Applications: JavaScript applications typically use JSON instead of HTML. If you use JSON, you can submit the CSRF token within an HTTP request header instead of a request parameter. In order to obtain the CSRF token, you can configure Spring Security to store the expected CSRF token in a cookie(#csrf-token-repository-cookie) . By storing the expected token in a cookie, JavaScript frameworks such as Angular(https://angular.io/api/common/http/HttpClientXsrfModule) can automatically include the actual CSRF token as an HTTP request header. There are special considerations for BREACH protection and deferred tokens when integrating a single-page application (SPA) with Spring Security’s CSRF protection. A full configuration example is provided in the next section(#csrf-integration-javascript-spa) . You can read about different types of JavaScript applications in the following sections: Single-Page Applications(#csrf-integration-javascript-spa) Multi-Page Applications(#csrf-integration-javascript-mpa) Other JavaScript Applications(#csrf-integration-javascript-other) Single-Page Applications: There are special considerations for integrating a single-page application (SPA) with Spring Security’s CSRF protection. Recall that Spring Security provides BREACH protection of the CsrfToken(#csrf-token-request-handler-breach) by default. When storing the expected CSRF token in a cookie(#csrf-token-repository-cookie) , JavaScript applications will only have access to the plain token value and will not have access to the encoded value. A customized request handler(#csrf-token-request-handler-custom) for resolving the actual token value will need to be provided. In addition, the cookie storing the CSRF token will be cleared upon authentication success and logout success. Spring Security defers loading a new CSRF token by default, and additional work is required to return a fresh cookie. Refreshing the token after authentication success and logout success is required because the CsrfAuthenticationStrategy(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/csrf/CsrfAuthenticationStrategy.html) and CsrfLogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/csrf/CsrfLogoutHandler.html) will clear the previous token. The client application will not be able to perform an unsafe HTTP request, such as a POST, without obtaining a fresh token. In order to easily integrate a single-page application with Spring Security, the following configuration can be used: Configure CSRF for Single-Page Application Java Kotlin XML @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .csrf((csrf) -> csrf .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) (1) .csrfTokenRequestHandler(new SpaCsrfTokenRequestHandler()) (2) ) .addFilterAfter(new CsrfCookieFilter(), BasicAuthenticationFilter.class); (3) return http.build(); } } final class SpaCsrfTokenRequestHandler extends CsrfTokenRequestAttributeHandler { private final CsrfTokenRequestHandler delegate = new XorCsrfTokenRequestAttributeHandler(); @Override public void handle(HttpServletRequest request, HttpServletResponse response, Supplier<CsrfToken> csrfToken) { /* * Always use XorCsrfTokenRequestAttributeHandler to provide BREACH protection of * the CsrfToken when it is rendered in the response body. */ this.delegate.handle(request, response, csrfToken); } @Override public String resolveCsrfTokenValue(HttpServletRequest request, CsrfToken csrfToken) { /* * If the request contains a request header, use CsrfTokenRequestAttributeHandler * to resolve the CsrfToken. This applies when a single-page application includes * the header value automatically, which was obtained via a cookie containing the * raw CsrfToken. */ if (StringUtils.hasText(request.getHeader(csrfToken.getHeaderName()))) { return super.resolveCsrfTokenValue(request, csrfToken); } /* * In all other cases (e.g. if the request contains a request parameter), use * XorCsrfTokenRequestAttributeHandler to resolve the CsrfToken. This applies * when a server-side rendered form includes the _csrf request parameter as a * hidden input. */ return this.delegate.resolveCsrfTokenValue(request, csrfToken); } } final class CsrfCookieFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { CsrfToken csrfToken = (CsrfToken) request.getAttribute(""_csrf""); // Render the token value to a cookie by causing the deferred token to be loaded csrfToken.getToken(); filterChain.doFilter(request, response); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... csrf { csrfTokenRepository = CookieCsrfTokenRepository.withHttpOnlyFalse() (1) csrfTokenRequestHandler = SpaCsrfTokenRequestHandler() (2) } } http.addFilterAfter(CsrfCookieFilter(), BasicAuthenticationFilter::class.java) (3) return http.build() } } class SpaCsrfTokenRequestHandler : CsrfTokenRequestAttributeHandler() { private val delegate: CsrfTokenRequestHandler = XorCsrfTokenRequestAttributeHandler() override fun handle(request: HttpServletRequest, response: HttpServletResponse, csrfToken: Supplier<CsrfToken>) { /* * Always use XorCsrfTokenRequestAttributeHandler to provide BREACH protection of * the CsrfToken when it is rendered in the response body. */ delegate.handle(request, response, csrfToken) } override fun resolveCsrfTokenValue(request: HttpServletRequest, csrfToken: CsrfToken): String? { /* * If the request contains a request header, use CsrfTokenRequestAttributeHandler * to resolve the CsrfToken. This applies when a single-page application includes * the header value automatically, which was obtained via a cookie containing the * raw CsrfToken. */ return if (StringUtils.hasText(request.getHeader(csrfToken.headerName))) { super.resolveCsrfTokenValue(request, csrfToken) } else { /* * In all other cases (e.g. if the request contains a request parameter), use * XorCsrfTokenRequestAttributeHandler to resolve the CsrfToken. This applies * when a server-side rendered form includes the _csrf request parameter as a * hidden input. */ delegate.resolveCsrfTokenValue(request, csrfToken) } } } class CsrfCookieFilter : OncePerRequestFilter() { @Throws(ServletException::class, IOException::class) override fun doFilterInternal(request: HttpServletRequest, response: HttpServletResponse, filterChain: FilterChain) { val csrfToken = request.getAttribute(""_csrf"") as CsrfToken // Render the token value to a cookie by causing the deferred token to be loaded csrfToken.token filterChain.doFilter(request, response) } } <http> <!-- ... --> <csrf token-repository-ref=""tokenRepository"" (1) request-handler-ref=""requestHandler""/> (2) <custom-filter ref=""csrfCookieFilter"" after=""BASIC_AUTH_FILTER""/> (3) </http> <b:bean id=""tokenRepository"" class=""org.springframework.security.web.csrf.CookieCsrfTokenRepository"" p:cookieHttpOnly=""false""/> <b:bean id=""requestHandler"" class=""example.SpaCsrfTokenRequestHandler""/> <b:bean id=""csrfCookieFilter"" class=""example.CsrfCookieFilter""/> 1 Configure CookieCsrfTokenRepository with HttpOnly set to false so the cookie can be read by the JavaScript application. 2 Configure a custom CsrfTokenRequestHandler that resolves the CSRF token based on whether it is an HTTP request header ( X-XSRF-TOKEN ) or request parameter ( _csrf ). 3 Configure a custom Filter to load the CsrfToken on every request, which will return a new cookie if needed. Multi-Page Applications: For multi-page applications where JavaScript is loaded on each page, an alternative to exposing the CSRF token in a cookie(#csrf-token-repository-cookie) is to include the CSRF token within your meta tags. The HTML might look something like this: CSRF Token in HTML Meta Tag <html> <head> <meta name=""_csrf"" content=""4bfd1575-3ad1-4d21-96c7-4ef2d9f86721""/> <meta name=""_csrf_header"" content=""X-CSRF-TOKEN""/> <!-- ... --> </head> <!-- ... --> </html> In order to include the CSRF token in the request, you can take advantage of the fact that the CsrfToken is exposed as an HttpServletRequest attribute named _csrf(#csrf-token-request-handler) . The following example does this with a JSP: CSRF Token in HTML Meta Tag with Request Attribute <html> <head> <meta name=""_csrf"" content=""${_csrf.token}""/> <!-- default header name is X-CSRF-TOKEN --> <meta name=""_csrf_header"" content=""${_csrf.headerName}""/> <!-- ... --> </head> <!-- ... --> </html> Once the meta tags contain the CSRF token, the JavaScript code can read the meta tags and include the CSRF token as a header. If you use jQuery, you can do this with the following code: Include CSRF Token in AJAX Request $(function () { var token = $(""meta[name='_csrf']"").attr(""content""); var header = $(""meta[name='_csrf_header']"").attr(""content""); $(document).ajaxSend(function(e, xhr, options) { xhr.setRequestHeader(header, token); }); }); Other JavaScript Applications: Another option for JavaScript applications is to include the CSRF token in an HTTP response header. One way to achieve this is through the use of a @ControllerAdvice with the CsrfTokenArgumentResolver(../integrations/mvc.html#mvc-csrf-resolver) . The following is an example of @ControllerAdvice that applies to all controller endpoints in the application: CSRF Token in HTTP Response Header Java Kotlin @ControllerAdvice public class CsrfControllerAdvice { @ModelAttribute public void getCsrfToken(HttpServletResponse response, CsrfToken csrfToken) { response.setHeader(csrfToken.getHeaderName(), csrfToken.getToken()); } } @ControllerAdvice class CsrfControllerAdvice { @ModelAttribute fun getCsrfToken(response: HttpServletResponse, csrfToken: CsrfToken) { response.setHeader(csrfToken.headerName, csrfToken.token) } } Because this @ControllerAdvice applies to all endpoints in the application, it will cause the CSRF token to be loaded on every request, which can negate the benefits of deferred tokens(#deferred-csrf-token) when using the HttpSessionCsrfTokenRepository(#csrf-token-repository-httpsession) . However, this is not usually an issue when using the CookieCsrfTokenRepository(#csrf-token-repository-cookie) . It is important to remember that controller endpoints and controller advice are called after the Spring Security filter chain. This means that this @ControllerAdvice will only be applied if the request passes through the filter chain to your application. See the configuration for single-page applications(#csrf-integration-javascript-spa-configuration) for an example of adding a filter to the filter chain for earlier access to the HttpServletResponse . The CSRF token will now be available in a response header ( X-CSRF-TOKEN(#csrf-token-repository-httpsession) or X-XSRF-TOKEN(#csrf-token-repository-cookie) by default) for any custom endpoints the controller advice applies to. Any request to the backend can be used to obtain the token from the response, and a subsequent request can include the token in a request header with the same name. Mobile Applications: Like JavaScript applications(#csrf-integration-javascript) , mobile applications typically use JSON instead of HTML. A backend application that does not serve browser traffic may choose to disable CSRF(#disable-csrf) . In that case, no additional work is required. However, a backend application that also serves browser traffic and therefore still requires CSRF protection may continue to store the CsrfToken in the session(#csrf-token-repository-httpsession) instead of in a cookie(#csrf-token-repository-cookie) . In this case, a typical pattern for integrating with the backend is to expose a /csrf endpoint to allow the frontend (mobile or browser client) to request a CSRF token on demand. The benefit of using this pattern is that the CSRF token can continue to be deferred(#deferred-csrf-token) and only needs to be loaded from the session when a request requires CSRF protection. The use of a custom endpoint also means the client application can request that a new token be generated on demand (if necessary) by issuing an explicit request. This pattern can be used for any type of application that requires CSRF protection, not just mobile applications. While this approach isn’t typically required in those cases, it is another option for integrating with a CSRF-protected backend. The following is an example of the /csrf endpoint that makes use of the CsrfTokenArgumentResolver(../integrations/mvc.html#mvc-csrf-resolver) : The /csrf endpoint Java Kotlin @RestController public class CsrfController { @GetMapping(""/csrf"") public CsrfToken csrf(CsrfToken csrfToken) { return csrfToken; } } @RestController class CsrfController { @GetMapping(""/csrf"") fun csrf(csrfToken: CsrfToken): CsrfToken { return csrfToken } } You may consider adding .requestMatchers(""/csrf"").permitAll() if the endpoint above is required prior to authenticating with the server. This endpoint should be called to obtain a CSRF token when the application is launched or initialized (e.g. at load time), and also after authentication success and logout success. Refreshing the token after authentication success and logout success is required because the CsrfAuthenticationStrategy(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/csrf/CsrfAuthenticationStrategy.html) and CsrfLogoutHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/csrf/CsrfLogoutHandler.html) will clear the previous token. The client application will not be able to perform an unsafe HTTP request, such as a POST, without obtaining a fresh token. Once you’ve obtained the CSRF token, you will need to include it as an HTTP request header (one of X-CSRF-TOKEN(#csrf-token-repository-httpsession) or X-XSRF-TOKEN(#csrf-token-repository-cookie) by default) yourself. Handle AccessDeniedException: To handle an AccessDeniedException such as InvalidCsrfTokenException , you can configure Spring Security to handle these exceptions in any way you like. For example, you can configure a custom access denied page using the following configuration: Configure AccessDeniedHandler Java Kotlin XML @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .exceptionHandling((exceptionHandling) -> exceptionHandling .accessDeniedPage(""/access-denied"") ); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... exceptionHandling { accessDeniedPage = ""/access-denied"" } } return http.build() } } <http> <!-- ... --> <access-denied-handler error-page=""/access-denied""/> </http> CSRF Testing: You can use Spring Security’s testing support(../test/mockmvc/setup.html) and CsrfRequestPostProcessor(../test/mockmvc/csrf.html) to test CSRF protection, like this: Test CSRF Protection Java Kotlin import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*; import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @ExtendWith(SpringExtension.class) @ContextConfiguration(classes = SecurityConfig.class) @WebAppConfiguration public class CsrfTests { private MockMvc mockMvc; @BeforeEach public void setUp(WebApplicationContext applicationContext) { this.mockMvc = MockMvcBuilders.webAppContextSetup(applicationContext) .apply(springSecurity()) .build(); } @Test public void loginWhenValidCsrfTokenThenSuccess() throws Exception { this.mockMvc.perform(post(""/login"").with(csrf()) .accept(MediaType.TEXT_HTML) .param(""username"", ""user"") .param(""password"", ""password"")) .andExpect(status().is3xxRedirection()) .andExpect(header().string(HttpHeaders.LOCATION, ""/"")); } @Test public void loginWhenInvalidCsrfTokenThenForbidden() throws Exception { this.mockMvc.perform(post(""/login"").with(csrf().useInvalidToken()) .accept(MediaType.TEXT_HTML) .param(""username"", ""user"") .param(""password"", ""password"")) .andExpect(status().isForbidden()); } @Test public void loginWhenMissingCsrfTokenThenForbidden() throws Exception { this.mockMvc.perform(post(""/login"") .accept(MediaType.TEXT_HTML) .param(""username"", ""user"") .param(""password"", ""password"")) .andExpect(status().isForbidden()); } @Test @WithMockUser public void logoutWhenValidCsrfTokenThenSuccess() throws Exception { this.mockMvc.perform(post(""/logout"").with(csrf()) .accept(MediaType.TEXT_HTML)) .andExpect(status().is3xxRedirection()) .andExpect(header().string(HttpHeaders.LOCATION, ""/login?logout"")); } } import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.* import org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.* import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.* import org.springframework.test.web.servlet.result.MockMvcResultMatchers.* @ExtendWith(SpringExtension::class) @ContextConfiguration(classes = [SecurityConfig::class]) @WebAppConfiguration class CsrfTests { private lateinit var mockMvc: MockMvc @BeforeEach fun setUp(applicationContext: WebApplicationContext) { mockMvc = MockMvcBuilders.webAppContextSetup(applicationContext) .apply<DefaultMockMvcBuilder>(springSecurity()) .build() } @Test fun loginWhenValidCsrfTokenThenSuccess() { mockMvc.perform(post(""/login"").with(csrf()) .accept(MediaType.TEXT_HTML) .param(""username"", ""user"") .param(""password"", ""password"")) .andExpect(status().is3xxRedirection) .andExpect(header().string(HttpHeaders.LOCATION, ""/"")) } @Test fun loginWhenInvalidCsrfTokenThenForbidden() { mockMvc.perform(post(""/login"").with(csrf().useInvalidToken()) .accept(MediaType.TEXT_HTML) .param(""username"", ""user"") .param(""password"", ""password"")) .andExpect(status().isForbidden) } @Test fun loginWhenMissingCsrfTokenThenForbidden() { mockMvc.perform(post(""/login"") .accept(MediaType.TEXT_HTML) .param(""username"", ""user"") .param(""password"", ""password"")) .andExpect(status().isForbidden) } @Test @WithMockUser @Throws(Exception::class) fun logoutWhenValidCsrfTokenThenSuccess() { mockMvc.perform(post(""/logout"").with(csrf()) .accept(MediaType.TEXT_HTML)) .andExpect(status().is3xxRedirection) .andExpect(header().string(HttpHeaders.LOCATION, ""/login?logout"")) } } Disable CSRF Protection: By default, CSRF protection is enabled, which affects integrating with the backend(#csrf-integration) and testing(#csrf-testing) your application. Before disabling CSRF protection, consider whether it makes sense for your application(../../features/exploits/csrf.html#csrf-when) . You can also consider whether only certain endpoints do not require CSRF protection and configure an ignoring rule, as in the following example: Ignoring Requests Java Kotlin XML @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .csrf((csrf) -> csrf .ignoringRequestMatchers(""/api/*"") ); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... csrf { ignoringRequestMatchers(""/api/*"") } } return http.build() } } <http> <!-- ... --> <csrf request-matcher-ref=""csrfMatcher""/> </http> <b:bean id=""csrfMatcher"" class=""org.springframework.security.web.util.matcher.AndRequestMatcher""> <b:constructor-arg value=""#{T(org.springframework.security.web.csrf.CsrfFilter).DEFAULT_CSRF_MATCHER}""/> <b:constructor-arg> <b:bean class=""org.springframework.security.web.util.matcher.NegatedRequestMatcher""> <b:bean class=""org.springframework.security.web.util.matcher.AntPathRequestMatcher""> <b:constructor-arg value=""/api/*""/> </b:bean> </b:bean> </b:constructor-arg> </b:bean> If you need to disable CSRF protection, you can do so using the following configuration: Disable CSRF Java Kotlin XML @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .csrf((csrf) -> csrf.disable()); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... csrf { disable() } } return http.build() } } <http> <!-- ... --> <csrf disabled=""true""/> </http> CSRF Considerations: There are a few special considerations when implementing protection against CSRF attacks. This section discusses those considerations as they pertain to servlet environments. See CSRF Considerations(../../features/exploits/csrf.html#csrf-considerations) for a more general discussion. Logging In: It is important to require CSRF for log in(../../features/exploits/csrf.html#csrf-considerations-login) requests to protect against forging log in attempts. Spring Security’s servlet support does this out of the box. Logging Out: It is important to require CSRF for log out(../../features/exploits/csrf.html#csrf-considerations-logout) requests to protect against forging logout attempts. If CSRF protection is enabled (the default), Spring Security’s LogoutFilter will only process HTTP POST requests. This ensures that logging out requires a CSRF token and that a malicious user cannot forcibly log your users out. The easiest approach is to use a form to log the user out. If you really want a link, you can use JavaScript to have the link perform a POST (maybe on a hidden form). For browsers with JavaScript that is disabled, you can optionally have the link take the user to a log out confirmation page that performs the POST. If you really want to use HTTP GET with logout, you can do so. However, remember that this is generally not recommended. For example, the following logs out when the /logout URL is requested with any HTTP method: Log Out with Any HTTP Method Java Kotlin @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http // ... .logout((logout) -> logout .logoutRequestMatcher(new AntPathRequestMatcher(""/logout"")) ); return http.build(); } } import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { // ... logout { logoutRequestMatcher = AntPathRequestMatcher(""/logout"") } } return http.build() } } See the Logout(../authentication/logout.html) chapter for more information. CSRF and Session Timeouts: By default, Spring Security stores the CSRF token in the HttpSession using the HttpSessionCsrfTokenRepository(#csrf-token-repository-httpsession) . This can lead to a situation where the session expires, leaving no CSRF token to validate against. We have already discussed general solutions(../../features/exploits/csrf.html#csrf-considerations-timeouts) to session timeouts. This section discusses the specifics of CSRF timeouts as it pertains to the servlet support. You can change the storage of the CSRF token to be in a cookie. For details, see the Using the CookieCsrfTokenRepository(#csrf-token-repository-cookie) section. If a token does expire, you might want to customize how it is handled by specifying a custom AccessDeniedHandler(#csrf-access-denied-handler) . The custom AccessDeniedHandler can process the InvalidCsrfTokenException any way you like. Multipart (file upload): We have already discussed(../../features/exploits/csrf.html#csrf-considerations-multipart) how protecting multipart requests (file uploads) from CSRF attacks causes a chicken and the egg(https://en.wikipedia.org/wiki/Chicken_or_the_egg) problem. When JavaScript is available, we recommend including the CSRF token in an HTTP request header(#csrf-integration-javascript-other) to side-step the issue. If JavaScript is not available, the following sections discuss options for placing the CSRF token in the body(#csrf-considerations-multipart-body) and url(#csrf-considerations-multipart-url) within a servlet application. You can find more information about using multipart forms with Spring in the Multipart Resolver(https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart) section of the Spring reference and the MultipartFilter javadoc(https://docs.spring.io/spring-framework/docs/6.1.12/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html) . Place CSRF Token in the Body: We have already discussed(../../features/exploits/csrf.html#csrf-considerations-multipart-body) the tradeoffs of placing the CSRF token in the body. In this section, we discuss how to configure Spring Security to read the CSRF from the body. To read the CSRF token from the body, the MultipartFilter is specified before the Spring Security filter. Specifying the MultipartFilter before the Spring Security filter means that there is no authorization for invoking the MultipartFilter , which means anyone can place temporary files on your server. However, only authorized users can submit a file that is processed by your application. In general, this is the recommended approach because the temporary file upload should have a negligible impact on most servers. Configure MultipartFilter Java Kotlin XML public class SecurityApplicationInitializer extends AbstractSecurityWebApplicationInitializer { @Override protected void beforeSpringSecurityFilterChain(ServletContext servletContext) { insertFilters(servletContext, new MultipartFilter()); } } class SecurityApplicationInitializer : AbstractSecurityWebApplicationInitializer() { override fun beforeSpringSecurityFilterChain(servletContext: ServletContext?) { insertFilters(servletContext, MultipartFilter()) } } <filter> <filter-name>MultipartFilter</filter-name> <filter-class>org.springframework.web.multipart.support.MultipartFilter</filter-class> </filter> <filter> <filter-name>springSecurityFilterChain</filter-name> <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class> </filter> <filter-mapping> <filter-name>MultipartFilter</filter-name> <url-pattern>/*</url-pattern> </filter-mapping> <filter-mapping> <filter-name>springSecurityFilterChain</filter-name> <url-pattern>/*</url-pattern> </filter-mapping> To ensure that MultipartFilter is specified before the Spring Security filter with XML configuration, you can ensure the <filter-mapping> element of the MultipartFilter is placed before the springSecurityFilterChain within the web.xml file. Include a CSRF Token in a URL: If letting unauthorized users upload temporary files is not acceptable, an alternative is to place the MultipartFilter after the Spring Security filter and include the CSRF as a query parameter in the action attribute of the form. Since the CsrfToken is exposed as an HttpServletRequest attribute named _csrf(#csrf-token-request-handler) , we can use that to create an action with the CSRF token in it. The following example does this with a JSP: CSRF Token in Action <form method=""post"" action=""./upload?${_csrf.parameterName}=${_csrf.token}"" enctype=""multipart/form-data""> HiddenHttpMethodFilter: We have already discussed(../../features/exploits/csrf.html#csrf-considerations-multipart-body) the trade-offs of placing the CSRF token in the body. In Spring’s Servlet support, overriding the HTTP method is done by using HiddenHttpMethodFilter(https://docs.spring.io/spring-framework/docs/6.1.12/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html) . You can find more information in the HTTP Method Conversion(https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-rest-method-conversion) section of the reference documentation. Further Reading: Now that you have reviewed CSRF protection, consider learning more about exploit protection(index.html) including secure headers(headers.html) and the HTTP firewall(firewall.html) or move on to learning how to test(../test/index.html) your application."
"https://docs.spring.io/spring-security/reference/6.3/servlet/exploits/headers.html","Security HTTP Response Headers: You can use Security HTTP Response Headers(../../features/exploits/headers.html#headers) to increase the security of web applications. This section is dedicated to servlet-based support for Security HTTP Response Headers. Default Security Headers: Spring Security provides a default set of Security HTTP Response Headers(../../features/exploits/headers.html#headers-default) to provide secure defaults. While each of these headers are considered best practice, it should be noted that not all clients use the headers, so additional testing is encouraged. You can customize specific headers. For example, assume that you want the defaults but you wish to specify SAMEORIGIN for X-Frame-Options(#servlet-headers-frame-options) . You can do so with the following configuration: Customize Default Security Headers Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .frameOptions(frameOptions -> frameOptions .sameOrigin() ) ); return http.build(); } } <http> <!-- ... --> <headers> <frame-options policy=""SAMEORIGIN"" /> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... headers { frameOptions { sameOrigin = true } } } return http.build() } } If you do not want the defaults to be added and want explicit control over what should be used, you can disable the defaults. The next code listing shows how to do so. If you use Spring Security’s configuration, the following adds only Cache Control(../../features/exploits/headers.html#headers-cache-control) : Customize Cache Control Headers Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers // do not use any default headers unless explicitly listed .defaultsDisabled() .cacheControl(withDefaults()) ); return http.build(); } } <http> <!-- ... --> <headers defaults-disabled=""true""> <cache-control/> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... headers { // do not use any default headers unless explicitly listed defaultsDisabled = true cacheControl { } } } return http.build() } } If necessary, you can disable all of the HTTP Security response headers with the following configuration: Disable All HTTP Security Headers Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers.disable()); return http.build(); } } <http> <!-- ... --> <headers disabled=""true"" /> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... headers { disable() } } return http.build() } } Cache Control: Spring Security includes Cache Control(../../features/exploits/headers.html#headers-cache-control) headers by default. However, if you actually want to cache specific responses, your application can selectively invoke HttpServletResponse.setHeader(String,String)(https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html#setHeader(java.lang.String,java.lang.String)) to override the header set by Spring Security. You can use this to ensure that content (such as CSS, JavaScript, and images) is properly cached. When you use Spring Web MVC, this is typically done within your configuration. You can find details on how to do this in the Static Resources(https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources) portion of the Spring Reference documentation If necessary, you can also disable Spring Security’s cache control HTTP response headers. Cache Control Disabled Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .cacheControl(cache -> cache.disable()) ); return http.build(); } } <http> <!-- ... --> <headers> <cache-control disabled=""true""/> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { headers { cacheControl { disable() } } } return http.build() } } Content Type Options: Spring Security includes Content-Type(../../features/exploits/headers.html#headers-content-type-options) headers by default. However, you can disable it: Content Type Options Disabled Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .contentTypeOptions(contentTypeOptions -> contentTypeOptions.disable()) ); return http.build(); } } <http> <!-- ... --> <headers> <content-type-options disabled=""true""/> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { headers { contentTypeOptions { disable() } } } return http.build() } } HTTP Strict Transport Security (HSTS): By default, Spring Security provides the Strict Transport Security(../../features/exploits/headers.html#headers-hsts) header. However, you can explicitly customize the results. The following example explicitly provides HSTS: Strict Transport Security Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .httpStrictTransportSecurity(hsts -> hsts .includeSubDomains(true) .preload(true) .maxAgeInSeconds(31536000) ) ); return http.build(); } } <http> <!-- ... --> <headers> <hsts include-subdomains=""true"" max-age-seconds=""31536000"" preload=""true"" /> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { headers { httpStrictTransportSecurity { includeSubDomains = true preload = true maxAgeInSeconds = 31536000 } } } return http.build() } } HTTP Public Key Pinning (HPKP): Spring Security provides servlet support for HTTP Public Key Pinning(../../features/exploits/headers.html#headers-hpkp) , but it is no longer recommended(../../features/exploits/headers.html#headers-hpkp-deprecated) . You can enable HPKP headers with the following configuration: HTTP Public Key Pinning Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .httpPublicKeyPinning(hpkp -> hpkp .includeSubDomains(true) .reportUri(""https://example.net/pkp-report"") .addSha256Pins(""d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM="", ""E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g="") ) ); return http.build(); } } <http> <!-- ... --> <headers> <hpkp include-subdomains=""true"" report-uri=""https://example.net/pkp-report""> <pins> <pin algorithm=""sha256"">d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=</pin> <pin algorithm=""sha256"">E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=</pin> </pins> </hpkp> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { headers { httpPublicKeyPinning { includeSubDomains = true reportUri = ""https://example.net/pkp-report"" pins = mapOf(""d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM="" to ""sha256"", ""E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g="" to ""sha256"") } } } return http.build() } } X-Frame-Options: By default, Spring Security instructs browsers to block reflected XSS attacks by using the X-Frame-Options(../../features/exploits/headers.html#headers-frame-options) . For example, the following configuration specifies that Spring Security should no longer instruct browsers to block the content: X-Frame-Options: SAMEORIGIN Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .frameOptions(frameOptions -> frameOptions .sameOrigin() ) ); return http.build(); } } <http> <!-- ... --> <headers> <frame-options policy=""SAMEORIGIN"" /> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { headers { frameOptions { sameOrigin = true } } } return http.build() } } X-XSS-Protection: By default, Spring Security instructs browsers to disable the XSS Auditor by using <<headers-xss-protection,X-XSS-Protection header>. However, you can change this default. For example, the following configuration specifies that Spring Security instruct compatible browsers to enable filtering, and block the content: X-XSS-Protection Customization Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .xssProtection(xss -> xss .headerValue(XXssProtectionHeaderWriter.HeaderValue.ENABLED_MODE_BLOCK) ) ); return http.build(); } } <http> <!-- ... --> <headers> <xss-protection headerValue=""1; mode=block""/> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { // ... http { headers { xssProtection { headerValue = XXssProtectionHeaderWriter.HeaderValue.ENABLED_MODE_BLOCK } } } return http.build() } } Content Security Policy (CSP): Spring Security does not add Content Security Policy(../../features/exploits/headers.html#headers-csp) by default, because a reasonable default is impossible to know without knowing the context of the application. The web application author must declare the security policy (or policies) to enforce or monitor for the protected resources. Consider the following security policy: Content Security Policy Example Content-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/ Given the preceding security policy, you can enable the CSP header: Content Security Policy Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .contentSecurityPolicy(csp -> csp .policyDirectives(""script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"") ) ); return http.build(); } } <http> <!-- ... --> <headers> <content-security-policy policy-directives=""script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"" /> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... headers { contentSecurityPolicy { policyDirectives = ""script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"" } } } return http.build() } } To enable the CSP report-only header, provide the following configuration: Content Security Policy Report Only Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .contentSecurityPolicy(csp -> csp .policyDirectives(""script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"") .reportOnly() ) ); return http.build(); } } <http> <!-- ... --> <headers> <content-security-policy policy-directives=""script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"" report-only=""true"" /> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... headers { contentSecurityPolicy { policyDirectives = ""script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"" reportOnly = true } } } return http.build() } } Referrer Policy: Spring Security does not add Referrer Policy(../../features/exploits/headers.html#headers-referrer) headers by default. You can enable the Referrer Policy header by using the configuration: Referrer Policy Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .referrerPolicy(referrer -> referrer .policy(ReferrerPolicy.SAME_ORIGIN) ) ); return http.build(); } } <http> <!-- ... --> <headers> <referrer-policy policy=""same-origin"" /> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... headers { referrerPolicy { policy = ReferrerPolicy.SAME_ORIGIN } } } return http.build() } } Feature Policy: Spring Security does not add Feature Policy(../../features/exploits/headers.html#headers-feature) headers by default. Consider the following Feature-Policy header: Feature-Policy Example Feature-Policy: geolocation 'self' You can enable the preceding feature policy header by using the following configuration: Feature-Policy Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .featurePolicy(""geolocation 'self'"") ); return http.build(); } } <http> <!-- ... --> <headers> <feature-policy policy-directives=""geolocation 'self'"" /> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... headers { featurePolicy(""geolocation 'self'"") } } return http.build() } } Permissions Policy: Spring Security does not add Permissions Policy(../../features/exploits/headers.html#headers-permissions) headers by default. Consider the following Permissions-Policy header: Permissions-Policy Example Permissions-Policy: geolocation=(self) You can enable the preceding permissions policy header using the following configuration: Permissions-Policy Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .permissionsPolicy(permissions -> permissions .policy(""geolocation=(self)"") ) ); return http.build(); } } <http> <!-- ... --> <headers> <permissions-policy policy=""geolocation=(self)"" /> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... headers { permissionPolicy { policy = ""geolocation=(self)"" } } } return http.build() } } Clear Site Data: Spring Security does not add Clear-Site-Data(../../features/exploits/headers.html#headers-clear-site-data) headers by default. Consider the following Clear-Site-Data header: Clear-Site-Data Example Clear-Site-Data: ""cache"", ""cookies"" You can send the preceding header on log out with the following configuration: Clear-Site-Data Java Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .logout((logout) -> logout .addLogoutHandler(new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(CACHE, COOKIES))) ); return http.build(); } } @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... logout { addLogoutHandler(HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter(CACHE, COOKIES))) } } return http.build() } } Custom Headers: Spring Security has mechanisms to make it convenient to add the more common security headers to your application. However, it also provides hooks to enable adding custom headers. Static Headers: There may be times when you wish to inject custom security headers that are not supported out of the box into your application. Consider the following custom security header: X-Custom-Security-Header: header-value Given the preceding header, you could add the headers to the response by using the following configuration: StaticHeadersWriter Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .addHeaderWriter(new StaticHeadersWriter(""X-Custom-Security-Header"",""header-value"")) ); return http.build(); } } <http> <!-- ... --> <headers> <header name=""X-Custom-Security-Header"" value=""header-value""/> </headers> </http> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... headers { addHeaderWriter(StaticHeadersWriter(""X-Custom-Security-Header"",""header-value"")) } } return http.build() } } Headers Writer: When the namespace or Java configuration does not support the headers you want, you can create a custom HeadersWriter instance or even provide a custom implementation of the HeadersWriter . The next example use a custom instance of XFrameOptionsHeaderWriter . If you wanted to explicitly configure X-Frame-Options(#servlet-headers-frame-options) , you could do so with the following configuration: Headers Writer Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .addHeaderWriter(new XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN)) ); return http.build(); } } <http> <!-- ... --> <headers> <header ref=""frameOptionsWriter""/> </headers> </http> <!-- Requires the c-namespace. See https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-c-namespace --> <beans:bean id=""frameOptionsWriter"" class=""org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"" c:frameOptionsMode=""SAMEORIGIN""/> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... headers { addHeaderWriter(XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN)) } } return http.build() } } DelegatingRequestMatcherHeaderWriter: At times, you may want to write a header only for certain requests. For example, perhaps you want to protect only your login page from being framed. You could use the DelegatingRequestMatcherHeaderWriter to do so. The following configuration example uses DelegatingRequestMatcherHeaderWriter : DelegatingRequestMatcherHeaderWriter Java Configuration Java XML Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { RequestMatcher matcher = new AntPathRequestMatcher(""/login""); DelegatingRequestMatcherHeaderWriter headerWriter = new DelegatingRequestMatcherHeaderWriter(matcher,new XFrameOptionsHeaderWriter()); http // ... .headers(headers -> headers .frameOptions(frameOptions -> frameOptions.disable()) .addHeaderWriter(headerWriter) ); return http.build(); } } <http> <!-- ... --> <headers> <frame-options disabled=""true""/> <header ref=""headerWriter""/> </headers> </http> <beans:bean id=""headerWriter"" class=""org.springframework.security.web.header.writers.DelegatingRequestMatcherHeaderWriter""> <beans:constructor-arg> <bean class=""org.springframework.security.web.util.matcher.AntPathRequestMatcher"" c:pattern=""/login""/> </beans:constructor-arg> <beans:constructor-arg> <beans:bean class=""org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter""/> </beans:constructor-arg> </beans:bean> @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { val matcher: RequestMatcher = AntPathRequestMatcher(""/login"") val headerWriter = DelegatingRequestMatcherHeaderWriter(matcher, XFrameOptionsHeaderWriter()) http { headers { frameOptions { disable() } addHeaderWriter(headerWriter) } } return http.build() } }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/exploits/http.html","HTTP: All HTTP-based communication should be protected using TLS(../../features/exploits/http.html#http) . This section discusses the details of servlet-specific features that assist with HTTPS usage. Redirect to HTTPS: If a client makes a request using HTTP rather than HTTPS, you can configure Spring Security to redirect to HTTPS. For example, the following Java or Kotlin configuration redirects any HTTP requests to HTTPS: Redirect to HTTPS Java Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .requiresChannel(channel -> channel .anyRequest().requiresSecure() ); return http.build(); } } @Configuration @EnableWebSecurity class SecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... requiresChannel { secure(AnyRequestMatcher.INSTANCE, ""REQUIRES_SECURE_CHANNEL"") } } return http.build() } } The following XML configuration redirects all HTTP requests to HTTPS Redirect to HTTPS with XML Configuration <http> <intercept-url pattern=""/**"" access=""ROLE_USER"" requires-channel=""https""/> ... </http> Strict Transport Security: Spring Security provides support for Strict Transport Security(headers.html#servlet-headers-hsts) and enables it by default. Proxy Server Configuration: Spring Security integrates with proxy servers(../../features/exploits/http.html#http-proxy-server) ."
"https://docs.spring.io/spring-security/reference/6.3/servlet/exploits/firewall.html","HttpFirewall: It is important to understand what the mechanism is and what URL value is used when testing against the patterns that you define. The servlet specification defines several properties for the HttpServletRequest that are accessible via getter methods and that we might want to match against. These are the contextPath , servletPath , pathInfo , and queryString . Spring Security is only interested in securing paths within the application, so the contextPath is ignored. Unfortunately, the servlet spec does not define exactly what the values of servletPath and pathInfo contain for a particular request URI. For example, each path segment of a URL may contain parameters, as defined in RFC 2396(https://www.ietf.org/rfc/rfc2396.txt) (You have probably seen this when a browser does not support cookies and the jsessionid parameter is appended to the URL after a semicolon. However, the RFC allows the presence of these parameters in any path segment of the URL.) The Specification does not clearly state whether these should be included in the servletPath and pathInfo values and the behavior varies between different servlet containers. There is a danger that, when an application is deployed in a container that does not strip path parameters from these values, an attacker could add them to the requested URL to cause a pattern match to succeed or fail unexpectedly. (The original values will be returned once the request leaves the FilterChainProxy , so will still be available to the application.) Other variations in the incoming URL are also possible. For example, it could contain path-traversal sequences (such as /../ ) or multiple forward slashes ( // ) that could also cause pattern-matches to fail. Some containers normalize these out before performing the servlet mapping, but others do not. To protect against issues like these, FilterChainProxy uses an HttpFirewall strategy to check and wrap the request. By default, un-normalized requests are automatically rejected, and path parameters and duplicate slashes are removed for matching purposes. (So, for example, an original request path of /secure;hack=1/somefile.html;hack=2 is returned as /secure/somefile.html .) It is, therefore, essential that a FilterChainProxy is used to manage the security filter chain. Note that the servletPath and pathInfo values are decoded by the container, so your application should not have any valid paths that contain semi-colons, as these parts are removed for matching purposes. As mentioned earlier, the default strategy is to use Ant-style paths for matching, and this is likely to be the best choice for most users. The strategy is implemented in the class AntPathRequestMatcher , which uses Spring’s AntPathMatcher to perform a case-insensitive match of the pattern against the concatenated servletPath and pathInfo , ignoring the queryString . If you need a more powerful matching strategy, you can use regular expressions. The strategy implementation is then RegexRequestMatcher . See the Javadoc for this class(https://docs.spring.io/spring-security/site/docs/6.3.3/api//org/springframework/security/web/util/matcher/RegexRequestMatcher.html) for more information. In practice, we recommend that you use method security at your service layer, to control access to your application, rather than rely entirely on the use of security constraints defined at the web-application level. URLs change, and it is difficult to take into account all the possible URLs that an application might support and how requests might be manipulated. You should restrict yourself to using a few simple Ant paths that are simple to understand. Always try to use a “deny-by-default” approach, where you have a catch-all wildcard ( / or ) defined last to deny access. Security defined at the service layer is much more robust and harder to bypass, so you should always take advantage of Spring Security’s method security options. The HttpFirewall also prevents HTTP Response Splitting(https://www.owasp.org/index.php/HTTP_Response_Splitting) by rejecting new line characters in the HTTP Response headers. By default, the StrictHttpFirewall implementation is used. This implementation rejects requests that appear to be malicious. If it is too strict for your needs, you can customize what types of requests are rejected. However, it is important that you do so knowing that this can open your application up to attacks. For example, if you wish to use Spring MVC’s matrix variables, you could use the following configuration: Allow Matrix Variables Java XML Kotlin @Bean public StrictHttpFirewall httpFirewall() { StrictHttpFirewall firewall = new StrictHttpFirewall(); firewall.setAllowSemicolon(true); return firewall; } <b:bean id=""httpFirewall"" class=""org.springframework.security.web.firewall.StrictHttpFirewall"" p:allowSemicolon=""true""/> <http-firewall ref=""httpFirewall""/> @Bean fun httpFirewall(): StrictHttpFirewall { val firewall = StrictHttpFirewall() firewall.setAllowSemicolon(true) return firewall } To protect against Cross Site Tracing (XST)(https://www.owasp.org/index.php/Cross_Site_Tracing) and HTTP Verb Tampering(https://www.owasp.org/index.php/Test_HTTP_Methods_(OTG-CONFIG-006)) , the StrictHttpFirewall provides an allowed list of valid HTTP methods that are allowed. The default valid methods are DELETE , GET , HEAD , OPTIONS , PATCH , POST , and PUT . If your application needs to modify the valid methods, you can configure a custom StrictHttpFirewall bean. The following example allows only HTTP GET and POST methods: Allow Only GET & POST Java XML Kotlin @Bean public StrictHttpFirewall httpFirewall() { StrictHttpFirewall firewall = new StrictHttpFirewall(); firewall.setAllowedHttpMethods(Arrays.asList(""GET"", ""POST"")); return firewall; } <b:bean id=""httpFirewall"" class=""org.springframework.security.web.firewall.StrictHttpFirewall"" p:allowedHttpMethods=""GET,POST""/> <http-firewall ref=""httpFirewall""/> @Bean fun httpFirewall(): StrictHttpFirewall { val firewall = StrictHttpFirewall() firewall.setAllowedHttpMethods(listOf(""GET"", ""POST"")) return firewall } If you use new MockHttpServletRequest() , it currently creates an HTTP method as an empty String ( """" ). This is an invalid HTTP method and is rejected by Spring Security. You can resolve this by replacing it with new MockHttpServletRequest(""GET"", """") . See SPR_16851(https://jira.spring.io/browse/SPR-16851) for an issue that requests improving this. If you must allow any HTTP method (not recommended), you can use StrictHttpFirewall.setUnsafeAllowAnyHttpMethod(true) . Doing so entirely disables validation of the HTTP method. StrictHttpFirewall also checks header names and values and parameter names. It requires that each character have a defined code point and not be a control character. This requirement can be relaxed or adjusted as necessary by using the following methods: StrictHttpFirewall#setAllowedHeaderNames(Predicate) StrictHttpFirewall#setAllowedHeaderValues(Predicate) StrictHttpFirewall#setAllowedParameterNames(Predicate) Parameter values can be also controlled with setAllowedParameterValues(Predicate) . For example, to switch off this check, you can wire your StrictHttpFirewall with Predicate instances that always return true : Allow Any Header Name, Header Value, and Parameter Name Java Kotlin @Bean public StrictHttpFirewall httpFirewall() { StrictHttpFirewall firewall = new StrictHttpFirewall(); firewall.setAllowedHeaderNames((header) -> true); firewall.setAllowedHeaderValues((header) -> true); firewall.setAllowedParameterNames((parameter) -> true); return firewall; } @Bean fun httpFirewall(): StrictHttpFirewall { val firewall = StrictHttpFirewall() firewall.setAllowedHeaderNames { true } firewall.setAllowedHeaderValues { true } firewall.setAllowedParameterNames { true } return firewall } Alternatively, there might be a specific value that you need to allow. For example, iPhone Xʀ uses a User-Agent that includes a character that is not in the ISO-8859-1 charset. Due to this fact, some application servers parse this value into two separate characters, the latter being an undefined character. You can address this with the setAllowedHeaderValues method: Allow Certain User Agents Java Kotlin @Bean public StrictHttpFirewall httpFirewall() { StrictHttpFirewall firewall = new StrictHttpFirewall(); Pattern allowed = Pattern.compile(""[\\p{IsAssigned}&&[^\\p{IsControl}]]*""); Pattern userAgent = ...; firewall.setAllowedHeaderValues((header) -> allowed.matcher(header).matches() || userAgent.matcher(header).matches()); return firewall; } @Bean fun httpFirewall(): StrictHttpFirewall { val firewall = StrictHttpFirewall() val allowed = Pattern.compile(""[\\p{IsAssigned}&&[^\\p{IsControl}]]*"") val userAgent = Pattern.compile(...) firewall.setAllowedHeaderValues { allowed.matcher(it).matches() || userAgent.matcher(it).matches() } return firewall } In the case of header values, you may instead consider parsing them as UTF-8 at verification time: Parse Headers As UTF-8 Java Kotlin firewall.setAllowedHeaderValues((header) -> { String parsed = new String(header.getBytes(ISO_8859_1), UTF_8); return allowed.matcher(parsed).matches(); }); firewall.setAllowedHeaderValues { val parsed = String(header.getBytes(ISO_8859_1), UTF_8) return allowed.matcher(parsed).matches() }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/integrations/index.html","Integrations: Spring Security integrates with numerous frameworks and APIs. This section describes various integrations that Spring Security has with other technologies: Section Summary: Concurrency(concurrency.html) Jackson(jackson.html) Localization(localization.html) Servlet APIs(servlet-api.html) Spring Data(data.html) Spring MVC(mvc.html) WebSocket(websocket.html) Spring’s CORS Support(cors.html) JSP Taglib(jsp-taglibs.html) Observability(observability.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/integrations/concurrency.html","Concurrency Support: In most environments, Security is stored on a per- Thread basis. This means that when work is done on a new Thread , the SecurityContext is lost. Spring Security provides some infrastructure to help make this much easier to manage. Spring Security provides low-level abstractions for working with Spring Security in multi-threaded environments. In fact, this is what Spring Security builds on to integrate with AsyncContext.start(Runnable)(servlet-api.html#servletapi-start-runnable) and Spring MVC Async Integration(mvc.html#mvc-async) . DelegatingSecurityContextRunnable: One of the most fundamental building blocks within Spring Security’s concurrency support is the DelegatingSecurityContextRunnable . It wraps a delegate Runnable to initialize the SecurityContextHolder with a specified SecurityContext for the delegate. It then invokes the delegate Runnable , ensuring to clear the SecurityContextHolder afterwards. The DelegatingSecurityContextRunnable looks something like this: public void run() { try { SecurityContextHolder.setContext(securityContext); delegate.run(); } finally { SecurityContextHolder.clearContext(); } } While very simple, it makes it seamless to transfer the SecurityContext from one Thread to another. This is important since, in most cases, the SecurityContextHolder acts on a per- Thread basis. For example, you might have used Spring Security’s <global-method-security>(../appendix/namespace/method-security.html#nsa-global-method-security) support to secure one of your services. You can now transfer the SecurityContext of the current Thread to the Thread that invokes the secured service. The following example show how you might do so: Runnable originalRunnable = new Runnable() { public void run() { // invoke secured service } }; SecurityContext context = SecurityContextHolder.getContext(); DelegatingSecurityContextRunnable wrappedRunnable = new DelegatingSecurityContextRunnable(originalRunnable, context); new Thread(wrappedRunnable).start(); The preceding code: Creates a Runnable that invokes our secured service. Note that it is not aware of Spring Security. Obtains the SecurityContext that we wish to use from the SecurityContextHolder and initializes the DelegatingSecurityContextRunnable . Uses the DelegatingSecurityContextRunnable to create a Thread . Starts the Thread we created. Since it is common to create a DelegatingSecurityContextRunnable with the SecurityContext from the SecurityContextHolder , there is a shortcut constructor for it. The following code has the same effect as the preceding code: Runnable originalRunnable = new Runnable() { public void run() { // invoke secured service } }; DelegatingSecurityContextRunnable wrappedRunnable = new DelegatingSecurityContextRunnable(originalRunnable); new Thread(wrappedRunnable).start(); The code we have is simple to use, but it still requires knowledge that we are using Spring Security. In the next section we will take a look at how we can utilize DelegatingSecurityContextExecutor to hide the fact that we are using Spring Security. DelegatingSecurityContextExecutor: In the previous section, we found that it was easy to use the DelegatingSecurityContextRunnable , but it was not ideal since we had to be aware of Spring Security to use it. Now we look at how DelegatingSecurityContextExecutor can shield our code from any knowledge that we are using Spring Security. The design of DelegatingSecurityContextExecutor is similar to that of DelegatingSecurityContextRunnable , except that it accepts a delegate Executor instead of a delegate Runnable . The following example shows how to use it: SecurityContext context = SecurityContextHolder.createEmptyContext(); Authentication authentication = UsernamePasswordAuthenticationToken.authenticated(""user"",""doesnotmatter"", AuthorityUtils.createAuthorityList(""ROLE_USER"")); context.setAuthentication(authentication); SimpleAsyncTaskExecutor delegateExecutor = new SimpleAsyncTaskExecutor(); DelegatingSecurityContextExecutor executor = new DelegatingSecurityContextExecutor(delegateExecutor, context); Runnable originalRunnable = new Runnable() { public void run() { // invoke secured service } }; executor.execute(originalRunnable); This code: Note that, in this example, we create the SecurityContext by hand. However, it does not matter where or how we get the SecurityContext (for example, we could obtain it from the SecurityContextHolder ). * Creates a delegateExecutor that is in charge of executing submitted Runnable objects. * Finally, we create a DelegatingSecurityContextExecutor , which is in charge of wrapping any Runnable that is passed into the execute method with a DelegatingSecurityContextRunnable . It then passes the wrapped Runnable to the delegateExecutor . In this case, the same SecurityContext is used for every Runnable submitted to our DelegatingSecurityContextExecutor . This is nice if we run background tasks that need to be run by a user with elevated privileges. * At this point, you may ask yourself, “How does this shield my code of any knowledge of Spring Security?” Instead of creating the SecurityContext and the DelegatingSecurityContextExecutor in our own code, we can inject an already initialized instance of DelegatingSecurityContextExecutor . Consider the following example: @Autowired private Executor executor; // becomes an instance of our DelegatingSecurityContextExecutor public void submitRunnable() { Runnable originalRunnable = new Runnable() { public void run() { // invoke secured service } }; executor.execute(originalRunnable); } Now our code is unaware that the SecurityContext is being propagated to the Thread , the originalRunnable is run, and the SecurityContextHolder is cleared out. In this example, the same user is being used to run each thread. What if we wanted to use the user from SecurityContextHolder (that is, the currently logged in-user) at the time we invoked executor.execute(Runnable) to process originalRunnable ? You can do so by removing the SecurityContext argument from our DelegatingSecurityContextExecutor constructor: SimpleAsyncTaskExecutor delegateExecutor = new SimpleAsyncTaskExecutor(); DelegatingSecurityContextExecutor executor = new DelegatingSecurityContextExecutor(delegateExecutor); Now, any time executor.execute(Runnable) is run, the SecurityContext is first obtained by the SecurityContextHolder and then that SecurityContext is used to create our DelegatingSecurityContextRunnable . This means that we are running our Runnable with the same user that was used to invoke the executor.execute(Runnable) code. Spring Security Concurrency Classes: See the Javadoc(https://docs.spring.io/spring-security/site/docs/6.3.3/api/index.html) for additional integrations with both the Java concurrent APIs and the Spring Task abstractions. They are self-explanatory once you understand the previous code. DelegatingSecurityContextCallable(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/concurrent/DelegatingSecurityContextCallable.html) DelegatingSecurityContextExecutor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/concurrent/DelegatingSecurityContextExecutor.html) DelegatingSecurityContextExecutorService(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/concurrent/DelegatingSecurityContextExecutorService.html) DelegatingSecurityContextRunnable(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/concurrent/DelegatingSecurityContextRunnable.html) DelegatingSecurityContextScheduledExecutorService(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/concurrent/DelegatingSecurityContextScheduledExecutorService.html) DelegatingSecurityContextSchedulingTaskExecutor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/scheduling/DelegatingSecurityContextSchedulingTaskExecutor.html) DelegatingSecurityContextAsyncTaskExecutor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/task/DelegatingSecurityContextAsyncTaskExecutor.html) DelegatingSecurityContextTaskExecutor(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/task/DelegatingSecurityContextTaskExecutor.html) DelegatingSecurityContextTaskScheduler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/scheduling/DelegatingSecurityContextTaskScheduler.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/integrations/jackson.html","Jackson Support: Spring Security provides Jackson support for persisting Spring Security-related classes. This can improve the performance of serializing Spring Security-related classes when working with distributed sessions (session replication, Spring Session, and so on). To use it, register the SecurityJackson2Modules.getModules(ClassLoader) with ObjectMapper ( jackson-databind(https://github.com/FasterXML/jackson-databind) ): ObjectMapper mapper = new ObjectMapper(); ClassLoader loader = getClass().getClassLoader(); List<Module> modules = SecurityJackson2Modules.getModules(loader); mapper.registerModules(modules); // ... use ObjectMapper as normally ... SecurityContext context = new SecurityContextImpl(); // ... String json = mapper.writeValueAsString(context); The following Spring Security modules provide Jackson support: spring-security-core ( CoreJackson2Module(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/jackson2/CoreJackson2Module.html) ) spring-security-web ( WebJackson2Module(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/jackson2/WebJackson2Module.html) , WebServletJackson2Module(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/jackson2/WebServletJackson2Module.html) , WebServerJackson2Module(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/server/jackson2/WebServerJackson2Module.html) ) spring-security-oauth2-client(#oauth2client) ( OAuth2ClientJackson2Module(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/client/jackson2/OAuth2ClientJackson2Module.html) ) spring-security-cas ( CasJackson2Module(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/cas/jackson2/CasJackson2Module.html) )"
"https://docs.spring.io/spring-security/reference/6.3/servlet/integrations/localization.html","Localization: If you need to support other locales, this section contains everything you need to know. All exception messages, including messages related to authentication failures and access being denied (authorization failures), can be localized. Exceptions and logging messages that are focused on developers or system deployers (including incorrect attributes, interface contract violations, using incorrect constructors, startup time validation, debug-level logging) are not localized and instead are hard-coded in English within Spring Security’s code. In the spring-security-core-xx.jar , you find an org.springframework.security package that, in turn, contains a messages.properties file as well as localized versions for some common languages. Your ApplicationContext should refer to this, as Spring Security classes implement Spring’s MessageSourceAware interface and expect the message resolver to be dependency injected at application context startup time. Usually, all you need to do is register a bean inside your application context to refer to the messages. The following listing shows an example: <bean id=""messageSource"" class=""org.springframework.context.support.ReloadableResourceBundleMessageSource""> <property name=""basename"" value=""classpath:org/springframework/security/messages""/> </bean> The messages.properties is named in accordance with standard resource bundles and represents the default language supported by Spring Security messages. This default file is in English. To customize the messages.properties file or support other languages, you should copy the file, rename it accordingly, and register it inside the preceding bean definition. There are not a large number of message keys inside this file, so localization should not be considered a major initiative. If you do perform localization of this file, consider sharing your work with the community by logging a JIRA task and attaching your appropriately-named localized version of messages.properties . Spring Security relies on Spring’s localization support in order to actually look up the appropriate message. For this to work, you have to make sure that the locale from the incoming request is stored in Spring’s org.springframework.context.i18n.LocaleContextHolder . Spring MVC’s DispatcherServlet does this for your application automatically. However, since Spring Security’s filters are invoked before this, the LocaleContextHolder needs to be set up to contain the correct Locale before the filters are called. You can either do this in a filter yourself (which must come before the Spring Security filters in web.xml ) or you can use Spring’s RequestContextFilter . See the Spring Framework documentation for further details on using localization with Spring. The contacts sample application is set up to use localized messages."
"https://docs.spring.io/spring-security/reference/6.3/servlet/integrations/servlet-api.html","Servlet API integration: Servlet 2.5+ Integration: This section describes how Spring Security integrates with the Servlet 2.5 specification. HttpServletRequest.getRemoteUser(): HttpServletRequest.getRemoteUser()(https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()) returns the result of SecurityContextHolder.getContext().getAuthentication().getName() , which is typically the current username.This can be useful if you want to display the current username in your application. Additionally, you can check this for null to determine whether a user has authenticated or is anonymous. Knowing whether the user is authenticated or not can be useful for determining if certain UI elements should be shown or not (for example, a logout link that should be displayed only if the user is authenticated). HttpServletRequest.getUserPrincipal(): HttpServletRequest.getUserPrincipal()(https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()) returns the result of SecurityContextHolder.getContext().getAuthentication() . This means that it is an Authentication , which is typically an instance of UsernamePasswordAuthenticationToken when using username- and password-based authentication. This can be useful if you need additional information about your user. For example, you might have created a custom UserDetailsService that returns a custom UserDetails containing a first and last name for your user. You could obtain this information with the following: Java Kotlin Authentication auth = httpServletRequest.getUserPrincipal(); // assume integrated custom UserDetails called MyCustomUserDetails // by default, typically instance of UserDetails MyCustomUserDetails userDetails = (MyCustomUserDetails) auth.getPrincipal(); String firstName = userDetails.getFirstName(); String lastName = userDetails.getLastName(); val auth: Authentication = httpServletRequest.getUserPrincipal() // assume integrated custom UserDetails called MyCustomUserDetails // by default, typically instance of UserDetails val userDetails: MyCustomUserDetails = auth.principal as MyCustomUserDetails val firstName: String = userDetails.firstName val lastName: String = userDetails.lastName It should be noted that it is typically bad practice to perform so much logic throughout your application. Instead, one should centralize it to reduce any coupling of Spring Security and the Servlet API’s. HttpServletRequest.isUserInRole(String): HttpServletRequest.isUserInRole(String)(https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)) determines if SecurityContextHolder.getContext().getAuthentication().getAuthorities() contains a GrantedAuthority with the role passed into isUserInRole(String) . Typically, users should not pass the ROLE_ prefix to this method, since it is added automatically. For example, if you want to determine if the current user has the authority ""ROLE_ADMIN"", you could use the following: Java Kotlin boolean isAdmin = httpServletRequest.isUserInRole(""ADMIN""); val isAdmin: Boolean = httpServletRequest.isUserInRole(""ADMIN"") This might be useful to determine if certain UI components should be displayed. For example, you might display admin links only if the current user is an admin. Servlet 3+ Integration: The following section describes the Servlet 3 methods with which Spring Security integrates. HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse): You can use the HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)(https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#authenticate%28javax.servlet.http.HttpServletResponse%29) method to ensure that a user is authenticated. If they are not authenticated, the configured AuthenticationEntryPoint is used to request the user to authenticate (redirect to the login page). HttpServletRequest.login(String,String): You can use the HttpServletRequest.login(String,String)(https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login%28java.lang.String,%20java.lang.String%29) method to authenticate the user with the current AuthenticationManager . For example, the following would attempt to authenticate with a username of user and a password of password : Java Kotlin try { httpServletRequest.login(""user"",""password""); } catch(ServletException ex) { // fail to authenticate } try { httpServletRequest.login(""user"", ""password"") } catch (ex: ServletException) { // fail to authenticate } You need not catch the ServletException if you want Spring Security to process the failed authentication attempt. HttpServletRequest.logout(): You can use the HttpServletRequest.logout()(https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout%28%29) method to log out the current user. Typically, this means that the SecurityContextHolder is cleared out, the HttpSession is invalidated, any “Remember Me” authentication is cleaned up, and so on. However, the configured LogoutHandler implementations vary, depending on your Spring Security configuration. Note that, after HttpServletRequest.logout() has been invoked, you are still in charge of writing out a response. Typically, this would involve a redirect to the welcome page. AsyncContext.start(Runnable): The AsyncContext.start(Runnable)(https://docs.oracle.com/javaee/6/api/javax/servlet/AsyncContext.html#start%28java.lang.Runnable%29) method ensures your credentials are propagated to the new Thread . By using Spring Security’s concurrency support, Spring Security overrides AsyncContext.start(Runnable) to ensure that the current SecurityContext is used when processing the Runnable. The following example outputs the current user’s Authentication: Java Kotlin final AsyncContext async = httpServletRequest.startAsync(); async.start(new Runnable() { public void run() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); try { final HttpServletResponse asyncResponse = (HttpServletResponse) async.getResponse(); asyncResponse.setStatus(HttpServletResponse.SC_OK); asyncResponse.getWriter().write(String.valueOf(authentication)); async.complete(); } catch(Exception ex) { throw new RuntimeException(ex); } } }); val async: AsyncContext = httpServletRequest.startAsync() async.start { val authentication: Authentication = SecurityContextHolder.getContext().authentication try { val asyncResponse = async.response as HttpServletResponse asyncResponse.status = HttpServletResponse.SC_OK asyncResponse.writer.write(String.valueOf(authentication)) async.complete() } catch (ex: Exception) { throw RuntimeException(ex) } } Async Servlet Support: If you use Java-based configuration, you are ready to go. If you use XML configuration, a few updates are necessary. The first step is to ensure that you have updated your web.xml file to use at least the 3.0 schema: <web-app xmlns=""http://java.sun.com/xml/ns/javaee"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"" version=""3.0""> </web-app> Next, you need to ensure that your springSecurityFilterChain is set up for processing asynchronous requests: <filter> <filter-name>springSecurityFilterChain</filter-name> <filter-class> org.springframework.web.filter.DelegatingFilterProxy </filter-class> <async-supported>true</async-supported> </filter> <filter-mapping> <filter-name>springSecurityFilterChain</filter-name> <url-pattern>/*</url-pattern> <dispatcher>REQUEST</dispatcher> <dispatcher>ASYNC</dispatcher> </filter-mapping> Now Spring Security ensures that your SecurityContext is propagated on asynchronous requests, too. So how does it work? If you are not really interested, feel free to skip the remainder of this section Most of this is built into the Servlet specification, but there is a little bit of tweaking that Spring Security does to ensure things work properly with asynchronous requests. Prior to Spring Security 3.2, the SecurityContext from the SecurityContextHolder was automatically saved as soon as the HttpServletResponse was committed. This can cause issues in an asynchronous environment. Consider the following example: Java Kotlin httpServletRequest.startAsync(); new Thread(""AsyncThread"") { @Override public void run() { try { // Do work TimeUnit.SECONDS.sleep(1); // Write to and commit the httpServletResponse httpServletResponse.getOutputStream().flush(); } catch (Exception ex) { ex.printStackTrace(); } } }.start(); httpServletRequest.startAsync() object : Thread(""AsyncThread"") { override fun run() { try { // Do work TimeUnit.SECONDS.sleep(1) // Write to and commit the httpServletResponse httpServletResponse.outputStream.flush() } catch (ex: java.lang.Exception) { ex.printStackTrace() } } }.start() The issue is that this Thread is not known to Spring Security, so the SecurityContext is not propagated to it. This means that, when we commit the HttpServletResponse , there is no SecurityContext . When Spring Security automatically saved the SecurityContext on committing the HttpServletResponse , it would lose a logged in user. Since version 3.2, Spring Security is smart enough to no longer automatically save the SecurityContext on committing the HttpServletResponse as soon as HttpServletRequest.startAsync() is invoked. Servlet 3.1+ Integration: The following section describes the Servlet 3.1 methods that Spring Security integrates with. HttpServletRequest#changeSessionId(): HttpServletRequest.changeSessionId()(https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html#changeSessionId()) is the default method for protecting against Session Fixation(../authentication/session-management.html#ns-session-fixation) attacks in Servlet 3.1 and higher."
"https://docs.spring.io/spring-security/reference/6.3/servlet/integrations/data.html","Spring Data Integration: Spring Security provides Spring Data integration that allows referring to the current user within your queries. It is not only useful but necessary to include the user in the queries to support paged results since filtering the results afterwards would not scale. Spring Data & Spring Security Configuration: To use this support, add org.springframework.security:spring-security-data dependency and provide a bean of type SecurityEvaluationContextExtension : Java Kotlin @Bean public SecurityEvaluationContextExtension securityEvaluationContextExtension() { return new SecurityEvaluationContextExtension(); } @Bean fun securityEvaluationContextExtension(): SecurityEvaluationContextExtension { return SecurityEvaluationContextExtension() } In XML Configuration, this would look like: <bean class=""org.springframework.security.data.repository.query.SecurityEvaluationContextExtension""/> Security Expressions within @Query: Now you can use Spring Security within your queries: Java Kotlin @Repository public interface MessageRepository extends PagingAndSortingRepository<Message,Long> { @Query(""select m from Message m where m.to.id = ?#{ principal?.id }"") Page<Message> findInbox(Pageable pageable); } @Repository interface MessageRepository : PagingAndSortingRepository<Message,Long> { @Query(""select m from Message m where m.to.id = ?#{ principal?.id }"") fun findInbox(pageable: Pageable): Page<Message> } This checks to see if the Authentication.getPrincipal().getId() is equal to the recipient of the Message . Note that this example assumes you have customized the principal to be an Object that has an id property. By exposing the SecurityEvaluationContextExtension bean, all of the Common Security Expressions(../authorization/method-security.html#authorization-expressions) are available within the Query."
"https://docs.spring.io/spring-security/reference/6.3/servlet/integrations/mvc.html","Spring MVC Integration: Spring Security provides a number of optional integrations with Spring MVC. This section covers the integration in further detail. @EnableWebMvcSecurity: As of Spring Security 4.0, @EnableWebMvcSecurity is deprecated. The replacement is @EnableWebSecurity , which adds the Spring MVC features, based upon the classpath. To enable Spring Security integration with Spring MVC, add the @EnableWebSecurity annotation to your configuration. Spring Security provides the configuration by using Spring MVC’s WebMvcConfigurer(https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-config-customize) . This means that, if you use more advanced options, such as integrating with WebMvcConfigurationSupport directly, you need to manually provide the Spring Security configuration. MvcRequestMatcher: Spring Security provides deep integration with how Spring MVC matches on URLs with MvcRequestMatcher . This is helpful to ensure that your Security rules match the logic used to handle your requests. To use MvcRequestMatcher , you must place the Spring Security Configuration in the same ApplicationContext as your DispatcherServlet . This is necessary because Spring Security’s MvcRequestMatcher expects a HandlerMappingIntrospector bean with the name of mvcHandlerMappingIntrospector to be registered by your Spring MVC configuration that is used to perform the matching. For a web.xml file, this means that you should place your configuration in the DispatcherServlet.xml : <listener> <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> </listener> <!-- All Spring Configuration (both MVC and Security) are in /WEB-INF/spring/ --> <context-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/spring/*.xml</param-value> </context-param> <servlet> <servlet-name>spring</servlet-name> <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> <!-- Load from the ContextLoaderListener --> <init-param> <param-name>contextConfigLocation</param-name> <param-value></param-value> </init-param> </servlet> <servlet-mapping> <servlet-name>spring</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping> The following WebSecurityConfiguration in placed in the ApplicationContext of the DispatcherServlet . Java Kotlin public class SecurityInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class<?>[] getRootConfigClasses() { return null; } @Override protected Class<?>[] getServletConfigClasses() { return new Class[] { RootConfiguration.class, WebMvcConfiguration.class }; } @Override protected String[] getServletMappings() { return new String[] { ""/"" }; } } class SecurityInitializer : AbstractAnnotationConfigDispatcherServletInitializer() { override fun getRootConfigClasses(): Array<Class<*>>? { return null } override fun getServletConfigClasses(): Array<Class<*>> { return arrayOf( RootConfiguration::class.java, WebMvcConfiguration::class.java ) } override fun getServletMappings(): Array<String> { return arrayOf(""/"") } } We always recommend that you provide authorization rules by matching on the HttpServletRequest and method security. Providing authorization rules by matching on HttpServletRequest is good, because it happens very early in the code path and helps reduce the attack surface(https://en.wikipedia.org/wiki/Attack_surface) . Method security ensures that, if someone has bypassed the web authorization rules, your application is still secured. This is known as Defense in Depth(https://en.wikipedia.org/wiki/Defense_in_depth_(computing)) Consider a controller that is mapped as follows: Java Kotlin @RequestMapping(""/admin"") public String admin() { // ... } @RequestMapping(""/admin"") fun admin(): String { // ... } To restrict access to this controller method to admin users, you can provide authorization rules by matching on the HttpServletRequest with the following: Java Kotlin @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(""/admin"").hasRole(""ADMIN"") ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(""/admin"", hasRole(""ADMIN"")) } } return http.build() } The following listing does the same thing in XML: <http> <intercept-url pattern=""/admin"" access=""hasRole('ADMIN')""/> </http> With either configuration, the /admin URL requires the authenticated user to be an admin user. However, depending on our Spring MVC configuration, the /admin.html URL also maps to our admin() method. Additionally, depending on our Spring MVC configuration, the /admin URL also maps to our admin() method. The problem is that our security rule protects only /admin . We could add additional rules for all the permutations of Spring MVC, but this would be quite verbose and tedious. Fortunately, when using the requestMatchers DSL method, Spring Security automatically creates a MvcRequestMatcher if it detects that Spring MVC is available in the classpath. Therefore, it will protect the same URLs that Spring MVC will match on by using Spring MVC to match on the URL. One common requirement when using Spring MVC is to specify the servlet path property, for that you can use the MvcRequestMatcher.Builder to create multiple MvcRequestMatcher instances that share the same servlet path: Java Kotlin @Bean public SecurityFilterChain filterChain(HttpSecurity http, HandlerMappingIntrospector introspector) throws Exception { MvcRequestMatcher.Builder mvcMatcherBuilder = new MvcRequestMatcher.Builder(introspector).servletPath(""/path""); http .authorizeHttpRequests((authorize) -> authorize .requestMatchers(mvcMatcherBuilder.pattern(""/admin"")).hasRole(""ADMIN"") .requestMatchers(mvcMatcherBuilder.pattern(""/user"")).hasRole(""USER"") ); return http.build(); } @Bean open fun filterChain(http: HttpSecurity, introspector: HandlerMappingIntrospector): SecurityFilterChain { val mvcMatcherBuilder = MvcRequestMatcher.Builder(introspector) http { authorizeHttpRequests { authorize(mvcMatcherBuilder.pattern(""/admin""), hasRole(""ADMIN"")) authorize(mvcMatcherBuilder.pattern(""/user""), hasRole(""USER"")) } } return http.build() } The following XML has the same effect: <http request-matcher=""mvc""> <intercept-url pattern=""/admin"" access=""hasRole('ADMIN')""/> </http> @AuthenticationPrincipal: Spring Security provides AuthenticationPrincipalArgumentResolver , which can automatically resolve the current Authentication.getPrincipal() for Spring MVC arguments. By using @EnableWebSecurity , you automatically have this added to your Spring MVC configuration. If you use XML-based configuration, you must add this yourself: <mvc:annotation-driven> <mvc:argument-resolvers> <bean class=""org.springframework.security.web.method.annotation.AuthenticationPrincipalArgumentResolver"" /> </mvc:argument-resolvers> </mvc:annotation-driven> Once you have properly configured AuthenticationPrincipalArgumentResolver , you can entirely decouple from Spring Security in your Spring MVC layer. Consider a situation where a custom UserDetailsService returns an Object that implements UserDetails and your own CustomUser Object . The CustomUser of the currently authenticated user could be accessed by using the following code: Java Kotlin @RequestMapping(""/messages/inbox"") public ModelAndView findMessagesForUser() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); CustomUser custom = (CustomUser) authentication == null ? null : authentication.getPrincipal(); // .. find messages for this user and return them ... } @RequestMapping(""/messages/inbox"") open fun findMessagesForUser(): ModelAndView { val authentication: Authentication = SecurityContextHolder.getContext().authentication val custom: CustomUser? = if (authentication as CustomUser == null) null else authentication.principal // .. find messages for this user and return them ... } As of Spring Security 3.2, we can resolve the argument more directly by adding an annotation: Java Kotlin import org.springframework.security.core.annotation.AuthenticationPrincipal; // ... @RequestMapping(""/messages/inbox"") public ModelAndView findMessagesForUser(@AuthenticationPrincipal CustomUser customUser) { // .. find messages for this user and return them ... } @RequestMapping(""/messages/inbox"") open fun findMessagesForUser(@AuthenticationPrincipal customUser: CustomUser?): ModelAndView { // .. find messages for this user and return them ... } Sometimes, you may need to transform the principal in some way. For example, if CustomUser needed to be final, it could not be extended. In this situation, the UserDetailsService might return an Object that implements UserDetails and provides a method named getCustomUser to access CustomUser : Java Kotlin public class CustomUserUserDetails extends User { // ... public CustomUser getCustomUser() { return customUser; } } class CustomUserUserDetails( username: String?, password: String?, authorities: MutableCollection<out GrantedAuthority>? ) : User(username, password, authorities) { // ... val customUser: CustomUser? = null } We could then access the CustomUser by using a SpEL expression(https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html) that uses Authentication.getPrincipal() as the root object: Java Kotlin import org.springframework.security.core.annotation.AuthenticationPrincipal; // ... @RequestMapping(""/messages/inbox"") public ModelAndView findMessagesForUser(@AuthenticationPrincipal(expression = ""customUser"") CustomUser customUser) { // .. find messages for this user and return them ... } import org.springframework.security.core.annotation.AuthenticationPrincipal // ... @RequestMapping(""/messages/inbox"") open fun findMessagesForUser(@AuthenticationPrincipal(expression = ""customUser"") customUser: CustomUser?): ModelAndView { // .. find messages for this user and return them ... } We can also refer to beans in our SpEL expressions. For example, we could use the following if we were using JPA to manage our users and if we wanted to modify and save a property on the current user: Java Kotlin import org.springframework.security.core.annotation.AuthenticationPrincipal; // ... @PutMapping(""/users/self"") public ModelAndView updateName(@AuthenticationPrincipal(expression = ""@jpaEntityManager.merge(#this)"") CustomUser attachedCustomUser, @RequestParam String firstName) { // change the firstName on an attached instance which will be persisted to the database attachedCustomUser.setFirstName(firstName); // ... } import org.springframework.security.core.annotation.AuthenticationPrincipal // ... @PutMapping(""/users/self"") open fun updateName( @AuthenticationPrincipal(expression = ""@jpaEntityManager.merge(#this)"") attachedCustomUser: CustomUser, @RequestParam firstName: String? ): ModelAndView { // change the firstName on an attached instance which will be persisted to the database attachedCustomUser.setFirstName(firstName) // ... } We can further remove our dependency on Spring Security by making @AuthenticationPrincipal a meta-annotation on our own annotation. The next example demonstrates how we could do so on an annotation named @CurrentUser . To remove the dependency on Spring Security, it is the consuming application that would create @CurrentUser . This step is not strictly required but assists in isolating your dependency to Spring Security to a more central location. Java Kotlin @Target({ElementType.PARAMETER, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @AuthenticationPrincipal public @interface CurrentUser {} @Target(AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.TYPE) @Retention(AnnotationRetention.RUNTIME) @MustBeDocumented @AuthenticationPrincipal annotation class CurrentUser We have isolated our dependency on Spring Security to a single file. Now that @CurrentUser has been specified, we can use it to signal to resolve our CustomUser of the currently authenticated user: Java Kotlin @RequestMapping(""/messages/inbox"") public ModelAndView findMessagesForUser(@CurrentUser CustomUser customUser) { // .. find messages for this user and return them ... } @RequestMapping(""/messages/inbox"") open fun findMessagesForUser(@CurrentUser customUser: CustomUser?): ModelAndView { // .. find messages for this user and return them ... } Spring MVC Async Integration: Spring Web MVC 3.2+ has excellent support for Asynchronous Request Processing(https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-ann-async) . With no additional configuration, Spring Security automatically sets up the SecurityContext to the Thread that invokes a Callable returned by your controllers. For example, the following method automatically has its Callable invoked with the SecurityContext that was available when the Callable was created: Java Kotlin @RequestMapping(method=RequestMethod.POST) public Callable<String> processUpload(final MultipartFile file) { return new Callable<String>() { public Object call() throws Exception { // ... return ""someView""; } }; } @RequestMapping(method = [RequestMethod.POST]) open fun processUpload(file: MultipartFile?): Callable<String> { return Callable { // ... ""someView"" } } Associating SecurityContext to Callable’s More technically speaking, Spring Security integrates with WebAsyncManager . The SecurityContext that is used to process the Callable is the SecurityContext that exists on the SecurityContextHolder when startCallableProcessing is invoked. There is no automatic integration with a DeferredResult that is returned by controllers. This is because DeferredResult is processed by the users and, thus, there is no way of automatically integrating with it. However, you can still use Concurrency Support(../../features/integrations/concurrency.html#concurrency) to provide transparent integration with Spring Security. Spring MVC and CSRF Integration: Spring Security integrates with Spring MVC to add CSRF protection. Automatic Token Inclusion: Spring Security automatically include the CSRF Token(../exploits/csrf.html#csrf-integration-form) within forms that use the Spring MVC form tag(https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/view.html#view-jsp-formtaglib-formtag) . Consider the following JSP: <jsp:root xmlns:jsp=""http://java.sun.com/JSP/Page"" xmlns:c=""http://java.sun.com/jsp/jstl/core"" xmlns:form=""http://www.springframework.org/tags/form"" version=""2.0""> <jsp:directive.page language=""java"" contentType=""text/html"" /> <html xmlns=""http://www.w3.org/1999/xhtml"" lang=""en"" xml:lang=""en""> <!-- ... --> <c:url var=""logoutUrl"" value=""/logout""/> <form:form action=""${logoutUrl}"" method=""post""> <input type=""submit"" value=""Log out"" /> <input type=""hidden"" name=""${_csrf.parameterName}"" value=""${_csrf.token}""/> </form:form> <!-- ... --> </html> </jsp:root> The preceding example output HTMLs that is similar to the following: <!-- ... --> <form action=""/context/logout"" method=""post""> <input type=""submit"" value=""Log out""/> <input type=""hidden"" name=""_csrf"" value=""f81d4fae-7dec-11d0-a765-00a0c91e6bf6""/> </form> <!-- ... --> Resolving the CsrfToken: Spring Security provides CsrfTokenArgumentResolver , which can automatically resolve the current CsrfToken for Spring MVC arguments. By using @EnableWebSecurity(../configuration/java.html#jc-hello-wsca) , you automatically have this added to your Spring MVC configuration. If you use XML-based configuration, you must add this yourself. Once CsrfTokenArgumentResolver is properly configured, you can expose the CsrfToken to your static HTML based application: Java Kotlin @RestController public class CsrfController { @RequestMapping(""/csrf"") public CsrfToken csrf(CsrfToken token) { return token; } } @RestController class CsrfController { @RequestMapping(""/csrf"") fun csrf(token: CsrfToken): CsrfToken { return token } } It is important to keep the CsrfToken a secret from other domains. This means that, if you use Cross Origin Sharing (CORS)(https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) , you should NOT expose the CsrfToken to any external domains."
"https://docs.spring.io/spring-security/reference/6.3/servlet/integrations/websocket.html","WebSocket Security: Spring Security 4 added support for securing Spring’s WebSocket support(https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html) . This section describes how to use Spring Security’s WebSocket support. Direct JSR-356 Support Spring Security does not provide direct JSR-356 support, because doing so would provide little value. This is because the format is unknown, and there is little Spring can do to secure an unknown format(https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-intro-sub-protocol) . Additionally, JSR-356 does not provide a way to intercept messages, so security would be invasive. WebSocket Authentication: WebSockets reuse the same authentication information that is found in the HTTP request when the WebSocket connection was made. This means that the Principal on the HttpServletRequest will be handed off to WebSockets. If you are using Spring Security, the Principal on the HttpServletRequest is overridden automatically. More concretely, to ensure a user has authenticated to your WebSocket application, all that is necessary is to ensure that you setup Spring Security to authenticate your HTTP based web application. WebSocket Authorization: Spring Security 4.0 has introduced authorization support for WebSockets through the Spring Messaging abstraction. In Spring Security 5.8, this support has been refreshed to use the AuthorizationManager API. To configure authorization using Java Configuration, simply include the @EnableWebSocketSecurity annotation and publish an AuthorizationManager<Message<?>> bean or in XML(../appendix/namespace/websocket.html#nsa-websocket-security) use the use-authorization-manager attribute. One way to do this is by using the AuthorizationManagerMessageMatcherRegistry to specify endpoint patterns like so: Java Kotlin Xml @Configuration @EnableWebSocketSecurity (1) (2) public class WebSocketSecurityConfig { @Bean AuthorizationManager<Message<?>> messageAuthorizationManager(MessageMatcherDelegatingAuthorizationManager.Builder messages) { messages .simpDestMatchers(""/user/**"").hasRole(""USER"") (3) return messages.build(); } } @Configuration @EnableWebSocketSecurity (1) (2) open class WebSocketSecurityConfig { (1) (2) @Bean fun messageAuthorizationManager(messages: MessageMatcherDelegatingAuthorizationManager.Builder): AuthorizationManager<Message<*>> { messages.simpDestMatchers(""/user/**"").hasRole(""USER"") (3) return messages.build() } } <websocket-message-broker use-authorization-manager=""true""> (1) (2) <intercept-message pattern=""/user/**"" access=""hasRole('USER')""/> (3) </websocket-message-broker> 1 Any inbound CONNECT message requires a valid CSRF token to enforce the Same Origin Policy(#websocket-sameorigin) . 2 The SecurityContextHolder is populated with the user within the simpUser header attribute for any inbound request. 3 Our messages require the proper authorization. Specifically, any inbound message that starts with /user/ will require ROLE_USER . You can find additional details on authorization in WebSocket Authorization(#websocket-authorization) Custom Authorization: When using AuthorizationManager , customization is quite simple. For example, you can publish an AuthorizationManager that requires that all messages have a role of ""USER"" using AuthorityAuthorizationManager , as seen below: Java Kotlin Xml @Configuration @EnableWebSocketSecurity (1) (2) public class WebSocketSecurityConfig { @Bean AuthorizationManager<Message<?>> messageAuthorizationManager(MessageMatcherDelegatingAuthorizationManager.Builder messages) { return AuthorityAuthorizationManager.hasRole(""USER""); } } @Configuration @EnableWebSocketSecurity (1) (2) open class WebSocketSecurityConfig { @Bean fun messageAuthorizationManager(messages: MessageMatcherDelegatingAuthorizationManager.Builder): AuthorizationManager<Message<*>> { return AuthorityAuthorizationManager.hasRole(""USER"") (3) } } <bean id=""authorizationManager"" class=""org.example.MyAuthorizationManager""/> <websocket-message-broker authorization-manager-ref=""myAuthorizationManager""/> There are several ways to further match messages, as can be seen in a more advanced example below: Java Kotlin Xml @Configuration public class WebSocketSecurityConfig { @Bean public AuthorizationManager<Message<?>> messageAuthorizationManager(MessageMatcherDelegatingAuthorizationManager.Builder messages) { messages .nullDestMatcher().authenticated() (1) .simpSubscribeDestMatchers(""/user/queue/errors"").permitAll() (2) .simpDestMatchers(""/app/**"").hasRole(""USER"") (3) .simpSubscribeDestMatchers(""/user/**"", ""/topic/friends/*"").hasRole(""USER"") (4) .simpTypeMatchers(MESSAGE, SUBSCRIBE).denyAll() (5) .anyMessage().denyAll(); (6) return messages.build(); } } @Configuration open class WebSocketSecurityConfig { fun messageAuthorizationManager(messages: MessageMatcherDelegatingAuthorizationManager.Builder): AuthorizationManager<Message<*>> { messages .nullDestMatcher().authenticated() (1) .simpSubscribeDestMatchers(""/user/queue/errors"").permitAll() (2) .simpDestMatchers(""/app/**"").hasRole(""USER"") (3) .simpSubscribeDestMatchers(""/user/**"", ""/topic/friends/*"").hasRole(""USER"") (4) .simpTypeMatchers(MESSAGE, SUBSCRIBE).denyAll() (5) .anyMessage().denyAll() (6) return messages.build(); } } <websocket-message-broker use-authorization-manager=""true""> (1) <intercept-message type=""CONNECT"" access=""permitAll"" /> <intercept-message type=""UNSUBSCRIBE"" access=""permitAll"" /> <intercept-message type=""DISCONNECT"" access=""permitAll"" /> <intercept-message pattern=""/user/queue/errors"" type=""SUBSCRIBE"" access=""permitAll"" /> (2) <intercept-message pattern=""/app/**"" access=""hasRole('USER')"" /> (3) (4) <intercept-message pattern=""/user/**"" type=""SUBSCRIBE"" access=""hasRole('USER')"" /> <intercept-message pattern=""/topic/friends/*"" type=""SUBSCRIBE"" access=""hasRole('USER')"" /> (5) <intercept-message type=""MESSAGE"" access=""denyAll"" /> <intercept-message type=""SUBSCRIBE"" access=""denyAll"" /> <intercept-message pattern=""/**"" access=""denyAll"" /> (6) </websocket-message-broker> This will ensure that: 1 Any message without a destination (i.e. anything other than Message type of MESSAGE or SUBSCRIBE) will require the user to be authenticated 2 Anyone can subscribe to /user/queue/errors 3 Any message that has a destination starting with ""/app/"" will be require the user to have the role ROLE_USER 4 Any message that starts with ""/user/"" or ""/topic/friends/"" that is of type SUBSCRIBE will require ROLE_USER 5 Any other message of type MESSAGE or SUBSCRIBE is rejected. Due to 6 we do not need this step, but it illustrates how one can match on specific message types. 6 Any other Message is rejected. This is a good idea to ensure that you do not miss any messages. WebSocket Authorization Notes: To properly secure your application, you need to understand Spring’s WebSocket support. WebSocket Authorization on Message Types: You need to understand the distinction between SUBSCRIBE and MESSAGE types of messages and how they work within Spring. Consider a chat application: The system can send a notification MESSAGE to all users through a destination of /topic/system/notifications . Clients can receive notifications by SUBSCRIBE to the /topic/system/notifications . While we want clients to be able to SUBSCRIBE to /topic/system/notifications , we do not want to enable them to send a MESSAGE to that destination. If we allowed sending a MESSAGE to /topic/system/notifications , clients could send a message directly to that endpoint and impersonate the system. In general, it is common for applications to deny any MESSAGE sent to a destination that starts with the broker prefix(https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp) ( /topic/ or /queue/ ). WebSocket Authorization on Destinations: You should also understand how destinations are transformed. Consider a chat application: Users can send messages to a specific user by sending a message to the /app/chat destination. The application sees the message, ensures that the from attribute is specified as the current user (we cannot trust the client). The application then sends the message to the recipient by using SimpMessageSendingOperations.convertAndSendToUser(""toUser"", ""/queue/messages"", message) . The message gets turned into the destination of /queue/user/messages-<sessionid> . With this chat application, we want to let our client to listen /user/queue , which is transformed into /queue/user/messages-<sessionid> . However, we do not want the client to be able to listen to /queue/* , because that would let the client see messages for every user. In general, it is common for applications to deny any SUBSCRIBE sent to a message that starts with the broker prefix(https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp) ( /topic/ or /queue/ ). We may provide exceptions to account for things like Outbound Messages: The Spring Framework reference documentation contains a section titled “Flow of Messages”(https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp-message-flow) that describes how messages flow through the system. Note that Spring Security secures only the clientInboundChannel . Spring Security does not attempt to secure the clientOutboundChannel . The most important reason for this is performance. For every message that goes in, typically many more go out. Instead of securing the outbound messages, we encourage securing the subscription to the endpoints. Enforcing Same Origin Policy: Note that the browser does not enforce the Same Origin Policy(https://en.wikipedia.org/wiki/Same-origin_policy) for WebSocket connections. This is an extremely important consideration. Why Same Origin?: Consider the following scenario. A user visits bank.com and authenticates to their account. The same user opens another tab in their browser and visits evil.com . The Same Origin Policy ensures that evil.com cannot read data from or write data to bank.com . With WebSockets, the Same Origin Policy does not apply. In fact, unless bank.com explicitly forbids it, evil.com can read and write data on behalf of the user. This means that anything the user can do over the webSocket (such as transferring money), evil.com can do on that user’s behalf. Since SockJS tries to emulate WebSockets, it also bypasses the Same Origin Policy. This means that developers need to explicitly protect their applications from external domains when they use SockJS. Spring WebSocket Allowed Origin: Fortunately, since Spring 4.1.5 Spring’s WebSocket and SockJS support restricts access to the current domain(https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-server-allowed-origins) . Spring Security adds an additional layer of protection to provide defense in depth(https://en.wikipedia.org/wiki/Defence_in_depth_(non-military)#Information_security) . Adding CSRF to Stomp Headers: By default, Spring Security requires the CSRF token(../../features/exploits/csrf.html#csrf) in any CONNECT message type. This ensures that only a site that has access to the CSRF token can connect. Since only the same origin can access the CSRF token, external domains are not allowed to make a connection. Typically we need to include the CSRF token in an HTTP header or an HTTP parameter. However, SockJS does not allow for these options. Instead, we must include the token in the Stomp headers. Applications can obtain a CSRF token(../exploits/csrf.html#csrf-integration) by accessing the request attribute named _csrf . For example, the following allows accessing the CsrfToken in a JSP: var headerName = ""${_csrf.headerName}""; var token = ""${_csrf.token}""; If you use static HTML, you can expose the CsrfToken on a REST endpoint. For example, the following would expose the CsrfToken on the /csrf URL: Java Kotlin @RestController public class CsrfController { @RequestMapping(""/csrf"") public CsrfToken csrf(CsrfToken token) { return token; } } @RestController class CsrfController { @RequestMapping(""/csrf"") fun csrf(token: CsrfToken): CsrfToken { return token } } The JavaScript can make a REST call to the endpoint and use the response to populate the headerName and the token. We can now include the token in our Stomp client: ... var headers = {}; headers[headerName] = token; stompClient.connect(headers, function(frame) { ... }) Disable CSRF within WebSockets: At this point, CSRF is not configurable when using @EnableWebSocketSecurity , though this will likely be added in a future release. To disable CSRF, instead of using @EnableWebSocketSecurity , you can use XML support or add the Spring Security components yourself, like so: Java Kotlin Xml @Configuration public class WebSocketSecurityConfig implements WebSocketMessageBrokerConfigurer { @Override public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) { argumentResolvers.add(new AuthenticationPrincipalArgumentResolver()); } @Override public void configureClientInboundChannel(ChannelRegistration registration) { AuthorizationManager<Message<?>> myAuthorizationRules = AuthenticatedAuthorizationManager.authenticated(); AuthorizationChannelInterceptor authz = new AuthorizationChannelInterceptor(myAuthorizationRules); AuthorizationEventPublisher publisher = new SpringAuthorizationEventPublisher(this.context); authz.setAuthorizationEventPublisher(publisher); registration.interceptors(new SecurityContextChannelInterceptor(), authz); } } @Configuration open class WebSocketSecurityConfig : WebSocketMessageBrokerConfigurer { @Override override fun addArgumentResolvers(argumentResolvers: List<HandlerMethodArgumentResolver>) { argumentResolvers.add(AuthenticationPrincipalArgumentResolver()) } @Override override fun configureClientInboundChannel(registration: ChannelRegistration) { var myAuthorizationRules: AuthorizationManager<Message<*>> = AuthenticatedAuthorizationManager.authenticated() var authz: AuthorizationChannelInterceptor = AuthorizationChannelInterceptor(myAuthorizationRules) var publisher: AuthorizationEventPublisher = SpringAuthorizationEventPublisher(this.context) authz.setAuthorizationEventPublisher(publisher) registration.interceptors(SecurityContextChannelInterceptor(), authz) } } <websocket-message-broker use-authorization-manager=""true"" same-origin-disabled=""true""> <intercept-message pattern=""/**"" access=""authenticated""/> </websocket-message-broker> On the other hand, if you are using the legacy AbstractSecurityWebSocketMessageBrokerConfigurer(#legacy-websocket-configuration) and you want to allow other domains to access your site, you can disable Spring Security’s protection. For example, in Java Configuration you can use the following: Java Kotlin @Configuration public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer { ... @Override protected boolean sameOriginDisabled() { return true; } } @Configuration open class WebSocketSecurityConfig : AbstractSecurityWebSocketMessageBrokerConfigurer() { // ... override fun sameOriginDisabled(): Boolean { return true } } Custom Expression Handler: At times, there may be value in customizing how the access expressions are handled defined in your intercept-message XML elements. To do this, you can create a class of type SecurityExpressionHandler<MessageAuthorizationContext<?>> and refer to it in your XML definition like so: <websocket-message-broker use-authorization-manager=""true""> <expression-handler ref=""myRef""/> ... </websocket-message-broker> <b:bean ref=""myRef"" class=""org.springframework.security.messaging.access.expression.MessageAuthorizationContextSecurityExpressionHandler""/> If you are migrating from a legacy usage of websocket-message-broker that implements a SecurityExpressionHandler<Message<?>> , you can: 1. Additionally implement the createEvaluationContext(Supplier, Message) method and then 2. Wrap that value in a MessageAuthorizationContextSecurityExpressionHandler like so: <websocket-message-broker use-authorization-manager=""true""> <expression-handler ref=""myRef""/> ... </websocket-message-broker> <b:bean ref=""myRef"" class=""org.springframework.security.messaging.access.expression.MessageAuthorizationContextSecurityExpressionHandler""> <b:constructor-arg> <b:bean class=""org.example.MyLegacyExpressionHandler""/> </b:constructor-arg> </b:bean> Working with SockJS: SockJS(https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-fallback) provides fallback transports to support older browsers. When using the fallback options, we need to relax a few security constraints to allow SockJS to work with Spring Security. SockJS & frame-options: SockJS may use a transport that leverages an iframe(https://github.com/sockjs/sockjs-client/tree/v0.3.4) . By default, Spring Security denies(../../features/exploits/headers.html#headers-frame-options) the site from being framed to prevent clickjacking attacks. To allow SockJS frame-based transports to work, we need to configure Spring Security to let the same origin frame the content. You can customize X-Frame-Options with the frame-options(../appendix/namespace/http.html#nsa-frame-options) element. For example, the following instructs Spring Security to use X-Frame-Options: SAMEORIGIN , which allows iframes within the same domain: <http> <!-- ... --> <headers> <frame-options policy=""SAMEORIGIN"" /> </headers> </http> Similarly, you can customize frame options to use the same origin within Java Configuration by using the following: Java Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // ... .headers(headers -> headers .frameOptions(frameOptions -> frameOptions .sameOrigin() ) ); return http.build(); } } @Configuration @EnableWebSecurity open class WebSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // ... headers { frameOptions { sameOrigin = true } } } return http.build() } } SockJS & Relaxing CSRF: SockJS uses a POST on the CONNECT messages for any HTTP-based transport. Typically, we need to include the CSRF token in an HTTP header or an HTTP parameter. However, SockJS does not allow for these options. Instead, we must include the token in the Stomp headers as described in Adding CSRF to Stomp Headers(#websocket-sameorigin-csrf) . It also means that we need to relax our CSRF protection with the web layer. Specifically, we want to disable CSRF protection for our connect URLs. We do NOT want to disable CSRF protection for every URL. Otherwise, our site is vulnerable to CSRF attacks. We can easily achieve this by providing a CSRF RequestMatcher . Our Java configuration makes this easy. For example, if our stomp endpoint is /chat , we can disable CSRF protection only for URLs that start with /chat/ by using the following configuration: Java Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .csrf(csrf -> csrf // ignore our stomp endpoints since they are protected using Stomp headers .ignoringRequestMatchers(""/chat/**"") ) .headers(headers -> headers // allow same origin to frame our site to support iframe SockJS .frameOptions(frameOptions -> frameOptions .sameOrigin() ) ) .authorizeHttpRequests(authorize -> authorize ... ) ... } } @Configuration @EnableWebSecurity open class WebSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { csrf { ignoringRequestMatchers(""/chat/**"") } headers { frameOptions { sameOrigin = true } } authorizeRequests { // ... } // ... } } } If we use XML-based configuration, we can use the csrf@request-matcher-ref(../appendix/namespace/http.html#nsa-csrf-request-matcher-ref) . <http ...> <csrf request-matcher-ref=""csrfMatcher""/> <headers> <frame-options policy=""SAMEORIGIN""/> </headers> ... </http> <b:bean id=""csrfMatcher"" class=""AndRequestMatcher""> <b:constructor-arg value=""#{T(org.springframework.security.web.csrf.CsrfFilter).DEFAULT_CSRF_MATCHER}""/> <b:constructor-arg> <b:bean class=""org.springframework.security.web.util.matcher.NegatedRequestMatcher""> <b:bean class=""org.springframework.security.web.util.matcher.AntPathRequestMatcher""> <b:constructor-arg value=""/chat/**""/> </b:bean> </b:bean> </b:constructor-arg> </b:bean> Legacy WebSocket Configuration: Before Spring Security 5.8, the way to configure messaging authorization using Java Configuration, was to extend the AbstractSecurityWebSocketMessageBrokerConfigurer and configure the MessageSecurityMetadataSourceRegistry . For example: Java Kotlin @Configuration public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer { (1) (2) protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) { messages .simpDestMatchers(""/user/**"").authenticated() (3) } } @Configuration open class WebSocketSecurityConfig : AbstractSecurityWebSocketMessageBrokerConfigurer() { (1) (2) override fun configureInbound(messages: MessageSecurityMetadataSourceRegistry) { messages.simpDestMatchers(""/user/**"").authenticated() (3) } } This will ensure that: 1 Any inbound CONNECT message requires a valid CSRF token to enforce Same Origin Policy(#websocket-sameorigin) 2 The SecurityContextHolder is populated with the user within the simpUser header attribute for any inbound request. 3 Our messages require the proper authorization. Specifically, any inbound message that starts with ""/user/"" will require ROLE_USER. Additional details on authorization can be found in WebSocket Authorization(#websocket-authorization) Using the legacy configuration is helpful in the event that you have a custom SecurityExpressionHandler that extends AbstractSecurityExpressionHandler and overrides createEvaluationContextInternal or createSecurityExpressionRoot . In order to defer Authorization lookup, the new AuthorizationManager API does not invoke these when evaluating expressions. If you are using XML, you can use the legacy APIs simply by not using the use-authorization-manager element or setting it to false ."
"https://docs.spring.io/spring-security/reference/6.3/servlet/integrations/cors.html","CORS: Spring Framework provides first class support for CORS(https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-cors) . CORS must be processed before Spring Security, because the pre-flight request does not contain any cookies (that is, the JSESSIONID ). If the request does not contain any cookies and Spring Security is first, the request determines that the user is not authenticated (since there are no cookies in the request) and rejects it. The easiest way to ensure that CORS is handled first is to use the CorsFilter . Users can integrate the CorsFilter with Spring Security by providing a CorsConfigurationSource . Note that Spring Security will automatically configure CORS only if a UrlBasedCorsConfigurationSource instance is present. For example, the following will integrate CORS support within Spring Security: Java Kotlin @Bean CorsConfigurationSource corsConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOrigins(Arrays.asList(""https://example.com"")); configuration.setAllowedMethods(Arrays.asList(""GET"",""POST"")); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(""/**"", configuration); return source; } @Bean fun corsConfigurationSource(): CorsConfigurationSource { val configuration = CorsConfiguration() configuration.allowedOrigins = listOf(""https://example.com"") configuration.allowedMethods = listOf(""GET"", ""POST"") val source = UrlBasedCorsConfigurationSource() source.registerCorsConfiguration(""/**"", configuration) return source } The following listing does the same thing in XML: <http> <cors configuration-source-ref=""corsSource""/> ... </http> <b:bean id=""corsSource"" class=""org.springframework.web.cors.UrlBasedCorsConfigurationSource""> ... </b:bean> If you use Spring MVC’s CORS support, you can omit specifying the CorsConfigurationSource and Spring Security uses the CORS configuration provided to Spring MVC: Java Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http // if Spring MVC is on classpath and no CorsConfigurationSource is provided, // Spring Security will use CORS configuration provided to Spring MVC .cors(withDefaults()) ... return http.build(); } } @Configuration @EnableWebSecurity open class WebSecurityConfig { @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { // if Spring MVC is on classpath and no CorsConfigurationSource is provided, // Spring Security will use CORS configuration provided to Spring MVC cors { } // ... } return http.build() } } The following listing does the same thing in XML: <http> <!-- Default to Spring MVC's CORS configuration --> <cors /> ... </http> If you have more than one CorsConfigurationSource bean, Spring Security won’t automatically configure CORS support for you, that is because it cannot decide which one to use. If you want to specify different CorsConfigurationSource for each SecurityFilterChain , you can pass it directly into the .cors() DSL. Java Kotlin @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean @Order(0) public SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception { http .securityMatcher(""/api/**"") .cors((cors) -> cors .configurationSource(apiConfigurationSource()) ) ... return http.build(); } @Bean @Order(1) public SecurityFilterChain myOtherFilterChain(HttpSecurity http) throws Exception { http .cors((cors) -> cors .configurationSource(myWebsiteConfigurationSource()) ) ... return http.build(); } CorsConfigurationSource apiConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOrigins(Arrays.asList(""https://api.example.com"")); configuration.setAllowedMethods(Arrays.asList(""GET"",""POST"")); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(""/**"", configuration); return source; } CorsConfigurationSource myWebsiteConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOrigins(Arrays.asList(""https://example.com"")); configuration.setAllowedMethods(Arrays.asList(""GET"",""POST"")); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(""/**"", configuration); return source; } } @Bean fun corsConfigurationSource(): CorsConfigurationSource { val configuration = CorsConfiguration() configuration.allowedOrigins = listOf(""https://example.com"") configuration.allowedMethods = listOf(""GET"", ""POST"") val source = UrlBasedCorsConfigurationSource() source.registerCorsConfiguration(""/**"", configuration) return source }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/integrations/jsp-taglibs.html","JSP Tag Libraries: Declaring the Taglib: To use any of the tags, you must have the security taglib declared in your JSP: <%@ taglib prefix=""sec"" uri=""http://www.springframework.org/security/tags"" %> The authorize Tag: This tag is used to determine whether its contents should be evaluated or not. In Spring Security 3.0, it can be used in two ways. The legacy options from Spring Security 2.0 are also supported, but discouraged. The first approach uses a web-security expression(../authorization/authorize-http-requests.html#authorization-expressions) , which is specified in the access attribute of the tag. The expression evaluation is delegated to the SecurityExpressionHandler<FilterInvocation> defined in the application context (you should have web expressions enabled in your <http> namespace configuration to make sure this service is available). So, for example, you might have: <sec:authorize access=""hasRole('supervisor')""> This content will only be visible to users who have the ""supervisor"" authority in their list of <tt>GrantedAuthority</tt>s. </sec:authorize> When used in conjunction with Spring Security’s PermissionEvaluator , the tag can also be used to check permissions: <sec:authorize access=""hasPermission(#domain,'read') or hasPermission(#domain,'write')""> This content will only be visible to users who have read or write permission to the Object found as a request attribute named ""domain"". </sec:authorize> A common requirement is to show only a particular link, assuming the user is actually allowed to click it. How can we determine in advance whether something is allowed? This tag can also operate in an alternative mode that lets you define a particular URL as an attribute. If the user is allowed to invoke that URL, the tag body is evaluated. Otherwise, it is skipped. So you might have something like: <sec:authorize url=""/admin""> This content will only be visible to users who are authorized to send requests to the ""/admin"" URL. </sec:authorize> To use this tag, you must also have an instance of WebInvocationPrivilegeEvaluator in your application context. If you are using the namespace, one is automatically registered. This is an instance of DefaultWebInvocationPrivilegeEvaluator , which creates a dummy web request for the supplied URL and invokes the security interceptor to see whether the request would succeed or fail. This lets you delegate to the access-control setup you defined by using intercept-url declarations within the <http> namespace configuration and saves having to duplicate the information (such as the required roles) within your JSPs. You can also combine this approach with a method attribute (supplying the HTTP method, such as POST ) for a more specific match. You can store the Boolean result of evaluating the tag (whether it grants or denies access) in a page context scope variable by setting the var attribute to the variable name, avoiding the need for duplicating and re-evaluating the condition at other points in the page. Disabling Tag Authorization for Testing: Hiding a link in a page for unauthorized users does not prevent them from accessing the URL. They could just type it into their browser directly, for example. As part of your testing process, you may want to reveal the hidden areas, to check that links really are secured at the back end. If you set the spring.security.disableUISecurity system property to true , the authorize tag still runs but does not hide its contents. By default, it also surrounds the content with <span class=""securityHiddenUI"">…​</span> tags. This lets you to display “hidden” content with a particular CSS style, such as a different background color. Try running the “tutorial” sample application, for example, with this property enabled. You can also set the spring.security.securedUIPrefix and spring.security.securedUISuffix properties if you want to change surrounding text from the default span tags (or use empty strings to remove it completely). The authentication Tag: This tag allows access to the current Authentication object stored in the security context. It renders a property of the object directly in the JSP. So, for example, if the principal property of the Authentication is an instance of Spring Security’s UserDetails object, then using <sec:authentication property=""principal.username"" /> renders the name of the current user. Of course, it is not necessary to use JSP tags for this kind of thing, and some people prefer to keep as little logic as possible in the view. You can access the Authentication object in your MVC controller (by calling SecurityContextHolder.getContext().getAuthentication() ) and add the data directly to your model for rendering by the view. The accesscontrollist Tag: This tag is only valid when used with Spring Security’s ACL module. It checks a comma-separated list of required permissions for a specified domain object. If the current user has all of those permissions, the tag body is evaluated. If they do not, it is skipped. In general, this tag should be considered deprecated. Instead, use the The authorize Tag(#taglibs-authorize) . The following listing shows an example: <sec:accesscontrollist hasPermission=""1,2"" domainObject=""${someObject}""> <!-- This will be shown if the user has all of the permissions represented by the values ""1"" or ""2"" on the given object. --> </sec:accesscontrollist> The permissions are passed to the PermissionFactory defined in the application context, converting them to ACL Permission instances, so they may be any format that is supported by the factory. They do not have to be integers. They could be strings such as READ or WRITE . If no PermissionFactory is found, an instance of DefaultPermissionFactory is used. The AclService from the application context is used to load the Acl instance for the supplied object. The Acl is invoked with the required permissions to check if all of them are granted. This tag also supports the var attribute, in the same way as the authorize tag. The csrfInput Tag: If CSRF protection is enabled, this tag inserts a hidden form field with the correct name and value for the CSRF protection token. If CSRF protection is not enabled, this tag outputs nothing. Normally, Spring Security automatically inserts a CSRF form field for any <form:form> tags you use, but if for some reason you cannot use <form:form> , csrfInput is a handy replacement. You should place this tag within an HTML <form></form> block, where you would normally place other input fields. Do NOT place this tag within a Spring <form:form></form:form> block. Spring Security handles Spring forms automatically. The following listing shows an example: <form method=""post"" action=""/do/something""> <sec:csrfInput /> Name:<br /> <input type=""text"" name=""name"" /> ... </form> The csrfMetaTags Tag: If CSRF protection is enabled, this tag inserts meta tags that contain the CSRF protection token form field and header names and CSRF protection token value. These meta tags are useful for employing CSRF protection within JavaScript in your applications. You should place csrfMetaTags within an HTML <head></head> block, where you would normally place other meta tags. Once you use this tag, you can access the form field name, header name, and token value by using JavaScript. JQuery is used in this example to make the task easier. The following listing shows an example: <!DOCTYPE html> <html> <head> <title>CSRF Protected JavaScript Page</title> <meta name=""description"" content=""This is the description for this page"" /> <sec:csrfMetaTags /> <script type=""text/javascript"" language=""javascript""> var csrfParameter = $(""meta[name='_csrf_parameter']"").attr(""content""); var csrfHeader = $(""meta[name='_csrf_header']"").attr(""content""); var csrfToken = $(""meta[name='_csrf']"").attr(""content""); // using XMLHttpRequest directly to send an x-www-form-urlencoded request var ajax = new XMLHttpRequest(); ajax.open(""POST"", ""https://www.example.org/do/something"", true); ajax.setRequestHeader(""Content-Type"", ""application/x-www-form-urlencoded data""); ajax.send(csrfParameter + ""="" + csrfToken + ""&name=John&...""); // using XMLHttpRequest directly to send a non-x-www-form-urlencoded request var ajax = new XMLHttpRequest(); ajax.open(""POST"", ""https://www.example.org/do/something"", true); ajax.setRequestHeader(csrfHeader, csrfToken); ajax.send(""...""); // using JQuery to send an x-www-form-urlencoded request var data = {}; data[csrfParameter] = csrfToken; data[""name""] = ""John""; ... $.ajax({ url: ""https://www.example.org/do/something"", type: ""POST"", data: data, ... }); // using JQuery to send a non-x-www-form-urlencoded request var headers = {}; headers[csrfHeader] = csrfToken; $.ajax({ url: ""https://www.example.org/do/something"", type: ""POST"", headers: headers, ... }); <script> </head> <body> ... </body> </html> If CSRF protection is not enabled, csrfMetaTags outputs nothing."
"https://docs.spring.io/spring-security/reference/6.3/servlet/integrations/observability.html","Observability: Spring Security integrates with Spring Observability out-of-the-box for tracing; though it’s also quite simple to configure for gathering metrics. Tracing: When an ObservationRegistry bean is present, Spring Security creates traces for: the filter chain the AuthenticationManager , and the AuthorizationManager Boot Integration: For example, consider a simple Boot application: Java Kotlin @SpringBootApplication public class MyApplication { @Bean public UserDetailsService userDetailsService() { return new InMemoryUserDetailsManager( User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .authorities(""app"") .build() ); } @Bean ObservationRegistryCustomizer<ObservationRegistry> addTextHandler() { return (registry) -> registry.observationConfig().observationHandler(new ObservationTextPublisher()); } public static void main(String[] args) { SpringApplication.run(ListenerSamplesApplication.class, args); } } @SpringBootApplication class MyApplication { @Bean fun userDetailsService(): UserDetailsService { InMemoryUserDetailsManager( User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .authorities(""app"") .build() ); } @Bean fun addTextHandler(): ObservationRegistryCustomizer<ObservationRegistry> { return registry: ObservationRegistry -> registry.observationConfig() .observationHandler(ObservationTextPublisher()); } fun main(args: Array<String>) { runApplication<MyApplication>(*args) } } And a corresponding request: ?> http -a user:password :8080 Will produce the following output (indentation added for clarity): START - name='http.server.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@687e16d1', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.001779024, duration(nanos)=1779024.0, startTimeNanos=91695917264958}'] START - name='spring.security.http.chains', contextualName='spring.security.http.chains.before', error='null', lowCardinalityKeyValues=[chain.position='0', chain.size='17', filter.section='before'], highCardinalityKeyValues=[request.line='GET /'], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@79f554a5', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=7.42147E-4, duration(nanos)=742147.0, startTimeNanos=91695947182029}'] ... skipped for brevity ... STOP - name='spring.security.http.chains', contextualName='spring.security.http.chains.before', error='null', lowCardinalityKeyValues=[chain.position='0', chain.size='17', filter.section='before'], highCardinalityKeyValues=[request.line='GET /'], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@79f554a5', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.014771848, duration(nanos)=1.4771848E7, startTimeNanos=91695947182029}'] START - name='spring.security.authentications', contextualName='null', error='null', lowCardinalityKeyValues=[authentication.failure.type='Optional', authentication.method='ProviderManager', authentication.request.type='UsernamePasswordAuthenticationToken'], highCardinalityKeyValues=[], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@4d4b2b56', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=7.09759E-4, duration(nanos)=709759.0, startTimeNanos=91696094477504}'] ... skipped for brevity ... STOP - name='spring.security.authentications', contextualName='null', error='null', lowCardinalityKeyValues=[authentication.failure.type='Optional', authentication.method='ProviderManager', authentication.request.type='UsernamePasswordAuthenticationToken', authentication.result.type='UsernamePasswordAuthenticationToken'], highCardinalityKeyValues=[], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@4d4b2b56', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.895141386, duration(nanos)=8.95141386E8, startTimeNanos=91696094477504}'] START - name='spring.security.authorizations', contextualName='null', error='null', lowCardinalityKeyValues=[object.type='Servlet3SecurityContextHolderAwareRequestWrapper'], highCardinalityKeyValues=[], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@6d834cc7', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=3.0965E-4, duration(nanos)=309650.0, startTimeNanos=91697034893983}'] ... skipped for brevity ... STOP - name='spring.security.authorizations', contextualName='null', error='null', lowCardinalityKeyValues=[authorization.decision='true', object.type='Servlet3SecurityContextHolderAwareRequestWrapper'], highCardinalityKeyValues=[authentication.authorities='[app]', authorization.decision.details='AuthorizationDecision [granted=true]'], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@6d834cc7', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.02084809, duration(nanos)=2.084809E7, startTimeNanos=91697034893983}'] START - name='spring.security.http.secured.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@649c5ec3', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=2.67878E-4, duration(nanos)=267878.0, startTimeNanos=91697059819304}'] ... skipped for brevity ... STOP - name='spring.security.http.secured.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@649c5ec3', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.090753322, duration(nanos)=9.0753322E7, startTimeNanos=91697059819304}'] START - name='spring.security.http.chains', contextualName='spring.security.http.chains.after', error='null', lowCardinalityKeyValues=[chain.position='0', chain.size='17', filter.section='after'], highCardinalityKeyValues=[request.line='GET /'], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@47af8207', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=5.31832E-4, duration(nanos)=531832.0, startTimeNanos=91697152857268}'] ... skipped for brevity ... STOP - name='spring.security.http.chains', contextualName='spring.security.http.chains.after', error='null', lowCardinalityKeyValues=[chain.position='17', chain.size='17', current.filter.name='DisableEncodeUrlFilter', filter.section='after'], highCardinalityKeyValues=[request.line='GET /'], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@47af8207', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.007689382, duration(nanos)=7689382.0, startTimeNanos=91697152857268}'] STOP - name='http.server.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[request.line='GET /'], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@687e16d1', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=1.245858319, duration(nanos)=1.245858319E9, startTimeNanos=91695917264958}'] Manual Configuration: For a non-Spring Boot application, or to override the existing Boot configuration, you can publish your own ObservationRegistry and Spring Security will still pick it up. Java Kotlin Xml @SpringBootApplication public class MyApplication { @Bean public UserDetailsService userDetailsService() { return new InMemoryUserDetailsManager( User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .authorities(""app"") .build() ); } @Bean ObservationRegistry<ObservationRegistry> observationRegistry() { ObservationRegistry registry = ObservationRegistry.create(); registry.observationConfig().observationHandler(new ObservationTextPublisher()); return registry; } public static void main(String[] args) { SpringApplication.run(ListenerSamplesApplication.class, args); } } @SpringBootApplication class MyApplication { @Bean fun userDetailsService(): UserDetailsService { InMemoryUserDetailsManager( User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .authorities(""app"") .build() ); } @Bean fun observationRegistry(): ObservationRegistry<ObservationRegistry> { ObservationRegistry registry = ObservationRegistry.create() registry.observationConfig().observationHandler(ObservationTextPublisher()) return registry } fun main(args: Array<String>) { runApplication<MyApplication>(*args) } } <sec:http auto-config=""true"" observation-registry-ref=""ref""> <sec:intercept-url pattern=""/**"" access=""authenticated""/> </sec:http> <!-- define and configure ObservationRegistry bean --> Disabling Observability: If you don’t want any Spring Security observations, in a Spring Boot application you can publish a ObservationRegistry.NOOP @Bean . However, this may turn off observations for more than just Spring Security. Instead, you can alter the provided ObservationRegistry with an ObservationPredicate like the following: Java Kotlin @Bean ObservationRegistryCustomizer<ObservationRegistry> noSpringSecurityObservations() { ObservationPredicate predicate = (name, context) -> !name.startsWith(""spring.security.""); return (registry) -> registry.observationConfig().observationPredicate(predicate); } @Bean fun noSpringSecurityObservations(): ObservationRegistryCustomizer<ObservationRegistry> { ObservationPredicate predicate = (name: String, context: Observation.Context) -> !name.startsWith(""spring.security."") (registry: ObservationRegistry) -> registry.observationConfig().observationPredicate(predicate) } There is no facility for disabling observations with XML support. Instead, simply do not set the observation-registry-ref attribute. Trace Listing: Spring Security tracks the following spans on each request: spring.security.http.requests - a span that wraps the entire filter chain, including the request spring.security.http.chains.before - a span that wraps the receiving part of the security filters spring.security.http.chains.after - a span that wraps the returning part of the security filters spring.security.http.secured.requests - a span that wraps the now-secured application request spring.security.http.unsecured.requests - a span that wraps requests that Spring Security does not secure spring.security.authentications - a span that wraps authentication attempts spring.security.authorizations - a span that wraps authorization attempts spring.security.http.chains.before + spring.security.http.secured.requests + spring.security.http.chains.after = spring.security.http.requests spring.security.http.chains.before + spring.security.http.chains.after = Spring Security’s part of the request"
"https://docs.spring.io/spring-security/reference/6.3/servlet/configuration/java.html","Java Configuration: General support for Java configuration(https://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/beans.html#beans-java) was added to Spring Framework in Spring 3.1. Spring Security 3.2 introduced Java configuration to let users configure Spring Security without the use of any XML. If you are familiar with the Security Namespace Configuration(xml-namespace.html#ns-config) , you should find quite a few similarities between it and Spring Security Java configuration. Spring Security provides lots of sample applications(https://github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration) to demonstrate the use of Spring Security Java Configuration. Hello Web Security Java Configuration: The first step is to create our Spring Security Java Configuration. The configuration creates a Servlet Filter known as the springSecurityFilterChain , which is responsible for all the security (protecting the application URLs, validating submitted username and passwords, redirecting to the log in form, and so on) within your application. The following example shows the most basic example of a Spring Security Java Configuration: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.*; import org.springframework.security.config.annotation.authentication.builders.*; import org.springframework.security.config.annotation.web.configuration.*; @Configuration @EnableWebSecurity public class WebSecurityConfig { @Bean public UserDetailsService userDetailsService() { InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(User.withDefaultPasswordEncoder().username(""user"").password(""password"").roles(""USER"").build()); return manager; } } This configuration is not complex or extensive, but it does a lot: Require authentication to every URL in your application Generate a login form for you Let the user with a Username of user and a Password of password authenticate with form based authentication Let the user logout CSRF attack(https://en.wikipedia.org/wiki/Cross-site_request_forgery) prevention Session Fixation(https://en.wikipedia.org/wiki/Session_fixation) protection Security Header integration: HTTP Strict Transport Security(https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security) for secure requests X-Content-Type-Options(https://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx) integration Cache Control (which you can override later in your application to allow caching of your static resources) X-XSS-Protection(https://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx) integration X-Frame-Options integration to help prevent Clickjacking(https://en.wikipedia.org/wiki/Clickjacking) Integration with the following Servlet API methods: HttpServletRequest#getRemoteUser()(https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()) HttpServletRequest#getUserPrincipal()(https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()) HttpServletRequest#isUserInRole(java.lang.String)(https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)) HttpServletRequest#login(java.lang.String, java.lang.String)(https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String,%20java.lang.String)) HttpServletRequest#logout()(https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout()) AbstractSecurityWebApplicationInitializer: The next step is to register the springSecurityFilterChain with the WAR file. You can do so in Java configuration with Spring’s WebApplicationInitializer support(https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-container-config) in a Servlet 3.0+ environment. Not surprisingly, Spring Security provides a base class ( AbstractSecurityWebApplicationInitializer ) to ensure that the springSecurityFilterChain gets registered for you. The way in which we use AbstractSecurityWebApplicationInitializer differs depending on if we are already using Spring or if Spring Security is the only Spring component in our application. AbstractSecurityWebApplicationInitializer without Existing Spring(#abstractsecuritywebapplicationinitializer-without-existing-spring) - Use these instructions if you are not already using Spring AbstractSecurityWebApplicationInitializer with Spring MVC(#abstractsecuritywebapplicationinitializer-with-spring-mvc) - Use these instructions if you are already using Spring AbstractSecurityWebApplicationInitializer without Existing Spring: If you are not using Spring or Spring MVC, you need to pass the WebSecurityConfig to the superclass to ensure the configuration is picked up: import org.springframework.security.web.context.*; public class SecurityWebApplicationInitializer extends AbstractSecurityWebApplicationInitializer { public SecurityWebApplicationInitializer() { super(WebSecurityConfig.class); } } The SecurityWebApplicationInitializer : Automatically registers the springSecurityFilterChain Filter for every URL in your application. Add a ContextLoaderListener that loads the WebSecurityConfig(#jc-hello-wsca) . AbstractSecurityWebApplicationInitializer with Spring MVC: If we use Spring elsewhere in our application, we probably already have a WebApplicationInitializer that is loading our Spring Configuration. If we use the previous configuration, we would get an error. Instead, we should register Spring Security with the existing ApplicationContext . For example, if we use Spring MVC, our SecurityWebApplicationInitializer could look something like the following: import org.springframework.security.web.context.*; public class SecurityWebApplicationInitializer extends AbstractSecurityWebApplicationInitializer { } This only registers the springSecurityFilterChain for every URL in your application. After that, we need to ensure that WebSecurityConfig was loaded in our existing ApplicationInitializer . For example, if we use Spring MVC it is added in the getServletConfigClasses() : public class MvcWebApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class<?>[] getServletConfigClasses() { return new Class[] { WebSecurityConfig.class, WebMvcConfig.class }; } // ... other overrides ... } The reason for this is that Spring Security needs to be able to inspect some Spring MVC configuration in order to appropriately configure underlying request matchers(../authorization/authorize-http-requests.html#authorizing-endpoints) , so they need to be in the same application context. Placing Spring Security in getRootConfigClasses places it into a parent application context that may not be able to find Spring MVC’s HandlerMappingIntrospector . Configuring for Multiple Spring MVC Dispatchers: If desired, any Spring Security configuration that is unrelated to Spring MVC may be placed in a different configuration class like so: public class MvcWebApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class<?>[] getRootConfigClasses() { return new Class[] { NonWebSecurityConfig.class }; } @Override protected Class<?>[] getServletConfigClasses() { return new Class[] { WebSecurityConfig.class, WebMvcConfig.class }; } // ... other overrides ... } This can be helpful if you have multiple instances of AbstractAnnotationConfigDispatcherServletInitializer and don’t want to duplicate the general security configuration across both of them. HttpSecurity: Thus far, our WebSecurityConfig(#jc-hello-wsca) contains only information about how to authenticate our users. How does Spring Security know that we want to require all users to be authenticated? How does Spring Security know we want to support form-based authentication? Actually, there is a configuration class (called SecurityFilterChain ) that is being invoked behind the scenes. It is configured with the following default implementation: @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .formLogin(withDefaults()) .httpBasic(withDefaults()); return http.build(); } The default configuration (shown in the preceding example): Ensures that any request to our application requires the user to be authenticated Lets users authenticate with form based login Lets users authenticate with HTTP Basic authentication Note that this configuration is parallels the XML Namespace configuration: <http> <intercept-url pattern=""/**"" access=""authenticated""/> <form-login /> <http-basic /> </http> Multiple HttpSecurity Instances: We can configure multiple HttpSecurity instances just as we can have multiple <http> blocks in XML. The key is to register multiple SecurityFilterChain @Bean s. The following example has a different configuration for URLs that start with /api/ . @Configuration @EnableWebSecurity public class MultiHttpSecurityConfig { @Bean (1) public UserDetailsService userDetailsService() throws Exception { // ensure the passwords are encoded properly UserBuilder users = User.withDefaultPasswordEncoder(); InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(users.username(""user"").password(""password"").roles(""USER"").build()); manager.createUser(users.username(""admin"").password(""password"").roles(""USER"",""ADMIN"").build()); return manager; } @Bean @Order(1) (2) public SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception { http .securityMatcher(""/api/**"") (3) .authorizeHttpRequests(authorize -> authorize .anyRequest().hasRole(""ADMIN"") ) .httpBasic(withDefaults()); return http.build(); } @Bean (4) public SecurityFilterChain formLoginFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() ) .formLogin(withDefaults()); return http.build(); } } 1 Configure Authentication as usual. 2 Create an instance of SecurityFilterChain that contains @Order to specify which SecurityFilterChain should be considered first. 3 The http.securityMatcher states that this HttpSecurity is applicable only to URLs that start with /api/ . 4 Create another instance of SecurityFilterChain . If the URL does not start with /api/ , this configuration is used. This configuration is considered after apiFilterChain , since it has an @Order value after 1 (no @Order defaults to last). Custom DSLs: You can provide your own custom DSLs in Spring Security: Java Kotlin public class MyCustomDsl extends AbstractHttpConfigurer<MyCustomDsl, HttpSecurity> { private boolean flag; @Override public void init(HttpSecurity http) throws Exception { // any method that adds another configurer // must be done in the init method http.csrf().disable(); } @Override public void configure(HttpSecurity http) throws Exception { ApplicationContext context = http.getSharedObject(ApplicationContext.class); // here we lookup from the ApplicationContext. You can also just create a new instance. MyFilter myFilter = context.getBean(MyFilter.class); myFilter.setFlag(flag); http.addFilterBefore(myFilter, UsernamePasswordAuthenticationFilter.class); } public MyCustomDsl flag(boolean value) { this.flag = value; return this; } public static MyCustomDsl customDsl() { return new MyCustomDsl(); } } class MyCustomDsl : AbstractHttpConfigurer<MyCustomDsl, HttpSecurity>() { var flag: Boolean = false override fun init(http: HttpSecurity) { // any method that adds another configurer // must be done in the init method http.csrf().disable() } override fun configure(http: HttpSecurity) { val context: ApplicationContext = http.getSharedObject(ApplicationContext::class.java) // here we lookup from the ApplicationContext. You can also just create a new instance. val myFilter: MyFilter = context.getBean(MyFilter::class.java) myFilter.setFlag(flag) http.addFilterBefore(myFilter, UsernamePasswordAuthenticationFilter::class.java) } companion object { @JvmStatic fun customDsl(): MyCustomDsl { return MyCustomDsl() } } } This is actually how methods like HttpSecurity.authorizeHttpRequests() are implemented. You can then use the custom DSL: Java Kotlin @Configuration @EnableWebSecurity public class Config { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .with(MyCustomDsl.customDsl(), (dsl) -> dsl .flag(true) ) // ... return http.build(); } } @Configuration @EnableWebSecurity class Config { @Bean fun filterChain(http: HttpSecurity): SecurityFilterChain { http .with(MyCustomDsl.customDsl()) { flag = true } // ... return http.build() } } The code is invoked in the following order: Code in the Config.filterChain method is invoked Code in the MyCustomDsl.init method is invoked Code in the MyCustomDsl.configure method is invoked If you want, you can have HttpSecurity add MyCustomDsl by default by using SpringFactories . For example, you can create a resource on the classpath named META-INF/spring.factories with the following contents: META-INF/spring.factories org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyCustomDsl You can also explicit disable the default: Java Kotlin @Configuration @EnableWebSecurity public class Config { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .with(MyCustomDsl.customDsl(), (dsl) -> dsl .disable() ) ...; return http.build(); } } @Configuration @EnableWebSecurity class Config { @Bean fun filterChain(http: HttpSecurity): SecurityFilterChain { http .with(MyCustomDsl.customDsl()) { disable() } // ... return http.build() } } Post Processing Configured Objects: Spring Security’s Java configuration does not expose every property of every object that it configures. This simplifies the configuration for a majority of users. After all, if every property were exposed, users could use standard bean configuration. While there are good reasons to not directly expose every property, users may still need more advanced configuration options. To address this issue, Spring Security introduces the concept of an ObjectPostProcessor , which can be used to modify or replace many of the Object instances created by the Java Configuration. For example, to configure the filterSecurityPublishAuthorizationSuccess property on FilterSecurityInterceptor , you can use the following: @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(authorize -> authorize .anyRequest().authenticated() .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() { public <O extends FilterSecurityInterceptor> O postProcess( O fsi) { fsi.setPublishAuthorizationSuccess(true); return fsi; } }) ); return http.build(); }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/configuration/kotlin.html","Kotlin Configuration: Spring Security Kotlin configuration has been available since Spring Security 5.3. It lets users configure Spring Security by using a native Kotlin DSL. Spring Security provides a sample application(https://github.com/spring-projects/spring-security-samples/tree/main/servlet/spring-boot/kotlin/hello-security) to demonstrate the use of Spring Security Kotlin Configuration. HttpSecurity: How does Spring Security know that we want to require all users to be authenticated? How does Spring Security know we want to support form-based authentication? There is a configuration class (called SecurityFilterChain ) that is being invoked behind the scenes. It is configured with the following default implementation: import org.springframework.security.config.annotation.web.invoke @Bean open fun filterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(anyRequest, authenticated) } formLogin { } httpBasic { } } return http.build() } Make sure to import the org.springframework.security.config.annotation.web.invoke function to enable the Kotlin DSL in your class, as the IDE will not always auto-import the method, causing compilation issues. The default configuration (shown in the preceding listing): Ensures that any request to our application requires the user to be authenticated Lets users authenticate with form-based login Lets users authenticate with HTTP Basic authentication Note that this configuration parallels the XML namespace configuration: <http> <intercept-url pattern=""/**"" access=""authenticated""/> <form-login /> <http-basic /> </http> Multiple HttpSecurity Instances: We can configure multiple HttpSecurity instances, just as we can have multiple <http> blocks. The key is to register multiple SecurityFilterChain @Bean s. The following example has a different configuration for URLs that start with /api/ : import org.springframework.security.config.annotation.web.invoke @Configuration @EnableWebSecurity class MultiHttpSecurityConfig { @Bean (1) public fun userDetailsService(): UserDetailsService { val users: User.UserBuilder = User.withDefaultPasswordEncoder() val manager = InMemoryUserDetailsManager() manager.createUser(users.username(""user"").password(""password"").roles(""USER"").build()) manager.createUser(users.username(""admin"").password(""password"").roles(""USER"",""ADMIN"").build()) return manager } @Order(1) (2) @Bean open fun apiFilterChain(http: HttpSecurity): SecurityFilterChain { http { securityMatcher(""/api/**"") (3) authorizeHttpRequests { authorize(anyRequest, hasRole(""ADMIN"")) } httpBasic { } } return http.build() } @Bean (4) open fun formLoginFilterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(anyRequest, authenticated) } formLogin { } } return http.build() } } 1 Configure Authentication as usual. 2 Create an instance of SecurityFilterChain that contains @Order to specify which SecurityFilterChain should be considered first. 3 The http.securityMatcher states that this HttpSecurity is applicable only to URLs that start with /api/ 4 Create another instance of SecurityFilterChain . If the URL does not start with /api/ , this configuration is used. This configuration is considered after apiFilterChain , since it has an @Order value after 1 (no @Order defaults to last)."
"https://docs.spring.io/spring-security/reference/6.3/servlet/configuration/xml-namespace.html","Security Namespace Configuration: Namespace configuration has been available since version 2.0 of the Spring Framework. It lets you supplement the traditional Spring beans application context syntax with elements from additional XML schema. You can find more information in the Spring Reference Documentation(https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/) . You can use a namespace element to more concisely configure an individual bean or, more powerfully, to define an alternative configuration syntax that more closely matches the problem domain and hides the underlying complexity from the user. A simple element can conceal the fact that multiple beans and processing steps are being added to the application context. For example, adding the following element from the security namespace to an application context starts up an embedded LDAP server for testing use within the application: <security:ldap-server /> This is much simpler than wiring up the equivalent Apache Directory Server beans. The most common alternative configuration requirements are supported by attributes on the ldap-server element, and the user is isolated from worrying about which beans they need to create and what the bean property names are. You can find out more about the use of the ldap-server element in the chapter on LDAP Authentication(../authentication/passwords/ldap.html#servlet-authentication-ldap) . A good XML editor while editing the application context file should provide information on the attributes and elements that are available. We recommend that you try the Spring Tool Suite(https://spring.io/tools/sts) , as it has special features for working with standard Spring namespaces. To start using the security namespace in your application context, add the spring-security-config jar to your classpath. Then, all you need to do is add the schema declaration to your application context file: <beans xmlns=""http://www.springframework.org/schema/beans"" xmlns:security=""http://www.springframework.org/schema/security"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/security https://www.springframework.org/schema/security/spring-security.xsd""> ... </beans> In many of the examples you can see (and in the sample applications), we often use security (rather than beans ) as the default namespace, which means we can omit the prefix on all the security namespace elements, making the content easier to read. You may also want to do this if you have your application context divided up into separate files and have most of your security configuration in one of them. Your security application context file would then start like this: <beans:beans xmlns=""http://www.springframework.org/schema/security"" xmlns:beans=""http://www.springframework.org/schema/beans"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/security https://www.springframework.org/schema/security/spring-security.xsd""> ... </beans:beans> We assume this syntax is being used from now on in this chapter. Design of the Namespace: The namespace is designed to capture the most common uses of the framework and provide a simplified and concise syntax for enabling them within an application. The design is based around the large-scale dependencies within the framework and can be divided up into the following areas: Web/HTTP Security is the most complex part. It sets up the filters and related service beans used to apply the framework authentication mechanisms, to secure URLs, render login and error pages, and much more. Business Object (Method) Security defines options for securing the service layer. AuthenticationManager handles authentication requests from other parts of the framework. AccessDecisionManager provides access decisions for web and method security. A default one is registered, but you can choose to use a custom one, declared with normal Spring bean syntax. AuthenticationProvider instances provide mechanisms against which the authentication manager authenticates users. The namespace provides supports for several standard options and a means of adding custom beans declared with a traditional syntax. UserDetailsService is closely related to authentication providers but is often also required by other beans. We see how to configure these in the following sections. Getting Started with Security Namespace Configuration: This section looks at how you can build up a namespace configuration to use some of the main features of the framework. We assume that you initially want to get up and running as quickly as possible and add authentication support and access control to an existing web application, with a few test logins. Then we look at how to change over to authenticating against a database or other security repository. In later sections, we introduce more advanced namespace configuration options. web.xml Configuration: The first thing you need to do is add the following filter declaration to your web.xml file: <filter> <filter-name>springSecurityFilterChain</filter-name> <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class> </filter> <filter-mapping> <filter-name>springSecurityFilterChain</filter-name> <url-pattern>/*</url-pattern> </filter-mapping> DelegatingFilterProxy is a Spring Framework class that delegates to a filter implementation that is defined as a Spring bean in your application context. In this case, the bean is named springSecurityFilterChain , which is an internal infrastructure bean created by the namespace to handle web security. In this case, the bean is named ""springSecurityFilterChain"", which is an internal infrastructure bean created by the namespace to handle web security. Note that you should not use this bean name yourself. Once you have added this bean to your web.xml , you are ready to start editing your application context file. Web security services are configured by the <http> element. A Minimal <http> Configuration: To enable web security, you need the following configuration: <http> <intercept-url pattern=""/**"" access=""hasRole('USER')"" /> <form-login /> <logout /> </http> That listing says that we want: All URLs within our application to be secured, requiring the role ROLE_USER to access them To log in to the application using a form with username and password A logout URL registered which will allow us to log out of the application The <http> element is the parent for all web-related namespace functionality. The <intercept-url> element defines a pattern , which is matched against the URLs of incoming requests using Ant path syntax. See the section on HttpFirewall(../exploits/firewall.html#servlet-httpfirewall) for more details on how matches are actually performed. You can also use regular-expression matching as an alternative (see the namespace appendix for more details). The access attribute defines the access requirements for requests that match the given pattern. With the default configuration, this is typically a comma-separated list of roles, one of which a user must have to be allowed to make the request. The ROLE_ prefix is a marker that indicates that a simple comparison with the user’s authorities should be made. In other words, a normal role-based check should be used. Access-control in Spring Security is not limited to the use of simple roles (hence the use of the prefix to differentiate between different types of security attributes). We see later how the interpretation can vary. The interpretation of the comma-separated values in the access attribute depends on the which implementation of the AccessDecisionManager(#ns-access-manager) is used. Since Spring Security 3.0, you can also populate the attribute with an EL expression(../authorization/authorize-http-requests.html#authorization-expressions) . You can use multiple <intercept-url> elements to define different access requirements for different sets of URLs, but they are evaluated in the order listed and the first match is used. So you must put the most specific matches at the top. You can also add a method attribute to limit the match to a particular HTTP method ( GET , POST , PUT , and so on). To add users, you can define a set of test data directly in the namespace: <authentication-manager> <authentication-provider> <user-service> <!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that NoOpPasswordEncoder should be used. This is not safe for production, but makes reading in samples easier. Normally passwords should be hashed using BCrypt --> <user name=""jimi"" password=""{noop}jimispassword"" authorities=""ROLE_USER, ROLE_ADMIN"" /> <user name=""bob"" password=""{noop}bobspassword"" authorities=""ROLE_USER"" /> </user-service> </authentication-provider> </authentication-manager> The preceding listing shows an example of a secure way to store the same passwords. The password is prefixed with {bcrypt} to instruct DelegatingPasswordEncoder , which supports any configured PasswordEncoder for matching, that the passwords are hashed using BCrypt: <authentication-manager> <authentication-provider> <user-service> <user name=""jimi"" password=""{bcrypt}$2a$10$ddEWZUl8aU0GdZPPpy7wbu82dvEw/pBpbRvDQRqA41y6mK1CoH00m"" authorities=""ROLE_USER, ROLE_ADMIN"" /> <user name=""bob"" password=""{bcrypt}$2a$10$/elFpMBnAYYig6KRR5bvOOYeZr1ie1hSogJryg9qDlhza4oCw1Qka"" authorities=""ROLE_USER"" /> <user name=""jimi"" password=""{noop}jimispassword"" authorities=""ROLE_USER, ROLE_ADMIN"" /> <user name=""bob"" password=""{noop}bobspassword"" authorities=""ROLE_USER"" /> </user-service> </authentication-provider> </authentication-manager> The <http> element is responsible for creating a FilterChainProxy and the filter beans that it uses. Previously common problems, such as incorrect filter ordering, are no longer an issue, as the filter positions are predefined. The <authentication-provider> element creates a DaoAuthenticationProvider bean, and the <user-service> element creates an InMemoryDaoImpl . All authentication-provider elements must be children of the <authentication-manager> element, which creates a ProviderManager and registers the authentication providers with it. You can find more detailed information on the beans that are created in the namespace appendix(../appendix/namespace/index.html#appendix-namespace) . You should cross-check this appendix if you want to start understanding what the important classes in the framework are and how they are used, particularly if you want to customize things later. The preceding configuration defines two users, their passwords, and their roles within the application (which are used for access control). You can also possible load user information from a standard properties file by setting the properties attribute on the user-service element. See the section on in-memory authentication(../authentication/passwords/in-memory.html#servlet-authentication-inmemory) for more details on the file format. Using the <authentication-provider> element means that the user information is used by the authentication manager to process authentication requests. You can have multiple <authentication-provider> elements to define different authentication sources. Each is consulted in turn. At this point, you should be able to start up your application, and you should be required to log in to proceed. Try it out, or try experimenting with the “tutorial” sample application that comes with the project. Setting a Default Post-Login Destination: If a form login is not prompted by an attempt to access a protected resource, the default-target-url option comes into play. This is the URL to which the user is taken after successfully logging in. it defaults to / . You can also configure things so that the user always ends up at this page (regardless of whether the login was “on-demand” or they explicitly chose to log in) by setting the always-use-default-target attribute to true . This is useful if your application always requires that the user starts at a “home” page, for example: <http pattern=""/login.htm*"" security=""none""/> <http use-expressions=""false""> <intercept-url pattern='/**' access='ROLE_USER' /> <form-login login-page='/login.htm' default-target-url='/home.htm' always-use-default-target='true' /> </http> For even more control over the destination, you can use the authentication-success-handler-ref attribute as an alternative to default-target-url . The referenced bean should be an instance of AuthenticationSuccessHandler . Advanced Web Features: This section covers various features that go beyond the basics. Adding in Your Own Filters: If you have used Spring Security before, you know that the framework maintains a chain of filters that it uses to apply its services. You may want to add your own filters to the stack at particular locations or use a Spring Security filter for which there is not currently a namespace configuration option (CAS, for example). Alternatively, you might want to use a customized version of a standard namespace filter, such as the UsernamePasswordAuthenticationFilter (which is created by the <form-login> element) to take advantage of some of the extra configuration options that are available when you use the bean explicitly. How can you do this with namespace configuration, since the filter chain is not directly exposed? The order of the filters is always strictly enforced when you use the namespace. When the application context is being created, the filter beans are sorted by the namespace handling code, and the standard Spring Security filters each have an alias in the namespace and a well-known position. In previous versions, the sorting took place after the filter instances had been created, during post-processing of the application context. In version 3.0+ the sorting is now done at the bean metadata level, before the classes have been instantiated. This has implications for how you add your own filters to the stack as the entire filter list must be known during the parsing of the <http> element, so the syntax has changed slightly in 3.0. The filters, aliases, and namespace elements and attributes that create the filters are shown in the following table, in the order in which they occur in the filter chain: Table 1. Standard Filter Aliases and Ordering Alias Filter Class Namespace Element or Attribute DISABLE_ENCODE_URL_FILTER DisableEncodeUrlFilter http@disable-url-rewriting FORCE_EAGER_SESSION_FILTER ForceEagerSessionCreationFilter http@create-session=""ALWAYS"" CHANNEL_FILTER ChannelProcessingFilter http/intercept-url@requires-channel SECURITY_CONTEXT_FILTER SecurityContextPersistenceFilter http CONCURRENT_SESSION_FILTER ConcurrentSessionFilter session-management/concurrency-control HEADERS_FILTER HeaderWriterFilter http/headers CSRF_FILTER CsrfFilter http/csrf LOGOUT_FILTER LogoutFilter http/logout X509_FILTER X509AuthenticationFilter http/x509 PRE_AUTH_FILTER AbstractPreAuthenticatedProcessingFilter Subclasses N/A CAS_FILTER CasAuthenticationFilter N/A FORM_LOGIN_FILTER UsernamePasswordAuthenticationFilter http/form-login BASIC_AUTH_FILTER BasicAuthenticationFilter http/http-basic SERVLET_API_SUPPORT_FILTER SecurityContextHolderAwareRequestFilter http/@servlet-api-provision JAAS_API_SUPPORT_FILTER JaasApiIntegrationFilter http/@jaas-api-provision REMEMBER_ME_FILTER RememberMeAuthenticationFilter http/remember-me ANONYMOUS_FILTER AnonymousAuthenticationFilter http/anonymous SESSION_MANAGEMENT_FILTER SessionManagementFilter session-management EXCEPTION_TRANSLATION_FILTER ExceptionTranslationFilter http FILTER_SECURITY_INTERCEPTOR FilterSecurityInterceptor http SWITCH_USER_FILTER SwitchUserFilter N/A You can add your own filter to the stack by using the custom-filter element and one of these names to specify the position at which your filter should appear: <http> <custom-filter position=""FORM_LOGIN_FILTER"" ref=""myFilter"" /> </http> <beans:bean id=""myFilter"" class=""com.mycompany.MySpecialAuthenticationFilter""/> You can also use the after or before attributes if you want your filter to be inserted before or after another filter in the stack. You can use FIRST and LAST with the position attribute to indicate that you want your filter to appear before or after the entire stack, respectively. Avoiding filter position conflicts If you insert a custom filter that may occupy the same position as one of the standard filters created by the namespace, you should not include the namespace versions by mistake. Remove any elements that create filters whose functionality you want to replace. Note that you cannot replace filters that are created by the use of the <http> element itself: SecurityContextPersistenceFilter , ExceptionTranslationFilter , or FilterSecurityInterceptor . By default, an AnonymousAuthenticationFilter is added and unless you have session-fixation protection(../authentication/session-management.html#ns-session-fixation) disabled, a SessionManagementFilter is also added to the filter chain. If you replace a namespace filter that requires an authentication entry point (that is, where the authentication process is triggered by an unauthenticated user’s attempt to access to a secured resource), you need to add a custom entry-point bean too. Method Security: Since version 2.0, Spring Security has substantial support for adding security to your service layer methods. It provides support for JSR-250 annotation security as well as the framework’s original @Secured annotation. Since version 3.0, you can also make use of expression-based annotations(../authorization/method-security.html#authorizing-with-annotations) . You can apply security to a single bean (by using the intercept-methods element to decorate the bean declaration), or you can secure multiple beans across the entire service layer using the AspectJ style pointcuts. The Default AccessDecisionManager: This section assumes that you have some knowledge of the underlying architecture for access-control within Spring Security. If you do not, you can skip it and come back to it later, as this section is relevant only for people who need to do some customization to use more than simple role-based security. When you use a namespace configuration, a default instance of AccessDecisionManager is automatically registered for you and is used to make access decisions for method invocations and web URL access, based on the access attributes you specify in your intercept-url and protect-pointcut declarations (and in annotations, if you use annotations to secure methods). The default strategy is to use an AffirmativeBased AccessDecisionManager with a RoleVoter and an AuthenticatedVoter . You can find out more about these in the chapter on authorization(../authorization/architecture.html#authz-arch) . Customizing the AccessDecisionManager: If you need to use a more complicated access control strategy, you can set an alternative for both method and web security. For method security, you do so by setting the access-decision-manager-ref attribute on global-method-security to the id of the appropriate AccessDecisionManager bean in the application context: <global-method-security access-decision-manager-ref=""myAccessDecisionManagerBean""> ... </global-method-security> The syntax for web security is the same, but the attribute is on the http element: <http access-decision-manager-ref=""myAccessDecisionManagerBean""> ... </http>"
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/index.html","Testing: This section describes the testing support provided by Spring Security. To use the Spring Security test support, you must include spring-security-test-6.3.3.jar as a dependency of your project. At a high level Spring Security’s test support provides integration for: Section Summary: Method Security(method.html) MockMvc Support(mockmvc/index.html) MockMvc Setup(mockmvc/setup.html) Security RequestPostProcessors(mockmvc/request-post-processors.html) Security RequestBuilders(mockmvc/request-builders.html) Security ResultMatchers(mockmvc/result-matchers.html) Security ResultHandlers(mockmvc/result-handlers.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/method.html","Testing Method Security: This section demonstrates how to use Spring Security’s Test support to test method-based security. We first introduce a MessageService that requires the user to be authenticated to be able to access it: Java Kotlin public class HelloMessageService implements MessageService { @PreAuthorize(""authenticated"") public String getMessage() { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); return ""Hello "" + authentication; } } class HelloMessageService : MessageService { @PreAuthorize(""authenticated"") fun getMessage(): String { val authentication: Authentication = SecurityContextHolder.getContext().authentication return ""Hello $authentication"" } } The result of getMessage is a String that says “Hello” to the current Spring Security Authentication . The following listing shows example output: Hello org.springframework.security.authentication.UsernamePasswordAuthenticationToken@ca25360: Principal: org.springframework.security.core.userdetails.User@36ebcb: Username: user; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_USER; Credentials: [PROTECTED]; Authenticated: true; Details: null; Granted Authorities: ROLE_USER Security Test Setup: Before we can use the Spring Security test support, we must perform some setup: Java Kotlin @ExtendWith(SpringExtension.class) (1) @ContextConfiguration (2) public class WithMockUserTests { // ... } @ExtendWith(SpringExtension.class) @ContextConfiguration class WithMockUserTests { // ... } 1 @ExtendWith instructs the spring-test module that it should create an ApplicationContext . For additional information, refer to the Spring reference(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html/testing.html#testcontext-junit-jupiter-extension) . 2 @ContextConfiguration instructs the spring-test the configuration to use to create the ApplicationContext . Since no configuration is specified, the default configuration locations will be tried. This is no different than using the existing Spring Test support. For additional information, refer to the Spring Reference(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html/testing.html#spring-testing-annotation-contextconfiguration) . Spring Security hooks into Spring Test support through the WithSecurityContextTestExecutionListener , which ensures that our tests are run with the correct user. It does this by populating the SecurityContextHolder prior to running our tests. If you use reactive method security, you also need ReactorContextTestExecutionListener , which populates ReactiveSecurityContextHolder . After the test is done, it clears out the SecurityContextHolder . If you need only Spring Security related support, you can replace @ContextConfiguration with @SecurityTestExecutionListeners . Remember, we added the @PreAuthorize annotation to our HelloMessageService , so it requires an authenticated user to invoke it. If we run the tests, we expect the following test will pass: Java Kotlin @Test(expected = AuthenticationCredentialsNotFoundException.class) public void getMessageUnauthenticated() { messageService.getMessage(); } @Test(expected = AuthenticationCredentialsNotFoundException::class) fun getMessageUnauthenticated() { messageService.getMessage() } @WithMockUser: The question is ""How could we most easily run the test as a specific user?"" The answer is to use @WithMockUser . The following test will be run as a user with the username ""user"", the password ""password"", and the roles ""ROLE_USER"". Java Kotlin @Test @WithMockUser public void getMessageWithMockUser() { String message = messageService.getMessage(); ... } @Test @WithMockUser fun getMessageWithMockUser() { val message: String = messageService.getMessage() // ... } Specifically the following is true: The user with a username of user does not have to exist, since we mock the user object. The Authentication that is populated in the SecurityContext is of type UsernamePasswordAuthenticationToken . The principal on the Authentication is Spring Security’s User object. The User has a username of user . The User has a password of password . A single GrantedAuthority named ROLE_USER is used. The preceding example is handy, because it lets us use a lot of defaults. What if we wanted to run the test with a different username? The following test would run with a username of customUser (again, the user does not need to actually exist): Java Kotlin @Test @WithMockUser(""customUsername"") public void getMessageWithMockUserCustomUsername() { String message = messageService.getMessage(); ... } @Test @WithMockUser(""customUsername"") fun getMessageWithMockUserCustomUsername() { val message: String = messageService.getMessage() // ... } We can also easily customize the roles. For example, the following test is invoked with a username of admin and roles of ROLE_USER and ROLE_ADMIN . Java Kotlin @Test @WithMockUser(username=""admin"",roles={""USER"",""ADMIN""}) public void getMessageWithMockUserCustomUser() { String message = messageService.getMessage(); ... } @Test @WithMockUser(username=""admin"",roles=[""USER"",""ADMIN""]) fun getMessageWithMockUserCustomUser() { val message: String = messageService.getMessage() // ... } If we do not want the value to automatically be prefixed with ROLE_ we can use the authorities attribute. For example, the following test is invoked with a username of admin and the USER and ADMIN authorities. Java Kotlin @Test @WithMockUser(username = ""admin"", authorities = { ""ADMIN"", ""USER"" }) public void getMessageWithMockUserCustomAuthorities() { String message = messageService.getMessage(); ... } @Test @WithMockUser(username = ""admin"", authorities = [""ADMIN"", ""USER""]) fun getMessageWithMockUserCustomUsername() { val message: String = messageService.getMessage() // ... } It can be a bit tedious to place the annotation on every test method. Instead, we can place the annotation at the class level. Then every test uses the specified user. The following example runs every test with a user whose username is admin , whose password is password , and who has the ROLE_USER and ROLE_ADMIN roles: Java Kotlin @ExtendWith(SpringExtension.class) @ContextConfiguration @WithMockUser(username=""admin"",roles={""USER"",""ADMIN""}) public class WithMockUserTests { // ... } @ExtendWith(SpringExtension.class) @ContextConfiguration @WithMockUser(username=""admin"",roles=[""USER"",""ADMIN""]) class WithMockUserTests { // ... } If you use JUnit 5’s @Nested test support, you can also place the annotation on the enclosing class to apply to all nested classes. The following example runs every test with a user whose username is admin , whose password is password , and who has the ROLE_USER and ROLE_ADMIN roles for both test methods. Java Kotlin @ExtendWith(SpringExtension.class) @ContextConfiguration @WithMockUser(username=""admin"",roles={""USER"",""ADMIN""}) public class WithMockUserTests { @Nested public class TestSuite1 { // ... all test methods use admin user } @Nested public class TestSuite2 { // ... all test methods use admin user } } @ExtendWith(SpringExtension::class) @ContextConfiguration @WithMockUser(username = ""admin"", roles = [""USER"", ""ADMIN""]) class WithMockUserTests { @Nested inner class TestSuite1 { // ... all test methods use admin user } @Nested inner class TestSuite2 { // ... all test methods use admin user } } By default, the SecurityContext is set during the TestExecutionListener.beforeTestMethod event. This is the equivalent of happening before JUnit’s @Before . You can change this to happen during the TestExecutionListener.beforeTestExecution event, which is after JUnit’s @Before but before the test method is invoked: @WithMockUser(setupBefore = TestExecutionEvent.TEST_EXECUTION) @WithAnonymousUser: Using @WithAnonymousUser allows running as an anonymous user. This is especially convenient when you wish to run most of your tests with a specific user but want to run a few tests as an anonymous user. The following example runs withMockUser1 and withMockUser2 by using @WithMockUser(#test-method-withmockuser) and anonymous as an anonymous user: Java Kotlin @ExtendWith(SpringExtension.class) @WithMockUser public class WithUserClassLevelAuthenticationTests { @Test public void withMockUser1() { } @Test public void withMockUser2() { } @Test @WithAnonymousUser public void anonymous() throws Exception { // override default to run as anonymous user } } @ExtendWith(SpringExtension.class) @WithMockUser class WithUserClassLevelAuthenticationTests { @Test fun withMockUser1() { } @Test fun withMockUser2() { } @Test @WithAnonymousUser fun anonymous() { // override default to run as anonymous user } } By default, the SecurityContext is set during the TestExecutionListener.beforeTestMethod event. This is the equivalent of happening before JUnit’s @Before . You can change this to happen during the TestExecutionListener.beforeTestExecution event, which is after JUnit’s @Before but before the test method is invoked: @WithAnonymousUser(setupBefore = TestExecutionEvent.TEST_EXECUTION) @WithUserDetails: While @WithMockUser is a convenient way to get started, it may not work in all instances. For example, some applications expect the Authentication principal to be of a specific type. This is done so that the application can refer to the principal as the custom type and reduce coupling on Spring Security. The custom principal is often returned by a custom UserDetailsService that returns an object that implements both UserDetails and the custom type. For situations like this, it is useful to create the test user by using a custom UserDetailsService . That is exactly what @WithUserDetails does. Assuming we have a UserDetailsService exposed as a bean, the following test is invoked with an Authentication of type UsernamePasswordAuthenticationToken and a principal that is returned from the UserDetailsService with the username of user : Java Kotlin @Test @WithUserDetails public void getMessageWithUserDetails() { String message = messageService.getMessage(); ... } @Test @WithUserDetails fun getMessageWithUserDetails() { val message: String = messageService.getMessage() // ... } We can also customize the username used to lookup the user from our UserDetailsService . For example, this test can be run with a principal that is returned from the UserDetailsService with the username of customUsername : Java Kotlin @Test @WithUserDetails(""customUsername"") public void getMessageWithUserDetailsCustomUsername() { String message = messageService.getMessage(); ... } @Test @WithUserDetails(""customUsername"") fun getMessageWithUserDetailsCustomUsername() { val message: String = messageService.getMessage() // ... } We can also provide an explicit bean name to look up the UserDetailsService . The following test looks up the username of customUsername by using the UserDetailsService with a bean name of myUserDetailsService : Java Kotlin @Test @WithUserDetails(value=""customUsername"", userDetailsServiceBeanName=""myUserDetailsService"") public void getMessageWithUserDetailsServiceBeanName() { String message = messageService.getMessage(); ... } @Test @WithUserDetails(value=""customUsername"", userDetailsServiceBeanName=""myUserDetailsService"") fun getMessageWithUserDetailsServiceBeanName() { val message: String = messageService.getMessage() // ... } As we did with @WithMockUser , we can also place our annotation at the class level so that every test uses the same user. However, unlike @WithMockUser , @WithUserDetails requires the user to exist. By default, the SecurityContext is set during the TestExecutionListener.beforeTestMethod event. This is the equivalent of happening before JUnit’s @Before . You can change this to happen during the TestExecutionListener.beforeTestExecution event, which is after JUnit’s @Before but before the test method is invoked: @WithUserDetails(setupBefore = TestExecutionEvent.TEST_EXECUTION) @WithSecurityContext: We have seen that @WithMockUser is an excellent choice if we do not use a custom Authentication principal. Next, we discovered that @WithUserDetails lets us use a custom UserDetailsService to create our Authentication principal but requires the user to exist. We now see an option that allows the most flexibility. We can create our own annotation that uses the @WithSecurityContext to create any SecurityContext we want. For example, we might create an annotation named @WithMockCustomUser : Java Kotlin @Retention(RetentionPolicy.RUNTIME) @WithSecurityContext(factory = WithMockCustomUserSecurityContextFactory.class) public @interface WithMockCustomUser { String username() default ""rob""; String name() default ""Rob Winch""; } @Retention(AnnotationRetention.RUNTIME) @WithSecurityContext(factory = WithMockCustomUserSecurityContextFactory::class) annotation class WithMockCustomUser(val username: String = ""rob"", val name: String = ""Rob Winch"") You can see that @WithMockCustomUser is annotated with the @WithSecurityContext annotation. This is what signals to Spring Security test support that we intend to create a SecurityContext for the test. The @WithSecurityContext annotation requires that we specify a SecurityContextFactory to create a new SecurityContext , given our @WithMockCustomUser annotation. The following listing shows our WithMockCustomUserSecurityContextFactory implementation: Java Kotlin public class WithMockCustomUserSecurityContextFactory implements WithSecurityContextFactory<WithMockCustomUser> { @Override public SecurityContext createSecurityContext(WithMockCustomUser customUser) { SecurityContext context = SecurityContextHolder.createEmptyContext(); CustomUserDetails principal = new CustomUserDetails(customUser.name(), customUser.username()); Authentication auth = UsernamePasswordAuthenticationToken.authenticated(principal, ""password"", principal.getAuthorities()); context.setAuthentication(auth); return context; } } class WithMockCustomUserSecurityContextFactory : WithSecurityContextFactory<WithMockCustomUser> { override fun createSecurityContext(customUser: WithMockCustomUser): SecurityContext { val context = SecurityContextHolder.createEmptyContext() val principal = CustomUserDetails(customUser.name, customUser.username) val auth: Authentication = UsernamePasswordAuthenticationToken(principal, ""password"", principal.authorities) context.authentication = auth return context } } We can now annotate a test class or a test method with our new annotation and Spring Security’s WithSecurityContextTestExecutionListener to ensure that our SecurityContext is populated appropriately. When creating your own WithSecurityContextFactory implementations, it is nice to know that they can be annotated with standard Spring annotations. For example, the WithUserDetailsSecurityContextFactory uses the @Autowired annotation to acquire the UserDetailsService : Java Kotlin final class WithUserDetailsSecurityContextFactory implements WithSecurityContextFactory<WithUserDetails> { private UserDetailsService userDetailsService; @Autowired public WithUserDetailsSecurityContextFactory(UserDetailsService userDetailsService) { this.userDetailsService = userDetailsService; } public SecurityContext createSecurityContext(WithUserDetails withUser) { String username = withUser.value(); Assert.hasLength(username, ""value() must be non-empty String""); UserDetails principal = userDetailsService.loadUserByUsername(username); Authentication authentication = UsernamePasswordAuthenticationToken.authenticated(principal, principal.getPassword(), principal.getAuthorities()); SecurityContext context = SecurityContextHolder.createEmptyContext(); context.setAuthentication(authentication); return context; } } class WithUserDetailsSecurityContextFactory @Autowired constructor(private val userDetailsService: UserDetailsService) : WithSecurityContextFactory<WithUserDetails> { override fun createSecurityContext(withUser: WithUserDetails): SecurityContext { val username: String = withUser.value Assert.hasLength(username, ""value() must be non-empty String"") val principal = userDetailsService.loadUserByUsername(username) val authentication: Authentication = UsernamePasswordAuthenticationToken(principal, principal.password, principal.authorities) val context = SecurityContextHolder.createEmptyContext() context.authentication = authentication return context } } By default, the SecurityContext is set during the TestExecutionListener.beforeTestMethod event. This is the equivalent of happening before JUnit’s @Before . You can change this to happen during the TestExecutionListener.beforeTestExecution event, which is after JUnit’s @Before but before the test method is invoked: @WithSecurityContext(setupBefore = TestExecutionEvent.TEST_EXECUTION) Test Meta Annotations: If you reuse the same user within your tests often, it is not ideal to have to repeatedly specify the attributes. For example, if you have many tests related to an administrative user with a username of admin and roles of ROLE_USER and ROLE_ADMIN , you have to write: Java Kotlin @WithMockUser(username=""admin"",roles={""USER"",""ADMIN""}) @WithMockUser(username=""admin"",roles=[""USER"",""ADMIN""]) Rather than repeating this everywhere, we can use a meta annotation. For example, we could create a meta annotation named WithMockAdmin : Java Kotlin @Retention(RetentionPolicy.RUNTIME) @WithMockUser(value=""rob"",roles=""ADMIN"") public @interface WithMockAdmin { } @Retention(AnnotationRetention.RUNTIME) @WithMockUser(value = ""rob"", roles = [""ADMIN""]) annotation class WithMockAdmin Now we can use @WithMockAdmin in the same way as the more verbose @WithMockUser . Meta annotations work with any of the testing annotations described above. For example, this means we could create a meta annotation for @WithUserDetails(""admin"") as well."
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/mockmvc/index.html","Spring MVC Test Integration: Spring Security provides comprehensive integration with Spring MVC Test(https://docs.spring.io/spring/docs/current/spring-framework-reference/html/testing.html#spring-mvc-test-framework)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/mockmvc/setup.html","Setting Up MockMvc and Spring Security: Spring Security’s testing support requires spring-test-4.1.3.RELEASE or greater. To use Spring Security with Spring MVC Test, add the Spring Security FilterChainProxy as a Filter . You also need to add Spring Security’s TestSecurityContextHolderPostProcessor to support Running as a User in Spring MVC Test with Annotations(#test-mockmvc-withmockuser) . To do so, use Spring Security’s SecurityMockMvcConfigurers.springSecurity() : Java Kotlin import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*; @ExtendWith(SpringExtension.class) @ContextConfiguration(classes = SecurityConfig.class) @WebAppConfiguration public class CsrfShowcaseTests { @Autowired private WebApplicationContext context; private MockMvc mvc; @BeforeEach public void setup() { mvc = MockMvcBuilders .webAppContextSetup(context) .apply(springSecurity()) (1) .build(); } // ... } @ExtendWith(SpringExtension.class) @ContextConfiguration(classes = [SecurityConfig::class]) @WebAppConfiguration class CsrfShowcaseTests { @Autowired private lateinit var context: WebApplicationContext private var mvc: MockMvc? = null @BeforeEach fun setup() { mvc = MockMvcBuilders .webAppContextSetup(context) .apply<DefaultMockMvcBuilder>(springSecurity()) (1) .build() } // ... } 1 SecurityMockMvcConfigurers.springSecurity() will perform all of the initial setup we need to integrate Spring Security with Spring MVC Test"
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/mockmvc/request-post-processors.html","SecurityMockMvcRequestPostProcessors: To use Spring Security’s RequestPostProcessor implementations, use the following static import: Java Kotlin import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*; import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.* Section Summary: Mocking Users(authentication.html) Mocking CSRF(csrf.html) Mocking Form Login(form-login.html) Mocking HTTP Basic(http-basic.html) Mocking OAuth2(oauth2.html) Mocking Logout(logout.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/mockmvc/authentication.html","Running a Test as a User in Spring MVC Test: It is often desirable to run tests as a specific user. There are two simple ways to populate the user: Running as a User in Spring MVC Test with RequestPostProcessor(#test-mockmvc-securitycontextholder-rpp) Running as a User in Spring MVC Test with Annotations(#running-as-a-user-in-spring-mvc-test-with-annotations) Running as a User in Spring MVC Test with RequestPostProcessor: You have a number of options to associate a user to the current HttpServletRequest . The following example runs as a user (which does not need to exist) whose username is user , whose password is password , and whose role is ROLE_USER : Java Kotlin mvc .perform(get(""/"").with(user(""user""))) mvc.get(""/"") { with(user(""user"")) } The support works by associating the user to the HttpServletRequest . To associate the request to the SecurityContextHolder , you need to ensure that the SecurityContextPersistenceFilter is associated with the MockMvc instance. You can do so in a number of ways: Invoking apply(springSecurity())(setup.html#test-mockmvc-setup) Adding Spring Security’s FilterChainProxy to MockMvc Manually adding SecurityContextPersistenceFilter to the MockMvc instance may make sense when using MockMvcBuilders.standaloneSetup You can easily make customizations. For example, the following will run as a user (which does not need to exist) with the username ""admin"", the password ""pass"", and the roles ""ROLE_USER"" and ""ROLE_ADMIN"". Java Kotlin mvc .perform(get(""/admin"").with(user(""admin"").password(""pass"").roles(""USER"",""ADMIN""))) mvc.get(""/admin"") { with(user(""admin"").password(""pass"").roles(""USER"",""ADMIN"")) } If you have a custom UserDetails that you would like to use, you can easily specify that as well. For example, the following will use the specified UserDetails (which does not need to exist) to run with a UsernamePasswordAuthenticationToken that has a principal of the specified UserDetails : Java Kotlin mvc .perform(get(""/"").with(user(userDetails))) mvc.get(""/"") { with(user(userDetails)) } You can run as anonymous user using the following: Java Kotlin mvc .perform(get(""/"").with(anonymous())) mvc.get(""/"") { with(anonymous()) } This is especially useful if you are running with a default user and wish to process a few requests as an anonymous user. If you want a custom Authentication (which does not need to exist) you can do so using the following: Java Kotlin mvc .perform(get(""/"").with(authentication(authentication))) mvc.get(""/"") { with(authentication(authentication)) } You can even customize the SecurityContext using the following: Java Kotlin mvc .perform(get(""/"").with(securityContext(securityContext))) mvc.get(""/"") { with(securityContext(securityContext)) } We can also ensure to run as a specific user for every request by using MockMvcBuilders 's default request. For example, the following will run as a user (which does not need to exist) with the username ""admin"", the password ""password"", and the role ""ROLE_ADMIN"": Java Kotlin mvc = MockMvcBuilders .webAppContextSetup(context) .defaultRequest(get(""/"").with(user(""user"").roles(""ADMIN""))) .apply(springSecurity()) .build(); mvc = MockMvcBuilders .webAppContextSetup(context) .defaultRequest<DefaultMockMvcBuilder>(get(""/"").with(user(""user"").roles(""ADMIN""))) .apply<DefaultMockMvcBuilder>(springSecurity()) .build() If you find you are using the same user in many of your tests, it is recommended to move the user to a method. For example, you can specify the following in your own class named CustomSecurityMockMvcRequestPostProcessors : Java Kotlin public static RequestPostProcessor rob() { return user(""rob"").roles(""ADMIN""); } fun rob(): RequestPostProcessor { return user(""rob"").roles(""ADMIN"") } Now you can perform a static import on CustomSecurityMockMvcRequestPostProcessors and use that within your tests: Java Kotlin import static sample.CustomSecurityMockMvcRequestPostProcessors.*; ... mvc .perform(get(""/"").with(rob())) import sample.CustomSecurityMockMvcRequestPostProcessors.* //... mvc.get(""/"") { with(rob()) } Running as a User in Spring MVC Test with Annotations: As an alternative to using a RequestPostProcessor to create your user, you can use annotations described in Testing Method Security(../method.html) . For example, the following will run the test with the user with username ""user"", password ""password"", and role ""ROLE_USER"": Java Kotlin @Test @WithMockUser public void requestProtectedUrlWithUser() throws Exception { mvc .perform(get(""/"")) ... } @Test @WithMockUser fun requestProtectedUrlWithUser() { mvc .get(""/"") // ... } Alternatively, the following will run the test with the user with username ""user"", password ""password"", and role ""ROLE_ADMIN"": Java Kotlin @Test @WithMockUser(roles=""ADMIN"") public void requestProtectedUrlWithUser() throws Exception { mvc .perform(get(""/"")) ... } @Test @WithMockUser(roles = [""ADMIN""]) fun requestProtectedUrlWithUser() { mvc .get(""/"") // ... }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/mockmvc/csrf.html","Testing with CSRF Protection: When testing any non-safe HTTP methods and using Spring Security’s CSRF protection, you must include a valid CSRF Token in the request. To specify a valid CSRF token as a request parameter use the CSRF RequestPostProcessor(request-post-processors.html) like so: Java Kotlin mvc .perform(post(""/"").with(csrf())) mvc.post(""/"") { with(csrf()) } If you like, you can include CSRF token in the header instead: Java Kotlin mvc .perform(post(""/"").with(csrf().asHeader())) mvc.post(""/"") { with(csrf().asHeader()) } You can also test providing an invalid CSRF token by using the following: Java Kotlin mvc .perform(post(""/"").with(csrf().useInvalidToken())) mvc.post(""/"") { with(csrf().useInvalidToken()) }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/mockmvc/form-login.html","Testing Form Based Authentication: You can easily create a request to test a form based authentication using Spring Security’s testing support. For example, the following formLogin RequestPostProcessor(request-post-processors.html) will submit a POST to ""/login"" with the username ""user"", the password ""password"", and a valid CSRF token: Java Kotlin mvc .perform(formLogin()) mvc .perform(formLogin()) It is easy to customize the request. For example, the following will submit a POST to ""/auth"" with the username ""admin"", the password ""pass"", and a valid CSRF token: Java Kotlin mvc .perform(formLogin(""/auth"").user(""admin"").password(""pass"")) mvc .perform(formLogin(""/auth"").user(""admin"").password(""pass"")) We can also customize the parameters names that the username and password are included on. For example, this is the above request modified to include the username on the HTTP parameter ""u"" and the password on the HTTP parameter ""p"". Java Kotlin mvc .perform(formLogin(""/auth"").user(""u"",""admin"").password(""p"",""pass"")) mvc .perform(formLogin(""/auth"").user(""u"",""admin"").password(""p"",""pass""))"
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/mockmvc/http-basic.html","Testing HTTP Basic Authentication: While it has always been possible to authenticate with HTTP Basic, it was a bit tedious to remember the header name, format, and encode the values. Now this can be done using Spring Security’s httpBasic RequestPostProcessor(request-post-processors.html) . For example, the snippet below: Java Kotlin mvc .perform(get(""/"").with(httpBasic(""user"",""password""))) mvc.get(""/"") { with(httpBasic(""user"",""password"")) } will attempt to use HTTP Basic to authenticate a user with the username ""user"" and the password ""password"" by ensuring the following header is populated on the HTTP Request: Authorization: Basic dXNlcjpwYXNzd29yZA=="
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/mockmvc/oauth2.html","Testing OAuth 2.0: When it comes to OAuth 2.0, the same principles covered earlier still apply: Ultimately, it depends on what your method under test is expecting to be in the SecurityContextHolder . For example, for a controller that looks like this: Java Kotlin @GetMapping(""/endpoint"") public String foo(Principal user) { return user.getName(); } @GetMapping(""/endpoint"") fun foo(user: Principal): String { return user.name } There’s nothing OAuth2-specific about it, so you will likely be able to simply use @WithMockUser(../method.html#test-method-withmockuser) and be fine. But, in cases where your controllers are bound to some aspect of Spring Security’s OAuth 2.0 support, like the following: Java Kotlin @GetMapping(""/endpoint"") public String foo(@AuthenticationPrincipal OidcUser user) { return user.getIdToken().getSubject(); } @GetMapping(""/endpoint"") fun foo(@AuthenticationPrincipal user: OidcUser): String { return user.idToken.subject } then Spring Security’s test support can come in handy. Testing OIDC Login: Testing the method above with Spring MVC Test would require simulating some kind of grant flow with an authorization server. Certainly this would be a daunting task, which is why Spring Security ships with support for removing this boilerplate. For example, we can tell Spring Security to include a default OidcUser using the oidcLogin RequestPostProcessor(request-post-processors.html) , like so: Java Kotlin mvc .perform(get(""/endpoint"").with(oidcLogin())); mvc.get(""/endpoint"") { with(oidcLogin()) } What this will do is configure the associated MockHttpServletRequest with an OidcUser that includes a simple OidcIdToken , OidcUserInfo , and Collection of granted authorities. Specifically, it will include an OidcIdToken with a sub claim set to user : Java Kotlin assertThat(user.getIdToken().getClaim(""sub"")).isEqualTo(""user""); assertThat(user.idToken.getClaim<String>(""sub"")).isEqualTo(""user"") an OidcUserInfo with no claims set: Java Kotlin assertThat(user.getUserInfo().getClaims()).isEmpty(); assertThat(user.userInfo.claims).isEmpty() and a Collection of authorities with just one authority, SCOPE_read : Java Kotlin assertThat(user.getAuthorities()).hasSize(1); assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority(""SCOPE_read"")); assertThat(user.authorities).hasSize(1) assertThat(user.authorities).containsExactly(SimpleGrantedAuthority(""SCOPE_read"")) Spring Security does the necessary work to make sure that the OidcUser instance is available for the @AuthenticationPrincipal annotation(../../integrations/mvc.html#mvc-authentication-principal) . Further, it also links that OidcUser to a simple instance of OAuth2AuthorizedClient that it deposits into an mock OAuth2AuthorizedClientRepository . This can be handy if your tests use the @RegisteredOAuth2AuthorizedClient annotation(#testing-oauth2-client) .. Configuring Authorities: In many circumstances, your method is protected by filter or method security and needs your Authentication to have certain granted authorities to allow the request. In this case, you can supply what granted authorities you need using the authorities() method: Java Kotlin mvc .perform(get(""/endpoint"") .with(oidcLogin() .authorities(new SimpleGrantedAuthority(""SCOPE_message:read"")) ) ); mvc.get(""/endpoint"") { with(oidcLogin() .authorities(SimpleGrantedAuthority(""SCOPE_message:read"")) ) } Configuring Claims: And while granted authorities are quite common across all of Spring Security, we also have claims in the case of OAuth 2.0. Let’s say, for example, that you’ve got a user_id claim that indicates the user’s id in your system. You might access it like so in a controller: Java Kotlin @GetMapping(""/endpoint"") public String foo(@AuthenticationPrincipal OidcUser oidcUser) { String userId = oidcUser.getIdToken().getClaim(""user_id""); // ... } @GetMapping(""/endpoint"") fun foo(@AuthenticationPrincipal oidcUser: OidcUser): String { val userId = oidcUser.idToken.getClaim<String>(""user_id"") // ... } In that case, you’d want to specify that claim with the idToken() method: Java Kotlin mvc .perform(get(""/endpoint"") .with(oidcLogin() .idToken(token -> token.claim(""user_id"", ""1234"")) ) ); mvc.get(""/endpoint"") { with(oidcLogin() .idToken { it.claim(""user_id"", ""1234"") } ) } since OidcUser collects its claims from OidcIdToken . Additional Configurations: There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects: userInfo(OidcUserInfo.Builder) - For configuring the OidcUserInfo instance clientRegistration(ClientRegistration) - For configuring the associated OAuth2AuthorizedClient with a given ClientRegistration oidcUser(OidcUser) - For configuring the complete OidcUser instance That last one is handy if you: 1. Have your own implementation of OidcUser , or 2. Need to change the name attribute For example, let’s say that your authorization server sends the principal name in the user_name claim instead of the sub claim. In that case, you can configure an OidcUser by hand: Java Kotlin OidcUser oidcUser = new DefaultOidcUser( AuthorityUtils.createAuthorityList(""SCOPE_message:read""), OidcIdToken.withTokenValue(""id-token"").claim(""user_name"", ""foo_user"").build(), ""user_name""); mvc .perform(get(""/endpoint"") .with(oidcLogin().oidcUser(oidcUser)) ); val oidcUser: OidcUser = DefaultOidcUser( AuthorityUtils.createAuthorityList(""SCOPE_message:read""), OidcIdToken.withTokenValue(""id-token"").claim(""user_name"", ""foo_user"").build(), ""user_name"" ) mvc.get(""/endpoint"") { with(oidcLogin().oidcUser(oidcUser)) } Testing OAuth 2.0 Login: As with testing OIDC login(#testing-oidc-login) , testing OAuth 2.0 Login presents a similar challenge of mocking a grant flow. And because of that, Spring Security also has test support for non-OIDC use cases. Let’s say that we’ve got a controller that gets the logged-in user as an OAuth2User : Java Kotlin @GetMapping(""/endpoint"") public String foo(@AuthenticationPrincipal OAuth2User oauth2User) { return oauth2User.getAttribute(""sub""); } @GetMapping(""/endpoint"") fun foo(@AuthenticationPrincipal oauth2User: OAuth2User): String? { return oauth2User.getAttribute(""sub"") } In that case, we can tell Spring Security to include a default OAuth2User using the oauth2Login RequestPostProcessor(request-post-processors.html) , like so: Java Kotlin mvc .perform(get(""/endpoint"").with(oauth2Login())); mvc.get(""/endpoint"") { with(oauth2Login()) } What this will do is configure the associated MockHttpServletRequest with an OAuth2User that includes a simple Map of attributes and Collection of granted authorities. Specifically, it will include a Map with a key/value pair of sub / user : Java Kotlin assertThat((String) user.getAttribute(""sub"")).isEqualTo(""user""); assertThat(user.getAttribute<String>(""sub"")).isEqualTo(""user"") and a Collection of authorities with just one authority, SCOPE_read : Java Kotlin assertThat(user.getAuthorities()).hasSize(1); assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority(""SCOPE_read"")); assertThat(user.authorities).hasSize(1) assertThat(user.authorities).containsExactly(SimpleGrantedAuthority(""SCOPE_read"")) Spring Security does the necessary work to make sure that the OAuth2User instance is available for the @AuthenticationPrincipal annotation(../../integrations/mvc.html#mvc-authentication-principal) . Further, it also links that OAuth2User to a simple instance of OAuth2AuthorizedClient that it deposits in a mock OAuth2AuthorizedClientRepository . This can be handy if your tests use the @RegisteredOAuth2AuthorizedClient annotation(#testing-oauth2-client) . Configuring Authorities: In many circumstances, your method is protected by filter or method security and needs your Authentication to have certain granted authorities to allow the request. In this case, you can supply what granted authorities you need using the authorities() method: Java Kotlin mvc .perform(get(""/endpoint"") .with(oauth2Login() .authorities(new SimpleGrantedAuthority(""SCOPE_message:read"")) ) ); mvc.get(""/endpoint"") { with(oauth2Login() .authorities(SimpleGrantedAuthority(""SCOPE_message:read"")) ) } Configuring Claims: And while granted authorities are quite common across all of Spring Security, we also have claims in the case of OAuth 2.0. Let’s say, for example, that you’ve got a user_id attribute that indicates the user’s id in your system. You might access it like so in a controller: Java Kotlin @GetMapping(""/endpoint"") public String foo(@AuthenticationPrincipal OAuth2User oauth2User) { String userId = oauth2User.getAttribute(""user_id""); // ... } @GetMapping(""/endpoint"") fun foo(@AuthenticationPrincipal oauth2User: OAuth2User): String { val userId = oauth2User.getAttribute<String>(""user_id"") // ... } In that case, you’d want to specify that attribute with the attributes() method: Java Kotlin mvc .perform(get(""/endpoint"") .with(oauth2Login() .attributes(attrs -> attrs.put(""user_id"", ""1234"")) ) ); mvc.get(""/endpoint"") { with(oauth2Login() .attributes { attrs -> attrs[""user_id""] = ""1234"" } ) } Additional Configurations: There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects: clientRegistration(ClientRegistration) - For configuring the associated OAuth2AuthorizedClient with a given ClientRegistration oauth2User(OAuth2User) - For configuring the complete OAuth2User instance That last one is handy if you: 1. Have your own implementation of OAuth2User , or 2. Need to change the name attribute For example, let’s say that your authorization server sends the principal name in the user_name claim instead of the sub claim. In that case, you can configure an OAuth2User by hand: Java Kotlin OAuth2User oauth2User = new DefaultOAuth2User( AuthorityUtils.createAuthorityList(""SCOPE_message:read""), Collections.singletonMap(""user_name"", ""foo_user""), ""user_name""); mvc .perform(get(""/endpoint"") .with(oauth2Login().oauth2User(oauth2User)) ); val oauth2User: OAuth2User = DefaultOAuth2User( AuthorityUtils.createAuthorityList(""SCOPE_message:read""), mapOf(Pair(""user_name"", ""foo_user"")), ""user_name"" ) mvc.get(""/endpoint"") { with(oauth2Login().oauth2User(oauth2User)) } Testing OAuth 2.0 Clients: Independent of how your user authenticates, you may have other tokens and client registrations that are in play for the request you are testing. For example, your controller may be relying on the client credentials grant to get a token that isn’t associated with the user at all: Java Kotlin @GetMapping(""/endpoint"") public String foo(@RegisteredOAuth2AuthorizedClient(""my-app"") OAuth2AuthorizedClient authorizedClient) { return this.webClient.get() .attributes(oauth2AuthorizedClient(authorizedClient)) .retrieve() .bodyToMono(String.class) .block(); } @GetMapping(""/endpoint"") fun foo(@RegisteredOAuth2AuthorizedClient(""my-app"") authorizedClient: OAuth2AuthorizedClient?): String? { return this.webClient.get() .attributes(oauth2AuthorizedClient(authorizedClient)) .retrieve() .bodyToMono(String::class.java) .block() } Simulating this handshake with the authorization server could be cumbersome. Instead, you can use the oauth2Client RequestPostProcessor(request-post-processors.html) to add a OAuth2AuthorizedClient into a mock OAuth2AuthorizedClientRepository : Java Kotlin mvc .perform(get(""/endpoint"").with(oauth2Client(""my-app""))); mvc.get(""/endpoint"") { with( oauth2Client(""my-app"") ) } What this will do is create an OAuth2AuthorizedClient that has a simple ClientRegistration , OAuth2AccessToken , and resource owner name. Specifically, it will include a ClientRegistration with a client id of ""test-client"" and client secret of ""test-secret"": Java Kotlin assertThat(authorizedClient.getClientRegistration().getClientId()).isEqualTo(""test-client""); assertThat(authorizedClient.getClientRegistration().getClientSecret()).isEqualTo(""test-secret""); assertThat(authorizedClient.clientRegistration.clientId).isEqualTo(""test-client"") assertThat(authorizedClient.clientRegistration.clientSecret).isEqualTo(""test-secret"") a resource owner name of ""user"": Java Kotlin assertThat(authorizedClient.getPrincipalName()).isEqualTo(""user""); assertThat(authorizedClient.principalName).isEqualTo(""user"") and an OAuth2AccessToken with just one scope, read : Java Kotlin assertThat(authorizedClient.getAccessToken().getScopes()).hasSize(1); assertThat(authorizedClient.getAccessToken().getScopes()).containsExactly(""read""); assertThat(authorizedClient.accessToken.scopes).hasSize(1) assertThat(authorizedClient.accessToken.scopes).containsExactly(""read"") The client can then be retrieved as normal using @RegisteredOAuth2AuthorizedClient in a controller method. Configuring Scopes: In many circumstances, the OAuth 2.0 access token comes with a set of scopes. If your controller inspects these, say like so: Java Kotlin @GetMapping(""/endpoint"") public String foo(@RegisteredOAuth2AuthorizedClient(""my-app"") OAuth2AuthorizedClient authorizedClient) { Set<String> scopes = authorizedClient.getAccessToken().getScopes(); if (scopes.contains(""message:read"")) { return this.webClient.get() .attributes(oauth2AuthorizedClient(authorizedClient)) .retrieve() .bodyToMono(String.class) .block(); } // ... } @GetMapping(""/endpoint"") fun foo(@RegisteredOAuth2AuthorizedClient(""my-app"") authorizedClient: OAuth2AuthorizedClient): String? { val scopes = authorizedClient.accessToken.scopes if (scopes.contains(""message:read"")) { return webClient.get() .attributes(oauth2AuthorizedClient(authorizedClient)) .retrieve() .bodyToMono(String::class.java) .block() } // ... } then you can configure the scope using the accessToken() method: Java Kotlin mvc .perform(get(""/endpoint"") .with(oauth2Client(""my-app"") .accessToken(new OAuth2AccessToken(BEARER, ""token"", null, null, Collections.singleton(""message:read"")))) ) ); mvc.get(""/endpoint"") { with(oauth2Client(""my-app"") .accessToken(OAuth2AccessToken(BEARER, ""token"", null, null, Collections.singleton(""message:read""))) ) } Additional Configurations: There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects: principalName(String) - For configuring the resource owner name clientRegistration(Consumer<ClientRegistration.Builder>) - For configuring the associated ClientRegistration clientRegistration(ClientRegistration) - For configuring the complete ClientRegistration That last one is handy if you want to use a real ClientRegistration For example, let’s say that you are wanting to use one of your app’s ClientRegistration definitions, as specified in your application.yml . In that case, your test can autowire the ClientRegistrationRepository and look up the one your test needs: Java Kotlin @Autowired ClientRegistrationRepository clientRegistrationRepository; // ... mvc .perform(get(""/endpoint"") .with(oauth2Client() .clientRegistration(this.clientRegistrationRepository.findByRegistrationId(""facebook"")))); @Autowired lateinit var clientRegistrationRepository: ClientRegistrationRepository // ... mvc.get(""/endpoint"") { with(oauth2Client(""my-app"") .clientRegistration(clientRegistrationRepository.findByRegistrationId(""facebook"")) ) } Testing JWT Authentication: In order to make an authorized request on a resource server, you need a bearer token. If your resource server is configured for JWTs, then this would mean that the bearer token needs to be signed and then encoded according to the JWT specification. All of this can be quite daunting, especially when this isn’t the focus of your test. Fortunately, there are a number of simple ways that you can overcome this difficulty and allow your tests to focus on authorization and not on representing bearer tokens. We’ll look at two of them now: jwt() RequestPostProcessor: The first way is via the jwt RequestPostProcessor(request-post-processors.html) . The simplest of these would look something like this: Java Kotlin mvc .perform(get(""/endpoint"").with(jwt())); mvc.get(""/endpoint"") { with(jwt()) } What this will do is create a mock Jwt , passing it correctly through any authentication APIs so that it’s available for your authorization mechanisms to verify. By default, the JWT that it creates has the following characteristics: { ""headers"" : { ""alg"" : ""none"" }, ""claims"" : { ""sub"" : ""user"", ""scope"" : ""read"" } } And the resulting Jwt , were it tested, would pass in the following way: Java Kotlin assertThat(jwt.getTokenValue()).isEqualTo(""token""); assertThat(jwt.getHeaders().get(""alg"")).isEqualTo(""none""); assertThat(jwt.getSubject()).isEqualTo(""sub""); assertThat(jwt.tokenValue).isEqualTo(""token"") assertThat(jwt.headers[""alg""]).isEqualTo(""none"") assertThat(jwt.subject).isEqualTo(""sub"") These values can, of course be configured. Any headers or claims can be configured with their corresponding methods: Java Kotlin mvc .perform(get(""/endpoint"") .with(jwt().jwt(jwt -> jwt.header(""kid"", ""one"").claim(""iss"", ""https://idp.example.org"")))); mvc.get(""/endpoint"") { with( jwt().jwt { jwt -> jwt.header(""kid"", ""one"").claim(""iss"", ""https://idp.example.org"") } ) } Java Kotlin mvc .perform(get(""/endpoint"") .with(jwt().jwt(jwt -> jwt.claims(claims -> claims.remove(""scope""))))); mvc.get(""/endpoint"") { with( jwt().jwt { jwt -> jwt.claims { claims -> claims.remove(""scope"") } } ) } The scope and scp claims are processed the same way here as they are in a normal bearer token request. However, this can be overridden simply by providing the list of GrantedAuthority instances that you need for your test: Java Kotlin mvc .perform(get(""/endpoint"") .with(jwt().authorities(new SimpleGrantedAuthority(""SCOPE_messages"")))); mvc.get(""/endpoint"") { with( jwt().authorities(SimpleGrantedAuthority(""SCOPE_messages"")) ) } Or, if you have a custom Jwt to Collection<GrantedAuthority> converter, you can also use that to derive the authorities: Java Kotlin mvc .perform(get(""/endpoint"") .with(jwt().authorities(new MyConverter()))); mvc.get(""/endpoint"") { with( jwt().authorities(MyConverter()) ) } You can also specify a complete Jwt , for which Jwt.Builder(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/jwt/Jwt.Builder.html) comes quite handy: Java Kotlin Jwt jwt = Jwt.withTokenValue(""token"") .header(""alg"", ""none"") .claim(""sub"", ""user"") .claim(""scope"", ""read"") .build(); mvc .perform(get(""/endpoint"") .with(jwt().jwt(jwt))); val jwt: Jwt = Jwt.withTokenValue(""token"") .header(""alg"", ""none"") .claim(""sub"", ""user"") .claim(""scope"", ""read"") .build() mvc.get(""/endpoint"") { with( jwt().jwt(jwt) ) } authentication() RequestPostProcessor: The second way is by using the authentication() RequestPostProcessor(request-post-processors.html) . Essentially, you can instantiate your own JwtAuthenticationToken and provide it in your test, like so: Java Kotlin Jwt jwt = Jwt.withTokenValue(""token"") .header(""alg"", ""none"") .claim(""sub"", ""user"") .build(); Collection<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList(""SCOPE_read""); JwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities); mvc .perform(get(""/endpoint"") .with(authentication(token))); val jwt = Jwt.withTokenValue(""token"") .header(""alg"", ""none"") .claim(""sub"", ""user"") .build() val authorities: Collection<GrantedAuthority> = AuthorityUtils.createAuthorityList(""SCOPE_read"") val token = JwtAuthenticationToken(jwt, authorities) mvc.get(""/endpoint"") { with( authentication(token) ) } Note that as an alternative to these, you can also mock the JwtDecoder bean itself with a @MockBean annotation. Testing Opaque Token Authentication: Similar to JWTs(#testing-jwt) , opaque tokens require an authorization server in order to verify their validity, which can make testing more difficult. To help with that, Spring Security has test support for opaque tokens. Let’s say that we’ve got a controller that retrieves the authentication as a BearerTokenAuthentication : Java Kotlin @GetMapping(""/endpoint"") public String foo(BearerTokenAuthentication authentication) { return (String) authentication.getTokenAttributes().get(""sub""); } @GetMapping(""/endpoint"") fun foo(authentication: BearerTokenAuthentication): String { return authentication.tokenAttributes[""sub""] as String } In that case, we can tell Spring Security to include a default BearerTokenAuthentication using the opaqueToken RequestPostProcessor(request-post-processors.html) method, like so: Java Kotlin mvc .perform(get(""/endpoint"").with(opaqueToken())); mvc.get(""/endpoint"") { with(opaqueToken()) } What this will do is configure the associated MockHttpServletRequest with a BearerTokenAuthentication that includes a simple OAuth2AuthenticatedPrincipal , Map of attributes, and Collection of granted authorities. Specifically, it will include a Map with a key/value pair of sub / user : Java Kotlin assertThat((String) token.getTokenAttributes().get(""sub"")).isEqualTo(""user""); assertThat(token.tokenAttributes[""sub""] as String).isEqualTo(""user"") and a Collection of authorities with just one authority, SCOPE_read : Java Kotlin assertThat(token.getAuthorities()).hasSize(1); assertThat(token.getAuthorities()).containsExactly(new SimpleGrantedAuthority(""SCOPE_read"")); assertThat(token.authorities).hasSize(1) assertThat(token.authorities).containsExactly(SimpleGrantedAuthority(""SCOPE_read"")) Spring Security does the necessary work to make sure that the BearerTokenAuthentication instance is available for your controller methods. Configuring Authorities: In many circumstances, your method is protected by filter or method security and needs your Authentication to have certain granted authorities to allow the request. In this case, you can supply what granted authorities you need using the authorities() method: Java Kotlin mvc .perform(get(""/endpoint"") .with(opaqueToken() .authorities(new SimpleGrantedAuthority(""SCOPE_message:read"")) ) ); mvc.get(""/endpoint"") { with(opaqueToken() .authorities(SimpleGrantedAuthority(""SCOPE_message:read"")) ) } Configuring Claims: And while granted authorities are quite common across all of Spring Security, we also have attributes in the case of OAuth 2.0. Let’s say, for example, that you’ve got a user_id attribute that indicates the user’s id in your system. You might access it like so in a controller: Java Kotlin @GetMapping(""/endpoint"") public String foo(BearerTokenAuthentication authentication) { String userId = (String) authentication.getTokenAttributes().get(""user_id""); // ... } @GetMapping(""/endpoint"") fun foo(authentication: BearerTokenAuthentication): String { val userId = authentication.tokenAttributes[""user_id""] as String // ... } In that case, you’d want to specify that attribute with the attributes() method: Java Kotlin mvc .perform(get(""/endpoint"") .with(opaqueToken() .attributes(attrs -> attrs.put(""user_id"", ""1234"")) ) ); mvc.get(""/endpoint"") { with(opaqueToken() .attributes { attrs -> attrs[""user_id""] = ""1234"" } ) } Additional Configurations: There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects. One such is principal(OAuth2AuthenticatedPrincipal) , which you can use to configure the complete OAuth2AuthenticatedPrincipal instance that underlies the BearerTokenAuthentication It’s handy if you: 1. Have your own implementation of OAuth2AuthenticatedPrincipal , or 2. Want to specify a different principal name For example, let’s say that your authorization server sends the principal name in the user_name attribute instead of the sub attribute. In that case, you can configure an OAuth2AuthenticatedPrincipal by hand: Java Kotlin Map<String, Object> attributes = Collections.singletonMap(""user_name"", ""foo_user""); OAuth2AuthenticatedPrincipal principal = new DefaultOAuth2AuthenticatedPrincipal( (String) attributes.get(""user_name""), attributes, AuthorityUtils.createAuthorityList(""SCOPE_message:read"")); mvc .perform(get(""/endpoint"") .with(opaqueToken().principal(principal)) ); val attributes: Map<String, Any> = Collections.singletonMap(""user_name"", ""foo_user"") val principal: OAuth2AuthenticatedPrincipal = DefaultOAuth2AuthenticatedPrincipal( attributes[""user_name""] as String?, attributes, AuthorityUtils.createAuthorityList(""SCOPE_message:read"") ) mvc.get(""/endpoint"") { with(opaqueToken().principal(principal)) } Note that as an alternative to using opaqueToken() test support, you can also mock the OpaqueTokenIntrospector bean itself with a @MockBean annotation."
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/mockmvc/logout.html","Testing Logout: While fairly trivial using standard Spring MVC Test, you can use Spring Security’s testing support to make testing log out easier. For example, the following logout RequestPostProcessor(request-post-processors.html) will submit a POST to ""/logout"" with a valid CSRF token: Java Kotlin mvc .perform(logout()) mvc .perform(logout()) You can also customize the URL to post to. For example, the snippet below will submit a POST to ""/signout"" with a valid CSRF token: Java Kotlin mvc .perform(logout(""/signout"")) mvc .perform(logout(""/signout""))"
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/mockmvc/request-builders.html","SecurityMockMvcRequestBuilders: Spring MVC Test also provides a RequestBuilder interface that can be used to create the MockHttpServletRequest used in your test. Spring Security provides a few RequestBuilder implementations that can be used to make testing easier. In order to use Spring Security’s RequestBuilder implementations ensure the following static import is used: Java Kotlin import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.*; import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.*"
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/mockmvc/result-matchers.html","SecurityMockMvcResultMatchers: At times it is desirable to make various security related assertions about a request. To accommodate this need, Spring Security Test support implements Spring MVC Test’s ResultMatcher interface. In order to use Spring Security’s ResultMatcher implementations ensure the following static import is used: Java Kotlin import static org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.*; import org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.* Unauthenticated Assertion: At times it may be valuable to assert that there is no authenticated user associated with the result of a MockMvc invocation. For example, you might want to test submitting an invalid username and password and verify that no user is authenticated. You can easily do this with Spring Security’s testing support using something like the following: Java Kotlin mvc .perform(formLogin().password(""invalid"")) .andExpect(unauthenticated()); mvc .perform(formLogin().password(""invalid"")) .andExpect { unauthenticated() } Authenticated Assertion: It is often times that we must assert that an authenticated user exists. For example, we may want to verify that we authenticated successfully. We could verify that a form based login was successful with the following snippet of code: Java Kotlin mvc .perform(formLogin()) .andExpect(authenticated()); mvc .perform(formLogin()) .andExpect { authenticated() } If we wanted to assert the roles of the user, we could refine our previous code as shown below: Java Kotlin mvc .perform(formLogin().user(""admin"")) .andExpect(authenticated().withRoles(""USER"",""ADMIN"")); mvc .perform(formLogin()) .andExpect { authenticated().withRoles(""USER"",""ADMIN"") } Alternatively, we could verify the username: Java Kotlin mvc .perform(formLogin().user(""admin"")) .andExpect(authenticated().withUsername(""admin"")); mvc .perform(formLogin().user(""admin"")) .andExpect { authenticated().withUsername(""admin"") } We can also combine the assertions: Java Kotlin mvc .perform(formLogin().user(""admin"")) .andExpect(authenticated().withUsername(""admin"").withRoles(""USER"", ""ADMIN"")); mvc .perform(formLogin().user(""admin"")) .andExpect { authenticated().withUsername(""admin"").withRoles(""USER"", ""ADMIN"") } We can also make arbitrary assertions on the authentication Java Kotlin mvc .perform(formLogin()) .andExpect(authenticated().withAuthentication(auth -> assertThat(auth).isInstanceOf(UsernamePasswordAuthenticationToken.class))); mvc .perform(formLogin()) .andExpect { authenticated().withAuthentication { auth -> assertThat(auth).isInstanceOf(UsernamePasswordAuthenticationToken::class.java) } } }"
"https://docs.spring.io/spring-security/reference/6.3/servlet/test/mockmvc/result-handlers.html","SecurityMockMvcResultHandlers: Spring Security provides a few ResultHandler s implementations. In order to use Spring Security’s ResultHandler s implementations ensure the following static import is used: import static org.springframework.security.test.web.servlet.response.SecurityMockMvcResultHandlers.*; Exporting the SecurityContext: Often times we want to query a repository to see if some MockMvc request actually persisted in the database. In some cases our repository query uses the Spring Data Integration(../../../features/integrations/data.html) to filter the results based on current user’s username or any other property. Let’s see an example: A repository interface: private interface MessageRepository extends JpaRepository<Message, Long> { @Query(""SELECT m.content FROM Message m WHERE m.sentBy = ?#{ principal?.name }"") List<String> findAllUserMessages(); } Our test scenario: mvc .perform(post(""/message"") .content(""New Message"") .contentType(MediaType.TEXT_PLAIN) ) .andExpect(status().isOk()); List<String> userMessages = messageRepository.findAllUserMessages(); assertThat(userMessages).hasSize(1); This test won’t pass because after our request finishes, the SecurityContextHolder will be cleared out by the filter chain. We can then export the TestSecurityContextHolder to our SecurityContextHolder and use it as we want: mvc .perform(post(""/message"") .content(""New Message"") .contentType(MediaType.TEXT_PLAIN) ) .andDo(exportTestSecurityContext()) .andExpect(status().isOk()); List<String> userMessages = messageRepository.findAllUserMessages(); assertThat(userMessages).hasSize(1); Remember to clear the SecurityContextHolder between your tests, or it may leak amongst them"
"https://docs.spring.io/spring-security/reference/6.3/servlet/appendix/index.html","Appendix: This is an appendix for Servlet based Spring Security. It has the following sections: Database Schemas(database-schema.html) XML Namespace(namespace/index.html) FAQ(faq.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/appendix/database-schema.html","Security Database Schema: DDL statements are given for the HSQLDB database. You can use these as a guideline for defining the schema for the database you are using. User Schema: The standard JDBC implementation of the UserDetailsService ( JdbcDaoImpl ) requires tables to load the password, account status (enabled or disabled) and a list of authorities (roles) for the user. You can use these as a guideline for defining the schema for the database you use. create table users( username varchar_ignorecase(50) not null primary key, password varchar_ignorecase(50) not null, enabled boolean not null ); create table authorities ( username varchar_ignorecase(50) not null, authority varchar_ignorecase(50) not null, constraint fk_authorities_users foreign key(username) references users(username) ); create unique index ix_auth_username on authorities (username,authority); For Oracle database: The following listing shows the Oracle variant of the schema creation commands: CREATE TABLE USERS ( USERNAME NVARCHAR2(128) PRIMARY KEY, PASSWORD NVARCHAR2(128) NOT NULL, ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL ); CREATE TABLE AUTHORITIES ( USERNAME NVARCHAR2(128) NOT NULL, AUTHORITY NVARCHAR2(128) NOT NULL ); ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY); ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE; Group Authorities: Spring Security 2.0 introduced support for group authorities in JdbcDaoImpl . The table structure if groups are enabled is as follows. You need to adjust the following schema to match the database dialect you use: create table groups ( id bigint generated by default as identity(start with 0) primary key, group_name varchar_ignorecase(50) not null ); create table group_authorities ( group_id bigint not null, authority varchar(50) not null, constraint fk_group_authorities_group foreign key(group_id) references groups(id) ); create table group_members ( id bigint generated by default as identity(start with 0) primary key, username varchar(50) not null, group_id bigint not null, constraint fk_group_members_group foreign key(group_id) references groups(id) ); Remember that these tables are required only if you us the provided JDBC UserDetailsService implementation. If you write your own or choose to implement AuthenticationProvider without a UserDetailsService , you have complete freedom over how you store the data, as long as the interface contract is satisfied. Persistent Login (Remember-Me) Schema: This table is used to store the data used by the more secure persistent token(#remember-me-persistent-token) remember-me implementation. If you use JdbcTokenRepositoryImpl either directly or through the namespace, you need this table. Remember to adjust this schema to match the database dialect you use: create table persistent_logins ( username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null ); ACL Schema: The Spring Security ACL(../authorization/acls.html#domain-acls) implementation uses four tables. acl_sid stores the security identities recognised by the ACL system. These can be unique principals or authorities, which may apply to multiple principals. acl_class defines the domain object types to which ACLs apply. The class column stores the Java class name of the object. acl_object_identity stores the object identity definitions of specific domain objects. acl_entry stores the ACL permissions, each of which applies to a specific object identity and security identity. We assume that the database auto-generates the primary keys for each of the identities. The JdbcMutableAclService has to be able to retrieve these when it has created a new row in the acl_sid or acl_class tables. It has two properties that define the SQL needed to retrieve these values classIdentityQuery and sidIdentityQuery . Both of these default to call identity() The ACL artifact JAR contains files for creating the ACL schema in HyperSQL (HSQLDB), PostgreSQL, MySQL/MariaDB, Microsoft SQL Server, and Oracle Database. These schemas are also demonstrated in the following sections. HyperSQL: The default schema works with the embedded HSQLDB database that is used in unit tests within the framework. create table acl_sid( id bigint generated by default as identity(start with 100) not null primary key, principal boolean not null, sid varchar_ignorecase(100) not null, constraint unique_uk_1 unique(sid,principal) ); create table acl_class( id bigint generated by default as identity(start with 100) not null primary key, class varchar_ignorecase(100) not null, constraint unique_uk_2 unique(class) ); create table acl_object_identity( id bigint generated by default as identity(start with 100) not null primary key, object_id_class bigint not null, object_id_identity varchar_ignorecase(36) not null, parent_object bigint, owner_sid bigint, entries_inheriting boolean not null, constraint unique_uk_3 unique(object_id_class,object_id_identity), constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id), constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id), constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id) ); create table acl_entry( id bigint generated by default as identity(start with 100) not null primary key, acl_object_identity bigint not null, ace_order int not null, sid bigint not null, mask integer not null, granting boolean not null, audit_success boolean not null, audit_failure boolean not null, constraint unique_uk_4 unique(acl_object_identity,ace_order), constraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id), constraint foreign_fk_5 foreign key(sid) references acl_sid(id) ); PostgreSQL: For PostgreSQL, you have to set the classIdentityQuery and sidIdentityQuery properties of JdbcMutableAclService to the following values, respectively: select currval(pg_get_serial_sequence('acl_class', 'id')) select currval(pg_get_serial_sequence('acl_sid', 'id')) create table acl_sid( id bigserial not null primary key, principal boolean not null, sid varchar(100) not null, constraint unique_uk_1 unique(sid,principal) ); create table acl_class( id bigserial not null primary key, class varchar(100) not null, constraint unique_uk_2 unique(class) ); create table acl_object_identity( id bigserial primary key, object_id_class bigint not null, object_id_identity varchar(36) not null, parent_object bigint, owner_sid bigint, entries_inheriting boolean not null, constraint unique_uk_3 unique(object_id_class,object_id_identity), constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id), constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id), constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id) ); create table acl_entry( id bigserial primary key, acl_object_identity bigint not null, ace_order int not null, sid bigint not null, mask integer not null, granting boolean not null, audit_success boolean not null, audit_failure boolean not null, constraint unique_uk_4 unique(acl_object_identity,ace_order), constraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id), constraint foreign_fk_5 foreign key(sid) references acl_sid(id) ); MySQL and MariaDB: CREATE TABLE acl_sid ( id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, principal BOOLEAN NOT NULL, sid VARCHAR(100) NOT NULL, UNIQUE KEY unique_acl_sid (sid, principal) ) ENGINE=InnoDB; CREATE TABLE acl_class ( id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, class VARCHAR(100) NOT NULL, UNIQUE KEY uk_acl_class (class) ) ENGINE=InnoDB; CREATE TABLE acl_object_identity ( id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, object_id_class BIGINT UNSIGNED NOT NULL, object_id_identity VARCHAR(36) NOT NULL, parent_object BIGINT UNSIGNED, owner_sid BIGINT UNSIGNED, entries_inheriting BOOLEAN NOT NULL, UNIQUE KEY uk_acl_object_identity (object_id_class, object_id_identity), CONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id), CONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id), CONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id) ) ENGINE=InnoDB; CREATE TABLE acl_entry ( id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, acl_object_identity BIGINT UNSIGNED NOT NULL, ace_order INTEGER NOT NULL, sid BIGINT UNSIGNED NOT NULL, mask INTEGER UNSIGNED NOT NULL, granting BOOLEAN NOT NULL, audit_success BOOLEAN NOT NULL, audit_failure BOOLEAN NOT NULL, UNIQUE KEY unique_acl_entry (acl_object_identity, ace_order), CONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id), CONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id) ) ENGINE=InnoDB; Microsoft SQL Server: CREATE TABLE acl_sid ( id BIGINT NOT NULL IDENTITY PRIMARY KEY, principal BIT NOT NULL, sid VARCHAR(100) NOT NULL, CONSTRAINT unique_acl_sid UNIQUE (sid, principal) ); CREATE TABLE acl_class ( id BIGINT NOT NULL IDENTITY PRIMARY KEY, class VARCHAR(100) NOT NULL, CONSTRAINT uk_acl_class UNIQUE (class) ); CREATE TABLE acl_object_identity ( id BIGINT NOT NULL IDENTITY PRIMARY KEY, object_id_class BIGINT NOT NULL, object_id_identity VARCHAR(36) NOT NULL, parent_object BIGINT, owner_sid BIGINT, entries_inheriting BIT NOT NULL, CONSTRAINT uk_acl_object_identity UNIQUE (object_id_class, object_id_identity), CONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id), CONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id), CONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id) ); CREATE TABLE acl_entry ( id BIGINT NOT NULL IDENTITY PRIMARY KEY, acl_object_identity BIGINT NOT NULL, ace_order INTEGER NOT NULL, sid BIGINT NOT NULL, mask INTEGER NOT NULL, granting BIT NOT NULL, audit_success BIT NOT NULL, audit_failure BIT NOT NULL, CONSTRAINT unique_acl_entry UNIQUE (acl_object_identity, ace_order), CONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id), CONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id) ); Oracle Database: CREATE TABLE ACL_SID ( ID NUMBER(18) PRIMARY KEY, PRINCIPAL NUMBER(1) NOT NULL CHECK (PRINCIPAL IN (0, 1 )), SID NVARCHAR2(128) NOT NULL, CONSTRAINT ACL_SID_UNIQUE UNIQUE (SID, PRINCIPAL) ); CREATE SEQUENCE ACL_SID_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE; CREATE OR REPLACE TRIGGER ACL_SID_SQ_TR BEFORE INSERT ON ACL_SID FOR EACH ROW BEGIN SELECT ACL_SID_SQ.NEXTVAL INTO :NEW.ID FROM DUAL; END; CREATE TABLE ACL_CLASS ( ID NUMBER(18) PRIMARY KEY, CLASS NVARCHAR2(128) NOT NULL, CONSTRAINT ACL_CLASS_UNIQUE UNIQUE (CLASS) ); CREATE SEQUENCE ACL_CLASS_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE; CREATE OR REPLACE TRIGGER ACL_CLASS_ID_TR BEFORE INSERT ON ACL_CLASS FOR EACH ROW BEGIN SELECT ACL_CLASS_SQ.NEXTVAL INTO :NEW.ID FROM DUAL; END; CREATE TABLE ACL_OBJECT_IDENTITY( ID NUMBER(18) PRIMARY KEY, OBJECT_ID_CLASS NUMBER(18) NOT NULL, OBJECT_ID_IDENTITY NVARCHAR2(64) NOT NULL, PARENT_OBJECT NUMBER(18), OWNER_SID NUMBER(18), ENTRIES_INHERITING NUMBER(1) NOT NULL CHECK (ENTRIES_INHERITING IN (0, 1)), CONSTRAINT ACL_OBJECT_IDENTITY_UNIQUE UNIQUE (OBJECT_ID_CLASS, OBJECT_ID_IDENTITY), CONSTRAINT ACL_OBJECT_IDENTITY_PARENT_FK FOREIGN KEY (PARENT_OBJECT) REFERENCES ACL_OBJECT_IDENTITY(ID), CONSTRAINT ACL_OBJECT_IDENTITY_CLASS_FK FOREIGN KEY (OBJECT_ID_CLASS) REFERENCES ACL_CLASS(ID), CONSTRAINT ACL_OBJECT_IDENTITY_OWNER_FK FOREIGN KEY (OWNER_SID) REFERENCES ACL_SID(ID) ); CREATE SEQUENCE ACL_OBJECT_IDENTITY_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE; CREATE OR REPLACE TRIGGER ACL_OBJECT_IDENTITY_ID_TR BEFORE INSERT ON ACL_OBJECT_IDENTITY FOR EACH ROW BEGIN SELECT ACL_OBJECT_IDENTITY_SQ.NEXTVAL INTO :NEW.ID FROM DUAL; END; CREATE TABLE ACL_ENTRY ( ID NUMBER(18) NOT NULL PRIMARY KEY, ACL_OBJECT_IDENTITY NUMBER(18) NOT NULL, ACE_ORDER INTEGER NOT NULL, SID NUMBER(18) NOT NULL, MASK INTEGER NOT NULL, GRANTING NUMBER(1) NOT NULL CHECK (GRANTING IN (0, 1)), AUDIT_SUCCESS NUMBER(1) NOT NULL CHECK (AUDIT_SUCCESS IN (0, 1)), AUDIT_FAILURE NUMBER(1) NOT NULL CHECK (AUDIT_FAILURE IN (0, 1)), CONSTRAINT ACL_ENTRY_UNIQUE UNIQUE (ACL_OBJECT_IDENTITY, ACE_ORDER), CONSTRAINT ACL_ENTRY_OBJECT_FK FOREIGN KEY (ACL_OBJECT_IDENTITY) REFERENCES ACL_OBJECT_IDENTITY (ID), CONSTRAINT ACL_ENTRY_ACL_FK FOREIGN KEY (SID) REFERENCES ACL_SID(ID) ); CREATE SEQUENCE ACL_ENTRY_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE; CREATE OR REPLACE TRIGGER ACL_ENTRY_ID_TRIGGER BEFORE INSERT ON ACL_ENTRY FOR EACH ROW BEGIN SELECT ACL_ENTRY_SQ.NEXTVAL INTO :NEW.ID FROM DUAL; END; OAuth 2.0 Client Schema: The JDBC implementation of OAuth2AuthorizedClientService(../oauth2/client/core.html#oauth2Client-authorized-repo-service) ( JdbcOAuth2AuthorizedClientService ) requires a table for persisting OAuth2AuthorizedClient instances. You will need to adjust this schema to match the database dialect you use. CREATE TABLE oauth2_authorized_client ( client_registration_id varchar(100) NOT NULL, principal_name varchar(200) NOT NULL, access_token_type varchar(100) NOT NULL, access_token_value blob NOT NULL, access_token_issued_at timestamp NOT NULL, access_token_expires_at timestamp NOT NULL, access_token_scopes varchar(1000) DEFAULT NULL, refresh_token_value blob DEFAULT NULL, refresh_token_issued_at timestamp DEFAULT NULL, created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL, PRIMARY KEY (client_registration_id, principal_name) );"
"https://docs.spring.io/spring-security/reference/6.3/servlet/appendix/namespace/index.html","The Security Namespace: This appendix provides a reference to the elements available in the security namespace and information on the underlying beans they create (a knowledge of the individual classes and how they work together is assumed - you can find more information in the project Javadoc and elsewhere in this document). If you haven’t used the namespace before, please read the introductory chapter(../../configuration/xml-namespace.html#ns-config) on namespace configuration, as this is intended as a supplement to the information there. Using a good quality XML editor while editing a configuration based on the schema is recommended as this will provide contextual information on which elements and attributes are available as well as comments explaining their purpose. The namespace is written in RELAX NG(https://relaxng.org/) Compact format and later converted into an XSD schema. If you are familiar with this format, you may wish to examine the schema file(https://raw.githubusercontent.com/spring-projects/spring-security/main/config/src/main/resources/org/springframework/security/config/spring-security-6.3.rnc) directly. Section Summary: Authentication Services(authentication-manager.html) Web Security(http.html) Method Security(method-security.html) LDAP Security(ldap.html) WebSocket Security(websocket.html)"
"https://docs.spring.io/spring-security/reference/6.3/servlet/appendix/namespace/authentication-manager.html","Authentication Services: This creates an instance of Spring Security’s ProviderManager class, which needs to be configured with a list of one or more AuthenticationProvider instances. These can either be created using syntax elements provided by the namespace, or they can be standard bean definitions, marked for addition to the list using the authentication-provider element. <authentication-manager>: Every Spring Security application which uses the namespace must have include this element somewhere. It is responsible for registering the AuthenticationManager which provides authentication services to the application. All elements which create AuthenticationProvider instances should be children of this element. <authentication-manager> Attributes: alias This attribute allows you to define an alias name for the internal instance for use in your own configuration. erase-credentials If set to true, the AuthenticationManager will attempt to clear any credentials data in the returned Authentication object, once the user has been authenticated. Literally it maps to the eraseCredentialsAfterAuthentication property of the ProviderManager(../../authentication/architecture.html#servlet-authentication-providermanager) . observation-registry-ref A reference to the ObservationRegistry used for the FilterChain and related components id This attribute allows you to define an id for the internal instance for use in your own configuration. It is the same as the alias element, but provides a more consistent experience with elements that use the id attribute. Child Elements of <authentication-manager>: authentication-provider(#nsa-authentication-provider) ldap-authentication-provider(ldap.html#nsa-ldap-authentication-provider) <authentication-provider>: Unless used with a ref attribute, this element is shorthand for configuring a DaoAuthenticationProvider . DaoAuthenticationProvider loads user information from a UserDetailsService and compares the username/password combination with the values supplied at login. The UserDetailsService instance can be defined either by using an available namespace element ( jdbc-user-service or by using the user-service-ref attribute to point to a bean defined elsewhere in the application context). Parent Elements of <authentication-provider>: authentication-manager(#nsa-authentication-manager) <authentication-provider> Attributes: ref Defines a reference to a Spring bean that implements AuthenticationProvider . If you have written your own AuthenticationProvider implementation (or want to configure one of Spring Security’s own implementations as a traditional bean for some reason, then you can use the following syntax to add it to the internal list of ProviderManager : <security:authentication-manager> <security:authentication-provider ref=""myAuthenticationProvider"" /> </security:authentication-manager> <bean id=""myAuthenticationProvider"" class=""com.something.MyAuthenticationProvider""/> user-service-ref A reference to a bean that implements UserDetailsService that may be created using the standard bean element or the custom user-service element. Child Elements of <authentication-provider>: jdbc-user-service(#nsa-jdbc-user-service) ldap-user-service(ldap.html#nsa-ldap-user-service) password-encoder(#nsa-password-encoder) user-service(#nsa-user-service) <jdbc-user-service>: Causes creation of a JDBC-based UserDetailsService. <jdbc-user-service> Attributes: authorities-by-username-query An SQL statement to query for a user’s granted authorities given a username. The default is select username, authority from authorities where username = ? cache-ref Defines a reference to a cache for use with a UserDetailsService. data-source-ref The bean ID of the DataSource which provides the required tables. group-authorities-by-username-query An SQL statement to query user’s group authorities given a username. The default is select g.id, g.group_name, ga.authority from groups g, group_members gm, group_authorities ga where gm.username = ? and g.id = ga.group_id and g.id = gm.group_id id A bean identifier, used for referring to the bean elsewhere in the context. role-prefix A non-empty string prefix that will be added to role strings loaded from persistent storage (default is ""ROLE_""). Use the value ""none"" for no prefix in cases where the default is non-empty. users-by-username-query An SQL statement to query a username, password, and enabled status given a username. The default is select username, password, enabled from users where username = ? <password-encoder>: Authentication providers can optionally be configured to use a password encoder as described in the Password Storage(../../../features/authentication/password-storage.html#authentication-password-storage) . This will result in the bean being injected with the appropriate PasswordEncoder instance. Parent Elements of <password-encoder>: authentication-provider(#nsa-authentication-provider) password-compare(#nsa-password-compare) <password-encoder> Attributes: hash Defines the hashing algorithm used on user passwords. We recommend strongly against using MD4, as it is a very weak hashing algorithm. ref Defines a reference to a Spring bean that implements PasswordEncoder . <user-service>: Creates an in-memory UserDetailsService from a properties file or a list of ""user"" child elements. Usernames are converted to lower-case internally to allow for case-insensitive lookups, so this should not be used if case-sensitivity is required. <user-service> Attributes: id A bean identifier, used for referring to the bean elsewhere in the context. properties The location of a Properties file where each line is in the format of username=password,grantedAuthority[,grantedAuthority][,enabled|disabled] Child Elements of <user-service>: user(#nsa-user) <user>: Represents a user in the application. Parent Elements of <user>: user-service(#nsa-user-service) <user> Attributes: authorities One of more authorities granted to the user. Separate authorities with a comma (but no space). For example, ""ROLE_USER,ROLE_ADMINISTRATOR"" disabled Can be set to ""true"" to mark an account as disabled and unusable. locked Can be set to ""true"" to mark an account as locked and unusable. name The username assigned to the user. password The password assigned to the user. This may be hashed if the corresponding authentication provider supports hashing (remember to set the ""hash"" attribute of the ""user-service"" element). This attribute be omitted in the case where the data will not be used for authentication, but only for accessing authorities. If omitted, the namespace will generate a random value, preventing its accidental use for authentication. Cannot be empty."
"https://docs.spring.io/spring-security/reference/6.3/servlet/appendix/namespace/http.html","Web Application Security: <debug>: Enables Spring Security debugging infrastructure. This will provide human-readable (multi-line) debugging information to monitor requests coming into the security filters. This may include sensitive information, such as request parameters or headers, and should only be used in a development environment. <http>: If you use an <http> element within your application, a FilterChainProxy bean named ""springSecurityFilterChain"" is created and the configuration within the element is used to build a filter chain within FilterChainProxy . As of Spring Security 3.1, additional http elements can be used to add extra filter chains [ 1(#_footnotedef_1) ] for how to set up the mapping from your web.xml ]. Some core filters are always created in a filter chain and others will be added to the stack depending on the attributes and child elements which are present. The positions of the standard filters are fixed (see the filter order table(../../configuration/xml-namespace.html#filter-stack) in the namespace introduction), removing a common source of errors with previous versions of the framework when users had to configure the filter chain explicitly in the FilterChainProxy bean. You can, of course, still do this if you need full control of the configuration. All filters which require a reference to the AuthenticationManager(../../authentication/architecture.html#servlet-authentication-authenticationmanager) will be automatically injected with the internal instance created by the namespace configuration. Each <http> namespace block always creates an SecurityContextPersistenceFilter , an ExceptionTranslationFilter and a FilterSecurityInterceptor . These are fixed and cannot be replaced with alternatives. <http> Attributes: The attributes on the <http> element control some of the properties on the core filters. use-authorization-manager Use AuthorizationManager API instead of SecurityMetadataSource (defaults to true) access-decision-manager-ref Use this AuthorizationManager instead of deriving one from <intercept-url> elements access-decision-manager-ref Optional attribute specifying the ID of the AccessDecisionManager implementation which should be used for authorizing HTTP requests. By default an AffirmativeBased implementation is used for with a RoleVoter and an AuthenticatedVoter . authentication-manager-ref A reference to the AuthenticationManager used for the FilterChain created by this http element. observation-registry-ref A reference to the ObservationRegistry used for the FilterChain and related components auto-config Automatically registers a login form, BASIC authentication, logout services. If set to ""true"", all of these capabilities are added (although you can still customize the configuration of each by providing the respective element). If unspecified, defaults to ""false"". Use of this attribute is not recommended. Use explicit configuration elements instead to avoid confusion. create-session Controls the eagerness with which an HTTP session is created by Spring Security classes. Options include: always - Spring Security will proactively create a session if one does not exist. ifRequired - Spring Security will only create a session only if one is required (default value). never - Spring Security will never create a session, but will make use of one if the application does. stateless - Spring Security will not create a session and ignore the session for obtaining a Spring Authentication . disable-url-rewriting Prevents session IDs from being appended to URLs in the application. Clients must use cookies if this attribute is set to true . The default is true . entry-point-ref Normally the AuthenticationEntryPoint used will be set depending on which authentication mechanisms have been configured. This attribute allows this behaviour to be overridden by defining a customized AuthenticationEntryPoint bean which will start the authentication process. jaas-api-provision If available, runs the request as the Subject acquired from the JaasAuthenticationToken which is implemented by adding a JaasApiIntegrationFilter bean to the stack. Defaults to false . name A bean identifier, used for referring to the bean elsewhere in the context. once-per-request Corresponds to the observeOncePerRequest property of FilterSecurityInterceptor . Defaults to false . filter-all-dispatcher-types Corresponds to the shouldFilterAllDispatcherTypes property of the AuthorizationFilter . Does not work when use-authorization-manager=false . Defaults to true . pattern Defining a pattern for the http(#nsa-http) element controls the requests which will be filtered through the list of filters which it defines. The interpretation is dependent on the configured request-matcher(#nsa-http-request-matcher) . If no pattern is defined, all requests will be matched, so the most specific patterns should be declared first. realm Sets the realm name used for basic authentication (if enabled). Corresponds to the realmName property on BasicAuthenticationEntryPoint . request-matcher Defines the RequestMatcher strategy used in the FilterChainProxy and the beans created by the intercept-url to match incoming requests. Options are currently mvc , ant , regex and ciRegex , for Spring MVC, ant, regular-expression and case-insensitive regular-expression respectively. A separate instance is created for each intercept-url(#nsa-intercept-url) element using its pattern(#nsa-intercept-url-pattern) , method(#nsa-intercept-url-method) and servlet-path(#nsa-intercept-url-servlet-path) attributes. Ant paths are matched using an AntPathRequestMatcher , regular expressions are matched using a RegexRequestMatcher and for Spring MVC path matching the MvcRequestMatcher is used. See the Javadoc for these classes for more details on exactly how the matching is performed. MVC is the default strategy if Spring MVC is present in the classpath, if not, Ant paths are used. request-matcher-ref A reference to a bean that implements RequestMatcher that will determine if this FilterChain should be used. This is a more powerful alternative to pattern(#nsa-http-pattern) . security A request pattern can be mapped to an empty filter chain, by setting this attribute to none . No security will be applied and none of Spring Security’s features will be available. security-context-repository-ref Allows injection of a custom SecurityContextHolderStrategy into SecurityContextPersistenceFilter , SecurityContextHolderFilter , BasicAuthenticationFilter , UsernamePasswordAuthenticationFilter , ExceptionTranslationFilter , LogoutFilter , and others. security-context-explicit-save If true, use SecurityContextHolderFilter instead of SecurityContextPersistenceFilter . Requires explicit save security-context-repository-ref Allows injection of a custom SecurityContextRepository into the SecurityContextPersistenceFilter . servlet-api-provision Provides versions of HttpServletRequest security methods such as isUserInRole() and getPrincipal() which are implemented by adding a SecurityContextHolderAwareRequestFilter bean to the stack. Defaults to true . use-expressions Enables EL-expressions in the access attribute, as described in the chapter on expression-based access-control(../../authorization/authorize-http-requests.html#authorization-expressions) . The default value is true. Child Elements of <http>: access-denied-handler(#nsa-access-denied-handler) anonymous(#nsa-anonymous) cors(#nsa-cors) csrf(#nsa-csrf) custom-filter(#nsa-custom-filter) expression-handler(#nsa-expression-handler) form-login(#nsa-form-login) headers(#nsa-headers) http-basic(#nsa-http-basic) intercept-url(#nsa-intercept-url) jee(#nsa-jee) logout(#nsa-logout) oauth2-client(#nsa-oauth2-client) oauth2-login(#nsa-oauth2-login) oauth2-resource-server(#nsa-oauth2-resource-server) password-management(#nsa-password-management) port-mappings(#nsa-port-mappings) remember-me(#nsa-remember-me) request-cache(#nsa-request-cache) saml2-login(#nsa-saml2-login) saml2-logout(#nsa-saml2-logout) session-management(#nsa-session-management) x509(#nsa-x509) <access-denied-handler>: This element allows you to set the errorPage property for the default AccessDeniedHandler used by the ExceptionTranslationFilter , using the error-page(#nsa-access-denied-handler-error-page) attribute, or to supply your own implementation using the ref(#nsa-access-denied-handler-ref) attribute. This is discussed in more detail in the section on the ExceptionTranslationFilter(../../architecture.html#servlet-exceptiontranslationfilter) . Parent Elements of <access-denied-handler>: http(#nsa-http) <access-denied-handler> Attributes: error-page The access denied page that an authenticated user will be redirected to if they request a page which they don’t have the authority to access. ref Defines a reference to a Spring bean of type AccessDeniedHandler . <cors>: This element allows for configuring a CorsFilter . If no CorsFilter or CorsConfigurationSource is specified and Spring MVC is on the classpath, a HandlerMappingIntrospector is used as the CorsConfigurationSource . <cors> Attributes: The attributes on the <cors> element control the headers element. ref Optional attribute that specifies the bean name of a CorsFilter . cors-configuration-source-ref Optional attribute that specifies the bean name of a CorsConfigurationSource to be injected into a CorsFilter created by the XML namespace. Parent Elements of <cors>: http(#nsa-http) <headers>: This element allows for configuring additional (security) headers to be send with the response. It enables easy configuration for several headers and also allows for setting custom headers through the header(#nsa-header) element. Additional information, can be found in the Security Headers(../../../features/exploits/headers.html#headers) section of the reference. Cache-Control , Pragma , and Expires - Can be set using the cache-control(#nsa-cache-control) element. This ensures that the browser does not cache your secured pages. Strict-Transport-Security - Can be set using the hsts(#nsa-hsts) element. This ensures that the browser automatically requests HTTPS for future requests. X-Frame-Options - Can be set using the frame-options(#nsa-frame-options) element. The X-Frame-Options(https://en.wikipedia.org/wiki/Clickjacking#X-Frame-Options) header can be used to prevent clickjacking attacks. X-XSS-Protection - Can be set using the xss-protection(#nsa-xss-protection) element. The X-XSS-Protection(https://en.wikipedia.org/wiki/Cross-site_scripting) header can be used by browser to do basic control. X-Content-Type-Options - Can be set using the content-type-options(#nsa-content-type-options) element. The X-Content-Type-Options(https://blogs.msdn.com/b/ie/archive/2008/09/02/ie8-security-part-vi-beta-2-update.aspx) header prevents Internet Explorer from MIME-sniffing a response away from the declared content-type. This also applies to Google Chrome, when downloading extensions. Public-Key-Pinning or Public-Key-Pinning-Report-Only - Can be set using the hpkp(#nsa-hpkp) element. This allows HTTPS websites to resist impersonation by attackers using mis-issued or otherwise fraudulent certificates. Content-Security-Policy or Content-Security-Policy-Report-Only - Can be set using the content-security-policy(#nsa-content-security-policy) element. Content Security Policy (CSP)(https://www.w3.org/TR/CSP2/) is a mechanism that web applications can leverage to mitigate content injection vulnerabilities, such as cross-site scripting (XSS). Referrer-Policy - Can be set using the referrer-policy(#nsa-referrer-policy) element, Referrer-Policy(https://www.w3.org/TR/referrer-policy/) is a mechanism that web applications can leverage to manage the referrer field, which contains the last page the user was on. Feature-Policy - Can be set using the feature-policy(#nsa-feature-policy) element, Feature-Policy(https://wicg.github.io/feature-policy/) is a mechanism that allows web developers to selectively enable, disable, and modify the behavior of certain APIs and web features in the browser. Cross-Origin-Opener-Policy - Can be set using the cross-origin-opener-policy(#nsa-cross-origin-opener-policy) element, Cross-Origin-Opener-Policy(https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy) is a mechanism that allows you to ensure a top-level document does not share a browsing context group with cross-origin documents. Cross-Origin-Embedder-Policy - Can be set using the cross-origin-embedder-policy(#nsa-cross-origin-embedder-policy) element, Cross-Origin-Embedder-Policy(https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy) is a mechanism that prevents a document from loading any cross-origin resources that don’t explicitly grant the document permission. Cross-Origin-Resource-Policy - Can be set using the cross-origin-resource-policy(#nsa-cross-origin-resource-policy) element, Cross-Origin-Resource-Policy(https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Resource-Policy) is a mechanism that conveys a desire that the browser blocks no-cors cross-origin/cross-site requests to the given resource. <headers> Attributes: The attributes on the <headers> element control the headers element. defaults-disabled Optional attribute that specifies to disable the default Spring Security’s HTTP response headers. The default is false (the default headers are included). disabled Optional attribute that specifies to disable Spring Security’s HTTP response headers. The default is false (the headers are enabled). Parent Elements of <headers>: http(#nsa-http) Child Elements of <headers>: cache-control(#nsa-cache-control) content-security-policy(#nsa-content-security-policy) content-type-options(#nsa-content-type-options) cross-origin-embedder-policy(#nsa-cross-origin-embedder-policy) cross-origin-opener-policy(#nsa-cross-origin-opener-policy) cross-origin-resource-policy(#nsa-cross-origin-resource-policy) feature-policy(#nsa-feature-policy) frame-options(#nsa-frame-options) header(#nsa-header) hpkp(#nsa-hpkp) hsts(#nsa-hsts) permission-policy(#nsa-permissions-policy) referrer-policy(#nsa-referrer-policy) xss-protection(#nsa-xss-protection) <cache-control>: Adds Cache-Control , Pragma , and Expires headers to ensure that the browser does not cache your secured pages. <cache-control> Attributes: disabled Specifies if Cache Control should be disabled. Default false. Parent Elements of <cache-control>: headers(#nsa-headers) <hsts>: When enabled adds the Strict-Transport-Security(https://tools.ietf.org/html/rfc6797) header to the response for any secure request. This allows the server to instruct browsers to automatically use HTTPS for future requests. <hsts> Attributes: disabled Specifies if Strict-Transport-Security should be disabled. Default false. include-sub-domains Specifies if subdomains should be included. Default true. max-age-seconds Specifies the maximum amount of time the host should be considered a Known HSTS Host. Default one year. request-matcher-ref The RequestMatcher instance to be used to determine if the header should be set. Default is if HttpServletRequest.isSecure() is true. preload Specifies if preload should be included. Default false. Parent Elements of <hsts>: headers(#nsa-headers) <hpkp>: When enabled adds the Public Key Pinning Extension for HTTP(https://tools.ietf.org/html/rfc7469) header to the response for any secure request. This allows HTTPS websites to resist impersonation by attackers using mis-issued or otherwise fraudulent certificates. <hpkp> Attributes: disabled Specifies if HTTP Public Key Pinning (HPKP) should be disabled. Default true. include-sub-domains Specifies if subdomains should be included. Default false. max-age-seconds Sets the value for the max-age directive of the Public-Key-Pins header. Default 60 days. report-only Specifies if the browser should only report pin validation failures. Default true. report-uri Specifies the URI to which the browser should report pin validation failures. Parent Elements of <hpkp>: headers(#nsa-headers) <pins>: The list of pins Child Elements of <pins>: pin(#nsa-pin) <pin>: A pin is specified using the base64-encoded SPKI fingerprint as value and the cryptographic hash algorithm as attribute <pin> Attributes: algorithm The cryptographic hash algorithm. Default is SHA256. Parent Elements of <pin>: pins(#nsa-pins) <content-security-policy>: When enabled adds the Content Security Policy (CSP)(https://www.w3.org/TR/CSP2/) header to the response. CSP is a mechanism that web applications can leverage to mitigate content injection vulnerabilities, such as cross-site scripting (XSS). <content-security-policy> Attributes: policy-directives The security policy directive(s) for the Content-Security-Policy header or if report-only is set to true, then the Content-Security-Policy-Report-Only header is used. report-only Set to true, to enable the Content-Security-Policy-Report-Only header for reporting policy violations only. Defaults to false. Parent Elements of <content-security-policy>: headers(#nsa-headers) <referrer-policy>: When enabled adds the Referrer Policy(https://www.w3.org/TR/referrer-policy/) header to the response. <referrer-policy> Attributes: policy The policy for the Referrer-Policy header. Default ""no-referrer"". Parent Elements of <referrer-policy>: headers(#nsa-headers) <feature-policy>: When enabled adds the Feature Policy(https://wicg.github.io/feature-policy/) header to the response. <feature-policy> Attributes: policy-directives The security policy directive(s) for the Feature-Policy header. Parent Elements of <feature-policy>: headers(#nsa-headers) <frame-options>: When enabled adds the X-Frame-Options header(https://tools.ietf.org/html/draft-ietf-websec-x-frame-options) to the response, this allows newer browsers to do some security checks and prevent clickjacking(https://en.wikipedia.org/wiki/Clickjacking) attacks. <frame-options> Attributes: disabled If disabled, the X-Frame-Options header will not be included. Default false. policy DENY The page cannot be displayed in a frame, regardless of the site attempting to do so. This is the default when frame-options-policy is specified. SAMEORIGIN The page can only be displayed in a frame on the same origin as the page itself In other words, if you specify DENY, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify SAMEORIGIN, you can still use the page in a frame as long as the site including it in a frame it is the same as the one serving the page. Parent Elements of <frame-options>: headers(#nsa-headers) <permissions-policy>: Adds the Permissions-Policy header(https://w3c.github.io/webappsec-permissions-policy/) to the response. <permissions-policy> Attributes: policy The policy value to write for the Permissions-Policy header Parent Elements of <permissions-policy>: headers(#nsa-headers) <xss-protection>: Adds the X-XSS-Protection header(https://blogs.msdn.com/b/ie/archive/2008/07/02/ie8-security-part-iv-the-xss-filter.aspx) to the response to assist in protecting against reflected / Type-1 Cross-Site Scripting (XSS)(https://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent) attacks. This is in no-way a full protection to XSS attacks! <xss-protection> Attributes: xss-protection-disabled Do not include the header for reflected / Type-1 Cross-Site Scripting (XSS)(https://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent) protection. xss-protection-header-value Explicitly set the value for reflected / Type-1 Cross-Site Scripting (XSS)(https://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent) header. One of: ""0"", ""1"", ""1; mode=block"". Defaults to ""0"". Parent Elements of <xss-protection>: headers(#nsa-headers) <content-type-options>: Add the X-Content-Type-Options header with the value of nosniff to the response. This disables MIME-sniffing(https://blogs.msdn.com/b/ie/archive/2008/09/02/ie8-security-part-vi-beta-2-update.aspx) for IE8+ and Chrome extensions. <content-type-options> Attributes: disabled Specifies if Content Type Options should be disabled. Default false. Parent Elements of <content-type-options>: headers(#nsa-headers) <cross-origin-embedder-policy>: When enabled adds the Cross-Origin-Embedder-Policy(https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy) header to the response. <cross-origin-embedder-policy> Attributes: policy The policy for the Cross-Origin-Embedder-Policy header. Parent Elements of <cross-origin-embedder-policy>: headers(#nsa-headers) <cross-origin-opener-policy>: When enabled adds the Cross-Origin-Opener-Policy(https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy) header to the response. <cross-origin-opener-policy> Attributes: policy The policy for the Cross-Origin-Opener-Policy header. Parent Elements of <cross-origin-opener-policy>: headers(#nsa-headers) <cross-origin-resource-policy>: When enabled adds the Cross-Origin-Resource-Policy(https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Resource-Policy) header to the response. <cross-origin-resource-policy> Attributes: policy The policy for the Cross-Origin-Resource-Policy header. Parent Elements of <cross-origin-resource-policy>: headers(#nsa-headers) <header>: Add additional headers to the response, both the name and value need to be specified. <header-attributes> Attributes: header-name The name of the header. value The value of the header to add. ref Reference to a custom implementation of the HeaderWriter interface. Parent Elements of <header>: headers(#nsa-headers) <anonymous>: Adds an AnonymousAuthenticationFilter to the stack and an AnonymousAuthenticationProvider . Required if you are using the IS_AUTHENTICATED_ANONYMOUSLY attribute. Parent Elements of <anonymous>: http(#nsa-http) <anonymous> Attributes: enabled With the default namespace setup, the anonymous ""authentication"" facility is automatically enabled. You can disable it using this property. granted-authority The granted authority that should be assigned to the anonymous request. Commonly this is used to assign the anonymous request particular roles, which can subsequently be used in authorization decisions. If unset, defaults to ROLE_ANONYMOUS . key The key shared between the provider and filter. This generally does not need to be set. If unset, it will default to a secure randomly generated value. This means setting this value can improve startup time when using the anonymous functionality since secure random values can take a while to be generated. username The username that should be assigned to the anonymous request. This allows the principal to be identified, which may be important for logging and auditing. if unset, defaults to anonymousUser . <csrf>: This element will add Cross Site Request Forger (CSRF)(https://en.wikipedia.org/wiki/Cross-site_request_forgery) protection to the application. It also updates the default RequestCache to only replay ""GET"" requests upon successful authentication. Additional information can be found in the Cross Site Request Forgery (CSRF)(../../../features/exploits/csrf.html#csrf) section of the reference. Parent Elements of <csrf>: http(#nsa-http) <csrf> Attributes: disabled Optional attribute that specifies to disable Spring Security’s CSRF protection. The default is false (CSRF protection is enabled). It is highly recommended to leave CSRF protection enabled. token-repository-ref The CsrfTokenRepository to use. The default is HttpSessionCsrfTokenRepository . request-handler-ref The optional CsrfTokenRequestHandler to use. The default is CsrfTokenRequestAttributeHandler . request-matcher-ref The RequestMatcher instance to be used to determine if CSRF should be applied. Default is any HTTP method except ""GET"", ""TRACE"", ""HEAD"", ""OPTIONS"". <custom-filter>: This element is used to add a filter to the filter chain. It doesn’t create any additional beans but is used to select a bean of type jakarta.servlet.Filter which is already defined in the application context and add that at a particular position in the filter chain maintained by Spring Security. Full details can be found in the namespace chapter(../../configuration/xml-namespace.html#ns-custom-filters) . Parent Elements of <custom-filter>: http(#nsa-http) <custom-filter> Attributes: after The filter immediately after which the custom-filter should be placed in the chain. This feature will only be needed by advanced users who wish to mix their own filters into the security filter chain and have some knowledge of the standard Spring Security filters. The filter names map to specific Spring Security implementation filters. before The filter immediately before which the custom-filter should be placed in the chain position The explicit position at which the custom-filter should be placed in the chain. Use if you are replacing a standard filter. ref Defines a reference to a Spring bean that implements Filter . <expression-handler>: Defines the SecurityExpressionHandler instance which will be used if expression-based access-control is enabled. A default implementation (with no ACL support) will be used if not supplied. Parent Elements of <expression-handler>: global-method-security(method-security.html#nsa-global-method-security) http(#nsa-http) method-security(method-security.html#nsa-method-security) websocket-message-broker(websocket.html#nsa-websocket-message-broker) <expression-handler> Attributes: ref Defines a reference to a Spring bean that implements SecurityExpressionHandler . <form-login>: Used to add an UsernamePasswordAuthenticationFilter to the filter stack and an LoginUrlAuthenticationEntryPoint to the application context to provide authentication on demand. This will always take precedence over other namespace-created entry points. If no attributes are supplied, a login page will be generated automatically at the URL ""/login"" [ 2(#_footnotedef_2) ] The behaviour can be customized using the <form-login> Attributes(#nsa-form-login-attributes) . Parent Elements of <form-login>: http(#nsa-http) <form-login> Attributes: always-use-default-target If set to true , the user will always start at the value given by default-target-url(#nsa-form-login-default-target-url) , regardless of how they arrived at the login page. Maps to the alwaysUseDefaultTargetUrl property of UsernamePasswordAuthenticationFilter . Default value is false . authentication-details-source-ref Reference to an AuthenticationDetailsSource which will be used by the authentication filter authentication-failure-handler-ref Can be used as an alternative to authentication-failure-url(#nsa-form-login-authentication-failure-url) , giving you full control over the navigation flow after an authentication failure. The value should be the name of an AuthenticationFailureHandler bean in the application context. authentication-failure-url Maps to the authenticationFailureUrl property of UsernamePasswordAuthenticationFilter . Defines the URL the browser will be redirected to on login failure. Defaults to /login?error , which will be automatically handled by the automatic login page generator, re-rendering the login page with an error message. authentication-success-handler-ref This can be used as an alternative to default-target-url(#nsa-form-login-default-target-url) and always-use-default-target(#nsa-form-login-always-use-default-target) , giving you full control over the navigation flow after a successful authentication. The value should be the name of an AuthenticationSuccessHandler bean in the application context. By default, an implementation of SavedRequestAwareAuthenticationSuccessHandler is used and injected with the default-target-url(#nsa-form-login-default-target-url) . default-target-url Maps to the defaultTargetUrl property of UsernamePasswordAuthenticationFilter . If not set, the default value is ""/"" (the application root). A user will be taken to this URL after logging in, provided they were not asked to login while attempting to access a secured resource, when they will be taken to the originally requested URL. login-page The URL that should be used to render the login page. Maps to the loginFormUrl property of the LoginUrlAuthenticationEntryPoint . Defaults to ""/login"". login-processing-url Maps to the filterProcessesUrl property of UsernamePasswordAuthenticationFilter . The default value is ""/login"". password-parameter The name of the request parameter which contains the password. Defaults to ""password"". username-parameter The name of the request parameter which contains the username. Defaults to ""username"". authentication-success-forward-url Maps a ForwardAuthenticationSuccessHandler to authenticationSuccessHandler property of UsernamePasswordAuthenticationFilter . authentication-failure-forward-url Maps a ForwardAuthenticationFailureHandler to authenticationFailureHandler property of UsernamePasswordAuthenticationFilter . <oauth2-login>: The OAuth 2.0 Login(../../oauth2/login/index.html#oauth2login) feature configures authentication support using an OAuth 2.0 and/or OpenID Connect 1.0 Provider. Parent Elements of <oauth2-login>: http(#nsa-http) <oauth2-login> Attributes: client-registration-repository-ref Reference to the ClientRegistrationRepository . authorized-client-repository-ref Reference to the OAuth2AuthorizedClientRepository . authorized-client-service-ref Reference to the OAuth2AuthorizedClientService . authorization-request-repository-ref Reference to the AuthorizationRequestRepository . authorization-request-resolver-ref Reference to the OAuth2AuthorizationRequestResolver . authorization-redirect-strategy-ref Reference to the authorization RedirectStrategy . access-token-response-client-ref Reference to the OAuth2AccessTokenResponseClient . user-authorities-mapper-ref Reference to the GrantedAuthoritiesMapper . user-service-ref Reference to the OAuth2UserService . oidc-user-service-ref Reference to the OpenID Connect OAuth2UserService . login-processing-url The URI where the filter processes authentication requests. login-page The URI to send users to login. authentication-success-handler-ref Reference to the AuthenticationSuccessHandler . authentication-failure-handler-ref Reference to the AuthenticationFailureHandler . jwt-decoder-factory-ref Reference to the JwtDecoderFactory used by OidcAuthorizationCodeAuthenticationProvider . <oauth2-client>: Configures OAuth 2.0 Client(../../oauth2/client/index.html#oauth2client) support. Parent Elements of <oauth2-client>: http(#nsa-http) <oauth2-client> Attributes: client-registration-repository-ref Reference to the ClientRegistrationRepository . authorized-client-repository-ref Reference to the OAuth2AuthorizedClientRepository . authorized-client-service-ref Reference to the OAuth2AuthorizedClientService . Child Elements of <oauth2-client>: authorization-code-grant(#nsa-authorization-code-grant) <authorization-code-grant>: Configures OAuth 2.0 Authorization Code Grant(../../oauth2/client/authorization-grants.html#oauth2Client-auth-grant-support) . Parent Elements of <authorization-code-grant>: oauth2-client(#nsa-oauth2-client) <authorization-code-grant> Attributes: authorization-request-repository-ref Reference to the AuthorizationRequestRepository . authorization-redirect-strategy-ref Reference to the authorization RedirectStrategy . authorization-request-resolver-ref Reference to the OAuth2AuthorizationRequestResolver . access-token-response-client-ref Reference to the OAuth2AccessTokenResponseClient . <client-registrations>: A container element for client(s) registered ( ClientRegistration(../../oauth2/client/index.html#oauth2Client-client-registration) ) with an OAuth 2.0 or OpenID Connect 1.0 Provider. Child Elements of <client-registrations>: client-registration(#nsa-client-registration) provider(#nsa-provider) <client-registration>: Represents a client registered with an OAuth 2.0 or OpenID Connect 1.0 Provider. Parent Elements of <client-registration>: client-registrations(#nsa-client-registrations) <client-registration> Attributes: registration-id The ID that uniquely identifies the ClientRegistration . client-id The client identifier. client-secret The client secret. client-authentication-method The method used to authenticate the Client with the Provider. The supported values are client_secret_basic , client_secret_post , private_key_jwt , client_secret_jwt and none (public clients)(https://tools.ietf.org/html/rfc6749#section-2.1) . authorization-grant-type The OAuth 2.0 Authorization Framework defines four Authorization Grant(https://tools.ietf.org/html/rfc6749#section-1.3) types. The supported values are authorization_code , client_credentials , password , as well as, extension grant type urn:ietf:params:oauth:grant-type:jwt-bearer . redirect-uri The client’s registered redirect URI that the Authorization Server redirects the end-user’s user-agent to after the end-user has authenticated and authorized access to the client. scope The scope(s) requested by the client during the Authorization Request flow, such as openid, email, or profile. client-name A descriptive name used for the client. The name may be used in certain scenarios, such as when displaying the name of the client in the auto-generated login page. provider-id A reference to the associated provider. May reference a <provider> element or use one of the common providers (google, github, facebook, okta). <provider>: The configuration information for an OAuth 2.0 or OpenID Connect 1.0 Provider. Parent Elements of <provider>: client-registrations(#nsa-client-registrations) <provider> Attributes: provider-id The ID that uniquely identifies the provider. authorization-uri The Authorization Endpoint URI for the Authorization Server. token-uri The Token Endpoint URI for the Authorization Server. user-info-uri The UserInfo Endpoint URI used to access the claims/attributes of the authenticated end-user. user-info-authentication-method The authentication method used when sending the access token to the UserInfo Endpoint. The supported values are header , form and query . user-info-user-name-attribute The name of the attribute returned in the UserInfo Response that references the Name or Identifier of the end-user. jwk-set-uri The URI used to retrieve the JSON Web Key (JWK)(https://tools.ietf.org/html/rfc7517) Set from the Authorization Server, which contains the cryptographic key(s) used to verify the JSON Web Signature (JWS)(https://tools.ietf.org/html/rfc7515) of the ID Token and optionally the UserInfo Response. issuer-uri The URI used to initially configure a ClientRegistration using discovery of an OpenID Connect Provider’s Configuration endpoint(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) or an Authorization Server’s Metadata endpoint(https://tools.ietf.org/html/rfc8414#section-3) . <oauth2-resource-server>: Adds a BearerTokenAuthenticationFilter , BearerTokenAuthenticationEntryPoint , and BearerTokenAccessDeniedHandler to the configuration. In addition, either <jwt> or <opaque-token> must be specified. Parents Elements of <oauth2-resource-server>: http(#nsa-http) Child Elements of <oauth2-resource-server>: jwt(#nsa-jwt) opaque-token(#nsa-opaque-token) <oauth2-resource-server> Attributes: authentication-manager-resolver-ref Reference to an AuthenticationManagerResolver which will resolve the AuthenticationManager at request time bearer-token-resolver-ref Reference to a BearerTokenResolver which will retrieve the bearer token from the request entry-point-ref Reference to a AuthenticationEntryPoint which will handle unauthorized requests <jwt>: Represents an OAuth 2.0 Resource Server that will authorize JWTs Parent Elements of <jwt>: oauth2-resource-server(#nsa-oauth2-resource-server) <jwt> Attributes: jwt-authentication-converter-ref Reference to a Converter<Jwt, AbstractAuthenticationToken> jwt-decoder-ref Reference to a JwtDecoder . This is a larger component that overrides jwk-set-uri jwk-set-uri The JWK Set Uri used to load signing verification keys from an OAuth 2.0 Authorization Server <opaque-token>: Represents an OAuth 2.0 Resource Server that will authorize opaque tokens Parent Elements of <opaque-token>: oauth2-resource-server(#nsa-oauth2-resource-server) <opaque-token> Attributes: introspector-ref Reference to an OpaqueTokenIntrospector . This is a larger component that overrides introspection-uri , client-id , and client-secret . introspection-uri The Introspection Uri used to introspect the details of an opaque token. Should be accompanied with a client-id and client-secret . client-id The Client Id to use for client authentication against the provided introspection-uri . client-secret The Client Secret to use for client authentication against the provided introspection-uri . authentication-converter-ref Reference to an OpaqueTokenAuthenticationConverter . Responsible for converting successful introspection result into an Authentication instance. <relying-party-registrations>: The container element for relying party(ies) registered ( ClientRegistration(../../saml2/login/overview.html#servlet-saml2login-relyingpartyregistration) ) with a SAML 2.0 Identity Provider. <relying-party-registrations> Attributes: id The ID that uniquely identifies the RelyingPartyRegistrationRepository . Child Elements of <relying-party-registrations>: asserting-party(#nsa-asserting-party) relying-party-registration(#nsa-relying-party-registration) <relying-party-registration>: Represents a relying party registered with a SAML 2.0 Identity Provider Parent Elements of <relying-party-registration>: relying-party-registrations(#nsa-relying-party-registrations) <relying-party-registration> Attributes: registration-id The ID that uniquely identifies the RelyingPartyRegistration . metadata-location The asserting party metadata location. client-id The relying party’s EntityID(https://www.oasis-open.org/committees/download.php/51890/SAML%20MD%20simplified%20overview.pdf#2.9%20EntityDescriptor) . assertion-consumer-service-location The AssertionConsumerService Location. Equivalent to the value found in <AssertionConsumerService Location=""…​""/> in the relying party’s <SPSSODescriptor> . assertion-consumer-service-binding the AssertionConsumerService Binding. Equivalent to the value found in <AssertionConsumerService Binding=""…​""/> in the relying party’s <SPSSODescriptor> . The supported values are POST and REDIRECT . single-logout-service-location The SingleLogoutService Location. Equivalent to the value found in <SingleLogoutService Location=""…​""/> in the relying party’s <SPSSODescriptor>. single-logout-service-response-location The SingleLogoutService ResponseLocation. Equivalent to the value found in <SingleLogoutService ResponseLocation=""…​""/> in the relying party’s <SPSSODescriptor>. single-logout-service-binding The SingleLogoutService Binding. Equivalent to the value found in <SingleLogoutService Binding=""…​""/> in the relying party’s <SPSSODescriptor>. The supported values are POST and REDIRECT . asserting-party-id A reference to the associated asserting party. Must reference an <asserting-party> element. Child Elements of <relying-party-registration>: decryption-credential(#nsa-decryption-credential) signing-credential(#nsa-signing-credential) <decryption-credential>: The decryption credentials associated with the relying party. Parent Elements of <decryption-credential>: relying-party-registration(#nsa-relying-party-registration) <decryption-credential> Attributes: certificate-location The location to get the certificate private-key-location The location to get the Relying Party’s private key <signing-credential>: The signing credentials associated with the relying party. Parent Elements of <verification-credential>: relying-party-registration(#nsa-relying-party-registration) <verification-credential> Attributes: certificate-location The location to get this certificate private-key-location The location to get the Relying Party’s private key <asserting-party>: The configuration information for a SAML 2.0 Asserting Party. Parent Elements of <asserting-party>: relying-party-registrations(#nsa-relying-party-registrations) <asserting-party> Attributes: asserting-party-id The ID that uniquely identifies the asserting party. entity-id The EntityID of the Asserting Party want-authn-requests-signed The WantAuthnRequestsSigned setting, indicating the asserting party’s preference that relying parties should sign the AuthnRequest before sending. single-sign-on-service-location The SingleSignOnService(https://www.oasis-open.org/committees/download.php/51890/SAML%20MD%20simplified%20overview.pdf#2.5%20Endpoint) Location. single-sign-on-service-binding The SingleSignOnService(https://www.oasis-open.org/committees/download.php/51890/SAML%20MD%20simplified%20overview.pdf#2.5%20Endpoint) Binding. The supported values are POST and REDIRECT . signing-algorithms The list of org.opensaml.saml.ext.saml2alg.SigningMethod Algorithms for this asserting party, in preference order. single-logout-service-location The SingleLogoutService Location. Equivalent to the value found in <SingleLogoutService Location=""…​""/> in the asserting party’s <IDPSSODescriptor>. single-logout-service-response-location The SingleLogoutService ResponseLocation. Equivalent to the value found in <SingleLogoutService ResponseLocation=""…​""/> in the asserting party’s <IDPSSODescriptor>. single-logout-service-binding The SingleLogoutService Binding. Equivalent to the value found in <SingleLogoutService Binding=""…​""/> in the asserting party’s <IDPSSODescriptor>. The supported values are POST and REDIRECT . Child Elements of <asserting-party>: encryption-credential(#nsa-encryption-credential) verification-credential(#nsa-verification-credential) <encryption-credential>: The encryption credentials associated with the asserting party. Parent Elements of <encryption-credential>: asserting-party(#nsa-asserting-party) <encryption-credential> Attributes: certificate-location The location to get the certificate private-key-location The location to get the Relying Party’s private key <verification-credential>: The verification credentials associated with the asserting party. Parent Elements of <verification-credential>: asserting-party(#nsa-asserting-party) <verification-credential> Attributes: certificate-location The location to get this certificate private-key-location The location to get the Relying Party’s private key <http-basic>: Adds a BasicAuthenticationFilter and BasicAuthenticationEntryPoint to the configuration. The latter will only be used as the configuration entry point if form-based login is not enabled. Parent Elements of <http-basic>: http(#nsa-http) <http-basic> Attributes: authentication-details-source-ref Reference to an AuthenticationDetailsSource which will be used by the authentication filter entry-point-ref Sets the AuthenticationEntryPoint which is used by the BasicAuthenticationFilter . <http-firewall> Element: This is a top-level element which can be used to inject a custom implementation of HttpFirewall into the FilterChainProxy created by the namespace. The default implementation should be suitable for most applications. <http-firewall> Attributes: ref Defines a reference to a Spring bean that implements HttpFirewall . <intercept-url>: This element is used to define the set of URL patterns that the application is interested in and to configure how they should be handled. It is used to construct the FilterInvocationSecurityMetadataSource used by the FilterSecurityInterceptor . It is also responsible for configuring a ChannelProcessingFilter if particular URLs need to be accessed by HTTPS, for example. When matching the specified patterns against an incoming request, the matching is done in the order in which the elements are declared. So the most specific patterns should come first and the most general should come last. Parent Elements of <intercept-url>: filter-security-metadata-source(#nsa-filter-security-metadata-source) http(#nsa-http) <intercept-url> Attributes: access Lists the access attributes which will be stored in the FilterInvocationSecurityMetadataSource for the defined URL pattern/method combination. This should be a comma-separated list of the security configuration attributes (such as role names). method The HTTP Method which will be used in combination with the pattern and servlet path (optional) to match an incoming request. If omitted, any method will match. If an identical pattern is specified with and without a method, the method-specific match will take precedence. pattern The pattern which defines the URL path. The content will depend on the request-matcher attribute from the containing http element, so will default to MVC matcher if Spring MVC is in the classpath. request-matcher-ref A reference to a RequestMatcher that will be used to determine if this <intercept-url> is used. requires-channel Can be ""http"" or ""https"" depending on whether a particular URL pattern should be accessed over HTTP or HTTPS respectively. Alternatively the value ""any"" can be used when there is no preference. If this attribute is present on any <intercept-url> element, then a ChannelProcessingFilter will be added to the filter stack and its additional dependencies added to the application context. If a <port-mappings> configuration is added, this will be used to by the SecureChannelProcessor and InsecureChannelProcessor beans to determine the ports used for redirecting to HTTP/HTTPS. This property is invalid for filter-security-metadata-source(#nsa-filter-security-metadata-source) servlet-path The servlet path which will be used in combination with the pattern and HTTP method to match an incoming request. This attribute is only applicable when request-matcher(#nsa-http-request-matcher) is 'mvc'. In addition, the value is only required in the following 2 use cases: 1) There are 2 or more HttpServlet 's registered in the ServletContext that have mappings starting with '/' and are different; 2) The pattern starts with the same value of a registered HttpServlet path, excluding the default (root) HttpServlet '/' . This property is invalid for filter-security-metadata-source(#nsa-filter-security-metadata-source) <jee>: Adds a J2eePreAuthenticatedProcessingFilter to the filter chain to provide integration with container authentication. Parent Elements of <jee>: http(#nsa-http) <jee> Attributes: mappable-roles A comma-separate list of roles to look for in the incoming HttpServletRequest. user-service-ref A reference to a user-service (or UserDetailsService bean) Id <logout>: Adds a LogoutFilter to the filter stack. This is configured with a SecurityContextLogoutHandler . Parent Elements of <logout>: http(#nsa-http) <logout> Attributes: delete-cookies A comma-separated list of the names of cookies which should be deleted when the user logs out. invalidate-session Maps to the invalidateHttpSession of the SecurityContextLogoutHandler . Defaults to ""true"", so the session will be invalidated on logout. logout-success-url The destination URL which the user will be taken to after logging out. Defaults to <form-login-login-page>/?logout (i.e. /login?logout) Setting this attribute will inject the SessionManagementFilter with a SimpleRedirectInvalidSessionStrategy configured with the attribute value. When an invalid session ID is submitted, the strategy will be invoked, redirecting to the configured URL. logout-url The URL which will cause a logout (i.e. which will be processed by the filter). Defaults to ""/logout"". success-handler-ref May be used to supply an instance of LogoutSuccessHandler which will be invoked to control the navigation after logging out. <saml2-login>: The SAML 2.0 Login(../../saml2/login/index.html#servlet-saml2login) feature configures authentication support using an SAML 2.0 Service Provider. Parent Elements of <saml2-login>: http(#nsa-http) <saml2-login> Attributes: relying-party-registration-repository-ref Reference to the RelyingPartyRegistrationRepository . authentication-request-repository-ref Reference to the Saml2AuthenticationRequestRepository . authentication-request-context-resolver-ref Reference to the Saml2AuthenticationRequestResolver . authentication-converter-ref Reference to the AuthenticationConverter . login-processing-url The URI where the filter processes authentication requests. login-page The URI to send users to login. authentication-success-handler-ref Reference to the AuthenticationSuccessHandler . authentication-failure-handler-ref Reference to the AuthenticationFailureHandler . authentication-manager-ref Reference to the AuthenticationManager . <saml2-logout>: The SAML 2.0 Single Logout(../../saml2/logout.html#servlet-saml2login-logout) feature configures support for RP- and AP-initiated SAML 2.0 Single Logout. Parent Elements of <saml2-logout>: http(#nsa-http) <saml2-logout> Attributes: logout-url The URL by which the relying or asserting party can trigger logout. logout-request-url The URL by which the asserting party can send a SAML 2.0 Logout Request. logout-response-url The URL by which the asserting party can send a SAML 2.0 Logout Response. relying-party-registration-repository-ref Reference to the RelyingPartyRegistrationRepository . logout-request-validator-ref Reference to the Saml2LogoutRequestValidator . logout-request-resolver-ref Reference to the Saml2LogoutRequestResolver . logout-request-repository-ref Reference to the Saml2LogoutRequestRepository . logout-response-validator-ref Reference to the Saml2LogoutResponseValidator . logout-response-resolver-ref Reference to the Saml2LogoutResponseResolver . <password-management>: This element configures password management. Parent Elements of <password-management>: http(#nsa-http) <password-management> Attributes: change-password-page The change password page. Defaults to ""/change-password"". <port-mappings>: By default, an instance of PortMapperImpl will be added to the configuration for use in redirecting to secure and insecure URLs. This element can optionally be used to override the default mappings which that class defines. Each child <port-mapping> element defines a pair of HTTP:HTTPS ports. The default mappings are 80:443 and 8080:8443. An example of overriding these can be found in Redirect to HTTPS(../../exploits/http.html#servlet-http-redirect) . Parent Elements of <port-mappings>: http(#nsa-http) Child Elements of <port-mappings>: port-mapping(#nsa-port-mapping) <port-mapping>: Provides a method to map http ports to https ports when forcing a redirect. Parent Elements of <port-mapping>: port-mappings(#nsa-port-mappings) <port-mapping> Attributes: http The http port to use. https The https port to use. <remember-me>: Adds the RememberMeAuthenticationFilter to the stack. This in turn will be configured with either a TokenBasedRememberMeServices , a PersistentTokenBasedRememberMeServices or a user-specified bean implementing RememberMeServices depending on the attribute settings. Parent Elements of <remember-me>: http(#nsa-http) <remember-me> Attributes: authentication-success-handler-ref Sets the authenticationSuccessHandler property on the RememberMeAuthenticationFilter if custom navigation is required. The value should be the name of a AuthenticationSuccessHandler bean in the application context. data-source-ref A reference to a DataSource bean. If this is set, PersistentTokenBasedRememberMeServices will be used and configured with a JdbcTokenRepositoryImpl instance. remember-me-parameter The name of the request parameter which toggles remember-me authentication. Defaults to ""remember-me"". Maps to the ""parameter"" property of AbstractRememberMeServices . remember-me-cookie The name of cookie which store the token for remember-me authentication. Defaults to ""remember-me"". Maps to the ""cookieName"" property of AbstractRememberMeServices . key Maps to the ""key"" property of AbstractRememberMeServices . Should be set to a unique value to ensure that remember-me cookies are only valid within the one application [ 3(#_footnotedef_3) ] . If this is not set a secure random value will be generated. Since generating secure random values can take a while, setting this value explicitly can help improve startup times when using the remember-me functionality. services-alias Exports the internally defined RememberMeServices as a bean alias, allowing it to be used by other beans in the application context. services-ref Allows complete control of the RememberMeServices implementation that will be used by the filter. The value should be the id of a bean in the application context which implements this interface. Should also implement LogoutHandler if a logout filter is in use. token-repository-ref Configures a PersistentTokenBasedRememberMeServices but allows the use of a custom PersistentTokenRepository bean. token-validity-seconds Maps to the tokenValiditySeconds property of AbstractRememberMeServices . Specifies the period in seconds for which the remember-me cookie should be valid. By default it will be valid for 14 days. use-secure-cookie It is recommended that remember-me cookies are only submitted over HTTPS and thus should be flagged as ""secure"". By default, a secure cookie will be used if the connection over which the login request is made is secure (as it should be). If you set this property to false , secure cookies will not be used. Setting it to true will always set the secure flag on the cookie. This attribute maps to the useSecureCookie property of AbstractRememberMeServices . user-service-ref The remember-me services implementations require access to a UserDetailsService , so there has to be one defined in the application context. If there is only one, it will be selected and used automatically by the namespace configuration. If there are multiple instances, you can specify a bean id explicitly using this attribute. <request-cache> Element: Sets the RequestCache instance which will be used by the ExceptionTranslationFilter to store request information before invoking an AuthenticationEntryPoint . Parent Elements of <request-cache>: http(#nsa-http) <request-cache> Attributes: ref Defines a reference to a Spring bean that is a RequestCache . <session-management>: Session-management related functionality is implemented by the addition of a SessionManagementFilter to the filter stack. Parent Elements of <session-management>: http(#nsa-http) <session-management> Attributes: authentication-strategy-explicit-invocation Setting this attribute to true will mean that SessionManagementFilter will not be injected and explicit invocation of SessionAuthenticationStrategy is required. invalid-session-url Setting this attribute will inject the SessionManagementFilter with a SimpleRedirectInvalidSessionStrategy configured with the attribute value. When an invalid session ID is submitted, the strategy will be invoked, redirecting to the configured URL. invalid-session-url Allows injection of the InvalidSessionStrategy instance used by the SessionManagementFilter. Use either this or the invalid-session-url attribute but not both. session-authentication-error-url Defines the URL of the error page which should be shown when the SessionAuthenticationStrategy raises an exception. If not set, an unauthorized (401) error code will be returned to the client. Note that this attribute doesn’t apply if the error occurs during a form-based login, where the URL for authentication failure will take precedence. session-authentication-strategy-ref Allows injection of the SessionAuthenticationStrategy instance used by the SessionManagementFilter session-fixation-protection Indicates how session fixation protection will be applied when a user authenticates. If set to ""none"", no protection will be applied. ""newSession"" will create a new empty session, with only Spring Security-related attributes migrated. ""migrateSession"" will create a new session and copy all session attributes to the new session. In Servlet 3.1 (Java EE 7) and newer containers, specifying ""changeSessionId"" will keep the existing session and use the container-supplied session fixation protection (HttpServletRequest#changeSessionId()). Defaults to ""changeSessionId"" in Servlet 3.1 and newer containers, ""migrateSession"" in older containers. Throws an exception if ""changeSessionId"" is used in older containers. If session fixation protection is enabled, the SessionManagementFilter is injected with an appropriately configured DefaultSessionAuthenticationStrategy . See the Javadoc for this class for more details. Child Elements of <session-management>: concurrency-control(#nsa-concurrency-control) <concurrency-control>: Adds support for concurrent session control, allowing limits to be placed on the number of active sessions a user can have. A ConcurrentSessionFilter will be created, and a ConcurrentSessionControlAuthenticationStrategy will be used with the SessionManagementFilter . If a form-login element has been declared, the strategy object will also be injected into the created authentication filter. An instance of SessionRegistry (a SessionRegistryImpl instance unless the user wishes to use a custom bean) will be created for use by the strategy. Parent Elements of <concurrency-control>: session-management(#nsa-session-management) <concurrency-control> Attributes: error-if-maximum-exceeded If set to ""true"" a SessionAuthenticationException will be raised when a user attempts to exceed the maximum allowed number of sessions. The default behaviour is to expire the original session. expired-url The URL a user will be redirected to if they attempt to use a session which has been ""expired"" by the concurrent session controller because the user has exceeded the number of allowed sessions and has logged in again elsewhere. Should be set unless exception-if-maximum-exceeded is set. If no value is supplied, an expiry message will just be written directly back to the response. expired-url Allows injection of the ExpiredSessionStrategy instance used by the ConcurrentSessionFilter max-sessions Maps to the maximumSessions property of ConcurrentSessionControlAuthenticationStrategy . Specify -1 as the value to support unlimited sessions. session-registry-alias It can also be useful to have a reference to the internal session registry for use in your own beans or an admin interface. You can expose the internal bean using the session-registry-alias attribute, giving it a name that you can use elsewhere in your configuration. session-registry-ref The user can supply their own SessionRegistry implementation using the session-registry-ref attribute. The other concurrent session control beans will be wired up to use it. <x509>: Adds support for X.509 authentication. An X509AuthenticationFilter will be added to the stack and an Http403ForbiddenEntryPoint bean will be created. The latter will only be used if no other authentication mechanisms are in use (its only functionality is to return an HTTP 403 error code). A PreAuthenticatedAuthenticationProvider will also be created which delegates the loading of user authorities to a UserDetailsService . Parent Elements of <x509>: http(#nsa-http) <x509> Attributes: authentication-details-source-ref A reference to an AuthenticationDetailsSource subject-principal-regex Defines a regular expression which will be used to extract the username from the certificate (for use with the UserDetailsService ). user-service-ref Allows a specific UserDetailsService to be used with X.509 in the case where multiple instances are configured. If not set, an attempt will be made to locate a suitable instance automatically and use that. <filter-chain-map>: Used to explicitly configure a FilterChainProxy instance with a FilterChainMap <filter-chain-map> Attributes: request-matcher Defines the strategy to use for matching incoming requests. Currently the options are 'ant' (for ant path patterns), 'regex' for regular expressions and 'ciRegex' for case-insensitive regular expressions. Child Elements of <filter-chain-map>: filter-chain(#nsa-filter-chain) <filter-chain>: Used within to define a specific URL pattern and the list of filters which apply to the URLs matching that pattern. When multiple filter-chain elements are assembled in a list in order to configure a FilterChainProxy, the most specific patterns must be placed at the top of the list, with most general ones at the bottom. Parent Elements of <filter-chain>: filter-chain-map(#nsa-filter-chain-map) <filter-chain> Attributes: filters A comma separated list of references to Spring beans that implement Filter . The value ""none"" means that no Filter should be used for this FilterChain . pattern A pattern that creates RequestMatcher in combination with the request-matcher(#nsa-filter-chain-map-request-matcher) request-matcher-ref A reference to a RequestMatcher that will be used to determine if any Filter from the filters attribute should be invoked. <filter-security-metadata-source>: Used to explicitly configure a FilterSecurityMetadataSource bean for use with a FilterSecurityInterceptor. Usually only needed if you are configuring a FilterChainProxy explicitly, rather than using the<http> element. The intercept-url elements used should only contain pattern, method and access attributes. Any others will result in a configuration error. <filter-security-metadata-source> Attributes: id A bean identifier, used for referring to the bean elsewhere in the context. request-matcher Defines the strategy use for matching incoming requests. Currently the options are 'ant' (for ant path patterns), 'regex' for regular expressions and 'ciRegex' for case-insensitive regular expressions. use-expressions Enables the use of expressions in the 'access' attributes in <intercept-url> elements rather than the traditional list of configuration attributes. Defaults to 'true'. If enabled, each attribute should contain a single Boolean expression. If the expression evaluates to 'true', access will be granted. Child Elements of <filter-security-metadata-source>: intercept-url(#nsa-intercept-url) 1(#_footnoteref_1) . See the xref:servlet/configuration/xml-namespace.adoc#ns-web-xml[introductory chapter 2(#_footnoteref_2) . This feature is really just provided for convenience and is not intended for production (where a view technology will have been chosen and can be used to render a customized login page). The class DefaultLoginPageGeneratingFilter is responsible for rendering the login page and will provide login forms for both normal form login and/or OIDC if required. 3(#_footnoteref_3) . This doesn’t affect the use of PersistentTokenBasedRememberMeServices , where the tokens are stored on the server side."
"https://docs.spring.io/spring-security/reference/6.3/servlet/appendix/namespace/method-security.html","Method Security: <method-security>: This element is the primary means of adding support for securing methods on Spring Security beans. Methods can be secured by the use of annotations (defined at the interface or class level) or by defining a set of pointcuts. <method-security> attributes: pre-post-enabled Enables Spring Security’s pre and post invocation annotations (@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) for this application context. Defaults to ""true"". secured-enabled Enables Spring Security’s @Secured annotation for this application context. Defaults to ""false"". jsr250-enabled Enables JSR-250 authorization annotations (@RolesAllowed, @PermitAll, @DenyAll) for this application context. Defaults to ""false"". mode If set to ""aspectj"", then uses AspectJ to intercept method invocations. proxy-target-class If true, class based proxying will be used instead of interface based proxying. Defaults to ""false"". security-context-holder-strategy-ref Specifies a SecurityContextHolderStrategy to use when retrieving the SecurityContext. Defaults to the value returned by SecurityContextHolder.getContextHolderStrategy(). observation-registry-ref A reference to the ObservationRegistry used for the FilterChain and related components Child Elements of <method-security>: expression-handler(http.html#nsa-expression-handler) protect-pointcut(#nsa-protect-pointcut) <global-method-security>: This element is the primary means of adding support for securing methods on Spring Security beans. Methods can be secured by the use of annotations (defined at the interface or class level) or by defining a set of pointcuts as child elements, using AspectJ syntax. <global-method-security> Attributes: access-decision-manager-ref Method security uses the same AccessDecisionManager configuration as web security, but this can be overridden using this attribute. By default an AffirmativeBased implementation is used for with a RoleVoter and an AuthenticatedVoter. authentication-manager-ref A reference to an AuthenticationManager that should be used for method security. jsr250-annotations Specifies whether JSR-250 style attributes are to be used (for example ""RolesAllowed""). This will require the javax.annotation.security classes on the classpath. Setting this to true also adds a Jsr250Voter to the AccessDecisionManager , so you need to make sure you do this if you are using a custom implementation and want to use these annotations. metadata-source-ref An external MethodSecurityMetadataSource instance can be supplied which will take priority over other sources (such as the default annotations). mode This attribute can be set to ""aspectj"" to specify that AspectJ should be used instead of the default Spring AOP. Secured methods must be woven with the AnnotationSecurityAspect from the spring-security-aspects module. It is important to note that AspectJ follows Java’s rule that annotations on interfaces are not inherited. This means that methods that define the Security annotations on the interface will not be secured. Instead, you must place the Security annotation on the class when using AspectJ. order Allows the advice ""order"" to be set for the method security interceptor. pre-post-annotations Specifies whether the use of Spring Security’s pre and post invocation annotations (@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) should be enabled for this application context. Defaults to ""disabled"". proxy-target-class If true, class based proxying will be used instead of interface based proxying. run-as-manager-ref A reference to an optional RunAsManager implementation which will be used by the configured MethodSecurityInterceptor secured-annotations Specifies whether the use of Spring Security’s @Secured annotations should be enabled for this application context. Defaults to ""disabled"". Child Elements of <global-method-security>: after-invocation-provider(#nsa-after-invocation-provider) expression-handler(http.html#nsa-expression-handler) pre-post-annotation-handling(#nsa-pre-post-annotation-handling) protect-pointcut(#nsa-protect-pointcut) <after-invocation-provider>: This element can be used to decorate an AfterInvocationProvider for use by the security interceptor maintained by the <global-method-security> namespace. You can define zero or more of these within the global-method-security element, each with a ref attribute pointing to an AfterInvocationProvider bean instance within your application context. Parent Elements of <after-invocation-provider>: global-method-security(#nsa-global-method-security) <after-invocation-provider> Attributes: ref Defines a reference to a Spring bean that implements AfterInvocationProvider . <pre-post-annotation-handling>: Allows the default expression-based mechanism for handling Spring Security’s pre and post invocation annotations (@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) to be replaced entirely. Only applies if these annotations are enabled. Parent Elements of <pre-post-annotation-handling>: global-method-security(#nsa-global-method-security) Child Elements of <pre-post-annotation-handling>: invocation-attribute-factory(#nsa-invocation-attribute-factory) post-invocation-advice(#nsa-post-invocation-advice) pre-invocation-advice(#nsa-pre-invocation-advice) <invocation-attribute-factory>: Defines the PrePostInvocationAttributeFactory instance which is used to generate pre and post invocation metadata from the annotated methods. Parent Elements of <invocation-attribute-factory>: pre-post-annotation-handling(#nsa-pre-post-annotation-handling) <invocation-attribute-factory> Attributes: ref Defines a reference to a Spring bean Id. <post-invocation-advice>: Customizes the PostInvocationAdviceProvider with the ref as the PostInvocationAuthorizationAdvice for the <pre-post-annotation-handling> element. Parent Elements of <post-invocation-advice>: pre-post-annotation-handling(#nsa-pre-post-annotation-handling) <post-invocation-advice> Attributes: ref Defines a reference to a Spring bean Id. <pre-invocation-advice>: Customizes the PreInvocationAuthorizationAdviceVoter with the ref as the PreInvocationAuthorizationAdviceVoter for the <pre-post-annotation-handling> element. Parent Elements of <pre-invocation-advice>: pre-post-annotation-handling(#nsa-pre-post-annotation-handling) <pre-invocation-advice> Attributes: ref Defines a reference to a Spring bean Id. Securing Methods using: <protect-pointcut> Rather than defining security attributes on an individual method or class basis using the @Secured annotation, you can define cross-cutting security constraints across whole sets of methods and interfaces in your service layer using the <protect-pointcut> element. You can find an example in the namespace introduction(../../authorization/method-security.html#ns-protect-pointcut) . Parent Elements of <protect-pointcut>: global-method-security(#nsa-global-method-security) method-security(#nsa-method-security) <protect-pointcut> Attributes: access Access configuration attributes list that applies to all methods matching the pointcut, e.g. ""ROLE_A,ROLE_B"" expression An AspectJ expression, including the execution keyword. For example, execution(int com.foo.TargetObject.countLength(String)) . <intercept-methods>: Can be used inside a bean definition to add a security interceptor to the bean and set up access configuration attributes for the bean’s methods <intercept-methods> Attributes: use-authorization-manager Use AuthorizationManager API instead of AccessDecisionManager (defaults to true) authorization-manager-ref Optional AuthorizationManager bean ID to be used instead of the default (supercedes use-authorization-manager) access-decision-manager-ref Optional AccessDecisionManager bean ID to be used by the created method security interceptor. Child Elements of <intercept-methods>: protect(#nsa-protect) <method-security-metadata-source>: Creates a MethodSecurityMetadataSource instance <method-security-metadata-source> Attributes: id A bean identifier, used for referring to the bean elsewhere in the context. use-expressions Enables the use of expressions in the 'access' attributes in <intercept-url> elements rather than the traditional list of configuration attributes. Defaults to 'false'. If enabled, each attribute should contain a single Boolean expression. If the expression evaluates to 'true', access will be granted. Child Elements of <method-security-metadata-source>: protect(#nsa-protect) <protect>: Defines a protected method and the access control configuration attributes that apply to it. We strongly advise you NOT to mix ""protect"" declarations with any services provided ""global-method-security"". Parent Elements of <protect>: intercept-methods(#nsa-intercept-methods) method-security-metadata-source(#nsa-method-security-metadata-source) <protect> Attributes: access Access configuration attributes list that applies to the method, e.g. ""ROLE_A,ROLE_B"". method A method name"
"https://docs.spring.io/spring-security/reference/6.3/servlet/appendix/namespace/ldap.html","LDAP Namespace Options: The LDAP implementation uses Spring LDAP extensively, so some familiarity with that project’s API may be useful. Defining the LDAP Server using the: <ldap-server> Element This element sets up a Spring LDAP ContextSource for use by the other LDAP beans, defining the location of the LDAP server and other information (such as a username and password, if it doesn’t allow anonymous access) for connecting to it. It can also be used to create an embedded server for testing. Details of the syntax for both options are covered in the LDAP chapter(../../authentication/passwords/ldap.html#servlet-authentication-ldap) . The actual ContextSource implementation is DefaultSpringSecurityContextSource which extends Spring LDAP’s LdapContextSource class. The manager-dn and manager-password attributes map to the latter’s userDn and password properties respectively. If you only have one server defined in your application context, the other LDAP namespace-defined beans will use it automatically. Otherwise, you can give the element an ""id"" attribute and refer to it from other namespace beans using the server-ref attribute. This is actually the bean id of the ContextSource instance, if you want to use it in other traditional Spring beans. <ldap-server> Attributes: mode Explicitly specifies which embedded ldap server should use. Values are apacheds and unboundid . By default, it will depends if the library is available in the classpath. id A bean identifier, used for referring to the bean elsewhere in the context. ldif Explicitly specifies an ldif file resource to load into an embedded LDAP server. The ldif should be a Spring resource pattern (i.e. classpath:init.ldif). The default is classpath*:*.ldif manager-dn Username (DN) of the ""manager"" user identity which will be used to authenticate to a (non-embedded) LDAP server. If omitted, anonymous access will be used. manager-password The password for the manager DN. This is required if the manager-dn is specified. port Specifies an IP port number. Used to configure an embedded LDAP server, for example. The default value is 33389. root Optional root suffix for the embedded LDAP server. Default is ""dc=springframework,dc=org"" url Specifies the ldap server URL when not using the embedded LDAP server. <ldap-authentication-provider>: This element is shorthand for the creation of an LdapAuthenticationProvider instance. By default this will be configured with a BindAuthenticator instance and a DefaultAuthoritiesPopulator . As with all namespace authentication providers, it must be included as a child of the authentication-provider element. Parent Elements of <ldap-authentication-provider>: authentication-manager(authentication-manager.html#nsa-authentication-manager) <ldap-authentication-provider> Attributes: group-role-attribute The LDAP attribute name which contains the role name which will be used within Spring Security. Maps to the DefaultLdapAuthoritiesPopulator 's groupRoleAttribute property. Defaults to ""cn"". group-search-base Search base for group membership searches. Maps to the DefaultLdapAuthoritiesPopulator 's groupSearchBase constructor argument. Defaults to """" (searching from the root). group-search-filter Group search filter. Maps to the DefaultLdapAuthoritiesPopulator 's groupSearchFilter property. Defaults to (uniqueMember={0}) . The substituted parameter is the DN of the user. role-prefix A non-empty string prefix that will be added to role strings loaded from persistent. Maps to the DefaultLdapAuthoritiesPopulator 's rolePrefix property. Defaults to ""ROLE_"". Use the value ""none"" for no prefix in cases where the default is non-empty. server-ref The optional server to use. If omitted, and a default LDAP server is registered (using <ldap-server> with no Id), that server will be used. user-context-mapper-ref Allows explicit customization of the loaded user object by specifying a UserDetailsContextMapper bean which will be called with the context information from the user’s directory entry user-details-class Allows the objectClass of the user entry to be specified. If set, the framework will attempt to load standard attributes for the defined class into the returned UserDetails object user-dn-pattern If your users are at a fixed location in the directory (i.e. you can work out the DN directly from the username without doing a directory search), you can use this attribute to map directly to the DN. It maps directly to the userDnPatterns property of AbstractLdapAuthenticator . The value is a specific pattern used to build the user’s DN, for example uid={0},ou=people . The key {0} must be present and will be substituted with the username. user-search-base Search base for user searches. Defaults to """". Only used with a 'user-search-filter'. If you need to perform a search to locate the user in the directory, then you can set these attributes to control the search. The BindAuthenticator will be configured with a FilterBasedLdapUserSearch and the attribute values map directly to the first two arguments of that bean’s constructor. If these attributes aren’t set and no user-dn-pattern has been supplied as an alternative, then the default search values of user-search-filter=""(uid={0})"" and user-search-base="""" will be used. user-search-filter The LDAP filter used to search for users (optional). For example (uid={0}) . The substituted parameter is the user’s login name. If you need to perform a search to locate the user in the directory, then you can set these attributes to control the search. The BindAuthenticator will be configured with a FilterBasedLdapUserSearch and the attribute values map directly to the first two arguments of that bean’s constructor. If these attributes aren’t set and no user-dn-pattern has been supplied as an alternative, then the default search values of user-search-filter=""(uid={0})"" and user-search-base="""" will be used. Child Elements of <ldap-authentication-provider>: password-compare(#nsa-password-compare) <password-compare>: This is used as child element to <ldap-provider> and switches the authentication strategy from BindAuthenticator to PasswordComparisonAuthenticator . Parent Elements of <password-compare>: ldap-authentication-provider(#nsa-ldap-authentication-provider) <password-compare> Attributes: hash Defines the hashing algorithm used on user passwords. We recommend strongly against using MD4, as it is a very weak hashing algorithm. password-attribute The attribute in the directory which contains the user password. Defaults to ""userPassword"". Child Elements of <password-compare>: password-encoder(authentication-manager.html#nsa-password-encoder) <ldap-user-service>: This element configures an LDAP UserDetailsService . The class used is LdapUserDetailsService which is a combination of a FilterBasedLdapUserSearch and a DefaultLdapAuthoritiesPopulator . The attributes it supports have the same usage as in <ldap-provider> . <ldap-user-service> Attributes: cache-ref Defines a reference to a cache for use with a UserDetailsService. group-role-attribute The LDAP attribute name which contains the role name which will be used within Spring Security. Defaults to ""cn"". group-search-base Search base for group membership searches. Defaults to """" (searching from the root). group-search-filter Group search filter. Defaults to (uniqueMember={0}) . The substituted parameter is the DN of the user. id A bean identifier, used for referring to the bean elsewhere in the context. role-prefix A non-empty string prefix that will be added to role strings loaded from persistent storage (e.g. ""ROLE_""). Use the value ""none"" for no prefix in cases where the default is non-empty. server-ref The optional server to use. If omitted, and a default LDAP server is registered (using <ldap-server> with no Id), that server will be used. user-context-mapper-ref Allows explicit customization of the loaded user object by specifying a UserDetailsContextMapper bean which will be called with the context information from the user’s directory entry user-details-class Allows the objectClass of the user entry to be specified. If set, the framework will attempt to load standard attributes for the defined class into the returned UserDetails object user-search-base Search base for user searches. Defaults to """". Only used with a 'user-search-filter'. user-search-filter The LDAP filter used to search for users (optional). For example (uid={0}) . The substituted parameter is the user’s login name."
"https://docs.spring.io/spring-security/reference/6.3/servlet/appendix/namespace/websocket.html","WebSocket Security: Spring Security 4.0+ provides support for authorizing messages. One concrete example of where this is useful is to provide authorization in WebSocket based applications. <websocket-message-broker>: The websocket-message-broker element has two different modes. If the websocket-message-broker@id(#nsa-websocket-message-broker-id) is not specified, then it will do the following things: Ensure that any SimpAnnotationMethodMessageHandler has the AuthenticationPrincipalArgumentResolver registered as a custom argument resolver. This allows the use of @AuthenticationPrincipal to resolve the principal of the current Authentication Ensures that the SecurityContextChannelInterceptor is automatically registered for the clientInboundChannel. This populates the SecurityContextHolder with the user that is found in the Message Ensures that a ChannelSecurityInterceptor is registered with the clientInboundChannel. This allows authorization rules to be specified for a message. Ensures that a CsrfChannelInterceptor is registered with the clientInboundChannel. This ensures that only requests from the original domain are enabled. Ensures that a CsrfTokenHandshakeInterceptor is registered with WebSocketHttpRequestHandler, TransportHandlingSockJsService, or DefaultSockJsService. This ensures that the expected CsrfToken from the HttpServletRequest is copied into the WebSocket Session attributes. If additional control is necessary, the id can be specified and a ChannelSecurityInterceptor will be assigned to the specified id. All the wiring with Spring’s messaging infrastructure can then be done manually. This is more cumbersome, but provides greater control over the configuration. <websocket-message-broker> Attributes: id A bean identifier, used for referring to the ChannelSecurityInterceptor bean elsewhere in the context. If specified, Spring Security requires explicit configuration within Spring Messaging. If not specified, Spring Security will automatically integrate with the messaging infrastructure as described in <websocket-message-broker>(#nsa-websocket-message-broker) same-origin-disabled Disables the requirement for CSRF token to be present in the Stomp headers (default false). Changing the default is useful if it is necessary to allow other origins to make SockJS connections. authorization-manager-ref Use this AuthorizationManager instance; when set, use-authorization-manager is ignored and assumed to be true use-authorization-manager Use AuthorizationManager API instead of SecurityMetadataSource API (defaults to true). security-context-holder-strategy-ref Use this SecurityContextHolderStrategy (note only supported in conjunction with the AuthorizationManager API) Child Elements of <websocket-message-broker>: expression-handler(http.html#nsa-expression-handler) intercept-message(#nsa-intercept-message) <intercept-message>: Defines an authorization rule for a message. Parent Elements of <intercept-message>: websocket-message-broker(#nsa-websocket-message-broker) <intercept-message> Attributes: pattern An ant based pattern that matches on the Message destination. For example, ""/ "" matches any Message with a destination; ""/admin/ "" matches any Message that has a destination that starts with ""/admin/**"". type The type of message to match on. Valid values are defined in SimpMessageType (i.e. CONNECT, CONNECT_ACK, HEARTBEAT, MESSAGE, SUBSCRIBE, UNSUBSCRIBE, DISCONNECT, DISCONNECT_ACK, OTHER). access The expression used to secure the Message. For example, ""denyAll"" will deny access to all of the matching Messages; ""permitAll"" will grant access to all of the matching Messages; ""hasRole('ADMIN') requires the current user to have the role 'ROLE_ADMIN' for the matching Messages."
"https://docs.spring.io/spring-security/reference/6.3/servlet/appendix/proxy-server.html","Proxy Server Configuration: When using a proxy server it is important to ensure that you have configured your application properly. For example, many applications will have a load balancer that responds to request for example.com/(https://example.com/) by forwarding the request to an application server at 192.168.1:8080(https://192.168.1:8080) Without proper configuration, the application server will not know that the load balancer exists and treat the request as though 192.168.1:8080(https://192.168.1:8080) was requested by the client. To fix this you can use RFC 7239(https://tools.ietf.org/html/rfc7239) to specify that a load balancer is being used. To make the application aware of this, you need to either configure your application server aware of the X-Forwarded headers. For example Tomcat uses the RemoteIpValve(https://tomcat.apache.org/tomcat-10.1-doc/api/org/apache/catalina/valves/RemoteIpValve.html) and Jetty uses ForwardedRequestCustomizer(https://eclipse.dev/jetty/javadoc/jetty-11/org/eclipse/jetty/server/ForwardedRequestCustomizer.html) . Alternatively, Spring 4.3+ users can leverage ForwardedHeaderFilter(https://github.com/spring-projects/spring-framework/blob/v4.3.3.RELEASE/spring-web/src/main/java/org/springframework/web/filter/ForwardedHeaderFilter.java) . Spring Boot users may use the server.use-forward-headers property to configure the application. See the Spring Boot documentation(https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto.webserver.use-behind-a-proxy-server) for further details."
"https://docs.spring.io/spring-security/reference/6.3/servlet/appendix/faq.html","Spring Security FAQ: This FAQ has the following sections: General Questions(#appendix-faq-general-questions) Common Problems(#appendix-faq-common-problems) Spring Security Architecture Questions(#appendix-faq-architecture) Common How-to Questions(#appendix-faq-howto) General Questions: This FAQ answers the following general questions: Can Spring Security take care of all my application security requirements?(#appendix-faq-other-concerns) Why Not Use web.xml Security?(#appendix-faq-web-xml) What Java and Spring Framework versions are required?(#appendix-faq-requirements) I have a complex scenario. What could be wrong?(#appendix-faq-start-simple) Can Spring Security take care of all my application security requirements?: Spring Security provides you with a flexible framework for your authentication and authorization requirements, but there are many other considerations for building a secure application that are outside its scope. Web applications are vulnerable to all kinds of attacks with which you should be familiar, preferably before you start development so that you can design and code with them in mind from the beginning. Check out the OWASP website(https://www.owasp.org/) for information on the major issues that face web application developers and the countermeasures you can use against them. Why Not Use web.xml Security?: Suppose you are developing an enterprise application based on Spring. You typically need to address four security concerns : authentication, web request security, service layer security (your methods that implement business logic), and domain object instance security (different domain objects can have different permissions). With these typical requirements in mind, we have the following considerations: Authentication : The servlet specification provides an approach to authentication. However, you need to configure the container to perform authentication, which typically requires editing of container-specific “realm” settings. This makes a non-portable configuration. Also, if you need to write an actual Java class to implement the container’s authentication interface, it becomes even more non-portable. With Spring Security, you achieve complete portability — right down to the WAR level. Also, Spring Security offers a choice of production-proven authentication providers and mechanisms, meaning you can switch your authentication approaches at deployment time. This is particularly valuable for software vendors writing products that need to work in an unknown target environment. Web request security: The servlet specification provides an approach to secure your request URIs. However, these URIs can be expressed only in the servlet specification’s own limited URI path format. Spring Security provides a far more comprehensive approach. For instance, you can use Ant paths or regular expressions, you can consider parts of the URI other than simply the requested page (for example, you can consider HTTP GET parameters), and you can implement your own runtime source of configuration data. This means that you can dynamically change your web request security during the actual execution of your web application. Service layer and domain object security: The absence of support in the servlet specification for services layer security or domain object instance security represents serious limitations for multi-tiered applications. Typically, developers either ignore these requirements or implement security logic within their MVC controller code (or, even worse, inside the views). There are serious disadvantages with this approach: Separation of concerns: Authorization is a crosscutting concern and should be implemented as such. MVC controllers or views that implement authorization code makes it more difficult to test both the controller and the authorization logic, is more difficult to debug, and often leads to code duplication. Support for rich clients and web services: If an additional client type must ultimately be supported, any authorization code embedded within the web layer is non-reusable. It should be considered that Spring remoting exporters export only service layer beans (not MVC controllers). As a result, authorization logic needs to be located in the services layer to support a multitude of client types. Layering issues: An MVC controller or view is the incorrect architectural layer in which to implement authorization decisions concerning services layer methods or domain object instances. While the principal may be passed to the services layer to enable it to make the authorization decision, doing so would introduce an additional argument on every services layer method. A more elegant approach is to use a ThreadLocal to hold the principal, although this would likely increase development time to a point where it would become more economical (on a cost-benefit basis) to use a dedicated security framework. Authorization code quality: It is often said of web frameworks that they “make it easier to do the right things, and harder to do the wrong things”. Security frameworks are the same, because they are designed in an abstract manner for a wide range of purposes. Writing your own authorization code from scratch does not provide the “design check” a framework would offer, and in-house authorization code typically lacks the improvements that emerge from widespread deployment, peer review, and new versions. For simple applications, servlet specification security may be enough. Although when considered within the context of web container portability, configuration requirements, limited web request security flexibility, and non-existent services layer and domain object instance security, it becomes clear why developers often look to alternative solutions. What Java and Spring Framework versions are required?: Spring Security 3.0 and 3.1 require at least JDK 1.5 and also require Spring 3.0.3 as a minimum. Ideally, you should use the latest release versions to avoid problems. Spring Security 2.0.x requires a minimum JDK version of 1.4 and is built against Spring 2.0.x. It should also be compatible with applications that use Spring 2.5.x. I have a complex scenario. What could be wrong?: (This answer address complex scenarios in general by dealing with a particular scenario.) Suppose you are new to Spring Security and need to build an application that supports CAS single sign-on over HTTPS while allowing basic authentication locally for certain URLs, authenticating against multiple back end user information sources (LDAP and JDBC). You have copied some configuration files but have found that it does not work. What could be wrong? You need an understanding of the technologies you intend to use before you can successfully build applications with them. Security is complicated. Setting up a simple configuration by using a login form and some hard-coded users with Spring Security’s namespace is reasonably straightforward. Moving to using a backed JDBC database is also easy enough. However, if you try to jump straight to a complicated deployment scenario like this scenario, you are almost certain to be frustrated. There is a big jump in the learning curve required to set up systems such as CAS, configure LDAP servers, and install SSL certificates properly. So you need to take things one step at a time. From a Spring Security perspective, the first thing you should do is follow the “Getting Started” guide on the website. This will take you through a series of steps to get up and running and get some idea of how the framework operates. If you use other technologies with which you are not familiar, you should do some research and try to make sure you can use them in isolation before combining them in a complex system. Common Problems: This section addresses the most common problems that people encounter when using Spring Security: Authentication When I try to log in, I get an error message that says, “Bad Credentials”. What is wrong?(#appendix-faq-bad-credentials) My application goes into an “endless loop” when I try to log in. What is going on?(#appendix-faq-login-loop) I get an exception with the message ""Access is denied (user is anonymous);"". What’s wrong?(#appendix-faq-anon-access-denied) Why can I still see a secured page even after I have logged out of my application?(#appendix-faq-cached-secure-page) I get an exception with a message of ""An Authentication object was not found in the SecurityContext"". What is wrong?(#auth-exception-credentials-not-found) I can’t get LDAP authentication to work. What’s wrong with my configuration?(#appendix-faq-ldap-authentication) Session Management I am using Spring Security’s concurrent session control to prevent users from logging in more than once at the same time. When I open another browser window after logging in, it does not stop me from logging in again. Why can I log in more than once?(#appendix-faq-concurrent-session-same-browser) Why does the session ID change when I authenticate through Spring Security?(#appendix-faq-new-session-on-authentication) I use Tomcat (or some other servlet container) and have enabled HTTPS for my login page, switching back to HTTP afterward. It does not work. I end up back at the login page after authenticating.(#appendix-faq-tomcat-https-session) I am trying to use the concurrent session-control support, but it does not let me log back in, even if I am sure I have logged out and have not exceeded the allowed sessions. What is wrong?(#appendix-faq-session-listener-missing) Spring Security creates a session somewhere, even though I have configured it not to, by setting the create-session attribute to never. What is wrong?(#appendix-faq-unwanted-session-creation) Miscellaneous I get a 403 Forbidden when performing a POST. What is wrong?(#appendix-faq-forbidden-csrf) I am forwarding a request to another URL by using the RequestDispatcher, but my security constraints are not being applied.(#appendix-faq-no-security-on-forward) I have added Spring Security’s <global-method-security> element to my application context, but, if I add security annotations to my Spring MVC controller beans (Struts actions etc.), they do not seem to have an effect. Why not?(#appendix-faq-method-security-in-web-context) I have a user who has definitely been authenticated, but, when I try to access the SecurityContextHolder during some requests, the Authentication is null. Why can I not see the user information?(#appendix-faq-no-filters-no-context) The authorize JSP Tag does not respect my method security annotations when using the URL attribute. Why not?(#appendix-faq-method-security-with-taglib) When I try to log in, I get an error message that says, “Bad Credentials”. What is wrong?: This means that authentication has failed. It does not say why, as it is good practice to avoid giving details that might help an attacker guess account names or passwords. This also means that, if you ask this question online, you should not expect an answer unless you provide additional information. As with any issue, you should check the output from the debug log and note any exception stacktraces and related messages. You should step through the code in a debugger to see where the authentication fails and why. You should also write a test case which exercises your authentication configuration outside the application. If you use hashed passwords, make sure the value stored in your database is exactly the same as the value produced by the PasswordEncoder configured in your application. My application goes into an “endless loop” when I try to log in. What is going on?: A common user problem with infinite loop and redirecting to the login page is caused by accidentally configuring the login page as a “secured” resource. Make sure your configuration allows anonymous access to the login page, either by excluding it from the security filter chain or marking it as requiring ROLE_ANONYMOUS . If your AccessDecisionManager includes an AuthenticatedVoter , you can use the IS_AUTHENTICATED_ANONYMOUSLY attribute. This is automatically available if you use the standard namespace configuration setup. From Spring Security 2.0.1 onwards, when you use namespace-based configuration, a check is made on loading the application context and a warning message logged if your login page appears to be protected. I get an exception with the message ""Access is denied (user is anonymous);"". What’s wrong?: This is a debug level message which occurs the first time an anonymous user attempts to access a protected resource. DEBUG [ExceptionTranslationFilter] - Access is denied (user is anonymous); redirecting to authentication entry point org.springframework.security.AccessDeniedException: Access is denied at org.springframework.security.vote.AffirmativeBased.decide(AffirmativeBased.java:68) at org.springframework.security.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:262) It is normal and shouldn’t be anything to worry about. Why can I still see a secured page even after I have logged out of my application?: The most common reason for this is that your browser has cached the page, and you are seeing a copy that is being retrieved from the browsers cache. Verify this by checking whether the browser is actually sending the request (check your server access logs and the debug log or use a suitable browser debugging plugin, such as “Tamper Data” for Firefox). This has nothing to do with Spring Security, and you should configure your application or server to set the appropriate Cache-Control response headers. Note that SSL requests are never cached. I get an exception with a message of ""An Authentication object was not found in the SecurityContext"". What is wrong?: The following listing shows another debug-level message that occurs the first time an anonymous user attempts to access a protected resource. However, this listing shows what happens when you do not have an AnonymousAuthenticationFilter in your filter chain configuration: DEBUG [ExceptionTranslationFilter] - Authentication exception occurred; redirecting to authentication entry point org.springframework.security.AuthenticationCredentialsNotFoundException: An Authentication object was not found in the SecurityContext at org.springframework.security.intercept.AbstractSecurityInterceptor.credentialsNotFound(AbstractSecurityInterceptor.java:342) at org.springframework.security.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:254) It is normal and is not something to worry about. I can’t get LDAP authentication to work. What’s wrong with my configuration?: Note that the permissions for an LDAP directory often do not let you read the password for a user. Hence, it is often not possible to use the What is a UserDetailsService and do I need one?(#appendix-faq-what-is-userdetailservice) where Spring Security compares the stored password with the one submitted by the user. The most common approach is to use LDAP “bind”, which is one of the operations supported by the LDAP protocol(https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol) . With this approach, Spring Security validates the password by trying to authenticate to the directory as the user. The most common problem with LDAP authentication is a lack of knowledge of the directory server tree structure and configuration. This differs from one company to another, so you have to find it out yourself. Before adding a Spring Security LDAP configuration to an application, you should write a simple test by using standard Java LDAP code (without Spring Security involved) and make sure you can get that to work first. For example, to authenticate a user, you could use the following code: Java Kotlin @Test public void ldapAuthenticationIsSuccessful() throws Exception { Hashtable<String,String> env = new Hashtable<String,String>(); env.put(Context.SECURITY_AUTHENTICATION, ""simple""); env.put(Context.SECURITY_PRINCIPAL, ""cn=joe,ou=users,dc=mycompany,dc=com""); env.put(Context.PROVIDER_URL, ""ldap://mycompany.com:389/dc=mycompany,dc=com""); env.put(Context.SECURITY_CREDENTIALS, ""joespassword""); env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory""); InitialLdapContext ctx = new InitialLdapContext(env, null); } @Test fun ldapAuthenticationIsSuccessful() { val env = Hashtable<String, String>() env[Context.SECURITY_AUTHENTICATION] = ""simple"" env[Context.SECURITY_PRINCIPAL] = ""cn=joe,ou=users,dc=mycompany,dc=com"" env[Context.PROVIDER_URL] = ""ldap://mycompany.com:389/dc=mycompany,dc=com"" env[Context.SECURITY_CREDENTIALS] = ""joespassword"" env[Context.INITIAL_CONTEXT_FACTORY] = ""com.sun.jndi.ldap.LdapCtxFactory"" val ctx = InitialLdapContext(env, null) } Session Management: Session management issues are a common source of questions. If you are developing Java web applications, you should understand how the session is maintained between the servlet container and the user’s browser. You should also understand the difference between secure and non-secure cookies and the implications of using HTTP and HTTPS and switching between the two. Spring Security has nothing to do with maintaining the session or providing session identifiers. This is entirely handled by the servlet container. I am using Spring Security’s concurrent session control to prevent users from logging in more than once at the same time. When I open another browser window after logging in, it does not stop me from logging in again. Why can I log in more than once?: Browsers generally maintain a single session per browser instance. You cannot have two separate sessions at once. So if you log in again in another window or tab you are just reauthenticating in the same session. So, if you log in again in another window or tab, you are reauthenticating in the same session. The server does not know anything about tabs, windows, or browser instances. All it sees are HTTP requests, and it ties those to a particular session according to the value of the JSESSIONID cookie that they contain. When a user authenticates during a session, Spring Security’s concurrent session control checks the number of other authenticated sessions that they have. If they are already authenticated with the same session, re-authenticating has no effect. Why does the session ID change when I authenticate through Spring Security?: With the default configuration, Spring Security changes the session ID when the user authenticates. If you use a Servlet 3.1 or newer container, the session ID is simply changed. If you use an older container, Spring Security invalidates the existing session, creates a new session, and transfers the session data to the new session. Changing the session identifier in this manner prevents “session-fixation” attacks. You can find more about this online and in the reference manual. I use Tomcat (or some other servlet container) and have enabled HTTPS for my login page, switching back to HTTP afterward. It does not work. I end up back at the login page after authenticating.: It doesn’t work - I just end up back at the login page after authenticating. This happens because sessions created under HTTPS, for which the session cookie is marked as “secure”, cannot subsequently be used under HTTP. The browser does not send the cookie back to the server, and any session state (including the security context information) is lost. Starting a session in HTTP first should work, as the session cookie is not marked as secure. However, Spring Security’s Session Fixation Protection(https://docs.spring.io/spring-security/site/docs/3.1.x/reference/springsecurity-single.html#ns-session-fixation) can interfere with this because it results in a new session ID cookie being sent back to the user’s browser, usually with the secure flag. To get around this, you can disable session fixation protection. However, in newer Servlet containers, you can also configure session cookies to never use the secure flag. Switching between HTTP and HTTPS is not a good idea in general, as any application that uses HTTP at all is vulnerable to man-in-the-middle attacks. To be truly secure, the user should begin accessing your site in HTTPS and continue using it until they log out. Even clicking on an HTTPS link from a page accessed over HTTP is potentially risky. If you need more convincing, check out a tool like sslstrip(https://github.com/moxie0/sslstrip/) . I am not switching between HTTP and HTTPS, but my session is still lost. What happened?: Sessions are maintained either by exchanging a session cookie or by adding a jsessionid parameter to URLs (this happens automatically if you use JSTL to output URLs or if you call HttpServletResponse.encodeUrl on URLs (before a redirect, for example). If clients have cookies disabled, and you are not rewriting URLs to include the jsessionid , the session is lost. Note that the use of cookies is preferred for security reasons, as it does not expose the session information in the URL. I am trying to use the concurrent session-control support, but it does not let me log back in, even if I am sure I have logged out and have not exceeded the allowed sessions. What is wrong?: Make sure you have added the listener to your web.xml file. It is essential to make sure that the Spring Security session registry is notified when a session is destroyed. Without it, the session information is not removed from the registry. The following example adds a listener in a web.xml file: <listener> <listener-class>org.springframework.security.web.session.HttpSessionEventPublisher</listener-class> </listener> Spring Security creates a session somewhere, even though I have configured it not to, by setting the create-session attribute to never. What is wrong?: This usually means that the user’s application is creating a session somewhere but that they are not aware of it. The most common culprit is a JSP. Many people are not aware that JSPs create sessions by default. To prevent a JSP from creating a session, add the <%@ page session=""false"" %> directive to the top of the page. If you have trouble working out where a session is being created, you can add some debugging code to track down the location(s). One way to do this is to add a javax.servlet.http.HttpSessionListener , which calls Thread.dumpStack() in the sessionCreated method, to your application. I get a 403 Forbidden when performing a POST. What is wrong?: If an HTTP 403 Forbidden error is returned for HTTP POST, but it works for HTTP GET, the issue is most likely related to CSRF(https://docs.spring.io/spring-security/site/docs/3.2.x/reference/htmlsingle/#csrf) . Either provide the CSRF Token or disable CSRF protection (the latter is not recommended). I am forwarding a request to another URL by using the RequestDispatcher, but my security constraints are not being applied.: By default, filters are not applied to forwards or includes. If you really want the security filters to be applied to forwards or includes, you have to configure these explicitly in your web.xml file by using the <dispatcher> element, which is a child element of the <filter-mapping> element. I have added Spring Security’s <global-method-security> element to my application context, but, if I add security annotations to my Spring MVC controller beans (Struts actions etc.), they do not seem to have an effect. Why not?: In a Spring web application, the application context that holds the Spring MVC beans for the dispatcher servlet is often separate from the main application context. It is often defined in a file called myapp-servlet.xml , where myapp is the name assigned to the Spring DispatcherServlet in the web.xml file. An application can have multiple DispatcherServlet instances, each with its own isolated application context. The beans in these “child” contexts are not visible to the rest of the application. The “parent” application context is loaded by the ContextLoaderListener you define in your web.xml file and is visible to all the child contexts. This parent context is usually where you define your security configuration, including the <global-method-security> element. As a result, any security constraints applied to methods in these web beans are not enforced, since the beans cannot be seen from the DispatcherServlet context. You need to either move the <global-method-security> declaration to the web context or move the beans you want secured into the main application context. Generally, we recommend applying method security at the service layer rather than on individual web controllers. I have a user who has definitely been authenticated, but, when I try to access the SecurityContextHolder during some requests, the Authentication is null. Why can I not see the user information?: Why can’t I see the user information? If you have excluded the request from the security filter chain by using the filters='none' attribute in the <intercept-url> element that matches the URL pattern, the SecurityContextHolder is not populated for that request. Check the debug log to see whether the request is passing through the filter chain. (You are reading the debug log, right?) The authorize JSP Tag does not respect my method security annotations when using the URL attribute. Why not?: Method security does not hide links when using the url attribute in <sec:authorize> , because we cannot readily reverse engineer what URL is mapped to what controller endpoint. We are limited because controllers can rely on headers, the current user, and other details to determine what method to invoke. Spring Security Architecture Questions: This section addresses common Spring Security architecture questions: How do I know which package class X is in?(#appendix-faq-where-is-class-x) How do the namespace elements map to conventional bean configurations?(#appendix-faq-namespace-to-bean-mapping) What does ""ROLE_"" mean and why do I need it on my role names?(#appendix-faq-role-prefix) How do I know which dependencies to add to my application to work with Spring Security?(#appendix-faq-what-dependencies) What dependencies are needed to run an embedded ApacheDS LDAP server?(#appendix-faq-apacheds-deps) What is a UserDetailsService and do I need one?(#appendix-faq-what-is-userdetailservice) How do I know which package class X is in?: The best way of locating classes is by installing the Spring Security source in your IDE. The distribution includes source jars for each of the modules the project is divided up into. Add these to your project source path, and then you can navigate directly to Spring Security classes ( Ctrl-Shift-T in Eclipse). This also makes debugging easier and lets you troubleshoot exceptions by looking directly at the code where they occur to see what is going on there. How do the namespace elements map to conventional bean configurations?: There is a general overview of what beans are created by the namespace in the namespace appendix of the reference guide. There is also a detailed blog article called ""Behind the Spring Security Namespace"" on blog.springsource.com(https://spring.io/blog/2010/03/06/behind-the-spring-security-namespace/) . If you want to know the full details, then the code is in the spring-security-config module within the Spring Security 3.0 distribution. You should probably read the chapters on namespace parsing in the standard Spring Framework reference documentation first. What does ""ROLE_"" mean and why do I need it on my role names?: Spring Security has a voter-based architecture, which means that an access decision is made by a series of AccessDecisionVoter instances. The voters act on the “configuration attributes”, which are specified for a secured resource (such as a method invocation). With this approach, not all attributes may be relevant to all voters, and a voter needs to know when it should ignore an attribute (abstain) and when it should vote to grant or deny access based on the attribute value. The most common voter is the RoleVoter , which, by default, votes whenever it finds an attribute with the ROLE_ prefix. It makes a simple comparison of the attribute (such as ROLE_USER ) with the names of the authorities that the current user has been assigned. If it finds a match (they have an authority called ROLE_USER ), it votes to grant access. Otherwise, it votes to deny access. You can change the prefix by setting the rolePrefix property of RoleVoter . If you need only to use roles in your application and have no need for other custom voters, you can set the prefix to a blank string. In that case, the RoleVoter treats all attributes as roles. How do I know which dependencies to add to my application to work with Spring Security?: It depends on what features you are using and what type of application you are developing. With Spring Security 3.0, the project jars are divided into clearly distinct areas of functionality, so it is straightforward to work out which Spring Security jars you need from your application requirements. All applications need the spring-security-core jar. If you are developing a web application, you need the spring-security-web jar. If you are using security namespace configuration, you need the spring-security-config jar. For LDAP support, you need the spring-security-ldap jar. And so on. For third-party jars, the situation is not always quite so obvious. A good starting point is to copy those from one of the pre-built sample applications WEB-INF/lib directories. For a basic application, you can start with the tutorial sample. For a basic application, you can start with the tutorial sample. If you want to use LDAP with an embedded test server, use the LDAP sample as a starting point. The reference manual also includes an appendix(#appendix-namespace) that lists the first-level dependencies for each Spring Security module, with some information on whether they are optional and when they are required. If you build your project with Maven, adding the appropriate Spring Security modules as dependencies to your pom.xml file automatically pulls in the core jars that the framework requires. Any that are marked as “optional” in the Spring Security pom.xml files have to be added to your own pom.xml file if you need them. What dependencies are needed to run an embedded ApacheDS LDAP server?: If you use Maven, you need to add the following to your pom.xml file dependencies: <dependency> <groupId>org.apache.directory.server</groupId> <artifactId>apacheds-core</artifactId> <version>1.5.5</version> <scope>runtime</scope> </dependency> <dependency> <groupId>org.apache.directory.server</groupId> <artifactId>apacheds-server-jndi</artifactId> <version>1.5.5</version> <scope>runtime</scope> </dependency> The other required jars should be pulled in transitively. What is a UserDetailsService and do I need one?: UserDetailsService is a DAO interface for loading data that is specific to a user account. It has no function other than to load that data for use by other components within the framework. It is not responsible for authenticating the user. Authenticating a user with a username and password combination is most commonly performed by the DaoAuthenticationProvider , which is injected with a UserDetailsService to let it load the password (and other data) for a user, to compare it with the submitted value. Note that, if you use LDAP, this approach may not work(#appendix-faq-ldap-authentication) . If you want to customize the authentication process, you should implement AuthenticationProvider yourself. See this blog article(https://spring.io/blog/2010/08/02/spring-security-in-google-app-engine/) for an example that integrate Spring Security authentication with Google App Engine. Common How-to Questions: This section addresses common how-to questions about Spring Security: I need to log in with more information than just the username. How do I add support for extra login fields (such as a company name)?(#appendix-faq-extra-login-fields) How do I apply different intercept-url constraints where only the fragment value of the requested URLs differs (such as /thing1#thing2 and /thing1#thing3)?(#appendix-faq-matching-url-fragments) How do I access the user’s IP Address (or other web-request data) in a UserDetailsService?(#appendix-faq-request-details-in-user-service) How do I access the HttpSession from a UserDetailsService?(#appendix-faq-access-session-from-user-service) How do I access the user’s password in a UserDetailsService?(#appendix-faq-password-in-user-service) How do I dynamically define the secured URLs within an application?(#appendix-faq-dynamic-url-metadata) How do I authenticate against LDAP but load user roles from a database?(#appendix-faq-ldap-authorities) I want to modify the property of a bean that is created by the namespace, but there is nothing in the schema to support it. What can I do short of abandoning namespace use?(#appendix-faq-namespace-post-processor) I need to log in with more information than just the username. How do I add support for extra login fields (such as a company name)?: This question comes up repeatedly, so you can find more information by searching online. The submitted login information is processed by an instance of UsernamePasswordAuthenticationFilter . You need to customize this class to handle the extra data fields. One option is to use your own customized authentication token class (rather than the standard UsernamePasswordAuthenticationToken ). Another option is to concatenate the extra fields with the username (for example, by using a : character as the separator) and pass them in the username property of UsernamePasswordAuthenticationToken . You also need to customize the actual authentication process. If you use a custom authentication token class, for example, you will have to write an AuthenticationProvider (or extend the standard DaoAuthenticationProvider ) to handle it. If you have concatenated the fields, you can implement your own UserDetailsService to split them up and load the appropriate user data for authentication. How do I apply different intercept-url constraints where only the fragment value of the requested URLs differs (such as /thing1#thing2 and /thing1#thing3)?: You cannot do this, since the fragment is not transmitted from the browser to the server. From the server’s perspective, the URLs are identical. This is a common question from GWT users. How do I access the user’s IP Address (or other web-request data) in a UserDetailsService?: You cannot (without resorting to something like thread-local variables), since the only information supplied to the interface is the username. Instead of implementing UserDetailsService , you should implement AuthenticationProvider directly and extract the information from the supplied Authentication token. In a standard web setup, the getDetails() method on the Authentication object will return an instance of WebAuthenticationDetails . If you need additional information, you can inject a custom AuthenticationDetailsSource into the authentication filter you are using. If you are using the namespace, for example with the <form-login> element, then you should remove this element and replace it with a <custom-filter> declaration pointing to an explicitly configured UsernamePasswordAuthenticationFilter . How do I access the HttpSession from a UserDetailsService?: You cannot, since the UserDetailsService has no awareness of the servlet API. If you want to store custom user data, you should customize the UserDetails object that is returned. This can then be accessed at any point, through the thread-local SecurityContextHolder . A call to SecurityContextHolder.getContext().getAuthentication().getPrincipal() returns this custom object. If you really need to access the session, you must do so by customizing the web tier. How do I access the user’s password in a UserDetailsService?: You cannot (and should not, even if you find a way to do so). You are probably misunderstanding its purpose. See "" What is a UserDetailsService?(#appendix-faq-what-is-userdetailservice) "", earlier in the FAQ. How do I dynamically define the secured URLs within an application?: People often ask about how to store the mapping between secured URLs and security metadata attributes in a database rather than in the application context. The first thing you should ask yourself is if you really need to do this. If an application needs to be secure, it also requires that the security be tested thoroughly based on a defined policy. It may require auditing and acceptance testing before being rolled out into a production environment. A security-conscious organization should be aware that the benefits of their diligent testing process could be wiped out instantly by letting the security settings be modified at runtime by changing a row or two in a configuration database. If you have taken this into account (perhaps by using multiple layers of security within your application), Spring Security lets you fully customize the source of security metadata. You can make it fully dynamic if you choose. Both method and web security are protected by subclasses of AbstractSecurityInterceptor , which is configured with a SecurityMetadataSource from which it obtains the metadata for a particular method or filter invocation. For web security, the interceptor class is FilterSecurityInterceptor , and it uses the FilterInvocationSecurityMetadataSource marker interface. The “secured object” type it operates on is a FilterInvocation . The default implementation (which is used both in the namespace <http> and when configuring the interceptor explicitly) stores the list of URL patterns and their corresponding list of “configuration attributes” (instances of ConfigAttribute ) in an in-memory map. To load the data from an alternative source, you must use an explicitly declared security filter chain (typically Spring Security’s FilterChainProxy ) to customize the FilterSecurityInterceptor bean. You cannot use the namespace. You would then implement FilterInvocationSecurityMetadataSource to load the data as you please for a particular FilterInvocation . The FilterInvocation object contains the HttpServletRequest , so you can obtain the URL or any other relevant information on which to base your decision, based on what the list of returned attributes contains. A basic outline would look something like the following example: Java Kotlin public class MyFilterSecurityMetadataSource implements FilterInvocationSecurityMetadataSource { public List<ConfigAttribute> getAttributes(Object object) { FilterInvocation fi = (FilterInvocation) object; String url = fi.getRequestUrl(); String httpMethod = fi.getRequest().getMethod(); List<ConfigAttribute> attributes = new ArrayList<ConfigAttribute>(); // Lookup your database (or other source) using this information and populate the // list of attributes return attributes; } public Collection<ConfigAttribute> getAllConfigAttributes() { return null; } public boolean supports(Class<?> clazz) { return FilterInvocation.class.isAssignableFrom(clazz); } } class MyFilterSecurityMetadataSource : FilterInvocationSecurityMetadataSource { override fun getAttributes(securedObject: Any): List<ConfigAttribute> { val fi = securedObject as FilterInvocation val url = fi.requestUrl val httpMethod = fi.request.method // Lookup your database (or other source) using this information and populate the // list of attributes return ArrayList() } override fun getAllConfigAttributes(): Collection<ConfigAttribute>? { return null } override fun supports(clazz: Class<*>): Boolean { return FilterInvocation::class.java.isAssignableFrom(clazz) } } For more information, look at the code for DefaultFilterInvocationSecurityMetadataSource . How do I authenticate against LDAP but load user roles from a database?: The LdapAuthenticationProvider bean (which handles normal LDAP authentication in Spring Security) is configured with two separate strategy interfaces, one that performs the authentication and one that loads the user authorities, called LdapAuthenticator and LdapAuthoritiesPopulator , respectively. The DefaultLdapAuthoritiesPopulator loads the user authorities from the LDAP directory and has various configuration parameters to let you specify how these should be retrieved. To use JDBC instead, you can implement the interface yourself, by using whatever SQL is appropriate for your schema: Java Kotlin public class MyAuthoritiesPopulator implements LdapAuthoritiesPopulator { @Autowired JdbcTemplate template; List<GrantedAuthority> getGrantedAuthorities(DirContextOperations userData, String username) { return template.query(""select role from roles where username = ?"", new String[] {username}, new RowMapper<GrantedAuthority>() { /** * We're assuming here that you're using the standard convention of using the role * prefix ""ROLE_"" to mark attributes which are supported by Spring Security's RoleVoter. */ @Override public GrantedAuthority mapRow(ResultSet rs, int rowNum) throws SQLException { return new SimpleGrantedAuthority(""ROLE_"" + rs.getString(1)); } }); } } class MyAuthoritiesPopulator : LdapAuthoritiesPopulator { @Autowired lateinit var template: JdbcTemplate override fun getGrantedAuthorities(userData: DirContextOperations, username: String): MutableList<GrantedAuthority?> { return template.query(""select role from roles where username = ?"", arrayOf(username) ) { rs, _ -> /** * We're assuming here that you're using the standard convention of using the role * prefix ""ROLE_"" to mark attributes which are supported by Spring Security's RoleVoter. */ SimpleGrantedAuthority(""ROLE_"" + rs.getString(1)) } } } You would then add a bean of this type to your application context and inject it into the LdapAuthenticationProvider . This is covered in the section on configuring LDAP by using explicit Spring beans in the LDAP chapter of the reference manual. Note that you cannot use the namespace for configuration in this case. You should also consult the security-api-url[Javadoc] for the relevant classes and interfaces. I want to modify the property of a bean that is created by the namespace, but there is nothing in the schema to support it. What can I do short of abandoning namespace use?: The namespace functionality is intentionally limited, so it does not cover everything that you can do with plain beans. If you want to do something simple, such as modifying a bean or injecting a different dependency, you can do so by adding a BeanPostProcessor to your configuration. You can find more information in the Spring Reference Manual(https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/htmlsingle/spring-framework-reference.html#beans-factory-extension-bpp) . To do so, you need to know a bit about which beans are created, so you should also read the blog article mentioned in the earlier question on how the namespace maps to Spring beans(#appendix-faq-namespace-to-bean-mapping) . Normally, you would add the functionality you require to the postProcessBeforeInitialization method of BeanPostProcessor . Suppose that you want to customize the AuthenticationDetailsSource used by the UsernamePasswordAuthenticationFilter (created by the form-login element). You want to extract a particular header called CUSTOM_HEADER from the request and use it while authenticating the user. The processor class would look like the following listing: Java Kotlin public class CustomBeanPostProcessor implements BeanPostProcessor { public Object postProcessAfterInitialization(Object bean, String name) { if (bean instanceof UsernamePasswordAuthenticationFilter) { System.out.println(""********* Post-processing "" + name); ((UsernamePasswordAuthenticationFilter)bean).setAuthenticationDetailsSource( new AuthenticationDetailsSource() { public Object buildDetails(Object context) { return ((HttpServletRequest)context).getHeader(""CUSTOM_HEADER""); } }); } return bean; } public Object postProcessBeforeInitialization(Object bean, String name) { return bean; } } class CustomBeanPostProcessor : BeanPostProcessor { override fun postProcessAfterInitialization(bean: Any, name: String): Any { if (bean is UsernamePasswordAuthenticationFilter) { println(""********* Post-processing $name"") bean.setAuthenticationDetailsSource( AuthenticationDetailsSource<HttpServletRequest, Any?> { context -> context.getHeader(""CUSTOM_HEADER"") }) } return bean } override fun postProcessBeforeInitialization(bean: Any, name: String?): Any { return bean } } You would then register this bean in your application context. Spring automatically invoke it on the beans defined in the application context."
"https://docs.spring.io/spring-security/reference/6.3/reactive/index.html","Reactive Applications: Reactive applications work very differently than Servlet Applications(../servlet/index.html#servlet-applications) . This section discusses how Spring Security works with reactive applications which are typically written using Spring’s WebFlux."
"https://docs.spring.io/spring-security/reference/6.3/reactive/getting-started.html","Getting Started with WebFlux Applications: This section covers the minimum setup for how to use Spring Security with Spring Boot in a reactive application. The completed application can be found in our samples repository(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/reactive/webflux/java/hello-security) . For your convenience, you can download a minimal Reactive Spring Boot + Spring Security application by clicking here(https://start.spring.io/starter.zip?type=maven-project&language=java&packaging=jar&jvmVersion=1.8&groupId=example&artifactId=hello-security&name=hello-security&description=Hello%20Security&packageName=example.hello-security&dependencies=webflux,security) . Updating Dependencies: You can add Spring Security to your Spring Boot project by adding spring-boot-starter-security . Maven Gradle <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-security</artifactId> </dependency> implementation 'org.springframework.boot:spring-boot-starter-security' Starting Hello Spring Security Boot: You can now run the Spring Boot application(https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-running-with-the-maven-plugin) by using the Maven Plugin’s run goal. The following example shows how to do so (and the beginning of the output from doing so): Running Spring Boot Application Maven Gradle $ ./mvnw spring-boot:run ... INFO 23689 --- [ restartedMain] .s.s.UserDetailsServiceAutoConfiguration : Using generated security password: 8e557245-73e2-4286-969a-ff57fe326336 ... $ ./gradlew bootRun ... INFO 23689 --- [ restartedMain] .s.s.UserDetailsServiceAutoConfiguration : Using generated security password: 8e557245-73e2-4286-969a-ff57fe326336 ... Authenticating: You can access the application at localhost:8080/(http://localhost:8080/) which will redirect the browser to the default log in page. You can provide the default username of user with the randomly generated password that is logged to the console. The browser is then taken to the orginally requested page. To log out you can visit localhost:8080/logout(http://localhost:8080/logout) and then confirming you wish to log out. Spring Boot Auto Configuration: Spring Boot automatically adds Spring Security which requires all requests be authenticated. It also generates a user with a randomly generated password that is logged to the console which can be used to authenticate using form or basic authentication."
"https://docs.spring.io/spring-security/reference/6.3/reactive/authentication/x509.html","Reactive X.509 Authentication: Similar to Servlet X.509 authentication(../../servlet/authentication/x509.html#servlet-x509) , the reactive x509 authentication filter allows extracting an authentication token from a certificate provided by a client. The following example shows a reactive x509 security configuration: Java Kotlin @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .x509(withDefaults()) .authorizeExchange(exchanges -> exchanges .anyExchange().permitAll() ); return http.build(); } @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { x509 { } authorizeExchange { authorize(anyExchange, authenticated) } } } In the preceding configuration, when neither principalExtractor nor authenticationManager is provided, defaults are used. The default principal extractor is SubjectDnX509PrincipalExtractor , which extracts the CN (common name) field from a certificate provided by a client. The default authentication manager is ReactivePreAuthenticatedAuthenticationManager , which performs user account validation, checking that a user account with a name extracted by principalExtractor exists and that it is not locked, disabled, or expired. The following example demonstrates how these defaults can be overridden: Java Kotlin @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { SubjectDnX509PrincipalExtractor principalExtractor = new SubjectDnX509PrincipalExtractor(); principalExtractor.setSubjectDnRegex(""OU=(.*?)(?:,|$)""); ReactiveAuthenticationManager authenticationManager = authentication -> { authentication.setAuthenticated(""Trusted Org Unit"".equals(authentication.getName())); return Mono.just(authentication); }; http .x509(x509 -> x509 .principalExtractor(principalExtractor) .authenticationManager(authenticationManager) ) .authorizeExchange(exchanges -> exchanges .anyExchange().authenticated() ); return http.build(); } @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain? { val customPrincipalExtractor = SubjectDnX509PrincipalExtractor() customPrincipalExtractor.setSubjectDnRegex(""OU=(.*?)(?:,|$)"") val customAuthenticationManager = ReactiveAuthenticationManager { authentication: Authentication -> authentication.isAuthenticated = ""Trusted Org Unit"" == authentication.name Mono.just(authentication) } return http { x509 { principalExtractor = customPrincipalExtractor authenticationManager = customAuthenticationManager } authorizeExchange { authorize(anyExchange, authenticated) } } } In the previous example, a username is extracted from the OU field of a client certificate instead of CN, and account lookup using ReactiveUserDetailsService is not performed at all. Instead, if the provided certificate issued to an OU named “Trusted Org Unit”, a request is authenticated. For an example of configuring Netty and WebClient or curl command-line tool to use mutual TLS and enable X.509 authentication, see github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration/authentication/x509(https://github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration/authentication/x509) ."
"https://docs.spring.io/spring-security/reference/6.3/reactive/authentication/logout.html","Logout: Spring Security provides a logout endpoint by default. Once logged in, you can GET /logout to see a default logout confirmation page, or you can POST /logout to initiate logout. This will: clear the ServerCsrfTokenRepository , ServerSecurityContextRepository , and redirect back to the login page Often, you will want to also invalidate the session on logout. To achieve this, you can add the WebSessionServerLogoutHandler to your logout configuration, like so: Java Kotlin @Bean SecurityWebFilterChain http(ServerHttpSecurity http) throws Exception { DelegatingServerLogoutHandler logoutHandler = new DelegatingServerLogoutHandler( new SecurityContextServerLogoutHandler(), new WebSessionServerLogoutHandler() ); http .authorizeExchange((exchange) -> exchange.anyExchange().authenticated()) .logout((logout) -> logout.logoutHandler(logoutHandler)); return http.build(); } @Bean fun http(http: ServerHttpSecurity): SecurityWebFilterChain { val customLogoutHandler = DelegatingServerLogoutHandler( SecurityContextServerLogoutHandler(), WebSessionServerLogoutHandler() ) return http { authorizeExchange { authorize(anyExchange, authenticated) } logout { logoutHandler = customLogoutHandler } } }"
"https://docs.spring.io/spring-security/reference/6.3/reactive/authentication/concurrent-sessions-control.html","Concurrent Sessions Control: Similar to Servlet’s Concurrent Sessions Control(../../servlet/authentication/session-management.html#ns-concurrent-sessions) , Spring Security also provides support to limit the number of concurrent sessions a user can have in a Reactive application. When you set up Concurrent Sessions Control in Spring Security, it monitors authentications carried out through Form Login, OAuth 2.0 Login(../oauth2/login/index.html) , and HTTP Basic authentication by hooking into the way those authentication mechanisms handle authentication success. More specifically, the session management DSL will add the ConcurrentSessionControlServerAuthenticationSuccessHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/server/authentication/ConcurrentSessionControlServerAuthenticationSuccessHandler.html) and the RegisterSessionServerAuthenticationSuccessHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/server/authentication/RegisterSessionServerAuthenticationSuccessHandler.html) to the list of ServerAuthenticationSuccessHandler used by the authentication filter. The following sections contains examples of how to configure Concurrent Sessions Control. I want to limit the number of concurrent sessions a user can have(#reactive-concurrent-sessions-control-limit) I want to customize the strategy used when the maximum number of sessions is exceeded(#concurrent-sessions-control-custom-strategy) I want to know how to specify a ReactiveSessionRegistry(#reactive-concurrent-sessions-control-specify-session-registry) I want to see a sample application that uses Concurrent Sessions Control(#concurrent-sessions-control-sample) I want to know how to disable it for some authentication filter(#disabling-for-authentication-filters) Limiting Concurrent Sessions: By default, Spring Security will allow any number of concurrent sessions for a user. To limit the number of concurrent sessions, you can use the maximumSessions DSL method: Configuring one session for any user Java Kotlin @Bean SecurityWebFilterChain filterChain(ServerHttpSecurity http) { http // ... .sessionManagement((sessions) -> sessions .concurrentSessions((concurrency) -> concurrency .maximumSessions(SessionLimit.of(1)) ) ); return http.build(); } @Bean ReactiveSessionRegistry reactiveSessionRegistry() { return new InMemoryReactiveSessionRegistry(); } @Bean open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... sessionManagement { sessionConcurrency { maximumSessions = SessionLimit.of(1) } } } } @Bean open fun reactiveSessionRegistry(): ReactiveSessionRegistry { return InMemoryReactiveSessionRegistry() } The above configuration allows one session for any user. Similarly, you can also allow unlimited sessions by using the SessionLimit#UNLIMITED constant: Configuring unlimited sessions Java Kotlin @Bean SecurityWebFilterChain filterChain(ServerHttpSecurity http) { http // ... .sessionManagement((sessions) -> sessions .concurrentSessions((concurrency) -> concurrency .maximumSessions(SessionLimit.UNLIMITED)) ); return http.build(); } @Bean ReactiveSessionRegistry reactiveSessionRegistry() { return new InMemoryReactiveSessionRegistry(); } @Bean open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... sessionManagement { sessionConcurrency { maximumSessions = SessionLimit.UNLIMITED } } } } @Bean open fun reactiveSessionRegistry(webSessionManager: WebSessionManager): ReactiveSessionRegistry { return InMemoryReactiveSessionRegistry() } Since the maximumSessions method accepts a SessionLimit interface, which in turn extends Function<Authentication, Mono<Integer>> , you can have a more complex logic to determine the maximum number of sessions based on the user’s authentication: Configuring maximumSessions based on Authentication Java Kotlin @Bean SecurityWebFilterChain filterChain(ServerHttpSecurity http) { http // ... .sessionManagement((sessions) -> sessions .concurrentSessions((concurrency) -> concurrency .maximumSessions(maxSessions())) ); return http.build(); } private SessionLimit maxSessions() { return (authentication) -> { if (authentication.getAuthorities().contains(new SimpleGrantedAuthority(""ROLE_UNLIMITED_SESSIONS""))) { return Mono.empty(); // allow unlimited sessions for users with ROLE_UNLIMITED_SESSIONS } if (authentication.getAuthorities().contains(new SimpleGrantedAuthority(""ROLE_ADMIN""))) { return Mono.just(2); // allow two sessions for admins } return Mono.just(1); // allow one session for every other user }; } @Bean ReactiveSessionRegistry reactiveSessionRegistry() { return new InMemoryReactiveSessionRegistry(); } @Bean open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... sessionManagement { sessionConcurrency { maximumSessions = maxSessions() } } } } fun maxSessions(): SessionLimit { return { authentication -> if (authentication.authorities.contains(SimpleGrantedAuthority(""ROLE_UNLIMITED_SESSIONS""))) Mono.empty if (authentication.authorities.contains(SimpleGrantedAuthority(""ROLE_ADMIN""))) Mono.just(2) Mono.just(1) } } @Bean open fun reactiveSessionRegistry(): ReactiveSessionRegistry { return InMemoryReactiveSessionRegistry() } When the maximum number of sessions is exceeded, by default, the least recently used session(s) will be expired. If you want to change that behavior, you can customize the strategy used when the maximum number of sessions is exceeded(#concurrent-sessions-control-custom-strategy) . The Concurrent Session Management is not aware if there is another session in some Identity Provider that you might use via OAuth 2 Login(../oauth2/login/index.html) for example. If you also need to invalidate the session against the Identity Provider you must include your own implementation of ServerMaximumSessionsExceededHandler(#concurrent-sessions-control-custom-strategy) . Handling Maximum Number of Sessions Exceeded: By default, when the maximum number of sessions is exceeded, the least recently used session(s) will be expired by using the InvalidateLeastUsedMaximumSessionsExceededHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/server/authentication/session/InvalidateLeastUsedMaximumSessionsExceededHandler.html) . Spring Security also provides another implementation that prevents the user from creating new sessions by using the PreventLoginMaximumSessionsExceededHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/server/authentication/session/PreventLoginMaximumSessionsExceededHandler.html) . If you want to use your own strategy, you can provide a different implementation of ServerMaximumSessionsExceededHandler(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/web/server/authentication/session/ServerMaximumSessionsExceededHandler.html) . Configuring maximumSessionsExceededHandler Java Kotlin @Bean SecurityWebFilterChain filterChain(ServerHttpSecurity http) { http // ... .sessionManagement((sessions) -> sessions .concurrentSessions((concurrency) -> concurrency .maximumSessions(SessionLimit.of(1)) .maximumSessionsExceededHandler(new PreventLoginMaximumSessionsExceededHandler()) ) ); return http.build(); } @Bean ReactiveSessionRegistry reactiveSessionRegistry() { return new InMemoryReactiveSessionRegistry(); } @Bean open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... sessionManagement { sessionConcurrency { maximumSessions = SessionLimit.of(1) maximumSessionsExceededHandler = PreventLoginMaximumSessionsExceededHandler() } } } } @Bean open fun reactiveSessionRegistry(): ReactiveSessionRegistry { return InMemoryReactiveSessionRegistry() } Specifying a ReactiveSessionRegistry: In order to keep track of the user’s sessions, Spring Security uses a ReactiveSessionRegistry(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/core/session/ReactiveSessionRegistry.html) , and, every time a user logs in, their session information is saved. Spring Security ships with InMemoryReactiveSessionRegistry(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/core/session/InMemoryReactiveSessionRegistry.html) implementation of ReactiveSessionRegistry . To specify a ReactiveSessionRegistry implementation you can either declare it as a bean: ReactiveSessionRegistry as a Bean Java Kotlin @Bean SecurityWebFilterChain filterChain(ServerHttpSecurity http) { http // ... .sessionManagement((sessions) -> sessions .concurrentSessions((concurrency) -> concurrency .maximumSessions(SessionLimit.of(1)) ) ); return http.build(); } @Bean ReactiveSessionRegistry reactiveSessionRegistry() { return new MyReactiveSessionRegistry(); } @Bean open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... sessionManagement { sessionConcurrency { maximumSessions = SessionLimit.of(1) } } } } @Bean open fun reactiveSessionRegistry(): ReactiveSessionRegistry { return MyReactiveSessionRegistry() } or you can use the sessionRegistry DSL method: ReactiveSessionRegistry using sessionRegistry DSL method Java Kotlin @Bean SecurityWebFilterChain filterChain(ServerHttpSecurity http) { http // ... .sessionManagement((sessions) -> sessions .concurrentSessions((concurrency) -> concurrency .maximumSessions(SessionLimit.of(1)) .sessionRegistry(new MyReactiveSessionRegistry()) ) ); return http.build(); } @Bean open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... sessionManagement { sessionConcurrency { maximumSessions = SessionLimit.of(1) sessionRegistry = MyReactiveSessionRegistry() } } } } Invalidating Registered User’s Sessions: At times, it is handy to be able to invalidate all or some of a user’s sessions. For example, when a user changes their password, you may want to invalidate all of their sessions so that they are forced to log in again. To do that, you can use the ReactiveSessionRegistry bean to retrieve all the user’s sessions, invalidate them, and them remove them from the WebSessionStore : Using ReactiveSessionRegistry to invalidate sessions manually Java public class SessionControl { private final ReactiveSessionRegistry reactiveSessionRegistry; private final WebSessionStore webSessionStore; public Mono<Void> invalidateSessions(String username) { return this.reactiveSessionRegistry.getAllSessions(username) .flatMap((session) -> session.invalidate().thenReturn(session)) .flatMap((session) -> this.webSessionStore.removeSession(session.getSessionId())) .then(); } } Disabling It for Some Authentication Filters: By default, Concurrent Sessions Control will be configured automatically for Form Login, OAuth 2.0 Login, and HTTP Basic authentication as long as they do not specify an ServerAuthenticationSuccessHandler themselves. For example, the following configuration will disable Concurrent Sessions Control for Form Login: Disabling Concurrent Sessions Control for Form Login Java Kotlin @Bean SecurityWebFilterChain filterChain(ServerHttpSecurity http) { http // ... .formLogin((login) -> login .authenticationSuccessHandler(new RedirectServerAuthenticationSuccessHandler(""/"")) ) .sessionManagement((sessions) -> sessions .concurrentSessions((concurrency) -> concurrency .maximumSessions(SessionLimit.of(1)) ) ); return http.build(); } @Bean open fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... formLogin { authenticationSuccessHandler = RedirectServerAuthenticationSuccessHandler(""/"") } sessionManagement { sessionConcurrency { maximumSessions = SessionLimit.of(1) } } } } Adding Additional Success Handlers Without Disabling Concurrent Sessions Control: You can also include additional ServerAuthenticationSuccessHandler instances to the list of handlers used by the authentication filter without disabling Concurrent Sessions Control. To do that you can use the authenticationSuccessHandler(Consumer<List<ServerAuthenticationSuccessHandler>>) method: Adding additional handlers Java @Bean SecurityWebFilterChain filterChain(ServerHttpSecurity http) { http // ... .formLogin((login) -> login .authenticationSuccessHandler((handlers) -> handlers.add(new MyAuthenticationSuccessHandler())) ) .sessionManagement((sessions) -> sessions .concurrentSessions((concurrency) -> concurrency .maximumSessions(SessionLimit.of(1)) ) ); return http.build(); } Checking a Sample Application: You can check the sample application here(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/reactive/webflux/java/session-management/maximum-sessions) ."
"https://docs.spring.io/spring-security/reference/6.3/reactive/authorization/authorize-http-requests.html","Authorize ServerHttpRequest: Spring Security provides support for authorizing the incoming HTTP requests. By default, Spring Security’s authorization will require all requests to be authenticated. The explicit configuration looks like: All Requests Require Authenticated User Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .anyExchange().authenticated() ) .httpBasic(withDefaults()) .formLogin(withDefaults()); return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, authenticated) } formLogin { } httpBasic { } } } We can configure Spring Security to have different rules by adding more rules in order of precedence. Multiple Authorize Requests Rules Java Kotlin import static org.springframework.security.authorization.AuthorityReactiveAuthorizationManager.hasRole; // ... @Bean SecurityWebFilterChain springWebFilterChain(ServerHttpSecurity http) { http // ... .authorizeExchange((authorize) -> authorize (1) .pathMatchers(""/resources/**"", ""/signup"", ""/about"").permitAll() (2) .pathMatchers(""/admin/**"").hasRole(""ADMIN"") (3) .pathMatchers(""/db/**"").access((authentication, context) -> (4) hasRole(""ADMIN"").check(authentication, context) .filter(decision -> !decision.isGranted()) .switchIfEmpty(hasRole(""DBA"").check(authentication, context)) ) .anyExchange().denyAll() (5) ); return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { (1) authorize(pathMatchers(""/resources/**"", ""/signup"", ""/about""), permitAll) (2) authorize(""/admin/**"", hasRole(""ADMIN"")) (3) authorize(""/db/**"", { authentication, context -> (4) hasRole(""ADMIN"").check(authentication, context) .filter({ decision -> !decision.isGranted() }) .switchIfEmpty(hasRole(""DBA"").check(authentication, context)) }) authorize(anyExchange, denyAll) (5) } // ... } } 1 There are multiple authorization rules specified. Each rule is considered in the order they were declared. 2 We specified multiple URL patterns that any user can access. Specifically, any user can access a request if the URL starts with ""/resources/"", equals ""/signup"", or equals ""/about"". 3 Any URL that starts with ""/admin/"" will be restricted to users who have the authority ""ROLE_ADMIN"". You will notice that since we are invoking the hasRole method we do not need to specify the ""ROLE_"" prefix. 4 Any URL that starts with ""/db/"" requires the user to have both ""ROLE_ADMIN"" and ""ROLE_DBA"". This demonstrates the flexibility of providing a custom ReactiveAuthorizationManager allowing us to implement arbitrary authorization logic. For simplicity, the sample uses a lambda and delegate to the existing AuthorityReactiveAuthorizationManager.hasRole implementation. However, in a real world situation applications would likely implement the logic in a proper class implementing ReactiveAuthorizationManager . 5 Any URL that has not already been matched on is denied access. This is a good strategy if you do not want to accidentally forget to update your authorization rules."
"https://docs.spring.io/spring-security/reference/6.3/reactive/authorization/method.html","EnableReactiveMethodSecurity: Spring Security supports method security by using Reactor’s Context(https://projectreactor.io/docs/core/release/reference/#context) , which is set up by ReactiveSecurityContextHolder . The following example shows how to retrieve the currently logged in user’s message: For this example to work, the return type of the method must be a org.reactivestreams.Publisher (that is, a Mono or a Flux ). This is necessary to integrate with Reactor’s Context . EnableReactiveMethodSecurity with AuthorizationManager: In Spring Security 5.8, we can enable annotation-based security using the @EnableReactiveMethodSecurity(useAuthorizationManager=true) annotation on any @Configuration instance. This improves upon @EnableReactiveMethodSecurity in a number of ways. @EnableReactiveMethodSecurity(useAuthorizationManager=true) : Uses the simplified AuthorizationManager API instead of metadata sources, config attributes, decision managers, and voters. This simplifies reuse and customization. Supports reactive return types including Kotlin coroutines. Is built using native Spring AOP, removing abstractions and allowing you to use Spring AOP building blocks to customize Checks for conflicting annotations to ensure an unambiguous security configuration Complies with JSR-250 For earlier versions, please read about similar support with @EnableReactiveMethodSecurity(#jc-enable-reactive-method-security) . For example, the following would enable Spring Security’s @PreAuthorize annotation: Method Security Configuration Java @EnableReactiveMethodSecurity(useAuthorizationManager=true) public class MethodSecurityConfig { // ... } Adding an annotation to a method (on a class or interface) would then limit the access to that method accordingly. Spring Security’s native annotation support defines a set of attributes for the method. These will be passed to the various method interceptors, like AuthorizationManagerBeforeReactiveMethodInterceptor , for it to make the actual decision: Method Security Annotation Usage Java public interface BankService { @PreAuthorize(""hasRole('USER')"") Mono<Account> readAccount(Long id); @PreAuthorize(""hasRole('USER')"") Flux<Account> findAccounts(); @PreAuthorize(""@func.apply(#account)"") Mono<Account> post(Account account, Double amount); } In this case hasRole refers to the method found in SecurityExpressionRoot that gets invoked by the SpEL evaluation engine. @bean refers to a custom component you have defined, where apply can return Boolean or Mono<Boolean> to indicate the authorization decision. A bean like that might look something like this: Method Security Reactive Boolean Expression Java @Bean public Function<Account, Mono<Boolean>> func() { return (account) -> Mono.defer(() -> Mono.just(account.getId().equals(12))); } Customizing Authorization: Spring Security’s @PreAuthorize , @PostAuthorize , @PreFilter , and @PostFilter ship with rich expression-based support. Also, for role-based authorization, Spring Security adds a default ROLE_ prefix, which is uses when evaluating expressions like hasRole . You can configure the authorization rules to use a different prefix by exposing a GrantedAuthorityDefaults bean, like so: Custom MethodSecurityExpressionHandler Java @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) static GrantedAuthorityDefaults grantedAuthorityDefaults() { return new GrantedAuthorityDefaults(""MYPREFIX_""); } We expose GrantedAuthorityDefaults using a static method to ensure that Spring publishes it before it initializes Spring Security’s method security @Configuration classes. Since the GrantedAuthorityDefaults bean is part of internal workings of Spring Security, we should also expose it as an infrastructural bean effectively avoiding some warnings related to bean post-processing (see gh-14751(https://github.com/spring-projects/spring-security/issues/14751) ). Custom Authorization Managers: Method authorization is a combination of before- and after-method authorization. Before-method authorization is performed before the method is invoked. If that authorization denies access, the method is not invoked, and an AccessDeniedException is thrown. After-method authorization is performed after the method is invoked, but before the method returns to the caller. If that authorization denies access, the value is not returned, and an AccessDeniedException is thrown To recreate what adding @EnableReactiveMethodSecurity(useAuthorizationManager=true) does by default, you would publish the following configuration: Full Pre-post Method Security Configuration Java @Configuration class MethodSecurityConfig { @Bean BeanDefinitionRegistryPostProcessor aopConfig() { return AopConfigUtils::registerAutoProxyCreatorIfNecessary; } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) PreFilterAuthorizationReactiveMethodInterceptor preFilterInterceptor() { return new PreFilterAuthorizationReactiveMethodInterceptor(); } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) AuthorizationManagerBeforeReactiveMethodInterceptor preAuthorizeInterceptor() { return AuthorizationManagerBeforeReactiveMethodInterceptor.preAuthorize(); } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) AuthorizationManagerAfterReactiveMethodInterceptor postAuthorizeInterceptor() { return AuthorizationManagerAfterReactiveMethodInterceptor.postAuthorize(); } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) PostFilterAuthorizationReactiveMethodInterceptor postFilterInterceptor() { return new PostFilterAuthorizationReactiveMethodInterceptor(); } } Notice that Spring Security’s method security is built using Spring AOP. So, interceptors are invoked based on the order specified. This can be customized by calling setOrder on the interceptor instances like so: Publish Custom Advisor Java @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) Advisor postFilterAuthorizationMethodInterceptor() { PostFilterAuthorizationMethodInterceptor interceptor = new PostFilterAuthorizationReactiveMethodInterceptor(); interceptor.setOrder(AuthorizationInterceptorOrders.POST_AUTHORIZE.getOrder() - 1); return interceptor; } You may want to only support @PreAuthorize in your application, in which case you can do the following: Only @PreAuthorize Configuration Java @Configuration class MethodSecurityConfig { @Bean BeanDefinitionRegistryPostProcessor aopConfig() { return AopConfigUtils::registerAutoProxyCreatorIfNecessary; } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) Advisor preAuthorize() { return AuthorizationManagerBeforeMethodInterceptor.preAuthorize(); } } Or, you may have a custom before-method ReactiveAuthorizationManager that you want to add to the list. In this case, you will need to tell Spring Security both the ReactiveAuthorizationManager and to which methods and classes your authorization manager applies. Thus, you can configure Spring Security to invoke your ReactiveAuthorizationManager in between @PreAuthorize and @PostAuthorize like so: Custom Before Advisor Java @EnableReactiveMethodSecurity(useAuthorizationManager=true) class MethodSecurityConfig { @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public Advisor customAuthorize() { JdkRegexpMethodPointcut pattern = new JdkRegexpMethodPointcut(); pattern.setPattern(""org.mycompany.myapp.service.*""); ReactiveAuthorizationManager<MethodInvocation> rule = AuthorityAuthorizationManager.isAuthenticated(); AuthorizationManagerBeforeReactiveMethodInterceptor interceptor = new AuthorizationManagerBeforeReactiveMethodInterceptor(pattern, rule); interceptor.setOrder(AuthorizationInterceptorsOrder.PRE_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1); return interceptor; } } You can place your interceptor in between Spring Security method interceptors using the order constants specified in AuthorizationInterceptorsOrder . The same can be done for after-method authorization. After-method authorization is generally concerned with analysing the return value to verify access. For example, you might have a method that confirms that the account requested actually belongs to the logged-in user like so: @PostAuthorize example Java public interface BankService { @PreAuthorize(""hasRole('USER')"") @PostAuthorize(""returnObject.owner == authentication.name"") Mono<Account> readAccount(Long id); } You can supply your own AuthorizationMethodInterceptor to customize how access to the return value is evaluated. For example, if you have your own custom annotation, you can configure it like so: Custom After Advisor Java @EnableReactiveMethodSecurity(useAuthorizationManager=true) class MethodSecurityConfig { @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public Advisor customAuthorize(ReactiveAuthorizationManager<MethodInvocationResult> rules) { AnnotationMethodMatcher pattern = new AnnotationMethodMatcher(MySecurityAnnotation.class); AuthorizationManagerAfterReactiveMethodInterceptor interceptor = new AuthorizationManagerAfterReactiveMethodInterceptor(pattern, rules); interceptor.setOrder(AuthorizationInterceptorsOrder.POST_AUTHORIZE_ADVISOR_ORDER.getOrder() + 1); return interceptor; } } and it will be invoked after the @PostAuthorize interceptor. EnableReactiveMethodSecurity: Java Kotlin Authentication authentication = new TestingAuthenticationToken(""user"", ""password"", ""ROLE_USER""); Mono<String> messageByUsername = ReactiveSecurityContextHolder.getContext() .map(SecurityContext::getAuthentication) .map(Authentication::getName) .flatMap(this::findMessageByUsername) // In a WebFlux application the `subscriberContext` is automatically setup using `ReactorContextWebFilter` .contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication)); StepVerifier.create(messageByUsername) .expectNext(""Hi user"") .verifyComplete(); val authentication: Authentication = TestingAuthenticationToken(""user"", ""password"", ""ROLE_USER"") val messageByUsername: Mono<String> = ReactiveSecurityContextHolder.getContext() .map(SecurityContext::getAuthentication) .map(Authentication::getName) .flatMap(this::findMessageByUsername) // In a WebFlux application the `subscriberContext` is automatically setup using `ReactorContextWebFilter` .contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication)) StepVerifier.create(messageByUsername) .expectNext(""Hi user"") .verifyComplete() Where this::findMessageByUsername is defined as: Java Kotlin Mono<String> findMessageByUsername(String username) { return Mono.just(""Hi "" + username); } fun findMessageByUsername(username: String): Mono<String> { return Mono.just(""Hi $username"") } The following minimal method security configures method security in reactive applications: Java Kotlin @Configuration @EnableReactiveMethodSecurity public class SecurityConfig { @Bean public MapReactiveUserDetailsService userDetailsService() { User.UserBuilder userBuilder = User.withDefaultPasswordEncoder(); UserDetails rob = userBuilder.username(""rob"") .password(""rob"") .roles(""USER"") .build(); UserDetails admin = userBuilder.username(""admin"") .password(""admin"") .roles(""USER"",""ADMIN"") .build(); return new MapReactiveUserDetailsService(rob, admin); } } @Configuration @EnableReactiveMethodSecurity class SecurityConfig { @Bean fun userDetailsService(): MapReactiveUserDetailsService { val userBuilder: User.UserBuilder = User.withDefaultPasswordEncoder() val rob = userBuilder.username(""rob"") .password(""rob"") .roles(""USER"") .build() val admin = userBuilder.username(""admin"") .password(""admin"") .roles(""USER"", ""ADMIN"") .build() return MapReactiveUserDetailsService(rob, admin) } } Consider the following class: Java Kotlin @Component public class HelloWorldMessageService { @PreAuthorize(""hasRole('ADMIN')"") public Mono<String> findMessage() { return Mono.just(""Hello World!""); } } @Component class HelloWorldMessageService { @PreAuthorize(""hasRole('ADMIN')"") fun findMessage(): Mono<String> { return Mono.just(""Hello World!"") } } Alternatively, the following class uses Kotlin coroutines: Kotlin @Component class HelloWorldMessageService { @PreAuthorize(""hasRole('ADMIN')"") suspend fun findMessage(): String { delay(10) return ""Hello World!"" } } Combined with our configuration above, @PreAuthorize(""hasRole('ADMIN')"") ensures that findByMessage is invoked only by a user with the ADMIN role. Note that any of the expressions in standard method security work for @EnableReactiveMethodSecurity . However, at this time, we support only a return type of Boolean or boolean of the expression. This means that the expression must not block. When integrating with WebFlux Security(../configuration/webflux.html#jc-webflux) , the Reactor Context is automatically established by Spring Security according to the authenticated user: Java Kotlin @Configuration @EnableWebFluxSecurity @EnableReactiveMethodSecurity public class SecurityConfig { @Bean SecurityWebFilterChain springWebFilterChain(ServerHttpSecurity http) throws Exception { return http // Demonstrate that method security works // Best practice to use both for defense in depth .authorizeExchange(exchanges -> exchanges .anyExchange().permitAll() ) .httpBasic(withDefaults()) .build(); } @Bean MapReactiveUserDetailsService userDetailsService() { User.UserBuilder userBuilder = User.withDefaultPasswordEncoder(); UserDetails rob = userBuilder.username(""rob"") .password(""rob"") .roles(""USER"") .build(); UserDetails admin = userBuilder.username(""admin"") .password(""admin"") .roles(""USER"",""ADMIN"") .build(); return new MapReactiveUserDetailsService(rob, admin); } } @Configuration @EnableWebFluxSecurity @EnableReactiveMethodSecurity class SecurityConfig { @Bean open fun springWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, permitAll) } httpBasic { } } } @Bean fun userDetailsService(): MapReactiveUserDetailsService { val userBuilder: User.UserBuilder = User.withDefaultPasswordEncoder() val rob = userBuilder.username(""rob"") .password(""rob"") .roles(""USER"") .build() val admin = userBuilder.username(""admin"") .password(""admin"") .roles(""USER"", ""ADMIN"") .build() return MapReactiveUserDetailsService(rob, admin) } } You can find a complete sample in hellowebflux-method(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/reactive/webflux/java/method) ."
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/index.html","OAuth2 WebFlux: Spring Security provides comprehensive OAuth 2.0 support. This section discusses how to integrate OAuth 2.0 into your reactive application. Overview: Spring Security’s OAuth 2.0 support consists of two primary feature sets: OAuth2 Resource Server(#oauth2-resource-server) OAuth2 Client(#oauth2-client) OAuth2 Login(#oauth2-client-log-users-in) is a very powerful OAuth2 Client feature that deserves its own section in the reference documentation. However, it does not exist as a standalone feature and requires OAuth2 Client in order to function. These feature sets cover the resource server and client roles defined in the OAuth 2.0 Authorization Framework(https://tools.ietf.org/html/rfc6749#section-1.1) , while the authorization server role is covered by Spring Authorization Server(https://docs.spring.io/spring-authorization-server/reference/index.html) , which is a separate project built on Spring Security(../../index.html) . The resource server and client roles in OAuth2 are typically represented by one or more server-side applications. Additionally, the authorization server role can be represented by one or more third parties (as is the case when centralizing identity management and/or authentication within an organization) -or- it can be represented by an application (as is the case with Spring Authorization Server). For example, a typical OAuth2-based microservices architecture might consist of a single user-facing client application, several backend resource servers providing REST APIs and a third party authorization server for managing users and authentication concerns. It is also common to have a single application representing only one of these roles with the need to integrate with one or more third parties that are providing the other roles. Spring Security handles these scenarios and more. The following sections cover the roles provided by Spring Security and contain examples for common scenarios. OAuth2 Resource Server: This section contains a summary of OAuth2 Resource Server features with examples. See OAuth 2.0 Resource Server(resource-server/index.html) for complete reference documentation. To get started, add the spring-security-oauth2-resource-server dependency to your project. When using Spring Boot, add the following starter: OAuth2 Client with Spring Boot Gradle Maven implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server' <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-oauth2-resource-server</artifactId> </dependency> See Getting Spring Security(../../getting-spring-security.html) for additional options when not using Spring Boot. Consider the following use cases for OAuth2 Resource Server: I want to protect access to the API using OAuth2(#oauth2-resource-server-access-token) (authorization server provides JWT or opaque access token) I want to protect access to the API using a JWT(#oauth2-resource-server-custom-jwt) (custom token) Protect Access with an OAuth2 Access Token: It is very common to protect access to an API using OAuth2 access tokens. In most cases, Spring Security requires only minimal configuration to secure an application with OAuth2. There are two types of Bearer tokens supported by Spring Security which each use a different component for validation: JWT support(#oauth2-resource-server-access-token-jwt) uses a ReactiveJwtDecoder bean to validate signatures and decode tokens Opaque token support(#oauth2-resource-server-access-token-opaque) uses a ReactiveOpaqueTokenIntrospector bean to introspect tokens JWT Support: The following example configures a ReactiveJwtDecoder bean using Spring Boot configuration properties: spring: security: oauth2: resourceserver: jwt: issuer-uri: https://my-auth-server.com When using Spring Boot, this is all that is required. The default arrangement provided by Spring Boot is equivalent to the following: Configure Resource Server with JWTs Java Kotlin @Configuration @EnableWebFluxSecurity public class SecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .authorizeExchange((authorize) -> authorize .anyExchange().authenticated() ) .oauth2ResourceServer((oauth2) -> oauth2 .jwt(Customizer.withDefaults()) ); return http.build(); } @Bean public ReactiveJwtDecoder jwtDecoder() { return ReactiveJwtDecoders.fromIssuerLocation(""https://my-auth-server.com""); } } import org.springframework.security.config.web.server.invoke @Configuration @EnableWebFluxSecurity class SecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { jwt { } } } } @Bean fun jwtDecoder(): ReactiveJwtDecoder { return ReactiveJwtDecoders.fromIssuerLocation(""https://my-auth-server.com"") } } Opaque Token Support: The following example configures an OpaqueTokenIntrospector bean using Spring Boot configuration properties: spring: security: oauth2: resourceserver: opaquetoken: introspection-uri: https://my-auth-server.com/oauth2/introspect client-id: my-client-id client-secret: my-client-secret When using Spring Boot, this is all that is required. The default arrangement provided by Spring Boot is equivalent to the following: Configure Resource Server with Opaque Tokens Java Kotlin @Configuration @EnableWebFluxSecurity public class SecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .authorizeExchange((authorize) -> authorize .anyExchange().authenticated() ) .oauth2ResourceServer((oauth2) -> oauth2 .opaqueToken(Customizer.withDefaults()) ); return http.build(); } @Bean public ReactiveOpaqueTokenIntrospector opaqueTokenIntrospector() { return new SpringReactiveOpaqueTokenIntrospector( ""https://my-auth-server.com/oauth2/introspect"", ""my-client-id"", ""my-client-secret""); } } import org.springframework.security.config.web.server.invoke @Configuration @EnableWebFluxSecurity class SecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { opaqueToken { } } } } @Bean fun opaqueTokenIntrospector(): ReactiveOpaqueTokenIntrospector { return SpringReactiveOpaqueTokenIntrospector( ""https://my-auth-server.com/oauth2/introspect"", ""my-client-id"", ""my-client-secret"" ) } } Protect Access with a custom JWT: It is a fairly common goal to protect access to an API using JWTs, particularly when the frontend is developed as a single-page application. The OAuth2 Resource Server support in Spring Security can be used for any type of Bearer token, including a custom JWT. All that is required to protect an API using JWTs is a ReactiveJwtDecoder bean, which is used to validate signatures and decode tokens. Spring Security will automatically use the provided bean to configure protection within the SecurityWebFilterChain . The following example configures a ReactiveJwtDecoder bean using Spring Boot configuration properties: spring: security: oauth2: resourceserver: jwt: public-key-location: classpath:my-public-key.pub You can provide the public key as a classpath resource (called my-public-key.pub in this example). When using Spring Boot, this is all that is required. The default arrangement provided by Spring Boot is equivalent to the following: Configure Resource Server with Custom JWTs Java Kotlin @Configuration @EnableWebFluxSecurity public class SecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .authorizeExchange((authorize) -> authorize .anyExchange().authenticated() ) .oauth2ResourceServer((oauth2) -> oauth2 .jwt(Customizer.withDefaults()) ); return http.build(); } @Bean public ReactiveJwtDecoder jwtDecoder() { return NimbusReactiveJwtDecoder.withPublicKey(publicKey()).build(); } private RSAPublicKey publicKey() { // ... } } import org.springframework.security.config.web.server.invoke @Configuration @EnableWebFluxSecurity class SecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { jwt { } } } } @Bean fun jwtDecoder(): ReactiveJwtDecoder { return NimbusReactiveJwtDecoder.withPublicKey(publicKey()).build() } private fun publicKey(): RSAPublicKey { // ... } } Spring Security does not provide an endpoint for minting tokens. However, Spring Security does provide the JwtEncoder interface along with one implementation, which is NimbusJwtEncoder . OAuth2 Client: This section contains a summary of OAuth2 Client features with examples. See OAuth 2.0 Client(client/index.html) and OAuth 2.0 Login(login/index.html) for complete reference documentation. To get started, add the spring-security-oauth2-client dependency to your project. When using Spring Boot, add the following starter: OAuth2 Client with Spring Boot Gradle Maven implementation 'org.springframework.boot:spring-boot-starter-oauth2-client' <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-oauth2-client</artifactId> </dependency> See Getting Spring Security(../../getting-spring-security.html) for additional options when not using Spring Boot. Consider the following use cases for OAuth2 Client: I want to log users in using OAuth 2.0 or OpenID Connect 1.0(#oauth2-client-log-users-in) I want to obtain an access token for users in order to access a third-party API(#oauth2-client-access-protected-resources) I want to do both(#oauth2-client-access-protected-resources-current-user) (log users in and access a third-party API) I want to enable an extension grant type(#oauth2-client-enable-extension-grant-type) I want to customize an existing grant type(#oauth2-client-customize-existing-grant-type) I want to customize token request parameters(#oauth2-client-customize-request-parameters) I want to customize the WebClient used by OAuth2 Client components(#oauth2-client-customize-web-client) Log Users In with OAuth2: It is very common to require users to log in via OAuth2. OpenID Connect 1.0(https://openid.net/specs/openid-connect-core-1_0.html) provides a special token called the id_token which is designed to provide an OAuth2 Client with the ability to perform user identity verification and log users in. In certain cases, OAuth2 can be used directly to log users in (as is the case with popular social login providers that do not implement OpenID Connect such as GitHub and Facebook). The following example configures the application to act as an OAuth2 Client capable of logging users in with OAuth2 or OpenID Connect: Configure OAuth2 Login Java Kotlin @Configuration @EnableWebFluxSecurity public class SecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http // ... .oauth2Login(Customizer.withDefaults()); return http.build(); } } import org.springframework.security.config.web.server.invoke @Configuration @EnableWebFluxSecurity class SecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... oauth2Login { } } } } In addition to the above configuration, the application requires at least one ClientRegistration to be configured through the use of a ReactiveClientRegistrationRepository bean. The following example configures an InMemoryReactiveClientRegistrationRepository bean using Spring Boot configuration properties: spring: security: oauth2: client: registration: my-oidc-client: provider: my-oidc-provider client-id: my-client-id client-secret: my-client-secret authorization-grant-type: authorization_code scope: openid,profile provider: my-oidc-provider: issuer-uri: https://my-oidc-provider.com With the above configuration, the application now supports two additional endpoints: The login endpoint (e.g. /oauth2/authorization/my-oidc-client ) is used to initiate login and perform a redirect to the third party authorization server. The redirection endpoint (e.g. /login/oauth2/code/my-oidc-client ) is used by the authorization server to redirect back to the client application, and will contain a code parameter used to obtain an id_token and/or access_token via the access token request. The presence of the openid scope in the above configuration indicates that OpenID Connect 1.0 should be used. This instructs Spring Security to use OIDC-specific components (such as OidcReactiveOAuth2UserService ) during request processing. Without this scope, Spring Security will use OAuth2-specific components (such as DefaultReactiveOAuth2UserService ) instead. Access Protected Resources: Making requests to a third party API that is protected by OAuth2 is a core use case of OAuth2 Client. This is accomplished by authorizing a client (represented by the OAuth2AuthorizedClient class in Spring Security) and accessing protected resources by placing a Bearer token in the Authorization header of an outbound request. The following example configures the application to act as an OAuth2 Client capable of requesting protected resources from a third party API: Configure OAuth2 Client Java Kotlin @Configuration @EnableWebFluxSecurity public class SecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http // ... .oauth2Client(Customizer.withDefaults()); return http.build(); } } import org.springframework.security.config.web.server.invoke @Configuration @EnableWebFluxSecurity class SecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... oauth2Client { } } } } The above example does not provide a way to log users in. You can use any other login mechanism (such as formLogin() ). See the next section(#oauth2-client-access-protected-resources-current-user) for an example combining oauth2Client() with oauth2Login() . In addition to the above configuration, the application requires at least one ClientRegistration to be configured through the use of a ReactiveClientRegistrationRepository bean. The following example configures an InMemoryReactiveClientRegistrationRepository bean using Spring Boot configuration properties: spring: security: oauth2: client: registration: my-oauth2-client: provider: my-auth-server client-id: my-client-id client-secret: my-client-secret authorization-grant-type: authorization_code scope: message.read,message.write provider: my-auth-server: issuer-uri: https://my-auth-server.com In addition to configuring Spring Security to support OAuth2 Client features, you will also need to decide how you will be accessing protected resources and configure your application accordingly. Spring Security provides implementations of ReactiveOAuth2AuthorizedClientManager for obtaining access tokens that can be used to access protected resources. Spring Security registers a default ReactiveOAuth2AuthorizedClientManager bean for you when one does not exist. The easiest way to use a ReactiveOAuth2AuthorizedClientManager is via an ExchangeFilterFunction that intercepts requests through a WebClient . The following example uses the default ReactiveOAuth2AuthorizedClientManager to configure a WebClient capable of accessing protected resources by placing Bearer tokens in the Authorization header of each request: Configure WebClient with ExchangeFilterFunction Java Kotlin @Configuration public class WebClientConfig { @Bean public WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) { ServerOAuth2AuthorizedClientExchangeFilterFunction filter = new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); return WebClient.builder() .filter(filter) .build(); } } @Configuration class WebClientConfig { @Bean fun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient { val filter = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager) return WebClient.builder() .filter(filter) .build() } } This configured WebClient can be used as in the following example: Use WebClient to Access Protected Resources Java Kotlin import static org.springframework.security.oauth2.client.web.reactive.function.client.ServerOAuth2AuthorizedClientExchangeFilterFunction.clientRegistrationId; @RestController public class MessagesController { private final WebClient webClient; public MessagesController(WebClient webClient) { this.webClient = webClient; } @GetMapping(""/messages"") public Mono<ResponseEntity<List<Message>>> messages() { return this.webClient.get() .uri(""http://localhost:8090/messages"") .attributes(clientRegistrationId(""my-oauth2-client"")) .retrieve() .toEntityList(Message.class); } public record Message(String message) { } } import org.springframework.security.oauth2.client.web.reactive.function.client.ServerOAuth2AuthorizedClientExchangeFilterFunction.clientRegistrationId @RestController class MessagesController(private val webClient: WebClient) { @GetMapping(""/messages"") fun messages(): Mono<ResponseEntity<List<Message>>> { return webClient.get() .uri(""http://localhost:8090/messages"") .attributes(clientRegistrationId(""my-oauth2-client"")) .retrieve() .toEntityList<Message>() } data class Message(val message: String) } Access Protected Resources for the Current User: When a user is logged in via OAuth2 or OpenID Connect, the authorization server may provide an access token that can be used directly to access protected resources. This is convenient because it only requires a single ClientRegistration to be configured for both use cases simultaneously. This section combines Log Users In with OAuth2(#oauth2-client-log-users-in) and Access Protected Resources(#oauth2-client-access-protected-resources) into a single configuration. Other advanced scenarios exist, such as configuring one ClientRegistration for login and another for accessing protected resources. All such scenarios would use the same basic configuration. The following example configures the application to act as an OAuth2 Client capable of logging the user in and requesting protected resources from a third party API: Configure OAuth2 Login and OAuth2 Client Java Kotlin @Configuration @EnableWebFluxSecurity public class SecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http // ... .oauth2Login(Customizer.withDefaults()) .oauth2Client(Customizer.withDefaults()); return http.build(); } } import org.springframework.security.config.web.server.invoke @Configuration @EnableWebFluxSecurity class SecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... oauth2Login { } oauth2Client { } } } } In addition to the above configuration, the application requires at least one ClientRegistration to be configured through the use of a ReactiveClientRegistrationRepository bean. The following example configures an InMemoryReactiveClientRegistrationRepository bean using Spring Boot configuration properties: spring: security: oauth2: client: registration: my-combined-client: provider: my-auth-server client-id: my-client-id client-secret: my-client-secret authorization-grant-type: authorization_code scope: openid,profile,message.read,message.write provider: my-auth-server: issuer-uri: https://my-auth-server.com The main difference between the previous examples ( Log Users In with OAuth2(#oauth2-client-log-users-in) , Access Protected Resources(#oauth2-client-access-protected-resources) ) and this one is what is configured via the scope property, which combines the standard scopes openid and profile with the custom scopes message.read and message.write . In addition to configuring Spring Security to support OAuth2 Client features, you will also need to decide how you will be accessing protected resources and configure your application accordingly. Spring Security provides implementations of ReactiveOAuth2AuthorizedClientManager for obtaining access tokens that can be used to access protected resources. Spring Security registers a default ReactiveOAuth2AuthorizedClientManager bean for you when one does not exist. The easiest way to use a ReactiveOAuth2AuthorizedClientManager is via an ExchangeFilterFunction that intercepts requests through a WebClient . The following example uses the default ReactiveOAuth2AuthorizedClientManager to configure a WebClient capable of accessing protected resources by placing Bearer tokens in the Authorization header of each request: Configure WebClient with ExchangeFilterFunction Java Kotlin @Configuration public class WebClientConfig { @Bean public WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) { ServerOAuth2AuthorizedClientExchangeFilterFunction filter = new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); return WebClient.builder() .filter(filter) .build(); } } @Configuration class WebClientConfig { @Bean fun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient { val filter = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager) return WebClient.builder() .filter(filter) .build() } } This configured WebClient can be used as in the following example: Use WebClient to Access Protected Resources (Current User) Java Kotlin @RestController public class MessagesController { private final WebClient webClient; public MessagesController(WebClient webClient) { this.webClient = webClient; } @GetMapping(""/messages"") public Mono<ResponseEntity<List<Message>>> messages() { return this.webClient.get() .uri(""http://localhost:8090/messages"") .retrieve() .toEntityList(Message.class); } public record Message(String message) { } } @RestController class MessagesController(private val webClient: WebClient) { @GetMapping(""/messages"") fun messages(): Mono<ResponseEntity<List<Message>>> { return webClient.get() .uri(""http://localhost:8090/messages"") .retrieve() .toEntityList<Message>() } data class Message(val message: String) } Unlike the previous example(#oauth2-client-accessing-protected-resources-example) , notice that we do not need to tell Spring Security about the clientRegistrationId we’d like to use. This is because it can be derived from the currently logged in user. Enable an Extension Grant Type: A common use case involves enabling and/or configuring an extension grant type. For example, Spring Security provides support for the jwt-bearer and token-exchange grant types, but does not enable them by default because they are not part of the core OAuth 2.0 specification. With Spring Security 6.3 and later, we can simply publish a bean for one or more ReactiveOAuth2AuthorizedClientProvider and they will be picked up automatically. The following example simply enables the jwt-bearer grant type: Enable jwt-bearer Grant Type Java Kotlin @Configuration public class SecurityConfig { @Bean public ReactiveOAuth2AuthorizedClientProvider jwtBearer() { return new JwtBearerReactiveOAuth2AuthorizedClientProvider(); } } @Configuration class SecurityConfig { @Bean fun jwtBearer(): ReactiveOAuth2AuthorizedClientProvider { return JwtBearerReactiveOAuth2AuthorizedClientProvider() } } A default ReactiveOAuth2AuthorizedClientManager will be published automatically by Spring Security when one is not already provided. Any custom OAuth2AuthorizedClientProvider bean will also be picked up and applied to the provided ReactiveOAuth2AuthorizedClientManager after the default grant types. In order to achieve the above configuration prior to Spring Security 6.3, we had to publish this bean ourselves and ensure we re-enabled default grant types as well. To understand what is being configured behind the scenes, here’s what the configuration might have looked like: Enable jwt-bearer Grant Type (prior to 6.3) Java Kotlin @Configuration public class SecurityConfig { @Bean public ReactiveOAuth2AuthorizedClientManager authorizedClientManager( ReactiveClientRegistrationRepository clientRegistrationRepository, ServerOAuth2AuthorizedClientRepository authorizedClientRepository) { ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken() .clientCredentials() .password() .provider(new JwtBearerReactiveOAuth2AuthorizedClientProvider()) .build(); DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager = new DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } } @Configuration class SecurityConfig { @Bean fun authorizedClientManager( clientRegistrationRepository: ReactiveClientRegistrationRepository, authorizedClientRepository: ServerOAuth2AuthorizedClientRepository ): ReactiveOAuth2AuthorizedClientManager { val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken() .clientCredentials() .password() .provider(JwtBearerReactiveOAuth2AuthorizedClientProvider()) .build() val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository ) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } } Customize an Existing Grant Type: The ability to enable extension grant types(#oauth2-client-enable-extension-grant-type) by publishing a bean also provides the opportunity for customizing an existing grant type without the need to re-define the defaults. For example, if we want to customize the clock skew of the ReactiveOAuth2AuthorizedClientProvider for the client_credentials grant, we can simply publish a bean like so: Customize Client Credentials Grant Type Java Kotlin @Configuration public class SecurityConfig { @Bean public ReactiveOAuth2AuthorizedClientProvider clientCredentials() { ClientCredentialsReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = new ClientCredentialsReactiveOAuth2AuthorizedClientProvider(); authorizedClientProvider.setClockSkew(Duration.ofMinutes(5)); return authorizedClientProvider; } } @Configuration class SecurityConfig { @Bean fun clientCredentials(): ReactiveOAuth2AuthorizedClientProvider { val authorizedClientProvider = ClientCredentialsReactiveOAuth2AuthorizedClientProvider() authorizedClientProvider.setClockSkew(Duration.ofMinutes(5)) return authorizedClientProvider } } Customize Token Request Parameters: The need to customize request parameters when obtaining an access token is fairly common. For example, let’s say we want to add a custom audience parameter to the token request because the provider requires this parameter for the authorization_code grant. We can simply publish a bean of type ReactiveOAuth2AccessTokenResponseClient with the generic type OAuth2AuthorizationCodeGrantRequest and it will be used by Spring Security to configure OAuth2 Client components. The following example customizes token request parameters for the authorization_code grant: Customize Token Request Parameters for Authorization Code Grant Java Kotlin @Configuration public class SecurityConfig { @Bean public ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() { WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient = new WebClientReactiveAuthorizationCodeTokenResponseClient(); accessTokenResponseClient.addParametersConverter(parametersConverter()); return accessTokenResponseClient; } private static Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> parametersConverter() { return (grantRequest) -> { MultiValueMap<String, String> parameters = new LinkedMultiValueMap<>(); parameters.set(""audience"", ""xyz_value""); return parameters; }; } } @Configuration class SecurityConfig { @Bean fun authorizationCodeAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> { val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient() accessTokenResponseClient.addParametersConverter(parametersConverter()) return accessTokenResponseClient } private fun parametersConverter(): Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> { return Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> { grantRequest -> LinkedMultiValueMap<String, String>().also { parameters -> parameters[""audience""] = ""xyz_value"" } } } } Notice that we don’t need to customize the SecurityWebFilterChain bean in this case, and can stick with the defaults. If using Spring Boot with no additional customizations, we can actually omit the SecurityWebFilterChain bean entirely. As you can see, providing the ReactiveOAuth2AccessTokenResponseClient as a bean is quite convenient. When using the Spring Security DSL directly, we need to ensure that this customization is applied for both OAuth2 Login (if we are using this feature) and OAuth2 Client components. To understand what is being configured behind the scenes, here’s what the configuration would look like with the DSL: Customize Token Request Parameters for Authorization Code Grant using the DSL Java Kotlin @Configuration @EnableWebFluxSecurity public class SecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient = new WebClientReactiveAuthorizationCodeTokenResponseClient(); accessTokenResponseClient.addParametersConverter(parametersConverter()); http .authorizeExchange((authorize) -> authorize .anyExchange().authenticated() ) .oauth2Login((oauth2Login) -> oauth2Login .authenticationManager(new DelegatingReactiveAuthenticationManager( new OidcAuthorizationCodeReactiveAuthenticationManager( accessTokenResponseClient, new OidcReactiveOAuth2UserService() ), new OAuth2LoginReactiveAuthenticationManager( accessTokenResponseClient, new DefaultReactiveOAuth2UserService() ) )) ) .oauth2Client((oauth2Client) -> oauth2Client .authenticationManager(new OAuth2AuthorizationCodeReactiveAuthenticationManager( accessTokenResponseClient )) ); return http.build(); } private static Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> parametersConverter() { // ... } } import org.springframework.security.config.web.server.invoke @Configuration @EnableWebFluxSecurity class SecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient() accessTokenResponseClient.addParametersConverter(parametersConverter()) return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2Login { authenticationManager = DelegatingReactiveAuthenticationManager( OidcAuthorizationCodeReactiveAuthenticationManager( accessTokenResponseClient, OidcReactiveOAuth2UserService() ), OAuth2LoginReactiveAuthenticationManager( accessTokenResponseClient, DefaultReactiveOAuth2UserService() ) ) } oauth2Client { authenticationManager = OAuth2AuthorizationCodeReactiveAuthenticationManager( accessTokenResponseClient ) } } } private fun parametersConverter(): Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> { // ... } } For other grant types we can publish additional ReactiveOAuth2AccessTokenResponseClient beans to override the defaults. For example, to customize token requests for the client_credentials grant we can publish the following bean: Customize Token Request Parameters for Client Credentials Grant Java Kotlin @Configuration public class SecurityConfig { @Bean public ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsAccessTokenResponseClient() { WebClientReactiveClientCredentialsTokenResponseClient accessTokenResponseClient = new WebClientReactiveClientCredentialsTokenResponseClient(); accessTokenResponseClient.addParametersConverter(parametersConverter()); return accessTokenResponseClient; } private static Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> parametersConverter() { // ... } } @Configuration class SecurityConfig { @Bean fun clientCredentialsAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> { val accessTokenResponseClient = WebClientReactiveClientCredentialsTokenResponseClient() accessTokenResponseClient.addParametersConverter(parametersConverter()) return accessTokenResponseClient } private fun parametersConverter(): Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> { // ... } } Spring Security automatically resolves the following generic types of ReactiveOAuth2AccessTokenResponseClient beans: OAuth2AuthorizationCodeGrantRequest (see WebClientReactiveAuthorizationCodeTokenResponseClient ) OAuth2RefreshTokenGrantRequest (see WebClientReactiveRefreshTokenTokenResponseClient ) OAuth2ClientCredentialsGrantRequest (see WebClientReactiveClientCredentialsTokenResponseClient ) OAuth2PasswordGrantRequest (see WebClientReactivePasswordTokenResponseClient ) JwtBearerGrantRequest (see WebClientReactiveJwtBearerTokenResponseClient ) TokenExchangeGrantRequest (see WebClientReactiveTokenExchangeTokenResponseClient ) Publishing a bean of type ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> will automatically enable the jwt-bearer grant type without the need to configure it separately(#oauth2-client-enable-extension-grant-type) . Publishing a bean of type ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> will automatically enable the token-exchange grant type without the need to configure it separately(#oauth2-client-enable-extension-grant-type) . Customize the WebClient used by OAuth2 Client Components: Another common use case is the need to customize the WebClient used when obtaining an access token. We might need to do this to customize the underlying HTTP client library (via a custom ClientHttpConnector ) to configure SSL settings or to apply proxy settings for a corporate network. With Spring Security 6.3 and later, we can simply publish beans of type ReactiveOAuth2AccessTokenResponseClient and Spring Security will configure and publish a ReactiveOAuth2AuthorizedClientManager bean for us. The following example customizes the WebClient for all of the supported grant types: Customize WebClient for OAuth2 Client Java Kotlin @Configuration public class SecurityConfig { @Bean public ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() { WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient = new WebClientReactiveAuthorizationCodeTokenResponseClient(); accessTokenResponseClient.setWebClient(webClient()); return accessTokenResponseClient; } @Bean public ReactiveOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> refreshTokenAccessTokenResponseClient() { WebClientReactiveRefreshTokenTokenResponseClient accessTokenResponseClient = new WebClientReactiveRefreshTokenTokenResponseClient(); accessTokenResponseClient.setWebClient(webClient()); return accessTokenResponseClient; } @Bean public ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsAccessTokenResponseClient() { WebClientReactiveClientCredentialsTokenResponseClient accessTokenResponseClient = new WebClientReactiveClientCredentialsTokenResponseClient(); accessTokenResponseClient.setWebClient(webClient()); return accessTokenResponseClient; } @Bean public ReactiveOAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> passwordAccessTokenResponseClient() { WebClientReactivePasswordTokenResponseClient accessTokenResponseClient = new WebClientReactivePasswordTokenResponseClient(); accessTokenResponseClient.setWebClient(webClient()); return accessTokenResponseClient; } @Bean public ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> jwtBearerAccessTokenResponseClient() { WebClientReactiveJwtBearerTokenResponseClient accessTokenResponseClient = new WebClientReactiveJwtBearerTokenResponseClient(); accessTokenResponseClient.setWebClient(webClient()); return accessTokenResponseClient; } @Bean public ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> tokenExchangeAccessTokenResponseClient() { WebClientReactiveTokenExchangeTokenResponseClient accessTokenResponseClient = new WebClientReactiveTokenExchangeTokenResponseClient(); accessTokenResponseClient.setWebClient(webClient()); return accessTokenResponseClient; } @Bean public WebClient webClient() { // ... } } @Configuration class SecurityConfig { @Bean fun authorizationCodeAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> { val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient() accessTokenResponseClient.setWebClient(webClient()) return accessTokenResponseClient } @Bean fun refreshTokenAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> { val accessTokenResponseClient = WebClientReactiveRefreshTokenTokenResponseClient() accessTokenResponseClient.setWebClient(webClient()) return accessTokenResponseClient } @Bean fun clientCredentialsAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> { val accessTokenResponseClient = WebClientReactiveClientCredentialsTokenResponseClient() accessTokenResponseClient.setWebClient(webClient()) return accessTokenResponseClient } @Bean fun passwordAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> { val accessTokenResponseClient = WebClientReactivePasswordTokenResponseClient() accessTokenResponseClient.setWebClient(webClient()) return accessTokenResponseClient } @Bean fun jwtBearerAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> { val accessTokenResponseClient = WebClientReactiveJwtBearerTokenResponseClient() accessTokenResponseClient.setWebClient(webClient()) return accessTokenResponseClient } @Bean fun tokenExchangeAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> { val accessTokenResponseClient = WebClientReactiveTokenExchangeTokenResponseClient() accessTokenResponseClient.setWebClient(webClient()) return accessTokenResponseClient } @Bean fun webClient(): WebClient { // ... } } A default ReactiveOAuth2AuthorizedClientManager will be published automatically by Spring Security when one is not already provided. Notice that we don’t need to customize the SecurityWebFilterChain bean in this case, and can stick with the defaults. If using Spring Boot with no additional customizations, we can actually omit the SecurityWebFilterChain bean entirely. Prior to Spring Security 6.3, we had to ensure this customization was applied to OAuth2 Client components ourselves. While we could publish a bean of type ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> for the authorization_code grant, we had to publish a bean of type ReactiveOAuth2AuthorizedClientManager for other grant types. To understand what is being configured behind the scenes, here’s what the configuration might have looked like: Customize WebClient for OAuth2 Client (prior to 6.3) Java Kotlin @Configuration public class SecurityConfig { @Bean public ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() { WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient = new WebClientReactiveAuthorizationCodeTokenResponseClient(); accessTokenResponseClient.setWebClient(webClient()); return accessTokenResponseClient; } @Bean public ReactiveOAuth2AuthorizedClientManager authorizedClientManager( ReactiveClientRegistrationRepository clientRegistrationRepository, ServerOAuth2AuthorizedClientRepository authorizedClientRepository) { WebClientReactiveRefreshTokenTokenResponseClient refreshTokenAccessTokenResponseClient = new WebClientReactiveRefreshTokenTokenResponseClient(); refreshTokenAccessTokenResponseClient.setWebClient(webClient()); WebClientReactiveClientCredentialsTokenResponseClient clientCredentialsAccessTokenResponseClient = new WebClientReactiveClientCredentialsTokenResponseClient(); clientCredentialsAccessTokenResponseClient.setWebClient(webClient()); WebClientReactivePasswordTokenResponseClient passwordAccessTokenResponseClient = new WebClientReactivePasswordTokenResponseClient(); passwordAccessTokenResponseClient.setWebClient(webClient()); WebClientReactiveJwtBearerTokenResponseClient jwtBearerAccessTokenResponseClient = new WebClientReactiveJwtBearerTokenResponseClient(); jwtBearerAccessTokenResponseClient.setWebClient(webClient()); JwtBearerReactiveOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider = new JwtBearerReactiveOAuth2AuthorizedClientProvider(); jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerAccessTokenResponseClient); WebClientReactiveTokenExchangeTokenResponseClient tokenExchangeAccessTokenResponseClient = new WebClientReactiveTokenExchangeTokenResponseClient(); tokenExchangeAccessTokenResponseClient.setWebClient(webClient()); TokenExchangeReactiveOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider = new TokenExchangeReactiveOAuth2AuthorizedClientProvider(); tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeAccessTokenResponseClient); ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken((refreshToken) -> refreshToken .accessTokenResponseClient(refreshTokenAccessTokenResponseClient) ) .clientCredentials((clientCredentials) -> clientCredentials .accessTokenResponseClient(clientCredentialsAccessTokenResponseClient) ) .password((password) -> password .accessTokenResponseClient(passwordAccessTokenResponseClient) ) .provider(jwtBearerAuthorizedClientProvider) .provider(tokenExchangeAuthorizedClientProvider) .build(); DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager = new DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean public WebClient webClient() { // ... } } import org.springframework.security.config.web.server.invoke @Configuration class SecurityConfig { @Bean fun authorizationCodeAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> { val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient() accessTokenResponseClient.setWebClient(webClient()) return accessTokenResponseClient } @Bean fun authorizedClientManager( clientRegistrationRepository: ReactiveClientRegistrationRepository?, authorizedClientRepository: ServerOAuth2AuthorizedClientRepository? ): ReactiveOAuth2AuthorizedClientManager { val refreshTokenAccessTokenResponseClient = WebClientReactiveRefreshTokenTokenResponseClient() refreshTokenAccessTokenResponseClient.setWebClient(webClient()) val clientCredentialsAccessTokenResponseClient = WebClientReactiveClientCredentialsTokenResponseClient() clientCredentialsAccessTokenResponseClient.setWebClient(webClient()) val passwordAccessTokenResponseClient = WebClientReactivePasswordTokenResponseClient() passwordAccessTokenResponseClient.setWebClient(webClient()) val jwtBearerAccessTokenResponseClient = WebClientReactiveJwtBearerTokenResponseClient() jwtBearerAccessTokenResponseClient.setWebClient(webClient()) val jwtBearerAuthorizedClientProvider = JwtBearerReactiveOAuth2AuthorizedClientProvider() jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerAccessTokenResponseClient) val tokenExchangeAccessTokenResponseClient = WebClientReactiveTokenExchangeTokenResponseClient() tokenExchangeAccessTokenResponseClient.setWebClient(webClient()) val tokenExchangeAuthorizedClientProvider = TokenExchangeReactiveOAuth2AuthorizedClientProvider() tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeAccessTokenResponseClient) val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken { refreshToken -> refreshToken.accessTokenResponseClient(refreshTokenAccessTokenResponseClient) } .clientCredentials { clientCredentials -> clientCredentials.accessTokenResponseClient(clientCredentialsAccessTokenResponseClient) } .password { password -> password.accessTokenResponseClient(passwordAccessTokenResponseClient) } .provider(jwtBearerAuthorizedClientProvider) .provider(tokenExchangeAuthorizedClientProvider) .build() val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository ) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } @Bean fun webClient(): WebClient { // ... } } Further Reading: This preceding sections introduced Spring Security’s support for OAuth2 with examples for common scenarios. You can read more about OAuth2 Client and Resource Server in the following sections of the reference documentation: OAuth 2.0 Login(login/index.html) OAuth 2.0 Client(client/index.html) OAuth 2.0 Resource Server(resource-server/index.html)"
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/login/index.html","OAuth 2.0 Login: The OAuth 2.0 Login feature provides an application with the ability to have users log in to the application by using their existing account at an OAuth 2.0 Provider (such as GitHub) or OpenID Connect 1.0 Provider (such as Google). OAuth 2.0 Login implements the ""Login with Google"" or ""Login with GitHub"" use cases. OAuth 2.0 Login is implemented by using the Authorization Code Grant , as specified in the OAuth 2.0 Authorization Framework(https://tools.ietf.org/html/rfc6749#section-4.1) and OpenID Connect Core 1.0(https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth) . Section Summary: Core Configuration(core.html) Advanced Configuration(advanced.html) OIDC Logout(logout.html)"
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/login/core.html","Core Configuration: Spring Boot Sample: Spring Boot brings full auto-configuration capabilities for OAuth 2.0 Login. This section shows how to configure the OAuth 2.0 Login WebFlux sample(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/boot/oauth2login-webflux) by using Google as the Authentication Provider and covers the following topics: Initial Setup(#webflux-oauth2-login-sample-setup) Setting the Redirect URI(#webflux-oauth2-login-sample-redirect) Configure application.yml(#webflux-oauth2-login-sample-config) Boot the Application(#webflux-oauth2-login-sample-start) Initial Setup: To use Google’s OAuth 2.0 authentication system for login, you must set up a project in the Google API Console to obtain OAuth 2.0 credentials. Google’s OAuth 2.0 implementation(https://developers.google.com/identity/protocols/OpenIDConnect) for authentication conforms to the OpenID Connect 1.0(https://openid.net/connect/) specification and is OpenID Certified(https://openid.net/certification/) . Follow the instructions on the OpenID Connect(https://developers.google.com/identity/protocols/OpenIDConnect) page, starting in the “Setting up OAuth 2.0” section. After completing the “Obtain OAuth 2.0 credentials” instructions, you should have a new OAuth Client with credentials that consist of a Client ID and a Client Secret. Setting the Redirect URI: The redirect URI is the path in the application that the end-user’s user-agent is redirected back to after they have authenticated with Google and have been granted access to the OAuth Client ( created in the previous step(#webflux-oauth2-login-sample-setup) ) on the consent page. In the “Set a redirect URI” sub-section, ensure that the Authorized redirect URIs field is set to localhost:8080/login/oauth2/code/google(http://localhost:8080/login/oauth2/code/google) . The default redirect URI template is {baseUrl}/login/oauth2/code/{registrationId} . The registrationId is a unique identifier for the ClientRegistration(../client/core.html#oauth2Client-client-registration) . For our example, the registrationId is google . If the OAuth Client is running behind a proxy server, it is recommended to check Proxy Server Configuration(../../../features/exploits/http.html#http-proxy-server) to ensure the application is correctly configured. Also, see the supported URI template variables(../client/authorization-grants.html#oauth2Client-auth-code-redirect-uri) for redirect-uri . Configure application.yml: Now that you have a new OAuth Client with Google, you need to configure the application to use the OAuth Client for the authentication flow . To do so: Go to application.yml and set the following configuration: Example 1. OAuth Client properties spring: security: oauth2: client: registration: (1) google: (2) client-id: google-client-id client-secret: google-client-secret 1 spring.security.oauth2.client.registration is the base property prefix for OAuth Client properties. 2 Following the base property prefix is the ID for the ClientRegistration(../client/core.html#oauth2Client-client-registration) , such as google. Replace the values in the client-id and client-secret property with the OAuth 2.0 credentials you created earlier. Boot the Application: Launch the Spring Boot sample and go to localhost:8080(http://localhost:8080) . You are then redirected to the default auto-generated login page, which displays a link for Google. Click on the Google link, and you are then redirected to Google for authentication. After authenticating with your Google account credentials, the next page presented to you is the Consent screen. The Consent screen asks you to either allow or deny access to the OAuth Client you created earlier. Click Allow to authorize the OAuth Client to access your email address and basic profile information. At this point, the OAuth Client retrieves your email address and basic profile information from the UserInfo Endpoint(https://openid.net/specs/openid-connect-core-1_0.html#UserInfo) and establishes an authenticated session. Spring Boot Property Mappings: The following table outlines the mapping of the Spring Boot OAuth Client properties to the ClientRegistration(../client/core.html#oauth2Client-client-registration) properties. Spring Boot ClientRegistration spring.security.oauth2.client.registration. [registrationId] registrationId spring.security.oauth2.client.registration. [registrationId] .client-id clientId spring.security.oauth2.client.registration. [registrationId] .client-secret clientSecret spring.security.oauth2.client.registration. [registrationId] .client-authentication-method clientAuthenticationMethod spring.security.oauth2.client.registration. [registrationId] .authorization-grant-type authorizationGrantType spring.security.oauth2.client.registration. [registrationId] .redirect-uri redirectUri spring.security.oauth2.client.registration. [registrationId] .scope scopes spring.security.oauth2.client.registration. [registrationId] .client-name clientName spring.security.oauth2.client.provider. [providerId] .authorization-uri providerDetails.authorizationUri spring.security.oauth2.client.provider. [providerId] .token-uri providerDetails.tokenUri spring.security.oauth2.client.provider. [providerId] .jwk-set-uri providerDetails.jwkSetUri spring.security.oauth2.client.provider. [providerId] .issuer-uri providerDetails.issuerUri spring.security.oauth2.client.provider. [providerId] .user-info-uri providerDetails.userInfoEndpoint.uri spring.security.oauth2.client.provider. [providerId] .user-info-authentication-method providerDetails.userInfoEndpoint.authenticationMethod spring.security.oauth2.client.provider. [providerId] .user-name-attribute providerDetails.userInfoEndpoint.userNameAttributeName A ClientRegistration can be initially configured using discovery of an OpenID Connect Provider’s Configuration endpoint(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) or an Authorization Server’s Metadata endpoint(https://tools.ietf.org/html/rfc8414#section-3) , by specifying the spring.security.oauth2.client.provider. [providerId] .issuer-uri property. CommonOAuth2Provider: CommonOAuth2Provider pre-defines a set of default client properties for a number of well known providers: Google, GitHub, Facebook, and Okta. For example, the authorization-uri , token-uri , and user-info-uri do not change often for a Provider. Therefore, it makes sense to provide default values in order to reduce the required configuration. As demonstrated previously, when we configured a Google client(#webflux-oauth2-login-sample-config) , only the client-id and client-secret properties are required. The following listing shows an example: spring: security: oauth2: client: registration: google: client-id: google-client-id client-secret: google-client-secret The auto-defaulting of client properties works seamlessly here because the registrationId ( google ) matches the GOOGLE enum (case-insensitive) in CommonOAuth2Provider . For cases where you may want to specify a different registrationId , such as google-login , you can still leverage auto-defaulting of client properties by configuring the provider property. The following listing shows an example: spring: security: oauth2: client: registration: google-login: (1) provider: google (2) client-id: google-client-id client-secret: google-client-secret 1 The registrationId is set to google-login . 2 The provider property is set to google , which will leverage the auto-defaulting of client properties set in CommonOAuth2Provider.GOOGLE.getBuilder() . Configuring Custom Provider Properties: There are some OAuth 2.0 Providers that support multi-tenancy, which results in different protocol endpoints for each tenant (or sub-domain). For example, an OAuth Client registered with Okta is assigned to a specific sub-domain and have their own protocol endpoints. For these cases, Spring Boot provides the following base property for configuring custom provider properties: spring.security.oauth2.client.provider. [providerId] . The following listing shows an example: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret provider: okta: (1) authorization-uri: https://your-subdomain.oktapreview.com/oauth2/v1/authorize token-uri: https://your-subdomain.oktapreview.com/oauth2/v1/token user-info-uri: https://your-subdomain.oktapreview.com/oauth2/v1/userinfo user-name-attribute: sub jwk-set-uri: https://your-subdomain.oktapreview.com/oauth2/v1/keys 1 The base property ( spring.security.oauth2.client.provider.okta ) allows for custom configuration of protocol endpoint locations. Overriding Spring Boot Auto-configuration: The Spring Boot auto-configuration class for OAuth Client support is ReactiveOAuth2ClientAutoConfiguration . It performs the following tasks: Registers a ReactiveClientRegistrationRepository @Bean composed of ClientRegistration (s) from the configured OAuth Client properties. Registers a SecurityWebFilterChain @Bean and enables OAuth 2.0 Login through serverHttpSecurity.oauth2Login() . If you need to override the auto-configuration based on your specific requirements, you may do so in the following ways: Register a ReactiveClientRegistrationRepository @Bean(#webflux-oauth2-login-register-reactiveclientregistrationrepository-bean) Register a SecurityWebFilterChain @Bean(#webflux-oauth2-login-register-securitywebfilterchain-bean) Completely Override the Auto-configuration(#webflux-oauth2-login-completely-override-autoconfiguration) Register a ReactiveClientRegistrationRepository @Bean: The following example shows how to register a ReactiveClientRegistrationRepository @Bean : Java Kotlin @Configuration public class OAuth2LoginConfig { @Bean public ReactiveClientRegistrationRepository clientRegistrationRepository() { return new InMemoryReactiveClientRegistrationRepository(this.googleClientRegistration()); } private ClientRegistration googleClientRegistration() { return ClientRegistration.withRegistrationId(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .redirectUri(""{baseUrl}/login/oauth2/code/{registrationId}"") .scope(""openid"", ""profile"", ""email"", ""address"", ""phone"") .authorizationUri(""https://accounts.google.com/o/oauth2/v2/auth"") .tokenUri(""https://www.googleapis.com/oauth2/v4/token"") .userInfoUri(""https://www.googleapis.com/oauth2/v3/userinfo"") .userNameAttributeName(IdTokenClaimNames.SUB) .jwkSetUri(""https://www.googleapis.com/oauth2/v3/certs"") .clientName(""Google"") .build(); } } @Configuration class OAuth2LoginConfig { @Bean fun clientRegistrationRepository(): ReactiveClientRegistrationRepository { return InMemoryReactiveClientRegistrationRepository(googleClientRegistration()) } private fun googleClientRegistration(): ClientRegistration { return ClientRegistration.withRegistrationId(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .redirectUri(""{baseUrl}/login/oauth2/code/{registrationId}"") .scope(""openid"", ""profile"", ""email"", ""address"", ""phone"") .authorizationUri(""https://accounts.google.com/o/oauth2/v2/auth"") .tokenUri(""https://www.googleapis.com/oauth2/v4/token"") .userInfoUri(""https://www.googleapis.com/oauth2/v3/userinfo"") .userNameAttributeName(IdTokenClaimNames.SUB) .jwkSetUri(""https://www.googleapis.com/oauth2/v3/certs"") .clientName(""Google"") .build() } } Register a SecurityWebFilterChain @Bean: The following example shows how to register a SecurityWebFilterChain @Bean with @EnableWebFluxSecurity and enable OAuth 2.0 login through serverHttpSecurity.oauth2Login() : OAuth2 Login Configuration Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .authorizeExchange(authorize -> authorize .anyExchange().authenticated() ) .oauth2Login(withDefaults()); return http.build(); } } @Configuration @EnableWebFluxSecurity class OAuth2LoginSecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2Login { } } return http.build() } } Completely Override the Auto-configuration: The following example shows how to completely override the auto-configuration by registering a ReactiveClientRegistrationRepository @Bean and a SecurityWebFilterChain @Bean . Overriding the auto-configuration Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2LoginConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .authorizeExchange(authorize -> authorize .anyExchange().authenticated() ) .oauth2Login(withDefaults()); return http.build(); } @Bean public ReactiveClientRegistrationRepository clientRegistrationRepository() { return new InMemoryReactiveClientRegistrationRepository(this.googleClientRegistration()); } private ClientRegistration googleClientRegistration() { return ClientRegistration.withRegistrationId(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .redirectUri(""{baseUrl}/login/oauth2/code/{registrationId}"") .scope(""openid"", ""profile"", ""email"", ""address"", ""phone"") .authorizationUri(""https://accounts.google.com/o/oauth2/v2/auth"") .tokenUri(""https://www.googleapis.com/oauth2/v4/token"") .userInfoUri(""https://www.googleapis.com/oauth2/v3/userinfo"") .userNameAttributeName(IdTokenClaimNames.SUB) .jwkSetUri(""https://www.googleapis.com/oauth2/v3/certs"") .clientName(""Google"") .build(); } } @Configuration @EnableWebFluxSecurity class OAuth2LoginConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2Login { } } return http.build() } @Bean fun clientRegistrationRepository(): ReactiveClientRegistrationRepository { return InMemoryReactiveClientRegistrationRepository(googleClientRegistration()) } private fun googleClientRegistration(): ClientRegistration { return ClientRegistration.withRegistrationId(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC) .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) .redirectUri(""{baseUrl}/login/oauth2/code/{registrationId}"") .scope(""openid"", ""profile"", ""email"", ""address"", ""phone"") .authorizationUri(""https://accounts.google.com/o/oauth2/v2/auth"") .tokenUri(""https://www.googleapis.com/oauth2/v4/token"") .userInfoUri(""https://www.googleapis.com/oauth2/v3/userinfo"") .userNameAttributeName(IdTokenClaimNames.SUB) .jwkSetUri(""https://www.googleapis.com/oauth2/v3/certs"") .clientName(""Google"") .build() } } Java Configuration without Spring Boot: If you are not able to use Spring Boot and would like to configure one of the pre-defined providers in CommonOAuth2Provider (for example, Google), apply the following configuration: OAuth2 Login Configuration Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2LoginConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .authorizeExchange(authorize -> authorize .anyExchange().authenticated() ) .oauth2Login(withDefaults()); return http.build(); } @Bean public ReactiveClientRegistrationRepository clientRegistrationRepository() { return new InMemoryReactiveClientRegistrationRepository(this.googleClientRegistration()); } @Bean public ReactiveOAuth2AuthorizedClientService authorizedClientService( ReactiveClientRegistrationRepository clientRegistrationRepository) { return new InMemoryReactiveOAuth2AuthorizedClientService(clientRegistrationRepository); } @Bean public ServerOAuth2AuthorizedClientRepository authorizedClientRepository( ReactiveOAuth2AuthorizedClientService authorizedClientService) { return new AuthenticatedPrincipalServerOAuth2AuthorizedClientRepository(authorizedClientService); } private ClientRegistration googleClientRegistration() { return CommonOAuth2Provider.GOOGLE.getBuilder(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .build(); } } @Configuration @EnableWebFluxSecurity class OAuth2LoginConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2Login { } } return http.build() } @Bean fun clientRegistrationRepository(): ReactiveClientRegistrationRepository { return InMemoryReactiveClientRegistrationRepository(googleClientRegistration()) } @Bean fun authorizedClientService( clientRegistrationRepository: ReactiveClientRegistrationRepository ): ReactiveOAuth2AuthorizedClientService { return InMemoryReactiveOAuth2AuthorizedClientService(clientRegistrationRepository) } @Bean fun authorizedClientRepository( authorizedClientService: ReactiveOAuth2AuthorizedClientService ): ServerOAuth2AuthorizedClientRepository { return AuthenticatedPrincipalServerOAuth2AuthorizedClientRepository(authorizedClientService) } private fun googleClientRegistration(): ClientRegistration { return CommonOAuth2Provider.GOOGLE.getBuilder(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .build() } }"
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/login/advanced.html","Advanced Configuration: The OAuth 2.0 Authorization Framework defines the Protocol Endpoints(https://tools.ietf.org/html/rfc6749#section-3) as follows: The authorization process utilizes two authorization server endpoints (HTTP resources): Authorization Endpoint: Used by the client to obtain authorization from the resource owner via user-agent redirection. Token Endpoint: Used by the client to exchange an authorization grant for an access token, typically with client authentication. As well as one client endpoint: Redirection Endpoint: Used by the authorization server to return responses containing authorization credentials to the client via the resource owner user-agent. The OpenID Connect Core 1.0 specification defines the UserInfo Endpoint(https://openid.net/specs/openid-connect-core-1_0.html#UserInfo) as follows: The UserInfo Endpoint is an OAuth 2.0 Protected Resource that returns claims about the authenticated end-user. To obtain the requested claims about the end-user, the client makes a request to the UserInfo Endpoint by using an access token obtained through OpenID Connect Authentication. These claims are normally represented by a JSON object that contains a collection of name-value pairs for the claims. ServerHttpSecurity.oauth2Login() provides a number of configuration options for customizing OAuth 2.0 Login. The following code shows the complete configuration options available for the oauth2Login() DSL: OAuth2 Login Configuration Options Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2LoginSecurityConfig { @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .oauth2Login(oauth2 -> oauth2 .authenticationConverter(this.authenticationConverter()) .authenticationMatcher(this.authenticationMatcher()) .authenticationManager(this.authenticationManager()) .authenticationSuccessHandler(this.authenticationSuccessHandler()) .authenticationFailureHandler(this.authenticationFailureHandler()) .clientRegistrationRepository(this.clientRegistrationRepository()) .authorizedClientRepository(this.authorizedClientRepository()) .authorizedClientService(this.authorizedClientService()) .authorizationRequestResolver(this.authorizationRequestResolver()) .authorizationRequestRepository(this.authorizationRequestRepository()) .securityContextRepository(this.securityContextRepository()) ); return http.build(); } } @Configuration @EnableWebFluxSecurity class OAuth2LoginSecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { oauth2Login { authenticationConverter = authenticationConverter() authenticationMatcher = authenticationMatcher() authenticationManager = authenticationManager() authenticationSuccessHandler = authenticationSuccessHandler() authenticationFailureHandler = authenticationFailureHandler() clientRegistrationRepository = clientRegistrationRepository() authorizedClientRepository = authorizedClientRepository() authorizedClientService = authorizedClientService() authorizationRequestResolver = authorizationRequestResolver() authorizationRequestRepository = authorizationRequestRepository() securityContextRepository = securityContextRepository() } } return http.build() } } The following sections go into more detail on each of the configuration options available: OAuth 2.0 Login Page(#webflux-oauth2-login-advanced-login-page) Redirection Endpoint(#webflux-oauth2-login-advanced-redirection-endpoint) UserInfo Endpoint(#webflux-oauth2-login-advanced-userinfo-endpoint) ID Token Signature Verification(#webflux-oauth2-login-advanced-idtoken-verify) OpenID Connect 1.0 Logout(#webflux-oauth2-login-advanced-oidc-logout) OAuth 2.0 Login Page: By default, the OAuth 2.0 Login Page is auto-generated by the LoginPageGeneratingWebFilter . The default login page shows each configured OAuth Client with its ClientRegistration.clientName as a link, which is capable of initiating the Authorization Request (or OAuth 2.0 Login). In order for LoginPageGeneratingWebFilter to show links for configured OAuth Clients, the registered ReactiveClientRegistrationRepository needs to also implement Iterable<ClientRegistration> . See InMemoryReactiveClientRegistrationRepository for reference. The link’s destination for each OAuth Client defaults to the following: ""/oauth2/authorization/{registrationId}"" The following line shows an example: <a href=""/oauth2/authorization/google"">Google</a> To override the default login page, configure the exceptionHandling().authenticationEntryPoint() and (optionally) oauth2Login().authorizationRequestResolver() . The following listing shows an example: OAuth2 Login Page Configuration Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .exceptionHandling(exceptionHandling -> exceptionHandling .authenticationEntryPoint(new RedirectServerAuthenticationEntryPoint(""/login/oauth2"")) ) .oauth2Login(oauth2 -> oauth2 .authorizationRequestResolver(this.authorizationRequestResolver()) ); return http.build(); } private ServerOAuth2AuthorizationRequestResolver authorizationRequestResolver() { ServerWebExchangeMatcher authorizationRequestMatcher = new PathPatternParserServerWebExchangeMatcher( ""/login/oauth2/authorization/{registrationId}""); return new DefaultServerOAuth2AuthorizationRequestResolver( this.clientRegistrationRepository(), authorizationRequestMatcher); } ... } @Configuration @EnableWebFluxSecurity class OAuth2LoginSecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { exceptionHandling { authenticationEntryPoint = RedirectServerAuthenticationEntryPoint(""/login/oauth2"") } oauth2Login { authorizationRequestResolver = authorizationRequestResolver() } } return http.build() } private fun authorizationRequestResolver(): ServerOAuth2AuthorizationRequestResolver { val authorizationRequestMatcher: ServerWebExchangeMatcher = PathPatternParserServerWebExchangeMatcher( ""/login/oauth2/authorization/{registrationId}"" ) return DefaultServerOAuth2AuthorizationRequestResolver( clientRegistrationRepository(), authorizationRequestMatcher ) } ... } You need to provide a @Controller with a @RequestMapping(""/login/oauth2"") that is capable of rendering the custom login page. As noted earlier, configuring oauth2Login().authorizationRequestResolver() is optional. However, if you choose to customize it, ensure the link to each OAuth Client matches the pattern provided through the ServerWebExchangeMatcher . The following line shows an example: <a href=""/login/oauth2/authorization/google"">Google</a> Redirection Endpoint: The Redirection Endpoint is used by the Authorization Server for returning the Authorization Response (which contains the authorization credentials) to the client via the Resource Owner user-agent. OAuth 2.0 Login leverages the Authorization Code Grant. Therefore, the authorization credential is the authorization code. The default Authorization Response redirection endpoint is /login/oauth2/code/{registrationId} . If you would like to customize the Authorization Response redirection endpoint, configure it as shown in the following example: Redirection Endpoint Configuration Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .oauth2Login(oauth2 -> oauth2 .authenticationMatcher(new PathPatternParserServerWebExchangeMatcher(""/login/oauth2/callback/{registrationId}"")) ); return http.build(); } } @Configuration @EnableWebFluxSecurity class OAuth2LoginSecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { oauth2Login { authenticationMatcher = PathPatternParserServerWebExchangeMatcher(""/login/oauth2/callback/{registrationId}"") } } return http.build() } } You also need to ensure the ClientRegistration.redirectUri matches the custom Authorization Response redirection endpoint. The following listing shows an example: Java Kotlin return CommonOAuth2Provider.GOOGLE.getBuilder(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .redirectUri(""{baseUrl}/login/oauth2/callback/{registrationId}"") .build(); return CommonOAuth2Provider.GOOGLE.getBuilder(""google"") .clientId(""google-client-id"") .clientSecret(""google-client-secret"") .redirectUri(""{baseUrl}/login/oauth2/callback/{registrationId}"") .build() UserInfo Endpoint: The UserInfo Endpoint includes a number of configuration options, as described in the following sub-sections: Mapping User Authorities(#webflux-oauth2-login-advanced-map-authorities) OAuth 2.0 UserService(#webflux-oauth2-login-advanced-oauth2-user-service) OpenID Connect 1.0 UserService(#webflux-oauth2-login-advanced-oidc-user-service) Mapping User Authorities: After the user successfully authenticates with the OAuth 2.0 Provider, the OAuth2User.getAuthorities() (or OidcUser.getAuthorities() ) contains a list of granted authorities populated from OAuth2UserRequest.getAccessToken().getScopes() and prefixed with SCOPE_ . These granted authorities may be mapped to a new set of GrantedAuthority instances, which will be supplied to OAuth2AuthenticationToken when completing the authentication. OAuth2AuthenticationToken.getAuthorities() is used for authorizing requests, such as in hasRole('USER') or hasRole('ADMIN') . There are a couple of options to choose from when mapping user authorities: Using a GrantedAuthoritiesMapper(#webflux-oauth2-login-advanced-map-authorities-grantedauthoritiesmapper) Delegation-based strategy with ReactiveOAuth2UserService(#webflux-oauth2-login-advanced-map-authorities-reactiveoauth2userservice) Using a GrantedAuthoritiesMapper: The GrantedAuthoritiesMapper is given a list of granted authorities which contains a special authority of type OAuth2UserAuthority and the authority string OAUTH2_USER (or OidcUserAuthority and the authority string OIDC_USER ). Register a GrantedAuthoritiesMapper @Bean to have it automatically applied to the configuration, as shown in the following example: Granted Authorities Mapper Configuration Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http ... .oauth2Login(withDefaults()); return http.build(); } @Bean public GrantedAuthoritiesMapper userAuthoritiesMapper() { return (authorities) -> { Set<GrantedAuthority> mappedAuthorities = new HashSet<>(); authorities.forEach(authority -> { if (OidcUserAuthority.class.isInstance(authority)) { OidcUserAuthority oidcUserAuthority = (OidcUserAuthority)authority; OidcIdToken idToken = oidcUserAuthority.getIdToken(); OidcUserInfo userInfo = oidcUserAuthority.getUserInfo(); // Map the claims found in idToken and/or userInfo // to one or more GrantedAuthority's and add it to mappedAuthorities } else if (OAuth2UserAuthority.class.isInstance(authority)) { OAuth2UserAuthority oauth2UserAuthority = (OAuth2UserAuthority)authority; Map<String, Object> userAttributes = oauth2UserAuthority.getAttributes(); // Map the attributes found in userAttributes // to one or more GrantedAuthority's and add it to mappedAuthorities } }); return mappedAuthorities; }; } } @Configuration @EnableWebFluxSecurity class OAuth2LoginSecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { oauth2Login { } } return http.build() } @Bean fun userAuthoritiesMapper(): GrantedAuthoritiesMapper = GrantedAuthoritiesMapper { authorities: Collection<GrantedAuthority> -> val mappedAuthorities = emptySet<GrantedAuthority>() authorities.forEach { authority -> if (authority is OidcUserAuthority) { val idToken = authority.idToken val userInfo = authority.userInfo // Map the claims found in idToken and/or userInfo // to one or more GrantedAuthority's and add it to mappedAuthorities } else if (authority is OAuth2UserAuthority) { val userAttributes = authority.attributes // Map the attributes found in userAttributes // to one or more GrantedAuthority's and add it to mappedAuthorities } } mappedAuthorities } } Delegation-based strategy with ReactiveOAuth2UserService: This strategy is advanced compared to using a GrantedAuthoritiesMapper , however, it’s also more flexible as it gives you access to the OAuth2UserRequest and OAuth2User (when using an OAuth 2.0 UserService) or OidcUserRequest and OidcUser (when using an OpenID Connect 1.0 UserService). The OAuth2UserRequest (and OidcUserRequest ) provides you access to the associated OAuth2AccessToken , which is very useful in the cases where the delegator needs to fetch authority information from a protected resource before it can map the custom authorities for the user. The following example shows how to implement and configure a delegation-based strategy using an OpenID Connect 1.0 UserService: ReactiveOAuth2UserService Configuration Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http ... .oauth2Login(withDefaults()); return http.build(); } @Bean public ReactiveOAuth2UserService<OidcUserRequest, OidcUser> oidcUserService() { final OidcReactiveOAuth2UserService delegate = new OidcReactiveOAuth2UserService(); return (userRequest) -> { // Delegate to the default implementation for loading a user return delegate.loadUser(userRequest) .flatMap((oidcUser) -> { OAuth2AccessToken accessToken = userRequest.getAccessToken(); Set<GrantedAuthority> mappedAuthorities = new HashSet<>(); // TODO // 1) Fetch the authority information from the protected resource using accessToken // 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities // 3) Create a copy of oidcUser but use the mappedAuthorities instead ProviderDetails providerDetails = userRequest.getClientRegistration().getProviderDetails(); String userNameAttributeName = providerDetails.getUserInfoEndpoint().getUserNameAttributeName(); if (StringUtils.hasText(userNameAttributeName)) { oidcUser = new DefaultOidcUser(mappedAuthorities, oidcUser.getIdToken(), oidcUser.getUserInfo(), userNameAttributeName); } else { oidcUser = new DefaultOidcUser(mappedAuthorities, oidcUser.getIdToken(), oidcUser.getUserInfo()); } return Mono.just(oidcUser); }); }; } } @Configuration @EnableWebFluxSecurity class OAuth2LoginSecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { oauth2Login { } } return http.build() } @Bean fun oidcUserService(): ReactiveOAuth2UserService<OidcUserRequest, OidcUser> { val delegate = OidcReactiveOAuth2UserService() return ReactiveOAuth2UserService { userRequest -> // Delegate to the default implementation for loading a user delegate.loadUser(userRequest) .flatMap { oidcUser -> val accessToken = userRequest.accessToken val mappedAuthorities = mutableSetOf<GrantedAuthority>() // TODO // 1) Fetch the authority information from the protected resource using accessToken // 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities // 3) Create a copy of oidcUser but use the mappedAuthorities instead val providerDetails = userRequest.getClientRegistration().getProviderDetails() val userNameAttributeName = providerDetails.getUserInfoEndpoint().getUserNameAttributeName() val mappedOidcUser = if (StringUtils.hasText(userNameAttributeName)) { DefaultOidcUser(mappedAuthorities, oidcUser.idToken, oidcUser.userInfo, userNameAttributeName) } else { DefaultOidcUser(mappedAuthorities, oidcUser.idToken, oidcUser.userInfo) } Mono.just(mappedOidcUser) } } } } OAuth 2.0 UserService: DefaultReactiveOAuth2UserService is an implementation of a ReactiveOAuth2UserService that supports standard OAuth 2.0 Provider’s. ReactiveOAuth2UserService obtains the user attributes of the end-user (the resource owner) from the UserInfo Endpoint (by using the access token granted to the client during the authorization flow) and returns an AuthenticatedPrincipal in the form of an OAuth2User . DefaultReactiveOAuth2UserService uses a WebClient when requesting the user attributes at the UserInfo Endpoint. If you need to customize the pre-processing of the UserInfo Request and/or the post-handling of the UserInfo Response, you will need to provide DefaultReactiveOAuth2UserService.setWebClient() with a custom configured WebClient . Whether you customize DefaultReactiveOAuth2UserService or provide your own implementation of ReactiveOAuth2UserService , you’ll need to configure it as shown in the following example: Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http ... .oauth2Login(withDefaults()); return http.build(); } @Bean public ReactiveOAuth2UserService<OAuth2UserRequest, OAuth2User> oauth2UserService() { ... } } @Configuration @EnableWebFluxSecurity class OAuth2LoginSecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { oauth2Login { } } return http.build() } @Bean fun oauth2UserService(): ReactiveOAuth2UserService<OAuth2UserRequest, OAuth2User> { // ... } } OpenID Connect 1.0 UserService: OidcReactiveOAuth2UserService is an implementation of a ReactiveOAuth2UserService that supports OpenID Connect 1.0 Provider’s. The OidcReactiveOAuth2UserService leverages the DefaultReactiveOAuth2UserService when requesting the user attributes at the UserInfo Endpoint. If you need to customize the pre-processing of the UserInfo Request and/or the post-handling of the UserInfo Response, you will need to provide OidcReactiveOAuth2UserService.setOauth2UserService() with a custom configured ReactiveOAuth2UserService . Whether you customize OidcReactiveOAuth2UserService or provide your own implementation of ReactiveOAuth2UserService for OpenID Connect 1.0 Provider’s, you’ll need to configure it as shown in the following example: Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2LoginSecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http ... .oauth2Login(withDefaults()); return http.build(); } @Bean public ReactiveOAuth2UserService<OidcUserRequest, OidcUser> oidcUserService() { ... } } @Configuration @EnableWebFluxSecurity class OAuth2LoginSecurityConfig { @Bean fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { oauth2Login { } } return http.build() } @Bean fun oidcUserService(): ReactiveOAuth2UserService<OidcUserRequest, OidcUser> { // ... } } ID Token Signature Verification: OpenID Connect 1.0 Authentication introduces the ID Token(https://openid.net/specs/openid-connect-core-1_0.html#IDToken) , which is a security token that contains Claims about the Authentication of an End-User by an Authorization Server when used by a Client. The ID Token is represented as a JSON Web Token(https://tools.ietf.org/html/rfc7519) (JWT) and MUST be signed using JSON Web Signature(https://tools.ietf.org/html/rfc7515) (JWS). The ReactiveOidcIdTokenDecoderFactory provides a ReactiveJwtDecoder used for OidcIdToken signature verification. The default algorithm is RS256 but may be different when assigned during client registration. For these cases, a resolver may be configured to return the expected JWS algorithm assigned for a specific client. The JWS algorithm resolver is a Function that accepts a ClientRegistration and returns the expected JwsAlgorithm for the client, eg. SignatureAlgorithm.RS256 or MacAlgorithm.HS256 The following code shows how to configure the OidcIdTokenDecoderFactory @Bean to default to MacAlgorithm.HS256 for all ClientRegistration : Java Kotlin @Bean public ReactiveJwtDecoderFactory<ClientRegistration> idTokenDecoderFactory() { ReactiveOidcIdTokenDecoderFactory idTokenDecoderFactory = new ReactiveOidcIdTokenDecoderFactory(); idTokenDecoderFactory.setJwsAlgorithmResolver(clientRegistration -> MacAlgorithm.HS256); return idTokenDecoderFactory; } @Bean fun idTokenDecoderFactory(): ReactiveJwtDecoderFactory<ClientRegistration> { val idTokenDecoderFactory = ReactiveOidcIdTokenDecoderFactory() idTokenDecoderFactory.setJwsAlgorithmResolver { MacAlgorithm.HS256 } return idTokenDecoderFactory } For MAC based algorithms such as HS256 , HS384 or HS512 , the client-secret corresponding to the client-id is used as the symmetric key for signature verification. If more than one ClientRegistration is configured for OpenID Connect 1.0 Authentication, the JWS algorithm resolver may evaluate the provided ClientRegistration to determine which algorithm to return. Then, you can proceed to configure logout(logout.html) ."
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/login/logout.html","OIDC Logout: Once an end user is able to login to your application, it’s important to consider how they will log out. Generally speaking, there are three use cases for you to consider: I want to perform only a local logout I want to log out both my application and the OIDC Provider, initiated by my application I want to log out both my application and the OIDC Provider, initiated by the OIDC Provider Local Logout: To perform a local logout, no special OIDC configuration is needed. Spring Security automatically stands up a local logout endpoint, which you can configure through the logout() DSL(../../authentication/logout.html) . OpenID Connect 1.0 Client-Initiated Logout: OpenID Connect Session Management 1.0 allows the ability to log out the end user at the Provider by using the Client. One of the strategies available is RP-Initiated Logout(https://openid.net/specs/openid-connect-rpinitiated-1_0.html) . If the OpenID Provider supports both Session Management and Discovery(https://openid.net/specs/openid-connect-discovery-1_0.html) , the client can obtain the end_session_endpoint URL from the OpenID Provider’s Discovery Metadata(https://openid.net/specs/openid-connect-session-1_0.html#OPMetadata) . You can do so by configuring the ClientRegistration with the issuer-uri , as follows: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret ... provider: okta: issuer-uri: https://dev-1234.oktapreview.com Also, you should configure OidcClientInitiatedServerLogoutSuccessHandler , which implements RP-Initiated Logout, as follows: Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2LoginSecurityConfig { @Autowired private ReactiveClientRegistrationRepository clientRegistrationRepository; @Bean public SecurityWebFilterChain filterChain(ServerHttpSecurity http) throws Exception { http .authorizeExchange((authorize) -> authorize .anyExchange().authenticated() ) .oauth2Login(withDefaults()) .logout((logout) -> logout .logoutSuccessHandler(oidcLogoutSuccessHandler()) ); return http.build(); } private ServerLogoutSuccessHandler oidcLogoutSuccessHandler() { OidcClientInitiatedServerLogoutSuccessHandler oidcLogoutSuccessHandler = new OidcClientInitiatedServerLogoutSuccessHandler(this.clientRegistrationRepository); // Sets the location that the End-User's User Agent will be redirected to // after the logout has been performed at the Provider oidcLogoutSuccessHandler.setPostLogoutRedirectUri(""{baseUrl}""); return oidcLogoutSuccessHandler; } } @Configuration @EnableWebFluxSecurity class OAuth2LoginSecurityConfig { @Autowired private lateinit var clientRegistrationRepository: ReactiveClientRegistrationRepository @Bean open fun filterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2Login { } logout { logoutSuccessHandler = oidcLogoutSuccessHandler() } } return http.build() } private fun oidcLogoutSuccessHandler(): ServerLogoutSuccessHandler { val oidcLogoutSuccessHandler = OidcClientInitiatedServerLogoutSuccessHandler(clientRegistrationRepository) // Sets the location that the End-User's User Agent will be redirected to // after the logout has been performed at the Provider oidcLogoutSuccessHandler.setPostLogoutRedirectUri(""{baseUrl}"") return oidcLogoutSuccessHandler } } OidcClientInitiatedServerLogoutSuccessHandler supports the {baseUrl} placeholder. If used, the application’s base URL, such as app.example.org(https://app.example.org) , replaces it at request time. OpenID Connect 1.0 Back-Channel Logout: OpenID Connect Session Management 1.0 allows the ability to log out the end user at the Client by having the Provider make an API call to the Client. This is referred to as OIDC Back-Channel Logout(https://openid.net/specs/openid-connect-backchannel-1_0.html) . To enable this, you can stand up the Back-Channel Logout endpoint in the DSL like so: Java Kotlin @Bean public SecurityWebFilterChain filterChain(ServerHttpSecurity http) throws Exception { http .authorizeExchange((authorize) -> authorize .anyExchange().authenticated() ) .oauth2Login(withDefaults()) .oidcLogout((logout) -> logout .backChannel(Customizer.withDefaults()) ); return http.build(); } @Bean open fun filterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2Login { } oidcLogout { backChannel { } } } return http.build() } And that’s it! This will stand up the endpoint /logout/connect/back-channel/{registrationId} which the OIDC Provider can request to invalidate a given session of an end user in your application. oidcLogout requires that oauth2Login also be configured. oidcLogout requires that the session cookie be called JSESSIONID in order to correctly log out each session through a backchannel. Back-Channel Logout Architecture: Consider a ClientRegistration whose identifier is registrationId . The overall flow for a Back-Channel logout is like this: At login time, Spring Security correlates the ID Token, CSRF Token, and Provider Session ID (if any) to your application’s session id in its ReactiveOidcSessionStrategy implementation. Then at logout time, your OIDC Provider makes an API call to /logout/connect/back-channel/registrationId including a Logout Token that indicates either the sub (the End User) or the sid (the Provider Session ID) to logout. Spring Security validates the token’s signature and claims. If the token contains a sid claim, then only the Client’s session that correlates to that provider session is terminated. Otherwise, if the token contains a sub claim, then all that Client’s sessions for that End User are terminated. Remember that Spring Security’s OIDC support is multi-tenant. This means that it will only terminate sessions whose Client matches the aud claim in the Logout Token. Customizing the OIDC Provider Session Strategy: By default, Spring Security stores in-memory all links between the OIDC Provider session and the Client session. There are a number of circumstances, like a clustered application, where it would be nice to store this instead in a separate location, like a database. You can achieve this by configuring a custom ReactiveOidcSessionStrategy , like so: Java Kotlin @Component public final class MySpringDataOidcSessionStrategy implements OidcSessionStrategy { private final OidcProviderSessionRepository sessions; // ... @Override public void saveSessionInformation(OidcSessionInformation info) { this.sessions.save(info); } @Override public OidcSessionInformation(String clientSessionId) { return this.sessions.removeByClientSessionId(clientSessionId); } @Override public Iterable<OidcSessionInformation> removeSessionInformation(OidcLogoutToken token) { return token.getSessionId() != null ? this.sessions.removeBySessionIdAndIssuerAndAudience(...) : this.sessions.removeBySubjectAndIssuerAndAudience(...); } } @Component class MySpringDataOidcSessionStrategy: ReactiveOidcSessionStrategy { val sessions: OidcProviderSessionRepository // ... @Override fun saveSessionInformation(info: OidcSessionInformation): Mono<Void> { return this.sessions.save(info) } @Override fun removeSessionInformation(clientSessionId: String): Mono<OidcSessionInformation> { return this.sessions.removeByClientSessionId(clientSessionId); } @Override fun removeSessionInformation(token: OidcLogoutToken): Flux<OidcSessionInformation> { return token.getSessionId() != null ? this.sessions.removeBySessionIdAndIssuerAndAudience(...) : this.sessions.removeBySubjectAndIssuerAndAudience(...); } }"
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/client/index.html","OAuth 2.0 Client: The OAuth 2.0 Client features provide support for the Client role as defined in the OAuth 2.0 Authorization Framework(https://tools.ietf.org/html/rfc6749#section-1.1) . At a high-level, the core features available are: Authorization Grant support Authorization Code(https://tools.ietf.org/html/rfc6749#section-1.3.1) Refresh Token(https://tools.ietf.org/html/rfc6749#section-6) Client Credentials(https://tools.ietf.org/html/rfc6749#section-1.3.4) Resource Owner Password Credentials(https://tools.ietf.org/html/rfc6749#section-1.3.3) JWT Bearer(https://datatracker.ietf.org/doc/html/rfc7523#section-2.1) Token Exchange(https://datatracker.ietf.org/doc/html/rfc8693#section-2.1) Client Authentication support JWT Bearer(https://datatracker.ietf.org/doc/html/rfc7523#section-2.2) HTTP Client support WebClient integration for Reactive Environments(authorized-clients.html#oauth2Client-webclient-webflux) (for requesting protected resources) The ServerHttpSecurity.oauth2Client() DSL provides a number of configuration options for customizing the core components used by OAuth 2.0 Client. The following code shows the complete configuration options provided by the ServerHttpSecurity.oauth2Client() DSL: OAuth2 Client Configuration Options Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2ClientSecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .oauth2Client(oauth2 -> oauth2 .clientRegistrationRepository(this.clientRegistrationRepository()) .authorizedClientRepository(this.authorizedClientRepository()) .authorizationRequestRepository(this.authorizationRequestRepository()) .authorizationRequestResolver(this.authorizationRequestResolver()) .authenticationConverter(this.authenticationConverter()) .authenticationManager(this.authenticationManager()) ); return http.build(); } } @Configuration @EnableWebFluxSecurity class OAuth2ClientSecurityConfig { @Bean fun securityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { oauth2Client { clientRegistrationRepository = clientRegistrationRepository() authorizedClientRepository = authorizedClientRepository() authorizationRequestRepository = authorizedRequestRepository() authorizationRequestResolver = authorizationRequestResolver() authenticationConverter = authenticationConverter() authenticationManager = authenticationManager() } } return http.build() } } The ReactiveOAuth2AuthorizedClientManager is responsible for managing the authorization (or re-authorization) of an OAuth 2.0 Client, in collaboration with one or more ReactiveOAuth2AuthorizedClientProvider (s). The following code shows an example of how to register a ReactiveOAuth2AuthorizedClientManager @Bean and associate it with a ReactiveOAuth2AuthorizedClientProvider composite that provides support for the authorization_code , refresh_token , client_credentials and password authorization grant types: Java Kotlin @Bean public ReactiveOAuth2AuthorizedClientManager authorizedClientManager( ReactiveClientRegistrationRepository clientRegistrationRepository, ServerOAuth2AuthorizedClientRepository authorizedClientRepository) { ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken() .clientCredentials() .password() .build(); DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager = new DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean fun authorizedClientManager( clientRegistrationRepository: ReactiveClientRegistrationRepository, authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager { val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken() .clientCredentials() .password() .build() val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } Section Summary: Core Interfaces and Classes(core.html) OAuth2 Authorization Grants(authorization-grants.html) OAuth2 Client Authentication(client-authentication.html) OAuth2 Authorized Clients(authorized-clients.html)"
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/client/core.html","Core Interfaces / Classes: ClientRegistration: ClientRegistration is a representation of a client registered with an OAuth 2.0 or OpenID Connect 1.0 Provider. A client registration holds information, such as client id, client secret, authorization grant type, redirect URI, scope(s), authorization URI, token URI, and other details. ClientRegistration and its properties are defined as follows: public final class ClientRegistration { private String registrationId; (1) private String clientId; (2) private String clientSecret; (3) private ClientAuthenticationMethod clientAuthenticationMethod; (4) private AuthorizationGrantType authorizationGrantType; (5) private String redirectUri; (6) private Set<String> scopes; (7) private ProviderDetails providerDetails; private String clientName; (8) public class ProviderDetails { private String authorizationUri; (9) private String tokenUri; (10) private UserInfoEndpoint userInfoEndpoint; private String jwkSetUri; (11) private String issuerUri; (12) private Map<String, Object> configurationMetadata; (13) public class UserInfoEndpoint { private String uri; (14) private AuthenticationMethod authenticationMethod; (15) private String userNameAttributeName; (16) } } } 1 registrationId : The ID that uniquely identifies the ClientRegistration . 2 clientId : The client identifier. 3 clientSecret : The client secret. 4 clientAuthenticationMethod : The method used to authenticate the Client with the Provider. The supported values are client_secret_basic , client_secret_post , private_key_jwt , client_secret_jwt and none (public clients)(https://tools.ietf.org/html/rfc6749#section-2.1) . 5 authorizationGrantType : The OAuth 2.0 Authorization Framework defines four Authorization Grant(https://tools.ietf.org/html/rfc6749#section-1.3) types. The supported values are authorization_code , client_credentials , password , as well as, extension grant type urn:ietf:params:oauth:grant-type:jwt-bearer . 6 redirectUri : The client’s registered redirect URI that the Authorization Server redirects the end-user’s user-agent to after the end-user has authenticated and authorized access to the client. 7 scopes : The scope(s) requested by the client during the Authorization Request flow, such as openid, email, or profile. 8 clientName : A descriptive name used for the client. The name may be used in certain scenarios, such as when displaying the name of the client in the auto-generated login page. 9 authorizationUri : The Authorization Endpoint URI for the Authorization Server. 10 tokenUri : The Token Endpoint URI for the Authorization Server. 11 jwkSetUri : The URI used to retrieve the JSON Web Key (JWK)(https://tools.ietf.org/html/rfc7517) Set from the Authorization Server, which contains the cryptographic key(s) used to verify the JSON Web Signature (JWS)(https://tools.ietf.org/html/rfc7515) of the ID Token and optionally the UserInfo Response. 12 issuerUri : Returns the issuer identifier uri for the OpenID Connect 1.0 provider or the OAuth 2.0 Authorization Server. 13 configurationMetadata : The OpenID Provider Configuration Information(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) . This information will only be available if the Spring Boot property spring.security.oauth2.client.provider.[providerId].issuerUri is configured. 14 (userInfoEndpoint)uri : The UserInfo Endpoint URI used to access the claims/attributes of the authenticated end-user. 15 (userInfoEndpoint)authenticationMethod : The authentication method used when sending the access token to the UserInfo Endpoint. The supported values are header , form and query . 16 userNameAttributeName : The name of the attribute returned in the UserInfo Response that references the Name or Identifier of the end-user. A ClientRegistration can be initially configured using discovery of an OpenID Connect Provider’s Configuration endpoint(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) or an Authorization Server’s Metadata endpoint(https://tools.ietf.org/html/rfc8414#section-3) . ClientRegistrations provides convenience methods for configuring a ClientRegistration in this way, as can be seen in the following example: Java Kotlin ClientRegistration clientRegistration = ClientRegistrations.fromIssuerLocation(""https://idp.example.com/issuer"").build(); val clientRegistration = ClientRegistrations.fromIssuerLocation(""https://idp.example.com/issuer"").build() The above code will query in series idp.example.com/issuer/.well-known/openid-configuration(https://idp.example.com/issuer/.well-known/openid-configuration) , and then idp.example.com/.well-known/openid-configuration/issuer(https://idp.example.com/.well-known/openid-configuration/issuer) , and finally idp.example.com/.well-known/oauth-authorization-server/issuer(https://idp.example.com/.well-known/oauth-authorization-server/issuer) , stopping at the first to return a 200 response. As an alternative, you can use ClientRegistrations.fromOidcIssuerLocation() to only query the OpenID Connect Provider’s Configuration endpoint. ReactiveClientRegistrationRepository: The ReactiveClientRegistrationRepository serves as a repository for OAuth 2.0 / OpenID Connect 1.0 ClientRegistration (s). Client registration information is ultimately stored and owned by the associated Authorization Server. This repository provides the ability to retrieve a sub-set of the primary client registration information, which is stored with the Authorization Server. Spring Boot auto-configuration binds each of the properties under spring.security.oauth2.client.registration. [registrationId] to an instance of ClientRegistration and then composes each of the ClientRegistration instance(s) within a ReactiveClientRegistrationRepository . The default implementation of ReactiveClientRegistrationRepository is InMemoryReactiveClientRegistrationRepository . The auto-configuration also registers the ReactiveClientRegistrationRepository as a @Bean in the ApplicationContext so that it is available for dependency-injection, if needed by the application. The following listing shows an example: Java Kotlin @Controller public class OAuth2ClientController { @Autowired private ReactiveClientRegistrationRepository clientRegistrationRepository; @GetMapping(""/"") public Mono<String> index() { return this.clientRegistrationRepository.findByRegistrationId(""okta"") ... .thenReturn(""index""); } } @Controller class OAuth2ClientController { @Autowired private lateinit var clientRegistrationRepository: ReactiveClientRegistrationRepository @GetMapping(""/"") fun index(): Mono<String> { return this.clientRegistrationRepository.findByRegistrationId(""okta"") ... .thenReturn(""index"") } } OAuth2AuthorizedClient: OAuth2AuthorizedClient is a representation of an Authorized Client. A client is considered to be authorized when the end-user (Resource Owner) has granted authorization to the client to access its protected resources. OAuth2AuthorizedClient serves the purpose of associating an OAuth2AccessToken (and optional OAuth2RefreshToken ) to a ClientRegistration (client) and resource owner, who is the Principal end-user that granted the authorization. ServerOAuth2AuthorizedClientRepository / ReactiveOAuth2AuthorizedClientService: ServerOAuth2AuthorizedClientRepository is responsible for persisting OAuth2AuthorizedClient (s) between web requests. Whereas, the primary role of ReactiveOAuth2AuthorizedClientService is to manage OAuth2AuthorizedClient (s) at the application-level. From a developer perspective, the ServerOAuth2AuthorizedClientRepository or ReactiveOAuth2AuthorizedClientService provides the capability to lookup an OAuth2AccessToken associated with a client so that it may be used to initiate a protected resource request. The following listing shows an example: Java Kotlin @Controller public class OAuth2ClientController { @Autowired private ReactiveOAuth2AuthorizedClientService authorizedClientService; @GetMapping(""/"") public Mono<String> index(Authentication authentication) { return this.authorizedClientService.loadAuthorizedClient(""okta"", authentication.getName()) .map(OAuth2AuthorizedClient::getAccessToken) ... .thenReturn(""index""); } } @Controller class OAuth2ClientController { @Autowired private lateinit var authorizedClientService: ReactiveOAuth2AuthorizedClientService @GetMapping(""/"") fun index(authentication: Authentication): Mono<String> { return this.authorizedClientService.loadAuthorizedClient<OAuth2AuthorizedClient>(""okta"", authentication.name) .map { it.accessToken } ... .thenReturn(""index"") } } Spring Boot auto-configuration registers an ServerOAuth2AuthorizedClientRepository and/or ReactiveOAuth2AuthorizedClientService @Bean in the ApplicationContext . However, the application may choose to override and register a custom ServerOAuth2AuthorizedClientRepository or ReactiveOAuth2AuthorizedClientService @Bean . The default implementation of ReactiveOAuth2AuthorizedClientService is InMemoryReactiveOAuth2AuthorizedClientService , which stores OAuth2AuthorizedClient (s) in-memory. Alternatively, the R2DBC implementation R2dbcReactiveOAuth2AuthorizedClientService may be configured for persisting OAuth2AuthorizedClient (s) in a database. R2dbcReactiveOAuth2AuthorizedClientService depends on the table definition described in OAuth 2.0 Client Schema(../../../servlet/appendix/database-schema.html#dbschema-oauth2-client) . ReactiveOAuth2AuthorizedClientManager / ReactiveOAuth2AuthorizedClientProvider: The ReactiveOAuth2AuthorizedClientManager is responsible for the overall management of OAuth2AuthorizedClient (s). The primary responsibilities include: Authorizing (or re-authorizing) an OAuth 2.0 Client, using a ReactiveOAuth2AuthorizedClientProvider . Delegating the persistence of an OAuth2AuthorizedClient , typically using a ReactiveOAuth2AuthorizedClientService or ServerOAuth2AuthorizedClientRepository . Delegating to a ReactiveOAuth2AuthorizationSuccessHandler when an OAuth 2.0 Client has been successfully authorized (or re-authorized). Delegating to a ReactiveOAuth2AuthorizationFailureHandler when an OAuth 2.0 Client fails to authorize (or re-authorize). A ReactiveOAuth2AuthorizedClientProvider implements a strategy for authorizing (or re-authorizing) an OAuth 2.0 Client. Implementations will typically implement an authorization grant type, eg. authorization_code , client_credentials , etc. The default implementation of ReactiveOAuth2AuthorizedClientManager is DefaultReactiveOAuth2AuthorizedClientManager , which is associated with a ReactiveOAuth2AuthorizedClientProvider that may support multiple authorization grant types using a delegation-based composite. The ReactiveOAuth2AuthorizedClientProviderBuilder may be used to configure and build the delegation-based composite. The following code shows an example of how to configure and build a ReactiveOAuth2AuthorizedClientProvider composite that provides support for the authorization_code , refresh_token , client_credentials and password authorization grant types: Java Kotlin @Bean public ReactiveOAuth2AuthorizedClientManager authorizedClientManager( ReactiveClientRegistrationRepository clientRegistrationRepository, ServerOAuth2AuthorizedClientRepository authorizedClientRepository) { ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken() .clientCredentials() .password() .build(); DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager = new DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean fun authorizedClientManager( clientRegistrationRepository: ReactiveClientRegistrationRepository, authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager { val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken() .clientCredentials() .password() .build() val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } When an authorization attempt succeeds, the DefaultReactiveOAuth2AuthorizedClientManager will delegate to the ReactiveOAuth2AuthorizationSuccessHandler , which (by default) will save the OAuth2AuthorizedClient via the ServerOAuth2AuthorizedClientRepository . In the case of a re-authorization failure, eg. a refresh token is no longer valid, the previously saved OAuth2AuthorizedClient will be removed from the ServerOAuth2AuthorizedClientRepository via the RemoveAuthorizedClientReactiveOAuth2AuthorizationFailureHandler . The default behaviour may be customized via setAuthorizationSuccessHandler(ReactiveOAuth2AuthorizationSuccessHandler) and setAuthorizationFailureHandler(ReactiveOAuth2AuthorizationFailureHandler) . The DefaultReactiveOAuth2AuthorizedClientManager is also associated with a contextAttributesMapper of type Function<OAuth2AuthorizeRequest, Mono<Map<String, Object>>> , which is responsible for mapping attribute(s) from the OAuth2AuthorizeRequest to a Map of attributes to be associated to the OAuth2AuthorizationContext . This can be useful when you need to supply a ReactiveOAuth2AuthorizedClientProvider with required (supported) attribute(s), eg. the PasswordReactiveOAuth2AuthorizedClientProvider requires the resource owner’s username and password to be available in OAuth2AuthorizationContext.getAttributes() . The following code shows an example of the contextAttributesMapper : Java Kotlin @Bean public ReactiveOAuth2AuthorizedClientManager authorizedClientManager( ReactiveClientRegistrationRepository clientRegistrationRepository, ServerOAuth2AuthorizedClientRepository authorizedClientRepository) { ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .password() .refreshToken() .build(); DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager = new DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); // Assuming the `username` and `password` are supplied as `ServerHttpRequest` parameters, // map the `ServerHttpRequest` parameters to `OAuth2AuthorizationContext.getAttributes()` authorizedClientManager.setContextAttributesMapper(contextAttributesMapper()); return authorizedClientManager; } private Function<OAuth2AuthorizeRequest, Mono<Map<String, Object>>> contextAttributesMapper() { return authorizeRequest -> { Map<String, Object> contextAttributes = Collections.emptyMap(); ServerWebExchange exchange = authorizeRequest.getAttribute(ServerWebExchange.class.getName()); ServerHttpRequest request = exchange.getRequest(); String username = request.getQueryParams().getFirst(OAuth2ParameterNames.USERNAME); String password = request.getQueryParams().getFirst(OAuth2ParameterNames.PASSWORD); if (StringUtils.hasText(username) && StringUtils.hasText(password)) { contextAttributes = new HashMap<>(); // `PasswordReactiveOAuth2AuthorizedClientProvider` requires both attributes contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username); contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password); } return Mono.just(contextAttributes); }; } @Bean fun authorizedClientManager( clientRegistrationRepository: ReactiveClientRegistrationRepository, authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager { val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .password() .refreshToken() .build() val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) // Assuming the `username` and `password` are supplied as `ServerHttpRequest` parameters, // map the `ServerHttpRequest` parameters to `OAuth2AuthorizationContext.getAttributes()` authorizedClientManager.setContextAttributesMapper(contextAttributesMapper()) return authorizedClientManager } private fun contextAttributesMapper(): Function<OAuth2AuthorizeRequest, Mono<MutableMap<String, Any>>> { return Function { authorizeRequest -> var contextAttributes: MutableMap<String, Any> = mutableMapOf() val exchange: ServerWebExchange = authorizeRequest.getAttribute(ServerWebExchange::class.java.name)!! val request: ServerHttpRequest = exchange.request val username: String? = request.queryParams.getFirst(OAuth2ParameterNames.USERNAME) val password: String? = request.queryParams.getFirst(OAuth2ParameterNames.PASSWORD) if (StringUtils.hasText(username) && StringUtils.hasText(password)) { contextAttributes = hashMapOf() // `PasswordReactiveOAuth2AuthorizedClientProvider` requires both attributes contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username!! contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password!! } Mono.just(contextAttributes) } } The DefaultReactiveOAuth2AuthorizedClientManager is designed to be used within the context of a ServerWebExchange . When operating outside of a ServerWebExchange context, use AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager instead. A service application is a common use case for when to use an AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager . Service applications often run in the background, without any user interaction, and typically run under a system-level account instead of a user account. An OAuth 2.0 Client configured with the client_credentials grant type can be considered a type of service application. The following code shows an example of how to configure an AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager that provides support for the client_credentials grant type: Java Kotlin @Bean public ReactiveOAuth2AuthorizedClientManager authorizedClientManager( ReactiveClientRegistrationRepository clientRegistrationRepository, ReactiveOAuth2AuthorizedClientService authorizedClientService) { ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .clientCredentials() .build(); AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager authorizedClientManager = new AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientService); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean fun authorizedClientManager( clientRegistrationRepository: ReactiveClientRegistrationRepository, authorizedClientService: ReactiveOAuth2AuthorizedClientService): ReactiveOAuth2AuthorizedClientManager { val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .clientCredentials() .build() val authorizedClientManager = AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientService) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager }"
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/client/authorization-grants.html","Authorization Grant Support: Authorization Code: Please refer to the OAuth 2.0 Authorization Framework for further details on the Authorization Code(https://tools.ietf.org/html/rfc6749#section-1.3.1) grant. Obtaining Authorization: Please refer to the Authorization Request/Response(https://tools.ietf.org/html/rfc6749#section-4.1.1) protocol flow for the Authorization Code grant. Initiating the Authorization Request: The OAuth2AuthorizationRequestRedirectWebFilter uses a ServerOAuth2AuthorizationRequestResolver to resolve an OAuth2AuthorizationRequest and initiate the Authorization Code grant flow by redirecting the end-user’s user-agent to the Authorization Server’s Authorization Endpoint. The primary role of the ServerOAuth2AuthorizationRequestResolver is to resolve an OAuth2AuthorizationRequest from the provided web request. The default implementation DefaultServerOAuth2AuthorizationRequestResolver matches on the (default) path /oauth2/authorization/{registrationId} extracting the registrationId and using it to build the OAuth2AuthorizationRequest for the associated ClientRegistration . Given the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret authorization-grant-type: authorization_code redirect-uri: ""{baseUrl}/authorized/okta"" scope: read, write provider: okta: authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token A request with the base path /oauth2/authorization/okta will initiate the Authorization Request redirect by the OAuth2AuthorizationRequestRedirectWebFilter and ultimately start the Authorization Code grant flow. The AuthorizationCodeReactiveOAuth2AuthorizedClientProvider is an implementation of ReactiveOAuth2AuthorizedClientProvider for the Authorization Code grant, which also initiates the Authorization Request redirect by the OAuth2AuthorizationRequestRedirectWebFilter . If the OAuth 2.0 Client is a Public Client(https://tools.ietf.org/html/rfc6749#section-2.1) , then configure the OAuth 2.0 Client registration as follows: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-authentication-method: none authorization-grant-type: authorization_code redirect-uri: ""{baseUrl}/authorized/okta"" ... Public Clients are supported using Proof Key for Code Exchange(https://tools.ietf.org/html/rfc7636) (PKCE). If the client is running in an untrusted environment (eg. native application or web browser-based application) and therefore incapable of maintaining the confidentiality of it’s credentials, PKCE will automatically be used when the following conditions are true: client-secret is omitted (or empty) client-authentication-method is set to ""none"" ( ClientAuthenticationMethod.NONE ) If the OAuth 2.0 Provider supports PKCE for Confidential Clients(https://tools.ietf.org/html/rfc6749#section-2.1) , you may (optionally) configure it using DefaultServerOAuth2AuthorizationRequestResolver.setAuthorizationRequestCustomizer(OAuth2AuthorizationRequestCustomizers.withPkce()) . The DefaultServerOAuth2AuthorizationRequestResolver also supports URI template variables for the redirect-uri using UriComponentsBuilder . The following configuration uses all the supported URI template variables: spring: security: oauth2: client: registration: okta: ... redirect-uri: ""{baseScheme}://{baseHost}{basePort}{basePath}/authorized/{registrationId}"" ... {baseUrl} resolves to {baseScheme}://{baseHost}{basePort}{basePath} Configuring the redirect-uri with URI template variables is especially useful when the OAuth 2.0 Client is running behind a Proxy Server(../../../features/exploits/http.html#http-proxy-server) . This ensures that the X-Forwarded-* headers are used when expanding the redirect-uri . Customizing the Authorization Request: One of the primary use cases a ServerOAuth2AuthorizationRequestResolver can realize is the ability to customize the Authorization Request with additional parameters above the standard parameters defined in the OAuth 2.0 Authorization Framework. For example, OpenID Connect defines additional OAuth 2.0 request parameters for the Authorization Code Flow(https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) extending from the standard parameters defined in the OAuth 2.0 Authorization Framework(https://tools.ietf.org/html/rfc6749#section-4.1.1) . One of those extended parameters is the prompt parameter. The prompt parameter is optional. Space delimited, case sensitive list of ASCII string values that specifies whether the Authorization Server prompts the End-User for re-authentication and consent. The defined values are: none , login , consent , and select_account . The following example shows how to configure the DefaultServerOAuth2AuthorizationRequestResolver with a Consumer<OAuth2AuthorizationRequest.Builder> that customizes the Authorization Request for oauth2Login() , by including the request parameter prompt=consent . Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2LoginSecurityConfig { @Autowired private ReactiveClientRegistrationRepository clientRegistrationRepository; @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .authorizeExchange(authorize -> authorize .anyExchange().authenticated() ) .oauth2Login(oauth2 -> oauth2 .authorizationRequestResolver( authorizationRequestResolver(this.clientRegistrationRepository) ) ); return http.build(); } private ServerOAuth2AuthorizationRequestResolver authorizationRequestResolver( ReactiveClientRegistrationRepository clientRegistrationRepository) { DefaultServerOAuth2AuthorizationRequestResolver authorizationRequestResolver = new DefaultServerOAuth2AuthorizationRequestResolver( clientRegistrationRepository); authorizationRequestResolver.setAuthorizationRequestCustomizer( authorizationRequestCustomizer()); return authorizationRequestResolver; } private Consumer<OAuth2AuthorizationRequest.Builder> authorizationRequestCustomizer() { return customizer -> customizer .additionalParameters(params -> params.put(""prompt"", ""consent"")); } } @Configuration @EnableWebFluxSecurity class SecurityConfig { @Autowired private lateinit var customClientRegistrationRepository: ReactiveClientRegistrationRepository @Bean fun securityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2Login { authorizationRequestResolver = authorizationRequestResolver(customClientRegistrationRepository) } } return http.build() } private fun authorizationRequestResolver( clientRegistrationRepository: ReactiveClientRegistrationRepository): ServerOAuth2AuthorizationRequestResolver { val authorizationRequestResolver = DefaultServerOAuth2AuthorizationRequestResolver( clientRegistrationRepository) authorizationRequestResolver.setAuthorizationRequestCustomizer( authorizationRequestCustomizer()) return authorizationRequestResolver } private fun authorizationRequestCustomizer(): Consumer<OAuth2AuthorizationRequest.Builder> { return Consumer { customizer -> customizer .additionalParameters { params -> params[""prompt""] = ""consent"" } } } } For the simple use case, where the additional request parameter is always the same for a specific provider, it may be added directly in the authorization-uri property. For example, if the value for the request parameter prompt is always consent for the provider okta , than simply configure as follows: spring: security: oauth2: client: provider: okta: authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize?prompt=consent The preceding example shows the common use case of adding a custom parameter on top of the standard parameters. Alternatively, if your requirements are more advanced, you can take full control in building the Authorization Request URI by simply overriding the OAuth2AuthorizationRequest.authorizationRequestUri property. OAuth2AuthorizationRequest.Builder.build() constructs the OAuth2AuthorizationRequest.authorizationRequestUri , which represents the Authorization Request URI including all query parameters using the application/x-www-form-urlencoded format. The following example shows a variation of authorizationRequestCustomizer() from the preceding example, and instead overrides the OAuth2AuthorizationRequest.authorizationRequestUri property. Java Kotlin private Consumer<OAuth2AuthorizationRequest.Builder> authorizationRequestCustomizer() { return customizer -> customizer .authorizationRequestUri(uriBuilder -> uriBuilder .queryParam(""prompt"", ""consent"").build()); } private fun authorizationRequestCustomizer(): Consumer<OAuth2AuthorizationRequest.Builder> { return Consumer { customizer: OAuth2AuthorizationRequest.Builder -> customizer .authorizationRequestUri { uriBuilder: UriBuilder -> uriBuilder .queryParam(""prompt"", ""consent"").build() } } } Storing the Authorization Request: The ServerAuthorizationRequestRepository is responsible for the persistence of the OAuth2AuthorizationRequest from the time the Authorization Request is initiated to the time the Authorization Response is received (the callback). The OAuth2AuthorizationRequest is used to correlate and validate the Authorization Response. The default implementation of ServerAuthorizationRequestRepository is WebSessionOAuth2ServerAuthorizationRequestRepository , which stores the OAuth2AuthorizationRequest in the WebSession . If you have a custom implementation of ServerAuthorizationRequestRepository , you may configure it as shown in the following example: ServerAuthorizationRequestRepository Configuration Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2ClientSecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .oauth2Client(oauth2 -> oauth2 .authorizationRequestRepository(this.authorizationRequestRepository()) ... ); return http.build(); } } @Configuration @EnableWebFluxSecurity class OAuth2ClientSecurityConfig { @Bean fun securityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { oauth2Client { authorizationRequestRepository = authorizationRequestRepository() } } return http.build() } } Requesting an Access Token: Please refer to the Access Token Request/Response(https://tools.ietf.org/html/rfc6749#section-4.1.3) protocol flow for the Authorization Code grant. The default implementation of ReactiveOAuth2AccessTokenResponseClient for the Authorization Code grant is WebClientReactiveAuthorizationCodeTokenResponseClient , which uses a WebClient for exchanging an authorization code for an access token at the Authorization Server’s Token Endpoint. The WebClientReactiveAuthorizationCodeTokenResponseClient is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response. Customizing the Access Token Request: If you need to customize the pre-processing of the Token Request, you can provide WebClientReactiveAuthorizationCodeTokenResponseClient.setParametersConverter() with a custom Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> . The default implementation builds a MultiValueMap<String, String> containing only the grant_type parameter of a standard OAuth 2.0 Access Token Request(https://tools.ietf.org/html/rfc6749#section-4.1.3) which is used to construct the request. Other parameters required by the Authorization Code grant are added directly to the body of the request by the WebClientReactiveAuthorizationCodeTokenResponseClient . However, providing a custom Converter , would allow you to extend the standard Token Request and add custom parameter(s). If you prefer to only add additional parameters, you can instead provide WebClientReactiveAuthorizationCodeTokenResponseClient.addParametersConverter() with a custom Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> which constructs an aggregate Converter . The custom Converter must return valid parameters of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider. Customizing the Access Token Response: On the other end, if you need to customize the post-handling of the Token Response, you will need to provide WebClientReactiveAuthorizationCodeTokenResponseClient.setBodyExtractor() with a custom configured BodyExtractor<Mono<OAuth2AccessTokenResponse>, ReactiveHttpInputMessage> that is used for converting the OAuth 2.0 Access Token Response to an OAuth2AccessTokenResponse . The default implementation provided by OAuth2BodyExtractors.oauth2AccessTokenResponse() parses the response and handles errors accordingly. Customizing the WebClient: Alternatively, if your requirements are more advanced, you can take full control of the request/response by simply providing WebClientReactiveAuthorizationCodeTokenResponseClient.setWebClient() with a custom configured WebClient . Whether you customize WebClientReactiveAuthorizationCodeTokenResponseClient or provide your own implementation of ReactiveOAuth2AccessTokenResponseClient , you’ll need to configure it as shown in the following example: Access Token Response Configuration Java Kotlin @Configuration @EnableWebFluxSecurity public class OAuth2ClientSecurityConfig { @Bean public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) { http .oauth2Client(oauth2 -> oauth2 .authenticationManager(this.authorizationCodeAuthenticationManager()) ... ); return http.build(); } private ReactiveAuthenticationManager authorizationCodeAuthenticationManager() { WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient = new WebClientReactiveAuthorizationCodeTokenResponseClient(); ... return new OAuth2AuthorizationCodeReactiveAuthenticationManager(accessTokenResponseClient); } } @Configuration @EnableWebFluxSecurity class OAuth2ClientSecurityConfig { @Bean fun securityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http { oauth2Client { authenticationManager = authorizationCodeAuthenticationManager() } } return http.build() } private fun authorizationCodeAuthenticationManager(): ReactiveAuthenticationManager { val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient() ... return OAuth2AuthorizationCodeReactiveAuthenticationManager(accessTokenResponseClient) } } Refresh Token: Please refer to the OAuth 2.0 Authorization Framework for further details on the Refresh Token(https://tools.ietf.org/html/rfc6749#section-1.5) . Refreshing an Access Token: Please refer to the Access Token Request/Response(https://tools.ietf.org/html/rfc6749#section-6) protocol flow for the Refresh Token grant. The default implementation of ReactiveOAuth2AccessTokenResponseClient for the Refresh Token grant is WebClientReactiveRefreshTokenTokenResponseClient , which uses a WebClient when refreshing an access token at the Authorization Server’s Token Endpoint. The WebClientReactiveRefreshTokenTokenResponseClient is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response. Customizing the Access Token Request: If you need to customize the pre-processing of the Token Request, you can provide WebClientReactiveRefreshTokenTokenResponseClient.setParametersConverter() with a custom Converter<OAuth2RefreshTokenGrantRequest, MultiValueMap<String, String>> . The default implementation builds a MultiValueMap<String, String> containing only the grant_type parameter of a standard OAuth 2.0 Access Token Request(https://tools.ietf.org/html/rfc6749#section-6) which is used to construct the request. Other parameters required by the Refresh Token grant are added directly to the body of the request by the WebClientReactiveRefreshTokenTokenResponseClient . However, providing a custom Converter , would allow you to extend the standard Token Request and add custom parameter(s). If you prefer to only add additional parameters, you can instead provide WebClientReactiveRefreshTokenTokenResponseClient.addParametersConverter() with a custom Converter<OAuth2RefreshTokenGrantRequest, MultiValueMap<String, String>> which constructs an aggregate Converter . The custom Converter must return valid parameters of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider. Customizing the Access Token Response: On the other end, if you need to customize the post-handling of the Token Response, you will need to provide WebClientReactiveRefreshTokenTokenResponseClient.setBodyExtractor() with a custom configured BodyExtractor<Mono<OAuth2AccessTokenResponse>, ReactiveHttpInputMessage> that is used for converting the OAuth 2.0 Access Token Response to an OAuth2AccessTokenResponse . The default implementation provided by OAuth2BodyExtractors.oauth2AccessTokenResponse() parses the response and handles errors accordingly. Customizing the WebClient: Alternatively, if your requirements are more advanced, you can take full control of the request/response by simply providing WebClientReactiveRefreshTokenTokenResponseClient.setWebClient() with a custom configured WebClient . Whether you customize WebClientReactiveRefreshTokenTokenResponseClient or provide your own implementation of ReactiveOAuth2AccessTokenResponseClient , you’ll need to configure it as shown in the following example: Access Token Response Configuration Java Kotlin // Customize ReactiveOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> refreshTokenTokenResponseClient = ... ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken(configurer -> configurer.accessTokenResponseClient(refreshTokenTokenResponseClient)) .build(); ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); // Customize val refreshTokenTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> = ... val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .authorizationCode() .refreshToken { it.accessTokenResponseClient(refreshTokenTokenResponseClient) } .build() ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) ReactiveOAuth2AuthorizedClientProviderBuilder.builder().refreshToken() configures a RefreshTokenReactiveOAuth2AuthorizedClientProvider , which is an implementation of a ReactiveOAuth2AuthorizedClientProvider for the Refresh Token grant. The OAuth2RefreshToken may optionally be returned in the Access Token Response for the authorization_code and password grant types. If the OAuth2AuthorizedClient.getRefreshToken() is available and the OAuth2AuthorizedClient.getAccessToken() is expired, it will automatically be refreshed by the RefreshTokenReactiveOAuth2AuthorizedClientProvider . Client Credentials: Please refer to the OAuth 2.0 Authorization Framework for further details on the Client Credentials(https://tools.ietf.org/html/rfc6749#section-1.3.4) grant. Requesting an Access Token: Please refer to the Access Token Request/Response(https://tools.ietf.org/html/rfc6749#section-4.4.2) protocol flow for the Client Credentials grant. The default implementation of ReactiveOAuth2AccessTokenResponseClient for the Client Credentials grant is WebClientReactiveClientCredentialsTokenResponseClient , which uses a WebClient when requesting an access token at the Authorization Server’s Token Endpoint. The WebClientReactiveClientCredentialsTokenResponseClient is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response. Customizing the Access Token Request: If you need to customize the pre-processing of the Token Request, you can provide WebClientReactiveClientCredentialsTokenResponseClient.setParametersConverter() with a custom Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> . The default implementation builds a MultiValueMap<String, String> containing only the grant_type parameter of a standard OAuth 2.0 Access Token Request(https://tools.ietf.org/html/rfc6749#section-4.4.2) which is used to construct the request. Other parameters required by the Client Credentials grant are added directly to the body of the request by the WebClientReactiveClientCredentialsTokenResponseClient . However, providing a custom Converter , would allow you to extend the standard Token Request and add custom parameter(s). If you prefer to only add additional parameters, you can instead provide WebClientReactiveClientCredentialsTokenResponseClient.addParametersConverter() with a custom Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> which constructs an aggregate Converter . The custom Converter must return valid parameters of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider. Customizing the Access Token Response: On the other end, if you need to customize the post-handling of the Token Response, you will need to provide WebClientReactiveClientCredentialsTokenResponseClient.setBodyExtractor() with a custom configured BodyExtractor<Mono<OAuth2AccessTokenResponse>, ReactiveHttpInputMessage> that is used for converting the OAuth 2.0 Access Token Response to an OAuth2AccessTokenResponse . The default implementation provided by OAuth2BodyExtractors.oauth2AccessTokenResponse() parses the response and handles errors accordingly. Customizing the WebClient: Alternatively, if your requirements are more advanced, you can take full control of the request/response by simply providing WebClientReactiveClientCredentialsTokenResponseClient.setWebClient() with a custom configured WebClient . Whether you customize WebClientReactiveClientCredentialsTokenResponseClient or provide your own implementation of ReactiveOAuth2AccessTokenResponseClient , you’ll need to configure it as shown in the following example: Java Kotlin // Customize ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsTokenResponseClient = ... ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .clientCredentials(configurer -> configurer.accessTokenResponseClient(clientCredentialsTokenResponseClient)) .build(); ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); // Customize val clientCredentialsTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> = ... val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .clientCredentials { it.accessTokenResponseClient(clientCredentialsTokenResponseClient) } .build() ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) ReactiveOAuth2AuthorizedClientProviderBuilder.builder().clientCredentials() configures a ClientCredentialsReactiveOAuth2AuthorizedClientProvider , which is an implementation of a ReactiveOAuth2AuthorizedClientProvider for the Client Credentials grant. Using the Access Token: Given the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret authorization-grant-type: client_credentials scope: read, write provider: okta: token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token …​and the ReactiveOAuth2AuthorizedClientManager @Bean : Java Kotlin @Bean public ReactiveOAuth2AuthorizedClientManager authorizedClientManager( ReactiveClientRegistrationRepository clientRegistrationRepository, ServerOAuth2AuthorizedClientRepository authorizedClientRepository) { ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .clientCredentials() .build(); DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager = new DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean fun authorizedClientManager( clientRegistrationRepository: ReactiveClientRegistrationRepository, authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager { val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .clientCredentials() .build() val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } You may obtain the OAuth2AccessToken as follows: Java Kotlin @Controller public class OAuth2ClientController { @Autowired private ReactiveOAuth2AuthorizedClientManager authorizedClientManager; @GetMapping(""/"") public Mono<String> index(Authentication authentication, ServerWebExchange exchange) { OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(authentication) .attribute(ServerWebExchange.class.getName(), exchange) .build(); return this.authorizedClientManager.authorize(authorizeRequest) .map(OAuth2AuthorizedClient::getAccessToken) ... .thenReturn(""index""); } } class OAuth2ClientController { @Autowired private lateinit var authorizedClientManager: ReactiveOAuth2AuthorizedClientManager @GetMapping(""/"") fun index(authentication: Authentication, exchange: ServerWebExchange): Mono<String> { val authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(authentication) .attribute(ServerWebExchange::class.java.name, exchange) .build() return authorizedClientManager.authorize(authorizeRequest) .map { it.accessToken } ... .thenReturn(""index"") } } ServerWebExchange is an OPTIONAL attribute. If not provided, it will be obtained from the Reactor’s Context(https://projectreactor.io/docs/core/release/reference/#context) via the key ServerWebExchange.class . Resource Owner Password Credentials: Please refer to the OAuth 2.0 Authorization Framework for further details on the Resource Owner Password Credentials(https://tools.ietf.org/html/rfc6749#section-1.3.3) grant. Requesting an Access Token: Please refer to the Access Token Request/Response(https://tools.ietf.org/html/rfc6749#section-4.3.2) protocol flow for the Resource Owner Password Credentials grant. The default implementation of ReactiveOAuth2AccessTokenResponseClient for the Resource Owner Password Credentials grant is WebClientReactivePasswordTokenResponseClient , which uses a WebClient when requesting an access token at the Authorization Server’s Token Endpoint. The WebClientReactivePasswordTokenResponseClient is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response. Customizing the Access Token Request: If you need to customize the pre-processing of the Token Request, you can provide WebClientReactivePasswordTokenResponseClient.setParametersConverter() with a custom Converter<OAuth2PasswordGrantRequest, MultiValueMap<String, String>> . The default implementation builds a MultiValueMap<String, String> containing only the grant_type parameter of a standard OAuth 2.0 Access Token Request(https://tools.ietf.org/html/rfc6749#section-4.4.2) which is used to construct the request. Other parameters required by the Resource Owner Password Credentials grant are added directly to the body of the request by the WebClientReactivePasswordTokenResponseClient . However, providing a custom Converter , would allow you to extend the standard Token Request and add custom parameter(s). If you prefer to only add additional parameters, you can instead provide WebClientReactivePasswordTokenResponseClient.addParametersConverter() with a custom Converter<OAuth2PasswordGrantRequest, MultiValueMap<String, String>> which constructs an aggregate Converter . The custom Converter must return valid parameters of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider. Customizing the Access Token Response: On the other end, if you need to customize the post-handling of the Token Response, you will need to provide WebClientReactivePasswordTokenResponseClient.setBodyExtractor() with a custom configured BodyExtractor<Mono<OAuth2AccessTokenResponse>, ReactiveHttpInputMessage> that is used for converting the OAuth 2.0 Access Token Response to an OAuth2AccessTokenResponse . The default implementation provided by OAuth2BodyExtractors.oauth2AccessTokenResponse() parses the response and handles errors accordingly. Customizing the WebClient: Alternatively, if your requirements are more advanced, you can take full control of the request/response by simply providing WebClientReactivePasswordTokenResponseClient.setWebClient() with a custom configured WebClient . Whether you customize WebClientReactivePasswordTokenResponseClient or provide your own implementation of ReactiveOAuth2AccessTokenResponseClient , you’ll need to configure it as shown in the following example: Java Kotlin // Customize ReactiveOAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> passwordTokenResponseClient = ... ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .password(configurer -> configurer.accessTokenResponseClient(passwordTokenResponseClient)) .refreshToken() .build(); ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); val passwordTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> = ... val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .password { it.accessTokenResponseClient(passwordTokenResponseClient) } .refreshToken() .build() ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) ReactiveOAuth2AuthorizedClientProviderBuilder.builder().password() configures a PasswordReactiveOAuth2AuthorizedClientProvider , which is an implementation of a ReactiveOAuth2AuthorizedClientProvider for the Resource Owner Password Credentials grant. Using the Access Token: Given the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret authorization-grant-type: password scope: read, write provider: okta: token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token …​and the ReactiveOAuth2AuthorizedClientManager @Bean : Java Kotlin @Bean public ReactiveOAuth2AuthorizedClientManager authorizedClientManager( ReactiveClientRegistrationRepository clientRegistrationRepository, ServerOAuth2AuthorizedClientRepository authorizedClientRepository) { ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .password() .refreshToken() .build(); DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager = new DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); // Assuming the `username` and `password` are supplied as `ServerHttpRequest` parameters, // map the `ServerHttpRequest` parameters to `OAuth2AuthorizationContext.getAttributes()` authorizedClientManager.setContextAttributesMapper(contextAttributesMapper()); return authorizedClientManager; } private Function<OAuth2AuthorizeRequest, Mono<Map<String, Object>>> contextAttributesMapper() { return authorizeRequest -> { Map<String, Object> contextAttributes = Collections.emptyMap(); ServerWebExchange exchange = authorizeRequest.getAttribute(ServerWebExchange.class.getName()); ServerHttpRequest request = exchange.getRequest(); String username = request.getQueryParams().getFirst(OAuth2ParameterNames.USERNAME); String password = request.getQueryParams().getFirst(OAuth2ParameterNames.PASSWORD); if (StringUtils.hasText(username) && StringUtils.hasText(password)) { contextAttributes = new HashMap<>(); // `PasswordReactiveOAuth2AuthorizedClientProvider` requires both attributes contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username); contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password); } return Mono.just(contextAttributes); }; } @Bean fun authorizedClientManager( clientRegistrationRepository: ReactiveClientRegistrationRepository, authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager { val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .password() .refreshToken() .build() val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) // Assuming the `username` and `password` are supplied as `ServerHttpRequest` parameters, // map the `ServerHttpRequest` parameters to `OAuth2AuthorizationContext.getAttributes()` authorizedClientManager.setContextAttributesMapper(contextAttributesMapper()) return authorizedClientManager } private fun contextAttributesMapper(): Function<OAuth2AuthorizeRequest, Mono<MutableMap<String, Any>>> { return Function { authorizeRequest -> var contextAttributes: MutableMap<String, Any> = mutableMapOf() val exchange: ServerWebExchange = authorizeRequest.getAttribute(ServerWebExchange::class.java.name)!! val request: ServerHttpRequest = exchange.request val username: String? = request.queryParams.getFirst(OAuth2ParameterNames.USERNAME) val password: String? = request.queryParams.getFirst(OAuth2ParameterNames.PASSWORD) if (StringUtils.hasText(username) && StringUtils.hasText(password)) { contextAttributes = hashMapOf() // `PasswordReactiveOAuth2AuthorizedClientProvider` requires both attributes contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username!! contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password!! } Mono.just(contextAttributes) } } You may obtain the OAuth2AccessToken as follows: Java Kotlin @Controller public class OAuth2ClientController { @Autowired private ReactiveOAuth2AuthorizedClientManager authorizedClientManager; @GetMapping(""/"") public Mono<String> index(Authentication authentication, ServerWebExchange exchange) { OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(authentication) .attribute(ServerWebExchange.class.getName(), exchange) .build(); return this.authorizedClientManager.authorize(authorizeRequest) .map(OAuth2AuthorizedClient::getAccessToken) ... .thenReturn(""index""); } } @Controller class OAuth2ClientController { @Autowired private lateinit var authorizedClientManager: ReactiveOAuth2AuthorizedClientManager @GetMapping(""/"") fun index(authentication: Authentication, exchange: ServerWebExchange): Mono<String> { val authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(authentication) .attribute(ServerWebExchange::class.java.name, exchange) .build() return authorizedClientManager.authorize(authorizeRequest) .map { it.accessToken } ... .thenReturn(""index"") } } ServerWebExchange is an OPTIONAL attribute. If not provided, it will be obtained from the Reactor’s Context(https://projectreactor.io/docs/core/release/reference/#context) via the key ServerWebExchange.class . JWT Bearer: Please refer to JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants for further details on the JWT Bearer(https://datatracker.ietf.org/doc/html/rfc7523) grant. Requesting an Access Token: Please refer to the Access Token Request/Response(https://datatracker.ietf.org/doc/html/rfc7523#section-2.1) protocol flow for the JWT Bearer grant. The default implementation of ReactiveOAuth2AccessTokenResponseClient for the JWT Bearer grant is WebClientReactiveJwtBearerTokenResponseClient , which uses a WebClient when requesting an access token at the Authorization Server’s Token Endpoint. The WebClientReactiveJwtBearerTokenResponseClient is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response. Customizing the Access Token Request: If you need to customize the pre-processing of the Token Request, you can provide WebClientReactiveJwtBearerTokenResponseClient.setParametersConverter() with a custom Converter<JwtBearerGrantRequest, MultiValueMap<String, String>> . The default implementation builds a MultiValueMap<String, String> containing only the grant_type parameter of a standard OAuth 2.0 Access Token Request(https://tools.ietf.org/html/rfc6749#section-4.4.2) which is used to construct the request. Other parameters required by the JWT Bearer grant are added directly to the body of the request by the WebClientReactiveJwtBearerTokenResponseClient . However, providing a custom Converter , would allow you to extend the standard Token Request and add custom parameter(s). If you prefer to only add additional parameters, you can instead provide WebClientReactiveJwtBearerTokenResponseClient.addParametersConverter() with a custom Converter<JwtBearerGrantRequest, MultiValueMap<String, String>> which constructs an aggregate Converter . The custom Converter must return valid parameters of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider. Customizing the Access Token Response: On the other end, if you need to customize the post-handling of the Token Response, you will need to provide WebClientReactiveJwtBearerTokenResponseClient.setBodyExtractor() with a custom configured BodyExtractor<Mono<OAuth2AccessTokenResponse>, ReactiveHttpInputMessage> that is used for converting the OAuth 2.0 Access Token Response to an OAuth2AccessTokenResponse . The default implementation provided by OAuth2BodyExtractors.oauth2AccessTokenResponse() parses the response and handles errors accordingly. Customizing the WebClient: Alternatively, if your requirements are more advanced, you can take full control of the request/response by simply providing WebClientReactiveJwtBearerTokenResponseClient.setWebClient() with a custom configured WebClient . Whether you customize WebClientReactiveJwtBearerTokenResponseClient or provide your own implementation of ReactiveOAuth2AccessTokenResponseClient , you’ll need to configure it as shown in the following example: Java Kotlin // Customize ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> jwtBearerTokenResponseClient = ... JwtBearerReactiveOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider = new JwtBearerReactiveOAuth2AuthorizedClientProvider(); jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient); ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .provider(jwtBearerAuthorizedClientProvider) .build(); ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); // Customize val jwtBearerTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> = ... val jwtBearerAuthorizedClientProvider = JwtBearerReactiveOAuth2AuthorizedClientProvider() jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient) val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .provider(jwtBearerAuthorizedClientProvider) .build() ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) Using the Access Token: Given the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret authorization-grant-type: urn:ietf:params:oauth:grant-type:jwt-bearer scope: read provider: okta: token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token …​and the OAuth2AuthorizedClientManager @Bean : Java Kotlin @Bean public ReactiveOAuth2AuthorizedClientManager authorizedClientManager( ReactiveClientRegistrationRepository clientRegistrationRepository, ServerOAuth2AuthorizedClientRepository authorizedClientRepository) { JwtBearerReactiveOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider = new JwtBearerReactiveOAuth2AuthorizedClientProvider(); ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .provider(jwtBearerAuthorizedClientProvider) .build(); DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager = new DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean fun authorizedClientManager( clientRegistrationRepository: ReactiveClientRegistrationRepository, authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager { val jwtBearerAuthorizedClientProvider = JwtBearerReactiveOAuth2AuthorizedClientProvider() val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .provider(jwtBearerAuthorizedClientProvider) .build() val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } You may obtain the OAuth2AccessToken as follows: Java Kotlin @RestController public class OAuth2ResourceServerController { @Autowired private ReactiveOAuth2AuthorizedClientManager authorizedClientManager; @GetMapping(""/resource"") public Mono<String> resource(JwtAuthenticationToken jwtAuthentication, ServerWebExchange exchange) { OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(jwtAuthentication) .build(); return this.authorizedClientManager.authorize(authorizeRequest) .map(OAuth2AuthorizedClient::getAccessToken) ... } } class OAuth2ResourceServerController { @Autowired private lateinit var authorizedClientManager: ReactiveOAuth2AuthorizedClientManager @GetMapping(""/resource"") fun resource(jwtAuthentication: JwtAuthenticationToken, exchange: ServerWebExchange): Mono<String> { val authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(jwtAuthentication) .build() return authorizedClientManager.authorize(authorizeRequest) .map { it.accessToken } ... } } JwtBearerReactiveOAuth2AuthorizedClientProvider resolves the Jwt assertion via OAuth2AuthorizationContext.getPrincipal().getPrincipal() by default, hence the use of JwtAuthenticationToken in the preceding example. If you need to resolve the Jwt assertion from a different source, you can provide JwtBearerReactiveOAuth2AuthorizedClientProvider.setJwtAssertionResolver() with a custom Function<OAuth2AuthorizationContext, Mono<Jwt>> . Token Exchange: Please refer to OAuth 2.0 Token Exchange for further details on the Token Exchange(https://datatracker.ietf.org/doc/html/rfc8693) grant. Requesting an Access Token: Please refer to the Token Exchange Request and Response(https://datatracker.ietf.org/doc/html/rfc8693#section-2) protocol flow for the Token Exchange grant. The default implementation of ReactiveOAuth2AccessTokenResponseClient for the Token Exchange grant is WebClientReactiveTokenExchangeTokenResponseClient , which uses a WebClient when requesting an access token at the Authorization Server’s Token Endpoint. The WebClientReactiveTokenExchangeTokenResponseClient is quite flexible as it allows you to customize the pre-processing of the Token Request and/or post-handling of the Token Response. Customizing the Access Token Request: If you need to customize the pre-processing of the Token Request, you can provide WebClientReactiveTokenExchangeTokenResponseClient.setParametersConverter() with a custom Converter<TokenExchangeGrantRequest, MultiValueMap<String, String>> . The default implementation builds a MultiValueMap<String, String> containing only the grant_type parameter of a standard OAuth 2.0 Access Token Request(https://tools.ietf.org/html/rfc6749#section-4.4.2) which is used to construct the request. Other parameters required by the Token Exchange grant are added directly to the body of the request by the WebClientReactiveTokenExchangeTokenResponseClient . However, providing a custom Converter , would allow you to extend the standard Token Request and add custom parameter(s). If you prefer to only add additional parameters, you can instead provide WebClientReactiveTokenExchangeTokenResponseClient.addParametersConverter() with a custom Converter<TokenExchangeGrantRequest, MultiValueMap<String, String>> which constructs an aggregate Converter . The custom Converter must return valid parameters of an OAuth 2.0 Access Token Request that is understood by the intended OAuth 2.0 Provider. Customizing the Access Token Response: On the other end, if you need to customize the post-handling of the Token Response, you will need to provide WebClientReactiveTokenExchangeTokenResponseClient.setBodyExtractor() with a custom configured BodyExtractor<Mono<OAuth2AccessTokenResponse>, ReactiveHttpInputMessage> that is used for converting the OAuth 2.0 Access Token Response to an OAuth2AccessTokenResponse . The default implementation provided by OAuth2BodyExtractors.oauth2AccessTokenResponse() parses the response and handles errors accordingly. Customizing the WebClient: Alternatively, if your requirements are more advanced, you can take full control of the request/response by simply providing WebClientReactiveTokenExchangeTokenResponseClient.setWebClient() with a custom configured WebClient . Whether you customize WebClientReactiveTokenExchangeTokenResponseClient or provide your own implementation of ReactiveOAuth2AccessTokenResponseClient , you’ll need to configure it as shown in the following example: Java Kotlin // Customize ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> tokenExchangeTokenResponseClient = ... TokenExchangeReactiveOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider = new TokenExchangeReactiveOAuth2AuthorizedClientProvider(); tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeTokenResponseClient); ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .provider(tokenExchangeAuthorizedClientProvider) .build(); ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); // Customize val tokenExchangeTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> = ... val tokenExchangeAuthorizedClientProvider = TokenExchangeReactiveOAuth2AuthorizedClientProvider() tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeTokenResponseClient) val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .provider(tokenExchangeAuthorizedClientProvider) .build() ... authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) Using the Access Token: Given the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret authorization-grant-type: urn:ietf:params:oauth:grant-type:token-exchange scope: read provider: okta: token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token …​and the OAuth2AuthorizedClientManager @Bean : Java Kotlin @Bean public ReactiveOAuth2AuthorizedClientManager authorizedClientManager( ReactiveClientRegistrationRepository clientRegistrationRepository, ServerOAuth2AuthorizedClientRepository authorizedClientRepository) { TokenExchangeReactiveOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider = new TokenExchangeReactiveOAuth2AuthorizedClientProvider(); ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .provider(tokenExchangeAuthorizedClientProvider) .build(); DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager = new DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository); authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider); return authorizedClientManager; } @Bean fun authorizedClientManager( clientRegistrationRepository: ReactiveClientRegistrationRepository, authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager { val tokenExchangeAuthorizedClientProvider = TokenExchangeReactiveOAuth2AuthorizedClientProvider() val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder() .provider(tokenExchangeAuthorizedClientProvider) .build() val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager( clientRegistrationRepository, authorizedClientRepository) authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider) return authorizedClientManager } You may obtain the OAuth2AccessToken as follows: Java Kotlin @RestController public class OAuth2ResourceServerController { @Autowired private ReactiveOAuth2AuthorizedClientManager authorizedClientManager; @GetMapping(""/resource"") public Mono<String> resource(JwtAuthenticationToken jwtAuthentication) { OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(jwtAuthentication) .build(); return this.authorizedClientManager.authorize(authorizeRequest) .map(OAuth2AuthorizedClient::getAccessToken) ... } } class OAuth2ResourceServerController { @Autowired private lateinit var authorizedClientManager: ReactiveOAuth2AuthorizedClientManager @GetMapping(""/resource"") fun resource(jwtAuthentication: JwtAuthenticationToken): Mono<String> { val authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(""okta"") .principal(jwtAuthentication) .build() return authorizedClientManager.authorize(authorizeRequest) .map { it.accessToken } ... } } TokenExchangeReactiveOAuth2AuthorizedClientProvider resolves the subject token (as an OAuth2Token ) via OAuth2AuthorizationContext.getPrincipal().getPrincipal() by default, hence the use of JwtAuthenticationToken in the preceding example. An actor token is not resolved by default. If you need to resolve the subject token from a different source, you can provide TokenExchangeReactiveOAuth2AuthorizedClientProvider.setSubjectTokenResolver() with a custom Function<OAuth2AuthorizationContext, Mono<OAuth2Token>> . If you need to resolve an actor token, you can provide TokenExchangeReactiveOAuth2AuthorizedClientProvider.setActorTokenResolver() with a custom Function<OAuth2AuthorizationContext, Mono<OAuth2Token>> ."
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/client/client-authentication.html","Client Authentication Support: Client Credentials: Authenticate using client_secret_basic: Client Authentication with HTTP Basic is supported out of the box and no customization is necessary to enable it. The default implementation is provided by DefaultOAuth2TokenRequestHeadersConverter . Given the following Spring Boot properties for an OAuth 2.0 client registration: spring: security: oauth2: client: registration: okta: client-id: client-id client-secret: client-secret client-authentication-method: client_secret_basic authorization-grant-type: authorization_code ... The following example shows how to configure WebClientReactiveAuthorizationCodeTokenResponseClient to disable URL encoding of the client credentials: Java Kotlin DefaultOAuth2TokenRequestHeadersConverter<OAuth2AuthorizationCodeGrantRequest> headersConverter = new DefaultOAuth2TokenRequestHeadersConverter<>(); headersConverter.setEncodeClientCredentials(false); WebClientReactiveAuthorizationCodeTokenResponseClient tokenResponseClient = new WebClientReactiveAuthorizationCodeTokenResponseClient(); tokenResponseClient.setHeadersConverter(headersConverter); val headersConverter = DefaultOAuth2TokenRequestHeadersConverter<OAuth2AuthorizationCodeGrantRequest>() headersConverter.setEncodeClientCredentials(false) val tokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient() tokenResponseClient.setHeadersConverter(headersConverter) Authenticate using client_secret_post: Client Authentication with client credentials included in the request-body is supported out of the box and no customization is necessary to enable it. The following Spring Boot properties for an OAuth 2.0 client registration demonstrate the configuration: spring: security: oauth2: client: registration: okta: client-id: client-id client-secret: client-secret client-authentication-method: client_secret_post authorization-grant-type: authorization_code ... JWT Bearer: Please refer to JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants for further details on JWT Bearer(https://datatracker.ietf.org/doc/html/rfc7523#section-2.2) Client Authentication. The default implementation for JWT Bearer Client Authentication is NimbusJwtClientAuthenticationParametersConverter , which is a Converter that customizes the Token Request parameters by adding a signed JSON Web Token (JWS) in the client_assertion parameter. The java.security.PrivateKey or javax.crypto.SecretKey used for signing the JWS is supplied by the com.nimbusds.jose.jwk.JWK resolver associated with NimbusJwtClientAuthenticationParametersConverter . Authenticate using private_key_jwt: Given the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-authentication-method: private_key_jwt authorization-grant-type: authorization_code ... The following example shows how to configure WebClientReactiveAuthorizationCodeTokenResponseClient : Java Kotlin Function<ClientRegistration, JWK> jwkResolver = (clientRegistration) -> { if (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) { // Assuming RSA key type RSAPublicKey publicKey = ... RSAPrivateKey privateKey = ... return new RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build(); } return null; }; WebClientReactiveAuthorizationCodeTokenResponseClient tokenResponseClient = new WebClientReactiveAuthorizationCodeTokenResponseClient(); tokenResponseClient.addParametersConverter( new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver)); val jwkResolver: Function<ClientRegistration, JWK> = Function<ClientRegistration, JWK> { clientRegistration -> if (clientRegistration.clientAuthenticationMethod.equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) { // Assuming RSA key type var publicKey: RSAPublicKey = ... var privateKey: RSAPrivateKey = ... RSAKey.Builder(publicKey) .privateKey(privateKey) .keyID(UUID.randomUUID().toString()) .build() } null } val tokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient() tokenResponseClient.addParametersConverter( NimbusJwtClientAuthenticationParametersConverter(jwkResolver) ) Authenticate using client_secret_jwt: Given the following Spring Boot properties for an OAuth 2.0 Client registration: spring: security: oauth2: client: registration: okta: client-id: okta-client-id client-secret: okta-client-secret client-authentication-method: client_secret_jwt authorization-grant-type: client_credentials ... The following example shows how to configure WebClientReactiveClientCredentialsTokenResponseClient : Java Kotlin Function<ClientRegistration, JWK> jwkResolver = (clientRegistration) -> { if (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.CLIENT_SECRET_JWT)) { SecretKeySpec secretKey = new SecretKeySpec( clientRegistration.getClientSecret().getBytes(StandardCharsets.UTF_8), ""HmacSHA256""); return new OctetSequenceKey.Builder(secretKey) .keyID(UUID.randomUUID().toString()) .build(); } return null; }; WebClientReactiveClientCredentialsTokenResponseClient tokenResponseClient = new WebClientReactiveClientCredentialsTokenResponseClient(); tokenResponseClient.addParametersConverter( new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver)); val jwkResolver = Function<ClientRegistration, JWK?> { clientRegistration: ClientRegistration -> if (clientRegistration.clientAuthenticationMethod == ClientAuthenticationMethod.CLIENT_SECRET_JWT) { val secretKey = SecretKeySpec( clientRegistration.clientSecret.toByteArray(StandardCharsets.UTF_8), ""HmacSHA256"" ) OctetSequenceKey.Builder(secretKey) .keyID(UUID.randomUUID().toString()) .build() } null } val tokenResponseClient = WebClientReactiveClientCredentialsTokenResponseClient() tokenResponseClient.addParametersConverter( NimbusJwtClientAuthenticationParametersConverter(jwkResolver) ) Customizing the JWT assertion: The JWT produced by NimbusJwtClientAuthenticationParametersConverter contains the iss , sub , aud , jti , iat and exp claims by default. You can customize the headers and/or claims by providing a Consumer<NimbusJwtClientAuthenticationParametersConverter.JwtClientAuthenticationContext<T>> to setJwtClientAssertionCustomizer() . The following example shows how to customize claims of the JWT: Java Kotlin Function<ClientRegistration, JWK> jwkResolver = ... NimbusJwtClientAuthenticationParametersConverter<OAuth2ClientCredentialsGrantRequest> converter = new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver); converter.setJwtClientAssertionCustomizer((context) -> { context.getHeaders().header(""custom-header"", ""header-value""); context.getClaims().claim(""custom-claim"", ""claim-value""); }); val jwkResolver = ... val converter: NimbusJwtClientAuthenticationParametersConverter<OAuth2ClientCredentialsGrantRequest> = NimbusJwtClientAuthenticationParametersConverter(jwkResolver) converter.setJwtClientAssertionCustomizer { context -> context.headers.header(""custom-header"", ""header-value"") context.claims.claim(""custom-claim"", ""claim-value"") } Public Authentication: Public Client Authentication is supported out of the box and no customization is necessary to enable it. The following Spring Boot properties for an OAuth 2.0 client registration demonstrate the configuration: spring: security: oauth2: client: registration: okta: client-id: client-id client-authentication-method: none authorization-grant-type: authorization_code ... Public Clients are supported using Proof Key for Code Exchange(https://tools.ietf.org/html/rfc7636) (PKCE). PKCE will automatically be used when client-authentication-method is set to ""none"" ( ClientAuthenticationMethod.NONE )."
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/client/authorized-clients.html","Authorized Clients: Resolving an Authorized Client: The @RegisteredOAuth2AuthorizedClient annotation provides the capability of resolving a method parameter to an argument value of type OAuth2AuthorizedClient . This is a convenient alternative compared to accessing the OAuth2AuthorizedClient using the ReactiveOAuth2AuthorizedClientManager or ReactiveOAuth2AuthorizedClientService . Java Kotlin @Controller public class OAuth2ClientController { @GetMapping(""/"") public Mono<String> index(@RegisteredOAuth2AuthorizedClient(""okta"") OAuth2AuthorizedClient authorizedClient) { return Mono.just(authorizedClient.getAccessToken()) ... .thenReturn(""index""); } } @Controller class OAuth2ClientController { @GetMapping(""/"") fun index(@RegisteredOAuth2AuthorizedClient(""okta"") authorizedClient: OAuth2AuthorizedClient): Mono<String> { return Mono.just(authorizedClient.accessToken) ... .thenReturn(""index"") } } The @RegisteredOAuth2AuthorizedClient annotation is handled by OAuth2AuthorizedClientArgumentResolver , which directly uses a ReactiveOAuth2AuthorizedClientManager(#oauth2Client-authorized-manager-provider) and therefore inherits it’s capabilities. WebClient integration for Reactive Environments: The OAuth 2.0 Client support integrates with WebClient using an ExchangeFilterFunction . The ServerOAuth2AuthorizedClientExchangeFilterFunction provides a simple mechanism for requesting protected resources by using an OAuth2AuthorizedClient and including the associated OAuth2AccessToken as a Bearer Token. It directly uses an ReactiveOAuth2AuthorizedClientManager(#oauth2Client-authorized-manager-provider) and therefore inherits the following capabilities: An OAuth2AccessToken will be requested if the client has not yet been authorized. authorization_code - triggers the Authorization Request redirect to initiate the flow client_credentials - the access token is obtained directly from the Token Endpoint password - the access token is obtained directly from the Token Endpoint If the OAuth2AccessToken is expired, it will be refreshed (or renewed) if a ReactiveOAuth2AuthorizedClientProvider is available to perform the authorization The following code shows an example of how to configure WebClient with OAuth 2.0 Client support: Java Kotlin @Bean WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) { ServerOAuth2AuthorizedClientExchangeFilterFunction oauth2Client = new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); return WebClient.builder() .filter(oauth2Client) .build(); } @Bean fun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient { val oauth2Client = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager) return WebClient.builder() .filter(oauth2Client) .build() } Providing the Authorized Client: The ServerOAuth2AuthorizedClientExchangeFilterFunction determines the client to use (for a request) by resolving the OAuth2AuthorizedClient from the ClientRequest.attributes() (request attributes). The following code shows how to set an OAuth2AuthorizedClient as a request attribute: Java Kotlin @GetMapping(""/"") public Mono<String> index(@RegisteredOAuth2AuthorizedClient(""okta"") OAuth2AuthorizedClient authorizedClient) { String resourceUri = ... return webClient .get() .uri(resourceUri) .attributes(oauth2AuthorizedClient(authorizedClient)) (1) .retrieve() .bodyToMono(String.class) ... .thenReturn(""index""); } @GetMapping(""/"") fun index(@RegisteredOAuth2AuthorizedClient(""okta"") authorizedClient: OAuth2AuthorizedClient): Mono<String> { val resourceUri: String = ... return webClient .get() .uri(resourceUri) .attributes(oauth2AuthorizedClient(authorizedClient)) (1) .retrieve() .bodyToMono<String>() ... .thenReturn(""index"") } 1 oauth2AuthorizedClient() is a static method in ServerOAuth2AuthorizedClientExchangeFilterFunction . The following code shows how to set the ClientRegistration.getRegistrationId() as a request attribute: Java Kotlin @GetMapping(""/"") public Mono<String> index() { String resourceUri = ... return webClient .get() .uri(resourceUri) .attributes(clientRegistrationId(""okta"")) (1) .retrieve() .bodyToMono(String.class) ... .thenReturn(""index""); } @GetMapping(""/"") fun index(): Mono<String> { val resourceUri: String = ... return webClient .get() .uri(resourceUri) .attributes(clientRegistrationId(""okta"")) (1) .retrieve() .bodyToMono<String>() ... .thenReturn(""index"") } 1 clientRegistrationId() is a static method in ServerOAuth2AuthorizedClientExchangeFilterFunction . Defaulting the Authorized Client: If neither OAuth2AuthorizedClient or ClientRegistration.getRegistrationId() is provided as a request attribute, the ServerOAuth2AuthorizedClientExchangeFilterFunction can determine the default client to use depending on it’s configuration. If setDefaultOAuth2AuthorizedClient(true) is configured and the user has authenticated using ServerHttpSecurity.oauth2Login() , the OAuth2AccessToken associated with the current OAuth2AuthenticationToken is used. The following code shows the specific configuration: Java Kotlin @Bean WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) { ServerOAuth2AuthorizedClientExchangeFilterFunction oauth2Client = new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); oauth2Client.setDefaultOAuth2AuthorizedClient(true); return WebClient.builder() .filter(oauth2Client) .build(); } @Bean fun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient { val oauth2Client = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager) oauth2Client.setDefaultOAuth2AuthorizedClient(true) return WebClient.builder() .filter(oauth2Client) .build() } It is recommended to be cautious with this feature since all HTTP requests will receive the access token. Alternatively, if setDefaultClientRegistrationId(""okta"") is configured with a valid ClientRegistration , the OAuth2AccessToken associated with the OAuth2AuthorizedClient is used. The following code shows the specific configuration: Java Kotlin @Bean WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) { ServerOAuth2AuthorizedClientExchangeFilterFunction oauth2Client = new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager); oauth2Client.setDefaultClientRegistrationId(""okta""); return WebClient.builder() .filter(oauth2Client) .build(); } @Bean fun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient { val oauth2Client = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager) oauth2Client.setDefaultClientRegistrationId(""okta"") return WebClient.builder() .filter(oauth2Client) .build() } It is recommended to be cautious with this feature since all HTTP requests will receive the access token."
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/resource-server/index.html","OAuth 2.0 Resource Server: Spring Security supports protecting endpoints by offering two forms of OAuth 2.0 Bearer Tokens(https://tools.ietf.org/html/rfc6750.html) : JWT(https://tools.ietf.org/html/rfc7519) Opaque Tokens This is handy in circumstances where an application has delegated its authority management to an authorization server(https://tools.ietf.org/html/rfc6749) (for example, Okta or Ping Identity). Resource serves can consult this authorization server to authorize requests. A complete working example for JWT(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/reactive/webflux/java/oauth2/resource-server) is available in the Spring Security repository(https://github.com/spring-projects/spring-security-samples/tree/6.3.x) ."
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/resource-server/jwt.html","OAuth 2.0 Resource Server JWT: Minimal Dependencies for JWT: Most Resource Server support is collected into spring-security-oauth2-resource-server . However, the support for decoding and verifying JWTs is in spring-security-oauth2-jose , meaning that both are necessary to have a working resource server that supports JWT-encoded Bearer Tokens. Minimal Configuration for JWTs: When using Spring Boot(https://spring.io/projects/spring-boot) , configuring an application as a resource server consists of two basic steps. First, include the needed dependencies. Second, indicate the location of the authorization server. Specifying the Authorization Server: In a Spring Boot application, you need to specify which authorization server to use: spring: security: oauth2: resourceserver: jwt: issuer-uri: https://idp.example.com/issuer Where idp.example.com/issuer(https://idp.example.com/issuer) is the value contained in the iss claim for JWT tokens that the authorization server issues. This resource server uses this property to further self-configure, discover the authorization server’s public keys, and subsequently validate incoming JWTs. To use the issuer-uri property, it must also be true that one of idp.example.com/issuer/.well-known/openid-configuration(https://idp.example.com/issuer/.well-known/openid-configuration) , idp.example.com/.well-known/openid-configuration/issuer(https://idp.example.com/.well-known/openid-configuration/issuer) , or idp.example.com/.well-known/oauth-authorization-server/issuer(https://idp.example.com/.well-known/oauth-authorization-server/issuer) is a supported endpoint for the authorization server. This endpoint is referred to as a Provider Configuration(https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig) endpoint or a Authorization Server Metadata(https://tools.ietf.org/html/rfc8414#section-3) endpoint. Startup Expectations: When this property and these dependencies are used, Resource Server automatically configures itself to validate JWT-encoded Bearer Tokens. It achieves this through a deterministic startup process: Hit the Provider Configuration or Authorization Server Metadata endpoint, processing the response for the jwks_url property. Configure the validation strategy to query jwks_url for valid public keys. Configure the validation strategy to validate each JWT’s iss claim against idp.example.com(https://idp.example.com) . A consequence of this process is that the authorization server must be receiving requests in order for Resource Server to successfully start up. If the authorization server is down when Resource Server queries it (given appropriate timeouts), then startup fails. Runtime Expectations: Once the application is started up, Resource Server tries to process any request that contains an Authorization: Bearer header: GET / HTTP/1.1 Authorization: Bearer some-token-value # Resource Server will process this So long as this scheme is indicated, Resource Server tries to process the request according to the Bearer Token specification. Given a well-formed JWT, Resource Server: Validates its signature against a public key obtained from the jwks_url endpoint during startup and matched against the JWTs header. Validates the JWTs exp and nbf timestamps and the JWTs iss claim. Maps each scope to an authority with the prefix SCOPE_ . As the authorization server makes available new keys, Spring Security automatically rotates the keys used to validate the JWT tokens. By default, the resulting Authentication#getPrincipal is a Spring Security Jwt object, and Authentication#getName maps to the JWT’s sub property, if one is present. From here, consider jumping to: How to Configure without Tying Resource Server startup to an authorization server’s availability(#webflux-oauth2resourceserver-jwt-jwkseturi) How to Configure without Spring Boot(#webflux-oauth2resourceserver-jwt-sansboot) Specifying the Authorization Server JWK Set Uri Directly: If the authorization server does not support any configuration endpoints, or if Resource Server must be able to start up independently from the authorization server, you can supply jwk-set-uri as well: spring: security: oauth2: resourceserver: jwt: issuer-uri: https://idp.example.com jwk-set-uri: https://idp.example.com/.well-known/jwks.json The JWK Set uri is not standardized, but you can typically find it in the authorization server’s documentation. Consequently, Resource Server does not ping the authorization server at startup. We still specify the issuer-uri so that Resource Server still validates the iss claim on incoming JWTs. You can supply this property directly on the DSL(#webflux-oauth2resourceserver-jwt-jwkseturi-dsl) . Overriding or Replacing Boot Auto Configuration: Spring Boot generates two @Bean objects on Resource Server’s behalf. The first bean is a SecurityWebFilterChain that configures the application as a resource server. When including spring-security-oauth2-jose , this SecurityWebFilterChain looks like: Resource Server SecurityWebFilterChain Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .anyExchange().authenticated() ) .oauth2ResourceServer(OAuth2ResourceServerSpec::jwt) return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { jwt { } } } } If the application does not expose a SecurityWebFilterChain bean, Spring Boot exposes the default one (shown in the preceding listing). To replace it, expose the @Bean within the application: Replacing SecurityWebFilterChain Java Kotlin import static org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope; @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .pathMatchers(""/message/**"").access(hasScope(""message:read"")) .anyExchange().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .jwt(withDefaults()) ); return http.build(); } import org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(""/message/**"", hasScope(""message:read"")) authorize(anyExchange, authenticated) } oauth2ResourceServer { jwt { } } } } The preceding configuration requires the scope of message:read for any URL that starts with /messages/ . Methods on the oauth2ResourceServer DSL also override or replace auto configuration. For example, the second @Bean Spring Boot creates is a ReactiveJwtDecoder , which decodes String tokens into validated instances of Jwt : ReactiveJwtDecoder Java Kotlin @Bean public ReactiveJwtDecoder jwtDecoder() { return ReactiveJwtDecoders.fromIssuerLocation(issuerUri); } @Bean fun jwtDecoder(): ReactiveJwtDecoder { return ReactiveJwtDecoders.fromIssuerLocation(issuerUri) } Calling ReactiveJwtDecoders#fromIssuerLocation(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/jwt/ReactiveJwtDecoders.html#fromIssuerLocation-java.lang.String-) invokes the Provider Configuration or Authorization Server Metadata endpoint to derive the JWK Set URI. If the application does not expose a ReactiveJwtDecoder bean, Spring Boot exposes the above default one. Its configuration can be overridden by using jwkSetUri() or replaced by using decoder() . Using jwkSetUri(): You can configure an authorization server’s JWK Set URI as a configuration property(#webflux-oauth2resourceserver-jwt-jwkseturi) or supply it in the DSL: Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .anyExchange().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .jwt(jwt -> jwt .jwkSetUri(""https://idp.example.com/.well-known/jwks.json"") ) ); return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { jwt { jwkSetUri = ""https://idp.example.com/.well-known/jwks.json"" } } } } Using jwkSetUri() takes precedence over any configuration property. Using decoder(): decoder() is more powerful than jwkSetUri() , because it completely replaces any Spring Boot auto-configuration of JwtDecoder : Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .anyExchange().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .jwt(jwt -> jwt .decoder(myCustomDecoder()) ) ); return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { jwt { jwtDecoder = myCustomDecoder() } } } } This is handy when you need deeper configuration, such as validation(#webflux-oauth2resourceserver-jwt-validation) . Exposing a ReactiveJwtDecoder @Bean: Alternately, exposing a ReactiveJwtDecoder @Bean has the same effect as decoder() : You can construct one with a jwkSetUri like so: Java Kotlin @Bean public ReactiveJwtDecoder jwtDecoder() { return NimbusReactiveJwtDecoder.withJwkSetUri(jwkSetUri).build(); } @Bean fun jwtDecoder(): ReactiveJwtDecoder { return NimbusReactiveJwtDecoder.withJwkSetUri(jwkSetUri).build() } or you can use the issuer and have NimbusReactiveJwtDecoder look up the jwkSetUri when build() is invoked, like the following: Java Kotlin @Bean public ReactiveJwtDecoder jwtDecoder() { return NimbusReactiveJwtDecoder.withIssuerLocation(issuer).build(); } @Bean fun jwtDecoder(): ReactiveJwtDecoder { return NimbusReactiveJwtDecoder.withIssuerLocation(issuer).build() } Or, if the defaults work for you, you can also use JwtDecoders , which does the above in addition to configuring the decoder’s validator: Java Kotlin @Bean public ReactiveJwtDecoder jwtDecoder() { return ReactiveJwtDecoders.fromIssuerLocation(issuer); } @Bean fun jwtDecoder(): ReactiveJwtDecoder { return ReactiveJwtDecoders.fromIssuerLocation(issuer) } Configuring Trusted Algorithms: By default, NimbusReactiveJwtDecoder , and hence Resource Server, trust and verify only tokens that use RS256 . You can customize this behavior with Spring Boot(#webflux-oauth2resourceserver-jwt-boot-algorithm) or by using the NimbusJwtDecoder builder(#webflux-oauth2resourceserver-jwt-decoder-builder) . Customizing Trusted Algorithms with Spring Boot: The simplest way to set the algorithm is as a property: spring: security: oauth2: resourceserver: jwt: jws-algorithms: RS512 jwk-set-uri: https://idp.example.org/.well-known/jwks.json Customizing Trusted Algorithms by Using a Builder: For greater power, though, we can use a builder that ships with NimbusReactiveJwtDecoder : Java Kotlin @Bean ReactiveJwtDecoder jwtDecoder() { return NimbusReactiveJwtDecoder.withIssuerLocation(this.issuer) .jwsAlgorithm(RS512).build(); } @Bean fun jwtDecoder(): ReactiveJwtDecoder { return NimbusReactiveJwtDecoder.withIssuerLocation(this.issuer) .jwsAlgorithm(RS512).build() } Calling jwsAlgorithm more than once configures NimbusReactiveJwtDecoder to trust more than one algorithm: Java Kotlin @Bean ReactiveJwtDecoder jwtDecoder() { return NimbusReactiveJwtDecoder.withIssuerLocation(this.issuer) .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build(); } @Bean fun jwtDecoder(): ReactiveJwtDecoder { return NimbusReactiveJwtDecoder.withIssuerLocation(this.issuer) .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build() } Alternately, you can call jwsAlgorithms : Java Kotlin @Bean ReactiveJwtDecoder jwtDecoder() { return NimbusReactiveJwtDecoder.withIssuerLocation(this.jwkSetUri) .jwsAlgorithms(algorithms -> { algorithms.add(RS512); algorithms.add(ES512); }).build(); } @Bean fun jwtDecoder(): ReactiveJwtDecoder { return NimbusReactiveJwtDecoder.withIssuerLocation(this.jwkSetUri) .jwsAlgorithms { it.add(RS512) it.add(ES512) } .build() } Trusting a Single Asymmetric Key: Simpler than backing a Resource Server with a JWK Set endpoint is to hard-code an RSA public key. The public key can be provided with Spring Boot(#webflux-oauth2resourceserver-jwt-decoder-public-key-boot) or by Using a Builder(#webflux-oauth2resourceserver-jwt-decoder-public-key-builder) . Via Spring Boot: You can specify a key with Spring Boot: spring: security: oauth2: resourceserver: jwt: public-key-location: classpath:my-key.pub Alternately, to allow for a more sophisticated lookup, you can post-process the RsaKeyConversionServicePostProcessor : BeanFactoryPostProcessor Java Kotlin @Bean BeanFactoryPostProcessor conversionServiceCustomizer() { return beanFactory -> beanFactory.getBean(RsaKeyConversionServicePostProcessor.class) .setResourceLoader(new CustomResourceLoader()); } @Bean fun conversionServiceCustomizer(): BeanFactoryPostProcessor { return BeanFactoryPostProcessor { beanFactory: ConfigurableListableBeanFactory -> beanFactory.getBean<RsaKeyConversionServicePostProcessor>() .setResourceLoader(CustomResourceLoader()) } } Specify your key’s location: key.location: hfds://my-key.pub Then autowire the value: Java Kotlin @Value(""${key.location}"") RSAPublicKey key; @Value(""\${key.location}"") val key: RSAPublicKey? = null Using a Builder: To wire an RSAPublicKey directly, use the appropriate NimbusReactiveJwtDecoder builder: Java Kotlin @Bean public ReactiveJwtDecoder jwtDecoder() { return NimbusReactiveJwtDecoder.withPublicKey(this.key).build(); } @Bean fun jwtDecoder(): ReactiveJwtDecoder { return NimbusReactiveJwtDecoder.withPublicKey(key).build() } Trusting a Single Symmetric Key: You can also use a single symmetric key. You can load in your SecretKey and use the appropriate NimbusReactiveJwtDecoder builder: Java Kotlin @Bean public ReactiveJwtDecoder jwtDecoder() { return NimbusReactiveJwtDecoder.withSecretKey(this.key).build(); } @Bean fun jwtDecoder(): ReactiveJwtDecoder { return NimbusReactiveJwtDecoder.withSecretKey(this.key).build() } Configuring Authorization: A JWT that is issued from an OAuth 2.0 Authorization Server typically has either a scope or an scp attribute, indicating the scopes (or authorities) it has been granted — for example: { ..., ""scope"" : ""messages contacts""} When this is the case, Resource Server tries to coerce these scopes into a list of granted authorities, prefixing each scope with the string, SCOPE_ . This means that, to protect an endpoint or method with a scope derived from a JWT, the corresponding expressions should include this prefix: Java Kotlin import static org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope; @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .mvcMatchers(""/contacts/**"").access(hasScope(""contacts"")) .mvcMatchers(""/messages/**"").access(hasScope(""messages"")) .anyExchange().authenticated() ) .oauth2ResourceServer(OAuth2ResourceServerSpec::jwt); return http.build(); } import org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(""/contacts/**"", hasScope(""contacts"")) authorize(""/messages/**"", hasScope(""messages"")) authorize(anyExchange, authenticated) } oauth2ResourceServer { jwt { } } } } You can do something similar with method security: Java Kotlin @PreAuthorize(""hasAuthority('SCOPE_messages')"") public Flux<Message> getMessages(...) {} @PreAuthorize(""hasAuthority('SCOPE_messages')"") fun getMessages(): Flux<Message> { } Extracting Authorities Manually: However, there are a number of circumstances where this default is insufficient. For example, some authorization servers do not use the scope attribute. Instead, they have their own custom attribute. At other times, the resource server may need to adapt the attribute or a composition of attributes into internalized authorities. To this end, the DSL exposes jwtAuthenticationConverter() : Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .anyExchange().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .jwt(jwt -> jwt .jwtAuthenticationConverter(grantedAuthoritiesExtractor()) ) ); return http.build(); } Converter<Jwt, Mono<AbstractAuthenticationToken>> grantedAuthoritiesExtractor() { JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter(); jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter (new GrantedAuthoritiesExtractor()); return new ReactiveJwtAuthenticationConverterAdapter(jwtAuthenticationConverter); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { jwt { jwtAuthenticationConverter = grantedAuthoritiesExtractor() } } } } fun grantedAuthoritiesExtractor(): Converter<Jwt, Mono<AbstractAuthenticationToken>> { val jwtAuthenticationConverter = JwtAuthenticationConverter() jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(GrantedAuthoritiesExtractor()) return ReactiveJwtAuthenticationConverterAdapter(jwtAuthenticationConverter) } jwtAuthenticationConverter() is responsible for converting a Jwt into an Authentication . As part of its configuration, we can supply a subsidiary converter to go from Jwt to a Collection of granted authorities. That final converter might be something like the following GrantedAuthoritiesExtractor : Java Kotlin static class GrantedAuthoritiesExtractor implements Converter<Jwt, Collection<GrantedAuthority>> { public Collection<GrantedAuthority> convert(Jwt jwt) { Collection<?> authorities = (Collection<?>) jwt.getClaims().getOrDefault(""mycustomclaim"", Collections.emptyList()); return authorities.stream() .map(Object::toString) .map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); } } internal class GrantedAuthoritiesExtractor : Converter<Jwt, Collection<GrantedAuthority>> { override fun convert(jwt: Jwt): Collection<GrantedAuthority> { val authorities: List<Any> = jwt.claims .getOrDefault(""mycustomclaim"", emptyList<Any>()) as List<Any> return authorities .map { it.toString() } .map { SimpleGrantedAuthority(it) } } } For more flexibility, the DSL supports entirely replacing the converter with any class that implements Converter<Jwt, Mono<AbstractAuthenticationToken>> : Java Kotlin static class CustomAuthenticationConverter implements Converter<Jwt, Mono<AbstractAuthenticationToken>> { public AbstractAuthenticationToken convert(Jwt jwt) { return Mono.just(jwt).map(this::doConversion); } } internal class CustomAuthenticationConverter : Converter<Jwt, Mono<AbstractAuthenticationToken>> { override fun convert(jwt: Jwt): Mono<AbstractAuthenticationToken> { return Mono.just(jwt).map(this::doConversion) } } Configuring Validation: Using minimal Spring Boot configuration(#webflux-oauth2resourceserver-jwt-minimalconfiguration) , indicating the authorization server’s issuer URI, Resource Server defaults to verifying the iss claim as well as the exp and nbf timestamp claims. In circumstances where you need to customize validation needs, Resource Server ships with two standard validators and also accepts custom OAuth2TokenValidator instances. Customizing Timestamp Validation: JWT instances typically have a window of validity, with the start of the window indicated in the nbf claim and the end indicated in the exp claim. However, every server can experience clock drift, which can cause tokens to appear to be expired to one server but not to another. This can cause some implementation heartburn, as the number of collaborating servers increases in a distributed system. Resource Server uses JwtTimestampValidator to verify a token’s validity window, and you can configure it with a clockSkew to alleviate the clock drift problem: Java Kotlin @Bean ReactiveJwtDecoder jwtDecoder() { NimbusReactiveJwtDecoder jwtDecoder = (NimbusReactiveJwtDecoder) ReactiveJwtDecoders.fromIssuerLocation(issuerUri); OAuth2TokenValidator<Jwt> withClockSkew = new DelegatingOAuth2TokenValidator<>( new JwtTimestampValidator(Duration.ofSeconds(60)), new IssuerValidator(issuerUri)); jwtDecoder.setJwtValidator(withClockSkew); return jwtDecoder; } @Bean fun jwtDecoder(): ReactiveJwtDecoder { val jwtDecoder = ReactiveJwtDecoders.fromIssuerLocation(issuerUri) as NimbusReactiveJwtDecoder val withClockSkew: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator( JwtTimestampValidator(Duration.ofSeconds(60)), JwtIssuerValidator(issuerUri)) jwtDecoder.setJwtValidator(withClockSkew) return jwtDecoder } By default, Resource Server configures a clock skew of 60 seconds. Configuring a Custom Validator: You can Add a check for the aud claim with the OAuth2TokenValidator API: Java Kotlin public class AudienceValidator implements OAuth2TokenValidator<Jwt> { OAuth2Error error = new OAuth2Error(""invalid_token"", ""The required audience is missing"", null); public OAuth2TokenValidatorResult validate(Jwt jwt) { if (jwt.getAudience().contains(""messaging"")) { return OAuth2TokenValidatorResult.success(); } else { return OAuth2TokenValidatorResult.failure(error); } } } class AudienceValidator : OAuth2TokenValidator<Jwt> { var error: OAuth2Error = OAuth2Error(""invalid_token"", ""The required audience is missing"", null) override fun validate(jwt: Jwt): OAuth2TokenValidatorResult { return if (jwt.audience.contains(""messaging"")) { OAuth2TokenValidatorResult.success() } else { OAuth2TokenValidatorResult.failure(error) } } } Then, to add into a resource server, you can specifying the ReactiveJwtDecoder instance: Java Kotlin @Bean ReactiveJwtDecoder jwtDecoder() { NimbusReactiveJwtDecoder jwtDecoder = (NimbusReactiveJwtDecoder) ReactiveJwtDecoders.fromIssuerLocation(issuerUri); OAuth2TokenValidator<Jwt> audienceValidator = new AudienceValidator(); OAuth2TokenValidator<Jwt> withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri); OAuth2TokenValidator<Jwt> withAudience = new DelegatingOAuth2TokenValidator<>(withIssuer, audienceValidator); jwtDecoder.setJwtValidator(withAudience); return jwtDecoder; } @Bean fun jwtDecoder(): ReactiveJwtDecoder { val jwtDecoder = ReactiveJwtDecoders.fromIssuerLocation(issuerUri) as NimbusReactiveJwtDecoder val audienceValidator: OAuth2TokenValidator<Jwt> = AudienceValidator() val withIssuer: OAuth2TokenValidator<Jwt> = JwtValidators.createDefaultWithIssuer(issuerUri) val withAudience: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(withIssuer, audienceValidator) jwtDecoder.setJwtValidator(withAudience) return jwtDecoder }"
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/resource-server/opaque-token.html","OAuth 2.0 Resource Server Opaque Token: Minimal Dependencies for Introspection: As described in Minimal Dependencies for JWT(../../../servlet/oauth2/resource-server/jwt.html#oauth2resourceserver-jwt-minimaldependencies) , most Resource Server support is collected in spring-security-oauth2-resource-server . However, unless you provide a custom ReactiveOpaqueTokenIntrospector(#webflux-oauth2resourceserver-opaque-introspector-bean) , the Resource Server falls back to ReactiveOpaqueTokenIntrospector . This means that both spring-security-oauth2-resource-server and oauth2-oidc-sdk are necessary to have a working minimal Resource Server that supports opaque Bearer Tokens. See spring-security-oauth2-resource-server in order to determine the correct version for oauth2-oidc-sdk . Minimal Configuration for Introspection: Typically, you can verify an opaque token with an OAuth 2.0 Introspection Endpoint(https://tools.ietf.org/html/rfc7662) , hosted by the authorization server. This can be handy when revocation is a requirement. When using Spring Boot(https://spring.io/projects/spring-boot) , configuring an application as a resource server that uses introspection consists of two steps: Include the needed dependencies. Indicate the introspection endpoint details. Specifying the Authorization Server: You can specify where the introspection endpoint is: spring: security: oauth2: resourceserver: opaque-token: introspection-uri: https://idp.example.com/introspect client-id: client client-secret: secret Where idp.example.com/introspect(https://idp.example.com/introspect) is the introspection endpoint hosted by your authorization server and client-id and client-secret are the credentials needed to hit that endpoint. Resource Server uses these properties to further self-configure and subsequently validate incoming JWTs. If the authorization server responses that the token is valid, then it is. Startup Expectations: When this property and these dependencies are used, Resource Server automatically configures itself to validate Opaque Bearer Tokens. This startup process is quite a bit simpler than for JWTs, since no endpoints need to be discovered and no additional validation rules get added. Runtime Expectations: Once the application has started, Resource Server tries to process any request containing an Authorization: Bearer header: GET / HTTP/1.1 Authorization: Bearer some-token-value # Resource Server will process this So long as this scheme is indicated, Resource Server tries to process the request according to the Bearer Token specification. Given an Opaque Token, Resource Server: Queries the provided introspection endpoint by using the provided credentials and the token. Inspects the response for an { 'active' : true } attribute. Maps each scope to an authority with a prefix of SCOPE_ . By default, the resulting Authentication#getPrincipal is a Spring Security OAuth2AuthenticatedPrincipal(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/core/OAuth2AuthenticatedPrincipal.html) object, and Authentication#getName maps to the token’s sub property, if one is present. From here, you may want to jump to: Looking Up Attributes After Authentication(#webflux-oauth2resourceserver-opaque-attributes) Extracting Authorities Manually(#webflux-oauth2resourceserver-opaque-authorization-extraction) Using Introspection with JWTs(#webflux-oauth2resourceserver-opaque-jwt-introspector) Looking Up Attributes After Authentication: Once a token is authenticated, an instance of BearerTokenAuthentication is set in the SecurityContext . This means that it is available in @Controller methods when you use @EnableWebFlux in your configuration: Java Kotlin @GetMapping(""/foo"") public Mono<String> foo(BearerTokenAuthentication authentication) { return Mono.just(authentication.getTokenAttributes().get(""sub"") + "" is the subject""); } @GetMapping(""/foo"") fun foo(authentication: BearerTokenAuthentication): Mono<String> { return Mono.just(authentication.tokenAttributes[""sub""].toString() + "" is the subject"") } Since BearerTokenAuthentication holds an OAuth2AuthenticatedPrincipal , that also means that it’s available to controller methods, too: Java Kotlin @GetMapping(""/foo"") public Mono<String> foo(@AuthenticationPrincipal OAuth2AuthenticatedPrincipal principal) { return Mono.just(principal.getAttribute(""sub"") + "" is the subject""); } @GetMapping(""/foo"") fun foo(@AuthenticationPrincipal principal: OAuth2AuthenticatedPrincipal): Mono<String> { return Mono.just(principal.getAttribute<Any>(""sub"").toString() + "" is the subject"") } Looking Up Attributes with SpEL: You can access attributes with the Spring Expression Language (SpEL). For example, if you use @EnableReactiveMethodSecurity so that you can use @PreAuthorize annotations, you can do: Java Kotlin @PreAuthorize(""principal?.attributes['sub'] = 'foo'"") public Mono<String> forFoosEyesOnly() { return Mono.just(""foo""); } @PreAuthorize(""principal.attributes['sub'] = 'foo'"") fun forFoosEyesOnly(): Mono<String> { return Mono.just(""foo"") } Overriding or Replacing Boot Auto Configuration: Spring Boot generates two @Bean instances for Resource Server. The first is a SecurityWebFilterChain that configures the application as a resource server. When you use an Opaque Token, this SecurityWebFilterChain looks like: Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .anyExchange().authenticated() ) .oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::opaqueToken) return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { opaqueToken { } } } } If the application does not expose a SecurityWebFilterChain bean, Spring Boot exposes the default bean (shown in the preceding listing). You can replace it by exposing the bean within the application: Replacing SecurityWebFilterChain Java Kotlin import static org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope; @Configuration @EnableWebFluxSecurity public class MyCustomSecurityConfiguration { @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .pathMatchers(""/messages/**"").access(hasScope(""message:read"")) .anyExchange().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .opaqueToken(opaqueToken -> opaqueToken .introspector(myIntrospector()) ) ); return http.build(); } } import org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(""/messages/**"", hasScope(""message:read"")) authorize(anyExchange, authenticated) } oauth2ResourceServer { opaqueToken { introspector = myIntrospector() } } } } The preceding example requires the scope of message:read for any URL that starts with /messages/ . Methods on the oauth2ResourceServer DSL also override or replace auto configuration. For example, the second @Bean Spring Boot creates is a ReactiveOpaqueTokenIntrospector , which decodes String tokens into validated instances of OAuth2AuthenticatedPrincipal : Java Kotlin @Bean public ReactiveOpaqueTokenIntrospector introspector() { return new NimbusReactiveOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret); } @Bean fun introspector(): ReactiveOpaqueTokenIntrospector { return NimbusReactiveOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret) } If the application does not expose a ReactiveOpaqueTokenIntrospector bean, Spring Boot exposes the default one (shown in the preceding listing). You can override its configuration by using introspectionUri() and introspectionClientCredentials() or replace it by using introspector() . Using introspectionUri(): You can configure an authorization server’s Introspection URI as a configuration property(#webflux-oauth2resourceserver-opaque-introspectionuri) , or you can supply in the DSL: Java Kotlin @Configuration @EnableWebFluxSecurity public class DirectlyConfiguredIntrospectionUri { @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .anyExchange().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .opaqueToken(opaqueToken -> opaqueToken .introspectionUri(""https://idp.example.com/introspect"") .introspectionClientCredentials(""client"", ""secret"") ) ); return http.build(); } } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { opaqueToken { introspectionUri = ""https://idp.example.com/introspect"" introspectionClientCredentials(""client"", ""secret"") } } } } Using introspectionUri() takes precedence over any configuration property. Using introspector(): introspector() is more powerful than introspectionUri() . It completely replaces any Boot auto-configuration of ReactiveOpaqueTokenIntrospector : Java Kotlin @Configuration @EnableWebFluxSecurity public class DirectlyConfiguredIntrospector { @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .anyExchange().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .opaqueToken(opaqueToken -> opaqueToken .introspector(myCustomIntrospector()) ) ); return http.build(); } } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { opaqueToken { introspector = myCustomIntrospector() } } } } This is handy when deeper configuration, such as authority mapping(#webflux-oauth2resourceserver-opaque-authorization-extraction) or JWT revocation(#webflux-oauth2resourceserver-opaque-jwt-introspector) , is necessary. Exposing a ReactiveOpaqueTokenIntrospector @Bean: Or, exposing a ReactiveOpaqueTokenIntrospector @Bean has the same effect as introspector() : Java Kotlin @Bean public ReactiveOpaqueTokenIntrospector introspector() { return new NimbusReactiveOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret); } @Bean fun introspector(): ReactiveOpaqueTokenIntrospector { return NimbusReactiveOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret) } Configuring Authorization: An OAuth 2.0 Introspection endpoint typically returns a scope attribute, indicating the scopes (or authorities) it has been granted — for example: { ..., ""scope"" : ""messages contacts""} When this is the case, Resource Server tries to coerce these scopes into a list of granted authorities, prefixing each scope with a string: SCOPE_ . This means that, to protect an endpoint or method with a scope derived from an Opaque Token, the corresponding expressions should include this prefix: Java Kotlin import static org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope; @Configuration @EnableWebFluxSecurity public class MappedAuthorities { @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchange -> exchange .pathMatchers(""/contacts/**"").access(hasScope(""contacts"")) .pathMatchers(""/messages/**"").access(hasScope(""messages"")) .anyExchange().authenticated() ) .oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::opaqueToken); return http.build(); } } import org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(""/contacts/**"", hasScope(""contacts"")) authorize(""/messages/**"", hasScope(""messages"")) authorize(anyExchange, authenticated) } oauth2ResourceServer { opaqueToken { } } } } You can do something similar with method security: Java Kotlin @PreAuthorize(""hasAuthority('SCOPE_messages')"") public Flux<Message> getMessages(...) {} @PreAuthorize(""hasAuthority('SCOPE_messages')"") fun getMessages(): Flux<Message> { } Extracting Authorities Manually: By default, Opaque Token support extracts the scope claim from an introspection response and parses it into individual GrantedAuthority instances. Consider the following example: { ""active"" : true, ""scope"" : ""message:read message:write"" } If the introspection response were as the preceding example shows, Resource Server would generate an Authentication with two authorities, one for message:read and the other for message:write . You can customize behavior by using a custom ReactiveOpaqueTokenIntrospector that looks at the attribute set and converts in its own way: Java Kotlin public class CustomAuthoritiesOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector { private ReactiveOpaqueTokenIntrospector delegate = new NimbusReactiveOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret""); public Mono<OAuth2AuthenticatedPrincipal> introspect(String token) { return this.delegate.introspect(token) .map(principal -> new DefaultOAuth2AuthenticatedPrincipal( principal.getName(), principal.getAttributes(), extractAuthorities(principal))); } private Collection<GrantedAuthority> extractAuthorities(OAuth2AuthenticatedPrincipal principal) { List<String> scopes = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE); return scopes.stream() .map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); } } class CustomAuthoritiesOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector { private val delegate: ReactiveOpaqueTokenIntrospector = NimbusReactiveOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret"") override fun introspect(token: String): Mono<OAuth2AuthenticatedPrincipal> { return delegate.introspect(token) .map { principal: OAuth2AuthenticatedPrincipal -> DefaultOAuth2AuthenticatedPrincipal( principal.name, principal.attributes, extractAuthorities(principal)) } } private fun extractAuthorities(principal: OAuth2AuthenticatedPrincipal): Collection<GrantedAuthority> { val scopes = principal.getAttribute<List<String>>(OAuth2IntrospectionClaimNames.SCOPE) return scopes .map { SimpleGrantedAuthority(it) } } } Thereafter, you can configure this custom introspector by exposing it as a @Bean : Java Kotlin @Bean public ReactiveOpaqueTokenIntrospector introspector() { return new CustomAuthoritiesOpaqueTokenIntrospector(); } @Bean fun introspector(): ReactiveOpaqueTokenIntrospector { return CustomAuthoritiesOpaqueTokenIntrospector() } Using Introspection with JWTs: A common question is whether or not introspection is compatible with JWTs. Spring Security’s Opaque Token support has been designed to not care about the format of the token. It gladly passes any token to the provided introspection endpoint. So, suppose you need to check with the authorization server on each request, in case the JWT has been revoked. Even though you are using the JWT format for the token, your validation method is introspection, meaning you would want to do: spring: security: oauth2: resourceserver: opaque-token: introspection-uri: https://idp.example.org/introspection client-id: client client-secret: secret In this case, the resulting Authentication would be BearerTokenAuthentication . Any attributes in the corresponding OAuth2AuthenticatedPrincipal would be whatever was returned by the introspection endpoint. However, suppose that, for whatever reason, the introspection endpoint returns only whether or not the token is active. Now what? In this case, you can create a custom ReactiveOpaqueTokenIntrospector that still hits the endpoint but then updates the returned principal to have the JWTs claims as the attributes: Java Kotlin public class JwtOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector { private ReactiveOpaqueTokenIntrospector delegate = new NimbusReactiveOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret""); private ReactiveJwtDecoder jwtDecoder = new NimbusReactiveJwtDecoder(new ParseOnlyJWTProcessor()); public Mono<OAuth2AuthenticatedPrincipal> introspect(String token) { return this.delegate.introspect(token) .flatMap(principal -> this.jwtDecoder.decode(token)) .map(jwt -> new DefaultOAuth2AuthenticatedPrincipal(jwt.getClaims(), NO_AUTHORITIES)); } private static class ParseOnlyJWTProcessor implements Converter<JWT, Mono<JWTClaimsSet>> { public Mono<JWTClaimsSet> convert(JWT jwt) { try { return Mono.just(jwt.getJWTClaimsSet()); } catch (Exception ex) { return Mono.error(ex); } } } } class JwtOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector { private val delegate: ReactiveOpaqueTokenIntrospector = NimbusReactiveOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret"") private val jwtDecoder: ReactiveJwtDecoder = NimbusReactiveJwtDecoder(ParseOnlyJWTProcessor()) override fun introspect(token: String): Mono<OAuth2AuthenticatedPrincipal> { return delegate.introspect(token) .flatMap { jwtDecoder.decode(token) } .map { jwt: Jwt -> DefaultOAuth2AuthenticatedPrincipal(jwt.claims, NO_AUTHORITIES) } } private class ParseOnlyJWTProcessor : Converter<JWT, Mono<JWTClaimsSet>> { override fun convert(jwt: JWT): Mono<JWTClaimsSet> { return try { Mono.just(jwt.jwtClaimsSet) } catch (e: Exception) { Mono.error(e) } } } } Thereafter, you can configure this custom introspector by exposing it as a @Bean : Java Kotlin @Bean public ReactiveOpaqueTokenIntrospector introspector() { return new JwtOpaqueTokenIntropsector(); } @Bean fun introspector(): ReactiveOpaqueTokenIntrospector { return JwtOpaqueTokenIntrospector() } Calling a /userinfo Endpoint: Generally speaking, a Resource Server does not care about the underlying user but, instead, cares about the authorities that have been granted. That said, at times it can be valuable to tie the authorization statement back to a user. If an application also uses spring-security-oauth2-client , having set up the appropriate ClientRegistrationRepository , you can do so with a custom OpaqueTokenIntrospector . The implementation in the next listing does three things: Delegates to the introspection endpoint, to affirm the token’s validity. Looks up the appropriate client registration associated with the /userinfo endpoint. Invokes and returns the response from the /userinfo endpoint. Java Kotlin public class UserInfoOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector { private final ReactiveOpaqueTokenIntrospector delegate = new NimbusReactiveOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret""); private final ReactiveOAuth2UserService<OAuth2UserRequest, OAuth2User> oauth2UserService = new DefaultReactiveOAuth2UserService(); private final ReactiveClientRegistrationRepository repository; // ... constructor @Override public Mono<OAuth2AuthenticatedPrincipal> introspect(String token) { return Mono.zip(this.delegate.introspect(token), this.repository.findByRegistrationId(""registration-id"")) .map(t -> { OAuth2AuthenticatedPrincipal authorized = t.getT1(); ClientRegistration clientRegistration = t.getT2(); Instant issuedAt = authorized.getAttribute(ISSUED_AT); Instant expiresAt = authorized.getAttribute(OAuth2IntrospectionClaimNames.EXPIRES_AT); OAuth2AccessToken accessToken = new OAuth2AccessToken(BEARER, token, issuedAt, expiresAt); return new OAuth2UserRequest(clientRegistration, accessToken); }) .flatMap(this.oauth2UserService::loadUser); } } class UserInfoOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector { private val delegate: ReactiveOpaqueTokenIntrospector = NimbusReactiveOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret"") private val oauth2UserService: ReactiveOAuth2UserService<OAuth2UserRequest, OAuth2User> = DefaultReactiveOAuth2UserService() private val repository: ReactiveClientRegistrationRepository? = null // ... constructor override fun introspect(token: String?): Mono<OAuth2AuthenticatedPrincipal> { return Mono.zip<OAuth2AuthenticatedPrincipal, ClientRegistration>(delegate.introspect(token), repository!!.findByRegistrationId(""registration-id"")) .map<OAuth2UserRequest> { t: Tuple2<OAuth2AuthenticatedPrincipal, ClientRegistration> -> val authorized = t.t1 val clientRegistration = t.t2 val issuedAt: Instant? = authorized.getAttribute(ISSUED_AT) val expiresAt: Instant? = authorized.getAttribute(OAuth2IntrospectionClaimNames.EXPIRES_AT) val accessToken = OAuth2AccessToken(BEARER, token, issuedAt, expiresAt) OAuth2UserRequest(clientRegistration, accessToken) } .flatMap { userRequest: OAuth2UserRequest -> oauth2UserService.loadUser(userRequest) } } } If you aren’t using spring-security-oauth2-client , it’s still quite simple. You will simply need to invoke the /userinfo with your own instance of WebClient : Java Kotlin public class UserInfoOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector { private final ReactiveOpaqueTokenIntrospector delegate = new NimbusReactiveOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret""); private final WebClient rest = WebClient.create(); @Override public Mono<OAuth2AuthenticatedPrincipal> introspect(String token) { return this.delegate.introspect(token) .map(this::makeUserInfoRequest); } } class UserInfoOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector { private val delegate: ReactiveOpaqueTokenIntrospector = NimbusReactiveOpaqueTokenIntrospector(""https://idp.example.org/introspect"", ""client"", ""secret"") private val rest: WebClient = WebClient.create() override fun introspect(token: String): Mono<OAuth2AuthenticatedPrincipal> { return delegate.introspect(token) .map(this::makeUserInfoRequest) } } Either way, having created your ReactiveOpaqueTokenIntrospector , you should publish it as a @Bean to override the defaults: Java Kotlin @Bean ReactiveOpaqueTokenIntrospector introspector() { return new UserInfoOpaqueTokenIntrospector(); } @Bean fun introspector(): ReactiveOpaqueTokenIntrospector { return UserInfoOpaqueTokenIntrospector() }"
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/resource-server/multitenancy.html","OAuth 2.0 Resource Server Multi-tenancy: Multi-tenancy: A resource server is considered multi-tenant when there are multiple strategies for verifying a bearer token, keyed by some tenant identifier. For example, your resource server can accept bearer tokens from two different authorization servers. Alternately, your authorization server can represent a multiplicity of issuers. In each case, two things need to be done and trade-offs are associated with how you choose to do them: Resolve the tenant. Propagate the tenant. Resolving the Tenant By Claim: One way to differentiate tenants is by the issuer claim. Since the issuer claim accompanies signed JWTs, you can do so with the JwtIssuerReactiveAuthenticationManagerResolver : Java Kotlin JwtIssuerReactiveAuthenticationManagerResolver authenticationManagerResolver = JwtIssuerReactiveAuthenticationManagerResolver .fromTrustedIssuers(""https://idp.example.org/issuerOne"", ""https://idp.example.org/issuerTwo""); http .authorizeExchange(exchanges -> exchanges .anyExchange().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .authenticationManagerResolver(authenticationManagerResolver) ); val customAuthenticationManagerResolver = JwtIssuerReactiveAuthenticationManagerResolver .fromTrustedIssuers(""https://idp.example.org/issuerOne"", ""https://idp.example.org/issuerTwo"") return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { authenticationManagerResolver = customAuthenticationManagerResolver } } This is nice because the issuer endpoints are loaded lazily. In fact, the corresponding JwtReactiveAuthenticationManager is instantiated only when the first request with the corresponding issuer is sent. This allows for an application startup that is independent from those authorization servers being up and available. Dynamic Tenants: You may not want to restart the application each time a new tenant is added. In this case, you can configure the JwtIssuerReactiveAuthenticationManagerResolver with a repository of ReactiveAuthenticationManager instances, which you can edit at runtime: Java Kotlin private Mono<ReactiveAuthenticationManager> addManager( Map<String, ReactiveAuthenticationManager> authenticationManagers, String issuer) { return Mono.fromCallable(() -> ReactiveJwtDecoders.fromIssuerLocation(issuer)) .subscribeOn(Schedulers.boundedElastic()) .map(JwtReactiveAuthenticationManager::new) .doOnNext(authenticationManager -> authenticationManagers.put(issuer, authenticationManager)); } // ... JwtIssuerReactiveAuthenticationManagerResolver authenticationManagerResolver = new JwtIssuerReactiveAuthenticationManagerResolver(authenticationManagers::get); http .authorizeExchange(exchanges -> exchanges .anyExchange().authenticated() ) .oauth2ResourceServer(oauth2 -> oauth2 .authenticationManagerResolver(authenticationManagerResolver) ); private fun addManager( authenticationManagers: MutableMap<String, ReactiveAuthenticationManager>, issuer: String): Mono<JwtReactiveAuthenticationManager> { return Mono.fromCallable { ReactiveJwtDecoders.fromIssuerLocation(issuer) } .subscribeOn(Schedulers.boundedElastic()) .map { jwtDecoder: ReactiveJwtDecoder -> JwtReactiveAuthenticationManager(jwtDecoder) } .doOnNext { authenticationManager: JwtReactiveAuthenticationManager -> authenticationManagers[issuer] = authenticationManager } } // ... var customAuthenticationManagerResolver = JwtIssuerReactiveAuthenticationManagerResolver(authenticationManagers::get) return http { authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { authenticationManagerResolver = customAuthenticationManagerResolver } } In this case, you construct JwtIssuerReactiveAuthenticationManagerResolver with a strategy for obtaining the ReactiveAuthenticationManager given to the issuer. This approach lets us add and remove elements from the repository (shown as a Map in the preceding snippet) at runtime. It would be unsafe to simply take any issuer and construct an ReactiveAuthenticationManager from it. The issuer should be one that the code can verify from a trusted source, such as an allowed list of issuers."
"https://docs.spring.io/spring-security/reference/6.3/reactive/oauth2/resource-server/bearer-tokens.html","OAuth 2.0 Resource Server Bearer Tokens: Bearer Token Resolution: By default, Resource Server looks for a bearer token in the Authorization header. However, you can verify this token. For example, you may have a need to read the bearer token from a custom header. To do so, you can wire an instance of ServerBearerTokenAuthenticationConverter into the DSL: Custom Bearer Token Header Java Kotlin ServerBearerTokenAuthenticationConverter converter = new ServerBearerTokenAuthenticationConverter(); converter.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION); http .oauth2ResourceServer(oauth2 -> oauth2 .bearerTokenConverter(converter) ); val converter = ServerBearerTokenAuthenticationConverter() converter.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION) return http { oauth2ResourceServer { bearerTokenConverter = converter } } Bearer Token Propagation: Now that you have a bearer token, you can pass that to downstream services. This is possible with ServerBearerExchangeFilterFunction(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/server/resource/web/reactive/function/client/ServerBearerExchangeFilterFunction.html) : Java Kotlin @Bean public WebClient rest() { return WebClient.builder() .filter(new ServerBearerExchangeFilterFunction()) .build(); } @Bean fun rest(): WebClient { return WebClient.builder() .filter(ServerBearerExchangeFilterFunction()) .build() } When the WebClient shown in the preceding example performs requests, Spring Security looks up the current Authentication and extract any AbstractOAuth2Token(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/core/AbstractOAuth2Token.html) credential. Then, it propagates that token in the Authorization header — for example: Java Kotlin this.rest.get() .uri(""https://other-service.example.com/endpoint"") .retrieve() .bodyToMono(String.class) this.rest.get() .uri(""https://other-service.example.com/endpoint"") .retrieve() .bodyToMono<String>() The prececing example invokes the other-service.example.com/endpoint(https://other-service.example.com/endpoint) , adding the bearer token Authorization header for you. In places where you need to override this behavior, you can supply the header yourself: Java Kotlin this.rest.get() .uri(""https://other-service.example.com/endpoint"") .headers(headers -> headers.setBearerAuth(overridingToken)) .retrieve() .bodyToMono(String.class) rest.get() .uri(""https://other-service.example.com/endpoint"") .headers { it.setBearerAuth(overridingToken) } .retrieve() .bodyToMono<String>() In this case, the filter falls back and forwards the request onto the rest of the web filter chain. Unlike the OAuth 2.0 Client filter function(https://docs.spring.io/spring-security/site/docs/current-SNAPSHOT/api/org/springframework/security/oauth2/client/web/reactive/function/client/ServerOAuth2AuthorizedClientExchangeFilterFunction.html) , this filter function makes no attempt to renew the token, should it be expired."
"https://docs.spring.io/spring-security/reference/6.3/reactive/exploits/index.html","Protection Against Exploits: Spring Security provides protection against numerous exploits. This section discusses WebFlux specific support for: CSRF(csrf.html) Headers(headers.html) HTTP Requests(http.html)"
"https://docs.spring.io/spring-security/reference/6.3/reactive/exploits/csrf.html","Cross Site Request Forgery (CSRF) for WebFlux Environments: This section discusses Spring Security’s Cross Site Request Forgery (CSRF)(../../features/exploits/csrf.html#csrf) support for WebFlux environments. Using Spring Security CSRF Protection: The steps to using Spring Security’s CSRF protection are outlined below: Use proper HTTP verbs(#webflux-csrf-read-only) Configure CSRF Protection(#webflux-csrf-configure) Include the CSRF Token(#webflux-csrf-include) Use Proper HTTP Verbs: The first step to protecting against CSRF attacks is to ensure your website uses proper HTTP verbs. This is covered in detail in Safe Methods Must be Read-only(../../features/exploits/csrf.html#csrf-protection-read-only) . Configure CSRF Protection: The next step is to configure Spring Security’s CSRF protection within your application. By default, Spring Security’s CSRF protection is enabled, but you may need to customize the configuration. The next few subsections cover a few common customizations. Custom CsrfTokenRepository: By default, Spring Security stores the expected CSRF token in the WebSession by using WebSessionServerCsrfTokenRepository . Sometimes, you may need to configure a custom ServerCsrfTokenRepository . For example, you may want to persist the CsrfToken in a cookie to support a JavaScript-based application(#webflux-csrf-include-ajax-auto) . By default, the CookieServerCsrfTokenRepository writes to a cookie named XSRF-TOKEN and read its from a header named X-XSRF-TOKEN or the HTTP _csrf parameter. These defaults come from AngularJS(https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection) You can configure CookieServerCsrfTokenRepository in Java Configuration: Store CSRF Token in a Cookie Java Kotlin @Bean public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .csrf(csrf -> csrf.csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse())) return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... csrf { csrfTokenRepository = CookieServerCsrfTokenRepository.withHttpOnlyFalse() } } } The preceding sample explicitly sets cookieHttpOnly=false . This is necessary to let JavaScript (in this case, AngularJS) to read it. If you do not need the ability to read the cookie with JavaScript directly, we recommend to omitting cookieHttpOnly=false (by using new CookieServerCsrfTokenRepository() instead) to improve security. Disable CSRF Protection: By default, CSRF protection is enabled. However, you can disable CSRF protection if it makes sense for your application(../../features/exploits/csrf.html#csrf-when) . The Java configuration below will disable CSRF protection. Disable CSRF Configuration Java Kotlin @Bean public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .csrf(csrf -> csrf.disable())) return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... csrf { disable() } } } Configure ServerCsrfTokenRequestHandler: Spring Security’s CsrfWebFilter(https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/server/csrf/CsrfWebFilter.html) exposes a Mono<CsrfToken>(https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/server/csrf/CsrfToken.html) as a ServerWebExchange attribute named org.springframework.security.web.server.csrf.CsrfToken with the help of a ServerCsrfTokenRequestHandler(https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/server/csrf/ServerCsrfTokenRequestHandler.html) . In 5.8, the default implementation was ServerCsrfTokenRequestAttributeHandler , which simply makes the Mono<CsrfToken> available as an exchange attribute. As of 6.0, the default implementation is XorServerCsrfTokenRequestAttributeHandler , which provides protection for BREACH (see gh-4001(https://github.com/spring-projects/spring-security/issues/4001) ). If you wish to disable BREACH protection of the CsrfToken and revert to the 5.8 default, you can configure ServerCsrfTokenRequestAttributeHandler using the following Java configuration: Disable BREACH protection Java Kotlin @Bean public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .csrf(csrf -> csrf .csrfTokenRequestHandler(new ServerCsrfTokenRequestAttributeHandler()) ) return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... csrf { csrfTokenRequestHandler = ServerCsrfTokenRequestAttributeHandler() } } } Include the CSRF Token: For the synchronizer token pattern(../../features/exploits/csrf.html#csrf-protection-stp) to protect against CSRF attacks, we must include the actual CSRF token in the HTTP request. It must be included in a part of the request (a form parameter, an HTTP header, or other option) that is not automatically included in the HTTP request by the browser. We’ve seen(#webflux-csrf-configure-request-handler) that the Mono<CsrfToken> is exposed as a ServerWebExchange attribute. This means that any view technology can access the Mono<CsrfToken> to expose the expected token as either a form(#webflux-csrf-include-form-attr) or a meta tag(#webflux-csrf-include-ajax-meta) . If your view technology does not provide a simple way to subscribe to the Mono<CsrfToken> , a common pattern is to use Spring’s @ControllerAdvice to expose the CsrfToken directly. The following example places the CsrfToken on the default attribute name ( _csrf ) used by Spring Security’s CsrfRequestDataValueProcessor(#webflux-csrf-include-form-auto) to automatically include the CSRF token as a hidden input: CsrfToken as @ModelAttribute Java Kotlin @ControllerAdvice public class SecurityControllerAdvice { @ModelAttribute Mono<CsrfToken> csrfToken(ServerWebExchange exchange) { Mono<CsrfToken> csrfToken = exchange.getAttribute(CsrfToken.class.getName()); return csrfToken.doOnSuccess(token -> exchange.getAttributes() .put(CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME, token)); } } @ControllerAdvice class SecurityControllerAdvice { @ModelAttribute fun csrfToken(exchange: ServerWebExchange): Mono<CsrfToken> { val csrfToken: Mono<CsrfToken>? = exchange.getAttribute(CsrfToken::class.java.name) return csrfToken!!.doOnSuccess { token -> exchange.attributes[CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME] = token } } } Fortunately, Thymeleaf provides integration(#webflux-csrf-include-form-auto) that works without any additional work. Form URL Encoded: To post an HTML form, the CSRF token must be included in the form as a hidden input. The following example shows what the rendered HTML might look like: CSRF Token HTML <input type=""hidden"" name=""_csrf"" value=""4bfd1575-3ad1-4d21-96c7-4ef2d9f86721""/> Next, we discuss various ways of including the CSRF token in a form as a hidden input. Automatic CSRF Token Inclusion: Spring Security’s CSRF support provides integration with Spring’s RequestDataValueProcessor(https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/reactive/result/view/RequestDataValueProcessor.html) through its CsrfRequestDataValueProcessor(https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html) . For CsrfRequestDataValueProcessor to work, the Mono<CsrfToken> must be subscribed to and the CsrfToken must be exposed as an attribute(#webflux-csrf-include-subscribe) that matches DEFAULT_CSRF_ATTR_NAME(https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html#DEFAULT_CSRF_ATTR_NAME) . Fortunately, Thymeleaf takes care of all the boilerplate(https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor) for you by integrating with RequestDataValueProcessor to ensure that forms that have an unsafe HTTP method (POST) automatically include the actual CSRF token. CsrfToken Request Attribute: If the other options(#webflux-csrf-include) for including the actual CSRF token in the request do not work, you can take advantage of the fact that the Mono<CsrfToken> is exposed(#webflux-csrf-include) as a ServerWebExchange attribute named org.springframework.security.web.server.csrf.CsrfToken . The following Thymeleaf sample assumes that you expose(#webflux-csrf-include-subscribe) the CsrfToken on an attribute named _csrf : CSRF Token in Form with Request Attribute <form th:action=""@{/logout}"" method=""post""> <input type=""submit"" value=""Log out"" /> <input type=""hidden"" th:name=""${_csrf.parameterName}"" th:value=""${_csrf.token}""/> </form> Ajax and JSON Requests: If you use JSON, you cannot submit the CSRF token within an HTTP parameter. Instead, you can submit the token within a HTTP header. In the following sections, we discuss various ways of including the CSRF token as an HTTP request header in JavaScript-based applications. Automatic Inclusion: You can configure(#webflux-csrf-configure-custom-repository) Spring Security to store the expected CSRF token in a cookie. By storing the expected CSRF in a cookie, JavaScript frameworks, such as AngularJS(https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection) , automatically include the actual CSRF token in the HTTP request headers. Meta Tags: An alternative pattern to exposing the CSRF in a cookie(#webflux-csrf-include-form-auto) is to include the CSRF token within your meta tags. The HTML might look something like this: CSRF meta tag HTML <html> <head> <meta name=""_csrf"" content=""4bfd1575-3ad1-4d21-96c7-4ef2d9f86721""/> <meta name=""_csrf_header"" content=""X-CSRF-TOKEN""/> <!-- ... --> </head> <!-- ... --> Once the meta tags contain the CSRF token, the JavaScript code can read the meta tags and include the CSRF token as a header. If you use jQuery, you could read the meta tags with the following code: AJAX send CSRF Token $(function () { var token = $(""meta[name='_csrf']"").attr(""content""); var header = $(""meta[name='_csrf_header']"").attr(""content""); $(document).ajaxSend(function(e, xhr, options) { xhr.setRequestHeader(header, token); }); }); The following sample assumes that you expose(#webflux-csrf-include-subscribe) the CsrfToken on an attribute named _csrf . The following example does this with Thymeleaf: CSRF meta tag JSP <html> <head> <meta name=""_csrf"" th:content=""${_csrf.token}""/> <!-- default header name is X-CSRF-TOKEN --> <meta name=""_csrf_header"" th:content=""${_csrf.headerName}""/> <!-- ... --> </head> <!-- ... --> CSRF Considerations: There are a few special considerations to consider when implementing protection against CSRF attacks. This section discusses those considerations as it pertains to WebFlux environments. See CSRF Considerations(../../features/exploits/csrf.html#csrf-considerations) for a more general discussion. Logging In: You should require CSRF for login(../../features/exploits/csrf.html#csrf-considerations-login) requests to protect against forged login attempts. Spring Security’s WebFlux support automatically does this. Logging Out: You should require CSRF for logout(../../features/exploits/csrf.html#csrf-considerations-logout) requests to protect against forging logout attempts. By default, Spring Security’s LogoutWebFilter only processes only HTTP post requests. This ensures that logout requires a CSRF token and that a malicious user cannot forcibly log out your users. The easiest approach is to use a form to log out. If you really want a link, you can use JavaScript to have the link perform a POST (maybe on a hidden form). For browsers with JavaScript that is disabled, you can optionally have the link take the user to a logout confirmation page that performs the POST. If you really want to use HTTP GET with logout, you can do so, but remember that doing so is generally not recommended. For example, the following Java Configuration logs out when the /logout URL is requested with any HTTP method: Log out with HTTP GET Java Kotlin @Bean public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .logout(logout -> logout.requiresLogout(new PathPatternParserServerWebExchangeMatcher(""/logout""))) return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... logout { requiresLogout = PathPatternParserServerWebExchangeMatcher(""/logout"") } } } CSRF and Session Timeouts: By default, Spring Security stores the CSRF token in the WebSession . This arrangement can lead to a situation where the session expires, which means that there is not an expected CSRF token to validate against. We have already discussed general solutions(../../features/exploits/csrf.html#csrf-considerations-login) to session timeouts. This section discusses the specifics of CSRF timeouts as it pertains to the WebFlux support. You can change storage of the expected CSRF token to be in a cookie. For details, see the Custom CsrfTokenRepository(#webflux-csrf-configure-custom-repository) section. Multipart (file upload): We have already discussed(../../features/exploits/csrf.html#csrf-considerations-multipart) how protecting multipart requests (file uploads) from CSRF attacks causes a chicken and the egg(https://en.wikipedia.org/wiki/Chicken_or_the_egg) problem. This section discusses how to implement placing the CSRF token in the body(#webflux-csrf-considerations-multipart-body) and url(#webflux-csrf-considerations-multipart-url) within a WebFlux application. For more information about using multipart forms with Spring, see the Multipart Data(https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web-reactive.html#webflux-multipart) section of the Spring reference. Place CSRF Token in the Body: We have already discussed(../../features/exploits/csrf.html#csrf-considerations-multipart) the trade-offs of placing the CSRF token in the body. In a WebFlux application, you can do so with the following configuration: Enable obtaining CSRF token from multipart/form-data Java Kotlin @Bean public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .csrf(csrf -> csrf.tokenFromMultipartDataEnabled(true)) return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... csrf { tokenFromMultipartDataEnabled = true } } } Include CSRF Token in URL: We have already discussed(../../features/exploits/csrf.html#csrf-considerations-multipart) the trade-offs of placing the CSRF token in the URL. Since the CsrfToken is exposed as an ServerHttpRequest request attribute(#webflux-csrf-include) , we can use that to create an action with the CSRF token in it. An example with Thymeleaf is shown below: CSRF Token in Action <form method=""post"" th:action=""@{/upload(${_csrf.parameterName}=${_csrf.token})}"" enctype=""multipart/form-data""> HiddenHttpMethodFilter: We have already discussed(../../features/exploits/csrf.html#csrf-considerations-override-method) overriding the HTTP method. In a Spring WebFlux application, overriding the HTTP method is done by using HiddenHttpMethodFilter(https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html) ."
"https://docs.spring.io/spring-security/reference/6.3/reactive/exploits/headers.html","Security HTTP Response Headers: You can use Security HTTP Response Headers(../../features/exploits/headers.html#headers) to increase the security of web applications. This section is dedicated to WebFlux-based support for Security HTTP Response Headers. Default Security Headers: Spring Security provides a default set of Security HTTP Response Headers(../../features/exploits/headers.html#headers-default) to provide secure defaults. While each of these headers are considered best practice, it should be noted that not all clients use the headers, so additional testing is encouraged. You can customize specific headers. For example, assume that you want the defaults but you wish to specify SAMEORIGIN for X-Frame-Options(../../servlet/exploits/headers.html#servlet-headers-frame-options) . You can do so with the following configuration: Customize Default Security Headers Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers .frameOptions(frameOptions -> frameOptions .mode(Mode.SAMEORIGIN) ) ); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { frameOptions { mode = Mode.SAMEORIGIN } } } } If you do not want the defaults to be added and want explicit control over what should be used, you can disable the defaults: Disable HTTP Security Response Headers Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers.disable()); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { disable() } } } Cache Control: Spring Security includes Cache Control(../../features/exploits/headers.html#headers-cache-control) headers by default. However, if you actually want to cache specific responses, your application can selectively add them to the ServerHttpResponse(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/server/reactive/ServerHttpResponse.html) to override the header set by Spring Security. This is useful to ensure that such things as CSS, JavaScript, and images are properly cached. When using Spring WebFlux, you typically do so within your configuration. You can find details on how to do so in the Static Resources(https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-static-resources) portion of the Spring Reference documentation. If necessary, you can also disable Spring Security’s cache control HTTP response headers. Cache Control Disabled Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers .cache(cache -> cache.disable()) ); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { cache { disable() } } } } Content Type Options: By default, Spring Security includes Content-Type(../../features/exploits/headers.html#headers-content-type-options) headers. However, you can disable it: Content Type Options Disabled Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers .contentTypeOptions(contentTypeOptions -> contentTypeOptions.disable()) ); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { contentTypeOptions { disable() } } } } HTTP Strict Transport Security (HSTS): By default, Spring Security provides the Strict Transport Security(../../features/exploits/headers.html#headers-hsts) header. However, you can customize the results explicitly. For example, the following example explicitly provides HSTS: Strict Transport Security Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers .hsts(hsts -> hsts .includeSubdomains(true) .preload(true) .maxAge(Duration.ofDays(365)) ) ); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { hsts { includeSubdomains = true preload = true maxAge = Duration.ofDays(365) } } } } X-Frame-Options: By default, Spring Security disables rendering within an iframe by using X-Frame-Options(../../features/exploits/headers.html#headers-frame-options) . You can customize frame options to use the same origin: X-Frame-Options: SAMEORIGIN Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers .frameOptions(frameOptions -> frameOptions .mode(SAMEORIGIN) ) ); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { frameOptions { mode = SAMEORIGIN } } } } X-XSS-Protection: By default, Spring Security instructs browsers to disable the XSS Auditor by using <<headers-xss-protection,X-XSS-Protection header>. You can disable the X-XSS-Protection header entirely: X-XSS-Protection Customization Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers .xssProtection(xssProtection -> xssProtection.disable()) ); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { xssProtection { disable() } } } } You can also change the header value: X-XSS-Protection Explicit header value Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers .xssProtection(xssProtection -> xssProtection.headerValue(XXssProtectionServerHttpHeadersWriter.HeaderValue.ENABLED_MODE_BLOCK)) ); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { xssProtection { headerValue = XXssProtectionServerHttpHeadersWriter.HeaderValue.ENABLED_MODE_BLOCK } } } } Content Security Policy (CSP): By default, Spring Security does not add Content Security Policy(../../features/exploits/headers.html#headers-csp) , because a reasonable default is impossible to know without the context of the application. The web application author must declare the security policies to enforce and/or monitor for the protected resources. For example, consider the following security policy: Content Security Policy Example Content-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/ Given the preceding policy, you can enable the CSP header: Content Security Policy Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers .contentSecurityPolicy(policy -> policy .policyDirectives(""script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"") ) ); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { contentSecurityPolicy { policyDirectives = ""script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"" } } } } To enable the CSP report-only header, provide the following configuration: Content Security Policy Report Only Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers .contentSecurityPolicy(policy -> policy .policyDirectives(""script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"") .reportOnly() ) ); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { contentSecurityPolicy { policyDirectives = ""script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"" reportOnly = true } } } } Referrer Policy: Spring Security adds the Referrer Policy(../../features/exploits/headers.html#headers-referrer) header by default with the directive no-referrer . You can change the Referrer Policy header using configuration as shown below: Referrer Policy Configuration Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers .referrerPolicy(referrer -> referrer .policy(ReferrerPolicy.SAME_ORIGIN) ) ); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { referrerPolicy { policy = ReferrerPolicy.SAME_ORIGIN } } } } Feature Policy: By default, Spring Security does not add Feature Policy(../../features/exploits/headers.html#headers-feature) headers. Consider the following Feature-Policy header: Feature-Policy Example Feature-Policy: geolocation 'self' You can enable the preceding Feature Policy header: Feature-Policy Configuration Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers .featurePolicy(""geolocation 'self'"") ); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { featurePolicy(""geolocation 'self'"") } } } Permissions Policy: By default, Spring Security does not add Permissions Policy(../../features/exploits/headers.html#headers-permissions) headers. Consider the following Permissions-Policy header: Permissions-Policy Example Permissions-Policy: geolocation=(self) You can enable the preceding Permissions Policy header: Permissions-Policy Configuration Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .headers(headers -> headers .permissionsPolicy(permissions -> permissions .policy(""geolocation=(self)"") ) ); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... headers { permissionsPolicy { policy = ""geolocation=(self)"" } } } } Clear Site Data: By default, Spring Security does not add Clear-Site-Data(../../features/exploits/headers.html#headers-clear-site-data) headers. Consider the following Clear-Site-Data header: Clear-Site-Data Example Clear-Site-Data: ""cache"", ""cookies"" You can send the Clear-Site-Data header on logout: Clear-Site-Data Configuration Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { ServerLogoutHandler securityContext = new SecurityContextServerLogoutHandler(); ClearSiteDataServerHttpHeadersWriter writer = new ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES); ServerLogoutHandler clearSiteData = new HeaderWriterServerLogoutHandler(writer); DelegatingServerLogoutHandler logoutHandler = new DelegatingServerLogoutHandler(securityContext, clearSiteData); http // ... .logout() .logoutHandler(logoutHandler); return http.build(); } @Bean fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { val securityContext: ServerLogoutHandler = SecurityContextServerLogoutHandler() val writer = ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES) val clearSiteData: ServerLogoutHandler = HeaderWriterServerLogoutHandler(writer) val customLogoutHandler = DelegatingServerLogoutHandler(securityContext, clearSiteData) return http { // ... logout { logoutHandler = customLogoutHandler } } }"
"https://docs.spring.io/spring-security/reference/6.3/reactive/exploits/http.html","HTTP: All HTTP-based communication should be protected with using TLS(../../features/exploits/http.html#http) . This section covers details about using WebFlux-specific features that assist with HTTPS usage. Redirect to HTTPS: If a client makes a request using HTTP rather than HTTPS, you can configure Spring Security to redirect to HTTPS. The following Java configuration redirects any HTTP requests to HTTPS: Redirect to HTTPS Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .redirectToHttps(withDefaults()); return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... redirectToHttps { } } } You can wrap the configuration can be wrapped around an if statement to be turned on only in production. Alternatively, you can enable it by looking for a property about the request that happens only in production. For example, if the production environment adds a header named X-Forwarded-Proto , you should use the following Java Configuration: Redirect to HTTPS when X-Forwarded Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .redirectToHttps(redirect -> redirect .httpsRedirectWhen(e -> e.getRequest().getHeaders().containsKey(""X-Forwarded-Proto"")) ); return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... redirectToHttps { httpsRedirectWhen { it.request.headers.containsKey(""X-Forwarded-Proto"") } } } } Strict Transport Security: Spring Security provides support for Strict Transport Security(../../servlet/exploits/headers.html#servlet-headers-hsts) and enables it by default. Proxy Server Configuration: Spring Security integrates with proxy servers(../../features/exploits/http.html#http-proxy-server) ."
"https://docs.spring.io/spring-security/reference/6.3/reactive/integrations/cors.html","CORS: Spring Framework provides first class support for CORS(https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-cors-intro) . CORS must be processed before Spring Security because the pre-flight request will not contain any cookies (i.e. the JSESSIONID ). If the request does not contain any cookies and Spring Security is first, the request will determine the user is not authenticated (since there are no cookies in the request) and reject it. The easiest way to ensure that CORS is handled first is to use the CorsWebFilter . Users can integrate the CorsWebFilter with Spring Security by providing a CorsConfigurationSource . For example, the following will integrate CORS support within Spring Security: Java Kotlin @Bean CorsConfigurationSource corsConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOrigins(Arrays.asList(""https://example.com"")); configuration.setAllowedMethods(Arrays.asList(""GET"",""POST"")); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(""/**"", configuration); return source; } @Bean fun corsConfigurationSource(): CorsConfigurationSource { val configuration = CorsConfiguration() configuration.allowedOrigins = listOf(""https://example.com"") configuration.allowedMethods = listOf(""GET"", ""POST"") val source = UrlBasedCorsConfigurationSource() source.registerCorsConfiguration(""/**"", configuration) return source } The following will disable the CORS integration within Spring Security: Java Kotlin @Bean SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http // ... .cors(cors -> cors.disable()); return http.build(); } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // ... cors { disable() } } }"
"https://docs.spring.io/spring-security/reference/6.3/reactive/integrations/rsocket.html","RSocket Security: Spring Security’s RSocket support relies on a SocketAcceptorInterceptor . The main entry point into security is in PayloadSocketAcceptorInterceptor , which adapts the RSocket APIs to allow intercepting a PayloadExchange with PayloadInterceptor implementations. The following example shows a minimal RSocket Security configuration: Hello RSocket hellorsocket(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/reactive/rsocket/hello-security) Spring Flights(https://github.com/rwinch/spring-flights/tree/security) Minimal RSocket Security Configuration: You can find a minimal RSocket Security configuration below: Java Kotlin @Configuration @EnableRSocketSecurity public class HelloRSocketSecurityConfig { @Bean public MapReactiveUserDetailsService userDetailsService() { UserDetails user = User.withDefaultPasswordEncoder() .username(""user"") .password(""user"") .roles(""USER"") .build(); return new MapReactiveUserDetailsService(user); } } @Configuration @EnableRSocketSecurity open class HelloRSocketSecurityConfig { @Bean open fun userDetailsService(): MapReactiveUserDetailsService { val user = User.withDefaultPasswordEncoder() .username(""user"") .password(""user"") .roles(""USER"") .build() return MapReactiveUserDetailsService(user) } } This configuration enables simple authentication(#rsocket-authentication-simple) and sets up rsocket-authorization(#rsocket-authorization) to require an authenticated user for any request. Adding SecuritySocketAcceptorInterceptor: For Spring Security to work, we need to apply SecuritySocketAcceptorInterceptor to the ServerRSocketFactory . Doing so connects our PayloadSocketAcceptorInterceptor with the RSocket infrastructure. Spring Boot registers it automatically in RSocketSecurityAutoConfiguration when you include the correct dependencies(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/reactive/rsocket/hello-security/build.gradle) . Or, if you are not using Boot’s auto-configuration, you can register it manually in the following way: Java Kotlin @Bean RSocketServerCustomizer springSecurityRSocketSecurity(SecuritySocketAcceptorInterceptor interceptor) { return (server) -> server.interceptors((registry) -> registry.forSocketAcceptor(interceptor)); } @Bean fun springSecurityRSocketSecurity(interceptor: SecuritySocketAcceptorInterceptor): RSocketServerCustomizer { return RSocketServerCustomizer { server -> server.interceptors { registry -> registry.forSocketAcceptor(interceptor) } } } To customize the interceptor itself, use RSocketSecurity to add authentication(#rsocket-authentication) and authorization(#rsocket-authorization) . RSocket Authentication: RSocket authentication is performed with AuthenticationPayloadInterceptor , which acts as a controller to invoke a ReactiveAuthenticationManager instance. Authentication at Setup versus Request Time: Generally, authentication can occur at setup time or at request time or both. Authentication at setup time makes sense in a few scenarios. A common scenarios is when a single user (such as a mobile connection) uses an RSocket connection. In this case, only a single user uses the connection, so authentication can be done once at connection time. In a scenario where the RSocket connection is shared, it makes sense to send credentials on each request. For example, a web application that connects to an RSocket server as a downstream service would make a single connection that all users use. In this case, if the RSocket server needs to perform authorization based on the web application’s users credentials, authentication for each request makes sense. In some scenarios, authentication at both setup and for each request makes sense. Consider a web application, as described previously. If we need to restrict the connection to the web application itself, we can provide a credential with a SETUP authority at connection time. Then each user can have different authorities but not the SETUP authority. This means that individual users can make requests but not make additional connections. Simple Authentication: Spring Security has support for the Simple Authentication Metadata Extension(https://github.com/rsocket/rsocket/blob/5920ed374d008abb712cb1fd7c9d91778b2f4a68/Extensions/Security/Simple.md) . Basic Authentication evolved into Simple Authentication and is only supported for backward compatibility. See RSocketSecurity.basicAuthentication(Customizer) for setting it up. The RSocket receiver can decode the credentials by using AuthenticationPayloadExchangeConverter , which is automatically setup by using the simpleAuthentication portion of the DSL. The following example shows an explicit configuration: Java Kotlin @Bean PayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) { rsocket .authorizePayload(authorize -> authorize .anyRequest().authenticated() .anyExchange().permitAll() ) .simpleAuthentication(Customizer.withDefaults()); return rsocket.build(); } @Bean open fun rsocketInterceptor(rsocket: RSocketSecurity): PayloadSocketAcceptorInterceptor { rsocket .authorizePayload { authorize -> authorize .anyRequest().authenticated() .anyExchange().permitAll() } .simpleAuthentication(withDefaults()) return rsocket.build() } The RSocket sender can send credentials by using SimpleAuthenticationEncoder , which you can add to Spring’s RSocketStrategies . Java Kotlin RSocketStrategies.Builder strategies = ...; strategies.encoder(new SimpleAuthenticationEncoder()); var strategies: RSocketStrategies.Builder = ... strategies.encoder(SimpleAuthenticationEncoder()) You can then use it to send a username and password to the receiver in the setup: Java Kotlin MimeType authenticationMimeType = MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString()); UsernamePasswordMetadata credentials = new UsernamePasswordMetadata(""user"", ""password""); Mono<RSocketRequester> requester = RSocketRequester.builder() .setupMetadata(credentials, authenticationMimeType) .rsocketStrategies(strategies.build()) .connectTcp(host, port); val authenticationMimeType: MimeType = MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.string) val credentials = UsernamePasswordMetadata(""user"", ""password"") val requester: Mono<RSocketRequester> = RSocketRequester.builder() .setupMetadata(credentials, authenticationMimeType) .rsocketStrategies(strategies.build()) .connectTcp(host, port) Alternatively or additionally, a username and password can be sent in a request. Java Kotlin Mono<RSocketRequester> requester; UsernamePasswordMetadata credentials = new UsernamePasswordMetadata(""user"", ""password""); public Mono<AirportLocation> findRadar(String code) { return this.requester.flatMap(req -> req.route(""find.radar.{code}"", code) .metadata(credentials, authenticationMimeType) .retrieveMono(AirportLocation.class) ); } import org.springframework.messaging.rsocket.retrieveMono // ... var requester: Mono<RSocketRequester>? = null var credentials = UsernamePasswordMetadata(""user"", ""password"") open fun findRadar(code: String): Mono<AirportLocation> { return requester!!.flatMap { req -> req.route(""find.radar.{code}"", code) .metadata(credentials, authenticationMimeType) .retrieveMono<AirportLocation>() } } JWT: Spring Security has support for the Bearer Token Authentication Metadata Extension(https://github.com/rsocket/rsocket/blob/5920ed374d008abb712cb1fd7c9d91778b2f4a68/Extensions/Security/Bearer.md) . The support comes in the form of authenticating a JWT (determining that the JWT is valid) and then using the JWT to make authorization decisions. The RSocket receiver can decode the credentials by using BearerPayloadExchangeConverter , which is automatically setup by using the jwt portion of the DSL. The following listing shows an example configuration: Java Kotlin @Bean PayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) { rsocket .authorizePayload(authorize -> authorize .anyRequest().authenticated() .anyExchange().permitAll() ) .jwt(Customizer.withDefaults()); return rsocket.build(); } @Bean fun rsocketInterceptor(rsocket: RSocketSecurity): PayloadSocketAcceptorInterceptor { rsocket .authorizePayload { authorize -> authorize .anyRequest().authenticated() .anyExchange().permitAll() } .jwt(withDefaults()) return rsocket.build() } The configuration above relies on the existence of a ReactiveJwtDecoder @Bean being present. An example of creating one from the issuer can be found below: Java Kotlin @Bean ReactiveJwtDecoder jwtDecoder() { return ReactiveJwtDecoders .fromIssuerLocation(""https://example.com/auth/realms/demo""); } @Bean fun jwtDecoder(): ReactiveJwtDecoder { return ReactiveJwtDecoders .fromIssuerLocation(""https://example.com/auth/realms/demo"") } The RSocket sender does not need to do anything special to send the token, because the value is a simple String . The following example sends the token at setup time: Java Kotlin MimeType authenticationMimeType = MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString()); BearerTokenMetadata token = ...; Mono<RSocketRequester> requester = RSocketRequester.builder() .setupMetadata(token, authenticationMimeType) .connectTcp(host, port); val authenticationMimeType: MimeType = MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.string) val token: BearerTokenMetadata = ... val requester = RSocketRequester.builder() .setupMetadata(token, authenticationMimeType) .connectTcp(host, port) Alternatively or additionally, you can send the token in a request: Java Kotlin MimeType authenticationMimeType = MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString()); Mono<RSocketRequester> requester; BearerTokenMetadata token = ...; public Mono<AirportLocation> findRadar(String code) { return this.requester.flatMap(req -> req.route(""find.radar.{code}"", code) .metadata(token, authenticationMimeType) .retrieveMono(AirportLocation.class) ); } val authenticationMimeType: MimeType = MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.string) var requester: Mono<RSocketRequester>? = null val token: BearerTokenMetadata = ... open fun findRadar(code: String): Mono<AirportLocation> { return this.requester!!.flatMap { req -> req.route(""find.radar.{code}"", code) .metadata(token, authenticationMimeType) .retrieveMono<AirportLocation>() } } RSocket Authorization: RSocket authorization is performed with AuthorizationPayloadInterceptor , which acts as a controller to invoke a ReactiveAuthorizationManager instance. You can use the DSL to set up authorization rules based upon the PayloadExchange . The following listing shows an example configuration: Java Kotlin rsocket .authorizePayload(authz -> authz .setup().hasRole(""SETUP"") (1) .route(""fetch.profile.me"").authenticated() (2) .matcher(payloadExchange -> isMatch(payloadExchange)) (3) .hasRole(""CUSTOM"") .route(""fetch.profile.{username}"") (4) .access((authentication, context) -> checkFriends(authentication, context)) .anyRequest().authenticated() (5) .anyExchange().permitAll() (6) ); rsocket .authorizePayload { authz -> authz .setup().hasRole(""SETUP"") (1) .route(""fetch.profile.me"").authenticated() (2) .matcher { payloadExchange -> isMatch(payloadExchange) } (3) .hasRole(""CUSTOM"") .route(""fetch.profile.{username}"") (4) .access { authentication, context -> checkFriends(authentication, context) } .anyRequest().authenticated() (5) .anyExchange().permitAll() } (6) 1 Setting up a connection requires the ROLE_SETUP authority. 2 If the route is fetch.profile.me , authorization only requires the user to be authenticated. 3 In this rule, we set up a custom matcher, where authorization requires the user to have the ROLE_CUSTOM authority. 4 This rule uses custom authorization. The matcher expresses a variable with a name of username that is made available in the context . A custom authorization rule is exposed in the checkFriends method. 5 This rule ensures that a request that does not already have a rule requires the user to be authenticated. A request is where the metadata is included. It would not include additional payloads. 6 This rule ensures that any exchange that does not already have a rule is allowed for anyone. In this example, it means that payloads that have no metadata also have no authorization rules. Note that authorization rules are performed in order. Only the first authorization rule that matches is invoked."
"https://docs.spring.io/spring-security/reference/6.3/reactive/integrations/observability.html","Observability: Spring Security integrates with Spring Observability out-of-the-box for tracing; though it’s also quite simple to configure for gathering metrics. Tracing: When an ObservationRegistry bean is present, Spring Security creates traces for: the filter chain the ReactiveAuthenticationManager , and the ReactiveAuthorizationManager Boot Integration: For example, consider a simple Boot application: Java Kotlin @SpringBootApplication public class MyApplication { @Bean public ReactiveUserDetailsService userDetailsService() { return new MapReactiveUserDetailsManager( User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .authorities(""app"") .build() ); } @Bean ObservationRegistryCustomizer<ObservationRegistry> addTextHandler() { return (registry) -> registry.observationConfig().observationHandler(new ObservationTextPublisher()); } public static void main(String[] args) { SpringApplication.run(ListenerSamplesApplication.class, args); } } @SpringBootApplication class MyApplication { @Bean fun userDetailsService(): ReactiveUserDetailsService { MapReactiveUserDetailsManager( User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .authorities(""app"") .build() ); } @Bean fun addTextHandler(): ObservationRegistryCustomizer<ObservationRegistry> { return registry: ObservationRegistry -> registry.observationConfig() .observationHandler(ObservationTextPublisher()); } fun main(args: Array<String>) { runApplication<MyApplication>(*args) } } And a corresponding request: ?> http -a user:password :8080 Will produce the following output (indentation added for clarity): START - name='http.server.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@5dfdb78', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.00191856, duration(nanos)=1918560.0, startTimeNanos=101177265022745}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@121549e0'] START - name='spring.security.http.chains', contextualName='spring.security.http.chains.before', error='null', lowCardinalityKeyValues=[chain.size='14', filter.section='before'], highCardinalityKeyValues=[request.line='/'], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@3932a48c', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=4.65777E-4, duration(nanos)=465777.0, startTimeNanos=101177276300777}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@562db70f'] STOP - name='spring.security.http.chains', contextualName='spring.security.http.chains.before', error='null', lowCardinalityKeyValues=[chain.size='14', filter.section='before'], highCardinalityKeyValues=[request.line='/'], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@3932a48c', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.003733105, duration(nanos)=3733105.0, startTimeNanos=101177276300777}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@562db70f'] START - name='spring.security.authentications', contextualName='null', error='null', lowCardinalityKeyValues=[authentication.failure.type='Optional', authentication.method='UserDetailsRepositoryReactiveAuthenticationManager', authentication.request.type='UsernamePasswordAuthenticationToken'], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@574ba6cd', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=3.21015E-4, duration(nanos)=321015.0, startTimeNanos=101177336038417}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@49202cc7'] STOP - name='spring.security.authentications', contextualName='null', error='null', lowCardinalityKeyValues=[authentication.failure.type='Optional', authentication.method='UserDetailsRepositoryReactiveAuthenticationManager', authentication.request.type='UsernamePasswordAuthenticationToken', authentication.result.type='UsernamePasswordAuthenticationToken'], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@574ba6cd', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.37574992, duration(nanos)=3.7574992E8, startTimeNanos=101177336038417}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@49202cc7'] START - name='spring.security.authorizations', contextualName='null', error='null', lowCardinalityKeyValues=[object.type='SecurityContextServerWebExchange'], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@6f837332', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=2.65687E-4, duration(nanos)=265687.0, startTimeNanos=101177777941381}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@7f5bc7cb'] STOP - name='spring.security.authorizations', contextualName='null', error='null', lowCardinalityKeyValues=[authorization.decision='true', object.type='SecurityContextServerWebExchange'], highCardinalityKeyValues=[authentication.authorities='[app]', authorization.decision.details='AuthorizationDecision [granted=true]'], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@6f837332', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.039239047, duration(nanos)=3.9239047E7, startTimeNanos=101177777941381}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@7f5bc7cb'] START - name='spring.security.http.secured.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@2f33dfae', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=3.1775E-4, duration(nanos)=317750.0, startTimeNanos=101177821377592}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@63b0d28f'] STOP - name='spring.security.http.secured.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@2f33dfae', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.219901971, duration(nanos)=2.19901971E8, startTimeNanos=101177821377592}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@63b0d28f'] START - name='spring.security.http.chains', contextualName='spring.security.http.chains.after', error='null', lowCardinalityKeyValues=[chain.size='14', filter.section='after'], highCardinalityKeyValues=[request.line='/'], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@40b25623', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=3.25118E-4, duration(nanos)=325118.0, startTimeNanos=101178044824275}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@3b6cec2'] STOP - name='spring.security.http.chains', contextualName='spring.security.http.chains.after', error='null', lowCardinalityKeyValues=[chain.size='14', filter.section='after'], highCardinalityKeyValues=[request.line='/'], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@40b25623', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.001693146, duration(nanos)=1693146.0, startTimeNanos=101178044824275}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@3b6cec2'] STOP - name='http.server.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@5dfdb78', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.784320641, duration(nanos)=7.84320641E8, startTimeNanos=101177265022745}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@121549e0'] Manual Configuration: For a non-Spring Boot application, or to override the existing Boot configuration, you can publish your own ObservationRegistry and Spring Security will still pick it up. Java Kotlin Xml @SpringBootApplication public class MyApplication { @Bean public ReactiveUserDetailsService userDetailsService() { return new MapReactiveUserDetailsManager( User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .authorities(""app"") .build() ); } @Bean ObservationRegistry<ObservationRegistry> observationRegistry() { ObservationRegistry registry = ObservationRegistry.create(); registry.observationConfig().observationHandler(new ObservationTextPublisher()); return registry; } public static void main(String[] args) { SpringApplication.run(ListenerSamplesApplication.class, args); } } @SpringBootApplication class MyApplication { @Bean fun userDetailsService(): ReactiveUserDetailsService { MapReactiveUserDetailsManager( User.withDefaultPasswordEncoder() .username(""user"") .password(""password"") .authorities(""app"") .build() ); } @Bean fun observationRegistry(): ObservationRegistry<ObservationRegistry> { ObservationRegistry registry = ObservationRegistry.create() registry.observationConfig().observationHandler(ObservationTextPublisher()) return registry } fun main(args: Array<String>) { runApplication<MyApplication>(*args) } } <sec:http auto-config=""true"" observation-registry-ref=""ref""> <sec:intercept-url pattern=""/**"" access=""authenticated""/> </sec:http> <!-- define and configure ObservationRegistry bean --> Disabling Observability: If you don’t want any Spring Security observations, in a Spring Boot application you can publish a ObservationRegistry.NOOP @Bean . However, this may turn off observations for more than just Spring Security. Instead, you can alter the provided ObservationRegistry with an ObservationPredicate like the following: Java Kotlin @Bean ObservationRegistryCustomizer<ObservationRegistry> noSpringSecurityObservations() { ObservationPredicate predicate = (name, context) -> !name.startsWith(""spring.security.""); return (registry) -> registry.observationConfig().observationPredicate(predicate); } @Bean fun noSpringSecurityObservations(): ObservationRegistryCustomizer<ObservationRegistry> { ObservationPredicate predicate = (name: String, context: Observation.Context) -> !name.startsWith(""spring.security."") (registry: ObservationRegistry) -> registry.observationConfig().observationPredicate(predicate) } There is no facility for disabling observations with XML support. Instead, simply do not set the observation-registry-ref attribute. Trace Listing: Spring Security tracks the following spans on each request: spring.security.http.requests - a span that wraps the entire filter chain, including the request spring.security.http.chains.before - a span that wraps the receiving part of the security filters spring.security.http.chains.after - a span that wraps the returning part of the security filters spring.security.http.secured.requests - a span that wraps the now-secured application request spring.security.http.unsecured.requests - a span that wraps requests that Spring Security does not secure spring.security.authentications - a span that wraps authentication attempts spring.security.authorizations - a span that wraps authorization attempts spring.security.http.chains.before + spring.security.http.secured.requests + spring.security.http.chains.after = spring.security.http.requests spring.security.http.chains.before + spring.security.http.chains.after = Spring Security’s part of the request"
"https://docs.spring.io/spring-security/reference/6.3/reactive/test/index.html","Reactive Test Support: Spring Security supports two basic modes for testing reactive applications. Section Summary: Testing Method Security(method.html) Testing Web Security(web/index.html)"
"https://docs.spring.io/spring-security/reference/6.3/reactive/test/method.html","Testing Method Security: For example, we can test our example from EnableReactiveMethodSecurity(../authorization/method.html#jc-erms) by using the same setup and annotations that we used in Testing Method Security(../../servlet/test/method.html#test-method) . The following minimal sample shows what we can do: Java Kotlin @ExtendWith(SpringExtension.class) @ContextConfiguration(classes = HelloWebfluxMethodApplication.class) public class HelloWorldMessageServiceTests { @Autowired HelloWorldMessageService messages; @Test public void messagesWhenNotAuthenticatedThenDenied() { StepVerifier.create(this.messages.findMessage()) .expectError(AccessDeniedException.class) .verify(); } @Test @WithMockUser public void messagesWhenUserThenDenied() { StepVerifier.create(this.messages.findMessage()) .expectError(AccessDeniedException.class) .verify(); } @Test @WithMockUser(roles = ""ADMIN"") public void messagesWhenAdminThenOk() { StepVerifier.create(this.messages.findMessage()) .expectNext(""Hello World!"") .verifyComplete(); } } @ExtendWith(SpringExtension.class) @ContextConfiguration(classes = [HelloWebfluxMethodApplication::class]) class HelloWorldMessageServiceTests { @Autowired lateinit var messages: HelloWorldMessageService @Test fun messagesWhenNotAuthenticatedThenDenied() { StepVerifier.create(messages.findMessage()) .expectError(AccessDeniedException::class.java) .verify() } @Test @WithMockUser fun messagesWhenUserThenDenied() { StepVerifier.create(messages.findMessage()) .expectError(AccessDeniedException::class.java) .verify() } @Test @WithMockUser(roles = [""ADMIN""]) fun messagesWhenAdminThenOk() { StepVerifier.create(messages.findMessage()) .expectNext(""Hello World!"") .verifyComplete() } }"
"https://docs.spring.io/spring-security/reference/6.3/reactive/test/web/index.html","Testing Web Security: In this section, we’ll talk about testing web application endpoints. Section Summary: WebTestClient Setup(setup.html) Testing Authentication(authentication.html) Testing CSRF(csrf.html) Testing OAuth 2.0(oauth2.html)"
"https://docs.spring.io/spring-security/reference/6.3/reactive/test/web/setup.html","WebTestClient Security Setup: The basic setup looks like this: Java Kotlin import static org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.springSecurity; import static org.springframework.web.reactive.function.client.ExchangeFilterFunctions.basicAuthentication; @ExtendWith(SpringExtension.class) @ContextConfiguration(classes = HelloWebfluxMethodApplication.class) public class HelloWebfluxMethodApplicationTests { @Autowired ApplicationContext context; WebTestClient rest; @BeforeEach public void setup() { this.rest = WebTestClient .bindToApplicationContext(this.context) // add Spring Security test Support .apply(springSecurity()) .configureClient() .filter(basicAuthentication(""user"", ""password"")) .build(); } // ... } import org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.springSecurity import org.springframework.web.reactive.function.client.ExchangeFilterFunctions.basicAuthentication @ExtendWith(SpringExtension::class) @ContextConfiguration(classes = [HelloWebfluxMethodApplication::class]) class HelloWebfluxMethodApplicationTests { @Autowired lateinit var context: ApplicationContext lateinit var rest: WebTestClient @BeforeEach fun setup() { this.rest = WebTestClient .bindToApplicationContext(this.context) // add Spring Security test Support .apply(springSecurity()) .configureClient() .filter(basicAuthentication(""user"", ""password"")) .build() } // ... }"
"https://docs.spring.io/spring-security/reference/6.3/reactive/test/web/authentication.html","Testing Authentication: After applying the Spring Security support to WebTestClient(setup.html) , we can use either annotations or mutateWith support — for example: Java Kotlin import static org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.mockUser; @Test public void messageWhenNotAuthenticated() throws Exception { this.rest .get() .uri(""/message"") .exchange() .expectStatus().isUnauthorized(); } // --- WithMockUser --- @Test @WithMockUser public void messageWhenWithMockUserThenForbidden() throws Exception { this.rest .get() .uri(""/message"") .exchange() .expectStatus().isEqualTo(HttpStatus.FORBIDDEN); } @Test @WithMockUser(roles = ""ADMIN"") public void messageWhenWithMockAdminThenOk() throws Exception { this.rest .get() .uri(""/message"") .exchange() .expectStatus().isOk() .expectBody(String.class).isEqualTo(""Hello World!""); } // --- mutateWith mockUser --- @Test public void messageWhenMutateWithMockUserThenForbidden() throws Exception { this.rest .mutateWith(mockUser()) .get() .uri(""/message"") .exchange() .expectStatus().isEqualTo(HttpStatus.FORBIDDEN); } @Test public void messageWhenMutateWithMockAdminThenOk() throws Exception { this.rest .mutateWith(mockUser().roles(""ADMIN"")) .get() .uri(""/message"") .exchange() .expectStatus().isOk() .expectBody(String.class).isEqualTo(""Hello World!""); } import org.springframework.test.web.reactive.server.expectBody import org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.mockUser //... @Test @WithMockUser fun messageWhenWithMockUserThenForbidden() { this.rest.get().uri(""/message"") .exchange() .expectStatus().isEqualTo(HttpStatus.FORBIDDEN) } @Test @WithMockUser(roles = [""ADMIN""]) fun messageWhenWithMockAdminThenOk() { this.rest.get().uri(""/message"") .exchange() .expectStatus().isOk .expectBody<String>().isEqualTo(""Hello World!"") } // --- mutateWith mockUser --- @Test fun messageWhenMutateWithMockUserThenForbidden() { this.rest .mutateWith(mockUser()) .get().uri(""/message"") .exchange() .expectStatus().isEqualTo(HttpStatus.FORBIDDEN) } @Test fun messageWhenMutateWithMockAdminThenOk() { this.rest .mutateWith(mockUser().roles(""ADMIN"")) .get().uri(""/message"") .exchange() .expectStatus().isOk .expectBody<String>().isEqualTo(""Hello World!"") } In addition to mockUser() , Spring Security ships with several other convenience mutators for things like CSRF(csrf.html) and OAuth 2.0(oauth2.html) ."
"https://docs.spring.io/spring-security/reference/6.3/reactive/test/web/csrf.html","Testing with CSRF: Spring Security also provides support for CSRF testing with WebTestClient — for example: Java Kotlin import static org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.csrf; this.rest // provide a valid CSRF token .mutateWith(csrf()) .post() .uri(""/login"") ... import org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.csrf this.rest // provide a valid CSRF token .mutateWith(csrf()) .post() .uri(""/login"") ..."
"https://docs.spring.io/spring-security/reference/6.3/reactive/test/web/oauth2.html","Testing OAuth 2.0: When it comes to OAuth 2.0, the same principles covered earlier still apply(../method.html#test-erms) : Ultimately, it depends on what your method under test is expecting to be in the SecurityContextHolder . Consider the following example of a controller: Java Kotlin @GetMapping(""/endpoint"") public Mono<String> foo(Principal user) { return Mono.just(user.getName()); } @GetMapping(""/endpoint"") fun foo(user: Principal): Mono<String> { return Mono.just(user.name) } Nothing about it is OAuth2-specific, so you can use @WithMockUser(../method.html#test-erms) and be fine. However, consider a case where your controller is bound to some aspect of Spring Security’s OAuth 2.0 support: Java Kotlin @GetMapping(""/endpoint"") public Mono<String> foo(@AuthenticationPrincipal OidcUser user) { return Mono.just(user.getIdToken().getSubject()); } @GetMapping(""/endpoint"") fun foo(@AuthenticationPrincipal user: OidcUser): Mono<String> { return Mono.just(user.idToken.subject) } In that case, Spring Security’s test support is handy. Testing OIDC Login: Testing the method shown in the preceding section(#webflux-testing-oauth2) with WebTestClient requires simulating some kind of grant flow with an authorization server. This is a daunting task, which is why Spring Security ships with support for removing this boilerplate. For example, we can tell Spring Security to include a default OidcUser by using the SecurityMockServerConfigurers#oidcLogin method: Java Kotlin client .mutateWith(mockOidcLogin()).get().uri(""/endpoint"").exchange(); client .mutateWith(mockOidcLogin()) .get().uri(""/endpoint"") .exchange() That line configures the associated MockServerRequest with an OidcUser that includes a simple OidcIdToken , an OidcUserInfo , and a Collection of granted authorities. Specifically, it includes an OidcIdToken with a sub claim set to user : Java Kotlin assertThat(user.getIdToken().getClaim(""sub"")).isEqualTo(""user""); assertThat(user.idToken.getClaim<String>(""sub"")).isEqualTo(""user"") It also includes an OidcUserInfo with no claims set: Java Kotlin assertThat(user.getUserInfo().getClaims()).isEmpty(); assertThat(user.userInfo.claims).isEmpty() It also includes a Collection of authorities with just one authority, SCOPE_read : Java Kotlin assertThat(user.getAuthorities()).hasSize(1); assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority(""SCOPE_read"")); assertThat(user.authorities).hasSize(1) assertThat(user.authorities).containsExactly(SimpleGrantedAuthority(""SCOPE_read"")) Spring Security makes sure that the OidcUser instance is available for the @AuthenticationPrincipal annotation(../../../servlet/integrations/mvc.html#mvc-authentication-principal) . Further, it also links the OidcUser to a simple instance of OAuth2AuthorizedClient that it deposits into a mock ServerOAuth2AuthorizedClientRepository . This can be handy if your tests use the @RegisteredOAuth2AuthorizedClient annotation(#webflux-testing-oauth2-client) .. Configuring Authorities: In many circumstances, your method is protected by filter or method security and needs your Authentication to have certain granted authorities to allow the request. In those cases, you can supply what granted authorities you need by using the authorities() method: Java Kotlin client .mutateWith(mockOidcLogin() .authorities(new SimpleGrantedAuthority(""SCOPE_message:read"")) ) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockOidcLogin() .authorities(SimpleGrantedAuthority(""SCOPE_message:read"")) ) .get().uri(""/endpoint"").exchange() Configuring Claims: While granted authorities are common across all of Spring Security, we also have claims in the case of OAuth 2.0. Suppose, for example, that you have a user_id claim that indicates the user’s ID in your system. You might access it as follows in a controller: Java Kotlin @GetMapping(""/endpoint"") public Mono<String> foo(@AuthenticationPrincipal OidcUser oidcUser) { String userId = oidcUser.getIdToken().getClaim(""user_id""); // ... } @GetMapping(""/endpoint"") fun foo(@AuthenticationPrincipal oidcUser: OidcUser): Mono<String> { val userId = oidcUser.idToken.getClaim<String>(""user_id"") // ... } In that case, you can specify that claim with the idToken() method: Java Kotlin client .mutateWith(mockOidcLogin() .idToken(token -> token.claim(""user_id"", ""1234"")) ) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockOidcLogin() .idToken { token -> token.claim(""user_id"", ""1234"") } ) .get().uri(""/endpoint"").exchange() That works because OidcUser collects its claims from OidcIdToken . Additional Configurations: There are additional methods, too, for further configuring the authentication, depending on what data your controller expects: userInfo(OidcUserInfo.Builder) : Configures the OidcUserInfo instance clientRegistration(ClientRegistration) : Configures the associated OAuth2AuthorizedClient with a given ClientRegistration oidcUser(OidcUser) : Configures the complete OidcUser instance That last one is handy if you: * Have your own implementation of OidcUser or * Need to change the name attribute For example, suppose that your authorization server sends the principal name in the user_name claim instead of the sub claim. In that case, you can configure an OidcUser by hand: Java Kotlin OidcUser oidcUser = new DefaultOidcUser( AuthorityUtils.createAuthorityList(""SCOPE_message:read""), OidcIdToken.withTokenValue(""id-token"").claim(""user_name"", ""foo_user"").build(), ""user_name""); client .mutateWith(mockOidcLogin().oidcUser(oidcUser)) .get().uri(""/endpoint"").exchange(); val oidcUser: OidcUser = DefaultOidcUser( AuthorityUtils.createAuthorityList(""SCOPE_message:read""), OidcIdToken.withTokenValue(""id-token"").claim(""user_name"", ""foo_user"").build(), ""user_name"" ) client .mutateWith(mockOidcLogin().oidcUser(oidcUser)) .get().uri(""/endpoint"").exchange() Testing OAuth 2.0 Login: As with testing OIDC login(#webflux-testing-oidc-login) , testing OAuth 2.0 Login presents a similar challenge: mocking a grant flow. Because of that, Spring Security also has test support for non-OIDC use cases. Suppose that we have a controller that gets the logged-in user as an OAuth2User : Java Kotlin @GetMapping(""/endpoint"") public Mono<String> foo(@AuthenticationPrincipal OAuth2User oauth2User) { return Mono.just(oauth2User.getAttribute(""sub"")); } @GetMapping(""/endpoint"") fun foo(@AuthenticationPrincipal oauth2User: OAuth2User): Mono<String> { return Mono.just(oauth2User.getAttribute(""sub"")) } In that case, we can tell Spring Security to include a default OAuth2User by using the SecurityMockServerConfigurers#oauth2User method: Java Kotlin client .mutateWith(mockOAuth2Login()) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockOAuth2Login()) .get().uri(""/endpoint"").exchange() The preceding example configures the associated MockServerRequest with an OAuth2User that includes a simple Map of attributes and a Collection of granted authorities. Specifically, it includes a Map with a key/value pair of sub / user : Java Kotlin assertThat((String) user.getAttribute(""sub"")).isEqualTo(""user""); assertThat(user.getAttribute<String>(""sub"")).isEqualTo(""user"") It also includes a Collection of authorities with just one authority, SCOPE_read : Java Kotlin assertThat(user.getAuthorities()).hasSize(1); assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority(""SCOPE_read"")); assertThat(user.authorities).hasSize(1) assertThat(user.authorities).containsExactly(SimpleGrantedAuthority(""SCOPE_read"")) Spring Security does the necessary work to make sure that the OAuth2User instance is available for the @AuthenticationPrincipal annotation(../../../servlet/integrations/mvc.html#mvc-authentication-principal) . Further, it also links that OAuth2User to a simple instance of OAuth2AuthorizedClient that it deposits in a mock ServerOAuth2AuthorizedClientRepository . This can be handy if your tests use the @RegisteredOAuth2AuthorizedClient annotation(#webflux-testing-oauth2-client) . Configuring Authorities: In many circumstances, your method is protected by filter or method security and needs your Authentication to have certain granted authorities to allow the request. In this case, you can supply the granted authorities you need by using the authorities() method: Java Kotlin client .mutateWith(mockOAuth2Login() .authorities(new SimpleGrantedAuthority(""SCOPE_message:read"")) ) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockOAuth2Login() .authorities(SimpleGrantedAuthority(""SCOPE_message:read"")) ) .get().uri(""/endpoint"").exchange() Configuring Claims: While granted authorities are quite common across all of Spring Security, we also have claims in the case of OAuth 2.0. Suppose, for example, that you have a user_id attribute that indicates the user’s ID in your system. You might access it as follows in a controller: Java Kotlin @GetMapping(""/endpoint"") public Mono<String> foo(@AuthenticationPrincipal OAuth2User oauth2User) { String userId = oauth2User.getAttribute(""user_id""); // ... } @GetMapping(""/endpoint"") fun foo(@AuthenticationPrincipal oauth2User: OAuth2User): Mono<String> { val userId = oauth2User.getAttribute<String>(""user_id"") // ... } In that case, you can specify that attribute with the attributes() method: Java Kotlin client .mutateWith(mockOAuth2Login() .attributes(attrs -> attrs.put(""user_id"", ""1234"")) ) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockOAuth2Login() .attributes { attrs -> attrs[""user_id""] = ""1234"" } ) .get().uri(""/endpoint"").exchange() Additional Configurations: There are additional methods, too, for further configuring the authentication, depending on what data your controller expects: clientRegistration(ClientRegistration) : Configures the associated OAuth2AuthorizedClient with a given ClientRegistration oauth2User(OAuth2User) : Configures the complete OAuth2User instance That last one is handy if you: * Have your own implementation of OAuth2User or * Need to change the name attribute For example, suppose that your authorization server sends the principal name in the user_name claim instead of the sub claim. In that case, you can configure an OAuth2User by hand: Java Kotlin OAuth2User oauth2User = new DefaultOAuth2User( AuthorityUtils.createAuthorityList(""SCOPE_message:read""), Collections.singletonMap(""user_name"", ""foo_user""), ""user_name""); client .mutateWith(mockOAuth2Login().oauth2User(oauth2User)) .get().uri(""/endpoint"").exchange(); val oauth2User: OAuth2User = DefaultOAuth2User( AuthorityUtils.createAuthorityList(""SCOPE_message:read""), mapOf(Pair(""user_name"", ""foo_user"")), ""user_name"" ) client .mutateWith(mockOAuth2Login().oauth2User(oauth2User)) .get().uri(""/endpoint"").exchange() Testing OAuth 2.0 Clients: Independent of how your user authenticates, you may have other tokens and client registrations that are in play for the request you are testing. For example, your controller may rely on the client credentials grant to get a token that is not associated with the user at all: Java Kotlin @GetMapping(""/endpoint"") public Mono<String> foo(@RegisteredOAuth2AuthorizedClient(""my-app"") OAuth2AuthorizedClient authorizedClient) { return this.webClient.get() .attributes(oauth2AuthorizedClient(authorizedClient)) .retrieve() .bodyToMono(String.class); } import org.springframework.web.reactive.function.client.bodyToMono // ... @GetMapping(""/endpoint"") fun foo(@RegisteredOAuth2AuthorizedClient(""my-app"") authorizedClient: OAuth2AuthorizedClient?): Mono<String> { return this.webClient.get() .attributes(oauth2AuthorizedClient(authorizedClient)) .retrieve() .bodyToMono() } Simulating this handshake with the authorization server can be cumbersome. Instead, you can use SecurityMockServerConfigurers#oauth2Client to add a OAuth2AuthorizedClient to a mock ServerOAuth2AuthorizedClientRepository : Java Kotlin client .mutateWith(mockOAuth2Client(""my-app"")) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockOAuth2Client(""my-app"")) .get().uri(""/endpoint"").exchange() This creates an OAuth2AuthorizedClient that has a simple ClientRegistration , a OAuth2AccessToken , and a resource owner name. Specifically, it includes a ClientRegistration with a client ID of test-client and a client secret of test-secret : Java Kotlin assertThat(authorizedClient.getClientRegistration().getClientId()).isEqualTo(""test-client""); assertThat(authorizedClient.getClientRegistration().getClientSecret()).isEqualTo(""test-secret""); assertThat(authorizedClient.clientRegistration.clientId).isEqualTo(""test-client"") assertThat(authorizedClient.clientRegistration.clientSecret).isEqualTo(""test-secret"") It also includes a resource owner name of user : Java Kotlin assertThat(authorizedClient.getPrincipalName()).isEqualTo(""user""); assertThat(authorizedClient.principalName).isEqualTo(""user"") It also includes an OAuth2AccessToken with one scope, read : Java Kotlin assertThat(authorizedClient.getAccessToken().getScopes()).hasSize(1); assertThat(authorizedClient.getAccessToken().getScopes()).containsExactly(""read""); assertThat(authorizedClient.accessToken.scopes).hasSize(1) assertThat(authorizedClient.accessToken.scopes).containsExactly(""read"") You can then retrieve the client as usual by using @RegisteredOAuth2AuthorizedClient in a controller method. Configuring Scopes: In many circumstances, the OAuth 2.0 access token comes with a set of scopes. Consider the following example of how a controller can inspect the scopes: Java Kotlin @GetMapping(""/endpoint"") public Mono<String> foo(@RegisteredOAuth2AuthorizedClient(""my-app"") OAuth2AuthorizedClient authorizedClient) { Set<String> scopes = authorizedClient.getAccessToken().getScopes(); if (scopes.contains(""message:read"")) { return this.webClient.get() .attributes(oauth2AuthorizedClient(authorizedClient)) .retrieve() .bodyToMono(String.class); } // ... } import org.springframework.web.reactive.function.client.bodyToMono // ... @GetMapping(""/endpoint"") fun foo(@RegisteredOAuth2AuthorizedClient(""my-app"") authorizedClient: OAuth2AuthorizedClient): Mono<String> { val scopes = authorizedClient.accessToken.scopes if (scopes.contains(""message:read"")) { return webClient.get() .attributes(oauth2AuthorizedClient(authorizedClient)) .retrieve() .bodyToMono() } // ... } Given a controller that inspects scopes, you can configure the scope by using the accessToken() method: Java Kotlin client .mutateWith(mockOAuth2Client(""my-app"") .accessToken(new OAuth2AccessToken(BEARER, ""token"", null, null, Collections.singleton(""message:read""))) ) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockOAuth2Client(""my-app"") .accessToken(OAuth2AccessToken(BEARER, ""token"", null, null, setOf(""message:read""))) ) .get().uri(""/endpoint"").exchange() Additional Configurations: You can also use additional methods to further configure the authentication depending on what data your controller expects: principalName(String) ; Configures the resource owner name clientRegistration(Consumer<ClientRegistration.Builder>) : Configures the associated ClientRegistration clientRegistration(ClientRegistration) : Configures the complete ClientRegistration That last one is handy if you want to use a real ClientRegistration For example, suppose that you want to use one of your application’s ClientRegistration definitions, as specified in your application.yml . In that case, your test can autowire the ReactiveClientRegistrationRepository and look up the one your test needs: Java Kotlin @Autowired ReactiveClientRegistrationRepository clientRegistrationRepository; // ... client .mutateWith(mockOAuth2Client() .clientRegistration(this.clientRegistrationRepository.findByRegistrationId(""facebook"").block()) ) .get().uri(""/exchange"").exchange(); @Autowired lateinit var clientRegistrationRepository: ReactiveClientRegistrationRepository // ... client .mutateWith(mockOAuth2Client() .clientRegistration(this.clientRegistrationRepository.findByRegistrationId(""facebook"").block()) ) .get().uri(""/exchange"").exchange() Testing JWT Authentication: To make an authorized request on a resource server, you need a bearer token. If your resource server is configured for JWTs, the bearer token needs to be signed and then encoded according to the JWT specification. All of this can be quite daunting, especially when this is not the focus of your test. Fortunately, there are a number of simple ways in which you can overcome this difficulty and let your tests focus on authorization and not on representing bearer tokens. We look at two of them in the next two subsections. mockJwt() WebTestClientConfigurer: The first way is with a WebTestClientConfigurer . The simplest of these would be to use the SecurityMockServerConfigurers#mockJwt method like the following: Java Kotlin client .mutateWith(mockJwt()).get().uri(""/endpoint"").exchange(); client .mutateWith(mockJwt()).get().uri(""/endpoint"").exchange() This example creates a mock Jwt and passes it through any authentication APIs so that it is available for your authorization mechanisms to verify. By default, the JWT that it creates has the following characteristics: { ""headers"" : { ""alg"" : ""none"" }, ""claims"" : { ""sub"" : ""user"", ""scope"" : ""read"" } } The resulting Jwt , were it tested, would pass in the following way: Java Kotlin assertThat(jwt.getTokenValue()).isEqualTo(""token""); assertThat(jwt.getHeaders().get(""alg"")).isEqualTo(""none""); assertThat(jwt.getSubject()).isEqualTo(""sub""); assertThat(jwt.tokenValue).isEqualTo(""token"") assertThat(jwt.headers[""alg""]).isEqualTo(""none"") assertThat(jwt.subject).isEqualTo(""sub"") Note that you configure these values. You can also configure any headers or claims with their corresponding methods: Java Kotlin client .mutateWith(mockJwt().jwt(jwt -> jwt.header(""kid"", ""one"") .claim(""iss"", ""https://idp.example.org""))) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockJwt().jwt { jwt -> jwt.header(""kid"", ""one"") .claim(""iss"", ""https://idp.example.org"") }) .get().uri(""/endpoint"").exchange() Java Kotlin client .mutateWith(mockJwt().jwt(jwt -> jwt.claims(claims -> claims.remove(""scope"")))) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockJwt().jwt { jwt -> jwt.claims { claims -> claims.remove(""scope"") } }) .get().uri(""/endpoint"").exchange() The scope and scp claims are processed the same way here as they are in a normal bearer token request. However, this can be overridden simply by providing the list of GrantedAuthority instances that you need for your test: Java Kotlin client .mutateWith(mockJwt().authorities(new SimpleGrantedAuthority(""SCOPE_messages""))) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockJwt().authorities(SimpleGrantedAuthority(""SCOPE_messages""))) .get().uri(""/endpoint"").exchange() Alternatively, if you have a custom Jwt to Collection<GrantedAuthority> converter, you can also use that to derive the authorities: Java Kotlin client .mutateWith(mockJwt().authorities(new MyConverter())) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockJwt().authorities(MyConverter())) .get().uri(""/endpoint"").exchange() You can also specify a complete Jwt , for which Jwt.Builder(https://docs.spring.io/spring-security/site/docs/6.3.3/api/org/springframework/security/oauth2/jwt/Jwt.Builder.html) is quite handy: Java Kotlin Jwt jwt = Jwt.withTokenValue(""token"") .header(""alg"", ""none"") .claim(""sub"", ""user"") .claim(""scope"", ""read"") .build(); client .mutateWith(mockJwt().jwt(jwt)) .get().uri(""/endpoint"").exchange(); val jwt: Jwt = Jwt.withTokenValue(""token"") .header(""alg"", ""none"") .claim(""sub"", ""user"") .claim(""scope"", ""read"") .build() client .mutateWith(mockJwt().jwt(jwt)) .get().uri(""/endpoint"").exchange() authentication() and WebTestClientConfigurer: The second way is by using the authentication() Mutator . You can instantiate your own JwtAuthenticationToken and provide it in your test: Java Kotlin Jwt jwt = Jwt.withTokenValue(""token"") .header(""alg"", ""none"") .claim(""sub"", ""user"") .build(); Collection<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList(""SCOPE_read""); JwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities); client .mutateWith(mockAuthentication(token)) .get().uri(""/endpoint"").exchange(); val jwt = Jwt.withTokenValue(""token"") .header(""alg"", ""none"") .claim(""sub"", ""user"") .build() val authorities: Collection<GrantedAuthority> = AuthorityUtils.createAuthorityList(""SCOPE_read"") val token = JwtAuthenticationToken(jwt, authorities) client .mutateWith(mockAuthentication<JwtMutator>(token)) .get().uri(""/endpoint"").exchange() Note that, as an alternative to these, you can also mock the ReactiveJwtDecoder bean itself with a @MockBean annotation. Testing Opaque Token Authentication: Similar to JWTs(#webflux-testing-jwt) , opaque tokens require an authorization server in order to verify their validity, which can make testing more difficult. To help with that, Spring Security has test support for opaque tokens. Suppose you have a controller that retrieves the authentication as a BearerTokenAuthentication : Java Kotlin @GetMapping(""/endpoint"") public Mono<String> foo(BearerTokenAuthentication authentication) { return Mono.just((String) authentication.getTokenAttributes().get(""sub"")); } @GetMapping(""/endpoint"") fun foo(authentication: BearerTokenAuthentication): Mono<String?> { return Mono.just(authentication.tokenAttributes[""sub""] as String?) } In that case, you can tell Spring Security to include a default BearerTokenAuthentication by using the SecurityMockServerConfigurers#opaqueToken method: Java Kotlin client .mutateWith(mockOpaqueToken()) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockOpaqueToken()) .get().uri(""/endpoint"").exchange() This example configures the associated MockHttpServletRequest with a BearerTokenAuthentication that includes a simple OAuth2AuthenticatedPrincipal , a Map of attributes, and a Collection of granted authorities. Specifically, it includes a Map with a key/value pair of sub / user : Java Kotlin assertThat((String) token.getTokenAttributes().get(""sub"")).isEqualTo(""user""); assertThat(token.tokenAttributes[""sub""] as String?).isEqualTo(""user"") It also includes a Collection of authorities with just one authority, SCOPE_read : Java Kotlin assertThat(token.getAuthorities()).hasSize(1); assertThat(token.getAuthorities()).containsExactly(new SimpleGrantedAuthority(""SCOPE_read"")); assertThat(token.authorities).hasSize(1) assertThat(token.authorities).containsExactly(SimpleGrantedAuthority(""SCOPE_read"")) Spring Security does the necessary work to make sure that the BearerTokenAuthentication instance is available for your controller methods. Configuring Authorities: In many circumstances, your method is protected by filter or method security and needs your Authentication to have certain granted authorities to allow the request. In this case, you can supply what granted authorities you need using the authorities() method: Java Kotlin client .mutateWith(mockOpaqueToken() .authorities(new SimpleGrantedAuthority(""SCOPE_message:read"")) ) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockOpaqueToken() .authorities(SimpleGrantedAuthority(""SCOPE_message:read"")) ) .get().uri(""/endpoint"").exchange() Configuring Claims: While granted authorities are quite common across all of Spring Security, we also have attributes in the case of OAuth 2.0. Suppose, for example, that you have a user_id attribute that indicates the user’s ID in your system. You might access it as follows in a controller: Java Kotlin @GetMapping(""/endpoint"") public Mono<String> foo(BearerTokenAuthentication authentication) { String userId = (String) authentication.getTokenAttributes().get(""user_id""); // ... } @GetMapping(""/endpoint"") fun foo(authentication: BearerTokenAuthentication): Mono<String?> { val userId = authentication.tokenAttributes[""user_id""] as String? // ... } In that case, you can specify that attribute with the attributes() method: Java Kotlin client .mutateWith(mockOpaqueToken() .attributes(attrs -> attrs.put(""user_id"", ""1234"")) ) .get().uri(""/endpoint"").exchange(); client .mutateWith(mockOpaqueToken() .attributes { attrs -> attrs[""user_id""] = ""1234"" } ) .get().uri(""/endpoint"").exchange() Additional Configurations: You can also use additional methods to further configure the authentication, depending on what data your controller expects. One such method is principal(OAuth2AuthenticatedPrincipal) , which you can use to configure the complete OAuth2AuthenticatedPrincipal instance that underlies the BearerTokenAuthentication . It is handy if you: * Have your own implementation of OAuth2AuthenticatedPrincipal or * Want to specify a different principal name For example, suppose that your authorization server sends the principal name in the user_name attribute instead of the sub attribute. In that case, you can configure an OAuth2AuthenticatedPrincipal by hand: Java Kotlin Map<String, Object> attributes = Collections.singletonMap(""user_name"", ""foo_user""); OAuth2AuthenticatedPrincipal principal = new DefaultOAuth2AuthenticatedPrincipal( (String) attributes.get(""user_name""), attributes, AuthorityUtils.createAuthorityList(""SCOPE_message:read"")); client .mutateWith(mockOpaqueToken().principal(principal)) .get().uri(""/endpoint"").exchange(); val attributes: Map<String, Any> = mapOf(Pair(""user_name"", ""foo_user"")) val principal: OAuth2AuthenticatedPrincipal = DefaultOAuth2AuthenticatedPrincipal( attributes[""user_name""] as String?, attributes, AuthorityUtils.createAuthorityList(""SCOPE_message:read"") ) client .mutateWith(mockOpaqueToken().principal(principal)) .get().uri(""/endpoint"").exchange() Note that, as an alternative to using mockOpaqueToken() test support, you can also mock the OpaqueTokenIntrospector bean itself with a @MockBean annotation."
"https://docs.spring.io/spring-security/reference/6.3/reactive/configuration/webflux.html","WebFlux Security: Spring Security’s WebFlux support relies on a WebFilter and works the same for Spring WebFlux and Spring WebFlux.Fn. A few sample applications demonstrate the code: Hello WebFlux hellowebflux(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/reactive/webflux/java/hello-security) Hello WebFlux.Fn hellowebfluxfn(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/reactive/webflux-fn/hello-security) Hello WebFlux Method hellowebflux-method(https://github.com/spring-projects/spring-security-samples/tree/6.3.x/reactive/webflux/java/method) Minimal WebFlux Security Configuration: The following listing shows a minimal WebFlux Security configuration: Minimal WebFlux Security Configuration Java Kotlin @Configuration @EnableWebFluxSecurity public class HelloWebfluxSecurityConfig { @Bean public MapReactiveUserDetailsService userDetailsService() { UserDetails user = User.withDefaultPasswordEncoder() .username(""user"") .password(""user"") .roles(""USER"") .build(); return new MapReactiveUserDetailsService(user); } } @Configuration @EnableWebFluxSecurity class HelloWebfluxSecurityConfig { @Bean fun userDetailsService(): ReactiveUserDetailsService { val userDetails = User.withDefaultPasswordEncoder() .username(""user"") .password(""user"") .roles(""USER"") .build() return MapReactiveUserDetailsService(userDetails) } } This configuration provides form and HTTP basic authentication, sets up authorization to require an authenticated user for accessing any page, sets up a default login page and a default logout page, sets up security related HTTP headers, adds CSRF protection, and more. Explicit WebFlux Security Configuration: The following page shows an explicit version of the minimal WebFlux Security configuration: Explicit WebFlux Security Configuration Java Kotlin @Configuration @EnableWebFluxSecurity public class HelloWebfluxSecurityConfig { @Bean public MapReactiveUserDetailsService userDetailsService() { UserDetails user = User.withDefaultPasswordEncoder() .username(""user"") .password(""user"") .roles(""USER"") .build(); return new MapReactiveUserDetailsService(user); } @Bean public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http .authorizeExchange(exchanges -> exchanges .anyExchange().authenticated() ) .httpBasic(withDefaults()) .formLogin(withDefaults()); return http.build(); } } import org.springframework.security.config.web.server.invoke @Configuration @EnableWebFluxSecurity class HelloWebfluxSecurityConfig { @Bean fun userDetailsService(): ReactiveUserDetailsService { val userDetails = User.withDefaultPasswordEncoder() .username(""user"") .password(""user"") .roles(""USER"") .build() return MapReactiveUserDetailsService(userDetails) } @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { return http { authorizeExchange { authorize(anyExchange, authenticated) } formLogin { } httpBasic { } } } } Make sure to import the org.springframework.security.config.annotation.web.invoke function to enable the Kotlin DSL in your class, as the IDE will not always auto-import the method, causing compilation issues. This configuration explicitly sets up all the same things as our minimal configuration. From here, you can more easily make changes to the defaults. You can find more examples of explicit configuration in unit tests, by searching for EnableWebFluxSecurity in the config/src/test/ directory(https://github.com/spring-projects/spring-security/search?q=path%3Aconfig%2Fsrc%2Ftest%2F+EnableWebFluxSecurity) . Multiple Chains Support: You can configure multiple SecurityWebFilterChain instances to separate configuration by RequestMatcher instances. For example, you can isolate configuration for URLs that start with /api : Java Kotlin @Configuration @EnableWebFluxSecurity static class MultiSecurityHttpConfig { @Order(Ordered.HIGHEST_PRECEDENCE) (1) @Bean SecurityWebFilterChain apiHttpSecurity(ServerHttpSecurity http) { http .securityMatcher(new PathPatternParserServerWebExchangeMatcher(""/api/**"")) (2) .authorizeExchange((exchanges) -> exchanges .anyExchange().authenticated() ) .oauth2ResourceServer(OAuth2ResourceServerSpec::jwt); (3) return http.build(); } @Bean SecurityWebFilterChain webHttpSecurity(ServerHttpSecurity http) { (4) http .authorizeExchange((exchanges) -> exchanges .anyExchange().authenticated() ) .httpBasic(withDefaults()); (5) return http.build(); } @Bean ReactiveUserDetailsService userDetailsService() { return new MapReactiveUserDetailsService( PasswordEncodedUser.user(), PasswordEncodedUser.admin()); } } import org.springframework.security.config.web.server.invoke @Configuration @EnableWebFluxSecurity open class MultiSecurityHttpConfig { @Order(Ordered.HIGHEST_PRECEDENCE) (1) @Bean open fun apiHttpSecurity(http: ServerHttpSecurity): SecurityWebFilterChain { return http { securityMatcher(PathPatternParserServerWebExchangeMatcher(""/api/**"")) (2) authorizeExchange { authorize(anyExchange, authenticated) } oauth2ResourceServer { jwt { } (3) } } } @Bean open fun webHttpSecurity(http: ServerHttpSecurity): SecurityWebFilterChain { (4) return http { authorizeExchange { authorize(anyExchange, authenticated) } httpBasic { } (5) } } @Bean open fun userDetailsService(): ReactiveUserDetailsService { return MapReactiveUserDetailsService( PasswordEncodedUser.user(), PasswordEncodedUser.admin() ) } } 1 Configure a SecurityWebFilterChain with an @Order to specify which SecurityWebFilterChain Spring Security should consider first 2 Use PathPatternParserServerWebExchangeMatcher to state that this SecurityWebFilterChain will only apply to URL paths that start with /api/ 3 Specify the authentication mechanisms that will be used for /api/** endpoints 4 Create another instance of SecurityWebFilterChain with lower precedence to match all other URLs 5 Specify the authentication mechanisms that will be used for the rest of the application Spring Security selects one SecurityWebFilterChain @Bean for each request. It matches the requests in order by the securityMatcher definition. In this case, that means that, if the URL path starts with /api , Spring Security uses apiHttpSecurity . If the URL does not start with /api , Spring Security defaults to webHttpSecurity , which has an implied securityMatcher that matches any request."
"https://docs.spring.io/spring-security/reference/6.3/native-image/index.html","GraalVM Native Image Support: Spring Boot 3.0 provides support for generating native images with GraalVM(https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images) . Spring Security integrates with that support and provides its features ready for native images. However, as mentioned in the Spring Boot documentation(https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images.understanding-aot-processing.hint-file-generation) , there are some cases where we need to provide hints to be used by GraalVM. This section aims to provide guidance in some Spring Security features that likely need to have additional hints provided by the application."
"https://docs.spring.io/spring-security/reference/6.3/native-image/method-security.html","Method Security in GraalVM Native Image: Although Method Security(../servlet/authorization/method-security.html) is supported in GraalVM Native Image, there are some use cases that need additional hints provided by the application. Using @PreAuthorize and @PostAuthorize Annotations: Using @PreAuthorize and @PostAuthorize annotations require additional hints if you have a custom implementation of UserDetails or Authentication classes. Let’s take an example where you have a custom implementation of UserDetails class as follows and that implementation is returned by your UserDetailsService : Custom Implementation of UserDetails public class CustomUserDetails implements UserDetails { private final String username; private final String password; private final Collection<? extends GrantedAuthority> authorities; public boolean isAdmin() { return this.authorities.contains(new SimpleGrantedAuthority(""ROLE_ADMIN"")); } // constructors, getters and setters } And you want to use the isAdmin() method inside a @PreAuthorize annotation as follows: Using isAdmin() to secure a method @PreAuthorize(""principal?.isAdmin()"") public String hello() { return ""Hello!""; } Remember that you need to add @EnableMethodSecurity annotation(../servlet/authorization/method-security.html#jc-enable-method-security) to your configuration class to enable method security annotations. If you run the native image(https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.developing-your-first-application) of your application with the above configuration, you will get an error similar to the following when trying to invoke the hello() method: failed: java.lang.IllegalArgumentException: Failed to evaluate expression 'principal?.isAdmin()' with root cause org.springframework.expression.spel.SpelEvaluationException: EL1004E: Method call: Method isAdmin() cannot be found on type com.mypackage.CustomUserDetails Which means that the isAdmin() method cannot be found on the CustomUserDetails class. This is because Spring Security uses reflection to invoke the isAdmin() method and GraalVM Native Image does not support reflection by default. To fix this issue, you need to give hints to GraalVM Native Image to allow reflection on the CustomUserDetails#isAdmin() method. We can do that by providing a custom hint(https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.advanced.custom-hints) . In this example we are going to use the @RegisterReflectionForBinding annotation(https://docs.spring.io/spring-framework/docs/6.1.12/reference/html/core.html#core.aot.hints.register-reflection-for-binding) . You might need to register all your classes that you want to use in your @PreAuthorize and @PostAuthorize annotations. Using @RegisterReflectionForBinding @Configuration @RegisterReflectionForBinding(CustomUserDetails.class) public class MyConfiguration { //... } And that’s it, now you can run the native image of your application and it should work as expected."
