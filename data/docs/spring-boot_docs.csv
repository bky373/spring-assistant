"url","content"
"https://docs.spring.io/spring-boot/index.html","Spring Boot: Spring Boot helps you to create stand-alone, production-grade Spring-based applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. You can use Spring Boot to create Java applications that can be started by using java -jar or more traditional war deployments. Our primary goals are: Provide a radically faster and widely accessible getting-started experience for all Spring development. Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults. Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration). Absolutely no code generation (when not targeting native image) and no requirement for XML configuration."
"https://docs.spring.io/spring-boot/documentation.html","Documentation Overview: This section provides a brief overview of Spring Boot reference documentation. It serves as a map for the rest of the document. First Steps: If you are getting started with Spring Boot or 'Spring' in general, start with the following topics: From scratch: Overview(index.html) | Requirements(system-requirements.html) | Installation(installing.html) Tutorial: Part 1(tutorial/first-application/index.html) | Part 2(tutorial/first-application/index.html#getting-started.first-application.code) Running your example: Part 1(tutorial/first-application/index.html#getting-started.first-application.run) | Part 2(tutorial/first-application/index.html#getting-started.first-application.executable-jar) Upgrading From an Earlier Version: You should always ensure that you are running a supported version(https://github.com/spring-projects/spring-boot/wiki/Supported-Versions) of Spring Boot. Depending on the version that you are upgrading to, you can find some additional tips here: From 1.x: Upgrading from 1.x(upgrading.html#upgrading.from-1x) To a new feature release: Upgrading to New Feature Release(upgrading.html#upgrading.to-feature) Spring Boot CLI: Upgrading the Spring Boot CLI(upgrading.html#upgrading.cli) Developing With Spring Boot: Ready to actually start using Spring Boot? We have you covered(reference/using/index.html) : Build systems: Maven(reference/using/build-systems.html#using.build-systems.maven) | Gradle(reference/using/build-systems.html#using.build-systems.gradle) | Ant(reference/using/build-systems.html#using.build-systems.ant) | Starters(reference/using/build-systems.html#using.build-systems.starters) Best practices: Code Structure(reference/using/structuring-your-code.html) | @Configuration(reference/using/configuration-classes.html) | @EnableAutoConfiguration(reference/using/auto-configuration.html) | Beans and Dependency Injection(reference/using/spring-beans-and-dependency-injection.html) Running your code: IDE(reference/using/running-your-application.html#using.running-your-application.from-an-ide) | Packaged(reference/using/running-your-application.html#using.running-your-application.as-a-packaged-application) | Maven(reference/using/running-your-application.html#using.running-your-application.with-the-maven-plugin) | Gradle(reference/using/running-your-application.html#using.running-your-application.with-the-gradle-plugin) Packaging your app: Production jars(reference/using/packaging-for-production.html) Spring Boot CLI: Using the CLI(cli/index.html) Learning About Spring Boot Features: Need more details about Spring Boot’s core features? The following content is for you(reference/features/index.html) : Spring Application: SpringApplication(reference/features/spring-application.html) External Configuration: External Configuration(reference/features/external-config.html) Profiles: Profiles(reference/features/profiles.html) Logging: Logging(reference/features/logging.html) Web: If you develop Spring Boot web applications, take a look at the following content: Servlet Web Applications: Spring MVC, Jersey, Embedded Servlet Containers(reference/web/servlet.html) Reactive Web Applications: Spring Webflux, Embedded Servlet Containers(reference/web/reactive.html) Graceful Shutdown: Graceful Shutdown(reference/web/graceful-shutdown.html) Spring Security: Default Security Configuration, Auto-configuration for OAuth2, SAML(reference/web/spring-security.html) Spring Session: Auto-configuration for Spring Session(reference/web/spring-session.html) Spring HATEOAS: Auto-configuration for Spring HATEOAS(reference/web/spring-hateoas.html) Data: If your application deals with a datastore, you can see how to configure that here: SQL: Configuring a SQL Datastore, Embedded Database support, Connection pools, and more.(reference/data/sql.html) NOSQL: Auto-configuration for NOSQL stores such as Redis, MongoDB, Neo4j, and others.(reference/data/nosql.html) Messaging: If your application uses any messaging protocol, see one or more of the following sections: JMS: Auto-configuration for ActiveMQ and Artemis, Sending and Receiving messages through JMS(reference/messaging/jms.html) AMQP: Auto-configuration for RabbitMQ(reference/messaging/amqp.html) Kafka: Auto-configuration for Spring Kafka(reference/messaging/kafka.html) Pulsar: Auto-configuration for Spring for Apache Pulsar(reference/messaging/pulsar.html) RSocket: Auto-configuration for Spring Framework’s RSocket Support(reference/messaging/rsocket.html) Spring Integration: Auto-configuration for Spring Integration(reference/messaging/spring-integration.html) IO: If your application needs IO capabilities, see one or more of the following sections: Caching: Caching support with EhCache, Hazelcast, Infinispan, and more(reference/io/caching.html) Quartz: Quartz Scheduling(reference/io/quartz.html) Mail: Sending Email(reference/io/email.html) Validation: JSR-303 Validation(reference/io/validation.html) REST Clients: Calling REST Services with RestTemplate and WebClient(reference/io/rest-client.html) Webservices: Auto-configuration for Spring Web Services(reference/io/webservices.html) JTA: Distributed Transactions with JTA(reference/io/jta.html) Container Images: Spring Boot provides first-class support for building efficient container images. You can read more about it here: Efficient Container Images: Tips to optimize container images such as Docker images(reference/packaging/container-images/efficient-images.html) Dockerfiles: Building container images using dockerfiles(reference/packaging/container-images/dockerfiles.html) Cloud Native Buildpacks: Support for Cloud Native Buildpacks with Maven and Gradle(reference/packaging/container-images/cloud-native-buildpacks.html) Moving to Production: When you are ready to push your Spring Boot application to production, we have some tricks(how-to/actuator.html) that you might like: Management endpoints: Overview(reference/actuator/endpoints.html) Connection options: HTTP(reference/actuator/monitoring.html) | JMX(reference/actuator/jmx.html) Monitoring: Metrics(reference/actuator/metrics.html) | Auditing(reference/actuator/auditing.html) | HTTP Exchanges(reference/actuator/http-exchanges.html) | Process(reference/actuator/process-monitoring.html) Optimizing for Production: Spring Boot applications can be optimized for production using technologies described in these sections: Efficient Deployments: Unpacking the Executable JAR(reference/packaging/efficient.html#packaging.efficient.unpacking) GraalVM Native Images: Introduction(reference/packaging/native-image/introducing-graalvm-native-images.html) | Advanced Topics(reference/packaging/native-image/advanced-topics.html) | Getting Started(how-to/native-image/developing-your-first-application.html) | Testing(how-to/native-image/testing-native-applications.html) Class Data Sharing: Overview(reference/packaging/class-data-sharing.html) Checkpoint and Restore Overview(reference/packaging/checkpoint-restore.html) Advanced Topics: Finally, we have a few topics for more advanced users: Spring Boot Applications Deployment: Cloud Deployment(how-to/deployment/cloud.html) | OS Service(how-to/deployment/installing.html) Build tool plugins: Maven(maven-plugin/index.html) | Gradle(gradle-plugin/index.html) Appendix: Application Properties(appendix/application-properties/index.html) | Configuration Metadata(specification/configuration-metadata/index.html) | Auto-configuration Classes(appendix/auto-configuration-classes/index.html) | Test Auto-configuration Annotations(appendix/test-auto-configuration/index.html) | Executable Jars(specification/executable-jar/index.html) | Dependency Versions(appendix/dependency-versions/index.html)"
"https://docs.spring.io/spring-boot/community.html","Community: If you have trouble with Spring Boot, we would like to help. Try the How-to documents(how-to/index.html) . They provide solutions to the most common questions. Learn the Spring basics. Spring Boot builds on many other Spring projects. Check the spring.io(https://spring.io) web-site for a wealth of reference documentation. If you are starting out with Spring, try one of the guides(https://spring.io/guides) . Ask a question. We monitor stackoverflow.com(https://stackoverflow.com) for questions tagged with spring-boot(https://stackoverflow.com/tags/spring-boot) . Report bugs with Spring Boot at github.com/spring-projects/spring-boot/issues(https://github.com/spring-projects/spring-boot/issues) . All of Spring Boot is open source, including the documentation. If you find problems with the docs or if you want to improve them, please get involved(https://github.com/spring-projects/spring-boot) ."
"https://docs.spring.io/spring-boot/system-requirements.html","System Requirements: Spring Boot 3.3.4 requires Java 17(https://www.java.com) and is compatible up to and including Java 22. Spring Framework 6.1.13(https://docs.spring.io/spring-framework/reference/6.1/) or above is also required. Explicit build support is provided for the following build tools: Build Tool Version Maven 3.6.3 or later Gradle 7.x (7.5 or later) and 8.x Servlet Containers: Spring Boot supports the following embedded servlet containers: Name Servlet Version Tomcat 10.1 6.0 Jetty 12.0 6.0 Undertow 2.3 6.0 You can also deploy Spring Boot applications to any servlet 5.0+ compatible container. GraalVM Native Images: Spring Boot applications can be converted into a Native Image(reference/packaging/native-image/introducing-graalvm-native-images.html) using GraalVM 22.3 or above. Images can be created using the native build tools(https://github.com/graalvm/native-build-tools) Gradle/Maven plugins or native-image tool provided by GraalVM. You can also create native images using the native-image Paketo buildpack(https://github.com/paketo-buildpacks/native-image) . The following versions are supported: Name Version GraalVM Community 22.3 Native Build Tools 0.10.3"
"https://docs.spring.io/spring-boot/installing.html","Installing Spring Boot: Spring Boot can be used with “classic” Java development tools or installed as a command line tool. Either way, you need Java SDK v17(https://www.java.com) or higher. Before you begin, you should check your current Java installation by using the following command: $ java -version If you are new to Java development or if you want to experiment with Spring Boot, you might want to try the Spring Boot CLI(#getting-started.installing.cli) (Command Line Interface) first. Otherwise, read on for “classic” installation instructions. Installation Instructions for the Java Developer: You can use Spring Boot in the same way as any standard Java library. To do so, include the appropriate spring-boot-*.jar files on your classpath. Spring Boot does not require any special tools integration, so you can use any IDE or text editor. Also, there is nothing special about a Spring Boot application, so you can run and debug a Spring Boot application as you would any other Java program. Although you could copy Spring Boot jars, we generally recommend that you use a build tool that supports dependency management (such as Maven or Gradle). Maven Installation: Spring Boot is compatible with Apache Maven 3.6.3 or later. If you do not already have Maven installed, you can follow the instructions at maven.apache.org(https://maven.apache.org) . On many operating systems, Maven can be installed with a package manager. If you use OSX Homebrew, try brew install maven . Ubuntu users can run sudo apt-get install maven . Windows users with Chocolatey(https://chocolatey.org/) can run choco install maven from an elevated (administrator) prompt. Spring Boot dependencies use the org.springframework.boot group id. Typically, your Maven POM file inherits from the spring-boot-starter-parent project and declares dependencies to one or more starters(reference/using/build-systems.html#using.build-systems.starters) . Spring Boot also provides an optional Maven plugin(maven-plugin/index.html) to create executable jars. More details on getting started with Spring Boot and Maven can be found in the Getting Started(maven-plugin/getting-started.html) section of the Maven plugin’s reference guide. Gradle Installation: Spring Boot is compatible with Gradle 7.x (7.5 or later) and 8.x. If you do not already have Gradle installed, you can follow the instructions at gradle.org(https://gradle.org) . Spring Boot dependencies can be declared by using the org.springframework.boot group . Typically, your project declares dependencies to one or more starters(reference/using/build-systems.html#using.build-systems.starters) . Spring Boot provides a useful Gradle plugin(gradle-plugin/index.html) that can be used to simplify dependency declarations and to create executable jars. Gradle Wrapper The Gradle Wrapper provides a nice way of “obtaining” Gradle when you need to build a project. It is a small script and library that you commit alongside your code to bootstrap the build process. See docs.gradle.org/current/userguide/gradle_wrapper.html(https://docs.gradle.org/current/userguide/gradle_wrapper.html) for details. More details on getting started with Spring Boot and Gradle can be found in the Getting Started(gradle-plugin/getting-started.html) section of the Gradle plugin’s reference guide. Installing the Spring Boot CLI: The Spring Boot CLI (Command Line Interface) is a command line tool that you can use to quickly prototype with Spring. You do not need to use the CLI to work with Spring Boot, but it is a quick way to get a Spring application off the ground without an IDE. Manual Installation: You can download the Spring CLI distribution from one of the following locations: spring-boot-cli-3.3.4-bin.zip(https://repo.maven.apache.org/maven2/org/springframework/boot/spring-boot-cli/3.3.4/spring-boot-cli-3.3.4-bin.zip) spring-boot-cli-3.3.4-bin.tar.gz(https://repo.maven.apache.org/maven2/org/springframework/boot/spring-boot-cli/3.3.4/spring-boot-cli-3.3.4-bin.tar.gz) Once downloaded, follow the INSTALL.txt(https://raw.githubusercontent.com/spring-projects/spring-boot/v3.3.4/spring-boot-project/spring-boot-tools/spring-boot-cli/src/main/content/INSTALL.txt) instructions from the unpacked archive. In summary, there is a spring script ( spring.bat for Windows) in a bin/ directory in the .zip file. Alternatively, you can use java -jar with the .jar file (the script helps you to be sure that the classpath is set correctly). Installation with SDKMAN!: SDKMAN! (The Software Development Kit Manager) can be used for managing multiple versions of various binary SDKs, including Groovy and the Spring Boot CLI. Get SDKMAN! from sdkman.io(https://sdkman.io) and install Spring Boot by using the following commands: $ sdk install springboot $ spring --version Spring CLI v3.3.4 If you develop features for the CLI and want access to the version you built, use the following commands: $ sdk install springboot dev /path/to/spring-boot/spring-boot-cli/target/spring-boot-cli-3.3.4-bin/spring-3.3.4/ $ sdk default springboot dev $ spring --version Spring CLI v3.3.4 The preceding instructions install a local instance of spring called the dev instance. It points at your target build location, so every time you rebuild Spring Boot, spring is up-to-date. You can see it by running the following command: $ sdk ls springboot ================================================================================ Available Springboot Versions ================================================================================ > + dev * 3.3.4 ================================================================================ + - local version * - installed > - currently in use ================================================================================ OSX Homebrew Installation: If you are on a Mac and use Homebrew(https://brew.sh/) , you can install the Spring Boot CLI by using the following commands: $ brew tap spring-io/tap $ brew install spring-boot Homebrew installs spring to /usr/local/bin . If you do not see the formula, your installation of brew might be out-of-date. In that case, run brew update and try again. MacPorts Installation: If you are on a Mac and use MacPorts(https://www.macports.org/) , you can install the Spring Boot CLI by using the following command: $ sudo port install spring-boot-cli Command-line Completion: The Spring Boot CLI includes scripts that provide command completion for the BASH(https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29) and zsh(https://en.wikipedia.org/wiki/Z_shell) shells. You can source the script named spring ( _spring for zsh) or put it in your personal or system-wide bash completion initialization. On a Debian system, the system-wide scripts are in <installation location>/shell-completion/<bash|zsh> and all scripts in that directory are executed when a new shell starts. For example, to run the script manually if you have installed by using SDKMAN!, use the following commands: $ . ~/.sdkman/candidates/springboot/current/shell-completion/bash/spring $ spring <HIT TAB HERE> encodepassword help init shell version If you install the Spring Boot CLI by using Homebrew or MacPorts, the command-line completion scripts are automatically registered with your shell. Windows Scoop Installation: If you are on a Windows and use Scoop(https://scoop.sh/) , you can install the Spring Boot CLI by using the following commands: $ scoop bucket add extras $ scoop install springboot Scoop installs spring to ~/scoop/apps/springboot/current/bin . If you do not see the app manifest, your installation of scoop might be out-of-date. In that case, run scoop update and try again."
"https://docs.spring.io/spring-boot/upgrading.html","Upgrading Spring Boot: Instructions for how to upgrade from earlier versions of Spring Boot are provided on the project wiki(https://github.com/spring-projects/spring-boot/wiki) . Follow the links in the release notes(https://github.com/spring-projects/spring-boot/wiki#release-notes) section to find the version that you want to upgrade to. Upgrading instructions are always the first item in the release notes. If you are more than one release behind, please make sure that you also review the release notes of the versions that you jumped. Upgrading From 1.x: If you are upgrading from the 1.x release of Spring Boot, check the migration guide(https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide) on the project wiki that provides detailed upgrade instructions. Check also the release notes(https://github.com/spring-projects/spring-boot/wiki) for a list of “new and noteworthy” features for each release. Upgrading to a New Feature Release: When upgrading to a new feature release, some properties may have been renamed or removed. Spring Boot provides a way to analyze your application’s environment and print diagnostics at startup, but also temporarily migrate properties at runtime for you. To enable that feature, add the following dependency to your project: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-properties-migrator</artifactId> <scope>runtime</scope> </dependency> Properties that are added late to the environment, such as when using @PropertySource , will not be taken into account. Once you finish the migration, please make sure to remove this module from your project’s dependencies. Upgrading the Spring Boot CLI: To upgrade an existing CLI installation, use the appropriate package manager command (for example, brew upgrade ). If you manually installed the CLI, follow the standard instructions(installing.html#getting-started.installing.cli.manual-installation) , remembering to update your PATH environment variable to remove any older references."
"https://docs.spring.io/spring-boot/tutorial/index.html","Tutorials: This section provides tutorials to help you get started using Spring Boot."
"https://docs.spring.io/spring-boot/tutorial/first-application/index.html","Developing Your First Spring Boot Application: This section describes how to develop a small “Hello World!” web application that highlights some of Spring Boot’s key features. You can choose between Maven or Gradle as the build system. The spring.io(https://spring.io) website contains many “Getting Started” guides(https://spring.io/guides) that use Spring Boot. If you need to solve a specific problem, check there first. You can shortcut the steps below by going to start.spring.io(https://start.spring.io) and choosing the ""Web"" starter from the dependencies searcher. Doing so generates a new project structure so that you can start coding right away(#getting-started.first-application.code) . Check the start.spring.io user guide(https://github.com/spring-io/start.spring.io/blob/main/USING.adoc) for more details. Prerequisites: Before we begin, open a terminal and run the following commands to ensure that you have a valid version of Java installed: $ java -version openjdk version ""17.0.4.1"" 2022-08-12 LTS OpenJDK Runtime Environment (build 17.0.4.1+1-LTS) OpenJDK 64-Bit Server VM (build 17.0.4.1+1-LTS, mixed mode, sharing) This sample needs to be created in its own directory. Subsequent instructions assume that you have created a suitable directory and that it is your current directory. Maven: If you want to use Maven, ensure that you have Maven installed: $ mvn -v Apache Maven 3.8.5 (3599d3414f046de2324203b78ddcf9b5e4388aa0) Maven home: usr/Users/developer/tools/maven/3.8.5 Java version: 17.0.4.1, vendor: BellSoft, runtime: /Users/developer/sdkman/candidates/java/17.0.4.1-librca Gradle: If you want to use Gradle, ensure that you have Gradle installed: $ gradle --version ------------------------------------------------------------ Gradle 8.1.1 ------------------------------------------------------------ Build time: 2023-04-21 12:31:26 UTC Revision: 1cf537a851c635c364a4214885f8b9798051175b Kotlin: 1.8.10 Groovy: 3.0.15 Ant: Apache Ant(TM) version 1.10.11 compiled on July 10 2021 JVM: 17.0.7 (BellSoft 17.0.7+7-LTS) OS: Linux 6.2.12-200.fc37.aarch64 aarch64 Setting Up the Project With Maven: We need to start by creating a Maven pom.xml file. The pom.xml is the recipe that is used to build your project. Open your favorite text editor and add the following: <?xml version=""1.0"" encoding=""UTF-8""?> <project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd""> <modelVersion>4.0.0</modelVersion> <groupId>com.example</groupId> <artifactId>myproject</artifactId> <version>0.0.1-SNAPSHOT</version> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>3.3.4</version> </parent> <!-- Additional lines to be added here... --> </project> The preceding listing should give you a working build. You can test it by running mvn package (for now, you can ignore the “jar will be empty - no content was marked for inclusion!” warning). At this point, you could import the project into an IDE (most modern Java IDEs include built-in support for Maven). For simplicity, we continue to use a plain text editor for this example. Setting Up the Project With Gradle: We need to start by creating a Gradle build.gradle file. The build.gradle is the build script that is used to build your project. Open your favorite text editor and add the following: plugins { id 'java' id 'org.springframework.boot' version '3.3.4' } apply plugin: 'io.spring.dependency-management' group = 'com.example' version = '0.0.1-SNAPSHOT' sourceCompatibility = '17' repositories { mavenCentral() } dependencies { } The preceding listing should give you a working build. You can test it by running gradle classes . At this point, you could import the project into an IDE (most modern Java IDEs include built-in support for Gradle). For simplicity, we continue to use a plain text editor for this example. Adding Classpath Dependencies: Spring Boot provides a number of starters that let you add jars to your classpath. Starters provide dependencies that you are likely to need when developing a specific type of application. Maven: Most Spring Boot applications use the spring-boot-starter-parent in the parent section of the POM. The spring-boot-starter-parent is a special starter that provides useful Maven defaults. It also provides a dependency-management(../../reference/using/build-systems.html#using.build-systems.dependency-management) section so that you can omit version tags for “blessed” dependencies. Since we are developing a web application, we add a spring-boot-starter-web dependency. Before that, we can look at what we currently have by running the following command: $ mvn dependency:tree [INFO] com.example:myproject:jar:0.0.1-SNAPSHOT The mvn dependency:tree command prints a tree representation of your project dependencies. You can see that spring-boot-starter-parent provides no dependencies by itself. To add the necessary dependencies, edit your pom.xml and add the spring-boot-starter-web dependency immediately below the parent section: <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> </dependencies> If you run mvn dependency:tree again, you see that there are now a number of additional dependencies, including the Tomcat web server and Spring Boot itself. Gradle: Most Spring Boot applications use the org.springframework.boot Gradle plugin. This plugin provides useful defaults and Gradle tasks. The io.spring.dependency-management Gradle plugin provides dependency management(../../reference/using/build-systems.html#using.build-systems.dependency-management) so that you can omit version tags for “blessed” dependencies. Since we are developing a web application, we add a spring-boot-starter-web dependency. Before that, we can look at what we currently have by running the following command: $ gradle dependencies > Task :dependencies ------------------------------------------------------------ Root project 'myproject' ------------------------------------------------------------ The gradle dependencies command prints a tree representation of your project dependencies. Right now, the project has no dependencies. To add the necessary dependencies, edit your build.gradle and add the spring-boot-starter-web dependency in the dependencies section: dependencies { implementation 'org.springframework.boot:spring-boot-starter-web' } If you run gradle dependencies again, you see that there are now a number of additional dependencies, including the Tomcat web server and Spring Boot itself. Writing the Code: To finish our application, we need to create a single Java file. By default, Maven and Gradle compile sources from src/main/java , so you need to create that directory structure and then add a file named src/main/java/MyApplication.java to contain the following code: Java Kotlin import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @SpringBootApplication public class MyApplication { @RequestMapping(""/"") String home() { return ""Hello World!""; } public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication import org.springframework.web.bind.annotation.RequestMapping import org.springframework.web.bind.annotation.RestController @RestController @SpringBootApplication class MyApplication { @RequestMapping(""/"") fun home() = ""Hello World!"" } fun main(args: Array<String>) { runApplication<MyApplication>(*args) } Although there is not much code here, quite a lot is going on. We step through the important parts in the next few sections. The @RestController and @RequestMapping Annotations: The first annotation on our MyApplication class is @RestController . This is known as a stereotype annotation. It provides hints for people reading the code and for Spring that the class plays a specific role. In this case, our class is a web @Controller , so Spring considers it when handling incoming web requests. The @RequestMapping annotation provides “routing” information. It tells Spring that any HTTP request with the / path should be mapped to the home method. The @RestController annotation tells Spring to render the resulting string directly back to the caller. The @RestController and @RequestMapping annotations are Spring MVC annotations (they are not specific to Spring Boot). See the MVC section(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc.html) in the Spring Reference Documentation for more details. The @SpringBootApplication Annotation: The second class-level annotation is @SpringBootApplication . This annotation is known as a meta-annotation , it combines @SpringBootConfiguration , @EnableAutoConfiguration and @ComponentScan . Of those, the annotation we’re most interested in here is @EnableAutoConfiguration . @EnableAutoConfiguration tells Spring Boot to “guess” how you want to configure Spring, based on the jar dependencies that you have added. Since spring-boot-starter-web added Tomcat and Spring MVC, the auto-configuration assumes that you are developing a web application and sets up Spring accordingly. Starters and Auto-configuration Auto-configuration is designed to work well with starters, but the two concepts are not directly tied. You are free to pick and choose jar dependencies outside of the starters. Spring Boot still does its best to auto-configure your application. The “main” Method: The final part of our application is the main method. This is a standard method that follows the Java convention for an application entry point. Our main method delegates to Spring Boot’s SpringApplication class by calling run . SpringApplication bootstraps our application, starting Spring, which, in turn, starts the auto-configured Tomcat web server. We need to pass MyApplication.class as an argument to the run method to tell SpringApplication which is the primary Spring component. The args array is also passed through to expose any command-line arguments. Running the Example: Maven: At this point, your application should work. Since you used the spring-boot-starter-parent POM, you have a useful run goal that you can use to start the application. Type mvn spring-boot:run from the root project directory to start the application. You should see output similar to the following: $ mvn spring-boot:run . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v3.3.4) ....... . . . ....... . . . (log output here) ....... . . . ........ Started MyApplication in 0.906 seconds (process running for 6.514) If you open a web browser to localhost:8080(http://localhost:8080) , you should see the following output: Hello World! To gracefully exit the application, press ctrl-c . Gradle: At this point, your application should work. Since you used the org.springframework.boot Gradle plugin, you have a useful bootRun goal that you can use to start the application. Type gradle bootRun from the root project directory to start the application. You should see output similar to the following: $ gradle bootRun . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v3.3.4) ....... . . . ....... . . . (log output here) ....... . . . ........ Started MyApplication in 0.906 seconds (process running for 6.514) If you open a web browser to localhost:8080(http://localhost:8080) , you should see the following output: Hello World! To gracefully exit the application, press ctrl-c . Creating an Executable Jar: We finish our example by creating a completely self-contained executable jar file that we could run in production. Executable jars (sometimes called “uber jars” or “fat jars”) are archives containing your compiled classes along with all of the jar dependencies that your code needs to run. Executable jars and Java Java does not provide a standard way to load nested jar files (jar files that are themselves contained within a jar). This can be problematic if you are looking to distribute a self-contained application. To solve this problem, many developers use “uber” jars. An uber jar packages all the classes from all the application’s dependencies into a single archive. The problem with this approach is that it becomes hard to see which libraries are in your application. It can also be problematic if the same filename is used (but with different content) in multiple jars. Spring Boot takes a different approach(../../specification/executable-jar/index.html) and lets you actually nest jars directly. Maven: To create an executable jar, we need to add the spring-boot-maven-plugin to our pom.xml . To do so, insert the following lines just below the dependencies section: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> The spring-boot-starter-parent POM includes <executions> configuration to bind the repackage goal. If you do not use the parent POM, you need to declare this configuration yourself. See the plugin documentation(../../maven-plugin/getting-started.html) for details. Save your pom.xml and run mvn package from the command line, as follows: $ mvn package [INFO] Scanning for projects... [INFO] [INFO] ------------------------------------------------------------------------ [INFO] Building myproject 0.0.1-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] .... .. [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject --- [INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar [INFO] [INFO] --- spring-boot-maven-plugin:3.3.4:repackage (default) @ myproject --- [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ If you look in the target directory, you should see myproject-0.0.1-SNAPSHOT.jar . The file should be around 18 MB in size. If you want to peek inside, you can use jar tvf , as follows: $ jar tvf target/myproject-0.0.1-SNAPSHOT.jar You should also see a much smaller file named myproject-0.0.1-SNAPSHOT.jar.original in the target directory. This is the original jar file that Maven created before it was repackaged by Spring Boot. To run that application, use the java -jar command, as follows: $ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v3.3.4) ....... . . . ....... . . . (log output here) ....... . . . ........ Started MyApplication in 0.999 seconds (process running for 1.253) As before, to exit the application, press ctrl-c . Gradle: To create an executable jar, we need to run gradle bootJar from the command line, as follows: $ gradle bootJar BUILD SUCCESSFUL in 639ms 3 actionable tasks: 3 executed If you look in the build/libs directory, you should see myproject-0.0.1-SNAPSHOT.jar . The file should be around 18 MB in size. If you want to peek inside, you can use jar tvf , as follows: $ jar tvf build/libs/myproject-0.0.1-SNAPSHOT.jar To run that application, use the java -jar command, as follows: $ java -jar build/libs/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v{version-spring-boot}) ....... . . . ....... . . . (log output here) ....... . . . ........ Started MyApplication in 0.999 seconds (process running for 1.253) As before, to exit the application, press ctrl-c ."
"https://docs.spring.io/spring-boot/reference/index.html","Reference: This section provides information on using the features and capabilities of Spring Boot."
"https://docs.spring.io/spring-boot/reference/using/index.html","Developing with Spring Boot: This section goes into more detail about how you should use Spring Boot. It covers topics such as build systems, auto-configuration, and how to run your applications. We also cover some Spring Boot best practices. Although there is nothing particularly special about Spring Boot (it is just another library that you can consume), there are a few recommendations that, when followed, make your development process a little easier. If you are starting out with Spring Boot, you should probably read the Developing Your First Spring Boot Application(../../tutorial/first-application/index.html) tutorial before diving into this section."
"https://docs.spring.io/spring-boot/reference/using/build-systems.html","Build Systems: It is strongly recommended that you choose a build system that supports dependency management(#using.build-systems.dependency-management) and that can consume artifacts published to the Maven Central repository. We would recommend that you choose Maven or Gradle. It is possible to get Spring Boot to work with other build systems (Ant, for example), but they are not particularly well supported. Dependency Management: Each release of Spring Boot provides a curated list of dependencies that it supports. In practice, you do not need to provide a version for any of these dependencies in your build configuration, as Spring Boot manages that for you. When you upgrade Spring Boot itself, these dependencies are upgraded as well in a consistent way. You can still specify a version and override Spring Boot’s recommendations if you need to do so. The curated list contains all the Spring modules that you can use with Spring Boot as well as a refined list of third party libraries. The list is available as a standard Bills of Materials ( spring-boot-dependencies ) that can be used with both Maven(#using.build-systems.maven) and Gradle(#using.build-systems.gradle) . Each release of Spring Boot is associated with a base version of the Spring Framework. We highly recommend that you do not specify its version. Maven: To learn about using Spring Boot with Maven, see the documentation for Spring Boot’s Maven plugin: Reference(../../maven-plugin/index.html) API(../../maven-plugin/api/java/index.html) Gradle: To learn about using Spring Boot with Gradle, see the documentation for Spring Boot’s Gradle plugin: Reference(../../gradle-plugin/index.html) API(../../gradle-plugin/api/java/index.html) Ant: It is possible to build a Spring Boot project using Apache Ant+Ivy. The spring-boot-antlib “AntLib” module is also available to help Ant create executable jars. To declare dependencies, a typical ivy.xml file looks something like the following example: <ivy-module version=""2.0""> <info organisation=""org.springframework.boot"" module=""spring-boot-sample-ant"" /> <configurations> <conf name=""compile"" description=""everything needed to compile this module"" /> <conf name=""runtime"" extends=""compile"" description=""everything needed to run this module"" /> </configurations> <dependencies> <dependency org=""org.springframework.boot"" name=""spring-boot-starter"" rev=""${spring-boot.version}"" conf=""compile"" /> </dependencies> </ivy-module> A typical build.xml looks like the following example: <project xmlns:ivy=""antlib:org.apache.ivy.ant"" xmlns:spring-boot=""antlib:org.springframework.boot.ant"" name=""myapp"" default=""build""> <property name=""spring-boot.version"" value=""3.3.4"" /> <target name=""resolve"" description=""--> retrieve dependencies with ivy""> <ivy:retrieve pattern=""lib/[conf]/[artifact]-[type]-[revision].[ext]"" /> </target> <target name=""classpaths"" depends=""resolve""> <path id=""compile.classpath""> <fileset dir=""lib/compile"" includes=""*.jar"" /> </path> </target> <target name=""init"" depends=""classpaths""> <mkdir dir=""build/classes"" /> </target> <target name=""compile"" depends=""init"" description=""compile""> <javac srcdir=""src/main/java"" destdir=""build/classes"" classpathref=""compile.classpath"" /> </target> <target name=""build"" depends=""compile""> <spring-boot:exejar destfile=""build/myapp.jar"" classes=""build/classes""> <spring-boot:lib> <fileset dir=""lib/runtime"" /> </spring-boot:lib> </spring-boot:exejar> </target> </project> If you do not want to use the spring-boot-antlib module, see the Build an Executable Archive From Ant without Using spring-boot-antlib(../../how-to/build.html#howto.build.build-an-executable-archive-with-ant-without-using-spring-boot-antlib) section of “How-to Guides”. Starters: Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop shop for all the Spring and related technologies that you need without having to hunt through sample code and copy-paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, include the spring-boot-starter-data-jpa dependency in your project. The starters contain a lot of the dependencies that you need to get a project up and running quickly and with a consistent, supported set of managed transitive dependencies. What is in a name All official starters follow a similar naming pattern; spring-boot-starter-* , where * is a particular type of application. This naming structure is intended to help when you need to find a starter. The Maven integration in many IDEs lets you search dependencies by name. For example, with the appropriate Eclipse or Spring Tools plugin installed, you can press ctrl-space in the POM editor and type “spring-boot-starter” for a complete list. As explained in the Creating Your Own Starter(../features/developing-auto-configuration.html#features.developing-auto-configuration.custom-starter) section, third party starters should not start with spring-boot , as it is reserved for official Spring Boot artifacts. Rather, a third-party starter typically starts with the name of the project. For example, a third-party starter project called thirdpartyproject would typically be named thirdpartyproject-spring-boot-starter . The following application starters are provided by Spring Boot under the org.springframework.boot group: Table 1. Spring Boot application starters Name Description () spring-boot-starter Core starter, including auto-configuration support, logging and YAML () spring-boot-starter-activemq Starter for JMS messaging using Apache ActiveMQ () spring-boot-starter-amqp Starter for using Spring AMQP and Rabbit MQ () spring-boot-starter-aop Starter for aspect-oriented programming with Spring AOP and AspectJ () spring-boot-starter-artemis Starter for JMS messaging using Apache Artemis () spring-boot-starter-batch Starter for using Spring Batch () spring-boot-starter-cache Starter for using Spring Framework’s caching support () spring-boot-starter-data-cassandra Starter for using Cassandra distributed database and Spring Data Cassandra () spring-boot-starter-data-cassandra-reactive Starter for using Cassandra distributed database and Spring Data Cassandra Reactive () spring-boot-starter-data-couchbase Starter for using Couchbase document-oriented database and Spring Data Couchbase () spring-boot-starter-data-couchbase-reactive Starter for using Couchbase document-oriented database and Spring Data Couchbase Reactive () spring-boot-starter-data-elasticsearch Starter for using Elasticsearch search and analytics engine and Spring Data Elasticsearch () spring-boot-starter-data-jdbc Starter for using Spring Data JDBC () spring-boot-starter-data-jpa Starter for using Spring Data JPA with Hibernate () spring-boot-starter-data-ldap Starter for using Spring Data LDAP () spring-boot-starter-data-mongodb Starter for using MongoDB document-oriented database and Spring Data MongoDB () spring-boot-starter-data-mongodb-reactive Starter for using MongoDB document-oriented database and Spring Data MongoDB Reactive () spring-boot-starter-data-neo4j Starter for using Neo4j graph database and Spring Data Neo4j () spring-boot-starter-data-r2dbc Starter for using Spring Data R2DBC () spring-boot-starter-data-redis Starter for using Redis key-value data store with Spring Data Redis and the Lettuce client () spring-boot-starter-data-redis-reactive Starter for using Redis key-value data store with Spring Data Redis reactive and the Lettuce client () spring-boot-starter-data-rest Starter for exposing Spring Data repositories over REST using Spring Data REST and Spring MVC () spring-boot-starter-freemarker Starter for building MVC web applications using FreeMarker views () spring-boot-starter-graphql Starter for building GraphQL applications with Spring GraphQL () spring-boot-starter-groovy-templates Starter for building MVC web applications using Groovy Templates views () spring-boot-starter-hateoas Starter for building hypermedia-based RESTful web application with Spring MVC and Spring HATEOAS () spring-boot-starter-integration Starter for using Spring Integration () spring-boot-starter-jdbc Starter for using JDBC with the HikariCP connection pool () spring-boot-starter-jersey Starter for building RESTful web applications using JAX-RS and Jersey. An alternative to spring-boot-starter-web(#spring-boot-starter-web) () spring-boot-starter-jooq Starter for using jOOQ to access SQL databases with JDBC. An alternative to spring-boot-starter-data-jpa(#spring-boot-starter-data-jpa) or spring-boot-starter-jdbc(#spring-boot-starter-jdbc) () spring-boot-starter-json Starter for reading and writing json () spring-boot-starter-mail Starter for using Java Mail and Spring Framework’s email sending support () spring-boot-starter-mustache Starter for building web applications using Mustache views () spring-boot-starter-oauth2-authorization-server Starter for using Spring Authorization Server features () spring-boot-starter-oauth2-client Starter for using Spring Security’s OAuth2/OpenID Connect client features () spring-boot-starter-oauth2-resource-server Starter for using Spring Security’s OAuth2 resource server features () spring-boot-starter-pulsar Starter for using Spring for Apache Pulsar () spring-boot-starter-pulsar-reactive Starter for using Spring for Apache Pulsar Reactive () spring-boot-starter-quartz Starter for using the Quartz scheduler () spring-boot-starter-rsocket Starter for building RSocket clients and servers () spring-boot-starter-security Starter for using Spring Security () spring-boot-starter-test Starter for testing Spring Boot applications with libraries including JUnit Jupiter, Hamcrest and Mockito () spring-boot-starter-thymeleaf Starter for building MVC web applications using Thymeleaf views () spring-boot-starter-validation Starter for using Java Bean Validation with Hibernate Validator () spring-boot-starter-web Starter for building web, including RESTful, applications using Spring MVC. Uses Tomcat as the default embedded container () spring-boot-starter-web-services Starter for using Spring Web Services () spring-boot-starter-webflux Starter for building WebFlux applications using Spring Framework’s Reactive Web support () spring-boot-starter-websocket Starter for building WebSocket applications using Spring Framework’s MVC WebSocket support In addition to the application starters, the following starters can be used to add production ready(../../how-to/actuator.html) features: Table 2. Spring Boot production starters Name Description () spring-boot-starter-actuator Starter for using Spring Boot’s Actuator which provides production ready features to help you monitor and manage your application Finally, Spring Boot also includes the following starters that can be used if you want to exclude or swap specific technical facets: Table 3. Spring Boot technical starters Name Description () spring-boot-starter-jetty Starter for using Jetty as the embedded servlet container. An alternative to spring-boot-starter-tomcat(#spring-boot-starter-tomcat) () spring-boot-starter-log4j2 Starter for using Log4j2 for logging. An alternative to spring-boot-starter-logging(#spring-boot-starter-logging) () spring-boot-starter-logging Starter for logging using Logback. Default logging starter () spring-boot-starter-reactor-netty Starter for using Reactor Netty as the embedded reactive HTTP server. () spring-boot-starter-tomcat Starter for using Tomcat as the embedded servlet container. Default servlet container starter used by spring-boot-starter-web(#spring-boot-starter-web) () spring-boot-starter-undertow Starter for using Undertow as the embedded servlet container. An alternative to spring-boot-starter-tomcat(#spring-boot-starter-tomcat) To learn how to swap technical facets, please see the how-to documentation for swapping web server(../../how-to/webserver.html#howto.webserver.use-another) and logging system(../../how-to/logging.html#howto.logging.log4j) . For a list of additional community contributed starters, see the README file(https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-starters/README.adoc) in the spring-boot-starters module on GitHub."
"https://docs.spring.io/spring-boot/reference/using/structuring-your-code.html","Structuring Your Code: Spring Boot does not require any specific code layout to work. However, there are some best practices that help. If you wish to enforce a structure based on domains, take a look at Spring Modulith(https://spring.io/projects/spring-modulith#overview) . Using the “default” Package: When a class does not include a package declaration, it is considered to be in the “default package”. The use of the “default package” is generally discouraged and should be avoided. It can cause particular problems for Spring Boot applications that use the @ComponentScan , @ConfigurationPropertiesScan , @EntityScan , or @SpringBootApplication annotations, since every class from every jar is read. We recommend that you follow Java’s recommended package naming conventions and use a reversed domain name (for example, com.example.project ). Locating the Main Application Class: We generally recommend that you locate your main application class in a root package above other classes. The @SpringBootApplication annotation(using-the-springbootapplication-annotation.html) is often placed on your main class, and it implicitly defines a base “search package” for certain items. For example, if you are writing a JPA application, the package of the @SpringBootApplication annotated class is used to search for @Entity items. Using a root package also allows component scan to apply only on your project. If you do not want to use @SpringBootApplication , the @EnableAutoConfiguration and @ComponentScan annotations that it imports defines that behavior so you can also use those instead. The following listing shows a typical layout: com +- example +- myapplication +- MyApplication.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java The MyApplication.java file would declare the main method, along with the basic @SpringBootApplication , as follows: Java Kotlin import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication @SpringBootApplication class MyApplication fun main(args: Array<String>) { runApplication<MyApplication>(*args) }"
"https://docs.spring.io/spring-boot/reference/using/configuration-classes.html","Configuration Classes: Spring Boot favors Java-based configuration. Although it is possible to use SpringApplication with XML sources, we generally recommend that your primary source be a single @Configuration class. Usually the class that defines the main method is a good candidate as the primary @Configuration . Many Spring configuration examples have been published on the Internet that use XML configuration. If possible, always try to use the equivalent Java-based configuration. Searching for Enable* annotations can be a good starting point. Importing Additional Configuration Classes: You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes. Alternatively, you can use @ComponentScan to automatically pick up all Spring components, including @Configuration classes. Importing XML Configuration: If you absolutely must use XML based configuration, we recommend that you still start with a @Configuration class. You can then use an @ImportResource annotation to load XML configuration files."
"https://docs.spring.io/spring-boot/reference/using/auto-configuration.html","Auto-configuration: Spring Boot auto-configuration attempts to automatically configure your Spring application based on the jar dependencies that you have added. For example, if HSQLDB is on your classpath, and you have not manually configured any database connection beans, then Spring Boot auto-configures an in-memory database. You need to opt-in to auto-configuration by adding the @EnableAutoConfiguration or @SpringBootApplication annotations to one of your @Configuration classes. You should only ever add one @SpringBootApplication or @EnableAutoConfiguration annotation. We generally recommend that you add one or the other to your primary @Configuration class only. Gradually Replacing Auto-configuration: Auto-configuration is non-invasive. At any point, you can start to define your own configuration to replace specific parts of the auto-configuration. For example, if you add your own DataSource bean, the default embedded database support backs away. If you need to find out what auto-configuration is currently being applied, and why, start your application with the --debug switch. Doing so enables debug logs for a selection of core loggers and logs a conditions report to the console. Disabling Specific Auto-configuration Classes: If you find that specific auto-configuration classes that you do not want are being applied, you can use the exclude attribute of @SpringBootApplication to disable them, as shown in the following example: Java Kotlin import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration; @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class }) public class MyApplication { } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration @SpringBootApplication(exclude = [DataSourceAutoConfiguration::class]) class MyApplication If the class is not on the classpath, you can use the excludeName attribute of the annotation and specify the fully qualified name instead. If you prefer to use @EnableAutoConfiguration rather than @SpringBootApplication , exclude and excludeName are also available. Finally, you can also control the list of auto-configuration classes to exclude by using the spring.autoconfigure.exclude property. You can define exclusions both at the annotation level and by using the property. Even though auto-configuration classes are public , the only aspect of the class that is considered public API is the name of the class which can be used for disabling the auto-configuration. The actual contents of those classes, such as nested configuration classes or bean methods are for internal use only and we do not recommend using those directly. Auto-configuration Packages: Auto-configuration packages are the packages that various auto-configured features look in by default when scanning for things such as entities and Spring Data repositories. The @EnableAutoConfiguration annotation (either directly or through its presence on @SpringBootApplication ) determines the default auto-configuration package. Additional packages can be configured using the @AutoConfigurationPackage annotation."
"https://docs.spring.io/spring-boot/reference/using/spring-beans-and-dependency-injection.html","Spring Beans and Dependency Injection: You are free to use any of the standard Spring Framework techniques to define your beans and their injected dependencies. We generally recommend using constructor injection to wire up dependencies and @ComponentScan to find beans. If you structure your code as suggested above (locating your application class in a top package), you can add @ComponentScan without any arguments or use the @SpringBootApplication annotation which implicitly includes it. All of your application components ( @Component , @Service , @Repository , @Controller , and others) are automatically registered as Spring Beans. The following example shows a @Service Bean that uses constructor injection to obtain a required RiskAssessor bean: Java Kotlin import org.springframework.stereotype.Service; @Service public class MyAccountService implements AccountService { private final RiskAssessor riskAssessor; public MyAccountService(RiskAssessor riskAssessor) { this.riskAssessor = riskAssessor; } // ... } import org.springframework.stereotype.Service @Service class MyAccountService(private val riskAssessor: RiskAssessor) : AccountService If a bean has more than one constructor, you will need to mark the one you want Spring to use with @Autowired : Java Kotlin import java.io.PrintStream; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class MyAccountService implements AccountService { private final RiskAssessor riskAssessor; private final PrintStream out; @Autowired public MyAccountService(RiskAssessor riskAssessor) { this.riskAssessor = riskAssessor; this.out = System.out; } public MyAccountService(RiskAssessor riskAssessor, PrintStream out) { this.riskAssessor = riskAssessor; this.out = out; } // ... } import org.springframework.beans.factory.annotation.Autowired import org.springframework.stereotype.Service import java.io.PrintStream @Service class MyAccountService : AccountService { private val riskAssessor: RiskAssessor private val out: PrintStream @Autowired constructor(riskAssessor: RiskAssessor) { this.riskAssessor = riskAssessor out = System.out } constructor(riskAssessor: RiskAssessor, out: PrintStream) { this.riskAssessor = riskAssessor this.out = out } // ... } Notice how using constructor injection lets the riskAssessor field be marked as final , indicating that it cannot be subsequently changed."
"https://docs.spring.io/spring-boot/reference/using/using-the-springbootapplication-annotation.html","Using the @SpringBootApplication Annotation: Many Spring Boot developers like their apps to use auto-configuration, component scan and be able to define extra configuration on their ""application class"". A single @SpringBootApplication annotation can be used to enable those three features, that is: @EnableAutoConfiguration : enable Spring Boot’s auto-configuration mechanism(auto-configuration.html) @ComponentScan : enable @Component scan on the package where the application is located (see the best practices(structuring-your-code.html) ) @SpringBootConfiguration : enable registration of extra beans in the context or the import of additional configuration classes. An alternative to Spring’s standard @Configuration that aids configuration detection(../testing/spring-boot-applications.html#testing.spring-boot-applications.detecting-configuration) in your integration tests. Java Kotlin import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; // Same as @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication // same as @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan @SpringBootApplication class MyApplication fun main(args: Array<String>) { runApplication<MyApplication>(*args) } @SpringBootApplication also provides aliases to customize the attributes of @EnableAutoConfiguration and @ComponentScan . None of these features are mandatory and you may choose to replace this single annotation by any of the features that it enables. For instance, you may not want to use component scan or configuration properties scan in your application: Java Kotlin import org.springframework.boot.SpringApplication; import org.springframework.boot.SpringBootConfiguration; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.context.annotation.Import; @SpringBootConfiguration(proxyBeanMethods = false) @EnableAutoConfiguration @Import({ SomeConfiguration.class, AnotherConfiguration.class }) public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } import org.springframework.boot.SpringBootConfiguration import org.springframework.boot.autoconfigure.EnableAutoConfiguration import org.springframework.boot.docs.using.structuringyourcode.locatingthemainclass.MyApplication import org.springframework.boot.runApplication import org.springframework.context.annotation.Import @SpringBootConfiguration(proxyBeanMethods = false) @EnableAutoConfiguration @Import(SomeConfiguration::class, AnotherConfiguration::class) class MyApplication fun main(args: Array<String>) { runApplication<MyApplication>(*args) } In this example, MyApplication is just like any other Spring Boot application except that @Component -annotated classes and @ConfigurationProperties -annotated classes are not detected automatically and the user-defined beans are imported explicitly (see @Import )."
"https://docs.spring.io/spring-boot/reference/using/running-your-application.html","Running Your Application: One of the biggest advantages of packaging your application as a jar and using an embedded HTTP server is that you can run your application as you would any other. The sample applies to debugging Spring Boot applications. You do not need any special IDE plugins or extensions. The options below are best suited for running an application locally for development. For production deployment, see Packaging Your Application for Production(packaging-for-production.html) . This section only covers jar-based packaging. If you choose to package your application as a war file, see your server and IDE documentation. Running From an IDE: You can run a Spring Boot application from your IDE as a Java application. However, you first need to import your project. Import steps vary depending on your IDE and build system. Most IDEs can import Maven projects directly. For example, Eclipse users can select Import…​ → Existing Maven Projects from the File menu. If you cannot directly import your project into your IDE, you may be able to generate IDE metadata by using a build plugin. Maven includes plugins for Eclipse(https://maven.apache.org/plugins/maven-eclipse-plugin/) and IDEA(https://maven.apache.org/plugins/maven-idea-plugin/) . Gradle offers plugins for various IDEs(https://docs.gradle.org/current/userguide/userguide.html) . If you accidentally run a web application twice, you see a “Port already in use” error. Spring Tools users can use the Relaunch button rather than the Run button to ensure that any existing instance is closed. Running as a Packaged Application: If you use the Spring Boot Maven or Gradle plugins to create an executable jar, you can run your application using java -jar , as shown in the following example: $ java -jar target/myapplication-0.0.1-SNAPSHOT.jar It is also possible to run a packaged application with remote debugging support enabled. Doing so lets you attach a debugger to your packaged application, as shown in the following example: $ java -agentlib:jdwp=server=y,transport=dt_socket,address=8000,suspend=n \ -jar target/myapplication-0.0.1-SNAPSHOT.jar Using the Maven Plugin: The Spring Boot Maven plugin includes a run goal that can be used to quickly compile and run your application. Applications run in an exploded form, as they do in your IDE. The following example shows a typical Maven command to run a Spring Boot application: $ mvn spring-boot:run You might also want to use the MAVEN_OPTS operating system environment variable, as shown in the following example: $ export MAVEN_OPTS=-Xmx1024m Using the Gradle Plugin: The Spring Boot Gradle plugin also includes a bootRun task that can be used to run your application in an exploded form. The bootRun task is added whenever you apply the org.springframework.boot and java plugins and is shown in the following example: $ gradle bootRun You might also want to use the JAVA_OPTS operating system environment variable, as shown in the following example: $ export JAVA_OPTS=-Xmx1024m Hot Swapping: Since Spring Boot applications are plain Java applications, JVM hot-swapping should work out of the box. JVM hot swapping is somewhat limited with the bytecode that it can replace. For a more complete solution, JRebel(https://www.jrebel.com/products/jrebel) can be used. The spring-boot-devtools module also includes support for quick application restarts. See the Hot Swapping(../../how-to/hotswapping.html) section in “How-to Guides” for details."
"https://docs.spring.io/spring-boot/reference/using/devtools.html","Developer Tools: Spring Boot includes an additional set of tools that can make the application development experience a little more pleasant. The spring-boot-devtools module can be included in any project to provide additional development-time features. To include devtools support, add the module dependency to your build, as shown in the following listings for Maven and Gradle: Maven <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> <optional>true</optional> </dependency> </dependencies> Gradle dependencies { developmentOnly(""org.springframework.boot:spring-boot-devtools"") } Devtools might cause classloading issues, in particular in multi-module projects. Diagnosing Classloading Issues(#using.devtools.diagnosing-classloading-issues) explains how to diagnose and solve them. Developer tools are automatically disabled when running a fully packaged application. If your application is launched from java -jar or if it is started from a special classloader, then it is considered a “production application”. You can control this behavior by using the spring.devtools.restart.enabled system property. To enable devtools, irrespective of the classloader used to launch your application, set the -Dspring.devtools.restart.enabled=true system property. This must not be done in a production environment where running devtools is a security risk. To disable devtools, exclude the dependency or set the -Dspring.devtools.restart.enabled=false system property. Flagging the dependency as optional in Maven or using the developmentOnly configuration in Gradle (as shown above) prevents devtools from being transitively applied to other modules that use your project. Repackaged archives do not contain devtools by default. If you want to use a certain remote devtools feature(#using.devtools.remote-applications) , you need to include it. When using the Maven plugin, set the excludeDevtools property to false . When using the Gradle plugin, configure the task’s classpath to include the developmentOnly configuration(../../gradle-plugin/packaging.html#packaging-executable.configuring.including-development-only-dependencies) . Diagnosing Classloading Issues: As described in the Restart vs Reload(#using.devtools.restart.restart-vs-reload) section, restart functionality is implemented by using two classloaders. For most applications, this approach works well. However, it can sometimes cause classloading issues, in particular in multi-module projects. To diagnose whether the classloading issues are indeed caused by devtools and its two classloaders, try disabling restart(#using.devtools.restart.disable) . If this solves your problems, customize the restart classloader(#using.devtools.restart.customizing-the-classload) to include your entire project. Property Defaults: Several of the libraries supported by Spring Boot use caches to improve performance. For example, template engines(../web/servlet.html#web.servlet.spring-mvc.template-engines) cache compiled templates to avoid repeatedly parsing template files. Also, Spring MVC can add HTTP caching headers to responses when serving static resources. While caching is very beneficial in production, it can be counter-productive during development, preventing you from seeing the changes you just made in your application. For this reason, spring-boot-devtools disables the caching options by default. Cache options are usually configured by settings in your application.properties file. For example, Thymeleaf offers the spring.thymeleaf.cache property. Rather than needing to set these properties manually, the spring-boot-devtools module automatically applies sensible development-time configuration. The following table lists all the properties that are applied: Name Default Value server.error.include-binding-errors always server.error.include-message always server.error.include-stacktrace always server.servlet.jsp.init-parameters.development true server.servlet.session.persistent true spring.docker.compose.readiness.wait only-if-started spring.freemarker.cache false spring.graphql.graphiql.enabled true spring.groovy.template.cache false spring.h2.console.enabled true spring.mustache.servlet.cache false spring.mvc.log-resolved-exception true spring.reactor.netty.shutdown-quiet-period 0s spring.template.provider.cache false spring.thymeleaf.cache false spring.web.resources.cache.period 0 spring.web.resources.chain.cache false If you do not want property defaults to be applied you can set spring.devtools.add-properties to false in your application.properties . Because you need more information about web requests while developing Spring MVC and Spring WebFlux applications, developer tools suggests you to enable DEBUG logging for the web logging group. This will give you information about the incoming request, which handler is processing it, the response outcome, and other details. If you wish to log all request details (including potentially sensitive information), you can turn on the spring.mvc.log-request-details or spring.codec.log-request-details configuration properties. Automatic Restart: Applications that use spring-boot-devtools automatically restart whenever files on the classpath change. This can be a useful feature when working in an IDE, as it gives a very fast feedback loop for code changes. By default, any entry on the classpath that points to a directory is monitored for changes. Note that certain resources, such as static assets and view templates, do not need to restart the application(#using.devtools.restart.excluding-resources) . Triggering a restart As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. Whether you’re using an IDE or one of the build plugins, the modified files have to be recompiled to trigger a restart. The way in which you cause the classpath to be updated depends on the tool that you are using: In Eclipse, saving a modified file causes the classpath to be updated and triggers a restart. In IntelliJ IDEA, building the project ( Build -> Build Project ) has the same effect. If using a build plugin, running mvn compile for Maven or gradle build for Gradle will trigger a restart. If you are restarting with Maven or Gradle using the build plugin you must leave the forking set to enabled . If you disable forking, the isolated application classloader used by devtools will not be created and restarts will not operate properly. Automatic restart works very well when used with LiveReload. See the LiveReload(#using.devtools.livereload) section for details. If you use JRebel, automatic restarts are disabled in favor of dynamic class reloading. Other devtools features (such as LiveReload and property overrides) can still be used. DevTools relies on the application context’s shutdown hook to close it during a restart. It does not work correctly if you have disabled the shutdown hook ( SpringApplication.setRegisterShutdownHook(false) ). DevTools needs to customize the ResourceLoader used by the ApplicationContext . If your application provides one already, it is going to be wrapped. Direct override of the getResource method on the ApplicationContext is not supported. Automatic restart is not supported when using AspectJ weaving. Restart vs Reload The restart technology provided by Spring Boot works by using two classloaders. Classes that do not change (for example, those from third-party jars) are loaded into a base classloader. Classes that you are actively developing are loaded into a restart classloader. When the application is restarted, the restart classloader is thrown away and a new one is created. This approach means that application restarts are typically much faster than “cold starts”, since the base classloader is already available and populated. If you find that restarts are not quick enough for your applications or you encounter classloading issues, you could consider reloading technologies such as JRebel(https://jrebel.com/software/jrebel/) from ZeroTurnaround. These work by rewriting classes as they are loaded to make them more amenable to reloading. Logging Changes in Condition Evaluation: By default, each time your application restarts, a report showing the condition evaluation delta is logged. The report shows the changes to your application’s auto-configuration as you make changes such as adding or removing beans and setting configuration properties. To disable the logging of the report, set the following property: Properties YAML spring.devtools.restart.log-condition-evaluation-delta=false spring: devtools: restart: log-condition-evaluation-delta: false Excluding Resources: Certain resources do not necessarily need to trigger a restart when they are changed. For example, Thymeleaf templates can be edited in-place. By default, changing resources in /META-INF/maven , /META-INF/resources , /resources , /static , /public , or /templates does not trigger a restart but does trigger a live reload(#using.devtools.livereload) . If you want to customize these exclusions, you can use the spring.devtools.restart.exclude property. For example, to exclude only /static and /public you would set the following property: Properties YAML spring.devtools.restart.exclude=static/**,public/** spring: devtools: restart: exclude: ""static/**,public/**"" If you want to keep those defaults and add additional exclusions, use the spring.devtools.restart.additional-exclude property instead. Watching Additional Paths: You may want your application to be restarted or reloaded when you make changes to files that are not on the classpath. To do so, use the spring.devtools.restart.additional-paths property to configure additional paths to watch for changes. You can use the spring.devtools.restart.exclude property described earlier(#using.devtools.restart.excluding-resources) to control whether changes beneath the additional paths trigger a full restart or a live reload(#using.devtools.livereload) . Disabling Restart: If you do not want to use the restart feature, you can disable it by using the spring.devtools.restart.enabled property. In most cases, you can set this property in your application.properties (doing so still initializes the restart classloader, but it does not watch for file changes). If you need to completely disable restart support (for example, because it does not work with a specific library), you need to set the spring.devtools.restart.enabled System property to false before calling SpringApplication.run(…​) , as shown in the following example: Java Kotlin import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MyApplication { public static void main(String[] args) { System.setProperty(""spring.devtools.restart.enabled"", ""false""); SpringApplication.run(MyApplication.class, args); } } import org.springframework.boot.SpringApplication import org.springframework.boot.autoconfigure.SpringBootApplication @SpringBootApplication object MyApplication { @JvmStatic fun main(args: Array<String>) { System.setProperty(""spring.devtools.restart.enabled"", ""false"") SpringApplication.run(MyApplication::class.java, *args) } } Using a Trigger File: If you work with an IDE that continuously compiles changed files, you might prefer to trigger restarts only at specific times. To do so, you can use a “trigger file”, which is a special file that must be modified when you want to actually trigger a restart check. Any update to the file will trigger a check, but restart only actually occurs if Devtools has detected it has something to do. To use a trigger file, set the spring.devtools.restart.trigger-file property to the name (excluding any path) of your trigger file. The trigger file must appear somewhere on your classpath. For example, if you have a project with the following structure: src +- main +- resources +- .reloadtrigger Then your trigger-file property would be: Properties YAML spring.devtools.restart.trigger-file=.reloadtrigger spring: devtools: restart: trigger-file: "".reloadtrigger"" Restarts will now only happen when the src/main/resources/.reloadtrigger is updated. You might want to set spring.devtools.restart.trigger-file as a global setting(#using.devtools.globalsettings) , so that all your projects behave in the same way. Some IDEs have features that save you from needing to update your trigger file manually. Spring Tools for Eclipse(https://spring.io/tools) and IntelliJ IDEA (Ultimate Edition)(https://www.jetbrains.com/idea/) both have such support. With Spring Tools, you can use the “reload” button from the console view (as long as your trigger-file is named .reloadtrigger ). For IntelliJ IDEA, you can follow the instructions in their documentation(https://www.jetbrains.com/help/idea/spring-boot.html#application-update-policies) . Customizing the Restart Classloader: As described earlier in the Restart vs Reload(#using.devtools.restart.restart-vs-reload) section, restart functionality is implemented by using two classloaders. If this causes issues, you can diagnose the problem by using the spring.devtools.restart.enabled system property, and if the app works with restart switched off, you might need to customize what gets loaded by which classloader. By default, any open project in your IDE is loaded with the “restart” classloader, and any regular .jar file is loaded with the “base” classloader. The same is true if you use mvn spring-boot:run or gradle bootRun : the project containing your @SpringBootApplication is loaded with the “restart” classloader, and everything else with the “base” classloader. The classpath is printed on the console when you start the app, which can help to identify any problematic entries. Classes used reflectively, especially annotations, can be loaded into the parent (fixed) classloader on startup before the application classes which uses them, and this might lead to them not being detected by Spring in the application. You can instruct Spring Boot to load parts of your project with a different classloader by creating a META-INF/spring-devtools.properties file. The spring-devtools.properties file can contain properties prefixed with restart.exclude and restart.include . The include elements are items that should be pulled up into the “restart” classloader, and the exclude elements are items that should be pushed down into the “base” classloader. The value of the property is a regex pattern that is applied to the classpath passed to the JVM on startup. Here is an example where some local class files are excluded and some extra libraries are included in the restart class loader: restart: exclude: companycommonlibs: ""/mycorp-common-[\\w\\d-\\.]/(build|bin|out|target)/"" include: projectcommon: ""/mycorp-myproj-[\\w\\d-\\.]+\\.jar"" All property keys must be unique. As long as a property starts with restart.include. or restart.exclude. it is considered. All META-INF/spring-devtools.properties from the classpath are loaded. You can package files inside your project, or in the libraries that the project consumes. System properties can not be used, only the properties file. Known Limitations: Restart functionality does not work well with objects that are deserialized by using a standard ObjectInputStream . If you need to deserialize data, you may need to use Spring’s ConfigurableObjectInputStream in combination with Thread.currentThread().getContextClassLoader() . Unfortunately, several third-party libraries deserialize without considering the context classloader. If you find such a problem, you need to request a fix with the original authors. LiveReload: The spring-boot-devtools module includes an embedded LiveReload server that can be used to trigger a browser refresh when a resource is changed. LiveReload browser extensions are freely available for Chrome, Firefox and Safari. You can find these extensions by searching 'LiveReload' in the marketplace or store of your chosen browser. If you do not want to start the LiveReload server when your application runs, you can set the spring.devtools.livereload.enabled property to false . You can only run one LiveReload server at a time. Before starting your application, ensure that no other LiveReload servers are running. If you start multiple applications from your IDE, only the first has LiveReload support. To trigger LiveReload when a file changes, Automatic Restart(#using.devtools.restart) must be enabled. Global Settings: You can configure global devtools settings by adding any of the following files to the $HOME/.config/spring-boot directory: spring-boot-devtools.properties spring-boot-devtools.yaml spring-boot-devtools.yml Any properties added to these files apply to all Spring Boot applications on your machine that use devtools. For example, to configure restart to always use a trigger file(#using.devtools.restart.triggerfile) , you would add the following property to your spring-boot-devtools file: Properties YAML spring.devtools.restart.trigger-file=.reloadtrigger spring: devtools: restart: trigger-file: "".reloadtrigger"" By default, $HOME is the user’s home directory. To customize this location, set the SPRING_DEVTOOLS_HOME environment variable or the spring.devtools.home system property. If devtools configuration files are not found in $HOME/.config/spring-boot , the root of the $HOME directory is searched for the presence of a .spring-boot-devtools.properties file. This allows you to share the devtools global configuration with applications that are on an older version of Spring Boot that does not support the $HOME/.config/spring-boot location. Profiles are not supported in devtools properties/yaml files. Any profiles activated in .spring-boot-devtools.properties will not affect the loading of profile-specific configuration files(../features/external-config.html#features.external-config.files.profile-specific) . Profile specific filenames (of the form spring-boot-devtools-<profile>.properties ) and spring.config.activate.on-profile documents in both YAML and Properties files are not supported. Configuring File System Watcher: FileSystemWatcher(../../api/java/org/springframework/boot/devtools/filewatch/FileSystemWatcher.html) works by polling the class changes with a certain time interval, and then waiting for a predefined quiet period to make sure there are no more changes. Since Spring Boot relies entirely on the IDE to compile and copy files into the location from where Spring Boot can read them, you might find that there are times when certain changes are not reflected when devtools restarts the application. If you observe such problems constantly, try increasing the spring.devtools.restart.poll-interval and spring.devtools.restart.quiet-period parameters to the values that fit your development environment: Properties YAML spring.devtools.restart.poll-interval=2s spring.devtools.restart.quiet-period=1s spring: devtools: restart: poll-interval: ""2s"" quiet-period: ""1s"" The monitored classpath directories are now polled every 2 seconds for changes, and a 1 second quiet period is maintained to make sure there are no additional class changes. Remote Applications: The Spring Boot developer tools are not limited to local development. You can also use several features when running applications remotely. Remote support is opt-in as enabling it can be a security risk. It should only be enabled when running on a trusted network or when secured with SSL. If neither of these options is available to you, you should not use DevTools' remote support. You should never enable support on a production deployment. To enable it, you need to make sure that devtools is included in the repackaged archive, as shown in the following listing: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <excludeDevtools>false</excludeDevtools> </configuration> </plugin> </plugins> </build> Then you need to set the spring.devtools.remote.secret property. Like any important password or secret, the value should be unique and strong such that it cannot be guessed or brute-forced. Remote devtools support is provided in two parts: a server-side endpoint that accepts connections and a client application that you run in your IDE. The server component is automatically enabled when the spring.devtools.remote.secret property is set. The client component must be launched manually. Remote devtools is not supported for Spring WebFlux applications. Running the Remote Client Application: The remote client application is designed to be run from within your IDE. You need to run org.springframework.boot.devtools.RemoteSpringApplication with the same classpath as the remote project that you connect to. The application’s single required argument is the remote URL to which it connects. For example, if you are using Eclipse or Spring Tools and you have a project named my-app that you have deployed to Cloud Foundry, you would do the following: Select Run Configurations…​ from the Run menu. Create a new Java Application “launch configuration”. Browse for the my-app project. Use org.springframework.boot.devtools.RemoteSpringApplication as the main class. Add https://myapp.cfapps.io to the Program arguments (or whatever your remote URL is). A running remote client might resemble the following listing: . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ ___ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | | _ \___ _ __ ___| |_ ___ \ \ \ \ \\/ ___)| |_)| | | | | || (_| []::::::[] / -_) ' \/ _ \ _/ -_) ) ) ) ) ' |____| .__|_| |_|_| |_\__, | |_|_\___|_|_|_\___/\__\___|/ / / / =========|_|==============|___/===================================/_/_/_/ :: Spring Boot Remote :: (v3.3.4) 2024-09-19T09:38:59.601Z INFO 111576 --- [ main] o.s.b.devtools.RemoteSpringApplication : Starting RemoteSpringApplication v3.3.4 using Java 17.0.12 with PID 111576 (/Users/myuser/.m2/repository/org/springframework/boot/spring-boot-devtools/3.3.4/spring-boot-devtools-3.3.4.jar started by myuser in /opt/apps/) 2024-09-19T09:38:59.607Z INFO 111576 --- [ main] o.s.b.devtools.RemoteSpringApplication : No active profile set, falling back to 1 default profile: ""default"" 2024-09-19T09:39:00.123Z INFO 111576 --- [ main] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 35729 2024-09-19T09:39:00.159Z INFO 111576 --- [ main] o.s.b.devtools.RemoteSpringApplication : Started RemoteSpringApplication in 1.249 seconds (process running for 1.879) Because the remote client is using the same classpath as the real application it can directly read application properties. This is how the spring.devtools.remote.secret property is read and passed to the server for authentication. It is always advisable to use https:// as the connection protocol, so that traffic is encrypted and passwords cannot be intercepted. If you need to use a proxy to access the remote application, configure the spring.devtools.remote.proxy.host and spring.devtools.remote.proxy.port properties. Remote Update: The remote client monitors your application classpath for changes in the same way as the local restart(#using.devtools.restart) . Any updated resource is pushed to the remote application and ( if required ) triggers a restart. This can be helpful if you iterate on a feature that uses a cloud service that you do not have locally. Generally, remote updates and restarts are much quicker than a full rebuild and deploy cycle. On a slower development environment, it may happen that the quiet period is not enough, and the changes in the classes may be split into batches. The server is restarted after the first batch of class changes is uploaded. The next batch can’t be sent to the application, since the server is restarting. This is typically manifested by a warning in the RemoteSpringApplication logs about failing to upload some of the classes, and a consequent retry. But it may also lead to application code inconsistency and failure to restart after the first batch of changes is uploaded. If you observe such problems constantly, try increasing the spring.devtools.restart.poll-interval and spring.devtools.restart.quiet-period parameters to the values that fit your development environment. See the Configuring File System Watcher(#using.devtools.globalsettings.configuring-file-system-watcher) section for configuring these properties. Files are only monitored when the remote client is running. If you change a file before starting the remote client, it is not pushed to the remote server."
"https://docs.spring.io/spring-boot/reference/using/packaging-for-production.html","Packaging Your Application for Production: Once your Spring Boot application is ready for production deployment, there are many options for packaging and optimizing the application. See the Packaging Spring Boot Applications(../packaging/index.html) section of the documentation to read about these features. For additional ""production ready"" features, such as health, auditing, and metric REST or JMX end-points, consider adding spring-boot-actuator . See Actuator(../../how-to/actuator.html) for details."
"https://docs.spring.io/spring-boot/reference/features/index.html","Core Features: This section dives into the details of Spring Boot. Here you can learn about the key features that you may want to use and customize. If you have not already done so, you might want to read the Tutorials(../../tutorial/index.html) and Developing with Spring Boot(../using/index.html) sections, so that you have a good grounding of the basics."
"https://docs.spring.io/spring-boot/reference/features/spring-application.html","SpringApplication: The SpringApplication class provides a convenient way to bootstrap a Spring application that is started from a main() method. In many situations, you can delegate to the static SpringApplication.run method, as shown in the following example: Java Kotlin import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication @SpringBootApplication class MyApplication fun main(args: Array<String>) { runApplication<MyApplication>(*args) } When your application starts, you should see something similar to the following output: . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v3.3.4) 2024-09-19T09:39:01.595Z INFO 111619 --- [ main] o.s.b.d.f.logexample.MyApplication : Starting MyApplication using Java 17.0.12 with PID 111619 (/opt/apps/myapp.jar started by myuser in /opt/apps/) 2024-09-19T09:39:01.604Z INFO 111619 --- [ main] o.s.b.d.f.logexample.MyApplication : No active profile set, falling back to 1 default profile: ""default"" 2024-09-19T09:39:05.112Z INFO 111619 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port 8080 (http) 2024-09-19T09:39:05.184Z INFO 111619 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2024-09-19T09:39:05.184Z INFO 111619 --- [ main] o.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/10.1.30] 2024-09-19T09:39:05.460Z INFO 111619 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2024-09-19T09:39:05.489Z INFO 111619 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 3750 ms 2024-09-19T09:39:07.281Z INFO 111619 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port 8080 (http) with context path '/' 2024-09-19T09:39:07.345Z INFO 111619 --- [ main] o.s.b.d.f.logexample.MyApplication : Started MyApplication in 6.706 seconds (process running for 7.169) By default, INFO logging messages are shown, including some relevant startup details, such as the user that launched the application. If you need a log level other than INFO , you can set it, as described in Log Levels(logging.html#features.logging.log-levels) . The application version is determined using the implementation version from the main application class’s package. Startup information logging can be turned off by setting spring.main.log-startup-info to false . This will also turn off logging of the application’s active profiles. To add additional logging during startup, you can override logStartupInfo(boolean) in a subclass of SpringApplication . Startup Failure: If your application fails to start, registered FailureAnalyzers get a chance to provide a dedicated error message and a concrete action to fix the problem. For instance, if you start a web application on port 8080 and that port is already in use, you should see something similar to the following message: *************************** APPLICATION FAILED TO START *************************** Description: Embedded servlet container failed to start. Port 8080 was already in use. Action: Identify and stop the process that is listening on port 8080 or configure this application to listen on another port. Spring Boot provides numerous FailureAnalyzer implementations, and you can add your own(../../how-to/application.html#howto.application.failure-analyzer) . If no failure analyzers are able to handle the exception, you can still display the full conditions report to better understand what went wrong. To do so, you need to enable the debug property(external-config.html) or enable DEBUG logging(logging.html#features.logging.log-levels) for org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener . For instance, if you are running your application by using java -jar , you can enable the debug property as follows: $ java -jar myproject-0.0.1-SNAPSHOT.jar --debug Lazy Initialization: SpringApplication allows an application to be initialized lazily. When lazy initialization is enabled, beans are created as they are needed rather than during application startup. As a result, enabling lazy initialization can reduce the time that it takes your application to start. In a web application, enabling lazy initialization will result in many web-related beans not being initialized until an HTTP request is received. A downside of lazy initialization is that it can delay the discovery of a problem with the application. If a misconfigured bean is initialized lazily, a failure will no longer occur during startup and the problem will only become apparent when the bean is initialized. Care must also be taken to ensure that the JVM has sufficient memory to accommodate all of the application’s beans and not just those that are initialized during startup. For these reasons, lazy initialization is not enabled by default and it is recommended that fine-tuning of the JVM’s heap size is done before enabling lazy initialization. Lazy initialization can be enabled programmatically using the lazyInitialization method on SpringApplicationBuilder or the setLazyInitialization method on SpringApplication . Alternatively, it can be enabled using the spring.main.lazy-initialization property as shown in the following example: Properties YAML spring.main.lazy-initialization=true spring: main: lazy-initialization: true If you want to disable lazy initialization for certain beans while using lazy initialization for the rest of the application, you can explicitly set their lazy attribute to false using the @Lazy(false) annotation. Customizing the Banner: The banner that is printed on start up can be changed by adding a banner.txt file to your classpath or by setting the spring.banner.location property to the location of such a file. If the file has an encoding other than UTF-8, you can set spring.banner.charset . Inside your banner.txt file, you can use any key available in the Environment as well as any of the following placeholders: Table 1. Banner variables Variable Description ${application.version} The version number of your application, as declared in MANIFEST.MF . For example, Implementation-Version: 1.0 is printed as 1.0 . ${application.formatted-version} The version number of your application, as declared in MANIFEST.MF and formatted for display (surrounded with brackets and prefixed with v ). For example (v1.0) . ${spring-boot.version} The Spring Boot version that you are using. For example 3.3.4 . ${spring-boot.formatted-version} The Spring Boot version that you are using, formatted for display (surrounded with brackets and prefixed with v ). For example (v3.3.4) . ${Ansi.NAME} (or ${AnsiColor.NAME} , ${AnsiBackground.NAME} , ${AnsiStyle.NAME} ) Where NAME is the name of an ANSI escape code. See AnsiPropertySource(../../api/java/org/springframework/boot/ansi/AnsiPropertySource.html) for details. ${application.title} The title of your application, as declared in MANIFEST.MF . For example Implementation-Title: MyApp is printed as MyApp . The SpringApplication.setBanner(…​) method can be used if you want to generate a banner programmatically. Use the org.springframework.boot.Banner interface and implement your own printBanner() method. You can also use the spring.main.banner-mode property to determine if the banner has to be printed on System.out ( console ), sent to the configured logger ( log ), or not produced at all ( off ). The printed banner is registered as a singleton bean under the following name: springBootBanner . The application.title , application.version , and application.formatted-version properties are only available if you are using java -jar or java -cp with Spring Boot launchers. The values will not be resolved if you are running an unpacked jar and starting it with java -cp <classpath> <mainclass> or running your application as a native image. To use the application. properties, launch your application as a packed jar using java -jar or as an unpacked jar using java org.springframework.boot.loader.launch.JarLauncher . This will initialize the application. banner properties before building the classpath and launching your app. Customizing SpringApplication: If the SpringApplication defaults are not to your taste, you can instead create a local instance and customize it. For example, to turn off the banner, you could write: Java Kotlin import org.springframework.boot.Banner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication application = new SpringApplication(MyApplication.class); application.setBannerMode(Banner.Mode.OFF); application.run(args); } } import org.springframework.boot.Banner import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication @SpringBootApplication class MyApplication fun main(args: Array<String>) { runApplication<MyApplication>(*args) { setBannerMode(Banner.Mode.OFF) } } The constructor arguments passed to SpringApplication are configuration sources for Spring beans. In most cases, these are references to @Configuration classes, but they could also be direct references @Component classes. It is also possible to configure the SpringApplication by using an application.properties file. See Externalized Configuration(external-config.html) for details. For a complete list of the configuration options, see the SpringApplication(../../api/java/org/springframework/boot/SpringApplication.html) API documentation. Fluent Builder API: If you need to build an ApplicationContext hierarchy (multiple contexts with a parent/child relationship) or if you prefer using a fluent builder API, you can use the SpringApplicationBuilder . The SpringApplicationBuilder lets you chain together multiple method calls and includes parent and child methods that let you create a hierarchy, as shown in the following example: Java Kotlin new SpringApplicationBuilder().sources(Parent.class) .child(Application.class) .bannerMode(Banner.Mode.OFF) .run(args); SpringApplicationBuilder() .sources(Parent::class.java) .child(Application::class.java) .bannerMode(Banner.Mode.OFF) .run(*args) There are some restrictions when creating an ApplicationContext hierarchy. For example, Web components must be contained within the child context, and the same Environment is used for both parent and child contexts. See the SpringApplicationBuilder(../../api/java/org/springframework/boot/builder/SpringApplicationBuilder.html) API documentation for full details. Application Availability: When deployed on platforms, applications can provide information about their availability to the platform using infrastructure such as Kubernetes Probes(https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/) . Spring Boot includes out-of-the box support for the commonly used “liveness” and “readiness” availability states. If you are using Spring Boot’s “actuator” support then these states are exposed as health endpoint groups. In addition, you can also obtain availability states by injecting the ApplicationAvailability interface into your own beans. Liveness State: The “Liveness” state of an application tells whether its internal state allows it to work correctly, or recover by itself if it is currently failing. A broken “Liveness” state means that the application is in a state that it cannot recover from, and the infrastructure should restart the application. In general, the ""Liveness"" state should not be based on external checks, such as health checks(../actuator/endpoints.html#actuator.endpoints.health) . If it did, a failing external system (a database, a Web API, an external cache) would trigger massive restarts and cascading failures across the platform. The internal state of Spring Boot applications is mostly represented by the Spring ApplicationContext . If the application context has started successfully, Spring Boot assumes that the application is in a valid state. An application is considered live as soon as the context has been refreshed, see Spring Boot application lifecycle and related Application Events(#features.spring-application.application-events-and-listeners) . Readiness State: The “Readiness” state of an application tells whether the application is ready to handle traffic. A failing “Readiness” state tells the platform that it should not route traffic to the application for now. This typically happens during startup, while CommandLineRunner and ApplicationRunner components are being processed, or at any time if the application decides that it is too busy for additional traffic. An application is considered ready as soon as application and command-line runners have been called, see Spring Boot application lifecycle and related Application Events(#features.spring-application.application-events-and-listeners) . Tasks expected to run during startup should be executed by CommandLineRunner and ApplicationRunner components instead of using Spring component lifecycle callbacks such as @PostConstruct . Managing the Application Availability State: Application components can retrieve the current availability state at any time, by injecting the ApplicationAvailability interface and calling methods on it. More often, applications will want to listen to state updates or update the state of the application. For example, we can export the ""Readiness"" state of the application to a file so that a Kubernetes ""exec Probe"" can look at this file: Java Kotlin import org.springframework.boot.availability.AvailabilityChangeEvent; import org.springframework.boot.availability.ReadinessState; import org.springframework.context.event.EventListener; import org.springframework.stereotype.Component; @Component public class MyReadinessStateExporter { @EventListener public void onStateChange(AvailabilityChangeEvent<ReadinessState> event) { switch (event.getState()) { case ACCEPTING_TRAFFIC -> { // create file /tmp/healthy } case REFUSING_TRAFFIC -> { // remove file /tmp/healthy } } } } import org.springframework.boot.availability.AvailabilityChangeEvent import org.springframework.boot.availability.ReadinessState import org.springframework.context.event.EventListener import org.springframework.stereotype.Component @Component class MyReadinessStateExporter { @EventListener fun onStateChange(event: AvailabilityChangeEvent<ReadinessState?>) { when (event.state) { ReadinessState.ACCEPTING_TRAFFIC -> { // create file /tmp/healthy } ReadinessState.REFUSING_TRAFFIC -> { // remove file /tmp/healthy } else -> { // ... } } } } We can also update the state of the application, when the application breaks and cannot recover: Java Kotlin import org.springframework.boot.availability.AvailabilityChangeEvent; import org.springframework.boot.availability.LivenessState; import org.springframework.context.ApplicationEventPublisher; import org.springframework.stereotype.Component; @Component public class MyLocalCacheVerifier { private final ApplicationEventPublisher eventPublisher; public MyLocalCacheVerifier(ApplicationEventPublisher eventPublisher) { this.eventPublisher = eventPublisher; } public void checkLocalCache() { try { // ... } catch (CacheCompletelyBrokenException ex) { AvailabilityChangeEvent.publish(this.eventPublisher, ex, LivenessState.BROKEN); } } } import org.springframework.boot.availability.AvailabilityChangeEvent import org.springframework.boot.availability.LivenessState import org.springframework.context.ApplicationEventPublisher import org.springframework.stereotype.Component @Component class MyLocalCacheVerifier(private val eventPublisher: ApplicationEventPublisher) { fun checkLocalCache() { try { // ... } catch (ex: CacheCompletelyBrokenException) { AvailabilityChangeEvent.publish(eventPublisher, ex, LivenessState.BROKEN) } } } Spring Boot provides Kubernetes HTTP probes for ""Liveness"" and ""Readiness"" with Actuator Health Endpoints(../actuator/endpoints.html#actuator.endpoints.kubernetes-probes) . You can get more guidance about deploying Spring Boot applications on Kubernetes in the dedicated section(../../how-to/deployment/cloud.html#howto.deployment.cloud.kubernetes) . Application Events and Listeners: In addition to the usual Spring Framework events, such as ContextRefreshedEvent(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/context/event/ContextRefreshedEvent.html) , a SpringApplication sends some additional application events. Some events are actually triggered before the ApplicationContext is created, so you cannot register a listener on those as a @Bean . You can register them with the SpringApplication.addListeners(…​) method or the SpringApplicationBuilder.listeners(…​) method. If you want those listeners to be registered automatically, regardless of the way the application is created, you can add a META-INF/spring.factories file to your project and reference your listener(s) by using the org.springframework.context.ApplicationListener key, as shown in the following example: org.springframework.context.ApplicationListener=com.example.project.MyListener Application events are sent in the following order, as your application runs: An ApplicationStartingEvent is sent at the start of a run but before any processing, except for the registration of listeners and initializers. An ApplicationEnvironmentPreparedEvent is sent when the Environment to be used in the context is known but before the context is created. An ApplicationContextInitializedEvent is sent when the ApplicationContext is prepared and ApplicationContextInitializers have been called but before any bean definitions are loaded. An ApplicationPreparedEvent is sent just before the refresh is started but after bean definitions have been loaded. An ApplicationStartedEvent is sent after the context has been refreshed but before any application and command-line runners have been called. An AvailabilityChangeEvent is sent right after with LivenessState.CORRECT to indicate that the application is considered as live. An ApplicationReadyEvent is sent after any application and command-line runners(#features.spring-application.command-line-runner) have been called. An AvailabilityChangeEvent is sent right after with ReadinessState.ACCEPTING_TRAFFIC to indicate that the application is ready to service requests. An ApplicationFailedEvent is sent if there is an exception on startup. The above list only includes SpringApplicationEvent s that are tied to a SpringApplication . In addition to these, the following events are also published after ApplicationPreparedEvent and before ApplicationStartedEvent : A WebServerInitializedEvent is sent after the WebServer is ready. ServletWebServerInitializedEvent and ReactiveWebServerInitializedEvent are the servlet and reactive variants respectively. A ContextRefreshedEvent is sent when an ApplicationContext is refreshed. You often need not use application events, but it can be handy to know that they exist. Internally, Spring Boot uses events to handle a variety of tasks. Event listeners should not run potentially lengthy tasks as they execute in the same thread by default. Consider using application and command-line runners(#features.spring-application.command-line-runner) instead. Application events are sent by using Spring Framework’s event publishing mechanism. Part of this mechanism ensures that an event published to the listeners in a child context is also published to the listeners in any ancestor contexts. As a result of this, if your application uses a hierarchy of SpringApplication instances, a listener may receive multiple instances of the same type of application event. To allow your listener to distinguish between an event for its context and an event for a descendant context, it should request that its application context is injected and then compare the injected context with the context of the event. The context can be injected by implementing ApplicationContextAware or, if the listener is a bean, by using @Autowired . Web Environment: A SpringApplication attempts to create the right type of ApplicationContext on your behalf. The algorithm used to determine a WebApplicationType is the following: If Spring MVC is present, an AnnotationConfigServletWebServerApplicationContext is used If Spring MVC is not present and Spring WebFlux is present, an AnnotationConfigReactiveWebServerApplicationContext is used Otherwise, AnnotationConfigApplicationContext is used This means that if you are using Spring MVC and the new WebClient from Spring WebFlux in the same application, Spring MVC will be used by default. You can override that easily by calling setWebApplicationType(WebApplicationType) . It is also possible to take complete control of the ApplicationContext type that is used by calling setApplicationContextFactory(…​) . It is often desirable to call setWebApplicationType(WebApplicationType.NONE) when using SpringApplication within a JUnit test. Accessing Application Arguments: If you need to access the application arguments that were passed to SpringApplication.run(…​) , you can inject a org.springframework.boot.ApplicationArguments bean. The ApplicationArguments interface provides access to both the raw String[] arguments as well as parsed option and non-option arguments, as shown in the following example: Java Kotlin import java.util.List; import org.springframework.boot.ApplicationArguments; import org.springframework.stereotype.Component; @Component public class MyBean { public MyBean(ApplicationArguments args) { boolean debug = args.containsOption(""debug""); List<String> files = args.getNonOptionArgs(); if (debug) { System.out.println(files); } // if run with ""--debug logfile.txt"" prints [""logfile.txt""] } } import org.springframework.boot.ApplicationArguments import org.springframework.stereotype.Component @Component class MyBean(args: ApplicationArguments) { init { val debug = args.containsOption(""debug"") val files = args.nonOptionArgs if (debug) { println(files) } // if run with ""--debug logfile.txt"" prints [""logfile.txt""] } } Spring Boot also registers a CommandLinePropertySource with the Spring Environment . This lets you also inject single application arguments by using the @Value annotation. Using the ApplicationRunner or CommandLineRunner: If you need to run some specific code once the SpringApplication has started, you can implement the ApplicationRunner or CommandLineRunner interfaces. Both interfaces work in the same way and offer a single run method, which is called just before SpringApplication.run(…​) completes. This contract is well suited for tasks that should run after application startup but before it starts accepting traffic. The CommandLineRunner interfaces provides access to application arguments as a string array, whereas the ApplicationRunner uses the ApplicationArguments interface discussed earlier. The following example shows a CommandLineRunner with a run method: Java Kotlin import org.springframework.boot.CommandLineRunner; import org.springframework.stereotype.Component; @Component public class MyCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) { // Do something... } } import org.springframework.boot.CommandLineRunner import org.springframework.stereotype.Component @Component class MyCommandLineRunner : CommandLineRunner { override fun run(vararg args: String) { // Do something... } } If several CommandLineRunner or ApplicationRunner beans are defined that must be called in a specific order, you can additionally implement the org.springframework.core.Ordered interface or use the org.springframework.core.annotation.Order annotation. Application Exit: Each SpringApplication registers a shutdown hook with the JVM to ensure that the ApplicationContext closes gracefully on exit. All the standard Spring lifecycle callbacks (such as the DisposableBean interface or the @PreDestroy annotation) can be used. In addition, beans may implement the org.springframework.boot.ExitCodeGenerator interface if they wish to return a specific exit code when SpringApplication.exit() is called. This exit code can then be passed to System.exit() to return it as a status code, as shown in the following example: Java Kotlin import org.springframework.boot.ExitCodeGenerator; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; @SpringBootApplication public class MyApplication { @Bean public ExitCodeGenerator exitCodeGenerator() { return () -> 42; } public static void main(String[] args) { System.exit(SpringApplication.exit(SpringApplication.run(MyApplication.class, args))); } } import org.springframework.boot.ExitCodeGenerator import org.springframework.boot.SpringApplication import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication import org.springframework.context.annotation.Bean import kotlin.system.exitProcess @SpringBootApplication class MyApplication { @Bean fun exitCodeGenerator() = ExitCodeGenerator { 42 } } fun main(args: Array<String>) { exitProcess(SpringApplication.exit( runApplication<MyApplication>(*args))) } Also, the ExitCodeGenerator interface may be implemented by exceptions. When such an exception is encountered, Spring Boot returns the exit code provided by the implemented getExitCode() method. If there is more than one ExitCodeGenerator , the first non-zero exit code that is generated is used. To control the order in which the generators are called, additionally implement the org.springframework.core.Ordered interface or use the org.springframework.core.annotation.Order annotation. Admin Features: It is possible to enable admin-related features for the application by specifying the spring.application.admin.enabled property. This exposes the SpringApplicationAdminMXBean(../../api/java/org/springframework/boot/admin/SpringApplicationAdminMXBean.html) on the platform MBeanServer . You could use this feature to administer your Spring Boot application remotely. This feature could also be useful for any service wrapper implementation. If you want to know on which HTTP port the application is running, get the property with a key of local.server.port . Application Startup tracking: During the application startup, the SpringApplication and the ApplicationContext perform many tasks related to the application lifecycle, the beans lifecycle or even processing application events. With ApplicationStartup(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/core/metrics/ApplicationStartup.html) , Spring Framework allows you to track the application startup sequence with StartupStep objects(https://docs.spring.io/spring-framework/reference/6.1/core/beans/context-introduction.html#context-functionality-startup) . This data can be collected for profiling purposes, or just to have a better understanding of an application startup process. You can choose an ApplicationStartup implementation when setting up the SpringApplication instance. For example, to use the BufferingApplicationStartup , you could write: Java Kotlin import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.context.metrics.buffering.BufferingApplicationStartup; @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication application = new SpringApplication(MyApplication.class); application.setApplicationStartup(new BufferingApplicationStartup(2048)); application.run(args); } } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.context.metrics.buffering.BufferingApplicationStartup import org.springframework.boot.runApplication @SpringBootApplication class MyApplication fun main(args: Array<String>) { runApplication<MyApplication>(*args) { applicationStartup = BufferingApplicationStartup(2048) } } The first available implementation, FlightRecorderApplicationStartup is provided by Spring Framework. It adds Spring-specific startup events to a Java Flight Recorder session and is meant for profiling applications and correlating their Spring context lifecycle with JVM events (such as allocations, GCs, class loading…​). Once configured, you can record data by running the application with the Flight Recorder enabled: $ java -XX:StartFlightRecording:filename=recording.jfr,duration=10s -jar demo.jar Spring Boot ships with the BufferingApplicationStartup variant; this implementation is meant for buffering the startup steps and draining them into an external metrics system. Applications can ask for the bean of type BufferingApplicationStartup in any component. Spring Boot can also be configured to expose a startup endpoint(../../api/rest/actuator/startup.html) that provides this information as a JSON document. Virtual threads: If you’re running on Java 21 or up, you can enable virtual threads by setting the property spring.threads.virtual.enabled to true . Before turning on this option for your application, you should consider reading the official Java virtual threads documentation(https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html) . In some cases, applications can experience lower throughput because of ""Pinned Virtual Threads""; this page also explains how to detect such cases with JDK Flight Recorder or the jcmd CLI. If virtual threads are enabled, properties which configure thread pools don’t have an effect anymore. That’s because virtual threads are scheduled on a JVM wide platform thread pool and not on dedicated thread pools. One side effect of virtual threads is that they are daemon threads. A JVM will exit if all of its threads are daemon threads. This behavior can be a problem when you rely on @Scheduled beans, for example, to keep your application alive. If you use virtual threads, the scheduler thread is a virtual thread and therefore a daemon thread and won’t keep the JVM alive. This not only affects scheduling and can be the case with other technologies too. To keep the JVM running in all cases, it is recommended to set the property spring.main.keep-alive to true . This ensures that the JVM is kept alive, even if all threads are virtual threads."
"https://docs.spring.io/spring-boot/reference/features/external-config.html","Externalized Configuration: Spring Boot lets you externalize your configuration so that you can work with the same application code in different environments. You can use a variety of external configuration sources including Java properties files, YAML files, environment variables, and command-line arguments. Property values can be injected directly into your beans by using the @Value annotation, accessed through Spring’s Environment abstraction, or be bound to structured objects(#features.external-config.typesafe-configuration-properties) through @ConfigurationProperties . Spring Boot uses a very particular PropertySource order that is designed to allow sensible overriding of values. Later property sources can override the values defined in earlier ones. Sources are considered in the following order: Default properties (specified by setting SpringApplication.setDefaultProperties ). @PropertySource(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/context/annotation/PropertySource.html) annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins. Config data (such as application.properties files). A RandomValuePropertySource that has properties only in random.* . OS environment variables. Java System properties ( System.getProperties() ). JNDI attributes from java:comp/env . ServletContext init parameters. ServletConfig init parameters. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property). Command line arguments. properties attribute on your tests. Available on @SpringBootTest(../../api/java/org/springframework/boot/test/context/SpringBootTest.html) and the test annotations for testing a particular slice of your application(../testing/spring-boot-applications.html#testing.spring-boot-applications.autoconfigured-tests) . @DynamicPropertySource(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/test/context/DynamicPropertySource.html) annotations in your tests. @TestPropertySource(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/test/context/TestPropertySource.html) annotations on your tests. Devtools global settings properties(../using/devtools.html#using.devtools.globalsettings) in the $HOME/.config/spring-boot directory when devtools is active. Config data files are considered in the following order: Application properties(#features.external-config.files) packaged inside your jar ( application.properties and YAML variants). Profile-specific application properties(#features.external-config.files.profile-specific) packaged inside your jar ( application-{profile}.properties and YAML variants). Application properties(#features.external-config.files) outside of your packaged jar ( application.properties and YAML variants). Profile-specific application properties(#features.external-config.files.profile-specific) outside of your packaged jar ( application-{profile}.properties and YAML variants). It is recommended to stick with one format for your entire application. If you have configuration files with both .properties and YAML format in the same location, .properties takes precedence. If you use environment variables rather than system properties, most operating systems disallow period-separated key names, but you can use underscores instead (for example, SPRING_CONFIG_NAME instead of spring.config.name ). See Binding From Environment Variables(#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables) for details. If your application runs in a servlet container or application server, then JNDI properties (in java:comp/env ) or servlet context initialization parameters can be used instead of, or as well as, environment variables or system properties. To provide a concrete example, suppose you develop a @Component that uses a name property, as shown in the following example: Java Kotlin import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class MyBean { @Value(""${name}"") private String name; // ... } import org.springframework.beans.factory.annotation.Value import org.springframework.stereotype.Component @Component class MyBean { @Value(""\${name}"") private val name: String? = null // ... } On your application classpath (for example, inside your jar) you can have an application.properties file that provides a sensible default property value for name . When running in a new environment, an application.properties file can be provided outside of your jar that overrides the name . For one-off testing, you can launch with a specific command line switch (for example, java -jar app.jar --name=""Spring"" ). The env and configprops endpoints can be useful in determining why a property has a particular value. You can use these two endpoints to diagnose unexpected property values. See the Production ready features(../actuator/endpoints.html) section for details. Accessing Command Line Properties: By default, SpringApplication converts any command line option arguments (that is, arguments starting with -- , such as --server.port=9000 ) to a property and adds them to the Spring Environment . As mentioned previously, command line properties always take precedence over file-based property sources. If you do not want command line properties to be added to the Environment , you can disable them by using SpringApplication.setAddCommandLineProperties(false) . JSON Application Properties: Environment variables and system properties often have restrictions that mean some property names cannot be used. To help with this, Spring Boot allows you to encode a block of properties into a single JSON structure. When your application starts, any spring.application.json or SPRING_APPLICATION_JSON properties will be parsed and added to the Environment . For example, the SPRING_APPLICATION_JSON property can be supplied on the command line in a UN*X shell as an environment variable: $ SPRING_APPLICATION_JSON='{""my"":{""name"":""test""}}' java -jar myapp.jar In the preceding example, you end up with my.name=test in the Spring Environment . The same JSON can also be provided as a system property: $ java -Dspring.application.json='{""my"":{""name"":""test""}}' -jar myapp.jar Or you could supply the JSON by using a command line argument: $ java -jar myapp.jar --spring.application.json='{""my"":{""name"":""test""}}' If you are deploying to a classic Application Server, you could also use a JNDI variable named java:comp/env/spring.application.json . Although null values from the JSON will be added to the resulting property source, the PropertySourcesPropertyResolver treats null properties as missing values. This means that the JSON cannot override properties from lower order property sources with a null value. External Application Properties: Spring Boot will automatically find and load application.properties and application.yaml files from the following locations when your application starts: From the classpath The classpath root The classpath /config package From the current directory The current directory The config/ subdirectory in the current directory Immediate child directories of the config/ subdirectory The list is ordered by precedence (with values from lower items overriding earlier ones). Documents from the loaded files are added as PropertySources to the Spring Environment . If you do not like application as the configuration file name, you can switch to another file name by specifying a spring.config.name environment property. For example, to look for myproject.properties and myproject.yaml files you can run your application as follows: $ java -jar myproject.jar --spring.config.name=myproject You can also refer to an explicit location by using the spring.config.location environment property. This property accepts a comma-separated list of one or more locations to check. The following example shows how to specify two distinct files: $ java -jar myproject.jar --spring.config.location=\ optional:classpath:/default.properties,\ optional:classpath:/override.properties Use the prefix optional: if the locations are optional(#features.external-config.files.optional-prefix) and you do not mind if they do not exist. spring.config.name , spring.config.location , and spring.config.additional-location are used very early to determine which files have to be loaded. They must be defined as an environment property (typically an OS environment variable, a system property, or a command-line argument). If spring.config.location contains directories (as opposed to files), they should end in / . At runtime they will be appended with the names generated from spring.config.name before being loaded. Files specified in spring.config.location are imported directly. Both directory and file location values are also expanded to check for profile-specific files(#features.external-config.files.profile-specific) . For example, if you have a spring.config.location of classpath:myconfig.properties , you will also find appropriate classpath:myconfig-<profile>.properties files are loaded. In most situations, each spring.config.location item you add will reference a single file or directory. Locations are processed in the order that they are defined and later ones can override the values of earlier ones. If you have a complex location setup, and you use profile-specific configuration files, you may need to provide further hints so that Spring Boot knows how they should be grouped. A location group is a collection of locations that are all considered at the same level. For example, you might want to group all classpath locations, then all external locations. Items within a location group should be separated with ; . See the example in the Profile Specific Files(#features.external-config.files.profile-specific) section for more details. Locations configured by using spring.config.location replace the default locations. For example, if spring.config.location is configured with the value optional:classpath:/custom-config/,optional:file:./custom-config/ , the complete set of locations considered is: optional:classpath:custom-config/ optional:file:./custom-config/ If you prefer to add additional locations, rather than replacing them, you can use spring.config.additional-location . Properties loaded from additional locations can override those in the default locations. For example, if spring.config.additional-location is configured with the value optional:classpath:/custom-config/,optional:file:./custom-config/ , the complete set of locations considered is: optional:classpath:/;optional:classpath:/config/ optional:file:./;optional:file:./config/;optional:file:./config/*/ optional:classpath:custom-config/ optional:file:./custom-config/ This search ordering lets you specify default values in one configuration file and then selectively override those values in another. You can provide default values for your application in application.properties (or whatever other basename you choose with spring.config.name ) in one of the default locations. These default values can then be overridden at runtime with a different file located in one of the custom locations. Optional Locations: By default, when a specified config data location does not exist, Spring Boot will throw a ConfigDataLocationNotFoundException and your application will not start. If you want to specify a location, but you do not mind if it does not always exist, you can use the optional: prefix. You can use this prefix with the spring.config.location and spring.config.additional-location properties, as well as with spring.config.import(#features.external-config.files.importing) declarations. For example, a spring.config.import value of optional:file:./myconfig.properties allows your application to start, even if the myconfig.properties file is missing. If you want to ignore all ConfigDataLocationNotFoundExceptions and always continue to start your application, you can use the spring.config.on-not-found property. Set the value to ignore using SpringApplication.setDefaultProperties(…​) or with a system/environment variable. Wildcard Locations: If a config file location includes the * character for the last path segment, it is considered a wildcard location. Wildcards are expanded when the config is loaded so that immediate subdirectories are also checked. Wildcard locations are particularly useful in an environment such as Kubernetes when there are multiple sources of config properties. For example, if you have some Redis configuration and some MySQL configuration, you might want to keep those two pieces of configuration separate, while requiring that both those are present in an application.properties file. This might result in two separate application.properties files mounted at different locations such as /config/redis/application.properties and /config/mysql/application.properties . In such a case, having a wildcard location of config/*/ , will result in both files being processed. By default, Spring Boot includes config/*/ in the default search locations. It means that all subdirectories of the /config directory outside of your jar will be searched. You can use wildcard locations yourself with the spring.config.location and spring.config.additional-location properties. A wildcard location must contain only one * and end with */ for search locations that are directories or */<filename> for search locations that are files. Locations with wildcards are sorted alphabetically based on the absolute path of the file names. Wildcard locations only work with external directories. You cannot use a wildcard in a classpath: location. Profile Specific Files: As well as application property files, Spring Boot will also attempt to load profile-specific files using the naming convention application-{profile} . For example, if your application activates a profile named prod and uses YAML files, then both application.yaml and application-prod.yaml will be considered. Profile-specific properties are loaded from the same locations as standard application.properties , with profile-specific files always overriding the non-specific ones. If several profiles are specified, a last-wins strategy applies. For example, if profiles prod,live are specified by the spring.profiles.active property, values in application-prod.properties can be overridden by those in application-live.properties . The last-wins strategy applies at the location group(#features.external-config.files.location-groups) level. A spring.config.location of classpath:/cfg/,classpath:/ext/ will not have the same override rules as classpath:/cfg/;classpath:/ext/ . For example, continuing our prod,live example above, we might have the following files: /cfg application-live.properties /ext application-live.properties application-prod.properties When we have a spring.config.location of classpath:/cfg/,classpath:/ext/ we process all /cfg files before all /ext files: /cfg/application-live.properties /ext/application-prod.properties /ext/application-live.properties When we have classpath:/cfg/;classpath:/ext/ instead (with a ; delimiter) we process /cfg and /ext at the same level: /ext/application-prod.properties /cfg/application-live.properties /ext/application-live.properties The Environment has a set of default profiles (by default, [default] ) that are used if no active profiles are set. In other words, if no profiles are explicitly activated, then properties from application-default are considered. Properties files are only ever loaded once. If you have already directly imported(#features.external-config.files.importing) a profile specific property files then it will not be imported a second time. Importing Additional Data: Application properties may import further config data from other locations using the spring.config.import property. Imports are processed as they are discovered, and are treated as additional documents inserted immediately below the one that declares the import. For example, you might have the following in your classpath application.properties file: Properties YAML spring.application.name=myapp spring.config.import=optional:file:./dev.properties spring: application: name: ""myapp"" config: import: ""optional:file:./dev.properties"" This will trigger the import of a dev.properties file in current directory (if such a file exists). Values from the imported dev.properties will take precedence over the file that triggered the import. In the above example, the dev.properties could redefine spring.application.name to a different value. An import will only be imported once no matter how many times it is declared. The order an import is defined inside a single document within the properties/yaml file does not matter. For instance, the two examples below produce the same result: Properties YAML spring.config.import=my.properties my.property=value spring: config: import: ""my.properties"" my: property: ""value"" Properties YAML my.property=value spring.config.import=my.properties my: property: ""value"" spring: config: import: ""my.properties"" In both of the above examples, the values from the my.properties file will take precedence over the file that triggered its import. Several locations can be specified under a single spring.config.import key. Locations will be processed in the order that they are defined, with later imports taking precedence. When appropriate, Profile-specific variants(#features.external-config.files.profile-specific) are also considered for import. The example above would import both my.properties as well as any my-<profile>.properties variants. Spring Boot includes pluggable API that allows various different location addresses to be supported. By default you can import Java Properties, YAML and configuration trees(#features.external-config.files.configtree) . Third-party jars can offer support for additional technologies (there is no requirement for files to be local). For example, you can imagine config data being from external stores such as Consul, Apache ZooKeeper or Netflix Archaius. If you want to support your own locations, see the ConfigDataLocationResolver and ConfigDataLoader classes in the org.springframework.boot.context.config package. Importing Extensionless Files: Some cloud platforms cannot add a file extension to volume mounted files. To import these extensionless files, you need to give Spring Boot a hint so that it knows how to load them. You can do this by putting an extension hint in square brackets. For example, suppose you have a /etc/config/myconfig file that you wish to import as yaml. You can import it from your application.properties using the following: Properties YAML spring.config.import=file:/etc/config/myconfig[.yaml] spring: config: import: ""file:/etc/config/myconfig[.yaml]"" Using Configuration Trees: When running applications on a cloud platform (such as Kubernetes) you often need to read config values that the platform supplies. It is not uncommon to use environment variables for such purposes, but this can have drawbacks, especially if the value is supposed to be kept secret. As an alternative to environment variables, many cloud platforms now allow you to map configuration into mounted data volumes. For example, Kubernetes can volume mount both ConfigMaps(https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#populate-a-volume-with-data-stored-in-a-configmap) and Secrets(https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod) . There are two common volume mount patterns that can be used: A single file contains a complete set of properties (usually written as YAML). Multiple files are written to a directory tree, with the filename becoming the ‘key’ and the contents becoming the ‘value’. For the first case, you can import the YAML or Properties file directly using spring.config.import as described above(#features.external-config.files.importing) . For the second case, you need to use the configtree: prefix so that Spring Boot knows it needs to expose all the files as properties. As an example, let’s imagine that Kubernetes has mounted the following volume: etc/ config/ myapp/ username password The contents of the username file would be a config value, and the contents of password would be a secret. To import these properties, you can add the following to your application.properties or application.yaml file: Properties YAML spring.config.import=optional:configtree:/etc/config/ spring: config: import: ""optional:configtree:/etc/config/"" You can then access or inject myapp.username and myapp.password properties from the Environment in the usual way. The names of the folders and files under the config tree form the property name. In the above example, to access the properties as username and password , you can set spring.config.import to optional:configtree:/etc/config/myapp . Filenames with dot notation are also correctly mapped. For example, in the above example, a file named myapp.username in /etc/config would result in a myapp.username property in the Environment . Configuration tree values can be bound to both string String and byte[] types depending on the contents expected. If you have multiple config trees to import from the same parent folder you can use a wildcard shortcut. Any configtree: location that ends with /*/ will import all immediate children as config trees. As with a non-wildcard import, the names of the folders and files under each config tree form the property name. For example, given the following volume: etc/ config/ dbconfig/ db/ username password mqconfig/ mq/ username password You can use configtree:/etc/config/*/ as the import location: Properties YAML spring.config.import=optional:configtree:/etc/config/*/ spring: config: import: ""optional:configtree:/etc/config/*/"" This will add db.username , db.password , mq.username and mq.password properties. Directories loaded using a wildcard are sorted alphabetically. If you need a different order, then you should list each location as a separate import Configuration trees can also be used for Docker secrets. When a Docker swarm service is granted access to a secret, the secret gets mounted into the container. For example, if a secret named db.password is mounted at location /run/secrets/ , you can make db.password available to the Spring environment using the following: Properties YAML spring.config.import=optional:configtree:/run/secrets/ spring: config: import: ""optional:configtree:/run/secrets/"" Property Placeholders: The values in application.properties and application.yaml are filtered through the existing Environment when they are used, so you can refer back to previously defined values (for example, from System properties or environment variables). The standard ${name} property-placeholder syntax can be used anywhere within a value. Property placeholders can also specify a default value using a : to separate the default value from the property name, for example ${name:default} . The use of placeholders with and without defaults is shown in the following example: Properties YAML app.name=MyApp app.description=${app.name} is a Spring Boot application written by ${username:Unknown} app: name: ""MyApp"" description: ""${app.name} is a Spring Boot application written by ${username:Unknown}"" Assuming that the username property has not been set elsewhere, app.description will have the value MyApp is a Spring Boot application written by Unknown . You should always refer to property names in the placeholder using their canonical form (kebab-case using only lowercase letters). This will allow Spring Boot to use the same logic as it does when relaxed binding(#features.external-config.typesafe-configuration-properties.relaxed-binding) @ConfigurationProperties . For example, ${demo.item-price} will pick up demo.item-price and demo.itemPrice forms from the application.properties file, as well as DEMO_ITEMPRICE from the system environment. If you used ${demo.itemPrice} instead, demo.item-price and DEMO_ITEMPRICE would not be considered. You can also use this technique to create “short” variants of existing Spring Boot properties. See the Use ‘Short’ Command Line Arguments(../../how-to/properties-and-configuration.html#howto.properties-and-configuration.short-command-line-arguments) section in “How-to Guides” for details. Working With Multi-Document Files: Spring Boot allows you to split a single physical file into multiple logical documents which are each added independently. Documents are processed in order, from top to bottom. Later documents can override the properties defined in earlier ones. For application.yaml files, the standard YAML multi-document syntax is used. Three consecutive hyphens represent the end of one document, and the start of the next. For example, the following file has two logical documents: spring: application: name: ""MyApp"" --- spring: application: name: ""MyCloudApp"" config: activate: on-cloud-platform: ""kubernetes"" For application.properties files a special #--- or !--- comment is used to mark the document splits: spring.application.name=MyApp #--- spring.application.name=MyCloudApp spring.config.activate.on-cloud-platform=kubernetes Property file separators must not have any leading whitespace and must have exactly three hyphen characters. The lines immediately before and after the separator must not be same comment prefix. Multi-document property files are often used in conjunction with activation properties such as spring.config.activate.on-profile . See the next section(#features.external-config.files.activation-properties) for details. Multi-document property files cannot be loaded by using the @PropertySource or @TestPropertySource annotations. Activation Properties: It is sometimes useful to only activate a given set of properties when certain conditions are met. For example, you might have properties that are only relevant when a specific profile is active. You can conditionally activate a properties document using spring.config.activate.* . The following activation properties are available: Table 1. activation properties Property Note on-profile A profile expression that must match for the document to be active. on-cloud-platform The CloudPlatform that must be detected for the document to be active. For example, the following specifies that the second document is only active when running on Kubernetes, and only when either the “prod” or “staging” profiles are active: Properties YAML myprop=always-set #--- spring.config.activate.on-cloud-platform=kubernetes spring.config.activate.on-profile=prod | staging myotherprop=sometimes-set myprop: ""always-set"" --- spring: config: activate: on-cloud-platform: ""kubernetes"" on-profile: ""prod | staging"" myotherprop: ""sometimes-set"" Encrypting Properties: Spring Boot does not provide any built-in support for encrypting property values, however, it does provide the hook points necessary to modify values contained in the Spring Environment . The EnvironmentPostProcessor interface allows you to manipulate the Environment before the application starts. See Customize the Environment or ApplicationContext Before It Starts(../../how-to/application.html#howto.application.customize-the-environment-or-application-context) for details. If you need a secure way to store credentials and passwords, the Spring Cloud Vault(https://cloud.spring.io/spring-cloud-vault/) project provides support for storing externalized configuration in HashiCorp Vault(https://www.vaultproject.io/) . Working With YAML: YAML(https://yaml.org) is a superset of JSON and, as such, is a convenient format for specifying hierarchical configuration data. The SpringApplication class automatically supports YAML as an alternative to properties whenever you have the SnakeYAML(https://github.com/snakeyaml/snakeyaml) library on your classpath. If you use starters, SnakeYAML is automatically provided by spring-boot-starter . Mapping YAML to Properties: YAML documents need to be converted from their hierarchical format to a flat structure that can be used with the Spring Environment . For example, consider the following YAML document: environments: dev: url: ""https://dev.example.com"" name: ""Developer Setup"" prod: url: ""https://another.example.com"" name: ""My Cool App"" In order to access these properties from the Environment , they would be flattened as follows: environments.dev.url=https://dev.example.com environments.dev.name=Developer Setup environments.prod.url=https://another.example.com environments.prod.name=My Cool App Likewise, YAML lists also need to be flattened. They are represented as property keys with [index] dereferencers. For example, consider the following YAML: my: servers: - ""dev.example.com"" - ""another.example.com"" The preceding example would be transformed into these properties: my.servers[0]=dev.example.com my.servers[1]=another.example.com Properties that use the [index] notation can be bound to Java List or Set objects using Spring Boot’s Binder class. For more details see the Type-safe Configuration Properties(#features.external-config.typesafe-configuration-properties) section below. YAML files cannot be loaded by using the @PropertySource or @TestPropertySource annotations. So, in the case that you need to load values that way, you need to use a properties file. Directly Loading YAML: Spring Framework provides two convenient classes that can be used to load YAML documents. The YamlPropertiesFactoryBean loads YAML as Properties and the YamlMapFactoryBean loads YAML as a Map . You can also use the YamlPropertySourceLoader class if you want to load YAML as a Spring PropertySource . Configuring Random Values: The RandomValuePropertySource is useful for injecting random values (for example, into secrets or test cases). It can produce integers, longs, uuids, or strings, as shown in the following example: Properties YAML my.secret=${random.value} my.number=${random.int} my.bignumber=${random.long} my.uuid=${random.uuid} my.number-less-than-ten=${random.int(10)} my.number-in-range=${random.int[1024,65536]} my: secret: ""${random.value}"" number: ""${random.int}"" bignumber: ""${random.long}"" uuid: ""${random.uuid}"" number-less-than-ten: ""${random.int(10)}"" number-in-range: ""${random.int[1024,65536]}"" The random.int* syntax is OPEN value (,max) CLOSE where the OPEN,CLOSE are any character and value,max are integers. If max is provided, then value is the minimum value and max is the maximum value (exclusive). Configuring System Environment Properties: Spring Boot supports setting a prefix for environment properties. This is useful if the system environment is shared by multiple Spring Boot applications with different configuration requirements. The prefix for system environment properties can be set directly on SpringApplication . For example, if you set the prefix to input , a property such as remote.timeout will also be resolved as input.remote.timeout in the system environment. Type-safe Configuration Properties: Using the @Value(""${property}"") annotation to inject configuration properties can sometimes be cumbersome, especially if you are working with multiple properties or your data is hierarchical in nature. Spring Boot provides an alternative method of working with properties that lets strongly typed beans govern and validate the configuration of your application. See also the differences between @Value and type-safe configuration properties(#features.external-config.typesafe-configuration-properties.vs-value-annotation) . JavaBean Properties Binding: It is possible to bind a bean declaring standard JavaBean properties as shown in the following example: Java Kotlin import java.net.InetAddress; import java.util.ArrayList; import java.util.Collections; import java.util.List; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(""my.service"") public class MyProperties { private boolean enabled; private InetAddress remoteAddress; private final Security security = new Security(); // getters / setters... public boolean isEnabled() { return this.enabled; } public void setEnabled(boolean enabled) { this.enabled = enabled; } public InetAddress getRemoteAddress() { return this.remoteAddress; } public void setRemoteAddress(InetAddress remoteAddress) { this.remoteAddress = remoteAddress; } public Security getSecurity() { return this.security; } public static class Security { private String username; private String password; private List<String> roles = new ArrayList<>(Collections.singleton(""USER"")); // getters / setters... public String getUsername() { return this.username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return this.password; } public void setPassword(String password) { this.password = password; } public List<String> getRoles() { return this.roles; } public void setRoles(List<String> roles) { this.roles = roles; } } } import org.springframework.boot.context.properties.ConfigurationProperties import java.net.InetAddress @ConfigurationProperties(""my.service"") class MyProperties { var isEnabled = false var remoteAddress: InetAddress? = null val security = Security() class Security { var username: String? = null var password: String? = null var roles: List<String> = ArrayList(setOf(""USER"")) } } The preceding POJO defines the following properties: my.service.enabled , with a value of false by default. my.service.remote-address , with a type that can be coerced from String . my.service.security.username , with a nested ""security"" object whose name is determined by the name of the property. In particular, the type is not used at all there and could have been SecurityProperties . my.service.security.password . my.service.security.roles , with a collection of String that defaults to USER . The properties that map to @ConfigurationProperties classes available in Spring Boot, which are configured through properties files, YAML files, environment variables, and other mechanisms, are public API but the accessors (getters/setters) of the class itself are not meant to be used directly. Such arrangement relies on a default empty constructor and getters and setters are usually mandatory, since binding is through standard Java Beans property descriptors, just like in Spring MVC. A setter may be omitted in the following cases: Maps, as long as they are initialized, need a getter but not necessarily a setter, since they can be mutated by the binder. Collections and arrays can be accessed either through an index (typically with YAML) or by using a single comma-separated value (properties). In the latter case, a setter is mandatory. We recommend to always add a setter for such types. If you initialize a collection, make sure it is not immutable (as in the preceding example). If nested POJO properties are initialized (like the Security field in the preceding example), a setter is not required. If you want the binder to create the instance on the fly by using its default constructor, you need a setter. Some people use Project Lombok to add getters and setters automatically. Make sure that Lombok does not generate any particular constructor for such a type, as it is used automatically by the container to instantiate the object. Finally, only standard Java Bean properties are considered and binding on static properties is not supported. Constructor Binding: The example in the previous section can be rewritten in an immutable fashion as shown in the following example: Java Kotlin import java.net.InetAddress; import java.util.List; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.context.properties.bind.DefaultValue; @ConfigurationProperties(""my.service"") public class MyProperties { // fields... private final boolean enabled; private final InetAddress remoteAddress; private final Security security; public MyProperties(boolean enabled, InetAddress remoteAddress, Security security) { this.enabled = enabled; this.remoteAddress = remoteAddress; this.security = security; } // getters... public boolean isEnabled() { return this.enabled; } public InetAddress getRemoteAddress() { return this.remoteAddress; } public Security getSecurity() { return this.security; } public static class Security { // fields... private final String username; private final String password; private final List<String> roles; public Security(String username, String password, @DefaultValue(""USER"") List<String> roles) { this.username = username; this.password = password; this.roles = roles; } // getters... public String getUsername() { return this.username; } public String getPassword() { return this.password; } public List<String> getRoles() { return this.roles; } } } import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.boot.context.properties.bind.DefaultValue import java.net.InetAddress @ConfigurationProperties(""my.service"") class MyProperties(val enabled: Boolean, val remoteAddress: InetAddress, val security: Security) { class Security(val username: String, val password: String, @param:DefaultValue(""USER"") val roles: List<String>) } In this setup, the presence of a single parameterized constructor implies that constructor binding should be used. This means that the binder will find a constructor with the parameters that you wish to have bound. If your class has multiple constructors, the @ConstructorBinding annotation can be used to specify which constructor to use for constructor binding. To opt out of constructor binding for a class with a single parameterized constructor, the constructor must be annotated with @Autowired or made private . Constructor binding can be used with records. Unless your record has multiple constructors, there is no need to use @ConstructorBinding . Nested members of a constructor bound class (such as Security in the example above) will also be bound through their constructor. Default values can be specified using @DefaultValue on constructor parameters and record components. The conversion service will be applied to coerce the annotation’s String value to the target type of a missing property. Referring to the previous example, if no properties are bound to Security , the MyProperties instance will contain a null value for security . To make it contain a non-null instance of Security even when no properties are bound to it (when using Kotlin, this will require the username and password parameters of Security to be declared as nullable as they do not have default values), use an empty @DefaultValue annotation: Java Kotlin public MyProperties(boolean enabled, InetAddress remoteAddress, @DefaultValue Security security) { this.enabled = enabled; this.remoteAddress = remoteAddress; this.security = security; } class MyProperties(val enabled: Boolean, val remoteAddress: InetAddress, @DefaultValue val security: Security) { class Security(val username: String?, val password: String?, @param:DefaultValue(""USER"") val roles: List<String>) } To use constructor binding the class must be enabled using @EnableConfigurationProperties or configuration property scanning. You cannot use constructor binding with beans that are created by the regular Spring mechanisms (for example @Component beans, beans created by using @Bean methods or beans loaded by using @Import ) To use constructor binding the class must be compiled with -parameters . This will happen automatically if you use Spring Boot’s Gradle plugin or if you use Maven and spring-boot-starter-parent . The use of java.util.Optional with @ConfigurationProperties is not recommended as it is primarily intended for use as a return type. As such, it is not well-suited to configuration property injection. For consistency with properties of other types, if you do declare an Optional property and it has no value, null rather than an empty Optional will be bound. To use a reserved keyword in the name of a property, such as my.service.import , use the @Name annotation on the constructor parameter. Enabling @ConfigurationProperties-annotated Types: Spring Boot provides infrastructure to bind @ConfigurationProperties types and register them as beans. You can either enable configuration properties on a class-by-class basis or enable configuration property scanning that works in a similar manner to component scanning. Sometimes, classes annotated with @ConfigurationProperties might not be suitable for scanning, for example, if you’re developing your own auto-configuration or you want to enable them conditionally. In these cases, specify the list of types to process using the @EnableConfigurationProperties annotation. This can be done on any @Configuration class, as shown in the following example: Java Kotlin import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) @EnableConfigurationProperties(SomeProperties.class) public class MyConfiguration { } import org.springframework.boot.context.properties.EnableConfigurationProperties import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) @EnableConfigurationProperties(SomeProperties::class) class MyConfiguration Java Kotlin import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(""some.properties"") public class SomeProperties { } import org.springframework.boot.context.properties.ConfigurationProperties @ConfigurationProperties(""some.properties"") class SomeProperties To use configuration property scanning, add the @ConfigurationPropertiesScan annotation to your application. Typically, it is added to the main application class that is annotated with @SpringBootApplication but it can be added to any @Configuration class. By default, scanning will occur from the package of the class that declares the annotation. If you want to define specific packages to scan, you can do so as shown in the following example: Java Kotlin import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.context.properties.ConfigurationPropertiesScan; @SpringBootApplication @ConfigurationPropertiesScan({ ""com.example.app"", ""com.example.another"" }) public class MyApplication { } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.context.properties.ConfigurationPropertiesScan @SpringBootApplication @ConfigurationPropertiesScan(""com.example.app"", ""com.example.another"") class MyApplication When the @ConfigurationProperties bean is registered using configuration property scanning or through @EnableConfigurationProperties , the bean has a conventional name: <prefix>-<fqn> , where <prefix> is the environment key prefix specified in the @ConfigurationProperties annotation and <fqn> is the fully qualified name of the bean. If the annotation does not provide any prefix, only the fully qualified name of the bean is used. Assuming that it is in the com.example.app package, the bean name of the SomeProperties example above is some.properties-com.example.app.SomeProperties . We recommend that @ConfigurationProperties only deal with the environment and, in particular, does not inject other beans from the context. For corner cases, setter injection can be used or any of the *Aware interfaces provided by the framework (such as EnvironmentAware if you need access to the Environment ). If you still want to inject other beans using the constructor, the configuration properties bean must be annotated with @Component and use JavaBean-based property binding. Using @ConfigurationProperties-annotated Types: This style of configuration works particularly well with the SpringApplication external YAML configuration, as shown in the following example: my: service: remote-address: 192.168.1.1 security: username: ""admin"" roles: - ""USER"" - ""ADMIN"" To work with @ConfigurationProperties beans, you can inject them in the same way as any other bean, as shown in the following example: Java Kotlin import org.springframework.stereotype.Service; @Service public class MyService { private final MyProperties properties; public MyService(MyProperties properties) { this.properties = properties; } public void openConnection() { Server server = new Server(this.properties.getRemoteAddress()); server.start(); // ... } // ... } import org.springframework.stereotype.Service @Service class MyService(val properties: MyProperties) { fun openConnection() { val server = Server(properties.remoteAddress) server.start() // ... } // ... } Using @ConfigurationProperties also lets you generate metadata files that can be used by IDEs to offer auto-completion for your own keys. See the appendix(../../specification/configuration-metadata/index.html) for details. Third-party Configuration: As well as using @ConfigurationProperties to annotate a class, you can also use it on public @Bean methods. Doing so can be particularly useful when you want to bind properties to third-party components that are outside of your control. To configure a bean from the Environment properties, add @ConfigurationProperties to its bean registration, as shown in the following example: Java Kotlin import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class ThirdPartyConfiguration { @Bean @ConfigurationProperties(prefix = ""another"") public AnotherComponent anotherComponent() { return new AnotherComponent(); } } import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class ThirdPartyConfiguration { @Bean @ConfigurationProperties(prefix = ""another"") fun anotherComponent(): AnotherComponent = AnotherComponent() } Any JavaBean property defined with the another prefix is mapped onto that AnotherComponent bean in manner similar to the preceding SomeProperties example. Relaxed Binding: Spring Boot uses some relaxed rules for binding Environment properties to @ConfigurationProperties beans, so there does not need to be an exact match between the Environment property name and the bean property name. Common examples where this is useful include dash-separated environment properties (for example, context-path binds to contextPath ), and capitalized environment properties (for example, PORT binds to port ). As an example, consider the following @ConfigurationProperties class: Java Kotlin import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = ""my.main-project.person"") public class MyPersonProperties { private String firstName; public String getFirstName() { return this.firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } } import org.springframework.boot.context.properties.ConfigurationProperties @ConfigurationProperties(prefix = ""my.main-project.person"") class MyPersonProperties { var firstName: String? = null } With the preceding code, the following properties names can all be used: Table 2. relaxed binding Property Note my.main-project.person.first-name Kebab case, which is recommended for use in .properties and YAML files. my.main-project.person.firstName Standard camel case syntax. my.main-project.person.first_name Underscore notation, which is an alternative format for use in .properties and YAML files. MY_MAINPROJECT_PERSON_FIRSTNAME Upper case format, which is recommended when using system environment variables. The prefix value for the annotation must be in kebab case (lowercase and separated by - , such as my.main-project.person ). Table 3. relaxed binding rules per property source Property Source Simple List Properties Files Camel case, kebab case, or underscore notation Standard list syntax using [ ] or comma-separated values YAML Files Camel case, kebab case, or underscore notation Standard YAML list syntax or comma-separated values Environment Variables Upper case format with underscore as the delimiter (see Binding From Environment Variables(#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables) ). Numeric values surrounded by underscores (see Binding From Environment Variables(#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables) ) System properties Camel case, kebab case, or underscore notation Standard list syntax using [ ] or comma-separated values We recommend that, when possible, properties are stored in lower-case kebab format, such as my.person.first-name=Rod . Binding Maps: When binding to Map properties you may need to use a special bracket notation so that the original key value is preserved. If the key is not surrounded by [] , any characters that are not alpha-numeric, - or . are removed. For example, consider binding the following properties to a Map<String,String> : Properties YAML my.map[/key1]=value1 my.map[/key2]=value2 my.map./key3=value3 my: map: ""[/key1]"": ""value1"" ""[/key2]"": ""value2"" ""/key3"": ""value3"" For YAML files, the brackets need to be surrounded by quotes for the keys to be parsed properly. The properties above will bind to a Map with /key1 , /key2 and key3 as the keys in the map. The slash has been removed from key3 because it was not surrounded by square brackets. When binding to scalar values, keys with . in them do not need to be surrounded by [] . Scalar values include enums and all types in the java.lang package except for Object . Binding a.b=c to Map<String, String> will preserve the . in the key and return a Map with the entry {""a.b""=""c""} . For any other types you need to use the bracket notation if your key contains a . . For example, binding a.b=c to Map<String, Object> will return a Map with the entry {""a""={""b""=""c""}} whereas [a.b]=c will return a Map with the entry {""a.b""=""c""} . Binding From Environment Variables: Most operating systems impose strict rules around the names that can be used for environment variables. For example, Linux shell variables can contain only letters ( a to z or A to Z ), numbers ( 0 to 9 ) or the underscore character ( _ ). By convention, Unix shell variables will also have their names in UPPERCASE. Spring Boot’s relaxed binding rules are, as much as possible, designed to be compatible with these naming restrictions. To convert a property name in the canonical-form to an environment variable name you can follow these rules: Replace dots ( . ) with underscores ( _ ). Remove any dashes ( - ). Convert to uppercase. For example, the configuration property spring.main.log-startup-info would be an environment variable named SPRING_MAIN_LOGSTARTUPINFO . Environment variables can also be used when binding to object lists. To bind to a List , the element number should be surrounded with underscores in the variable name. For example, the configuration property my.service[0].other would use an environment variable named MY_SERVICE_0_OTHER . Support for binding from environment variables is applied to the systemEnvironment property source and to any additional property source whose name ends with -systemEnvironment . Caching: Relaxed binding uses a cache to improve performance. By default, this caching is only applied to immutable property sources. To customize this behavior, for example to enable caching for mutable property sources, use ConfigurationPropertyCaching . Merging Complex Types: When lists are configured in more than one place, overriding works by replacing the entire list. For example, assume a MyPojo object with name and description attributes that are null by default. The following example exposes a list of MyPojo objects from MyProperties : Java Kotlin import java.util.ArrayList; import java.util.List; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(""my"") public class MyProperties { private final List<MyPojo> list = new ArrayList<>(); public List<MyPojo> getList() { return this.list; } } import org.springframework.boot.context.properties.ConfigurationProperties @ConfigurationProperties(""my"") class MyProperties { val list: List<MyPojo> = ArrayList() } Consider the following configuration: Properties YAML my.list[0].name=my name my.list[0].description=my description #--- spring.config.activate.on-profile=dev my.list[0].name=my another name my: list: - name: ""my name"" description: ""my description"" --- spring: config: activate: on-profile: ""dev"" my: list: - name: ""my another name"" If the dev profile is not active, MyProperties.list contains one MyPojo entry, as previously defined. If the dev profile is enabled, however, the list still contains only one entry (with a name of my another name and a description of null ). This configuration does not add a second MyPojo instance to the list, and it does not merge the items. When a List is specified in multiple profiles, the one with the highest priority (and only that one) is used. Consider the following example: Properties YAML my.list[0].name=my name my.list[0].description=my description my.list[1].name=another name my.list[1].description=another description #--- spring.config.activate.on-profile=dev my.list[0].name=my another name my: list: - name: ""my name"" description: ""my description"" - name: ""another name"" description: ""another description"" --- spring: config: activate: on-profile: ""dev"" my: list: - name: ""my another name"" In the preceding example, if the dev profile is active, MyProperties.list contains one MyPojo entry (with a name of my another name and a description of null ). For YAML, both comma-separated lists and YAML lists can be used for completely overriding the contents of the list. For Map properties, you can bind with property values drawn from multiple sources. However, for the same property in multiple sources, the one with the highest priority is used. The following example exposes a Map<String, MyPojo> from MyProperties : Java Kotlin import java.util.LinkedHashMap; import java.util.Map; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(""my"") public class MyProperties { private final Map<String, MyPojo> map = new LinkedHashMap<>(); public Map<String, MyPojo> getMap() { return this.map; } } import org.springframework.boot.context.properties.ConfigurationProperties @ConfigurationProperties(""my"") class MyProperties { val map: Map<String, MyPojo> = LinkedHashMap() } Consider the following configuration: Properties YAML my.map.key1.name=my name 1 my.map.key1.description=my description 1 #--- spring.config.activate.on-profile=dev my.map.key1.name=dev name 1 my.map.key2.name=dev name 2 my.map.key2.description=dev description 2 my: map: key1: name: ""my name 1"" description: ""my description 1"" --- spring: config: activate: on-profile: ""dev"" my: map: key1: name: ""dev name 1"" key2: name: ""dev name 2"" description: ""dev description 2"" If the dev profile is not active, MyProperties.map contains one entry with key key1 (with a name of my name 1 and a description of my description 1 ). If the dev profile is enabled, however, map contains two entries with keys key1 (with a name of dev name 1 and a description of my description 1 ) and key2 (with a name of dev name 2 and a description of dev description 2 ). The preceding merging rules apply to properties from all property sources, and not just files. Properties Conversion: Spring Boot attempts to coerce the external application properties to the right type when it binds to the @ConfigurationProperties beans. If you need custom type conversion, you can provide a ConversionService bean (with a bean named conversionService ) or custom property editors (through a CustomEditorConfigurer bean) or custom Converters (with bean definitions annotated as @ConfigurationPropertiesBinding ). As this bean is requested very early during the application lifecycle, make sure to limit the dependencies that your ConversionService is using. Typically, any dependency that you require may not be fully initialized at creation time. You may want to rename your custom ConversionService if it is not required for configuration keys coercion and only rely on custom converters qualified with @ConfigurationPropertiesBinding . Converting Durations: Spring Boot has dedicated support for expressing durations. If you expose a java.time.Duration property, the following formats in application properties are available: A regular long representation (using milliseconds as the default unit unless a @DurationUnit has been specified) The standard ISO-8601 format used by java.time.Duration(https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/Duration.html#parse(java.lang.CharSequence)) A more readable format where the value and the unit are coupled ( 10s means 10 seconds) Consider the following example: Java Kotlin import java.time.Duration; import java.time.temporal.ChronoUnit; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.convert.DurationUnit; @ConfigurationProperties(""my"") public class MyProperties { @DurationUnit(ChronoUnit.SECONDS) private Duration sessionTimeout = Duration.ofSeconds(30); private Duration readTimeout = Duration.ofMillis(1000); // getters / setters... public Duration getSessionTimeout() { return this.sessionTimeout; } public void setSessionTimeout(Duration sessionTimeout) { this.sessionTimeout = sessionTimeout; } public Duration getReadTimeout() { return this.readTimeout; } public void setReadTimeout(Duration readTimeout) { this.readTimeout = readTimeout; } } import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.boot.convert.DurationUnit import java.time.Duration import java.time.temporal.ChronoUnit @ConfigurationProperties(""my"") class MyProperties { @DurationUnit(ChronoUnit.SECONDS) var sessionTimeout = Duration.ofSeconds(30) var readTimeout = Duration.ofMillis(1000) } To specify a session timeout of 30 seconds, 30 , PT30S and 30s are all equivalent. A read timeout of 500ms can be specified in any of the following form: 500 , PT0.5S and 500ms . You can also use any of the supported units. These are: ns for nanoseconds us for microseconds ms for milliseconds s for seconds m for minutes h for hours d for days The default unit is milliseconds and can be overridden using @DurationUnit as illustrated in the sample above. If you prefer to use constructor binding, the same properties can be exposed, as shown in the following example: Java Kotlin import java.time.Duration; import java.time.temporal.ChronoUnit; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.context.properties.bind.DefaultValue; import org.springframework.boot.convert.DurationUnit; @ConfigurationProperties(""my"") public class MyProperties { // fields... private final Duration sessionTimeout; private final Duration readTimeout; public MyProperties(@DurationUnit(ChronoUnit.SECONDS) @DefaultValue(""30s"") Duration sessionTimeout, @DefaultValue(""1000ms"") Duration readTimeout) { this.sessionTimeout = sessionTimeout; this.readTimeout = readTimeout; } // getters... public Duration getSessionTimeout() { return this.sessionTimeout; } public Duration getReadTimeout() { return this.readTimeout; } } import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.boot.context.properties.bind.DefaultValue import org.springframework.boot.convert.DurationUnit import java.time.Duration import java.time.temporal.ChronoUnit @ConfigurationProperties(""my"") class MyProperties(@param:DurationUnit(ChronoUnit.SECONDS) @param:DefaultValue(""30s"") val sessionTimeout: Duration, @param:DefaultValue(""1000ms"") val readTimeout: Duration) If you are upgrading a Long property, make sure to define the unit (using @DurationUnit ) if it is not milliseconds. Doing so gives a transparent upgrade path while supporting a much richer format. Converting Periods: In addition to durations, Spring Boot can also work with java.time.Period type. The following formats can be used in application properties: An regular int representation (using days as the default unit unless a @PeriodUnit has been specified) The standard ISO-8601 format used by java.time.Period(https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/Period.html#parse(java.lang.CharSequence)) A simpler format where the value and the unit pairs are coupled ( 1y3d means 1 year and 3 days) The following units are supported with the simple format: y for years m for months w for weeks d for days The java.time.Period type never actually stores the number of weeks, it is a shortcut that means “7 days”. Converting Data Sizes: Spring Framework has a DataSize value type that expresses a size in bytes. If you expose a DataSize property, the following formats in application properties are available: A regular long representation (using bytes as the default unit unless a @DataSizeUnit has been specified) A more readable format where the value and the unit are coupled ( 10MB means 10 megabytes) Consider the following example: Java Kotlin import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.convert.DataSizeUnit; import org.springframework.util.unit.DataSize; import org.springframework.util.unit.DataUnit; @ConfigurationProperties(""my"") public class MyProperties { @DataSizeUnit(DataUnit.MEGABYTES) private DataSize bufferSize = DataSize.ofMegabytes(2); private DataSize sizeThreshold = DataSize.ofBytes(512); // getters/setters... public DataSize getBufferSize() { return this.bufferSize; } public void setBufferSize(DataSize bufferSize) { this.bufferSize = bufferSize; } public DataSize getSizeThreshold() { return this.sizeThreshold; } public void setSizeThreshold(DataSize sizeThreshold) { this.sizeThreshold = sizeThreshold; } } import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.boot.convert.DataSizeUnit import org.springframework.util.unit.DataSize import org.springframework.util.unit.DataUnit @ConfigurationProperties(""my"") class MyProperties { @DataSizeUnit(DataUnit.MEGABYTES) var bufferSize = DataSize.ofMegabytes(2) var sizeThreshold = DataSize.ofBytes(512) } To specify a buffer size of 10 megabytes, 10 and 10MB are equivalent. A size threshold of 256 bytes can be specified as 256 or 256B . You can also use any of the supported units. These are: B for bytes KB for kilobytes MB for megabytes GB for gigabytes TB for terabytes The default unit is bytes and can be overridden using @DataSizeUnit as illustrated in the sample above. If you prefer to use constructor binding, the same properties can be exposed, as shown in the following example: Java Kotlin import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.context.properties.bind.DefaultValue; import org.springframework.boot.convert.DataSizeUnit; import org.springframework.util.unit.DataSize; import org.springframework.util.unit.DataUnit; @ConfigurationProperties(""my"") public class MyProperties { // fields... private final DataSize bufferSize; private final DataSize sizeThreshold; public MyProperties(@DataSizeUnit(DataUnit.MEGABYTES) @DefaultValue(""2MB"") DataSize bufferSize, @DefaultValue(""512B"") DataSize sizeThreshold) { this.bufferSize = bufferSize; this.sizeThreshold = sizeThreshold; } // getters... public DataSize getBufferSize() { return this.bufferSize; } public DataSize getSizeThreshold() { return this.sizeThreshold; } } import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.boot.context.properties.bind.DefaultValue import org.springframework.boot.convert.DataSizeUnit import org.springframework.util.unit.DataSize import org.springframework.util.unit.DataUnit @ConfigurationProperties(""my"") class MyProperties(@param:DataSizeUnit(DataUnit.MEGABYTES) @param:DefaultValue(""2MB"") val bufferSize: DataSize, @param:DefaultValue(""512B"") val sizeThreshold: DataSize) If you are upgrading a Long property, make sure to define the unit (using @DataSizeUnit ) if it is not bytes. Doing so gives a transparent upgrade path while supporting a much richer format. @ConfigurationProperties Validation: Spring Boot attempts to validate @ConfigurationProperties classes whenever they are annotated with Spring’s @Validated annotation. You can use JSR-303 jakarta.validation constraint annotations directly on your configuration class. To do so, ensure that a compliant JSR-303 implementation is on your classpath and then add constraint annotations to your fields, as shown in the following example: Java Kotlin import java.net.InetAddress; import jakarta.validation.constraints.NotNull; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.validation.annotation.Validated; @ConfigurationProperties(""my.service"") @Validated public class MyProperties { @NotNull private InetAddress remoteAddress; // getters/setters... public InetAddress getRemoteAddress() { return this.remoteAddress; } public void setRemoteAddress(InetAddress remoteAddress) { this.remoteAddress = remoteAddress; } } import jakarta.validation.constraints.NotNull import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.validation.annotation.Validated import java.net.InetAddress @ConfigurationProperties(""my.service"") @Validated class MyProperties { var remoteAddress: @NotNull InetAddress? = null } You can also trigger validation by annotating the @Bean method that creates the configuration properties with @Validated . To ensure that validation is always triggered for nested properties, even when no properties are found, the associated field must be annotated with @Valid . The following example builds on the preceding MyProperties example: Java Kotlin import java.net.InetAddress; import jakarta.validation.Valid; import jakarta.validation.constraints.NotEmpty; import jakarta.validation.constraints.NotNull; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.validation.annotation.Validated; @ConfigurationProperties(""my.service"") @Validated public class MyProperties { @NotNull private InetAddress remoteAddress; @Valid private final Security security = new Security(); // getters/setters... public InetAddress getRemoteAddress() { return this.remoteAddress; } public void setRemoteAddress(InetAddress remoteAddress) { this.remoteAddress = remoteAddress; } public Security getSecurity() { return this.security; } public static class Security { @NotEmpty private String username; // getters/setters... public String getUsername() { return this.username; } public void setUsername(String username) { this.username = username; } } } import jakarta.validation.Valid import jakarta.validation.constraints.NotEmpty import jakarta.validation.constraints.NotNull import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.validation.annotation.Validated import java.net.InetAddress @ConfigurationProperties(""my.service"") @Validated class MyProperties { var remoteAddress: @NotNull InetAddress? = null @Valid val security = Security() class Security { @NotEmpty var username: String? = null } } You can also add a custom Spring Validator by creating a bean definition called configurationPropertiesValidator . The @Bean method should be declared static . The configuration properties validator is created very early in the application’s lifecycle, and declaring the @Bean method as static lets the bean be created without having to instantiate the @Configuration class. Doing so avoids any problems that may be caused by early instantiation. The spring-boot-actuator module includes an endpoint that exposes all @ConfigurationProperties beans. Point your web browser to /actuator/configprops or use the equivalent JMX endpoint. See the Production ready features(../actuator/endpoints.html) section for details. @ConfigurationProperties vs. @Value: The @Value annotation is a core container feature, and it does not provide the same features as type-safe configuration properties. The following table summarizes the features that are supported by @ConfigurationProperties and @Value : Feature @ConfigurationProperties @Value Relaxed binding(#features.external-config.typesafe-configuration-properties.relaxed-binding) Yes Limited (see note below(#features.external-config.typesafe-configuration-properties.vs-value-annotation.note) ) Meta-data support(../../specification/configuration-metadata/index.html) Yes No SpEL evaluation No Yes If you do want to use @Value , we recommend that you refer to property names using their canonical form (kebab-case using only lowercase letters). This will allow Spring Boot to use the same logic as it does when relaxed binding(#features.external-config.typesafe-configuration-properties.relaxed-binding) @ConfigurationProperties . For example, @Value(""${demo.item-price}"") will pick up demo.item-price and demo.itemPrice forms from the application.properties file, as well as DEMO_ITEMPRICE from the system environment. If you used @Value(""${demo.itemPrice}"") instead, demo.item-price and DEMO_ITEMPRICE would not be considered. If you define a set of configuration keys for your own components, we recommend you group them in a POJO annotated with @ConfigurationProperties . Doing so will provide you with structured, type-safe object that you can inject into your own beans. SpEL expressions from application property files(#features.external-config.files) are not processed at time of parsing these files and populating the environment. However, it is possible to write a SpEL expression in @Value . If the value of a property from an application property file is a SpEL expression, it will be evaluated when consumed through @Value ."
"https://docs.spring.io/spring-boot/reference/features/profiles.html","Profiles: Spring Profiles provide a way to segregate parts of your application configuration and make it be available only in certain environments. Any @Component , @Configuration or @ConfigurationProperties can be marked with @Profile to limit when it is loaded, as shown in the following example: Java Kotlin import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; @Configuration(proxyBeanMethods = false) @Profile(""production"") public class ProductionConfiguration { // ... } import org.springframework.context.annotation.Configuration import org.springframework.context.annotation.Profile @Configuration(proxyBeanMethods = false) @Profile(""production"") class ProductionConfiguration { // ... } If @ConfigurationProperties beans are registered through @EnableConfigurationProperties instead of automatic scanning, the @Profile annotation needs to be specified on the @Configuration class that has the @EnableConfigurationProperties annotation. In the case where @ConfigurationProperties are scanned, @Profile can be specified on the @ConfigurationProperties class itself. You can use a spring.profiles.active Environment property to specify which profiles are active. You can specify the property in any of the ways described earlier in this chapter. For example, you could include it in your application.properties , as shown in the following example: Properties YAML spring.profiles.active=dev,hsqldb spring: profiles: active: ""dev,hsqldb"" You could also specify it on the command line by using the following switch: --spring.profiles.active=dev,hsqldb . If no profile is active, a default profile is enabled. The name of the default profile is default and it can be tuned using the spring.profiles.default Environment property, as shown in the following example: Properties YAML spring.profiles.default=none spring: profiles: default: ""none"" spring.profiles.active and spring.profiles.default can only be used in non-profile-specific documents. This means they cannot be included in profile specific files(external-config.html#features.external-config.files.profile-specific) or documents activated(external-config.html#features.external-config.files.activation-properties) by spring.config.activate.on-profile . For example, the second document configuration is invalid: Properties YAML spring.profiles.active=prod #--- spring.config.activate.on-profile=prod spring.profiles.active=metrics # this document is valid spring: profiles: active: ""prod"" --- # this document is invalid spring: config: activate: on-profile: ""prod"" profiles: active: ""metrics"" Adding Active Profiles: The spring.profiles.active property follows the same ordering rules as other properties: The highest PropertySource wins. This means that you can specify active profiles in application.properties and then replace them by using the command line switch. Sometimes, it is useful to have properties that add to the active profiles rather than replace them. The spring.profiles.include property can be used to add active profiles on top of those activated by the spring.profiles.active property. The SpringApplication entry point also has a Java API for setting additional profiles. See the setAdditionalProfiles() method in SpringApplication(../../api/java/org/springframework/boot/SpringApplication.html) . For example, when an application with the following properties is run, the common and local profiles will be activated even when it runs using the --spring.profiles.active switch: Properties YAML spring.profiles.include[0]=common spring.profiles.include[1]=local spring: profiles: include: - ""common"" - ""local"" Similar to spring.profiles.active , spring.profiles.include can only be used in non-profile-specific documents. This means it cannot be included in profile specific files(external-config.html#features.external-config.files.profile-specific) or documents activated(external-config.html#features.external-config.files.activation-properties) by spring.config.activate.on-profile . Profile groups, which are described in the next section(#features.profiles.groups) can also be used to add active profiles if a given profile is active. Profile Groups: Occasionally the profiles that you define and use in your application are too fine-grained and become cumbersome to use. For example, you might have proddb and prodmq profiles that you use to enable database and messaging features independently. To help with this, Spring Boot lets you define profile groups. A profile group allows you to define a logical name for a related group of profiles. For example, we can create a production group that consists of our proddb and prodmq profiles. Properties YAML spring.profiles.group.production[0]=proddb spring.profiles.group.production[1]=prodmq spring: profiles: group: production: - ""proddb"" - ""prodmq"" Our application can now be started using --spring.profiles.active=production to activate the production , proddb and prodmq profiles in one hit. Similar to spring.profiles.active and spring.profiles.include , spring.profiles.group can only be used in non-profile-specific documents. This means it cannot be included in profile specific files(external-config.html#features.external-config.files.profile-specific) or documents activated(external-config.html#features.external-config.files.activation-properties) by spring.config.activate.on-profile . Programmatically Setting Profiles: You can programmatically set active profiles by calling SpringApplication.setAdditionalProfiles(…​) before your application runs. It is also possible to activate profiles by using Spring’s ConfigurableEnvironment interface. Profile-specific Configuration Files: Profile-specific variants of both application.properties (or application.yaml ) and files referenced through @ConfigurationProperties are considered as files and loaded. See Profile Specific Files(external-config.html#features.external-config.files.profile-specific) for details."
"https://docs.spring.io/spring-boot/reference/features/logging.html","Logging: Spring Boot uses Commons Logging(https://commons.apache.org/logging) for all internal logging but leaves the underlying log implementation open. Default configurations are provided for Java Util Logging(https://docs.oracle.com/en/java/javase/17/docs/api/java.logging/java/util/logging/package-summary.html) , Log4j2(https://logging.apache.org/log4j/2.x/) , and Logback(https://logback.qos.ch/) . In each case, loggers are pre-configured to use console output with optional file output also available. By default, if you use the starters, Logback is used for logging. Appropriate Logback routing is also included to ensure that dependent libraries that use Java Util Logging, Commons Logging, Log4J, or SLF4J all work correctly. There are a lot of logging frameworks available for Java. Do not worry if the above list seems confusing. Generally, you do not need to change your logging dependencies and the Spring Boot defaults work just fine. When you deploy your application to a servlet container or application server, logging performed with the Java Util Logging API is not routed into your application’s logs. This prevents logging performed by the container or other applications that have been deployed to it from appearing in your application’s logs. Log Format: The default log output from Spring Boot resembles the following example: 2024-09-19T09:38:51.573Z INFO 111370 --- [myapp] [ main] o.s.b.d.f.logexample.MyApplication : Starting MyApplication using Java 17.0.12 with PID 111370 (/opt/apps/myapp.jar started by myuser in /opt/apps/) 2024-09-19T09:38:51.583Z INFO 111370 --- [myapp] [ main] o.s.b.d.f.logexample.MyApplication : No active profile set, falling back to 1 default profile: ""default"" 2024-09-19T09:38:56.347Z INFO 111370 --- [myapp] [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port 8080 (http) 2024-09-19T09:38:56.381Z INFO 111370 --- [myapp] [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2024-09-19T09:38:56.381Z INFO 111370 --- [myapp] [ main] o.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/10.1.30] 2024-09-19T09:38:56.559Z INFO 111370 --- [myapp] [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2024-09-19T09:38:56.572Z INFO 111370 --- [myapp] [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 4797 ms 2024-09-19T09:38:58.147Z INFO 111370 --- [myapp] [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port 8080 (http) with context path '/' 2024-09-19T09:38:58.182Z INFO 111370 --- [myapp] [ main] o.s.b.d.f.logexample.MyApplication : Started MyApplication in 8.33 seconds (process running for 10.307) The following items are output: Date and Time: Millisecond precision and easily sortable. Log Level: ERROR , WARN , INFO , DEBUG , or TRACE . Process ID. A --- separator to distinguish the start of actual log messages. Application name: Enclosed in square brackets (logged by default only if spring.application.name is set) Thread name: Enclosed in square brackets (may be truncated for console output). Correlation ID: If tracing is enabled (not shown in the sample above) Logger name: This is usually the source class name (often abbreviated). The log message. Logback does not have a FATAL level. It is mapped to ERROR . If you have a spring.application.name property but don’t want it logged you can set logging.include-application-name to false . Console Output: The default log configuration echoes messages to the console as they are written. By default, ERROR -level, WARN -level, and INFO -level messages are logged. You can also enable a “debug” mode by starting your application with a --debug flag. $ java -jar myapp.jar --debug You can also specify debug=true in your application.properties . When the debug mode is enabled, a selection of core loggers (embedded container, Hibernate, and Spring Boot) are configured to output more information. Enabling the debug mode does not configure your application to log all messages with DEBUG level. Alternatively, you can enable a “trace” mode by starting your application with a --trace flag (or trace=true in your application.properties ). Doing so enables trace logging for a selection of core loggers (embedded container, Hibernate schema generation, and the whole Spring portfolio). Color-coded Output: If your terminal supports ANSI, color output is used to aid readability. You can set spring.output.ansi.enabled to a supported value(../../api/java/org/springframework/boot/ansi/AnsiOutput.Enabled.html) to override the auto-detection. Color coding is configured by using the %clr conversion word. In its simplest form, the converter colors the output according to the log level, as shown in the following example: %clr(%5p) The following table describes the mapping of log levels to colors: Level Color FATAL Red ERROR Red WARN Yellow INFO Green DEBUG Green TRACE Green Alternatively, you can specify the color or style that should be used by providing it as an option to the conversion. For example, to make the text yellow, use the following setting: %clr(%d{yyyy-MM-dd'T'HH:mm:ss.SSSXXX}){yellow} The following colors and styles are supported: blue cyan faint green magenta red yellow File Output: By default, Spring Boot logs only to the console and does not write log files. If you want to write log files in addition to the console output, you need to set a logging.file.name or logging.file.path property (for example, in your application.properties ). If both properties are set, logging.file.path is ignored and only logging.file.name is used. The following table shows how the logging.* properties can be used together: Table 1. Logging properties logging.file.name logging.file.path Description (none) (none) Console only logging. Specific file (for example, my.log ) (none) Writes to the location specified by logging.file.name . The location can be absolute or relative to the current directory. (none) Specific directory (for example, /var/log ) Writes spring.log to the directory specified by logging.file.path . The directory can be absolute or relative to the current directory. Specific file Specific directory Writes to the location specified by logging.file.name and ignores logging.file.path . The location can be absolute or relative to the current directory. Log files rotate when they reach 10 MB and, as with console output, ERROR -level, WARN -level, and INFO -level messages are logged by default. Logging properties are independent of the actual logging infrastructure. As a result, specific configuration keys (such as logback.configurationFile for Logback) are not managed by spring Boot. File Rotation: If you are using the Logback, it is possible to fine-tune log rotation settings using your application.properties or application.yaml file. For all other logging system, you will need to configure rotation settings directly yourself (for example, if you use Log4j2 then you could add a log4j2.xml or log4j2-spring.xml file). The following rotation policy properties are supported: Name Description logging.logback.rollingpolicy.file-name-pattern The filename pattern used to create log archives. logging.logback.rollingpolicy.clean-history-on-start If log archive cleanup should occur when the application starts. logging.logback.rollingpolicy.max-file-size The maximum size of log file before it is archived. logging.logback.rollingpolicy.total-size-cap The maximum amount of size log archives can take before being deleted. logging.logback.rollingpolicy.max-history The maximum number of archive log files to keep (defaults to 7). Log Levels: All the supported logging systems can have the logger levels set in the Spring Environment (for example, in application.properties ) by using logging.level.<logger-name>=<level> where level is one of TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or OFF. The root logger can be configured by using logging.level.root . The following example shows potential logging settings in application.properties : Properties YAML logging.level.root=warn logging.level.org.springframework.web=debug logging.level.org.hibernate=error logging: level: root: ""warn"" org.springframework.web: ""debug"" org.hibernate: ""error"" It is also possible to set logging levels using environment variables. For example, LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG will set org.springframework.web to DEBUG . The above approach will only work for package level logging. Since relaxed binding always converts environment variables to lowercase, it is not possible to configure logging for an individual class in this way. If you need to configure logging for a class, you can use the SPRING_APPLICATION_JSON(external-config.html#features.external-config.application-json) variable. Log Groups: It is often useful to be able to group related loggers together so that they can all be configured at the same time. For example, you might commonly change the logging levels for all Tomcat related loggers, but you can not easily remember top level packages. To help with this, Spring Boot allows you to define logging groups in your Spring Environment . For example, here is how you could define a “tomcat” group by adding it to your application.properties : Properties YAML logging.group.tomcat=org.apache.catalina,org.apache.coyote,org.apache.tomcat logging: group: tomcat: ""org.apache.catalina,org.apache.coyote,org.apache.tomcat"" Once defined, you can change the level for all the loggers in the group with a single line: Properties YAML logging.level.tomcat=trace logging: level: tomcat: ""trace"" Spring Boot includes the following pre-defined logging groups that can be used out-of-the-box: Name Loggers web org.springframework.core.codec , org.springframework.http , org.springframework.web , org.springframework.boot.actuate.endpoint.web , org.springframework.boot.web.servlet.ServletContextInitializerBeans sql org.springframework.jdbc.core , org.hibernate.SQL , org.jooq.tools.LoggerListener Using a Log Shutdown Hook: In order to release logging resources when your application terminates, a shutdown hook that will trigger log system cleanup when the JVM exits is provided. This shutdown hook is registered automatically unless your application is deployed as a war file. If your application has complex context hierarchies the shutdown hook may not meet your needs. If it does not, disable the shutdown hook and investigate the options provided directly by the underlying logging system. For example, Logback offers context selectors(https://logback.qos.ch/manual/loggingSeparation.html) which allow each Logger to be created in its own context. You can use the logging.register-shutdown-hook property to disable the shutdown hook. Setting it to false will disable the registration. You can set the property in your application.properties or application.yaml file: Properties YAML logging.register-shutdown-hook=false logging: register-shutdown-hook: false Custom Log Configuration: The various logging systems can be activated by including the appropriate libraries on the classpath and can be further customized by providing a suitable configuration file in the root of the classpath or in a location specified by the following Spring Environment property: logging.config . You can force Spring Boot to use a particular logging system by using the org.springframework.boot.logging.LoggingSystem system property. The value should be the fully qualified class name of a LoggingSystem implementation. You can also disable Spring Boot’s logging configuration entirely by using a value of none . Since logging is initialized before the ApplicationContext is created, it is not possible to control logging from @PropertySources in Spring @Configuration files. The only way to change the logging system or disable it entirely is through System properties. Depending on your logging system, the following files are loaded: Logging System Customization Logback logback-spring.xml , logback-spring.groovy , logback.xml , or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties When possible, we recommend that you use the -spring variants for your logging configuration (for example, logback-spring.xml rather than logback.xml ). If you use standard configuration locations, Spring cannot completely control log initialization. There are known classloading issues with Java Util Logging that cause problems when running from an 'executable jar'. We recommend that you avoid it when running from an 'executable jar' if at all possible. To help with the customization, some other properties are transferred from the Spring Environment to System properties. This allows the properties to be consumed by logging system configuration. For example, setting logging.file.name in application.properties or LOGGING_FILE_NAME as an environment variable will result in the LOG_FILE System property being set. The properties that are transferred are described in the following table: Spring Environment System Property Comments logging.exception-conversion-word LOG_EXCEPTION_CONVERSION_WORD The conversion word used when logging exceptions. logging.file.name LOG_FILE If defined, it is used in the default log configuration. logging.file.path LOG_PATH If defined, it is used in the default log configuration. logging.pattern.console CONSOLE_LOG_PATTERN The log pattern to use on the console (stdout). logging.pattern.dateformat LOG_DATEFORMAT_PATTERN Appender pattern for log date format. logging.charset.console CONSOLE_LOG_CHARSET The charset to use for console logging. logging.threshold.console CONSOLE_LOG_THRESHOLD The log level threshold to use for console logging. logging.pattern.file FILE_LOG_PATTERN The log pattern to use in a file (if LOG_FILE is enabled). logging.charset.file FILE_LOG_CHARSET The charset to use for file logging (if LOG_FILE is enabled). logging.threshold.file FILE_LOG_THRESHOLD The log level threshold to use for file logging. logging.pattern.level LOG_LEVEL_PATTERN The format to use when rendering the log level (default %5p ). PID PID The current process ID (discovered if possible and when not already defined as an OS environment variable). If you use Logback, the following properties are also transferred: Spring Environment System Property Comments logging.logback.rollingpolicy.file-name-pattern LOGBACK_ROLLINGPOLICY_FILE_NAME_PATTERN Pattern for rolled-over log file names (default ${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz ). logging.logback.rollingpolicy.clean-history-on-start LOGBACK_ROLLINGPOLICY_CLEAN_HISTORY_ON_START Whether to clean the archive log files on startup. logging.logback.rollingpolicy.max-file-size LOGBACK_ROLLINGPOLICY_MAX_FILE_SIZE Maximum log file size. logging.logback.rollingpolicy.total-size-cap LOGBACK_ROLLINGPOLICY_TOTAL_SIZE_CAP Total size of log backups to be kept. logging.logback.rollingpolicy.max-history LOGBACK_ROLLINGPOLICY_MAX_HISTORY Maximum number of archive log files to keep. All the supported logging systems can consult System properties when parsing their configuration files. See the default configurations in spring-boot.jar for examples: Logback(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml) Log4j 2(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml) Java Util logging(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties) If you want to use a placeholder in a logging property, you should use Spring Boot’s syntax(external-config.html#features.external-config.files.property-placeholders) and not the syntax of the underlying framework. Notably, if you use Logback, you should use : as the delimiter between a property name and its default value and not use :- . You can add MDC and other ad-hoc content to log lines by overriding only the LOG_LEVEL_PATTERN (or logging.pattern.level with Logback). For example, if you use logging.pattern.level=user:%X{user} %5p , then the default log format contains an MDC entry for ""user"", if it exists, as shown in the following example. 2019-08-30 12:30:04.031 user:someone INFO 22174 --- [ nio-8080-exec-0] demo.Controller Handling authenticated request Logback Extensions: Spring Boot includes a number of extensions to Logback that can help with advanced configuration. You can use these extensions in your logback-spring.xml configuration file. Because the standard logback.xml configuration file is loaded too early, you cannot use extensions in it. You need to either use logback-spring.xml or define a logging.config property. The extensions cannot be used with Logback’s configuration scanning(https://logback.qos.ch/manual/configuration.html#autoScan) . If you attempt to do so, making changes to the configuration file results in an error similar to one of the following being logged: ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]] ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]] Profile-specific Configuration: The <springProfile> tag lets you optionally include or exclude sections of configuration based on the active Spring profiles. Profile sections are supported anywhere within the <configuration> element. Use the name attribute to specify which profile accepts the configuration. The <springProfile> tag can contain a profile name (for example staging ) or a profile expression. A profile expression allows for more complicated profile logic to be expressed, for example production & (eu-central | eu-west) . Check the Spring Framework reference guide(https://docs.spring.io/spring-framework/reference/6.1/core/beans/environment.html#beans-definition-profiles-java) for more details. The following listing shows three sample profiles: <springProfile name=""staging""> <!-- configuration to be enabled when the ""staging"" profile is active --> </springProfile> <springProfile name=""dev | staging""> <!-- configuration to be enabled when the ""dev"" or ""staging"" profiles are active --> </springProfile> <springProfile name=""!production""> <!-- configuration to be enabled when the ""production"" profile is not active --> </springProfile> Environment Properties: The <springProperty> tag lets you expose properties from the Spring Environment for use within Logback. Doing so can be useful if you want to access values from your application.properties file in your Logback configuration. The tag works in a similar way to Logback’s standard <property> tag. However, rather than specifying a direct value , you specify the source of the property (from the Environment ). If you need to store the property somewhere other than in local scope, you can use the scope attribute. If you need a fallback value (in case the property is not set in the Environment ), you can use the defaultValue attribute. The following example shows how to expose properties for use within Logback: <springProperty scope=""context"" name=""fluentHost"" source=""myapp.fluentd.host"" defaultValue=""localhost""/> <appender name=""FLUENT"" class=""ch.qos.logback.more.appenders.DataFluentAppender""> <remoteHost>${fluentHost}</remoteHost> ... </appender> The source must be specified in kebab case (such as my.property-name ). However, properties can be added to the Environment by using the relaxed rules. Log4j2 Extensions: Spring Boot includes a number of extensions to Log4j2 that can help with advanced configuration. You can use these extensions in any log4j2-spring.xml configuration file. Because the standard log4j2.xml configuration file is loaded too early, you cannot use extensions in it. You need to either use log4j2-spring.xml or define a logging.config property. The extensions supersede the Spring Boot support(https://logging.apache.org/log4j/2.x/log4j-spring-boot.html) provided by Log4J. You should make sure not to include the org.apache.logging.log4j:log4j-spring-boot module in your build. Profile-specific Configuration: The <SpringProfile> tag lets you optionally include or exclude sections of configuration based on the active Spring profiles. Profile sections are supported anywhere within the <Configuration> element. Use the name attribute to specify which profile accepts the configuration. The <SpringProfile> tag can contain a profile name (for example staging ) or a profile expression. A profile expression allows for more complicated profile logic to be expressed, for example production & (eu-central | eu-west) . Check the Spring Framework reference guide(https://docs.spring.io/spring-framework/reference/6.1/core/beans/environment.html#beans-definition-profiles-java) for more details. The following listing shows three sample profiles: <SpringProfile name=""staging""> <!-- configuration to be enabled when the ""staging"" profile is active --> </SpringProfile> <SpringProfile name=""dev | staging""> <!-- configuration to be enabled when the ""dev"" or ""staging"" profiles are active --> </SpringProfile> <SpringProfile name=""!production""> <!-- configuration to be enabled when the ""production"" profile is not active --> </SpringProfile> Environment Properties Lookup: If you want to refer to properties from your Spring Environment within your Log4j2 configuration you can use spring: prefixed lookups(https://logging.apache.org/log4j/2.x/manual/lookups.html) . Doing so can be useful if you want to access values from your application.properties file in your Log4j2 configuration. The following example shows how to set a Log4j2 property named applicationName that reads spring.application.name from the Spring Environment : <Properties> <Property name=""applicationName"">${spring:spring.application.name}</Property> </Properties> The lookup key should be specified in kebab case (such as my.property-name ). Log4j2 System Properties: Log4j2 supports a number of System Properties(https://logging.apache.org/log4j/2.x/manual/systemproperties.html) that can be used to configure various items. For example, the log4j2.skipJansi system property can be used to configure if the ConsoleAppender will try to use a Jansi(https://github.com/fusesource/jansi) output stream on Windows. All system properties that are loaded after the Log4j2 initialization can be obtained from the Spring Environment . For example, you could add log4j2.skipJansi=false to your application.properties file to have the ConsoleAppender use Jansi on Windows. The Spring Environment is only considered when system properties and OS environment variables do not contain the value being loaded. System properties that are loaded during early Log4j2 initialization cannot reference the Spring Environment . For example, the property Log4j2 uses to allow the default Log4j2 implementation to be chosen is used before the Spring Environment is available."
"https://docs.spring.io/spring-boot/reference/features/internationalization.html","Internationalization: Spring Boot supports localized messages so that your application can cater to users of different language preferences. By default, Spring Boot looks for the presence of a messages resource bundle at the root of the classpath. The auto-configuration applies when the default properties file for the configured resource bundle is available ( messages.properties by default). If your resource bundle contains only language-specific properties files, you are required to add the default. If no properties file is found that matches any of the configured base names, there will be no auto-configured MessageSource . The basename of the resource bundle as well as several other attributes can be configured using the spring.messages namespace, as shown in the following example: Properties YAML spring.messages.basename=messages,config.i18n.messages spring.messages.fallback-to-system-locale=false spring: messages: basename: ""messages,config.i18n.messages"" fallback-to-system-locale: false spring.messages.basename supports comma-separated list of locations, either a package qualifier or a resource resolved from the classpath root. See MessageSourceProperties(../../api/java/org/springframework/boot/autoconfigure/context/MessageSourceProperties.html) for more supported options."
"https://docs.spring.io/spring-boot/reference/features/aop.html","Aspect-Oriented Programming: Spring Boot provides auto-configuration for aspect-oriented programming (AOP). You can learn more about AOP with Spring in the Spring Framework reference documentation(https://docs.spring.io/spring-framework/reference/6.1/core/aop-api.html) . By default, Spring Boot’s auto-configuration configures Spring AOP to use CGLib proxies. To use JDK proxies instead, set spring.aop.proxy-target-class to false . If AspectJ is on the classpath, Spring Boot’s auto-configuration will automatically enable AspectJ auto proxy such that @EnableAspectJAutoProxy is not required."
"https://docs.spring.io/spring-boot/reference/features/json.html","JSON: Spring Boot provides integration with three JSON mapping libraries: Gson Jackson JSON-B Jackson is the preferred and default library. Jackson: Auto-configuration for Jackson is provided and Jackson is part of spring-boot-starter-json . When Jackson is on the classpath an ObjectMapper bean is automatically configured. Several configuration properties are provided for customizing the configuration of the ObjectMapper(../../how-to/spring-mvc.html#howto.spring-mvc.customize-jackson-objectmapper) . Custom Serializers and Deserializers: If you use Jackson to serialize and deserialize JSON data, you might want to write your own JsonSerializer and JsonDeserializer classes. Custom serializers are usually registered with Jackson through a module(https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers) , but Spring Boot provides an alternative @JsonComponent annotation that makes it easier to directly register Spring Beans. You can use the @JsonComponent annotation directly on JsonSerializer , JsonDeserializer or KeyDeserializer implementations. You can also use it on classes that contain serializers/deserializers as inner classes, as shown in the following example: Java Kotlin import java.io.IOException; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.ObjectCodec; import com.fasterxml.jackson.databind.DeserializationContext; import com.fasterxml.jackson.databind.JsonDeserializer; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.SerializerProvider; import org.springframework.boot.jackson.JsonComponent; @JsonComponent public class MyJsonComponent { public static class Serializer extends JsonSerializer<MyObject> { @Override public void serialize(MyObject value, JsonGenerator jgen, SerializerProvider serializers) throws IOException { jgen.writeStartObject(); jgen.writeStringField(""name"", value.getName()); jgen.writeNumberField(""age"", value.getAge()); jgen.writeEndObject(); } } public static class Deserializer extends JsonDeserializer<MyObject> { @Override public MyObject deserialize(JsonParser jsonParser, DeserializationContext ctxt) throws IOException { ObjectCodec codec = jsonParser.getCodec(); JsonNode tree = codec.readTree(jsonParser); String name = tree.get(""name"").textValue(); int age = tree.get(""age"").intValue(); return new MyObject(name, age); } } } import com.fasterxml.jackson.core.JsonGenerator import com.fasterxml.jackson.core.JsonParser import com.fasterxml.jackson.core.JsonProcessingException import com.fasterxml.jackson.databind.DeserializationContext import com.fasterxml.jackson.databind.JsonDeserializer import com.fasterxml.jackson.databind.JsonNode import com.fasterxml.jackson.databind.JsonSerializer import com.fasterxml.jackson.databind.SerializerProvider import org.springframework.boot.jackson.JsonComponent import java.io.IOException @JsonComponent class MyJsonComponent { class Serializer : JsonSerializer<MyObject>() { @Throws(IOException::class) override fun serialize(value: MyObject, jgen: JsonGenerator, serializers: SerializerProvider) { jgen.writeStartObject() jgen.writeStringField(""name"", value.name) jgen.writeNumberField(""age"", value.age) jgen.writeEndObject() } } class Deserializer : JsonDeserializer<MyObject>() { @Throws(IOException::class, JsonProcessingException::class) override fun deserialize(jsonParser: JsonParser, ctxt: DeserializationContext): MyObject { val codec = jsonParser.codec val tree = codec.readTree<JsonNode>(jsonParser) val name = tree[""name""].textValue() val age = tree[""age""].intValue() return MyObject(name, age) } } } All @JsonComponent beans in the ApplicationContext are automatically registered with Jackson. Because @JsonComponent is meta-annotated with @Component , the usual component-scanning rules apply. Spring Boot also provides JsonObjectSerializer(../../api/java/org/springframework/boot/jackson/JsonObjectSerializer.html) and JsonObjectDeserializer(../../api/java/org/springframework/boot/jackson/JsonObjectDeserializer.html) base classes that provide useful alternatives to the standard Jackson versions when serializing objects. See JsonObjectSerializer(../../api/java/org/springframework/boot/jackson/JsonObjectSerializer.html) and JsonObjectDeserializer(../../api/java/org/springframework/boot/jackson/JsonObjectDeserializer.html) in the API documentation for details. The example above can be rewritten to use JsonObjectSerializer / JsonObjectDeserializer as follows: Java Kotlin import java.io.IOException; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.ObjectCodec; import com.fasterxml.jackson.databind.DeserializationContext; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.SerializerProvider; import org.springframework.boot.jackson.JsonComponent; import org.springframework.boot.jackson.JsonObjectDeserializer; import org.springframework.boot.jackson.JsonObjectSerializer; @JsonComponent public class MyJsonComponent { public static class Serializer extends JsonObjectSerializer<MyObject> { @Override protected void serializeObject(MyObject value, JsonGenerator jgen, SerializerProvider provider) throws IOException { jgen.writeStringField(""name"", value.getName()); jgen.writeNumberField(""age"", value.getAge()); } } public static class Deserializer extends JsonObjectDeserializer<MyObject> { @Override protected MyObject deserializeObject(JsonParser jsonParser, DeserializationContext context, ObjectCodec codec, JsonNode tree) throws IOException { String name = nullSafeValue(tree.get(""name""), String.class); int age = nullSafeValue(tree.get(""age""), Integer.class); return new MyObject(name, age); } } } /* * Copyright 2012-2022 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the ""License""); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an ""AS IS"" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.springframework.boot.docs.features.json.jackson.customserializersanddeserializers.`object` import com.fasterxml.jackson.core.JsonGenerator import com.fasterxml.jackson.core.JsonParser import com.fasterxml.jackson.core.ObjectCodec import com.fasterxml.jackson.databind.DeserializationContext import com.fasterxml.jackson.databind.JsonNode import com.fasterxml.jackson.databind.SerializerProvider import org.springframework.boot.jackson.JsonComponent import org.springframework.boot.jackson.JsonObjectDeserializer import org.springframework.boot.jackson.JsonObjectSerializer import java.io.IOException @JsonComponent class MyJsonComponent { class Serializer : JsonObjectSerializer<MyObject>() { @Throws(IOException::class) override fun serializeObject(value: MyObject, jgen: JsonGenerator, provider: SerializerProvider) { jgen.writeStringField(""name"", value.name) jgen.writeNumberField(""age"", value.age) } } class Deserializer : JsonObjectDeserializer<MyObject>() { @Throws(IOException::class) override fun deserializeObject(jsonParser: JsonParser, context: DeserializationContext, codec: ObjectCodec, tree: JsonNode): MyObject { val name = nullSafeValue(tree[""name""], String::class.java) val age = nullSafeValue(tree[""age""], Int::class.java) return MyObject(name, age) } } } Mixins: Jackson has support for mixins that can be used to mix additional annotations into those already declared on a target class. Spring Boot’s Jackson auto-configuration will scan your application’s packages for classes annotated with @JsonMixin and register them with the auto-configured ObjectMapper . The registration is performed by Spring Boot’s JsonMixinModule . Gson: Auto-configuration for Gson is provided. When Gson is on the classpath a Gson bean is automatically configured. Several spring.gson.* configuration properties are provided for customizing the configuration. To take more control, one or more GsonBuilderCustomizer beans can be used. JSON-B: Auto-configuration for JSON-B is provided. When the JSON-B API and an implementation are on the classpath a Jsonb bean will be automatically configured. The preferred JSON-B implementation is Eclipse Yasson for which dependency management is provided."
"https://docs.spring.io/spring-boot/reference/features/task-execution-and-scheduling.html","Task Execution and Scheduling: In the absence of an Executor bean in the context, Spring Boot auto-configures an AsyncTaskExecutor . When virtual threads are enabled (using Java 21+ and spring.threads.virtual.enabled set to true ) this will be a SimpleAsyncTaskExecutor that uses virtual threads. Otherwise, it will be a ThreadPoolTaskExecutor with sensible defaults. In either case, the auto-configured executor will be automatically used for: asynchronous task execution ( @EnableAsync ) Spring for GraphQL’s asynchronous handling of Callable return values from controller methods Spring MVC’s asynchronous request processing Spring WebFlux’s blocking execution support If you have defined a custom Executor in the context, both regular task execution (that is @EnableAsync ) and Spring for GraphQL will use it. However, the Spring MVC and Spring WebFlux support will only use it if it is an AsyncTaskExecutor implementation (named applicationTaskExecutor ). Depending on your target arrangement, you could change your Executor into an AsyncTaskExecutor or define both an AsyncTaskExecutor and an AsyncConfigurer wrapping your custom Executor . The auto-configured ThreadPoolTaskExecutorBuilder allows you to easily create instances that reproduce what the auto-configuration does by default. When a ThreadPoolTaskExecutor is auto-configured, the thread pool uses 8 core threads that can grow and shrink according to the load. Those default settings can be fine-tuned using the spring.task.execution namespace, as shown in the following example: Properties YAML spring.task.execution.pool.max-size=16 spring.task.execution.pool.queue-capacity=100 spring.task.execution.pool.keep-alive=10s spring: task: execution: pool: max-size: 16 queue-capacity: 100 keep-alive: ""10s"" This changes the thread pool to use a bounded queue so that when the queue is full (100 tasks), the thread pool increases to maximum 16 threads. Shrinking of the pool is more aggressive as threads are reclaimed when they are idle for 10 seconds (rather than 60 seconds by default). A scheduler can also be auto-configured if it needs to be associated with scheduled task execution (using @EnableScheduling for instance). If virtual threads are enabled (using Java 21+ and spring.threads.virtual.enabled set to true ) this will be a SimpleAsyncTaskScheduler that uses virtual threads. This SimpleAsyncTaskScheduler will ignore any pooling related properties. If virtual threads are not enabled, it will be a ThreadPoolTaskScheduler with sensible defaults. The ThreadPoolTaskScheduler uses one thread by default and its settings can be fine-tuned using the spring.task.scheduling namespace, as shown in the following example: Properties YAML spring.task.scheduling.thread-name-prefix=scheduling- spring.task.scheduling.pool.size=2 spring: task: scheduling: thread-name-prefix: ""scheduling-"" pool: size: 2 A ThreadPoolTaskExecutorBuilder bean, a SimpleAsyncTaskExecutorBuilder bean, a ThreadPoolTaskSchedulerBuilder bean and a SimpleAsyncTaskSchedulerBuilder are made available in the context if a custom executor or scheduler needs to be created. The SimpleAsyncTaskExecutorBuilder and SimpleAsyncTaskSchedulerBuilder beans are auto-configured to use virtual threads if they are enabled (using Java 21+ and spring.threads.virtual.enabled set to true )."
"https://docs.spring.io/spring-boot/reference/features/dev-services.html","Development-time Services: Development-time services provide external dependencies needed to run the application while developing it. They are only supposed to be used while developing and are disabled when the application is deployed. Spring Boot offers support for two development time services, Docker Compose and Testcontainers. The next sections will provide more details about them. Docker Compose Support: Docker Compose is a popular technology that can be used to define and manage multiple containers for services that your application needs. A compose.yml file is typically created next to your application which defines and configures service containers. A typical workflow with Docker Compose is to run docker compose up , work on your application with it connecting to started services, then run docker compose down when you are finished. The spring-boot-docker-compose module can be included in a project to provide support for working with containers using Docker Compose. Add the module dependency to your build, as shown in the following listings for Maven and Gradle: Maven <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-docker-compose</artifactId> <optional>true</optional> </dependency> </dependencies> Gradle dependencies { developmentOnly(""org.springframework.boot:spring-boot-docker-compose"") } When this module is included as a dependency Spring Boot will do the following: Search for a compose.yml and other common compose filenames in your working directory Call docker compose up with the discovered compose.yml Create service connection beans for each supported container Call docker compose stop when the application is shutdown If the Docker Compose services are already running when starting the application, Spring Boot will only create the service connection beans for each supported container. It will not call docker compose up again and it will not call docker compose stop when the application is shutdown. Repackaged archives do not contain Spring Boot’s Docker Compose by default. If you want to use this support, you need to include it. When using the Maven plugin, set the excludeDockerCompose property to false . When using the Gradle plugin, configure the task’s classpath to include the developmentOnly configuration(../../gradle-plugin/packaging.html#packaging-executable.configuring.including-development-only-dependencies) . Prerequisites: You need to have the docker and docker compose (or docker-compose ) CLI applications on your path. The minimum supported Docker Compose version is 2.2.0. Service Connections: A service connection is a connection to any remote service. Spring Boot’s auto-configuration can consume the details of a service connection and use them to establish a connection to a remote service. When doing so, the connection details take precedence over any connection-related configuration properties. When using Spring Boot’s Docker Compose support, service connections are established to the port mapped by the container. Docker compose is usually used in such a way that the ports inside the container are mapped to ephemeral ports on your computer. For example, a Postgres server may run inside the container using port 5432 but be mapped to a totally different port locally. The service connection will always discover and use the locally mapped port. Service connections are established by using the image name of the container. The following service connections are currently supported: Connection Details Matched on ActiveMQConnectionDetails Containers named ""symptoma/activemq"" or ""apache/activemq-classic"" ArtemisConnectionDetails Containers named ""apache/activemq-artemis"" CassandraConnectionDetails Containers named ""cassandra"" or ""bitnami/cassandra"" ElasticsearchConnectionDetails Containers named ""elasticsearch"" or ""bitnami/elasticsearch"" JdbcConnectionDetails Containers named ""gvenzl/oracle-free"", ""gvenzl/oracle-xe"", ""mariadb"", ""bitnami/mariadb"", ""mssql/server"", ""mysql"", ""bitnami/mysql"", ""postgres"", or ""bitnami/postgresql"" LdapConnectionDetails Containers named ""osixia/openldap"" MongoConnectionDetails Containers named ""mongo"" or ""bitnami/mongodb"" Neo4jConnectionDetails Containers named ""neo4j"" or ""bitnami/neo4j"" OtlpMetricsConnectionDetails Containers named ""otel/opentelemetry-collector-contrib"" OtlpTracingConnectionDetails Containers named ""otel/opentelemetry-collector-contrib"" PulsarConnectionDetails Containers named ""apachepulsar/pulsar"" R2dbcConnectionDetails Containers named ""gvenzl/oracle-free"", ""gvenzl/oracle-xe"", ""mariadb"", ""bitnami/mariadb"", ""mssql/server"", ""mysql"", ""bitnami/mysql"", ""postgres"", or ""bitnami/postgresql"" RabbitConnectionDetails Containers named ""rabbitmq"" or ""bitnami/rabbitmq"" RedisConnectionDetails Containers named ""redis"" or ""bitnami/redis"" ZipkinConnectionDetails Containers named ""openzipkin/zipkin"". Custom Images: Sometimes you may need to use your own version of an image to provide a service. You can use any custom image as long as it behaves in the same way as the standard image. Specifically, any environment variables that the standard image supports must also be used in your custom image. If your image uses a different name, you can use a label in your compose.yml file so that Spring Boot can provide a service connection. Use a label named org.springframework.boot.service-connection to provide the service name. For example: services: redis: image: 'mycompany/mycustomredis:7.0' ports: - '6379' labels: org.springframework.boot.service-connection: redis Skipping Specific Containers: If you have a container image defined in your compose.yml that you don’t want connected to your application you can use a label to ignore it. Any container with labeled with org.springframework.boot.ignore will be ignored by Spring Boot. For example: services: redis: image: 'redis:7.0' ports: - '6379' labels: org.springframework.boot.ignore: true Using a Specific Compose File: If your compose file is not in the same directory as your application, or if it’s named differently, you can use spring.docker.compose.file in your application.properties or application.yaml to point to a different file. Properties can be defined as an exact path or a path that’s relative to your application. For example: Properties YAML spring.docker.compose.file=../my-compose.yml spring: docker: compose: file: ""../my-compose.yml"" Waiting for Container Readiness: Containers started by Docker Compose may take some time to become fully ready. The recommended way of checking for readiness is to add a healthcheck section under the service definition in your compose.yml file. Since it’s not uncommon for healthcheck configuration to be omitted from compose.yml files, Spring Boot also checks directly for service readiness. By default, a container is considered ready when a TCP/IP connection can be established to its mapped port. You can disable this on a per-container basis by adding a org.springframework.boot.readiness-check.tcp.disable label in your compose.yml file. For example: services: redis: image: 'redis:7.0' ports: - '6379' labels: org.springframework.boot.readiness-check.tcp.disable: true You can also change timeout values in your application.properties or application.yaml file: Properties YAML spring.docker.compose.readiness.tcp.connect-timeout=10s spring.docker.compose.readiness.tcp.read-timeout=5s spring: docker: compose: readiness: tcp: connect-timeout: 10s read-timeout: 5s The overall timeout can be configured using spring.docker.compose.readiness.timeout . Controlling the Docker Compose Lifecycle: By default Spring Boot calls docker compose up when your application starts and docker compose stop when it’s shut down. If you prefer to have different lifecycle management you can use the spring.docker.compose.lifecycle-management property. The following values are supported: none - Do not start or stop Docker Compose start-only - Start Docker Compose when the application starts and leave it running start-and-stop - Start Docker Compose when the application starts and stop it when the JVM exits In addition you can use the spring.docker.compose.start.command property to change whether docker compose up or docker compose start is used. The spring.docker.compose.stop.command allows you to configure if docker compose down or docker compose stop is used. The following example shows how lifecycle management can be configured: Properties YAML spring.docker.compose.lifecycle-management=start-and-stop spring.docker.compose.start.command=start spring.docker.compose.stop.command=down spring.docker.compose.stop.timeout=1m spring: docker: compose: lifecycle-management: start-and-stop start: command: start stop: command: down timeout: 1m Activating Docker Compose Profiles: Docker Compose profiles are similar to Spring profiles in that they let you adjust your Docker Compose configuration for specific environments. If you want to activate a specific Docker Compose profile you can use the spring.docker.compose.profiles.active property in your application.properties or application.yaml file: Properties YAML spring.docker.compose.profiles.active=myprofile spring: docker: compose: profiles: active: ""myprofile"" Using Docker Compose in Tests: By default, Spring Boot’s Docker Compose support is disabled when running tests. To enable Docker Compose support in tests, set spring.docker.compose.skip.in-tests to false . When using Gradle, you also need to change the configuration of the spring-boot-docker-compose dependency from developmentOnly to testAndDevelopmentOnly : Gradle dependencies { testAndDevelopmentOnly(""org.springframework.boot:spring-boot-docker-compose"") } Testcontainers Support: As well as using Testcontainers for integration testing(../testing/testcontainers.html#testing.testcontainers) , it’s also possible to use them at development time. The next sections will provide more details about that. Using Testcontainers at Development Time: This approach allows developers to quickly start containers for the services that the application depends on, removing the need to manually provision things like database servers. Using Testcontainers in this way provides functionality similar to Docker Compose, except that your container configuration is in Java rather than YAML. To use Testcontainers at development time you need to launch your application using your “test” classpath rather than “main”. This will allow you to access all declared test dependencies and give you a natural place to write your test configuration. To create a test launchable version of your application you should create an “Application” class in the src/test directory. For example, if your main application is in src/main/java/com/example/MyApplication.java , you should create src/test/java/com/example/TestMyApplication.java The TestMyApplication class can use the SpringApplication.from(…​) method to launch the real application: import org.springframework.boot.SpringApplication; public class TestMyApplication { public static void main(String[] args) { SpringApplication.from(MyApplication::main).run(args); } } You’ll also need to define the Container instances that you want to start along with your application. To do this, you need to make sure that the spring-boot-testcontainers module has been added as a test dependency. Once that has been done, you can create a @TestConfiguration class that declares @Bean methods for the containers you want to start. You can also annotate your @Bean methods with @ServiceConnection in order to create ConnectionDetails beans. See the service connections(../testing/testcontainers.html#testing.testcontainers.service-connections) section for details of the supported technologies. A typical Testcontainers configuration would look like this: import org.testcontainers.containers.Neo4jContainer; import org.springframework.boot.test.context.TestConfiguration; import org.springframework.boot.testcontainers.service.connection.ServiceConnection; import org.springframework.context.annotation.Bean; @TestConfiguration(proxyBeanMethods = false) public class MyContainersConfiguration { @Bean @ServiceConnection public Neo4jContainer<?> neo4jContainer() { return new Neo4jContainer<>(""neo4j:5""); } } The lifecycle of Container beans is automatically managed by Spring Boot. Containers will be started and stopped automatically. You can use the spring.testcontainers.beans.startup property to change how containers are started. By default sequential startup is used, but you may also choose parallel if you wish to start multiple containers in parallel. Once you have defined your test configuration, you can use the with(…​) method to attach it to your test launcher: import org.springframework.boot.SpringApplication; public class TestMyApplication { public static void main(String[] args) { SpringApplication.from(MyApplication::main).with(MyContainersConfiguration.class).run(args); } } You can now launch TestMyApplication as you would any regular Java main method application to start your application and the containers that it needs to run. You can use the Maven goal spring-boot:test-run or the Gradle task bootTestRun to do this from the command line. Contributing Dynamic Properties at Development Time: If you want to contribute dynamic properties at development time from your Container @Bean methods, you can do so by injecting a DynamicPropertyRegistry . This works in a similar way to the @DynamicPropertySource annotation(../testing/testcontainers.html#testing.testcontainers.dynamic-properties) that you can use in your tests. It allows you to add properties that will become available once your container has started. A typical configuration would look like this: import org.testcontainers.containers.MongoDBContainer; import org.springframework.boot.test.context.TestConfiguration; import org.springframework.context.annotation.Bean; import org.springframework.test.context.DynamicPropertyRegistry; @TestConfiguration(proxyBeanMethods = false) public class MyContainersConfiguration { @Bean public MongoDBContainer mongoDbContainer(DynamicPropertyRegistry properties) { MongoDBContainer container = new MongoDBContainer(""mongo:5.0""); properties.add(""spring.data.mongodb.host"", container::getHost); properties.add(""spring.data.mongodb.port"", container::getFirstMappedPort); return container; } } Using a @ServiceConnection is recommended whenever possible, however, dynamic properties can be a useful fallback for technologies that don’t yet have @ServiceConnection support. Importing Testcontainer Declaration Classes: A common pattern when using Testcontainers is to declare Container instances as static fields. Often these fields are defined directly on the test class. They can also be declared on a parent class or on an interface that the test implements. For example, the following MyContainers interface declares mongo and neo4j containers: import org.testcontainers.containers.MongoDBContainer; import org.testcontainers.containers.Neo4jContainer; import org.testcontainers.junit.jupiter.Container; import org.springframework.boot.testcontainers.service.connection.ServiceConnection; public interface MyContainers { @Container @ServiceConnection MongoDBContainer mongoContainer = new MongoDBContainer(""mongo:5.0""); @Container @ServiceConnection Neo4jContainer<?> neo4jContainer = new Neo4jContainer<>(""neo4j:5""); } If you already have containers defined in this way, or you just prefer this style, you can import these declaration classes rather than defining your containers as @Bean methods. To do so, add the @ImportTestcontainers annotation to your test configuration class: import org.springframework.boot.test.context.TestConfiguration; import org.springframework.boot.testcontainers.context.ImportTestcontainers; @TestConfiguration(proxyBeanMethods = false) @ImportTestcontainers(MyContainers.class) public class MyContainersConfiguration { } If you don’t intend to use the service connections feature(../testing/testcontainers.html#testing.testcontainers.service-connections) but want to use @DynamicPropertySource(../testing/testcontainers.html#testing.testcontainers.dynamic-properties) instead, remove the @ServiceConnection annotation from the Container fields. You can also add @DynamicPropertySource annotated methods to your declaration class. Using DevTools with Testcontainers at Development Time: When using devtools, you can annotate beans and bean methods with @RestartScope . Such beans won’t be recreated when the devtools restart the application. This is especially useful for Testcontainer Container beans, as they keep their state despite the application restart. import org.testcontainers.containers.MongoDBContainer; import org.springframework.boot.devtools.restart.RestartScope; import org.springframework.boot.test.context.TestConfiguration; import org.springframework.boot.testcontainers.service.connection.ServiceConnection; import org.springframework.context.annotation.Bean; @TestConfiguration(proxyBeanMethods = false) public class MyContainersConfiguration { @Bean @RestartScope @ServiceConnection public MongoDBContainer mongoDbContainer() { return new MongoDBContainer(""mongo:5.0""); } } If you’re using Gradle and want to use this feature, you need to change the configuration of the spring-boot-devtools dependency from developmentOnly to testAndDevelopmentOnly . With the default scope of developmentOnly , the bootTestRun task will not pick up changes in your code, as the devtools are not active."
"https://docs.spring.io/spring-boot/reference/features/developing-auto-configuration.html","Creating Your Own Auto-configuration: If you work in a company that develops shared libraries, or if you work on an open-source or commercial library, you might want to develop your own auto-configuration. Auto-configuration classes can be bundled in external jars and still be picked up by Spring Boot. Auto-configuration can be associated to a “starter” that provides the auto-configuration code as well as the typical libraries that you would use with it. We first cover what you need to know to build your own auto-configuration and then we move on to the typical steps required to create a custom starter(#features.developing-auto-configuration.custom-starter) . Understanding Auto-configured Beans: Classes that implement auto-configuration are annotated with @AutoConfiguration . This annotation itself is meta-annotated with @Configuration , making auto-configurations standard @Configuration classes. Additional @Conditional annotations are used to constrain when the auto-configuration should apply. Usually, auto-configuration classes use @ConditionalOnClass and @ConditionalOnMissingBean annotations. This ensures that auto-configuration applies only when relevant classes are found and when you have not declared your own @Configuration . You can browse the source code of spring-boot-autoconfigure(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure) to see the @AutoConfiguration classes that Spring provides (see the META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports) file). Locating Auto-configuration Candidates: Spring Boot checks for the presence of a META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports file within your published jar. The file should list your configuration classes, with one class name per line, as shown in the following example: com.mycorp.libx.autoconfigure.LibXAutoConfiguration com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration You can add comments to the imports file using the # character. Auto-configurations must be loaded only by being named in the imports file. Make sure that they are defined in a specific package space and that they are never the target of component scanning. Furthermore, auto-configuration classes should not enable component scanning to find additional components. Specific @Import annotations should be used instead. If your configuration needs to be applied in a specific order, you can use the before , beforeName , after and afterName attributes on the @AutoConfiguration(../../api/java/org/springframework/boot/autoconfigure/AutoConfiguration.html) annotation or the dedicated @AutoConfigureBefore(../../api/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.html) and @AutoConfigureAfter(../../api/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.html) annotations. For example, if you provide web-specific configuration, your class may need to be applied after WebMvcAutoConfiguration . If you want to order certain auto-configurations that should not have any direct knowledge of each other, you can also use @AutoConfigureOrder . That annotation has the same semantic as the regular @Order annotation but provides a dedicated order for auto-configuration classes. As with standard @Configuration classes, the order in which auto-configuration classes are applied only affects the order in which their beans are defined. The order in which those beans are subsequently created is unaffected and is determined by each bean’s dependencies and any @DependsOn relationships. Condition Annotations: You almost always want to include one or more @Conditional annotations on your auto-configuration class. The @ConditionalOnMissingBean annotation is one common example that is used to allow developers to override auto-configuration if they are not happy with your defaults. Spring Boot includes a number of @Conditional annotations that you can reuse in your own code by annotating @Configuration classes or individual @Bean methods. These annotations include: Class Conditions(#features.developing-auto-configuration.condition-annotations.class-conditions) Bean Conditions(#features.developing-auto-configuration.condition-annotations.bean-conditions) Property Conditions(#features.developing-auto-configuration.condition-annotations.property-conditions) Resource Conditions(#features.developing-auto-configuration.condition-annotations.resource-conditions) Web Application Conditions(#features.developing-auto-configuration.condition-annotations.web-application-conditions) SpEL Expression Conditions(#features.developing-auto-configuration.condition-annotations.spel-conditions) Class Conditions: The @ConditionalOnClass and @ConditionalOnMissingClass annotations let @Configuration classes be included based on the presence or absence of specific classes. Due to the fact that annotation metadata is parsed by using ASM(https://asm.ow2.io/) , you can use the value attribute to refer to the real class, even though that class might not actually appear on the running application classpath. You can also use the name attribute if you prefer to specify the class name by using a String value. This mechanism does not apply the same way to @Bean methods where typically the return type is the target of the condition: before the condition on the method applies, the JVM will have loaded the class and potentially processed method references which will fail if the class is not present. To handle this scenario, a separate @Configuration class can be used to isolate the condition, as shown in the following example: Java Kotlin import org.springframework.boot.autoconfigure.AutoConfiguration; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @AutoConfiguration // Some conditions ... public class MyAutoConfiguration { // Auto-configured beans ... @Configuration(proxyBeanMethods = false) @ConditionalOnClass(SomeService.class) public static class SomeServiceConfiguration { @Bean @ConditionalOnMissingBean public SomeService someService() { return new SomeService(); } } } import org.springframework.boot.autoconfigure.condition.ConditionalOnClass import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) // Some conditions ... class MyAutoConfiguration { // Auto-configured beans ... @Configuration(proxyBeanMethods = false) @ConditionalOnClass(SomeService::class) class SomeServiceConfiguration { @Bean @ConditionalOnMissingBean fun someService(): SomeService { return SomeService() } } } If you use @ConditionalOnClass or @ConditionalOnMissingClass as a part of a meta-annotation to compose your own composed annotations, you must use name as referring to the class in such a case is not handled. Bean Conditions: The @ConditionalOnBean and @ConditionalOnMissingBean annotations let a bean be included based on the presence or absence of specific beans. You can use the value attribute to specify beans by type or name to specify beans by name. The search attribute lets you limit the ApplicationContext hierarchy that should be considered when searching for beans. When placed on a @Bean method, the target type defaults to the return type of the method, as shown in the following example: Java Kotlin import org.springframework.boot.autoconfigure.AutoConfiguration; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.context.annotation.Bean; @AutoConfiguration public class MyAutoConfiguration { @Bean @ConditionalOnMissingBean public SomeService someService() { return new SomeService(); } } import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyAutoConfiguration { @Bean @ConditionalOnMissingBean fun someService(): SomeService { return SomeService() } } In the preceding example, the someService bean is going to be created if no bean of type SomeService is already contained in the ApplicationContext . You need to be very careful about the order in which bean definitions are added, as these conditions are evaluated based on what has been processed so far. For this reason, we recommend using only @ConditionalOnBean and @ConditionalOnMissingBean annotations on auto-configuration classes (since these are guaranteed to load after any user-defined bean definitions have been added). @ConditionalOnBean and @ConditionalOnMissingBean do not prevent @Configuration classes from being created. The only difference between using these conditions at the class level and marking each contained @Bean method with the annotation is that the former prevents registration of the @Configuration class as a bean if the condition does not match. When declaring a @Bean method, provide as much type information as possible in the method’s return type. For example, if your bean’s concrete class implements an interface the bean method’s return type should be the concrete class and not the interface. Providing as much type information as possible in @Bean methods is particularly important when using bean conditions as their evaluation can only rely upon to type information that is available in the method signature. Property Conditions: The @ConditionalOnProperty annotation lets configuration be included based on a Spring Environment property. Use the prefix and name attributes to specify the property that should be checked. By default, any property that exists and is not equal to false is matched. You can also create more advanced checks by using the havingValue and matchIfMissing attributes. If multiple names are given in the name attribute, all of the properties have to pass the test for the condition to match. Resource Conditions: The @ConditionalOnResource annotation lets configuration be included only when a specific resource is present. Resources can be specified by using the usual Spring conventions, as shown in the following example: file:/home/user/test.dat . Web Application Conditions: The @ConditionalOnWebApplication and @ConditionalOnNotWebApplication annotations let configuration be included depending on whether the application is a web application. A servlet-based web application is any application that uses a Spring WebApplicationContext , defines a session scope, or has a ConfigurableWebEnvironment . A reactive web application is any application that uses a ReactiveWebApplicationContext , or has a ConfigurableReactiveWebEnvironment . The @ConditionalOnWarDeployment and @ConditionalOnNotWarDeployment annotations let configuration be included depending on whether the application is a traditional WAR application that is deployed to a servlet container. This condition will not match for applications that are run with an embedded web server. SpEL Expression Conditions: The @ConditionalOnExpression annotation lets configuration be included based on the result of a SpEL expression(https://docs.spring.io/spring-framework/reference/6.1/core/expressions.html) . Referencing a bean in the expression will cause that bean to be initialized very early in context refresh processing. As a result, the bean won’t be eligible for post-processing (such as configuration properties binding) and its state may be incomplete. Testing your Auto-configuration: An auto-configuration can be affected by many factors: user configuration ( @Bean definition and Environment customization), condition evaluation (presence of a particular library), and others. Concretely, each test should create a well defined ApplicationContext that represents a combination of those customizations. ApplicationContextRunner provides a great way to achieve that. ApplicationContextRunner doesn’t work when running the tests in a native image. ApplicationContextRunner is usually defined as a field of the test class to gather the base, common configuration. The following example makes sure that MyServiceAutoConfiguration is always invoked: Java Kotlin private final ApplicationContextRunner contextRunner = new ApplicationContextRunner() .withConfiguration(AutoConfigurations.of(MyServiceAutoConfiguration.class)); val contextRunner = ApplicationContextRunner() .withConfiguration(AutoConfigurations.of(MyServiceAutoConfiguration::class.java)) If multiple auto-configurations have to be defined, there is no need to order their declarations as they are invoked in the exact same order as when running the application. Each test can use the runner to represent a particular use case. For instance, the sample below invokes a user configuration ( UserConfiguration ) and checks that the auto-configuration backs off properly. Invoking run provides a callback context that can be used with AssertJ . Java Kotlin @Test void defaultServiceBacksOff() { this.contextRunner.withUserConfiguration(UserConfiguration.class).run((context) -> { assertThat(context).hasSingleBean(MyService.class); assertThat(context).getBean(""myCustomService"").isSameAs(context.getBean(MyService.class)); }); } @Configuration(proxyBeanMethods = false) static class UserConfiguration { @Bean MyService myCustomService() { return new MyService(""mine""); } } @Test fun defaultServiceBacksOff() { contextRunner.withUserConfiguration(UserConfiguration::class.java) .run { context: AssertableApplicationContext -> assertThat(context).hasSingleBean(MyService::class.java) assertThat(context).getBean(""myCustomService"") .isSameAs(context.getBean(MyService::class.java)) } } @Configuration(proxyBeanMethods = false) internal class UserConfiguration { @Bean fun myCustomService(): MyService { return MyService(""mine"") } } It is also possible to easily customize the Environment , as shown in the following example: Java Kotlin @Test void serviceNameCanBeConfigured() { this.contextRunner.withPropertyValues(""user.name=test123"").run((context) -> { assertThat(context).hasSingleBean(MyService.class); assertThat(context.getBean(MyService.class).getName()).isEqualTo(""test123""); }); } @Test fun serviceNameCanBeConfigured() { contextRunner.withPropertyValues(""user.name=test123"").run { context: AssertableApplicationContext -> assertThat(context).hasSingleBean(MyService::class.java) assertThat(context.getBean(MyService::class.java).name).isEqualTo(""test123"") } } The runner can also be used to display the ConditionEvaluationReport . The report can be printed at INFO or DEBUG level. The following example shows how to use the ConditionEvaluationReportLoggingListener to print the report in auto-configuration tests. Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener; import org.springframework.boot.logging.LogLevel; import org.springframework.boot.test.context.runner.ApplicationContextRunner; class MyConditionEvaluationReportingTests { @Test void autoConfigTest() { new ApplicationContextRunner() .withInitializer(ConditionEvaluationReportLoggingListener.forLogLevel(LogLevel.INFO)) .run((context) -> { // Test something... }); } } import org.junit.jupiter.api.Test import org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener import org.springframework.boot.logging.LogLevel import org.springframework.boot.test.context.assertj.AssertableApplicationContext import org.springframework.boot.test.context.runner.ApplicationContextRunner class MyConditionEvaluationReportingTests { @Test fun autoConfigTest() { ApplicationContextRunner() .withInitializer(ConditionEvaluationReportLoggingListener.forLogLevel(LogLevel.INFO)) .run { context: AssertableApplicationContext? -> } } } Simulating a Web Context: If you need to test an auto-configuration that only operates in a servlet or reactive web application context, use the WebApplicationContextRunner or ReactiveWebApplicationContextRunner respectively. Overriding the Classpath: It is also possible to test what happens when a particular class and/or package is not present at runtime. Spring Boot ships with a FilteredClassLoader that can easily be used by the runner. In the following example, we assert that if MyService is not present, the auto-configuration is properly disabled: Java Kotlin @Test void serviceIsIgnoredIfLibraryIsNotPresent() { this.contextRunner.withClassLoader(new FilteredClassLoader(MyService.class)) .run((context) -> assertThat(context).doesNotHaveBean(""myService"")); } @Test fun serviceIsIgnoredIfLibraryIsNotPresent() { contextRunner.withClassLoader(FilteredClassLoader(MyService::class.java)) .run { context: AssertableApplicationContext? -> assertThat(context).doesNotHaveBean(""myService"") } } Creating Your Own Starter: A typical Spring Boot starter contains code to auto-configure and customize the infrastructure of a given technology, let’s call that ""acme"". To make it easily extensible, a number of configuration keys in a dedicated namespace can be exposed to the environment. Finally, a single ""starter"" dependency is provided to help users get started as easily as possible. Concretely, a custom starter can contain the following: The autoconfigure module that contains the auto-configuration code for ""acme"". The starter module that provides a dependency to the autoconfigure module as well as ""acme"" and any additional dependencies that are typically useful. In a nutshell, adding the starter should provide everything needed to start using that library. This separation in two modules is in no way necessary. If ""acme"" has several flavors, options or optional features, then it is better to separate the auto-configuration as you can clearly express the fact some features are optional. Besides, you have the ability to craft a starter that provides an opinion about those optional dependencies. At the same time, others can rely only on the autoconfigure module and craft their own starter with different opinions. If the auto-configuration is relatively straightforward and does not have optional features, merging the two modules in the starter is definitely an option. Naming: You should make sure to provide a proper namespace for your starter. Do not start your module names with spring-boot , even if you use a different Maven groupId . We may offer official support for the thing you auto-configure in the future. As a rule of thumb, you should name a combined module after the starter. For example, assume that you are creating a starter for ""acme"" and that you name the auto-configure module acme-spring-boot and the starter acme-spring-boot-starter . If you only have one module that combines the two, name it acme-spring-boot-starter . Configuration keys: If your starter provides configuration keys, use a unique namespace for them. In particular, do not include your keys in the namespaces that Spring Boot uses (such as server , management , spring , and so on). If you use the same namespace, we may modify these namespaces in the future in ways that break your modules. As a rule of thumb, prefix all your keys with a namespace that you own (for example acme ). Make sure that configuration keys are documented by adding field Javadoc for each property, as shown in the following example: Java Kotlin import java.time.Duration; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(""acme"") public class AcmeProperties { /** * Whether to check the location of acme resources. */ private boolean checkLocation = true; /** * Timeout for establishing a connection to the acme server. */ private Duration loginTimeout = Duration.ofSeconds(3); // getters/setters ... public boolean isCheckLocation() { return this.checkLocation; } public void setCheckLocation(boolean checkLocation) { this.checkLocation = checkLocation; } public Duration getLoginTimeout() { return this.loginTimeout; } public void setLoginTimeout(Duration loginTimeout) { this.loginTimeout = loginTimeout; } } import org.springframework.boot.context.properties.ConfigurationProperties import java.time.Duration @ConfigurationProperties(""acme"") class AcmeProperties( /** * Whether to check the location of acme resources. */ var isCheckLocation: Boolean = true, /** * Timeout for establishing a connection to the acme server. */ var loginTimeout:Duration = Duration.ofSeconds(3)) You should only use plain text with @ConfigurationProperties field Javadoc, since they are not processed before being added to the JSON. If you use @ConfigurationProperties with record class then record components' descriptions should be provided via class-level Javadoc tag @param (there are no explicit instance fields in record classes to put regular field-level Javadocs on). Here are some rules we follow internally to make sure descriptions are consistent: Do not start the description by ""The"" or ""A"". For boolean types, start the description with ""Whether"" or ""Enable"". For collection-based types, start the description with ""Comma-separated list"" Use java.time.Duration rather than long and describe the default unit if it differs from milliseconds, such as ""If a duration suffix is not specified, seconds will be used"". Do not provide the default value in the description unless it has to be determined at runtime. Make sure to trigger meta-data generation(../../specification/configuration-metadata/annotation-processor.html) so that IDE assistance is available for your keys as well. You may want to review the generated metadata ( META-INF/spring-configuration-metadata.json ) to make sure your keys are properly documented. Using your own starter in a compatible IDE is also a good idea to validate that quality of the metadata. The “autoconfigure” Module: The autoconfigure module contains everything that is necessary to get started with the library. It may also contain configuration key definitions (such as @ConfigurationProperties ) and any callback interface that can be used to further customize how the components are initialized. You should mark the dependencies to the library as optional so that you can include the autoconfigure module in your projects more easily. If you do it that way, the library is not provided and, by default, Spring Boot backs off. Spring Boot uses an annotation processor to collect the conditions on auto-configurations in a metadata file ( META-INF/spring-autoconfigure-metadata.properties ). If that file is present, it is used to eagerly filter auto-configurations that do not match, which will improve startup time. When building with Maven, it is recommended to add the following dependency in a module that contains auto-configurations: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-autoconfigure-processor</artifactId> <optional>true</optional> </dependency> If you have defined auto-configurations directly in your application, make sure to configure the spring-boot-maven-plugin to prevent the repackage goal from adding the dependency into the uber jar: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <excludes> <exclude> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-autoconfigure-processor</artifactId> </exclude> </excludes> </configuration> </plugin> </plugins> </build> </project> With Gradle, the dependency should be declared in the annotationProcessor configuration, as shown in the following example: dependencies { annotationProcessor ""org.springframework.boot:spring-boot-autoconfigure-processor"" } Starter Module: The starter is really an empty jar. Its only purpose is to provide the necessary dependencies to work with the library. You can think of it as an opinionated view of what is required to get started. Do not make assumptions about the project in which your starter is added. If the library you are auto-configuring typically requires other starters, mention them as well. Providing a proper set of default dependencies may be hard if the number of optional dependencies is high, as you should avoid including dependencies that are unnecessary for a typical usage of the library. In other words, you should not include optional dependencies. Either way, your starter must reference the core Spring Boot starter ( spring-boot-starter ) directly or indirectly (there is no need to add it if your starter relies on another starter). If a project is created with only your custom starter, Spring Boot’s core features will be honoured by the presence of the core starter."
"https://docs.spring.io/spring-boot/reference/features/kotlin.html","Kotlin Support: Kotlin(https://kotlinlang.org) is a statically-typed language targeting the JVM (and other platforms) which allows writing concise and elegant code while providing interoperability(https://kotlinlang.org/docs/reference/java-interop.html) with existing libraries written in Java. Spring Boot provides Kotlin support by leveraging the support in other Spring projects such as Spring Framework, Spring Data, and Reactor. See the Spring Framework Kotlin support documentation(https://docs.spring.io/spring-framework/reference/6.1/languages/kotlin.html) for more information. The easiest way to start with Spring Boot and Kotlin is to follow this comprehensive tutorial(https://spring.io/guides/tutorials/spring-boot-kotlin/) . You can create new Kotlin projects by using start.spring.io(https://start.spring.io/#!language=kotlin) . Feel free to join the #spring channel of Kotlin Slack(https://slack.kotlinlang.org/) or ask a question with the spring and kotlin tags on Stack Overflow(https://stackoverflow.com/questions/tagged/spring+kotlin) if you need support. Requirements: Spring Boot requires at least Kotlin 1.7.x and manages a suitable Kotlin version through dependency management. To use Kotlin, org.jetbrains.kotlin:kotlin-stdlib and org.jetbrains.kotlin:kotlin-reflect must be present on the classpath. The kotlin-stdlib variants kotlin-stdlib-jdk7 and kotlin-stdlib-jdk8 can also be used. Since Kotlin classes are final by default(https://discuss.kotlinlang.org/t/classes-final-by-default/166) , you are likely to want to configure kotlin-spring(https://kotlinlang.org/docs/reference/compiler-plugins.html#spring-support) plugin in order to automatically open Spring-annotated classes so that they can be proxied. Jackson’s Kotlin module(https://github.com/FasterXML/jackson-module-kotlin) is required for serializing / deserializing JSON data in Kotlin. It is automatically registered when found on the classpath. A warning message is logged if Jackson and Kotlin are present but the Jackson Kotlin module is not. These dependencies and plugins are provided by default if one bootstraps a Kotlin project on start.spring.io(https://start.spring.io/#!language=kotlin) . Null-safety: One of Kotlin’s key features is null-safety(https://kotlinlang.org/docs/reference/null-safety.html) . It deals with null values at compile time rather than deferring the problem to runtime and encountering a NullPointerException . This helps to eliminate a common source of bugs without paying the cost of wrappers like Optional . Kotlin also allows using functional constructs with nullable values as described in this comprehensive guide to null-safety in Kotlin(https://www.baeldung.com/kotlin-null-safety) . Although Java does not allow one to express null-safety in its type system, Spring Framework, Spring Data, and Reactor now provide null-safety of their API through tooling-friendly annotations. By default, types from Java APIs used in Kotlin are recognized as platform types(https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types) for which null-checks are relaxed. Kotlin’s support for JSR 305 annotations(https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support) combined with nullability annotations provide null-safety for the related Spring API in Kotlin. The JSR 305 checks can be configured by adding the -Xjsr305 compiler flag with the following options: -Xjsr305={strict|warn|ignore} . The default behavior is the same as -Xjsr305=warn . The strict value is required to have null-safety taken in account in Kotlin types inferred from Spring API but should be used with the knowledge that Spring API nullability declaration could evolve even between minor releases and more checks may be added in the future). Generic type arguments, varargs and array elements nullability are not yet supported. See SPR-15942(https://jira.spring.io/browse/SPR-15942) for up-to-date information. Also be aware that Spring Boot’s own API is not yet annotated(https://github.com/spring-projects/spring-boot/issues/10712) . Kotlin API: runApplication: Spring Boot provides an idiomatic way to run an application with runApplication<MyApplication>(*args) as shown in the following example: import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication @SpringBootApplication class MyApplication fun main(args: Array<String>) { runApplication<MyApplication>(*args) } This is a drop-in replacement for SpringApplication.run(MyApplication::class.java, *args) . It also allows customization of the application as shown in the following example: runApplication<MyApplication>(*args) { setBannerMode(OFF) } Extensions: Kotlin extensions(https://kotlinlang.org/docs/reference/extensions.html) provide the ability to extend existing classes with additional functionality. The Spring Boot Kotlin API makes use of these extensions to add new Kotlin specific conveniences to existing APIs. TestRestTemplate extensions, similar to those provided by Spring Framework for RestOperations in Spring Framework, are provided. Among other things, the extensions make it possible to take advantage of Kotlin reified type parameters. Dependency Management: In order to avoid mixing different versions of Kotlin dependencies on the classpath, Spring Boot imports the Kotlin BOM. With Maven, the Kotlin version can be customized by setting the kotlin.version property and plugin management is provided for kotlin-maven-plugin . With Gradle, the Spring Boot plugin automatically aligns the kotlin.version with the version of the Kotlin plugin. Spring Boot also manages the version of Coroutines dependencies by importing the Kotlin Coroutines BOM. The version can be customized by setting the kotlin-coroutines.version property. org.jetbrains.kotlinx:kotlinx-coroutines-reactor dependency is provided by default if one bootstraps a Kotlin project with at least one reactive dependency on start.spring.io(https://start.spring.io/#!language=kotlin) . @ConfigurationProperties: @ConfigurationProperties when used in combination with constructor binding(external-config.html#features.external-config.typesafe-configuration-properties.constructor-binding) supports data classes with immutable val properties as shown in the following example: @ConfigurationProperties(""example.kotlin"") data class KotlinExampleProperties( val name: String, val description: String, val myService: MyService) { data class MyService( val apiToken: String, val uri: URI ) } Due to the limitations of their interoperability with Java, support for value classes is limited. In particular, relying upon a value class’s default value will not work with configuration property binding. In such cases, a data class should be used instead. To generate your own metadata(../../specification/configuration-metadata/annotation-processor.html) using the annotation processor, kapt should be configured(https://kotlinlang.org/docs/reference/kapt.html) with the spring-boot-configuration-processor dependency. Note that some features (such as detecting the default value or deprecated items) are not working due to limitations in the model kapt provides. Testing: While it is possible to use JUnit 4 to test Kotlin code, JUnit 5 is provided by default and is recommended. JUnit 5 enables a test class to be instantiated once and reused for all of the class’s tests. This makes it possible to use @BeforeAll and @AfterAll annotations on non-static methods, which is a good fit for Kotlin. To mock Kotlin classes, MockK(https://mockk.io/) is recommended. If you need the MockK equivalent of the Mockito specific @MockBean and @SpyBean annotations(../testing/spring-boot-applications.html#testing.spring-boot-applications.mocking-beans) , you can use SpringMockK(https://github.com/Ninja-Squad/springmockk) which provides similar @MockkBean and @SpykBean annotations. Resources: Further Reading: Kotlin language reference(https://kotlinlang.org/docs/reference) Kotlin Slack(https://kotlinlang.slack.com/) (with a dedicated #spring channel) Stack Overflow with spring and kotlin tags(https://stackoverflow.com/questions/tagged/spring+kotlin) Try Kotlin in your browser(https://try.kotlinlang.org/) Kotlin blog(https://blog.jetbrains.com/kotlin/) Awesome Kotlin(https://kotlin.link/) Tutorial: building web applications with Spring Boot and Kotlin(https://spring.io/guides/tutorials/spring-boot-kotlin/) Developing Spring Boot applications with Kotlin(https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin) A Geospatial Messenger with Kotlin, Spring Boot and PostgreSQL(https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql) Introducing Kotlin support in Spring Framework 5.0(https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0) Spring Framework 5 Kotlin APIs, the functional way(https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way) Examples: spring-boot-kotlin-demo(https://github.com/sdeleuze/spring-boot-kotlin-demo) : regular Spring Boot + Spring Data JPA project mixit(https://github.com/mixitconf/mixit) : Spring Boot 2 + WebFlux + Reactive Spring Data MongoDB spring-kotlin-fullstack(https://github.com/sdeleuze/spring-kotlin-fullstack) : WebFlux Kotlin fullstack example with Kotlin2js for frontend instead of JavaScript or TypeScript spring-petclinic-kotlin(https://github.com/spring-petclinic/spring-petclinic-kotlin) : Kotlin version of the Spring PetClinic Sample Application spring-kotlin-deepdive(https://github.com/sdeleuze/spring-kotlin-deepdive) : a step by step migration for Boot 1.0 + Java to Boot 2.0 + Kotlin spring-boot-coroutines-demo(https://github.com/sdeleuze/spring-boot-coroutines-demo) : Coroutines sample project"
"https://docs.spring.io/spring-boot/reference/features/ssl.html","SSL: Spring Boot provides the ability to configure SSL trust material that can be applied to several types of connections in order to support secure communications. Configuration properties with the prefix spring.ssl.bundle can be used to specify named sets of trust material and associated information. Configuring SSL With Java KeyStore Files: Configuration properties with the prefix spring.ssl.bundle.jks can be used to configure bundles of trust material created with the Java keytool utility and stored in Java KeyStore files in the JKS or PKCS12 format. Each bundle has a user-provided name that can be used to reference the bundle. When used to secure an embedded web server, a keystore is typically configured with a Java KeyStore containing a certificate and private key as shown in this example: Properties YAML spring.ssl.bundle.jks.mybundle.key.alias=application spring.ssl.bundle.jks.mybundle.keystore.location=classpath:application.p12 spring.ssl.bundle.jks.mybundle.keystore.password=secret spring.ssl.bundle.jks.mybundle.keystore.type=PKCS12 spring: ssl: bundle: jks: mybundle: key: alias: ""application"" keystore: location: ""classpath:application.p12"" password: ""secret"" type: ""PKCS12"" When used to secure a client-side connection, a truststore is typically configured with a Java KeyStore containing the server certificate as shown in this example: Properties YAML spring.ssl.bundle.jks.mybundle.truststore.location=classpath:server.p12 spring.ssl.bundle.jks.mybundle.truststore.password=secret spring: ssl: bundle: jks: mybundle: truststore: location: ""classpath:server.p12"" password: ""secret"" See JksSslBundleProperties(../../api/java/org/springframework/boot/autoconfigure/ssl/JksSslBundleProperties.html) for the full set of supported properties. Configuring SSL With PEM-encoded Certificates: Configuration properties with the prefix spring.ssl.bundle.pem can be used to configure bundles of trust material in the form of PEM-encoded text. Each bundle has a user-provided name that can be used to reference the bundle. When used to secure an embedded web server, a keystore is typically configured with a certificate and private key as shown in this example: Properties YAML spring.ssl.bundle.pem.mybundle.keystore.certificate=classpath:application.crt spring.ssl.bundle.pem.mybundle.keystore.private-key=classpath:application.key spring: ssl: bundle: pem: mybundle: keystore: certificate: ""classpath:application.crt"" private-key: ""classpath:application.key"" When used to secure a client-side connection, a truststore is typically configured with the server certificate as shown in this example: Properties YAML spring.ssl.bundle.pem.mybundle.truststore.certificate=classpath:server.crt spring: ssl: bundle: pem: mybundle: truststore: certificate: ""classpath:server.crt"" PEM content can be used directly for both the certificate and private-key properties. If the property values contain BEGIN and END markers then they will be treated as PEM content rather than a resource location. The following example shows how a truststore certificate can be defined: Properties YAML spring.ssl.bundle.pem.mybundle.truststore.certificate=-----BEGIN CERTIFICATE----- MIID1zCCAr+gAwIBAgIUNM5QQv8IzVQsgSmmdPQNaqyzWs4wDQYJKoZIhvcNAQEL BQAwezELMAkGA1UEBhMCWFgxEjAQBgNVBAgMCVN0YXRlTmFtZTERMA8GA1UEBwwI ... V0IJjcmYjEZbTvpjFKznvaFiOUv+8L7jHQ1/Yf+9c3C8gSjdUfv88m17pqYXd+Ds HEmfmNNjht130UyjNCITmLVXyy5p35vWmdf95U3uEbJSnNVtXH8qRmN9oK9mUpDb ngX6JBJI7fw7tXoqWSLHNiBODM88fUlQSho8 -----END CERTIFICATE----- spring: ssl: bundle: pem: mybundle: truststore: certificate: | -----BEGIN CERTIFICATE----- MIID1zCCAr+gAwIBAgIUNM5QQv8IzVQsgSmmdPQNaqyzWs4wDQYJKoZIhvcNAQEL BQAwezELMAkGA1UEBhMCWFgxEjAQBgNVBAgMCVN0YXRlTmFtZTERMA8GA1UEBwwI ... V0IJjcmYjEZbTvpjFKznvaFiOUv+8L7jHQ1/Yf+9c3C8gSjdUfv88m17pqYXd+Ds HEmfmNNjht130UyjNCITmLVXyy5p35vWmdf95U3uEbJSnNVtXH8qRmN9oK9mUpDb ngX6JBJI7fw7tXoqWSLHNiBODM88fUlQSho8 -----END CERTIFICATE----- See PemSslBundleProperties(../../api/java/org/springframework/boot/autoconfigure/ssl/PemSslBundleProperties.html) for the full set of supported properties. Applying SSL Bundles: Once configured using properties, SSL bundles can be referred to by name in configuration properties for various types of connections that are auto-configured by Spring Boot. See the sections on embedded web servers(../../how-to/webserver.html#howto.webserver.configure-ssl) , data technologies(../data/index.html) , and REST clients(../io/rest-client.html) for further information. Using SSL Bundles: Spring Boot auto-configures a bean of type SslBundles that provides access to each of the named bundles configured using the spring.ssl.bundle properties. An SslBundle can be retrieved from the auto-configured SslBundles bean and used to create objects that are used to configure SSL connectivity in client libraries. The SslBundle provides a layered approach of obtaining these SSL objects: getStores() provides access to the key store and trust store java.security.KeyStore instances as well as any required key store password. getManagers() provides access to the java.net.ssl.KeyManagerFactory and java.net.ssl.TrustManagerFactory instances as well as the java.net.ssl.KeyManager and java.net.ssl.TrustManager arrays that they create. createSslContext() provides a convenient way to obtain a new java.net.ssl.SSLContext instance. In addition, the SslBundle provides details about the key being used, the protocol to use and any option that should be applied to the SSL engine. The following example shows retrieving an SslBundle and using it to create an SSLContext : Java Kotlin import javax.net.ssl.SSLContext; import org.springframework.boot.ssl.SslBundle; import org.springframework.boot.ssl.SslBundles; import org.springframework.stereotype.Component; @Component public class MyComponent { public MyComponent(SslBundles sslBundles) { SslBundle sslBundle = sslBundles.getBundle(""mybundle""); SSLContext sslContext = sslBundle.createSslContext(); // do something with the created sslContext } } import org.springframework.boot.ssl.SslBundles import org.springframework.stereotype.Component @Component class MyComponent(sslBundles: SslBundles) { init { val sslBundle = sslBundles.getBundle(""mybundle"") val sslContext = sslBundle.createSslContext() // do something with the created sslContext } } Reloading SSL bundles: SSL bundles can be reloaded when the key material changes. The component consuming the bundle has to be compatible with reloadable SSL bundles. Currently the following components are compatible: Tomcat web server Netty web server To enable reloading, you need to opt-in via a configuration property as shown in this example: Properties YAML spring.ssl.bundle.pem.mybundle.reload-on-update=true spring.ssl.bundle.pem.mybundle.keystore.certificate=file:/some/directory/application.crt spring.ssl.bundle.pem.mybundle.keystore.private-key=file:/some/directory/application.key spring: ssl: bundle: pem: mybundle: reload-on-update: true keystore: certificate: ""file:/some/directory/application.crt"" private-key: ""file:/some/directory/application.key"" A file watcher is then watching the files and if they change, the SSL bundle will be reloaded. This in turn triggers a reload in the consuming component, e.g. Tomcat rotates the certificates in the SSL enabled connectors. You can configure the quiet period (to make sure that there are no more changes) of the file watcher with the spring.ssl.bundle.watch.file.quiet-period property."
"https://docs.spring.io/spring-boot/reference/web/index.html","Web: Spring Boot is well suited for web application development. You can create a self-contained HTTP server by using embedded Tomcat, Jetty, Undertow, or Netty. Most web applications use the spring-boot-starter-web module to get up and running quickly. You can also choose to build reactive web applications by using the spring-boot-starter-webflux module. If you have not yet developed a Spring Boot web application, you can follow the “Hello World!” example in the Getting started(../../tutorial/first-application/index.html) section."
"https://docs.spring.io/spring-boot/reference/web/servlet.html","Servlet Web Applications: If you want to build servlet-based web applications, you can take advantage of Spring Boot’s auto-configuration for Spring MVC or Jersey. The “Spring Web MVC Framework”: The Spring Web MVC framework(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc.html) (often referred to as “Spring MVC”) is a rich “model view controller” web framework. Spring MVC lets you create special @Controller or @RestController beans to handle incoming HTTP requests. Methods in your controller are mapped to HTTP by using @RequestMapping annotations. The following code shows a typical @RestController that serves JSON data: Java Kotlin import java.util.List; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(""/users"") public class MyRestController { private final UserRepository userRepository; private final CustomerRepository customerRepository; public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) { this.userRepository = userRepository; this.customerRepository = customerRepository; } @GetMapping(""/{userId}"") public User getUser(@PathVariable Long userId) { return this.userRepository.findById(userId).get(); } @GetMapping(""/{userId}/customers"") public List<Customer> getUserCustomers(@PathVariable Long userId) { return this.userRepository.findById(userId).map(this.customerRepository::findByUser).get(); } @DeleteMapping(""/{userId}"") public void deleteUser(@PathVariable Long userId) { this.userRepository.deleteById(userId); } } import org.springframework.web.bind.annotation.DeleteMapping import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.PathVariable import org.springframework.web.bind.annotation.RequestMapping import org.springframework.web.bind.annotation.RestController @RestController @RequestMapping(""/users"") class MyRestController(private val userRepository: UserRepository, private val customerRepository: CustomerRepository) { @GetMapping(""/{userId}"") fun getUser(@PathVariable userId: Long): User { return userRepository.findById(userId).get() } @GetMapping(""/{userId}/customers"") fun getUserCustomers(@PathVariable userId: Long): List<Customer> { return userRepository.findById(userId).map(customerRepository::findByUser).get() } @DeleteMapping(""/{userId}"") fun deleteUser(@PathVariable userId: Long) { userRepository.deleteById(userId) } } “WebMvc.fn”, the functional variant, separates the routing configuration from the actual handling of the requests, as shown in the following example: Java Kotlin import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.MediaType; import org.springframework.web.servlet.function.RequestPredicate; import org.springframework.web.servlet.function.RouterFunction; import org.springframework.web.servlet.function.ServerResponse; import static org.springframework.web.servlet.function.RequestPredicates.accept; import static org.springframework.web.servlet.function.RouterFunctions.route; @Configuration(proxyBeanMethods = false) public class MyRoutingConfiguration { private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON); @Bean public RouterFunction<ServerResponse> routerFunction(MyUserHandler userHandler) { return route() .GET(""/{user}"", ACCEPT_JSON, userHandler::getUser) .GET(""/{user}/customers"", ACCEPT_JSON, userHandler::getUserCustomers) .DELETE(""/{user}"", ACCEPT_JSON, userHandler::deleteUser) .build(); } } import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.http.MediaType import org.springframework.web.servlet.function.RequestPredicates.accept import org.springframework.web.servlet.function.RouterFunction import org.springframework.web.servlet.function.RouterFunctions import org.springframework.web.servlet.function.ServerResponse @Configuration(proxyBeanMethods = false) class MyRoutingConfiguration { @Bean fun routerFunction(userHandler: MyUserHandler): RouterFunction<ServerResponse> { return RouterFunctions.route() .GET(""/{user}"", ACCEPT_JSON, userHandler::getUser) .GET(""/{user}/customers"", ACCEPT_JSON, userHandler::getUserCustomers) .DELETE(""/{user}"", ACCEPT_JSON, userHandler::deleteUser) .build() } companion object { private val ACCEPT_JSON = accept(MediaType.APPLICATION_JSON) } } Java Kotlin import org.springframework.stereotype.Component; import org.springframework.web.servlet.function.ServerRequest; import org.springframework.web.servlet.function.ServerResponse; @Component public class MyUserHandler { public ServerResponse getUser(ServerRequest request) { ... } public ServerResponse getUserCustomers(ServerRequest request) { ... } public ServerResponse deleteUser(ServerRequest request) { ... } } import org.springframework.stereotype.Component import org.springframework.web.servlet.function.ServerRequest import org.springframework.web.servlet.function.ServerResponse @Component class MyUserHandler { fun getUser(request: ServerRequest?): ServerResponse { ... } fun getUserCustomers(request: ServerRequest?): ServerResponse { ... } fun deleteUser(request: ServerRequest?): ServerResponse { ... } } Spring MVC is part of the core Spring Framework, and detailed information is available in the reference documentation(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc.html) . There are also several guides that cover Spring MVC available at spring.io/guides(https://spring.io/guides) . You can define as many RouterFunction beans as you like to modularize the definition of the router. Beans can be ordered if you need to apply a precedence. Spring MVC Auto-configuration: Spring Boot provides auto-configuration for Spring MVC that works well with most applications. It replaces the need for @EnableWebMvc and the two cannot be used together. In addition to Spring MVC’s defaults, the auto-configuration provides the following features: Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. Support for serving static resources, including support for WebJars (covered later in this document(#web.servlet.spring-mvc.static-content) ). Automatic registration of Converter , GenericConverter , and Formatter beans. Support for HttpMessageConverters (covered later in this document(#web.servlet.spring-mvc.message-converters) ). Automatic registration of MessageCodesResolver (covered later in this document(#web.servlet.spring-mvc.message-codes) ). Static index.html support. Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document(#web.servlet.spring-mvc.binding-initializer) ). If you want to keep those Spring Boot MVC customizations and make more MVC customizations(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc.html) (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc . If you want to provide custom instances of RequestMappingHandlerMapping , RequestMappingHandlerAdapter , or ExceptionHandlerExceptionResolver , and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components. The custom instances will be subject to further initialization and configuration by Spring MVC. To participate in, and if desired, override that subsequent processing, a WebMvcConfigurer should be used. If you do not want to use the auto-configuration and want to take complete control of Spring MVC, add your own @Configuration annotated with @EnableWebMvc . Alternatively, add your own @Configuration -annotated DelegatingWebMvcConfiguration as described in the @EnableWebMvc API documentation. Spring MVC Conversion Service: Spring MVC uses a different ConversionService to the one used to convert values from your application.properties or application.yaml file. It means that Period , Duration and DataSize converters are not available and that @DurationUnit and @DataSizeUnit annotations will be ignored. If you want to customize the ConversionService used by Spring MVC, you can provide a WebMvcConfigurer bean with an addFormatters method. From this method you can register any converter that you like, or you can delegate to the static methods available on ApplicationConversionService . Conversion can also be customized using the spring.mvc.format.* configuration properties. When not configured, the following defaults are used: Property DateTimeFormatter Formats spring.mvc.format.date ofLocalizedDate(FormatStyle.SHORT) java.util.Date and java.time.LocalDate spring.mvc.format.time ofLocalizedTime(FormatStyle.SHORT) java.time’s LocalTime and OffsetTime spring.mvc.format.date-time ofLocalizedDateTime(FormatStyle.SHORT) java.time’s LocalDateTime , OffsetDateTime , and ZonedDateTime HttpMessageConverters: Spring MVC uses the HttpMessageConverter interface to convert HTTP requests and responses. Sensible defaults are included out of the box. For example, objects can be automatically converted to JSON (by using the Jackson library) or XML (by using the Jackson XML extension, if available, or by using JAXB if the Jackson XML extension is not available). By default, strings are encoded in UTF-8 . Any HttpMessageConverter bean that is present in the context is added to the list of converters. You can also override default converters in the same way. If you need to add or customize converters, you can use Spring Boot’s HttpMessageConverters class, as shown in the following listing: Java Kotlin import org.springframework.boot.autoconfigure.http.HttpMessageConverters; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.converter.HttpMessageConverter; @Configuration(proxyBeanMethods = false) public class MyHttpMessageConvertersConfiguration { @Bean public HttpMessageConverters customConverters() { HttpMessageConverter<?> additional = new AdditionalHttpMessageConverter(); HttpMessageConverter<?> another = new AnotherHttpMessageConverter(); return new HttpMessageConverters(additional, another); } } import org.springframework.boot.autoconfigure.http.HttpMessageConverters import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.http.converter.HttpMessageConverter @Configuration(proxyBeanMethods = false) class MyHttpMessageConvertersConfiguration { @Bean fun customConverters(): HttpMessageConverters { val additional: HttpMessageConverter<*> = AdditionalHttpMessageConverter() val another: HttpMessageConverter<*> = AnotherHttpMessageConverter() return HttpMessageConverters(additional, another) } } For further control, you can also sub-class HttpMessageConverters and override its postProcessConverters and/or postProcessPartConverters methods. This can be useful when you want to re-order or remove some of the converters that Spring MVC configures by default. MessageCodesResolver: Spring MVC has a strategy for generating error codes for rendering error messages from binding errors: MessageCodesResolver . If you set the spring.mvc.message-codes-resolver-format property PREFIX_ERROR_CODE or POSTFIX_ERROR_CODE , Spring Boot creates one for you (see the enumeration in DefaultMessageCodesResolver.Format(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html#Format) ). Static Content: By default, Spring Boot serves static content from a directory called /static (or /public or /resources or /META-INF/resources ) in the classpath or from the root of the ServletContext . It uses the ResourceHttpRequestHandler from Spring MVC so that you can modify that behavior by adding your own WebMvcConfigurer and overriding the addResourceHandlers method. In a stand-alone web application, the default servlet from the container is not enabled. It can be enabled using the server.servlet.register-default-servlet property. The default servlet acts as a fallback, serving content from the root of the ServletContext if Spring decides not to handle it. Most of the time, this does not happen (unless you modify the default MVC configuration), because Spring can always handle requests through the DispatcherServlet . By default, resources are mapped on /** , but you can tune that with the spring.mvc.static-path-pattern property. For instance, relocating all resources to /resources/** can be achieved as follows: Properties YAML spring.mvc.static-path-pattern=/resources/** spring: mvc: static-path-pattern: ""/resources/**"" You can also customize the static resource locations by using the spring.web.resources.static-locations property (replacing the default values with a list of directory locations). The root servlet context path, ""/"" , is automatically added as a location as well. In addition to the “standard” static resource locations mentioned earlier, a special case is made for Webjars content(https://www.webjars.org/) . By default, any resources with a path in /webjars/** are served from jar files if they are packaged in the Webjars format. The path can be customized with the spring.mvc.webjars-path-pattern property. Do not use the src/main/webapp directory if your application is packaged as a jar. Although this directory is a common standard, it works only with war packaging, and it is silently ignored by most build tools if you generate a jar. Spring Boot also supports the advanced resource handling features provided by Spring MVC, allowing use cases such as cache-busting static resources or using version agnostic URLs for Webjars. To use version agnostic URLs for Webjars, add the webjars-locator-core dependency. Then declare your Webjar. Using jQuery as an example, adding ""/webjars/jquery/jquery.min.js"" results in ""/webjars/jquery/x.y.z/jquery.min.js"" where x.y.z is the Webjar version. If you use JBoss, you need to declare the webjars-locator-jboss-vfs dependency instead of the webjars-locator-core . Otherwise, all Webjars resolve as a 404 . To use cache busting, the following configuration configures a cache busting solution for all static resources, effectively adding a content hash, such as <link href=""/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css""/> , in URLs: Properties YAML spring.web.resources.chain.strategy.content.enabled=true spring.web.resources.chain.strategy.content.paths=/** spring: web: resources: chain: strategy: content: enabled: true paths: ""/**"" Links to resources are rewritten in templates at runtime, thanks to a ResourceUrlEncodingFilter that is auto-configured for Thymeleaf and FreeMarker. You should manually declare this filter when using JSPs. Other template engines are currently not automatically supported but can be with custom template macros/helpers and the use of the ResourceUrlProvider(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html) . When loading resources dynamically with, for example, a JavaScript module loader, renaming files is not an option. That is why other strategies are also supported and can be combined. A ""fixed"" strategy adds a static version string in the URL without changing the file name, as shown in the following example: Properties YAML spring.web.resources.chain.strategy.content.enabled=true spring.web.resources.chain.strategy.content.paths=/** spring.web.resources.chain.strategy.fixed.enabled=true spring.web.resources.chain.strategy.fixed.paths=/js/lib/ spring.web.resources.chain.strategy.fixed.version=v12 spring: web: resources: chain: strategy: content: enabled: true paths: ""/**"" fixed: enabled: true paths: ""/js/lib/"" version: ""v12"" With this configuration, JavaScript modules located under ""/js/lib/"" use a fixed versioning strategy ( ""/v12/js/lib/mymodule.js"" ), while other resources still use the content one ( <link href=""/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css""/> ). See WebProperties.Resources(../../api/java/org/springframework/boot/autoconfigure/web/WebProperties.Resources.html) for more supported options. This feature has been thoroughly described in a dedicated blog post(https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources) and in Spring Framework’s reference documentation(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc/mvc-config/static-resources.html) . Welcome Page: Spring Boot supports both static and templated welcome pages. It first looks for an index.html file in the configured static content locations. If one is not found, it then looks for an index template. If either is found, it is automatically used as the welcome page of the application. This only acts as a fallback for actual index routes defined by the application. The ordering is defined by the order of HandlerMapping beans which is by default the following: RouterFunctionMapping Endpoints declared with RouterFunction beans RequestMappingHandlerMapping Endpoints declared in @Controller beans WelcomePageHandlerMapping The welcome page support Custom Favicon: As with other static resources, Spring Boot checks for a favicon.ico in the configured static content locations. If such a file is present, it is automatically used as the favicon of the application. Path Matching and Content Negotiation: Spring MVC can map incoming HTTP requests to handlers by looking at the request path and matching it to the mappings defined in your application (for example, @GetMapping annotations on Controller methods). Spring Boot chooses to disable suffix pattern matching by default, which means that requests like ""GET /projects/spring-boot.json"" will not be matched to @GetMapping(""/projects/spring-boot"") mappings. This is considered as a best practice for Spring MVC applications(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc/mvc-controller/ann-requestmapping.html#mvc-ann-requestmapping-suffix-pattern-match) . This feature was mainly useful in the past for HTTP clients which did not send proper ""Accept"" request headers; we needed to make sure to send the correct Content Type to the client. Nowadays, Content Negotiation is much more reliable. There are other ways to deal with HTTP clients that do not consistently send proper ""Accept"" request headers. Instead of using suffix matching, we can use a query parameter to ensure that requests like ""GET /projects/spring-boot?format=json"" will be mapped to @GetMapping(""/projects/spring-boot"") : Properties YAML spring.mvc.contentnegotiation.favor-parameter=true spring: mvc: contentnegotiation: favor-parameter: true Or if you prefer to use a different parameter name: Properties YAML spring.mvc.contentnegotiation.favor-parameter=true spring.mvc.contentnegotiation.parameter-name=myparam spring: mvc: contentnegotiation: favor-parameter: true parameter-name: ""myparam"" Most standard media types are supported out-of-the-box, but you can also define new ones: Properties YAML spring.mvc.contentnegotiation.media-types.markdown=text/markdown spring: mvc: contentnegotiation: media-types: markdown: ""text/markdown"" As of Spring Framework 5.3, Spring MVC supports two strategies for matching request paths to controllers. By default, Spring Boot uses the PathPatternParser strategy. PathPatternParser is an optimized implementation(https://spring.io/blog/2020/06/30/url-matching-with-pathpattern-in-spring-mvc) but comes with some restrictions compared to the AntPathMatcher strategy. PathPatternParser restricts usage of some path pattern variants(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc/mvc-controller/ann-requestmapping.html#mvc-ann-requestmapping-uri-templates) . It is also incompatible with configuring the DispatcherServlet with a path prefix ( spring.mvc.servlet.path ). The strategy can be configured using the spring.mvc.pathmatch.matching-strategy configuration property, as shown in the following example: Properties YAML spring.mvc.pathmatch.matching-strategy=ant-path-matcher spring: mvc: pathmatch: matching-strategy: ""ant-path-matcher"" Spring MVC will throw a NoHandlerFoundException if a handler is not found for a request. Note that, by default, the serving of static content(#web.servlet.spring-mvc.static-content) is mapped to /** and will, therefore, provide a handler for all requests. If no static content is available, ResourceHttpRequestHandler will throw a NoResourceFoundException . For a NoHandlerFoundException to be thrown, set spring.mvc.static-path-pattern to a more specific value such as /resources/** or set spring.web.resources.add-mappings to false to disable serving of static content entirely. ConfigurableWebBindingInitializer: Spring MVC uses a WebBindingInitializer to initialize a WebDataBinder for a particular request. If you create your own ConfigurableWebBindingInitializer @Bean , Spring Boot automatically configures Spring MVC to use it. Template Engines: As well as REST web services, you can also use Spring MVC to serve dynamic HTML content. Spring MVC supports a variety of templating technologies, including Thymeleaf, FreeMarker, and JSPs. Also, many other templating engines include their own Spring MVC integrations. Spring Boot includes auto-configuration support for the following templating engines: FreeMarker(https://freemarker.apache.org/docs/) Groovy(https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine) Thymeleaf(https://www.thymeleaf.org) Mustache(https://mustache.github.io/) If possible, JSPs should be avoided. There are several known limitations(#web.servlet.embedded-container.jsp-limitations) when using them with embedded servlet containers. When you use one of these templating engines with the default configuration, your templates are picked up automatically from src/main/resources/templates . Depending on how you run your application, your IDE may order the classpath differently. Running your application in the IDE from its main method results in a different ordering than when you run your application by using Maven or Gradle or from its packaged jar. This can cause Spring Boot to fail to find the expected template. If you have this problem, you can reorder the classpath in the IDE to place the module’s classes and resources first. Error Handling: By default, Spring Boot provides an /error mapping that handles all errors in a sensible way, and it is registered as a “global” error page in the servlet container. For machine clients, it produces a JSON response with details of the error, the HTTP status, and the exception message. For browser clients, there is a “whitelabel” error view that renders the same data in HTML format (to customize it, add a View that resolves to error ). There are a number of server.error properties that can be set if you want to customize the default error handling behavior. See the Server Properties(../../appendix/application-properties/index.html#appendix.application-properties.server) section of the Appendix. To replace the default behavior completely, you can implement ErrorController and register a bean definition of that type or add a bean of type ErrorAttributes to use the existing mechanism but replace the contents. The BasicErrorController can be used as a base class for a custom ErrorController . This is particularly useful if you want to add a handler for a new content type (the default is to handle text/html specifically and provide a fallback for everything else). To do so, extend BasicErrorController , add a public method with a @RequestMapping that has a produces attribute, and create a bean of your new type. As of Spring Framework 6.0, RFC 9457 Problem Details(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc/mvc-ann-rest-exceptions.html) is supported. Spring MVC can produce custom error messages with the application/problem+json media type, like: { ""type"": ""https://example.org/problems/unknown-project"", ""title"": ""Unknown project"", ""status"": 404, ""detail"": ""No project found for id 'spring-unknown'"", ""instance"": ""/projects/spring-unknown"" } This support can be enabled by setting spring.mvc.problemdetails.enabled to true . You can also define a class annotated with @ControllerAdvice to customize the JSON document to return for a particular controller and/or exception type, as shown in the following example: Java Kotlin import jakarta.servlet.RequestDispatcher; import jakarta.servlet.http.HttpServletRequest; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler; @ControllerAdvice(basePackageClasses = SomeController.class) public class MyControllerAdvice extends ResponseEntityExceptionHandler { @ResponseBody @ExceptionHandler(MyException.class) public ResponseEntity<?> handleControllerException(HttpServletRequest request, Throwable ex) { HttpStatus status = getStatus(request); return new ResponseEntity<>(new MyErrorBody(status.value(), ex.getMessage()), status); } private HttpStatus getStatus(HttpServletRequest request) { Integer code = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE); HttpStatus status = HttpStatus.resolve(code); return (status != null) ? status : HttpStatus.INTERNAL_SERVER_ERROR; } } import jakarta.servlet.RequestDispatcher import jakarta.servlet.http.HttpServletRequest import org.springframework.http.HttpStatus import org.springframework.http.ResponseEntity import org.springframework.web.bind.annotation.ControllerAdvice import org.springframework.web.bind.annotation.ExceptionHandler import org.springframework.web.bind.annotation.ResponseBody import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler @ControllerAdvice(basePackageClasses = [SomeController::class]) class MyControllerAdvice : ResponseEntityExceptionHandler() { @ResponseBody @ExceptionHandler(MyException::class) fun handleControllerException(request: HttpServletRequest, ex: Throwable): ResponseEntity<*> { val status = getStatus(request) return ResponseEntity(MyErrorBody(status.value(), ex.message), status) } private fun getStatus(request: HttpServletRequest): HttpStatus { val code = request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE) as Int val status = HttpStatus.resolve(code) return status ?: HttpStatus.INTERNAL_SERVER_ERROR } } In the preceding example, if MyException is thrown by a controller defined in the same package as SomeController , a JSON representation of the MyErrorBody POJO is used instead of the ErrorAttributes representation. In some cases, errors handled at the controller level are not recorded by web observations or the metrics infrastructure(../actuator/metrics.html#actuator.metrics.supported.spring-mvc) . Applications can ensure that such exceptions are recorded with the observations by setting the handled exception on the observation context(https://docs.spring.io/spring-framework/reference/6.1/integration/observability.html#observability.http-server.servlet) . Custom Error Pages: If you want to display a custom HTML error page for a given status code, you can add a file to an /error directory. Error pages can either be static HTML (that is, added under any of the static resource directories) or be built by using templates. The name of the file should be the exact status code or a series mask. For example, to map 404 to a static HTML file, your directory structure would be as follows: src/ +- main/ +- java/ | + <source code> +- resources/ +- public/ +- error/ | +- 404.html +- <other public assets> To map all 5xx errors by using a FreeMarker template, your directory structure would be as follows: src/ +- main/ +- java/ | + <source code> +- resources/ +- templates/ +- error/ | +- 5xx.ftlh +- <other templates> For more complex mappings, you can also add beans that implement the ErrorViewResolver interface, as shown in the following example: Java Kotlin import java.util.Map; import jakarta.servlet.http.HttpServletRequest; import org.springframework.boot.autoconfigure.web.servlet.error.ErrorViewResolver; import org.springframework.http.HttpStatus; import org.springframework.web.servlet.ModelAndView; public class MyErrorViewResolver implements ErrorViewResolver { @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map<String, Object> model) { // Use the request or status to optionally return a ModelAndView if (status == HttpStatus.INSUFFICIENT_STORAGE) { // We could add custom model values here new ModelAndView(""myview""); } return null; } } import jakarta.servlet.http.HttpServletRequest import org.springframework.boot.autoconfigure.web.servlet.error.ErrorViewResolver import org.springframework.http.HttpStatus import org.springframework.web.servlet.ModelAndView class MyErrorViewResolver : ErrorViewResolver { override fun resolveErrorView(request: HttpServletRequest, status: HttpStatus, model: Map<String, Any>): ModelAndView? { // Use the request or status to optionally return a ModelAndView if (status == HttpStatus.INSUFFICIENT_STORAGE) { // We could add custom model values here return ModelAndView(""myview"") } return null } } You can also use regular Spring MVC features such as @ExceptionHandler methods(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc/mvc-servlet/exceptionhandlers.html) and @ControllerAdvice(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc/mvc-controller/ann-advice.html) . The ErrorController then picks up any unhandled exceptions. Mapping Error Pages Outside of Spring MVC: For applications that do not use Spring MVC, you can use the ErrorPageRegistrar interface to directly register ErrorPages . This abstraction works directly with the underlying embedded servlet container and works even if you do not have a Spring MVC DispatcherServlet . Java Kotlin import org.springframework.boot.web.server.ErrorPage; import org.springframework.boot.web.server.ErrorPageRegistrar; import org.springframework.boot.web.server.ErrorPageRegistry; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.HttpStatus; @Configuration(proxyBeanMethods = false) public class MyErrorPagesConfiguration { @Bean public ErrorPageRegistrar errorPageRegistrar() { return this::registerErrorPages; } private void registerErrorPages(ErrorPageRegistry registry) { registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, ""/400"")); } } import org.springframework.boot.web.server.ErrorPage import org.springframework.boot.web.server.ErrorPageRegistrar import org.springframework.boot.web.server.ErrorPageRegistry import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.http.HttpStatus @Configuration(proxyBeanMethods = false) class MyErrorPagesConfiguration { @Bean fun errorPageRegistrar(): ErrorPageRegistrar { return ErrorPageRegistrar { registry: ErrorPageRegistry -> registerErrorPages(registry) } } private fun registerErrorPages(registry: ErrorPageRegistry) { registry.addErrorPages(ErrorPage(HttpStatus.BAD_REQUEST, ""/400"")) } } If you register an ErrorPage with a path that ends up being handled by a Filter (as is common with some non-Spring web frameworks, like Jersey and Wicket), then the Filter has to be explicitly registered as an ERROR dispatcher, as shown in the following example: Java Kotlin import java.util.EnumSet; import jakarta.servlet.DispatcherType; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyFilterConfiguration { @Bean public FilterRegistrationBean<MyFilter> myFilter() { FilterRegistrationBean<MyFilter> registration = new FilterRegistrationBean<>(new MyFilter()); // ... registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class)); return registration; } } import jakarta.servlet.DispatcherType import org.springframework.boot.web.servlet.FilterRegistrationBean import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import java.util.EnumSet @Configuration(proxyBeanMethods = false) class MyFilterConfiguration { @Bean fun myFilter(): FilterRegistrationBean<MyFilter> { val registration = FilterRegistrationBean(MyFilter()) // ... registration.setDispatcherTypes(EnumSet.allOf(DispatcherType::class.java)) return registration } } Note that the default FilterRegistrationBean does not include the ERROR dispatcher type. Error Handling in a WAR Deployment: When deployed to a servlet container, Spring Boot uses its error page filter to forward a request with an error status to the appropriate error page. This is necessary as the servlet specification does not provide an API for registering error pages. Depending on the container that you are deploying your war file to and the technologies that your application uses, some additional configuration may be required. The error page filter can only forward the request to the correct error page if the response has not already been committed. By default, WebSphere Application Server 8.0 and later commits the response upon successful completion of a servlet’s service method. You should disable this behavior by setting com.ibm.ws.webcontainer.invokeFlushAfterService to false . CORS Support: Cross-origin resource sharing(https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) (CORS) is a W3C specification(https://www.w3.org/TR/cors/) implemented by most browsers(https://caniuse.com/#feat=cors) that lets you specify in a flexible way what kind of cross-domain requests are authorized, instead of using some less secure and less powerful approaches such as IFRAME or JSONP. As of version 4.2, Spring MVC supports CORS(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc-cors.html) . Using controller method CORS configuration(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc-cors.html#mvc-cors-controller) with @CrossOrigin(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html) annotations in your Spring Boot application does not require any specific configuration. Global CORS configuration(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc-cors.html#mvc-cors-global) can be defined by registering a WebMvcConfigurer bean with a customized addCorsMappings(CorsRegistry) method, as shown in the following example: Java Kotlin import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration(proxyBeanMethods = false) public class MyCorsConfiguration { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurer() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(""/api/**""); } }; } } import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.web.servlet.config.annotation.CorsRegistry import org.springframework.web.servlet.config.annotation.WebMvcConfigurer @Configuration(proxyBeanMethods = false) class MyCorsConfiguration { @Bean fun corsConfigurer(): WebMvcConfigurer { return object : WebMvcConfigurer { override fun addCorsMappings(registry: CorsRegistry) { registry.addMapping(""/api/**"") } } } } JAX-RS and Jersey: If you prefer the JAX-RS programming model for REST endpoints, you can use one of the available implementations instead of Spring MVC. Jersey(https://jersey.github.io/) and Apache CXF(https://cxf.apache.org/) work quite well out of the box. CXF requires you to register its Servlet or Filter as a @Bean in your application context. Jersey has some native Spring support, so we also provide auto-configuration support for it in Spring Boot, together with a starter. To get started with Jersey, include the spring-boot-starter-jersey as a dependency and then you need one @Bean of type ResourceConfig in which you register all the endpoints, as shown in the following example: import org.glassfish.jersey.server.ResourceConfig; import org.springframework.stereotype.Component; @Component public class MyJerseyConfig extends ResourceConfig { public MyJerseyConfig() { register(MyEndpoint.class); } } Jersey’s support for scanning executable archives is rather limited. For example, it cannot scan for endpoints in a package found in a fully executable jar file(../../how-to/deployment/installing.html) or in WEB-INF/classes when running an executable war file. To avoid this limitation, the packages method should not be used, and endpoints should be registered individually by using the register method, as shown in the preceding example. For more advanced customizations, you can also register an arbitrary number of beans that implement ResourceConfigCustomizer . All the registered endpoints should be @Components with HTTP resource annotations ( @GET and others), as shown in the following example: import jakarta.ws.rs.GET; import jakarta.ws.rs.Path; import org.springframework.stereotype.Component; @Component @Path(""/hello"") public class MyEndpoint { @GET public String message() { return ""Hello""; } } Since the Endpoint is a Spring @Component , its lifecycle is managed by Spring and you can use the @Autowired annotation to inject dependencies and use the @Value annotation to inject external configuration. By default, the Jersey servlet is registered and mapped to /* . You can change the mapping by adding @ApplicationPath to your ResourceConfig . By default, Jersey is set up as a servlet in a @Bean of type ServletRegistrationBean named jerseyServletRegistration . By default, the servlet is initialized lazily, but you can customize that behavior by setting spring.jersey.servlet.load-on-startup . You can disable or override that bean by creating one of your own with the same name. You can also use a filter instead of a servlet by setting spring.jersey.type=filter (in which case, the @Bean to replace or override is jerseyFilterRegistration ). The filter has an @Order , which you can set with spring.jersey.filter.order . When using Jersey as a filter, a servlet that will handle any requests that are not intercepted by Jersey must be present. If your application does not contain such a servlet, you may want to enable the default servlet by setting server.servlet.register-default-servlet to true . Both the servlet and the filter registrations can be given init parameters by using spring.jersey.init.* to specify a map of properties. Embedded Servlet Container Support: For servlet application, Spring Boot includes support for embedded Tomcat(https://tomcat.apache.org/) , Jetty(https://www.eclipse.org/jetty/) , and Undertow(https://github.com/undertow-io/undertow) servers. Most developers use the appropriate starter to obtain a fully configured instance. By default, the embedded server listens for HTTP requests on port 8080 . Servlets, Filters, and Listeners: When using an embedded servlet container, you can register servlets, filters, and all the listeners (such as HttpSessionListener ) from the servlet spec, either by using Spring beans or by scanning for servlet components. Registering Servlets, Filters, and Listeners as Spring Beans: Any Servlet , Filter , or servlet *Listener instance that is a Spring bean is registered with the embedded container. This can be particularly convenient if you want to refer to a value from your application.properties during configuration. By default, if the context contains only a single Servlet, it is mapped to / . In the case of multiple servlet beans, the bean name is used as a path prefix. Filters map to /* . If convention-based mapping is not flexible enough, you can use the ServletRegistrationBean , FilterRegistrationBean , and ServletListenerRegistrationBean classes for complete control. It is usually safe to leave filter beans unordered. If a specific order is required, you should annotate the Filter with @Order or make it implement Ordered . You cannot configure the order of a Filter by annotating its bean method with @Order . If you cannot change the Filter class to add @Order or implement Ordered , you must define a FilterRegistrationBean for the Filter and set the registration bean’s order using the setOrder(int) method. Avoid configuring a filter that reads the request body at Ordered.HIGHEST_PRECEDENCE , since it might go against the character encoding configuration of your application. If a servlet filter wraps the request, it should be configured with an order that is less than or equal to OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER . To see the order of every Filter in your application, enable debug level logging for the web logging group(../features/logging.html#features.logging.log-groups) ( logging.level.web=debug ). Details of the registered filters, including their order and URL patterns, will then be logged at startup. Take care when registering Filter beans since they are initialized very early in the application lifecycle. If you need to register a Filter that interacts with other beans, consider using a DelegatingFilterProxyRegistrationBean(../../api/java/org/springframework/boot/web/servlet/DelegatingFilterProxyRegistrationBean.html) instead. Servlet Context Initialization: Embedded servlet containers do not directly execute the jakarta.servlet.ServletContainerInitializer interface or Spring’s org.springframework.web.WebApplicationInitializer interface. This is an intentional design decision intended to reduce the risk that third party libraries designed to run inside a war may break Spring Boot applications. If you need to perform servlet context initialization in a Spring Boot application, you should register a bean that implements the org.springframework.boot.web.servlet.ServletContextInitializer interface. The single onStartup method provides access to the ServletContext and, if necessary, can easily be used as an adapter to an existing WebApplicationInitializer . Scanning for Servlets, Filters, and listeners: When using an embedded container, automatic registration of classes annotated with @WebServlet , @WebFilter , and @WebListener can be enabled by using @ServletComponentScan . @ServletComponentScan has no effect in a standalone container, where the container’s built-in discovery mechanisms are used instead. The ServletWebServerApplicationContext: Under the hood, Spring Boot uses a different type of ApplicationContext for embedded servlet container support. The ServletWebServerApplicationContext is a special type of WebApplicationContext that bootstraps itself by searching for a single ServletWebServerFactory bean. Usually a TomcatServletWebServerFactory , JettyServletWebServerFactory , or UndertowServletWebServerFactory has been auto-configured. You usually do not need to be aware of these implementation classes. Most applications are auto-configured, and the appropriate ApplicationContext and ServletWebServerFactory are created on your behalf. In an embedded container setup, the ServletContext is set as part of server startup which happens during application context initialization. Because of this beans in the ApplicationContext cannot be reliably initialized with a ServletContext . One way to get around this is to inject ApplicationContext as a dependency of the bean and access the ServletContext only when it is needed. Another way is to use a callback once the server has started. This can be done using an ApplicationListener which listens for the ApplicationStartedEvent as follows: import jakarta.servlet.ServletContext; import org.springframework.boot.context.event.ApplicationStartedEvent; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationListener; import org.springframework.web.context.WebApplicationContext; public class MyDemoBean implements ApplicationListener<ApplicationStartedEvent> { private ServletContext servletContext; @Override public void onApplicationEvent(ApplicationStartedEvent event) { ApplicationContext applicationContext = event.getApplicationContext(); this.servletContext = ((WebApplicationContext) applicationContext).getServletContext(); } } Customizing Embedded Servlet Containers: Common servlet container settings can be configured by using Spring Environment properties. Usually, you would define the properties in your application.properties or application.yaml file. Common server settings include: Network settings: Listen port for incoming HTTP requests ( server.port ), interface address to bind to ( server.address ), and so on. Session settings: Whether the session is persistent ( server.servlet.session.persistent ), session timeout ( server.servlet.session.timeout ), location of session data ( server.servlet.session.store-dir ), and session-cookie configuration ( server.servlet.session.cookie.* ). Error management: Location of the error page ( server.error.path ) and so on. SSL(../../how-to/webserver.html#howto.webserver.configure-ssl) HTTP compression(../../how-to/webserver.html#howto.webserver.enable-response-compression) Spring Boot tries as much as possible to expose common settings, but this is not always possible. For those cases, dedicated namespaces offer server-specific customizations (see server.tomcat and server.undertow ). For instance, access logs(../../how-to/webserver.html#howto.webserver.configure-access-logs) can be configured with specific features of the embedded servlet container. See the ServerProperties(../../api/java/org/springframework/boot/autoconfigure/web/ServerProperties.html) class for a complete list. SameSite Cookies: The SameSite cookie attribute can be used by web browsers to control if and how cookies are submitted in cross-site requests. The attribute is particularly relevant for modern web browsers which have started to change the default value that is used when the attribute is missing. If you want to change the SameSite attribute of your session cookie, you can use the server.servlet.session.cookie.same-site property. This property is supported by auto-configured Tomcat, Jetty and Undertow servers. It is also used to configure Spring Session servlet based SessionRepository beans. For example, if you want your session cookie to have a SameSite attribute of None , you can add the following to your application.properties or application.yaml file: Properties YAML server.servlet.session.cookie.same-site=none server: servlet: session: cookie: same-site: ""none"" If you want to change the SameSite attribute on other cookies added to your HttpServletResponse , you can use a CookieSameSiteSupplier . The CookieSameSiteSupplier is passed a Cookie and may return a SameSite value, or null . There are a number of convenience factory and filter methods that you can use to quickly match specific cookies. For example, adding the following bean will automatically apply a SameSite of Lax for all cookies with a name that matches the regular expression myapp.* . Java Kotlin import org.springframework.boot.web.servlet.server.CookieSameSiteSupplier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MySameSiteConfiguration { @Bean public CookieSameSiteSupplier applicationCookieSameSiteSupplier() { return CookieSameSiteSupplier.ofLax().whenHasNameMatching(""myapp.*""); } } import org.springframework.boot.web.servlet.server.CookieSameSiteSupplier import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MySameSiteConfiguration { @Bean fun applicationCookieSameSiteSupplier(): CookieSameSiteSupplier { return CookieSameSiteSupplier.ofLax().whenHasNameMatching(""myapp.*"") } } Character Encoding: The character encoding behavior of the embedded servlet container for request and response handling can be configured using the server.servlet.encoding.* configuration properties. When a request’s Accept-Language header indicates a locale for the request it will be automatically mapped to a charset by the servlet container. Each container provides default locale to charset mappings and you should verify that they meet your application’s needs. When they do not, use the server.servlet.encoding.mapping configuration property to customize the mappings, as shown in the following example: Properties YAML server.servlet.encoding.mapping.ko=UTF-8 server: servlet: encoding: mapping: ko: ""UTF-8"" In the preceding example, the ko (Korean) locale has been mapped to UTF-8 . This is equivalent to a <locale-encoding-mapping-list> entry in a web.xml file of a traditional war deployment. Programmatic Customization: If you need to programmatically configure your embedded servlet container, you can register a Spring bean that implements the WebServerFactoryCustomizer interface. WebServerFactoryCustomizer provides access to the ConfigurableServletWebServerFactory , which includes numerous customization setter methods. The following example shows programmatically setting the port: Java Kotlin import org.springframework.boot.web.server.WebServerFactoryCustomizer; import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory; import org.springframework.stereotype.Component; @Component public class MyWebServerFactoryCustomizer implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> { @Override public void customize(ConfigurableServletWebServerFactory server) { server.setPort(9000); } } import org.springframework.boot.web.server.WebServerFactoryCustomizer import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory import org.springframework.stereotype.Component @Component class MyWebServerFactoryCustomizer : WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> { override fun customize(server: ConfigurableServletWebServerFactory) { server.setPort(9000) } } TomcatServletWebServerFactory , JettyServletWebServerFactory and UndertowServletWebServerFactory are dedicated variants of ConfigurableServletWebServerFactory that have additional customization setter methods for Tomcat, Jetty and Undertow respectively. The following example shows how to customize TomcatServletWebServerFactory that provides access to Tomcat-specific configuration options: Java Kotlin import java.time.Duration; import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory; import org.springframework.boot.web.server.WebServerFactoryCustomizer; import org.springframework.stereotype.Component; @Component public class MyTomcatWebServerFactoryCustomizer implements WebServerFactoryCustomizer<TomcatServletWebServerFactory> { @Override public void customize(TomcatServletWebServerFactory server) { server.addConnectorCustomizers((connector) -> connector.setAsyncTimeout(Duration.ofSeconds(20).toMillis())); } } import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory import org.springframework.boot.web.server.WebServerFactoryCustomizer import org.springframework.stereotype.Component import java.time.Duration @Component class MyTomcatWebServerFactoryCustomizer : WebServerFactoryCustomizer<TomcatServletWebServerFactory> { override fun customize(server: TomcatServletWebServerFactory) { server.addConnectorCustomizers({ connector -> connector.asyncTimeout = Duration.ofSeconds(20).toMillis() }) } } Customizing ConfigurableServletWebServerFactory Directly: For more advanced use cases that require you to extend from ServletWebServerFactory , you can expose a bean of such type yourself. Setters are provided for many configuration options. Several protected method “hooks” are also provided should you need to do something more exotic. See the ConfigurableServletWebServerFactory(../../api/java/org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html) API documentation for details. Auto-configured customizers are still applied on your custom factory, so use that option carefully. JSP Limitations: When running a Spring Boot application that uses an embedded servlet container (and is packaged as an executable archive), there are some limitations in the JSP support. With Jetty and Tomcat, it should work if you use war packaging. An executable war will work when launched with java -jar , and will also be deployable to any standard container. JSPs are not supported when using an executable jar. Undertow does not support JSPs. Creating a custom error.jsp page does not override the default view for error handling(#web.servlet.spring-mvc.error-handling) . Custom error pages(#web.servlet.spring-mvc.error-handling.error-pages) should be used instead."
"https://docs.spring.io/spring-boot/reference/web/reactive.html","Reactive Web Applications: Spring Boot simplifies development of reactive web applications by providing auto-configuration for Spring Webflux. The “Spring WebFlux Framework”: Spring WebFlux is the new reactive web framework introduced in Spring Framework 5.0. Unlike Spring MVC, it does not require the servlet API, is fully asynchronous and non-blocking, and implements the Reactive Streams(https://www.reactive-streams.org/) specification through the Reactor project(https://projectreactor.io/) . Spring WebFlux comes in two flavors: functional and annotation-based. The annotation-based one is quite close to the Spring MVC model, as shown in the following example: Java Kotlin import reactor.core.publisher.Flux; import reactor.core.publisher.Mono; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(""/users"") public class MyRestController { private final UserRepository userRepository; private final CustomerRepository customerRepository; public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) { this.userRepository = userRepository; this.customerRepository = customerRepository; } @GetMapping(""/{userId}"") public Mono<User> getUser(@PathVariable Long userId) { return this.userRepository.findById(userId); } @GetMapping(""/{userId}/customers"") public Flux<Customer> getUserCustomers(@PathVariable Long userId) { return this.userRepository.findById(userId).flatMapMany(this.customerRepository::findByUser); } @DeleteMapping(""/{userId}"") public Mono<Void> deleteUser(@PathVariable Long userId) { return this.userRepository.deleteById(userId); } } import org.springframework.web.bind.annotation.DeleteMapping import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.PathVariable import org.springframework.web.bind.annotation.RequestMapping import org.springframework.web.bind.annotation.RestController import reactor.core.publisher.Flux import reactor.core.publisher.Mono @RestController @RequestMapping(""/users"") class MyRestController(private val userRepository: UserRepository, private val customerRepository: CustomerRepository) { @GetMapping(""/{userId}"") fun getUser(@PathVariable userId: Long): Mono<User?> { return userRepository.findById(userId) } @GetMapping(""/{userId}/customers"") fun getUserCustomers(@PathVariable userId: Long): Flux<Customer> { return userRepository.findById(userId).flatMapMany { user: User? -> customerRepository.findByUser(user) } } @DeleteMapping(""/{userId}"") fun deleteUser(@PathVariable userId: Long): Mono<Void> { return userRepository.deleteById(userId) } } WebFlux is part of the Spring Framework and detailed information is available in its reference documentation(https://docs.spring.io/spring-framework/reference/6.1/web/webflux.html) . “WebFlux.fn”, the functional variant, separates the routing configuration from the actual handling of the requests, as shown in the following example: Java Kotlin import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.MediaType; import org.springframework.web.reactive.function.server.RequestPredicate; import org.springframework.web.reactive.function.server.RouterFunction; import org.springframework.web.reactive.function.server.ServerResponse; import static org.springframework.web.reactive.function.server.RequestPredicates.accept; import static org.springframework.web.reactive.function.server.RouterFunctions.route; @Configuration(proxyBeanMethods = false) public class MyRoutingConfiguration { private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON); @Bean public RouterFunction<ServerResponse> monoRouterFunction(MyUserHandler userHandler) { return route() .GET(""/{user}"", ACCEPT_JSON, userHandler::getUser) .GET(""/{user}/customers"", ACCEPT_JSON, userHandler::getUserCustomers) .DELETE(""/{user}"", ACCEPT_JSON, userHandler::deleteUser) .build(); } } import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.http.MediaType import org.springframework.web.reactive.function.server.RequestPredicates.DELETE import org.springframework.web.reactive.function.server.RequestPredicates.GET import org.springframework.web.reactive.function.server.RequestPredicates.accept import org.springframework.web.reactive.function.server.RouterFunction import org.springframework.web.reactive.function.server.RouterFunctions import org.springframework.web.reactive.function.server.ServerResponse @Configuration(proxyBeanMethods = false) class MyRoutingConfiguration { @Bean fun monoRouterFunction(userHandler: MyUserHandler): RouterFunction<ServerResponse> { return RouterFunctions.route( GET(""/{user}"").and(ACCEPT_JSON), userHandler::getUser).andRoute( GET(""/{user}/customers"").and(ACCEPT_JSON), userHandler::getUserCustomers).andRoute( DELETE(""/{user}"").and(ACCEPT_JSON), userHandler::deleteUser) } companion object { private val ACCEPT_JSON = accept(MediaType.APPLICATION_JSON) } } Java Kotlin import reactor.core.publisher.Mono; import org.springframework.stereotype.Component; import org.springframework.web.reactive.function.server.ServerRequest; import org.springframework.web.reactive.function.server.ServerResponse; @Component public class MyUserHandler { public Mono<ServerResponse> getUser(ServerRequest request) { ... } public Mono<ServerResponse> getUserCustomers(ServerRequest request) { ... } public Mono<ServerResponse> deleteUser(ServerRequest request) { ... } } import org.springframework.stereotype.Component import org.springframework.web.reactive.function.server.ServerRequest import org.springframework.web.reactive.function.server.ServerResponse import reactor.core.publisher.Mono @Component class MyUserHandler { fun getUser(request: ServerRequest?): Mono<ServerResponse> { ... } fun getUserCustomers(request: ServerRequest?): Mono<ServerResponse> { ... } fun deleteUser(request: ServerRequest?): Mono<ServerResponse> { ... } } “WebFlux.fn” is part of the Spring Framework and detailed information is available in its reference documentation(https://docs.spring.io/spring-framework/reference/6.1/web/webflux-functional.html) . You can define as many RouterFunction beans as you like to modularize the definition of the router. Beans can be ordered if you need to apply a precedence. To get started, add the spring-boot-starter-webflux module to your application. Adding both spring-boot-starter-web and spring-boot-starter-webflux modules in your application results in Spring Boot auto-configuring Spring MVC, not WebFlux. This behavior has been chosen because many Spring developers add spring-boot-starter-webflux to their Spring MVC application to use the reactive WebClient . You can still enforce your choice by setting the chosen application type to SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE) . Spring WebFlux Auto-configuration: Spring Boot provides auto-configuration for Spring WebFlux that works well with most applications. The auto-configuration adds the following features on top of Spring’s defaults: Configuring codecs for HttpMessageReader and HttpMessageWriter instances (described later in this document(#web.reactive.webflux.httpcodecs) ). Support for serving static resources, including support for WebJars (described later in this document(servlet.html#web.servlet.spring-mvc.static-content) ). If you want to keep Spring Boot WebFlux features and you want to add additional WebFlux configuration(https://docs.spring.io/spring-framework/reference/6.1/web/webflux/config.html) , you can add your own @Configuration class of type WebFluxConfigurer but without @EnableWebFlux . If you want to add additional customization to the auto-configured HttpHandler , you can define beans of type WebHttpHandlerBuilderCustomizer and use them to modify the WebHttpHandlerBuilder . If you want to take complete control of Spring WebFlux, you can add your own @Configuration annotated with @EnableWebFlux . Spring WebFlux Conversion Service: If you want to customize the ConversionService used by Spring WebFlux, you can provide a WebFluxConfigurer bean with an addFormatters method. Conversion can also be customized using the spring.webflux.format.* configuration properties. When not configured, the following defaults are used: Property DateTimeFormatter Formats spring.webflux.format.date ofLocalizedDate(FormatStyle.SHORT) java.util.Date and java.time.LocalDate spring.webflux.format.time ofLocalizedTime(FormatStyle.SHORT) java.time’s LocalTime and OffsetTime spring.webflux.format.date-time ofLocalizedDateTime(FormatStyle.SHORT) java.time’s LocalDateTime , OffsetDateTime , and ZonedDateTime HTTP Codecs with HttpMessageReaders and HttpMessageWriters: Spring WebFlux uses the HttpMessageReader and HttpMessageWriter interfaces to convert HTTP requests and responses. They are configured with CodecConfigurer to have sensible defaults by looking at the libraries available in your classpath. Spring Boot provides dedicated configuration properties for codecs, spring.codec.* . It also applies further customization by using CodecCustomizer instances. For example, spring.jackson.* configuration keys are applied to the Jackson codec. If you need to add or customize codecs, you can create a custom CodecCustomizer component, as shown in the following example: Java Kotlin import org.springframework.boot.web.codec.CodecCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.codec.ServerSentEventHttpMessageReader; @Configuration(proxyBeanMethods = false) public class MyCodecsConfiguration { @Bean public CodecCustomizer myCodecCustomizer() { return (configurer) -> { configurer.registerDefaults(false); configurer.customCodecs().register(new ServerSentEventHttpMessageReader()); // ... }; } } import org.springframework.boot.web.codec.CodecCustomizer import org.springframework.context.annotation.Bean import org.springframework.http.codec.CodecConfigurer import org.springframework.http.codec.ServerSentEventHttpMessageReader class MyCodecsConfiguration { @Bean fun myCodecCustomizer(): CodecCustomizer { return CodecCustomizer { configurer: CodecConfigurer -> configurer.registerDefaults(false) configurer.customCodecs().register(ServerSentEventHttpMessageReader()) } } } You can also leverage Boot’s custom JSON serializers and deserializers(../features/json.html#features.json.jackson.custom-serializers-and-deserializers) . Static Content: By default, Spring Boot serves static content from a directory called /static (or /public or /resources or /META-INF/resources ) in the classpath. It uses the ResourceWebHandler from Spring WebFlux so that you can modify that behavior by adding your own WebFluxConfigurer and overriding the addResourceHandlers method. By default, resources are mapped on /** , but you can tune that by setting the spring.webflux.static-path-pattern property. For instance, relocating all resources to /resources/** can be achieved as follows: Properties YAML spring.webflux.static-path-pattern=/resources/** spring: webflux: static-path-pattern: ""/resources/**"" You can also customize the static resource locations by using spring.web.resources.static-locations . Doing so replaces the default values with a list of directory locations. If you do so, the default welcome page detection switches to your custom locations. So, if there is an index.html in any of your locations on startup, it is the home page of the application. In addition to the “standard” static resource locations listed earlier, a special case is made for Webjars content(https://www.webjars.org/) . By default, any resources with a path in /webjars/** are served from jar files if they are packaged in the Webjars format. The path can be customized with the spring.webflux.webjars-path-pattern property. Spring WebFlux applications do not strictly depend on the servlet API, so they cannot be deployed as war files and do not use the src/main/webapp directory. Welcome Page: Spring Boot supports both static and templated welcome pages. It first looks for an index.html file in the configured static content locations. If one is not found, it then looks for an index template. If either is found, it is automatically used as the welcome page of the application. This only acts as a fallback for actual index routes defined by the application. The ordering is defined by the order of HandlerMapping beans which is by default the following: RouterFunctionMapping Endpoints declared with RouterFunction beans RequestMappingHandlerMapping Endpoints declared in @Controller beans RouterFunctionMapping for the Welcome Page The welcome page support Template Engines: As well as REST web services, you can also use Spring WebFlux to serve dynamic HTML content. Spring WebFlux supports a variety of templating technologies, including Thymeleaf, FreeMarker, and Mustache. Spring Boot includes auto-configuration support for the following templating engines: FreeMarker(https://freemarker.apache.org/docs/) Thymeleaf(https://www.thymeleaf.org) Mustache(https://mustache.github.io/) When you use one of these templating engines with the default configuration, your templates are picked up automatically from src/main/resources/templates . Error Handling: Spring Boot provides a WebExceptionHandler that handles all errors in a sensible way. Its position in the processing order is immediately before the handlers provided by WebFlux, which are considered last. For machine clients, it produces a JSON response with details of the error, the HTTP status, and the exception message. For browser clients, there is a “whitelabel” error handler that renders the same data in HTML format. You can also provide your own HTML templates to display errors (see the next section(#web.reactive.webflux.error-handling.error-pages) ). Before customizing error handling in Spring Boot directly, you can leverage the RFC 9457 Problem Details(https://docs.spring.io/spring-framework/reference/6.1/web/webflux/ann-rest-exceptions.html) support in Spring WebFlux. Spring WebFlux can produce custom error messages with the application/problem+json media type, like: { ""type"": ""https://example.org/problems/unknown-project"", ""title"": ""Unknown project"", ""status"": 404, ""detail"": ""No project found for id 'spring-unknown'"", ""instance"": ""/projects/spring-unknown"" } This support can be enabled by setting spring.webflux.problemdetails.enabled to true . The first step to customizing this feature often involves using the existing mechanism but replacing or augmenting the error contents. For that, you can add a bean of type ErrorAttributes . To change the error handling behavior, you can implement ErrorWebExceptionHandler and register a bean definition of that type. Because an ErrorWebExceptionHandler is quite low-level, Spring Boot also provides a convenient AbstractErrorWebExceptionHandler to let you handle errors in a WebFlux functional way, as shown in the following example: Java Kotlin import reactor.core.publisher.Mono; import org.springframework.boot.autoconfigure.web.WebProperties; import org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler; import org.springframework.boot.web.reactive.error.ErrorAttributes; import org.springframework.context.ApplicationContext; import org.springframework.http.HttpStatus; import org.springframework.http.MediaType; import org.springframework.http.codec.ServerCodecConfigurer; import org.springframework.stereotype.Component; import org.springframework.web.reactive.function.server.RouterFunction; import org.springframework.web.reactive.function.server.RouterFunctions; import org.springframework.web.reactive.function.server.ServerRequest; import org.springframework.web.reactive.function.server.ServerResponse; import org.springframework.web.reactive.function.server.ServerResponse.BodyBuilder; @Component public class MyErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler { public MyErrorWebExceptionHandler(ErrorAttributes errorAttributes, WebProperties webProperties, ApplicationContext applicationContext, ServerCodecConfigurer serverCodecConfigurer) { super(errorAttributes, webProperties.getResources(), applicationContext); setMessageReaders(serverCodecConfigurer.getReaders()); setMessageWriters(serverCodecConfigurer.getWriters()); } @Override protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) { return RouterFunctions.route(this::acceptsXml, this::handleErrorAsXml); } private boolean acceptsXml(ServerRequest request) { return request.headers().accept().contains(MediaType.APPLICATION_XML); } public Mono<ServerResponse> handleErrorAsXml(ServerRequest request) { BodyBuilder builder = ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR); // ... additional builder calls return builder.build(); } } import org.springframework.boot.autoconfigure.web.WebProperties import org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler import org.springframework.boot.web.reactive.error.ErrorAttributes import org.springframework.context.ApplicationContext import org.springframework.http.HttpStatus import org.springframework.http.MediaType import org.springframework.http.codec.ServerCodecConfigurer import org.springframework.stereotype.Component import org.springframework.web.reactive.function.server.RouterFunction import org.springframework.web.reactive.function.server.RouterFunctions import org.springframework.web.reactive.function.server.ServerRequest import org.springframework.web.reactive.function.server.ServerResponse import reactor.core.publisher.Mono @Component class MyErrorWebExceptionHandler( errorAttributes: ErrorAttributes, webProperties: WebProperties, applicationContext: ApplicationContext, serverCodecConfigurer: ServerCodecConfigurer ) : AbstractErrorWebExceptionHandler(errorAttributes, webProperties.resources, applicationContext) { init { setMessageReaders(serverCodecConfigurer.readers) setMessageWriters(serverCodecConfigurer.writers) } override fun getRoutingFunction(errorAttributes: ErrorAttributes): RouterFunction<ServerResponse> { return RouterFunctions.route(this::acceptsXml, this::handleErrorAsXml) } private fun acceptsXml(request: ServerRequest): Boolean { return request.headers().accept().contains(MediaType.APPLICATION_XML) } fun handleErrorAsXml(request: ServerRequest): Mono<ServerResponse> { val builder = ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR) // ... additional builder calls return builder.build() } } For a more complete picture, you can also subclass DefaultErrorWebExceptionHandler directly and override specific methods. In some cases, errors handled at the controller level are not recorded by web observations or the metrics infrastructure(../actuator/metrics.html#actuator.metrics.supported.spring-webflux) . Applications can ensure that such exceptions are recorded with the observations by setting the handled exception on the observation context(https://docs.spring.io/spring-framework/reference/6.1/integration/observability.html#observability.http-server.reactive) . Custom Error Pages: If you want to display a custom HTML error page for a given status code, you can add views that resolve from error/* , for example by adding files to a /error directory. Error pages can either be static HTML (that is, added under any of the static resource directories) or built with templates. The name of the file should be the exact status code, a status code series mask, or error for a default if nothing else matches. Note that the path to the default error view is error/error , whereas with Spring MVC the default error view is error . For example, to map 404 to a static HTML file, your directory structure would be as follows: src/ +- main/ +- java/ | + <source code> +- resources/ +- public/ +- error/ | +- 404.html +- <other public assets> To map all 5xx errors by using a Mustache template, your directory structure would be as follows: src/ +- main/ +- java/ | + <source code> +- resources/ +- templates/ +- error/ | +- 5xx.mustache +- <other templates> Web Filters: Spring WebFlux provides a WebFilter interface that can be implemented to filter HTTP request-response exchanges. WebFilter beans found in the application context will be automatically used to filter each exchange. Where the order of the filters is important they can implement Ordered or be annotated with @Order . Spring Boot auto-configuration may configure web filters for you. When it does so, the orders shown in the following table will be used: Web Filter Order WebFilterChainProxy (Spring Security) -100 HttpExchangesWebFilter Ordered.LOWEST_PRECEDENCE - 10 Embedded Reactive Server Support: Spring Boot includes support for the following embedded reactive web servers: Reactor Netty, Tomcat, Jetty, and Undertow. Most developers use the appropriate starter to obtain a fully configured instance. By default, the embedded server listens for HTTP requests on port 8080. Customizing Reactive Servers: Common reactive web server settings can be configured by using Spring Environment properties. Usually, you would define the properties in your application.properties or application.yaml file. Common server settings include: Network settings: Listen port for incoming HTTP requests ( server.port ), interface address to bind to ( server.address ), and so on. Error management: Location of the error page ( server.error.path ) and so on. SSL(../../how-to/webserver.html#howto.webserver.configure-ssl) HTTP compression(../../how-to/webserver.html#howto.webserver.enable-response-compression) Spring Boot tries as much as possible to expose common settings, but this is not always possible. For those cases, dedicated namespaces such as server.netty.* offer server-specific customizations. See the ServerProperties(../../api/java/org/springframework/boot/autoconfigure/web/ServerProperties.html) class for a complete list. Programmatic Customization: If you need to programmatically configure your reactive web server, you can register a Spring bean that implements the WebServerFactoryCustomizer interface. WebServerFactoryCustomizer provides access to the ConfigurableReactiveWebServerFactory , which includes numerous customization setter methods. The following example shows programmatically setting the port: Java Kotlin import org.springframework.boot.web.reactive.server.ConfigurableReactiveWebServerFactory; import org.springframework.boot.web.server.WebServerFactoryCustomizer; import org.springframework.stereotype.Component; @Component public class MyWebServerFactoryCustomizer implements WebServerFactoryCustomizer<ConfigurableReactiveWebServerFactory> { @Override public void customize(ConfigurableReactiveWebServerFactory server) { server.setPort(9000); } } import org.springframework.boot.web.server.WebServerFactoryCustomizer import org.springframework.boot.web.reactive.server.ConfigurableReactiveWebServerFactory import org.springframework.stereotype.Component @Component class MyWebServerFactoryCustomizer : WebServerFactoryCustomizer<ConfigurableReactiveWebServerFactory> { override fun customize(server: ConfigurableReactiveWebServerFactory) { server.setPort(9000) } } JettyReactiveWebServerFactory , NettyReactiveWebServerFactory , TomcatReactiveWebServerFactory , and UndertowReactiveWebServerFactory are dedicated variants of ConfigurableReactiveWebServerFactory that have additional customization setter methods for Jetty, Reactor Netty, Tomcat, and Undertow respectively. The following example shows how to customize NettyReactiveWebServerFactory that provides access to Reactor Netty-specific configuration options: Java Kotlin import java.time.Duration; import org.springframework.boot.web.embedded.netty.NettyReactiveWebServerFactory; import org.springframework.boot.web.server.WebServerFactoryCustomizer; import org.springframework.stereotype.Component; @Component public class MyNettyWebServerFactoryCustomizer implements WebServerFactoryCustomizer<NettyReactiveWebServerFactory> { @Override public void customize(NettyReactiveWebServerFactory factory) { factory.addServerCustomizers((server) -> server.idleTimeout(Duration.ofSeconds(20))); } } import org.springframework.boot.web.embedded.netty.NettyReactiveWebServerFactory import org.springframework.boot.web.server.WebServerFactoryCustomizer import org.springframework.stereotype.Component import java.time.Duration @Component class MyNettyWebServerFactoryCustomizer : WebServerFactoryCustomizer<NettyReactiveWebServerFactory> { override fun customize(factory: NettyReactiveWebServerFactory) { factory.addServerCustomizers({ server -> server.idleTimeout(Duration.ofSeconds(20)) }) } } Customizing ConfigurableReactiveWebServerFactory Directly: For more advanced use cases that require you to extend from ReactiveWebServerFactory , you can expose a bean of such type yourself. Setters are provided for many configuration options. Several protected method “hooks” are also provided should you need to do something more exotic. See the ConfigurableReactiveWebServerFactory(../../api/java/org/springframework/boot/web/reactive/server/ConfigurableReactiveWebServerFactory.html) API documentation for details. Auto-configured customizers are still applied on your custom factory, so use that option carefully. Reactive Server Resources Configuration: When auto-configuring a Reactor Netty or Jetty server, Spring Boot will create specific beans that will provide HTTP resources to the server instance: ReactorResourceFactory or JettyResourceFactory . By default, those resources will be also shared with the Reactor Netty and Jetty clients for optimal performances, given: the same technology is used for server and client the client instance is built using the WebClient.Builder bean auto-configured by Spring Boot Developers can override the resource configuration for Jetty and Reactor Netty by providing a custom ReactorResourceFactory or JettyResourceFactory bean - this will be applied to both clients and servers. You can learn more about the resource configuration on the client side in the WebClient Runtime(../io/rest-client.html#io.rest-client.webclient.runtime) section."
"https://docs.spring.io/spring-boot/reference/web/graceful-shutdown.html","Graceful Shutdown: Graceful shutdown is supported with all four embedded web servers (Jetty, Reactor Netty, Tomcat, and Undertow) and with both reactive and servlet-based web applications. It occurs as part of closing the application context and is performed in the earliest phase of stopping SmartLifecycle beans. This stop processing uses a timeout which provides a grace period during which existing requests will be allowed to complete but no new requests will be permitted. The exact way in which new requests are not permitted varies depending on the web server that is being used. Implementations may stop accepting requests at the network layer, or they may return a response with a specific HTTP status code or HTTP header. The use of persistent connections can also change the way that requests stop being accepted. To learn about more the specific method used with your web server, see the shutDownGracefully API documentation for TomcatWebServer.shutDownGracefully(GracefulShutdownCallback)(../../api/java/org/springframework/boot/web/embedded/tomcat/TomcatWebServer.html#shutDownGracefully(org.springframework.boot.web.server.GracefulShutdownCallback)) , NettyWebServer.shutDownGracefully(GracefulShutdownCallback)(../../api/java/org/springframework/boot/web/embedded/netty/NettyWebServer.html#shutDownGracefully(org.springframework.boot.web.server.GracefulShutdownCallback)) , JettyWebServer.shutDownGracefully(GracefulShutdownCallback)(../../api/java/org/springframework/boot/web/embedded/jetty/JettyWebServer.html#shutDownGracefully(org.springframework.boot.web.server.GracefulShutdownCallback)) or UndertowWebServer.shutDownGracefully(GracefulShutdownCallback)(../../api/java/org/springframework/boot/web/embedded/undertow/UndertowWebServer.html#shutDownGracefully(org.springframework.boot.web.server.GracefulShutdownCallback)) . Jetty, Reactor Netty, and Tomcat will stop accepting new requests at the network layer. Undertow will accept new connections but respond immediately with a service unavailable (503) response. Graceful shutdown with Tomcat requires Tomcat 9.0.33 or later. To enable graceful shutdown, configure the server.shutdown property, as shown in the following example: Properties YAML server.shutdown=graceful server: shutdown: ""graceful"" To configure the timeout period, configure the spring.lifecycle.timeout-per-shutdown-phase property, as shown in the following example: Properties YAML spring.lifecycle.timeout-per-shutdown-phase=20s spring: lifecycle: timeout-per-shutdown-phase: ""20s"" Using graceful shutdown with your IDE may not work properly if it does not send a proper SIGTERM signal. See the documentation of your IDE for more details."
"https://docs.spring.io/spring-boot/reference/web/spring-security.html","Spring Security: If Spring Security(https://spring.io/projects/spring-security) is on the classpath, then web applications are secured by default. Spring Boot relies on Spring Security’s content-negotiation strategy to determine whether to use httpBasic or formLogin . To add method-level security to a web application, you can also add @EnableGlobalMethodSecurity with your desired settings. Additional information can be found in the Spring Security Reference Guide(https://docs.spring.io/spring-security/reference/6.3/servlet/authorization/method-security.html) . The default UserDetailsService has a single user. The user name is user , and the password is random and is printed at WARN level when the application starts, as shown in the following example: Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35 This generated password is for development use only. Your security configuration must be updated before running your application in production. If you fine-tune your logging configuration, ensure that the org.springframework.boot.autoconfigure.security category is set to log WARN -level messages. Otherwise, the default password is not printed. You can change the username and password by providing a spring.security.user.name and spring.security.user.password . The basic features you get by default in a web application are: A UserDetailsService (or ReactiveUserDetailsService in case of a WebFlux application) bean with in-memory store and a single user with a generated password (see SecurityProperties.User(../../api/java/org/springframework/boot/autoconfigure/security/SecurityProperties.User.html) for the properties of the user). Form-based login or HTTP Basic security (depending on the Accept header in the request) for the entire application (including actuator endpoints if actuator is on the classpath). A DefaultAuthenticationEventPublisher for publishing authentication events. You can provide a different AuthenticationEventPublisher by adding a bean for it. MVC Security: The default security configuration is implemented in SecurityAutoConfiguration and UserDetailsServiceAutoConfiguration . SecurityAutoConfiguration imports SpringBootWebSecurityConfiguration for web security and UserDetailsServiceAutoConfiguration configures authentication, which is also relevant in non-web applications. To completely switch off the default web application security configuration, including Actuator security, or to combine multiple Spring Security components such as OAuth2 Client and Resource Server, add a bean of type SecurityFilterChain (doing so does not disable the UserDetailsService configuration). To also switch off the UserDetailsService configuration, add a bean of type UserDetailsService , AuthenticationProvider , or AuthenticationManager . The auto-configuration of a UserDetailsService will also back off any of the following Spring Security modules is on the classpath: spring-security-oauth2-client spring-security-oauth2-resource-server spring-security-saml2-service-provider To use UserDetailsService in addition to one or more of these dependencies, define your own InMemoryUserDetailsManager bean. Access rules can be overridden by adding a custom SecurityFilterChain bean. Spring Boot provides convenience methods that can be used to override access rules for actuator endpoints and static resources. EndpointRequest can be used to create a RequestMatcher that is based on the management.endpoints.web.base-path property. PathRequest can be used to create a RequestMatcher for resources in commonly used locations. WebFlux Security: Similar to Spring MVC applications, you can secure your WebFlux applications by adding the spring-boot-starter-security dependency. The default security configuration is implemented in ReactiveSecurityAutoConfiguration and UserDetailsServiceAutoConfiguration . ReactiveSecurityAutoConfiguration imports WebFluxSecurityConfiguration for web security and UserDetailsServiceAutoConfiguration configures authentication, which is also relevant in non-web applications. To completely switch off the default web application security configuration, including Actuator security, add a bean of type WebFilterChainProxy (doing so does not disable the UserDetailsService configuration). To also switch off the UserDetailsService configuration, add a bean of type ReactiveUserDetailsService or ReactiveAuthenticationManager . The auto-configuration will also back off when any of the following Spring Security modules is on the classpath: spring-security-oauth2-client spring-security-oauth2-resource-server To use ReactiveUserDetailsService in addition to one or more of these dependencies, define your own MapReactiveUserDetailsService bean. Access rules and the use of multiple Spring Security components such as OAuth 2 Client and Resource Server can be configured by adding a custom SecurityWebFilterChain bean. Spring Boot provides convenience methods that can be used to override access rules for actuator endpoints and static resources. EndpointRequest can be used to create a ServerWebExchangeMatcher that is based on the management.endpoints.web.base-path property. PathRequest can be used to create a ServerWebExchangeMatcher for resources in commonly used locations. For example, you can customize your security configuration by adding something like: Java Kotlin import org.springframework.boot.autoconfigure.security.reactive.PathRequest; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.web.server.ServerHttpSecurity; import org.springframework.security.web.server.SecurityWebFilterChain; import static org.springframework.security.config.Customizer.withDefaults; @Configuration(proxyBeanMethods = false) public class MyWebFluxSecurityConfiguration { @Bean public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { http.authorizeExchange((exchange) -> { exchange.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); exchange.pathMatchers(""/foo"", ""/bar"").authenticated(); }); http.formLogin(withDefaults()); return http.build(); } } import org.springframework.boot.autoconfigure.security.reactive.PathRequest import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.security.config.Customizer.withDefaults import org.springframework.security.config.web.server.ServerHttpSecurity import org.springframework.security.web.server.SecurityWebFilterChain @Configuration(proxyBeanMethods = false) class MyWebFluxSecurityConfiguration { @Bean fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain { http.authorizeExchange { spec -> spec.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() spec.pathMatchers(""/foo"", ""/bar"").authenticated() } http.formLogin(withDefaults()) return http.build() } } OAuth2: OAuth2(https://oauth.net/2/) is a widely used authorization framework that is supported by Spring. Client: If you have spring-security-oauth2-client on your classpath, you can take advantage of some auto-configuration to set up OAuth2/Open ID Connect clients. This configuration makes use of the properties under OAuth2ClientProperties . The same properties are applicable to both servlet and reactive applications. You can register multiple OAuth2 clients and providers under the spring.security.oauth2.client prefix, as shown in the following example: Properties YAML spring.security.oauth2.client.registration.my-login-client.client-id=abcd spring.security.oauth2.client.registration.my-login-client.client-secret=password spring.security.oauth2.client.registration.my-login-client.client-name=Client for OpenID Connect spring.security.oauth2.client.registration.my-login-client.provider=my-oauth-provider spring.security.oauth2.client.registration.my-login-client.scope=openid,profile,email,phone,address spring.security.oauth2.client.registration.my-login-client.redirect-uri={baseUrl}/login/oauth2/code/{registrationId} spring.security.oauth2.client.registration.my-login-client.client-authentication-method=client_secret_basic spring.security.oauth2.client.registration.my-login-client.authorization-grant-type=authorization_code spring.security.oauth2.client.registration.my-client-1.client-id=abcd spring.security.oauth2.client.registration.my-client-1.client-secret=password spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider spring.security.oauth2.client.registration.my-client-1.scope=user spring.security.oauth2.client.registration.my-client-1.redirect-uri={baseUrl}/authorized/user spring.security.oauth2.client.registration.my-client-1.client-authentication-method=client_secret_basic spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code spring.security.oauth2.client.registration.my-client-2.client-id=abcd spring.security.oauth2.client.registration.my-client-2.client-secret=password spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider spring.security.oauth2.client.registration.my-client-2.scope=email spring.security.oauth2.client.registration.my-client-2.redirect-uri={baseUrl}/authorized/email spring.security.oauth2.client.registration.my-client-2.client-authentication-method=client_secret_basic spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=https://my-auth-server.com/oauth2/authorize spring.security.oauth2.client.provider.my-oauth-provider.token-uri=https://my-auth-server.com/oauth2/token spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=https://my-auth-server.com/userinfo spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=https://my-auth-server.com/oauth2/jwks spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name spring: security: oauth2: client: registration: my-login-client: client-id: ""abcd"" client-secret: ""password"" client-name: ""Client for OpenID Connect"" provider: ""my-oauth-provider"" scope: ""openid,profile,email,phone,address"" redirect-uri: ""{baseUrl}/login/oauth2/code/{registrationId}"" client-authentication-method: ""client_secret_basic"" authorization-grant-type: ""authorization_code"" my-client-1: client-id: ""abcd"" client-secret: ""password"" client-name: ""Client for user scope"" provider: ""my-oauth-provider"" scope: ""user"" redirect-uri: ""{baseUrl}/authorized/user"" client-authentication-method: ""client_secret_basic"" authorization-grant-type: ""authorization_code"" my-client-2: client-id: ""abcd"" client-secret: ""password"" client-name: ""Client for email scope"" provider: ""my-oauth-provider"" scope: ""email"" redirect-uri: ""{baseUrl}/authorized/email"" client-authentication-method: ""client_secret_basic"" authorization-grant-type: ""authorization_code"" provider: my-oauth-provider: authorization-uri: ""https://my-auth-server.com/oauth2/authorize"" token-uri: ""https://my-auth-server.com/oauth2/token"" user-info-uri: ""https://my-auth-server.com/userinfo"" user-info-authentication-method: ""header"" jwk-set-uri: ""https://my-auth-server.com/oauth2/jwks"" user-name-attribute: ""name"" For OpenID Connect providers that support OpenID Connect discovery(https://openid.net/specs/openid-connect-discovery-1_0.html) , the configuration can be further simplified. The provider needs to be configured with an issuer-uri which is the URI that it asserts as its Issuer Identifier. For example, if the issuer-uri provided is ""https://example.com"", then an ""OpenID Provider Configuration Request"" will be made to ""https://example.com/.well-known/openid-configuration"". The result is expected to be an ""OpenID Provider Configuration Response"". The following example shows how an OpenID Connect Provider can be configured with the issuer-uri : Properties YAML spring.security.oauth2.client.provider.oidc-provider.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/ spring: security: oauth2: client: provider: oidc-provider: issuer-uri: ""https://dev-123456.oktapreview.com/oauth2/default/"" By default, Spring Security’s OAuth2LoginAuthenticationFilter only processes URLs matching /login/oauth2/code/* . If you want to customize the redirect-uri to use a different pattern, you need to provide configuration to process that custom pattern. For example, for servlet applications, you can add your own SecurityFilterChain that resembles the following: Java Kotlin import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.web.SecurityFilterChain; @Configuration(proxyBeanMethods = false) @EnableWebSecurity public class MyOAuthClientConfiguration { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests((requests) -> requests .anyRequest().authenticated() ) .oauth2Login((login) -> login .redirectionEndpoint((endpoint) -> endpoint .baseUri(""/login/oauth2/callback/*"") ) ); return http.build(); } } import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.security.config.annotation.web.builders.HttpSecurity import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity import org.springframework.security.config.annotation.web.invoke import org.springframework.security.web.SecurityFilterChain @Configuration(proxyBeanMethods = false) @EnableWebSecurity open class MyOAuthClientConfiguration { @Bean open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http { authorizeHttpRequests { authorize(anyRequest, authenticated) } oauth2Login { redirectionEndpoint { baseUri = ""/login/oauth2/callback/*"" } } } return http.build() } } Spring Boot auto-configures an InMemoryOAuth2AuthorizedClientService which is used by Spring Security for the management of client registrations. The InMemoryOAuth2AuthorizedClientService has limited capabilities and we recommend using it only for development environments. For production environments, consider using a JdbcOAuth2AuthorizedClientService or creating your own implementation of OAuth2AuthorizedClientService . OAuth2 Client Registration for Common Providers: For common OAuth2 and OpenID providers, including Google, Github, Facebook, and Okta, we provide a set of provider defaults ( google , github , facebook , and okta , respectively). If you do not need to customize these providers, you can set the provider attribute to the one for which you need to infer defaults. Also, if the key for the client registration matches a default supported provider, Spring Boot infers that as well. In other words, the two configurations in the following example use the Google provider: Properties YAML spring.security.oauth2.client.registration.my-client.client-id=abcd spring.security.oauth2.client.registration.my-client.client-secret=password spring.security.oauth2.client.registration.my-client.provider=google spring.security.oauth2.client.registration.google.client-id=abcd spring.security.oauth2.client.registration.google.client-secret=password spring: security: oauth2: client: registration: my-client: client-id: ""abcd"" client-secret: ""password"" provider: ""google"" google: client-id: ""abcd"" client-secret: ""password"" Resource Server: If you have spring-security-oauth2-resource-server on your classpath, Spring Boot can set up an OAuth2 Resource Server. For JWT configuration, a JWK Set URI or OIDC Issuer URI needs to be specified, as shown in the following examples: Properties YAML spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://example.com/oauth2/default/v1/keys spring: security: oauth2: resourceserver: jwt: jwk-set-uri: ""https://example.com/oauth2/default/v1/keys"" Properties YAML spring.security.oauth2.resourceserver.jwt.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/ spring: security: oauth2: resourceserver: jwt: issuer-uri: ""https://dev-123456.oktapreview.com/oauth2/default/"" If the authorization server does not support a JWK Set URI, you can configure the resource server with the Public Key used for verifying the signature of the JWT. This can be done using the spring.security.oauth2.resourceserver.jwt.public-key-location property, where the value needs to point to a file containing the public key in the PEM-encoded x509 format. The spring.security.oauth2.resourceserver.jwt.audiences property can be used to specify the expected values of the aud claim in JWTs. For example, to require JWTs to contain an aud claim with the value my-audience : Properties YAML spring.security.oauth2.resourceserver.jwt.audiences[0]=my-audience spring: security: oauth2: resourceserver: jwt: audiences: - ""my-audience"" The same properties are applicable for both servlet and reactive applications. Alternatively, you can define your own JwtDecoder bean for servlet applications or a ReactiveJwtDecoder for reactive applications. In cases where opaque tokens are used instead of JWTs, you can configure the following properties to validate tokens through introspection: Properties YAML spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://example.com/check-token spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret spring: security: oauth2: resourceserver: opaquetoken: introspection-uri: ""https://example.com/check-token"" client-id: ""my-client-id"" client-secret: ""my-client-secret"" Again, the same properties are applicable for both servlet and reactive applications. Alternatively, you can define your own OpaqueTokenIntrospector bean for servlet applications or a ReactiveOpaqueTokenIntrospector for reactive applications. Authorization Server: If you have spring-security-oauth2-authorization-server on your classpath, you can take advantage of some auto-configuration to set up a Servlet-based OAuth2 Authorization Server. You can register multiple OAuth2 clients under the spring.security.oauth2.authorizationserver.client prefix, as shown in the following example: Properties YAML spring.security.oauth2.authorizationserver.client.my-client-1.registration.client-id=abcd spring.security.oauth2.authorizationserver.client.my-client-1.registration.client-secret={noop}secret1 spring.security.oauth2.authorizationserver.client.my-client-1.registration.client-authentication-methods[0]=client_secret_basic spring.security.oauth2.authorizationserver.client.my-client-1.registration.authorization-grant-types[0]=authorization_code spring.security.oauth2.authorizationserver.client.my-client-1.registration.authorization-grant-types[1]=refresh_token spring.security.oauth2.authorizationserver.client.my-client-1.registration.redirect-uris[0]=https://my-client-1.com/login/oauth2/code/abcd spring.security.oauth2.authorizationserver.client.my-client-1.registration.redirect-uris[1]=https://my-client-1.com/authorized spring.security.oauth2.authorizationserver.client.my-client-1.registration.scopes[0]=openid spring.security.oauth2.authorizationserver.client.my-client-1.registration.scopes[1]=profile spring.security.oauth2.authorizationserver.client.my-client-1.registration.scopes[2]=email spring.security.oauth2.authorizationserver.client.my-client-1.registration.scopes[3]=phone spring.security.oauth2.authorizationserver.client.my-client-1.registration.scopes[4]=address spring.security.oauth2.authorizationserver.client.my-client-1.require-authorization-consent=true spring.security.oauth2.authorizationserver.client.my-client-2.registration.client-id=efgh spring.security.oauth2.authorizationserver.client.my-client-2.registration.client-secret={noop}secret2 spring.security.oauth2.authorizationserver.client.my-client-2.registration.client-authentication-methods[0]=client_secret_jwt spring.security.oauth2.authorizationserver.client.my-client-2.registration.authorization-grant-types[0]=client_credentials spring.security.oauth2.authorizationserver.client.my-client-2.registration.scopes[0]=user.read spring.security.oauth2.authorizationserver.client.my-client-2.registration.scopes[1]=user.write spring.security.oauth2.authorizationserver.client.my-client-2.jwk-set-uri=https://my-client-2.com/jwks spring.security.oauth2.authorizationserver.client.my-client-2.token-endpoint-authentication-signing-algorithm=RS256 spring: security: oauth2: authorizationserver: client: my-client-1: registration: client-id: ""abcd"" client-secret: ""{noop}secret1"" client-authentication-methods: - ""client_secret_basic"" authorization-grant-types: - ""authorization_code"" - ""refresh_token"" redirect-uris: - ""https://my-client-1.com/login/oauth2/code/abcd"" - ""https://my-client-1.com/authorized"" scopes: - ""openid"" - ""profile"" - ""email"" - ""phone"" - ""address"" require-authorization-consent: true my-client-2: registration: client-id: ""efgh"" client-secret: ""{noop}secret2"" client-authentication-methods: - ""client_secret_jwt"" authorization-grant-types: - ""client_credentials"" scopes: - ""user.read"" - ""user.write"" jwk-set-uri: ""https://my-client-2.com/jwks"" token-endpoint-authentication-signing-algorithm: ""RS256"" The client-secret property must be in a format that can be matched by the configured PasswordEncoder . The default instance of PasswordEncoder is created via PasswordEncoderFactories.createDelegatingPasswordEncoder() . The auto-configuration Spring Boot provides for Spring Authorization Server is designed for getting started quickly. Most applications will require customization and will want to define several beans to override auto-configuration. The following components can be defined as beans to override auto-configuration specific to Spring Authorization Server: RegisteredClientRepository AuthorizationServerSettings SecurityFilterChain com.nimbusds.jose.jwk.source.JWKSource<com.nimbusds.jose.proc.SecurityContext> JwtDecoder Spring Boot auto-configures an InMemoryRegisteredClientRepository which is used by Spring Authorization Server for the management of registered clients. The InMemoryRegisteredClientRepository has limited capabilities and we recommend using it only for development environments. For production environments, consider using a JdbcRegisteredClientRepository or creating your own implementation of RegisteredClientRepository . Additional information can be found in the Getting Started(https://docs.spring.io/spring-authorization-server/reference/1.3/getting-started.html) chapter of the Spring Authorization Server Reference Guide(https://docs.spring.io/spring-authorization-server/reference/1.3) . SAML 2.0: Relying Party: If you have spring-security-saml2-service-provider on your classpath, you can take advantage of some auto-configuration to set up a SAML 2.0 Relying Party. This configuration makes use of the properties under Saml2RelyingPartyProperties . A relying party registration represents a paired configuration between an Identity Provider, IDP, and a Service Provider, SP. You can register multiple relying parties under the spring.security.saml2.relyingparty prefix, as shown in the following example: Properties YAML spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].private-key-location=path-to-private-key spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].certificate-location=path-to-certificate spring.security.saml2.relyingparty.registration.my-relying-party1.decryption.credentials[0].private-key-location=path-to-private-key spring.security.saml2.relyingparty.registration.my-relying-party1.decryption.credentials[0].certificate-location=path-to-certificate spring.security.saml2.relyingparty.registration.my-relying-party1.singlelogout.url=https://myapp/logout/saml2/slo spring.security.saml2.relyingparty.registration.my-relying-party1.singlelogout.response-url=https://remoteidp2.slo.url spring.security.saml2.relyingparty.registration.my-relying-party1.singlelogout.binding=POST spring.security.saml2.relyingparty.registration.my-relying-party1.assertingparty.verification.credentials[0].certificate-location=path-to-verification-cert spring.security.saml2.relyingparty.registration.my-relying-party1.assertingparty.entity-id=remote-idp-entity-id1 spring.security.saml2.relyingparty.registration.my-relying-party1.assertingparty.sso-url=https://remoteidp1.sso.url spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].private-key-location=path-to-private-key spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].certificate-location=path-to-certificate spring.security.saml2.relyingparty.registration.my-relying-party2.decryption.credentials[0].private-key-location=path-to-private-key spring.security.saml2.relyingparty.registration.my-relying-party2.decryption.credentials[0].certificate-location=path-to-certificate spring.security.saml2.relyingparty.registration.my-relying-party2.assertingparty.verification.credentials[0].certificate-location=path-to-other-verification-cert spring.security.saml2.relyingparty.registration.my-relying-party2.assertingparty.entity-id=remote-idp-entity-id2 spring.security.saml2.relyingparty.registration.my-relying-party2.assertingparty.sso-url=https://remoteidp2.sso.url spring.security.saml2.relyingparty.registration.my-relying-party2.assertingparty.singlelogout.url=https://remoteidp2.slo.url spring.security.saml2.relyingparty.registration.my-relying-party2.assertingparty.singlelogout.response-url=https://myapp/logout/saml2/slo spring.security.saml2.relyingparty.registration.my-relying-party2.assertingparty.singlelogout.binding=POST spring: security: saml2: relyingparty: registration: my-relying-party1: signing: credentials: - private-key-location: ""path-to-private-key"" certificate-location: ""path-to-certificate"" decryption: credentials: - private-key-location: ""path-to-private-key"" certificate-location: ""path-to-certificate"" singlelogout: url: ""https://myapp/logout/saml2/slo"" response-url: ""https://remoteidp2.slo.url"" binding: ""POST"" assertingparty: verification: credentials: - certificate-location: ""path-to-verification-cert"" entity-id: ""remote-idp-entity-id1"" sso-url: ""https://remoteidp1.sso.url"" my-relying-party2: signing: credentials: - private-key-location: ""path-to-private-key"" certificate-location: ""path-to-certificate"" decryption: credentials: - private-key-location: ""path-to-private-key"" certificate-location: ""path-to-certificate"" assertingparty: verification: credentials: - certificate-location: ""path-to-other-verification-cert"" entity-id: ""remote-idp-entity-id2"" sso-url: ""https://remoteidp2.sso.url"" singlelogout: url: ""https://remoteidp2.slo.url"" response-url: ""https://myapp/logout/saml2/slo"" binding: ""POST"" For SAML2 logout, by default, Spring Security’s Saml2LogoutRequestFilter and Saml2LogoutResponseFilter only process URLs matching /logout/saml2/slo . If you want to customize the url to which AP-initiated logout requests get sent to or the response-url to which an AP sends logout responses to, to use a different pattern, you need to provide configuration to process that custom pattern. For example, for servlet applications, you can add your own SecurityFilterChain that resembles the following: import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.web.SecurityFilterChain; import static org.springframework.security.config.Customizer.withDefaults; @Configuration(proxyBeanMethods = false) public class MySamlRelyingPartyConfiguration { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated()); http.saml2Login(withDefaults()); http.saml2Logout((saml2) -> saml2.logoutRequest((request) -> request.logoutUrl(""/SLOService.saml2"")) .logoutResponse((response) -> response.logoutUrl(""/SLOService.saml2""))); return http.build(); } }"
"https://docs.spring.io/spring-boot/reference/web/spring-session.html","Spring Session: Spring Boot provides Spring Session(https://spring.io/projects/spring-session) auto-configuration for a wide range of data stores. When building a servlet web application, the following stores can be auto-configured: Redis JDBC Hazelcast MongoDB Additionally, Spring Boot for Apache Geode(https://github.com/spring-projects/spring-boot-data-geode) provides auto-configuration for using Apache Geode as a session store(https://docs.spring.io/spring-boot-data-geode-build/2.0.x/reference/html5#geode-session) . The servlet auto-configuration replaces the need to use @Enable*HttpSession . If a single Spring Session module is present on the classpath, Spring Boot uses that store implementation automatically. If you have more than one implementation, Spring Boot uses the following order for choosing a specific implementation: Redis JDBC Hazelcast MongoDB If none of Redis, JDBC, Hazelcast and MongoDB are available, we do not configure a SessionRepository . When building a reactive web application, the following stores can be auto-configured: Redis MongoDB The reactive auto-configuration replaces the need to use @Enable*WebSession . Similar to the servlet configuration, if you have more than one implementation, Spring Boot uses the following order for choosing a specific implementation: Redis MongoDB If neither Redis nor MongoDB are available, we do not configure a ReactiveSessionRepository . Each store has specific additional settings. For instance, it is possible to customize the name of the table for the JDBC store, as shown in the following example: Properties YAML spring.session.jdbc.table-name=SESSIONS spring: session: jdbc: table-name: ""SESSIONS"" For setting the timeout of the session you can use the spring.session.timeout property. If that property is not set with a servlet web application, the auto-configuration falls back to the value of server.servlet.session.timeout . You can take control over Spring Session’s configuration using @Enable*HttpSession (servlet) or @Enable*WebSession (reactive). This will cause the auto-configuration to back off. Spring Session can then be configured using the annotation’s attributes rather than the previously described configuration properties."
"https://docs.spring.io/spring-boot/reference/web/spring-graphql.html","Spring for GraphQL: If you want to build GraphQL applications, you can take advantage of Spring Boot’s auto-configuration for Spring for GraphQL(https://spring.io/projects/spring-graphql) . The Spring for GraphQL project is based on GraphQL Java(https://github.com/graphql-java/graphql-java) . You’ll need the spring-boot-starter-graphql starter at a minimum. Because GraphQL is transport-agnostic, you’ll also need to have one or more additional starters in your application to expose your GraphQL API over the web: Starter Transport Implementation spring-boot-starter-web HTTP Spring MVC spring-boot-starter-websocket WebSocket WebSocket for Servlet apps spring-boot-starter-webflux HTTP, WebSocket Spring WebFlux spring-boot-starter-rsocket TCP, WebSocket Spring WebFlux on Reactor Netty GraphQL Schema: A Spring GraphQL application requires a defined schema at startup. By default, you can write "".graphqls"" or "".gqls"" schema files under src/main/resources/graphql/** and Spring Boot will pick them up automatically. You can customize the locations with spring.graphql.schema.locations and the file extensions with spring.graphql.schema.file-extensions . If you want Spring Boot to detect schema files in all your application modules and dependencies for that location, you can set spring.graphql.schema.locations to ""classpath*:graphql/**/"" (note the classpath*: prefix). In the following sections, we’ll consider this sample GraphQL schema, defining two types and two queries: type Query { greeting(name: String! = ""Spring""): String! project(slug: ID!): Project } """""" A Project in the Spring portfolio """""" type Project { """""" Unique string id used in URLs """""" slug: ID! """""" Project name """""" name: String! """""" URL of the git repository """""" repositoryUrl: String! """""" Current support status """""" status: ProjectStatus! } enum ProjectStatus { """""" Actively supported by the Spring team """""" ACTIVE """""" Supported by the community """""" COMMUNITY """""" Prototype, not officially supported yet """""" INCUBATING """""" Project being retired, in maintenance mode """""" ATTIC """""" End-Of-Lifed """""" EOL } By default, field introspection(https://spec.graphql.org/draft/#sec-Introspection) will be allowed on the schema as it is required for tools such as GraphiQL. If you wish to not expose information about the schema, you can disable introspection by setting spring.graphql.schema.introspection.enabled to false . GraphQL RuntimeWiring: The GraphQL Java RuntimeWiring.Builder can be used to register custom scalar types, directives, type resolvers, DataFetcher , and more. You can declare RuntimeWiringConfigurer beans in your Spring config to get access to the RuntimeWiring.Builder . Spring Boot detects such beans and adds them to the GraphQlSource builder(https://docs.spring.io/spring-graphql/reference/1.3/request-execution.html#execution.graphqlsource) . Typically, however, applications will not implement DataFetcher directly and will instead create annotated controllers(https://docs.spring.io/spring-graphql/reference/1.3/controllers.html) . Spring Boot will automatically detect @Controller classes with annotated handler methods and register those as DataFetcher s. Here’s a sample implementation for our greeting query with a @Controller class: Java Kotlin import org.springframework.graphql.data.method.annotation.Argument; import org.springframework.graphql.data.method.annotation.QueryMapping; import org.springframework.stereotype.Controller; @Controller public class GreetingController { @QueryMapping public String greeting(@Argument String name) { return ""Hello, "" + name + ""!""; } } import org.springframework.graphql.data.method.annotation.Argument import org.springframework.graphql.data.method.annotation.QueryMapping import org.springframework.stereotype.Controller @Controller class GreetingController { @QueryMapping fun greeting(@Argument name: String): String { return ""Hello, $name!"" } } Querydsl and QueryByExample Repositories Support: Spring Data offers support for both Querydsl and QueryByExample repositories. Spring GraphQL can configure Querydsl and QueryByExample repositories as DataFetcher(https://docs.spring.io/spring-graphql/reference/1.3/data.html) . Spring Data repositories annotated with @GraphQlRepository and extending one of: QuerydslPredicateExecutor ReactiveQuerydslPredicateExecutor QueryByExampleExecutor ReactiveQueryByExampleExecutor are detected by Spring Boot and considered as candidates for DataFetcher for matching top-level queries. Transports: HTTP and WebSocket: The GraphQL HTTP endpoint is at HTTP POST /graphql by default. It also supports the ""text/event-stream"" media type over Server Sent Events for subscriptions only. The path can be customized with spring.graphql.path . The HTTP endpoint for both Spring MVC and Spring WebFlux is provided by a RouterFunction bean with an @Order of 0 . If you define your own RouterFunction beans, you may want to add appropriate @Order annotations to ensure that they are sorted correctly. The GraphQL WebSocket endpoint is off by default. To enable it: For a Servlet application, add the WebSocket starter spring-boot-starter-websocket For a WebFlux application, no additional dependency is required For both, the spring.graphql.websocket.path application property must be set Spring GraphQL provides a Web Interception(https://docs.spring.io/spring-graphql/reference/1.3/transports.html#server.interception) model. This is quite useful for retrieving information from an HTTP request header and set it in the GraphQL context or fetching information from the same context and writing it to a response header. With Spring Boot, you can declare a WebInterceptor bean to have it registered with the web transport. Spring MVC(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc-cors.html) and Spring WebFlux(https://docs.spring.io/spring-framework/reference/6.1/web/webflux-cors.html) support CORS (Cross-Origin Resource Sharing) requests. CORS is a critical part of the web config for GraphQL applications that are accessed from browsers using different domains. Spring Boot supports many configuration properties under the spring.graphql.cors.* namespace; here’s a short configuration sample: Properties YAML spring.graphql.cors.allowed-origins=https://example.org spring.graphql.cors.allowed-methods=GET,POST spring.graphql.cors.max-age=1800s spring: graphql: cors: allowed-origins: ""https://example.org"" allowed-methods: GET,POST max-age: 1800s RSocket: RSocket is also supported as a transport, on top of WebSocket or TCP. Once the RSocket server is configured(../messaging/rsocket.html#messaging.rsocket.server-auto-configuration) , we can configure our GraphQL handler on a particular route using spring.graphql.rsocket.mapping . For example, configuring that mapping as ""graphql"" means we can use that as a route when sending requests with the RSocketGraphQlClient . Spring Boot auto-configures a RSocketGraphQlClient.Builder<?> bean that you can inject in your components: Java Kotlin @Component public class RSocketGraphQlClientExample { private final RSocketGraphQlClient graphQlClient; public RSocketGraphQlClientExample(RSocketGraphQlClient.Builder<?> builder) { this.graphQlClient = builder.tcp(""example.spring.io"", 8181).route(""graphql"").build(); } @Component class RSocketGraphQlClientExample(private val builder: RSocketGraphQlClient.Builder<*>) { And then send a request: include-code::RSocketGraphQlClientExample[tag=request] Exception Handling: Spring GraphQL enables applications to register one or more Spring DataFetcherExceptionResolver components that are invoked sequentially. The Exception must be resolved to a list of graphql.GraphQLError objects, see Spring GraphQL exception handling documentation(https://docs.spring.io/spring-graphql/reference/1.3/controllers.html#controllers.exception-handler) . Spring Boot will automatically detect DataFetcherExceptionResolver beans and register them with the GraphQlSource.Builder . GraphiQL and Schema Printer: Spring GraphQL offers infrastructure for helping developers when consuming or developing a GraphQL API. Spring GraphQL ships with a default GraphiQL(https://github.com/graphql/graphiql) page that is exposed at ""/graphiql"" by default. This page is disabled by default and can be turned on with the spring.graphql.graphiql.enabled property. Many applications exposing such a page will prefer a custom build. A default implementation is very useful during development, this is why it is exposed automatically with spring-boot-devtools(../using/devtools.html) during development. You can also choose to expose the GraphQL schema in text format at /graphql/schema when the spring.graphql.schema.printer.enabled property is enabled."
"https://docs.spring.io/spring-boot/reference/web/spring-hateoas.html","Spring HATEOAS: If you develop a RESTful API that makes use of hypermedia, Spring Boot provides auto-configuration for Spring HATEOAS that works well with most applications. The auto-configuration replaces the need to use @EnableHypermediaSupport and registers a number of beans to ease building hypermedia-based applications, including a LinkDiscoverers (for client side support) and an ObjectMapper configured to correctly marshal responses into the desired representation. The ObjectMapper is customized by setting the various spring.jackson.* properties or, if one exists, by a Jackson2ObjectMapperBuilder bean. You can take control of Spring HATEOAS’s configuration by using @EnableHypermediaSupport . Note that doing so disables the ObjectMapper customization described earlier. spring-boot-starter-hateoas is specific to Spring MVC and should not be combined with Spring WebFlux. In order to use Spring HATEOAS with Spring WebFlux, you can add a direct dependency on org.springframework.hateoas:spring-hateoas along with spring-boot-starter-webflux . By default, requests that accept application/json will receive an application/hal+json response. To disable this behavior set spring.hateoas.use-hal-as-default-json-media-type to false and define a HypermediaMappingInformation or HalConfiguration to configure Spring HATEOAS to meet the needs of your application and its clients."
"https://docs.spring.io/spring-boot/reference/data/index.html","Data: Spring Boot integrates with a number of data technologies, both SQL and NoSQL."
"https://docs.spring.io/spring-boot/reference/data/sql.html","SQL Databases: The Spring Framework(https://spring.io/projects/spring-framework) provides extensive support for working with SQL databases, from direct JDBC access using JdbcClient or JdbcTemplate to complete “object relational mapping” technologies such as Hibernate. Spring Data(https://spring.io/projects/spring-data) provides an additional level of functionality: creating Repository implementations directly from interfaces and using conventions to generate queries from your method names. Configure a DataSource: Java’s javax.sql.DataSource interface provides a standard method of working with database connections. Traditionally, a DataSource uses a URL along with some credentials to establish a database connection. See the Configure a Custom DataSource(../../how-to/data-access.html#howto.data-access.configure-custom-datasource) section of the “How-to Guides” for more advanced examples, typically to take full control over the configuration of the DataSource. Embedded Database Support: It is often convenient to develop applications by using an in-memory embedded database. Obviously, in-memory databases do not provide persistent storage. You need to populate your database when your application starts and be prepared to throw away data when your application ends. The “How-to Guides” section includes a section on how to initialize a database(../../how-to/data-initialization.html) . Spring Boot can auto-configure embedded H2(https://www.h2database.com) , HSQL(https://hsqldb.org/) , and Derby(https://db.apache.org/derby/) databases. You need not provide any connection URLs. You need only include a build dependency to the embedded database that you want to use. If there are multiple embedded databases on the classpath, set the spring.datasource.embedded-database-connection configuration property to control which one is used. Setting the property to none disables auto-configuration of an embedded database. If you are using this feature in your tests, you may notice that the same database is reused by your whole test suite regardless of the number of application contexts that you use. If you want to make sure that each context has a separate embedded database, you should set spring.datasource.generate-unique-name to true . For example, the typical POM dependencies would be as follows: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> <dependency> <groupId>org.hsqldb</groupId> <artifactId>hsqldb</artifactId> <scope>runtime</scope> </dependency> You need a dependency on spring-jdbc for an embedded database to be auto-configured. In this example, it is pulled in transitively through spring-boot-starter-data-jpa . If, for whatever reason, you do configure the connection URL for an embedded database, take care to ensure that the database’s automatic shutdown is disabled. If you use H2, you should use DB_CLOSE_ON_EXIT=FALSE to do so. If you use HSQLDB, you should ensure that shutdown=true is not used. Disabling the database’s automatic shutdown lets Spring Boot control when the database is closed, thereby ensuring that it happens once access to the database is no longer needed. Connection to a Production Database: Production database connections can also be auto-configured by using a pooling DataSource . DataSource Configuration: DataSource configuration is controlled by external configuration properties in spring.datasource.* . For example, you might declare the following section in application.properties : Properties YAML spring.datasource.url=jdbc:mysql://localhost/test spring.datasource.username=dbuser spring.datasource.password=dbpass spring: datasource: url: ""jdbc:mysql://localhost/test"" username: ""dbuser"" password: ""dbpass"" You should at least specify the URL by setting the spring.datasource.url property. Otherwise, Spring Boot tries to auto-configure an embedded database. Spring Boot can deduce the JDBC driver class for most databases from the URL. If you need to specify a specific class, you can use the spring.datasource.driver-class-name property. For a pooling DataSource to be created, we need to be able to verify that a valid Driver class is available, so we check for that before doing anything. In other words, if you set spring.datasource.driver-class-name=com.mysql.jdbc.Driver , then that class has to be loadable. See DataSourceProperties(../../api/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.html) API documentation for more of the supported options. These are the standard options that work regardless of the actual implementation(#data.sql.datasource.connection-pool) . It is also possible to fine-tune implementation-specific settings by using their respective prefix ( spring.datasource.hikari.* , spring.datasource.tomcat.* , spring.datasource.dbcp2.* , and spring.datasource.oracleucp.* ). See the documentation of the connection pool implementation you are using for more details. For instance, if you use the Tomcat connection pool(https://tomcat.apache.org/tomcat-10.1-doc/jdbc-pool.html#Common_Attributes) , you could customize many additional settings, as shown in the following example: Properties YAML spring.datasource.tomcat.max-wait=10000 spring.datasource.tomcat.max-active=50 spring.datasource.tomcat.test-on-borrow=true spring: datasource: tomcat: max-wait: 10000 max-active: 50 test-on-borrow: true This will set the pool to wait 10000ms before throwing an exception if no connection is available, limit the maximum number of connections to 50 and validate the connection before borrowing it from the pool. Supported Connection Pools: Spring Boot uses the following algorithm for choosing a specific implementation: We prefer HikariCP(https://github.com/brettwooldridge/HikariCP) for its performance and concurrency. If HikariCP is available, we always choose it. Otherwise, if the Tomcat pooling DataSource is available, we use it. Otherwise, if Commons DBCP2(https://commons.apache.org/proper/commons-dbcp/) is available, we use it. If none of HikariCP, Tomcat, and DBCP2 are available and if Oracle UCP is available, we use it. If you use the spring-boot-starter-jdbc or spring-boot-starter-data-jpa starters, you automatically get a dependency to HikariCP . You can bypass that algorithm completely and specify the connection pool to use by setting the spring.datasource.type property. This is especially important if you run your application in a Tomcat container, as tomcat-jdbc is provided by default. Additional connection pools can always be configured manually, using DataSourceBuilder . If you define your own DataSource bean, auto-configuration does not occur. The following connection pools are supported by DataSourceBuilder : HikariCP Tomcat pooling DataSource Commons DBCP2 Oracle UCP & OracleDataSource Spring Framework’s SimpleDriverDataSource H2 JdbcDataSource PostgreSQL PGSimpleDataSource C3P0 Connection to a JNDI DataSource: If you deploy your Spring Boot application to an Application Server, you might want to configure and manage your DataSource by using your Application Server’s built-in features and access it by using JNDI. The spring.datasource.jndi-name property can be used as an alternative to the spring.datasource.url , spring.datasource.username , and spring.datasource.password properties to access the DataSource from a specific JNDI location. For example, the following section in application.properties shows how you can access a JBoss AS defined DataSource : Properties YAML spring.datasource.jndi-name=java:jboss/datasources/customers spring: datasource: jndi-name: ""java:jboss/datasources/customers"" Using JdbcTemplate: Spring’s JdbcTemplate and NamedParameterJdbcTemplate classes are auto-configured, and you can @Autowire them directly into your own beans, as shown in the following example: Java Kotlin import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Component; @Component public class MyBean { private final JdbcTemplate jdbcTemplate; public MyBean(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } public void doSomething() { this.jdbcTemplate ... } } import org.springframework.jdbc.core.JdbcTemplate import org.springframework.stereotype.Component @Component class MyBean(private val jdbcTemplate: JdbcTemplate) { fun doSomething() { jdbcTemplate.execute(""delete from customer"") } } You can customize some properties of the template by using the spring.jdbc.template.* properties, as shown in the following example: Properties YAML spring.jdbc.template.max-rows=500 spring: jdbc: template: max-rows: 500 The NamedParameterJdbcTemplate reuses the same JdbcTemplate instance behind the scenes. If more than one JdbcTemplate is defined and no primary candidate exists, the NamedParameterJdbcTemplate is not auto-configured. Using JdbcClient: Spring’s JdbcClient is auto-configured based on the presence of a NamedParameterJdbcTemplate . You can inject it directly in your own beans as well, as shown in the following example: Java Kotlin import org.springframework.jdbc.core.simple.JdbcClient; import org.springframework.stereotype.Component; @Component public class MyBean { private final JdbcClient jdbcClient; public MyBean(JdbcClient jdbcClient) { this.jdbcClient = jdbcClient; } public void doSomething() { this.jdbcClient ... } } import org.springframework.jdbc.core.simple.JdbcClient import org.springframework.stereotype.Component @Component class MyBean(private val jdbcClient: JdbcClient) { fun doSomething() { jdbcClient.sql(""delete from customer"").update() } } If you rely on auto-configuration to create the underlying JdbcTemplate , any customization using spring.jdbc.template.* properties is taken into account in the client as well. JPA and Spring Data JPA: The Java Persistence API is a standard technology that lets you “map” objects to relational databases. The spring-boot-starter-data-jpa POM provides a quick way to get started. It provides the following key dependencies: Hibernate: One of the most popular JPA implementations. Spring Data JPA: Helps you to implement JPA-based repositories. Spring ORM: Core ORM support from the Spring Framework. We do not go into too many details of JPA or Spring Data(https://spring.io/projects/spring-data) here. You can follow the Accessing Data with JPA(https://spring.io/guides/gs/accessing-data-jpa/) guide from spring.io(https://spring.io) and read the Spring Data JPA(https://spring.io/projects/spring-jpa) and Hibernate(https://hibernate.org/orm/documentation/) reference documentation. Entity Classes: Traditionally, JPA “Entity” classes are specified in a persistence.xml file. With Spring Boot, this file is not necessary and “Entity Scanning” is used instead. By default the auto-configuration packages(../using/auto-configuration.html#using.auto-configuration.packages) are scanned. Any classes annotated with @Entity , @Embeddable , or @MappedSuperclass are considered. A typical entity class resembles the following example: Java Kotlin import java.io.Serializable; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.Id; @Entity public class City implements Serializable { @Id @GeneratedValue private Long id; @Column(nullable = false) private String name; @Column(nullable = false) private String state; // ... additional members, often include @OneToMany mappings protected City() { // no-args constructor required by JPA spec // this one is protected since it should not be used directly } public City(String name, String state) { this.name = name; this.state = state; } public String getName() { return this.name; } public String getState() { return this.state; } // ... etc } import jakarta.persistence.Column import jakarta.persistence.Entity import jakarta.persistence.GeneratedValue import jakarta.persistence.Id import java.io.Serializable @Entity class City : Serializable { @Id @GeneratedValue private val id: Long? = null @Column(nullable = false) var name: String? = null private set // ... etc @Column(nullable = false) var state: String? = null private set // ... additional members, often include @OneToMany mappings protected constructor() { // no-args constructor required by JPA spec // this one is protected since it should not be used directly } constructor(name: String?, state: String?) { this.name = name this.state = state } } You can customize entity scanning locations by using the @EntityScan annotation. See the Separate @Entity Definitions from Spring Configuration(../../how-to/data-access.html#howto.data-access.separate-entity-definitions-from-spring-configuration) section of the “How-to Guides”. Spring Data JPA Repositories: Spring Data JPA(https://spring.io/projects/spring-jpa) repositories are interfaces that you can define to access data. JPA queries are created automatically from your method names. For example, a CityRepository interface might declare a findAllByState(String state) method to find all the cities in a given state. For more complex queries, you can annotate your method with Spring Data’s Query(https://docs.spring.io/spring-data/jpa/docs/3.3.x/api/org/springframework/data/jpa/repository/Query.html) annotation. Spring Data repositories usually extend from the Repository(https://docs.spring.io/spring-data/commons/docs/3.3.x/api/org/springframework/data/repository/Repository.html) or CrudRepository(https://docs.spring.io/spring-data/commons/docs/3.3.x/api/org/springframework/data/repository/CrudRepository.html) interfaces. If you use auto-configuration, the auto-configuration packages(../using/auto-configuration.html#using.auto-configuration.packages) are searched for repositories. You can customize the locations to look for repositories using @EnableJpaRepositories . The following example shows a typical Spring Data repository interface definition: Java Kotlin import org.springframework.boot.docs.data.sql.jpaandspringdata.entityclasses.City; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.repository.Repository; public interface CityRepository extends Repository<City, Long> { Page<City> findAll(Pageable pageable); City findByNameAndStateAllIgnoringCase(String name, String state); } import org.springframework.boot.docs.data.sql.jpaandspringdata.entityclasses.City import org.springframework.data.domain.Page import org.springframework.data.domain.Pageable import org.springframework.data.repository.Repository interface CityRepository : Repository<City?, Long?> { fun findAll(pageable: Pageable?): Page<City?>? fun findByNameAndStateAllIgnoringCase(name: String?, state: String?): City? } Spring Data JPA repositories support three different modes of bootstrapping: default, deferred, and lazy. To enable deferred or lazy bootstrapping, set the spring.data.jpa.repositories.bootstrap-mode property to deferred or lazy respectively. When using deferred or lazy bootstrapping, the auto-configured EntityManagerFactoryBuilder will use the context’s AsyncTaskExecutor , if any, as the bootstrap executor. If more than one exists, the one named applicationTaskExecutor will be used. When using deferred or lazy bootstrapping, make sure to defer any access to the JPA infrastructure after the application context bootstrap phase. You can use SmartInitializingSingleton to invoke any initialization that requires the JPA infrastructure. For JPA components (such as converters) that are created as Spring beans, use ObjectProvider to delay the resolution of dependencies, if any. We have barely scratched the surface of Spring Data JPA. For complete details, see the Spring Data JPA reference documentation(https://docs.spring.io/spring-data/jpa/reference/3.3) . Spring Data Envers Repositories: If Spring Data Envers(https://spring.io/projects/spring-data-envers) is available, JPA repositories are auto-configured to support typical Envers queries. To use Spring Data Envers, make sure your repository extends from RevisionRepository as shown in the following example: Java Kotlin import org.springframework.boot.docs.data.sql.jpaandspringdata.entityclasses.Country; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.repository.Repository; import org.springframework.data.repository.history.RevisionRepository; public interface CountryRepository extends RevisionRepository<Country, Long, Integer>, Repository<Country, Long> { Page<Country> findAll(Pageable pageable); } import org.springframework.boot.docs.data.sql.jpaandspringdata.entityclasses.Country import org.springframework.data.domain.Page import org.springframework.data.domain.Pageable import org.springframework.data.repository.Repository import org.springframework.data.repository.history.RevisionRepository interface CountryRepository : RevisionRepository<Country?, Long?, Int>, Repository<Country?, Long?> { fun findAll(pageable: Pageable?): Page<Country?>? } For more details, check the Spring Data Envers reference documentation(https://docs.spring.io/spring-data/jpa/reference/3.3/envers.html) . Creating and Dropping JPA Databases: By default, JPA databases are automatically created only if you use an embedded database (H2, HSQL, or Derby). You can explicitly configure JPA settings by using spring.jpa.* properties. For example, to create and drop tables you can add the following line to your application.properties : Properties YAML spring.jpa.hibernate.ddl-auto=create-drop spring: jpa: hibernate.ddl-auto: ""create-drop"" Hibernate’s own internal property name for this (if you happen to remember it better) is hibernate.hbm2ddl.auto . You can set it, along with other Hibernate native properties, by using spring.jpa.properties.* (the prefix is stripped before adding them to the entity manager). The following line shows an example of setting JPA properties for Hibernate: Properties YAML spring.jpa.properties.hibernate.globally_quoted_identifiers=true spring: jpa: properties: hibernate: ""globally_quoted_identifiers"": ""true"" The line in the preceding example passes a value of true for the hibernate.globally_quoted_identifiers property to the Hibernate entity manager. By default, the DDL execution (or validation) is deferred until the ApplicationContext has started. Open EntityManager in View: If you are running a web application, Spring Boot by default registers OpenEntityManagerInViewInterceptor(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html) to apply the “Open EntityManager in View” pattern, to allow for lazy loading in web views. If you do not want this behavior, you should set spring.jpa.open-in-view to false in your application.properties . Spring Data JDBC: Spring Data includes repository support for JDBC and will automatically generate SQL for the methods on CrudRepository . For more advanced queries, a @Query annotation is provided. Spring Boot will auto-configure Spring Data’s JDBC repositories when the necessary dependencies are on the classpath. They can be added to your project with a single dependency on spring-boot-starter-data-jdbc . If necessary, you can take control of Spring Data JDBC’s configuration by adding the @EnableJdbcRepositories annotation or an AbstractJdbcConfiguration subclass to your application. For complete details of Spring Data JDBC, see the reference documentation(https://docs.spring.io/spring-data/relational/reference/3.3) . Using H2’s Web Console: The H2 database(https://www.h2database.com) provides a browser-based console(https://www.h2database.com/html/quickstart.html#h2_console) that Spring Boot can auto-configure for you. The console is auto-configured when the following conditions are met: You are developing a servlet-based web application. com.h2database:h2 is on the classpath. You are using Spring Boot’s developer tools(../using/devtools.html) . If you are not using Spring Boot’s developer tools but would still like to make use of H2’s console, you can configure the spring.h2.console.enabled property with a value of true . The H2 console is only intended for use during development, so you should take care to ensure that spring.h2.console.enabled is not set to true in production. Changing the H2 Console’s Path: By default, the console is available at /h2-console . You can customize the console’s path by using the spring.h2.console.path property. Accessing the H2 Console in a Secured Application: H2 Console uses frames and, as it is intended for development only, does not implement CSRF protection measures. If your application uses Spring Security, you need to configure it to disable CSRF protection for requests against the console, set the header X-Frame-Options to SAMEORIGIN on responses from the console. More information on CSRF(https://docs.spring.io/spring-security/reference/6.3/features/exploits/csrf.html) and the header X-Frame-Options(https://docs.spring.io/spring-security/reference/6.3/features/exploits/headers.html#headers-frame-options) can be found in the Spring Security Reference Guide. In simple setups, a SecurityFilterChain like the following can be used: Java Kotlin import org.springframework.boot.autoconfigure.security.servlet.PathRequest; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; import org.springframework.core.Ordered; import org.springframework.core.annotation.Order; import org.springframework.security.config.Customizer; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configurers.CsrfConfigurer; import org.springframework.security.config.annotation.web.configurers.HeadersConfigurer.FrameOptionsConfig; import org.springframework.security.web.SecurityFilterChain; @Profile(""dev"") @Configuration(proxyBeanMethods = false) public class DevProfileSecurityConfiguration { @Bean @Order(Ordered.HIGHEST_PRECEDENCE) SecurityFilterChain h2ConsoleSecurityFilterChain(HttpSecurity http) throws Exception { http.securityMatcher(PathRequest.toH2Console()); http.authorizeHttpRequests(yourCustomAuthorization()); http.csrf(CsrfConfigurer::disable); http.headers((headers) -> headers.frameOptions(FrameOptionsConfig::sameOrigin)); return http.build(); } } import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.context.annotation.Profile import org.springframework.core.Ordered import org.springframework.core.annotation.Order import org.springframework.security.config.Customizer import org.springframework.security.config.annotation.web.builders.HttpSecurity import org.springframework.security.web.SecurityFilterChain @Profile(""dev"") @Configuration(proxyBeanMethods = false) class DevProfileSecurityConfiguration { @Bean @Order(Ordered.HIGHEST_PRECEDENCE) fun h2ConsoleSecurityFilterChain(http: HttpSecurity): SecurityFilterChain { return http.authorizeHttpRequests(yourCustomAuthorization()) .csrf { csrf -> csrf.disable() } .headers { headers -> headers.frameOptions { frameOptions -> frameOptions.sameOrigin() } } .build() } } The H2 console is only intended for use during development. In production, disabling CSRF protection or allowing frames for a website may create severe security risks. PathRequest.toH2Console() returns the correct request matcher also when the console’s path has been customized. Using jOOQ: jOOQ Object Oriented Querying ( jOOQ(https://www.jooq.org/) ) is a popular product from Data Geekery(https://www.datageekery.com/) which generates Java code from your database and lets you build type-safe SQL queries through its fluent API. Both the commercial and open source editions can be used with Spring Boot. Code Generation: In order to use jOOQ type-safe queries, you need to generate Java classes from your database schema. You can follow the instructions in the jOOQ user manual(https://www.jooq.org/doc/3.19.11/manual-single-page/#jooq-in-7-steps-step3) . If you use the jooq-codegen-maven plugin and you also use the spring-boot-starter-parent “parent POM”, you can safely omit the plugin’s <version> tag. You can also use Spring Boot-defined version variables (such as h2.version ) to declare the plugin’s database dependency. The following listing shows an example: <plugin> <groupId>org.jooq</groupId> <artifactId>jooq-codegen-maven</artifactId> <executions> ... </executions> <dependencies> <dependency> <groupId>com.h2database</groupId> <artifactId>h2</artifactId> <version>${h2.version}</version> </dependency> </dependencies> <configuration> <jdbc> <driver>org.h2.Driver</driver> <url>jdbc:h2:~/yourdatabase</url> </jdbc> <generator> ... </generator> </configuration> </plugin> Using DSLContext: The fluent API offered by jOOQ is initiated through the org.jooq.DSLContext interface. Spring Boot auto-configures a DSLContext as a Spring Bean and connects it to your application DataSource . To use the DSLContext , you can inject it, as shown in the following example: Java Kotlin import java.util.GregorianCalendar; import java.util.List; import org.jooq.DSLContext; import org.springframework.stereotype.Component; import static org.springframework.boot.docs.data.sql.jooq.dslcontext.Tables.AUTHOR; @Component public class MyBean { private final DSLContext create; public MyBean(DSLContext dslContext) { this.create = dslContext; } } import org.jooq.DSLContext import org.springframework.stereotype.Component import java.util.GregorianCalendar @Component class MyBean(private val create: DSLContext) { } The jOOQ manual tends to use a variable named create to hold the DSLContext . You can then use the DSLContext to construct your queries, as shown in the following example: Java Kotlin public List<GregorianCalendar> authorsBornAfter1980() { return this.create.selectFrom(AUTHOR) .where(AUTHOR.DATE_OF_BIRTH.greaterThan(new GregorianCalendar(1980, 0, 1))) .fetch(AUTHOR.DATE_OF_BIRTH); fun authorsBornAfter1980(): List<GregorianCalendar> { return create.selectFrom<Tables.TAuthorRecord>(Tables.AUTHOR) .where(Tables.AUTHOR?.DATE_OF_BIRTH?.greaterThan(GregorianCalendar(1980, 0, 1))) .fetch(Tables.AUTHOR?.DATE_OF_BIRTH) } jOOQ SQL Dialect: Unless the spring.jooq.sql-dialect property has been configured, Spring Boot determines the SQL dialect to use for your datasource. If Spring Boot could not detect the dialect, it uses DEFAULT . Spring Boot can only auto-configure dialects supported by the open source version of jOOQ. Customizing jOOQ: More advanced customizations can be achieved by defining your own DefaultConfigurationCustomizer bean that will be invoked prior to creating the org.jooq.Configuration @Bean . This takes precedence to anything that is applied by the auto-configuration. You can also create your own org.jooq.Configuration @Bean if you want to take complete control of the jOOQ configuration. Using R2DBC: The Reactive Relational Database Connectivity ( R2DBC(https://r2dbc.io) ) project brings reactive programming APIs to relational databases. R2DBC’s io.r2dbc.spi.Connection provides a standard method of working with non-blocking database connections. Connections are provided by using a ConnectionFactory , similar to a DataSource with jdbc. ConnectionFactory configuration is controlled by external configuration properties in spring.r2dbc.* . For example, you might declare the following section in application.properties : Properties YAML spring.r2dbc.url=r2dbc:postgresql://localhost/test spring.r2dbc.username=dbuser spring.r2dbc.password=dbpass spring: r2dbc: url: ""r2dbc:postgresql://localhost/test"" username: ""dbuser"" password: ""dbpass"" You do not need to specify a driver class name, since Spring Boot obtains the driver from R2DBC’s Connection Factory discovery. At least the url should be provided. Information specified in the URL takes precedence over individual properties, that is name , username , password and pooling options. The “How-to Guides” section includes a section on how to initialize a database(../../how-to/data-initialization.html#howto.data-initialization.using-basic-sql-scripts) . To customize the connections created by a ConnectionFactory , that is, set specific parameters that you do not want (or cannot) configure in your central database configuration, you can use a ConnectionFactoryOptionsBuilderCustomizer @Bean . The following example shows how to manually override the database port while the rest of the options are taken from the application configuration: Java Kotlin import io.r2dbc.spi.ConnectionFactoryOptions; import org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryOptionsBuilderCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyR2dbcConfiguration { @Bean public ConnectionFactoryOptionsBuilderCustomizer connectionFactoryPortCustomizer() { return (builder) -> builder.option(ConnectionFactoryOptions.PORT, 5432); } } import io.r2dbc.spi.ConnectionFactoryOptions import org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryOptionsBuilderCustomizer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyR2dbcConfiguration { @Bean fun connectionFactoryPortCustomizer(): ConnectionFactoryOptionsBuilderCustomizer { return ConnectionFactoryOptionsBuilderCustomizer { builder -> builder.option(ConnectionFactoryOptions.PORT, 5432) } } } The following examples show how to set some PostgreSQL connection options: Java Kotlin import java.util.HashMap; import java.util.Map; import io.r2dbc.postgresql.PostgresqlConnectionFactoryProvider; import org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryOptionsBuilderCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyPostgresR2dbcConfiguration { @Bean public ConnectionFactoryOptionsBuilderCustomizer postgresCustomizer() { Map<String, String> options = new HashMap<>(); options.put(""lock_timeout"", ""30s""); options.put(""statement_timeout"", ""60s""); return (builder) -> builder.option(PostgresqlConnectionFactoryProvider.OPTIONS, options); } } import io.r2dbc.postgresql.PostgresqlConnectionFactoryProvider import org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryOptionsBuilderCustomizer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyPostgresR2dbcConfiguration { @Bean fun postgresCustomizer(): ConnectionFactoryOptionsBuilderCustomizer { val options: MutableMap<String, String> = HashMap() options[""lock_timeout""] = ""30s"" options[""statement_timeout""] = ""60s"" return ConnectionFactoryOptionsBuilderCustomizer { builder -> builder.option(PostgresqlConnectionFactoryProvider.OPTIONS, options) } } } When a ConnectionFactory bean is available, the regular JDBC DataSource auto-configuration backs off. If you want to retain the JDBC DataSource auto-configuration, and are comfortable with the risk of using the blocking JDBC API in a reactive application, add @Import(DataSourceAutoConfiguration.class) on a @Configuration class in your application to re-enable it. Embedded Database Support: Similarly to the JDBC support(#data.sql.datasource.embedded) , Spring Boot can automatically configure an embedded database for reactive usage. You need not provide any connection URLs. You need only include a build dependency to the embedded database that you want to use, as shown in the following example: <dependency> <groupId>io.r2dbc</groupId> <artifactId>r2dbc-h2</artifactId> <scope>runtime</scope> </dependency> If you are using this feature in your tests, you may notice that the same database is reused by your whole test suite regardless of the number of application contexts that you use. If you want to make sure that each context has a separate embedded database, you should set spring.r2dbc.generate-unique-name to true . Using DatabaseClient: A DatabaseClient bean is auto-configured, and you can @Autowire it directly into your own beans, as shown in the following example: Java Kotlin import java.util.Map; import reactor.core.publisher.Flux; import org.springframework.r2dbc.core.DatabaseClient; import org.springframework.stereotype.Component; @Component public class MyBean { private final DatabaseClient databaseClient; public MyBean(DatabaseClient databaseClient) { this.databaseClient = databaseClient; } // ... public Flux<Map<String, Object>> someMethod() { return this.databaseClient.sql(""select * from user"").fetch().all(); } } import org.springframework.r2dbc.core.DatabaseClient import org.springframework.stereotype.Component import reactor.core.publisher.Flux @Component class MyBean(private val databaseClient: DatabaseClient) { // ... fun someMethod(): Flux<Map<String, Any>> { return databaseClient.sql(""select * from user"").fetch().all() } } Spring Data R2DBC Repositories: Spring Data R2DBC(https://spring.io/projects/spring-data-r2dbc) repositories are interfaces that you can define to access data. Queries are created automatically from your method names. For example, a CityRepository interface might declare a findAllByState(String state) method to find all the cities in a given state. For more complex queries, you can annotate your method with Spring Data’s @Query(https://docs.spring.io/spring-data/r2dbc/docs/3.3.x/api/org/springframework/data/r2dbc/repository/Query.html) annotation. Spring Data repositories usually extend from the Repository(https://docs.spring.io/spring-data/commons/docs/3.3.x/api/org/springframework/data/repository/Repository.html) or CrudRepository(https://docs.spring.io/spring-data/commons/docs/3.3.x/api/org/springframework/data/repository/CrudRepository.html) interfaces. If you use auto-configuration, the auto-configuration packages(../using/auto-configuration.html#using.auto-configuration.packages) are searched for repositories. The following example shows a typical Spring Data repository interface definition: Java Kotlin import reactor.core.publisher.Mono; import org.springframework.data.repository.Repository; public interface CityRepository extends Repository<City, Long> { Mono<City> findByNameAndStateAllIgnoringCase(String name, String state); } import org.springframework.data.repository.Repository import reactor.core.publisher.Mono interface CityRepository : Repository<City?, Long?> { fun findByNameAndStateAllIgnoringCase(name: String?, state: String?): Mono<City?>? } We have barely scratched the surface of Spring Data R2DBC. For complete details, see the Spring Data R2DBC reference documentation(https://docs.spring.io/spring-data/relational/reference/3.3) ."
"https://docs.spring.io/spring-boot/reference/data/nosql.html","Working with NoSQL Technologies: Spring Data provides additional projects that help you access a variety of NoSQL technologies, including: Cassandra(https://spring.io/projects/spring-data-cassandra) Couchbase(https://spring.io/projects/spring-data-couchbase) Elasticsearch(https://spring.io/projects/spring-data-elasticsearch) GemFire(https://spring.io/projects/spring-data-gemfire) or Geode(https://spring.io/projects/spring-data-geode) LDAP(https://spring.io/projects/spring-data-ldap) MongoDB(https://spring.io/projects/spring-data-mongodb) Neo4J(https://spring.io/projects/spring-data-neo4j) Redis(https://spring.io/projects/spring-data-redis) Of these, Spring Boot provides auto-configuration for Cassandra, Couchbase, Elasticsearch, LDAP, MongoDB, Neo4J and Redis. Additionally, Spring Boot for Apache Geode(https://github.com/spring-projects/spring-boot-data-geode) provides auto-configuration for Apache Geode(https://docs.spring.io/spring-boot-data-geode-build/2.0.x/reference/html5#geode-repositories) . You can make use of the other projects, but you must configure them yourself. See the appropriate reference documentation at spring.io/projects/spring-data(https://spring.io/projects/spring-data) . Spring Boot also provides auto-configuration for the InfluxDB client but it is deprecated in favor of the new InfluxDB Java client(https://github.com/influxdata/influxdb-client-java) that provides its own Spring Boot integration. Redis: Redis(https://redis.io/) is a cache, message broker, and richly-featured key-value store. Spring Boot offers basic auto-configuration for the Lettuce(https://github.com/lettuce-io/lettuce-core/) and Jedis(https://github.com/xetorthio/jedis/) client libraries and the abstractions on top of them provided by Spring Data Redis(https://github.com/spring-projects/spring-data-redis) . There is a spring-boot-starter-data-redis starter for collecting the dependencies in a convenient way. By default, it uses Lettuce(https://github.com/lettuce-io/lettuce-core/) . That starter handles both traditional and reactive applications. We also provide a spring-boot-starter-data-redis-reactive starter for consistency with the other stores with reactive support. Connecting to Redis: You can inject an auto-configured RedisConnectionFactory , StringRedisTemplate , or vanilla RedisTemplate instance as you would any other Spring Bean. The following listing shows an example of such a bean: Java Kotlin import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.stereotype.Component; @Component public class MyBean { private final StringRedisTemplate template; public MyBean(StringRedisTemplate template) { this.template = template; } // ... public Boolean someMethod() { return this.template.hasKey(""spring""); } } import org.springframework.data.redis.core.StringRedisTemplate import org.springframework.stereotype.Component @Component class MyBean(private val template: StringRedisTemplate) { // ... fun someMethod(): Boolean { return template.hasKey(""spring"") } } By default, the instance tries to connect to a Redis server at localhost:6379 . You can specify custom connection details using spring.data.redis.* properties, as shown in the following example: Properties YAML spring.data.redis.host=localhost spring.data.redis.port=6379 spring.data.redis.database=0 spring.data.redis.username=user spring.data.redis.password=secret spring: data: redis: host: ""localhost"" port: 6379 database: 0 username: ""user"" password: ""secret"" You can also specify the url of the Redis server directly. When setting the url, the host, port, username and password properties are ignored. This is shown in the following example: Properties YAML spring.data.redis.url=redis://user:secret@localhost:6379 spring.data.redis.database=0 spring: data: redis: url: ""redis://user:secret@localhost:6379"" database: 0 You can also register an arbitrary number of beans that implement LettuceClientConfigurationBuilderCustomizer for more advanced customizations. ClientResources can also be customized using ClientResourcesBuilderCustomizer . If you use Jedis, JedisClientConfigurationBuilderCustomizer is also available. Alternatively, you can register a bean of type RedisStandaloneConfiguration , RedisSentinelConfiguration , or RedisClusterConfiguration to take full control over the configuration. If you add your own @Bean of any of the auto-configured types, it replaces the default (except in the case of RedisTemplate , when the exclusion is based on the bean name, redisTemplate , not its type). By default, a pooled connection factory is auto-configured if commons-pool2 is on the classpath. The auto-configured RedisConnectionFactory can be configured to use SSL for communication with the server by setting the properties as shown in this example: Properties YAML spring.data.redis.ssl.enabled=true spring: data: redis: ssl: enabled: true Custom SSL trust material can be configured in an SSL bundle(../features/ssl.html) and applied to the RedisConnectionFactory as shown in this example: Properties YAML spring.data.redis.ssl.bundle=example spring: data: redis: ssl: bundle: ""example"" MongoDB: MongoDB(https://www.mongodb.com/) is an open-source NoSQL document database that uses a JSON-like schema instead of traditional table-based relational data. Spring Boot offers several conveniences for working with MongoDB, including the spring-boot-starter-data-mongodb and spring-boot-starter-data-mongodb-reactive starters. Connecting to a MongoDB Database: To access MongoDB databases, you can inject an auto-configured org.springframework.data.mongodb.MongoDatabaseFactory . By default, the instance tries to connect to a MongoDB server at mongodb://localhost/test . The following example shows how to connect to a MongoDB database: Java Kotlin import com.mongodb.client.MongoCollection; import com.mongodb.client.MongoDatabase; import org.bson.Document; import org.springframework.data.mongodb.MongoDatabaseFactory; import org.springframework.stereotype.Component; @Component public class MyBean { private final MongoDatabaseFactory mongo; public MyBean(MongoDatabaseFactory mongo) { this.mongo = mongo; } // ... public MongoCollection<Document> someMethod() { MongoDatabase db = this.mongo.getMongoDatabase(); return db.getCollection(""users""); } } import com.mongodb.client.MongoCollection import org.bson.Document import org.springframework.data.mongodb.MongoDatabaseFactory import org.springframework.stereotype.Component @Component class MyBean(private val mongo: MongoDatabaseFactory) { // ... fun someMethod(): MongoCollection<Document> { val db = mongo.mongoDatabase return db.getCollection(""users"") } } If you have defined your own MongoClient , it will be used to auto-configure a suitable MongoDatabaseFactory . The auto-configured MongoClient is created using a MongoClientSettings bean. If you have defined your own MongoClientSettings , it will be used without modification and the spring.data.mongodb properties will be ignored. Otherwise a MongoClientSettings will be auto-configured and will have the spring.data.mongodb properties applied to it. In either case, you can declare one or more MongoClientSettingsBuilderCustomizer beans to fine-tune the MongoClientSettings configuration. Each will be called in order with the MongoClientSettings.Builder that is used to build the MongoClientSettings . You can set the spring.data.mongodb.uri property to change the URL and configure additional settings such as the replica set , as shown in the following example: Properties YAML spring.data.mongodb.uri=mongodb://user: [email protected](/cdn-cgi/l/email-protection) :27017,mongoserver2.example.com:23456/test spring: data: mongodb: uri: ""mongodb://user: [email protected](/cdn-cgi/l/email-protection) :27017,mongoserver2.example.com:23456/test"" Alternatively, you can specify connection details using discrete properties. For example, you might declare the following settings in your application.properties : Properties YAML spring.data.mongodb.host=mongoserver1.example.com spring.data.mongodb.port=27017 spring.data.mongodb.additional-hosts[0]=mongoserver2.example.com:23456 spring.data.mongodb.database=test spring.data.mongodb.username=user spring.data.mongodb.password=secret spring: data: mongodb: host: ""mongoserver1.example.com"" port: 27017 additional-hosts: - ""mongoserver2.example.com:23456"" database: ""test"" username: ""user"" password: ""secret"" The auto-configured MongoClient can be configured to use SSL for communication with the server by setting the properties as shown in this example: Properties YAML spring.data.mongodb.uri=mongodb://user: [email protected](/cdn-cgi/l/email-protection) :27017,mongoserver2.example.com:23456/test spring.data.mongodb.ssl.enabled=true spring: data: mongodb: uri: ""mongodb://user: [email protected](/cdn-cgi/l/email-protection) :27017,mongoserver2.example.com:23456/test"" ssl: enabled: true Custom SSL trust material can be configured in an SSL bundle(../features/ssl.html) and applied to the MongoClient as shown in this example: Properties YAML spring.data.mongodb.uri=mongodb://user: [email protected](/cdn-cgi/l/email-protection) :27017,mongoserver2.example.com:23456/test spring.data.mongodb.ssl.bundle=example spring: data: mongodb: uri: ""mongodb://user: [email protected](/cdn-cgi/l/email-protection) :27017,mongoserver2.example.com:23456/test"" ssl: bundle: ""example"" If spring.data.mongodb.port is not specified, the default of 27017 is used. You could delete this line from the example shown earlier. You can also specify the port as part of the host address by using the host:port syntax. This format should be used if you need to change the port of an additional-hosts entry. If you do not use Spring Data MongoDB, you can inject a MongoClient bean instead of using MongoDatabaseFactory . If you want to take complete control of establishing the MongoDB connection, you can also declare your own MongoDatabaseFactory or MongoClient bean. If you are using the reactive driver, Netty is required for SSL. The auto-configuration configures this factory automatically if Netty is available and the factory to use has not been customized already. MongoTemplate: Spring Data MongoDB(https://spring.io/projects/spring-data-mongodb) provides a MongoTemplate(https://docs.spring.io/spring-data/mongodb/docs/4.3.x/api/org/springframework/data/mongodb/core/MongoTemplate.html) class that is very similar in its design to Spring’s JdbcTemplate . As with JdbcTemplate , Spring Boot auto-configures a bean for you to inject the template, as follows: Java Kotlin import com.mongodb.client.MongoCollection; import org.bson.Document; import org.springframework.data.mongodb.core.MongoTemplate; import org.springframework.stereotype.Component; @Component public class MyBean { private final MongoTemplate mongoTemplate; public MyBean(MongoTemplate mongoTemplate) { this.mongoTemplate = mongoTemplate; } // ... public MongoCollection<Document> someMethod() { return this.mongoTemplate.getCollection(""users""); } } import com.mongodb.client.MongoCollection import org.bson.Document import org.springframework.data.mongodb.core.MongoTemplate import org.springframework.stereotype.Component @Component class MyBean(private val mongoTemplate: MongoTemplate) { // ... fun someMethod(): MongoCollection<Document> { return mongoTemplate.getCollection(""users"") } } See the MongoOperations(https://docs.spring.io/spring-data/mongodb/docs/4.3.x/api/org/springframework/data/mongodb/core/MongoOperations.html) API documentation for complete details. Spring Data MongoDB Repositories: Spring Data includes repository support for MongoDB. As with the JPA repositories discussed earlier, the basic principle is that queries are constructed automatically, based on method names. In fact, both Spring Data JPA and Spring Data MongoDB share the same common infrastructure. You could take the JPA example from earlier and, assuming that City is now a MongoDB data class rather than a JPA @Entity , it works in the same way, as shown in the following example: Java Kotlin import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.repository.Repository; public interface CityRepository extends Repository<City, Long> { Page<City> findAll(Pageable pageable); City findByNameAndStateAllIgnoringCase(String name, String state); } import org.springframework.data.domain.Page import org.springframework.data.domain.Pageable import org.springframework.data.repository.Repository interface CityRepository : Repository<City?, Long?> { fun findAll(pageable: Pageable?): Page<City?>? fun findByNameAndStateAllIgnoringCase(name: String?, state: String?): City? } Repositories and documents are found through scanning. By default, the auto-configuration packages(../using/auto-configuration.html#using.auto-configuration.packages) are scanned. You can customize the locations to look for repositories and documents by using @EnableMongoRepositories and @EntityScan respectively. For complete details of Spring Data MongoDB, including its rich object mapping technologies, see its reference documentation(https://docs.spring.io/spring-data/mongodb/reference/4.3) . Neo4j: Neo4j(https://neo4j.com/) is an open-source NoSQL graph database that uses a rich data model of nodes connected by first class relationships, which is better suited for connected big data than traditional RDBMS approaches. Spring Boot offers several conveniences for working with Neo4j, including the spring-boot-starter-data-neo4j starter. Connecting to a Neo4j Database: To access a Neo4j server, you can inject an auto-configured org.neo4j.driver.Driver . By default, the instance tries to connect to a Neo4j server at localhost:7687 using the Bolt protocol. The following example shows how to inject a Neo4j Driver that gives you access, amongst other things, to a Session : Java Kotlin import org.neo4j.driver.Driver; import org.neo4j.driver.Session; import org.neo4j.driver.Values; import org.springframework.stereotype.Component; @Component public class MyBean { private final Driver driver; public MyBean(Driver driver) { this.driver = driver; } // ... public String someMethod(String message) { try (Session session = this.driver.session()) { return session.executeWrite( (transaction) -> transaction .run(""CREATE (a:Greeting) SET a.message = $message RETURN a.message + ', from node ' + id(a)"", Values.parameters(""message"", message)) .single() .get(0) .asString()); } } } import org.neo4j.driver.* import org.springframework.stereotype.Component @Component class MyBean(private val driver: Driver) { // ... fun someMethod(message: String?): String { driver.session().use { session -> return@someMethod session.executeWrite { transaction: TransactionContext -> transaction .run( ""CREATE (a:Greeting) SET a.message = \$message RETURN a.message + ', from node ' + id(a)"", Values.parameters(""message"", message) ) .single()[0].asString() } } } } You can configure various aspects of the driver using spring.neo4j.* properties. The following example shows how to configure the uri and credentials to use: Properties YAML spring.neo4j.uri=bolt://my-server:7687 spring.neo4j.authentication.username=neo4j spring.neo4j.authentication.password=secret spring: neo4j: uri: ""bolt://my-server:7687"" authentication: username: ""neo4j"" password: ""secret"" The auto-configured Driver is created using ConfigBuilder . To fine-tune its configuration, declare one or more ConfigBuilderCustomizer beans. Each will be called in order with the ConfigBuilder that is used to build the Driver . Spring Data Neo4j Repositories: Spring Data includes repository support for Neo4j. For complete details of Spring Data Neo4j, see the reference documentation(https://docs.spring.io/spring-data/neo4j/reference/7.3) . Spring Data Neo4j shares the common infrastructure with Spring Data JPA as many other Spring Data modules do. You could take the JPA example from earlier and define City as Spring Data Neo4j @Node rather than JPA @Entity and the repository abstraction works in the same way, as shown in the following example: Java Kotlin import java.util.Optional; import org.springframework.data.neo4j.repository.Neo4jRepository; public interface CityRepository extends Neo4jRepository<City, Long> { Optional<City> findOneByNameAndState(String name, String state); } import org.springframework.data.neo4j.repository.Neo4jRepository import java.util.Optional interface CityRepository : Neo4jRepository<City?, Long?> { fun findOneByNameAndState(name: String?, state: String?): Optional<City?>? } The spring-boot-starter-data-neo4j starter enables the repository support as well as transaction management. Spring Boot supports both classic and reactive Neo4j repositories, using the Neo4jTemplate or ReactiveNeo4jTemplate beans. When Project Reactor is available on the classpath, the reactive style is also auto-configured. Repositories and entities are found through scanning. By default, the auto-configuration packages(../using/auto-configuration.html#using.auto-configuration.packages) are scanned. You can customize the locations to look for repositories and entities by using @EnableNeo4jRepositories and @EntityScan respectively. In an application using the reactive style, a ReactiveTransactionManager is not auto-configured. To enable transaction management, the following bean must be defined in your configuration: Java Kotlin import org.neo4j.driver.Driver; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.neo4j.core.ReactiveDatabaseSelectionProvider; import org.springframework.data.neo4j.core.transaction.ReactiveNeo4jTransactionManager; @Configuration(proxyBeanMethods = false) public class MyNeo4jConfiguration { @Bean public ReactiveNeo4jTransactionManager reactiveTransactionManager(Driver driver, ReactiveDatabaseSelectionProvider databaseNameProvider) { return new ReactiveNeo4jTransactionManager(driver, databaseNameProvider); } } import org.neo4j.driver.Driver import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.data.neo4j.core.ReactiveDatabaseSelectionProvider import org.springframework.data.neo4j.core.transaction.ReactiveNeo4jTransactionManager @Configuration(proxyBeanMethods = false) class MyNeo4jConfiguration { @Bean fun reactiveTransactionManager(driver: Driver, databaseNameProvider: ReactiveDatabaseSelectionProvider): ReactiveNeo4jTransactionManager { return ReactiveNeo4jTransactionManager(driver, databaseNameProvider) } } Elasticsearch: Elasticsearch(https://www.elastic.co/products/elasticsearch) is an open source, distributed, RESTful search and analytics engine. Spring Boot offers basic auto-configuration for Elasticsearch clients. Spring Boot supports several clients: The official low-level REST client The official Java API client The ReactiveElasticsearchClient provided by Spring Data Elasticsearch Spring Boot provides a dedicated starter, spring-boot-starter-data-elasticsearch . Connecting to Elasticsearch Using REST clients: Elasticsearch ships two different REST clients that you can use to query a cluster: the low-level client(https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/java-rest-low.html) from the org.elasticsearch.client:elasticsearch-rest-client module and the Java API client(https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/index.html) from the co.elastic.clients:elasticsearch-java module. Additionally, Spring Boot provides support for a reactive client from the org.springframework.data:spring-data-elasticsearch module. By default, the clients will target localhost:9200(http://localhost:9200) . You can use spring.elasticsearch.* properties to further tune how the clients are configured, as shown in the following example: Properties YAML spring.elasticsearch.uris=https://search.example.com:9200 spring.elasticsearch.socket-timeout=10s spring.elasticsearch.username=user spring.elasticsearch.password=secret spring: elasticsearch: uris: ""https://search.example.com:9200"" socket-timeout: ""10s"" username: ""user"" password: ""secret"" Connecting to Elasticsearch Using RestClient: If you have elasticsearch-rest-client on the classpath, Spring Boot will auto-configure and register a RestClient bean. In addition to the properties described previously, to fine-tune the RestClient you can register an arbitrary number of beans that implement RestClientBuilderCustomizer for more advanced customizations. To take full control over the clients' configuration, define a RestClientBuilder bean. Additionally, if elasticsearch-rest-client-sniffer is on the classpath, a Sniffer is auto-configured to automatically discover nodes from a running Elasticsearch cluster and set them on the RestClient bean. You can further tune how Sniffer is configured, as shown in the following example: Properties YAML spring.elasticsearch.restclient.sniffer.interval=10m spring.elasticsearch.restclient.sniffer.delay-after-failure=30s spring: elasticsearch: restclient: sniffer: interval: ""10m"" delay-after-failure: ""30s"" Connecting to Elasticsearch Using ElasticsearchClient: If you have co.elastic.clients:elasticsearch-java on the classpath, Spring Boot will auto-configure and register an ElasticsearchClient bean. The ElasticsearchClient uses a transport that depends upon the previously described RestClient . Therefore, the properties described previously can be used to configure the ElasticsearchClient . Furthermore, you can define a RestClientOptions bean to take further control of the behavior of the transport. Connecting to Elasticsearch using ReactiveElasticsearchClient: Spring Data Elasticsearch(https://spring.io/projects/spring-data-elasticsearch) ships ReactiveElasticsearchClient for querying Elasticsearch instances in a reactive fashion. If you have Spring Data Elasticsearch and Reactor on the classpath, Spring Boot will auto-configure and register a ReactiveElasticsearchClient . The ReactiveElasticsearchclient uses a transport that depends upon the previously described RestClient . Therefore, the properties described previously can be used to configure the ReactiveElasticsearchClient . Furthermore, you can define a RestClientOptions bean to take further control of the behavior of the transport. Connecting to Elasticsearch by Using Spring Data: To connect to Elasticsearch, an ElasticsearchClient bean must be defined, auto-configured by Spring Boot or manually provided by the application (see previous sections). With this configuration in place, an ElasticsearchTemplate can be injected like any other Spring bean, as shown in the following example: Java Kotlin import org.springframework.data.elasticsearch.client.elc.ElasticsearchTemplate; import org.springframework.stereotype.Component; @Component public class MyBean { private final ElasticsearchTemplate template; public MyBean(ElasticsearchTemplate template) { this.template = template; } // ... public boolean someMethod(String id) { return this.template.exists(id, User.class); } } import org.springframework.stereotype.Component @Component class MyBean(private val template: org.springframework.data.elasticsearch.client.elc.ElasticsearchTemplate ) { // ... fun someMethod(id: String): Boolean { return template.exists(id, User::class.java) } } In the presence of spring-data-elasticsearch and Reactor, Spring Boot can also auto-configure a ReactiveElasticsearchClient(#data.nosql.elasticsearch.connecting-using-rest.reactiveclient) and a ReactiveElasticsearchTemplate as beans. They are the reactive equivalent of the other REST clients. Spring Data Elasticsearch Repositories: Spring Data includes repository support for Elasticsearch. As with the JPA repositories discussed earlier, the basic principle is that queries are constructed for you automatically based on method names. In fact, both Spring Data JPA and Spring Data Elasticsearch share the same common infrastructure. You could take the JPA example from earlier and, assuming that City is now an Elasticsearch @Document class rather than a JPA @Entity , it works in the same way. Repositories and documents are found through scanning. By default, the auto-configuration packages(../using/auto-configuration.html#using.auto-configuration.packages) are scanned. You can customize the locations to look for repositories and documents by using @EnableElasticsearchRepositories and @EntityScan respectively. For complete details of Spring Data Elasticsearch, see the reference documentation(https://docs.spring.io/spring-data/elasticsearch/reference/5.3) . Spring Boot supports both classic and reactive Elasticsearch repositories, using the ElasticsearchRestTemplate or ReactiveElasticsearchTemplate beans. Most likely those beans are auto-configured by Spring Boot given the required dependencies are present. If you wish to use your own template for backing the Elasticsearch repositories, you can add your own ElasticsearchRestTemplate or ElasticsearchOperations @Bean , as long as it is named ""elasticsearchTemplate"" . Same applies to ReactiveElasticsearchTemplate and ReactiveElasticsearchOperations , with the bean name ""reactiveElasticsearchTemplate"" . You can choose to disable the repositories support with the following property: Properties YAML spring.data.elasticsearch.repositories.enabled=false spring: data: elasticsearch: repositories: enabled: false Cassandra: Cassandra(https://cassandra.apache.org/) is an open source, distributed database management system designed to handle large amounts of data across many commodity servers. Spring Boot offers auto-configuration for Cassandra and the abstractions on top of it provided by Spring Data Cassandra(https://spring.io/projects/spring-data-cassandra) . There is a spring-boot-starter-data-cassandra starter for collecting the dependencies in a convenient way. Connecting to Cassandra: You can inject an auto-configured CassandraTemplate or a Cassandra CqlSession instance as you would with any other Spring Bean. The spring.cassandra.* properties can be used to customize the connection. Generally, you provide keyspace-name and contact-points as well the local datacenter name, as shown in the following example: Properties YAML spring.cassandra.keyspace-name=mykeyspace spring.cassandra.contact-points=cassandrahost1:9042,cassandrahost2:9042 spring.cassandra.local-datacenter=datacenter1 spring: cassandra: keyspace-name: ""mykeyspace"" contact-points: ""cassandrahost1:9042,cassandrahost2:9042"" local-datacenter: ""datacenter1"" If the port is the same for all your contact points you can use a shortcut and only specify the host names, as shown in the following example: Properties YAML spring.cassandra.keyspace-name=mykeyspace spring.cassandra.contact-points=cassandrahost1,cassandrahost2 spring.cassandra.local-datacenter=datacenter1 spring: cassandra: keyspace-name: ""mykeyspace"" contact-points: ""cassandrahost1,cassandrahost2"" local-datacenter: ""datacenter1"" Those two examples are identical as the port default to 9042 . If you need to configure the port, use spring.cassandra.port . The auto-configured CqlSession can be configured to use SSL for communication with the server by setting the properties as shown in this example: Properties YAML spring.cassandra.keyspace-name=mykeyspace spring.cassandra.contact-points=cassandrahost1,cassandrahost2 spring.cassandra.local-datacenter=datacenter1 spring.cassandra.ssl.enabled=true spring: cassandra: keyspace-name: ""mykeyspace"" contact-points: ""cassandrahost1,cassandrahost2"" local-datacenter: ""datacenter1"" ssl: enabled: true Custom SSL trust material can be configured in an SSL bundle(../features/ssl.html) and applied to the CqlSession as shown in this example: Properties YAML spring.cassandra.keyspace-name=mykeyspace spring.cassandra.contact-points=cassandrahost1,cassandrahost2 spring.cassandra.local-datacenter=datacenter1 spring.cassandra.ssl.bundle=example spring: cassandra: keyspace-name: ""mykeyspace"" contact-points: ""cassandrahost1,cassandrahost2"" local-datacenter: ""datacenter1"" ssl: bundle: ""example"" The Cassandra driver has its own configuration infrastructure that loads an application.conf at the root of the classpath. Spring Boot does not look for such a file by default but can load one using spring.cassandra.config . If a property is both present in spring.cassandra.* and the configuration file, the value in spring.cassandra.* takes precedence. For more advanced driver customizations, you can register an arbitrary number of beans that implement DriverConfigLoaderBuilderCustomizer . The CqlSession can be customized with a bean of type CqlSessionBuilderCustomizer . If you use CqlSessionBuilder to create multiple CqlSession beans, keep in mind the builder is mutable so make sure to inject a fresh copy for each session. The following code listing shows how to inject a Cassandra bean: Java Kotlin import org.springframework.data.cassandra.core.CassandraTemplate; import org.springframework.stereotype.Component; @Component public class MyBean { private final CassandraTemplate template; public MyBean(CassandraTemplate template) { this.template = template; } // ... public long someMethod() { return this.template.count(User.class); } } import org.springframework.data.cassandra.core.CassandraTemplate import org.springframework.stereotype.Component @Component class MyBean(private val template: CassandraTemplate) { // ... fun someMethod(): Long { return template.count(User::class.java) } } If you add your own @Bean of type CassandraTemplate , it replaces the default. Spring Data Cassandra Repositories: Spring Data includes basic repository support for Cassandra. Currently, this is more limited than the JPA repositories discussed earlier and needs @Query annotated finder methods. Repositories and entities are found through scanning. By default, the auto-configuration packages(../using/auto-configuration.html#using.auto-configuration.packages) are scanned. You can customize the locations to look for repositories and entities by using @EnableCassandraRepositories and @EntityScan respectively. For complete details of Spring Data Cassandra, see the reference documentation(https://docs.spring.io/spring-data/cassandra/docs/) . Couchbase: Couchbase(https://www.couchbase.com/) is an open-source, distributed, multi-model NoSQL document-oriented database that is optimized for interactive applications. Spring Boot offers auto-configuration for Couchbase and the abstractions on top of it provided by Spring Data Couchbase(https://github.com/spring-projects/spring-data-couchbase) . There are spring-boot-starter-data-couchbase and spring-boot-starter-data-couchbase-reactive starters for collecting the dependencies in a convenient way. Connecting to Couchbase: You can get a Cluster by adding the Couchbase SDK and some configuration. The spring.couchbase.* properties can be used to customize the connection. Generally, you provide the connection string(https://github.com/couchbaselabs/sdk-rfcs/blob/master/rfc/0011-connection-string.md) , username, and password, as shown in the following example: Properties YAML spring.couchbase.connection-string=couchbase://192.168.1.123 spring.couchbase.username=user spring.couchbase.password=secret spring: couchbase: connection-string: ""couchbase://192.168.1.123"" username: ""user"" password: ""secret"" It is also possible to customize some of the ClusterEnvironment settings. For instance, the following configuration changes the timeout to open a new Bucket and enables SSL support with a reference to a configured SSL bundle(../features/ssl.html) : Properties YAML spring.couchbase.env.timeouts.connect=3s spring.couchbase.env.ssl.bundle=example spring: couchbase: env: timeouts: connect: ""3s"" ssl: bundle: ""example"" Check the spring.couchbase.env.* properties for more details. To take more control, one or more ClusterEnvironmentBuilderCustomizer beans can be used. Spring Data Couchbase Repositories: Spring Data includes repository support for Couchbase. Repositories and documents are found through scanning. By default, the auto-configuration packages(../using/auto-configuration.html#using.auto-configuration.packages) are scanned. You can customize the locations to look for repositories and documents by using @EnableCouchbaseRepositories and @EntityScan respectively. For complete details of Spring Data Couchbase, see the reference documentation(https://docs.spring.io/spring-data/couchbase/reference/5.3) . You can inject an auto-configured CouchbaseTemplate instance as you would with any other Spring Bean, provided a CouchbaseClientFactory bean is available. This happens when a Cluster is available, as described above, and a bucket name has been specified: Properties YAML spring.data.couchbase.bucket-name=my-bucket spring: data: couchbase: bucket-name: ""my-bucket"" The following examples shows how to inject a CouchbaseTemplate bean: Java Kotlin import org.springframework.data.couchbase.core.CouchbaseTemplate; import org.springframework.stereotype.Component; @Component public class MyBean { private final CouchbaseTemplate template; public MyBean(CouchbaseTemplate template) { this.template = template; } // ... public String someMethod() { return this.template.getBucketName(); } } import org.springframework.data.couchbase.core.CouchbaseTemplate import org.springframework.stereotype.Component @Component class MyBean(private val template: CouchbaseTemplate) { // ... fun someMethod(): String { return template.bucketName } } There are a few beans that you can define in your own configuration to override those provided by the auto-configuration: A CouchbaseMappingContext @Bean with a name of couchbaseMappingContext . A CustomConversions @Bean with a name of couchbaseCustomConversions . A CouchbaseTemplate @Bean with a name of couchbaseTemplate . To avoid hard-coding those names in your own config, you can reuse BeanNames provided by Spring Data Couchbase. For instance, you can customize the converters to use, as follows: Java Kotlin import org.assertj.core.util.Arrays; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.couchbase.config.BeanNames; import org.springframework.data.couchbase.core.convert.CouchbaseCustomConversions; @Configuration(proxyBeanMethods = false) public class MyCouchbaseConfiguration { @Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS) public CouchbaseCustomConversions myCustomConversions() { return new CouchbaseCustomConversions(Arrays.asList(new MyConverter())); } } import org.assertj.core.util.Arrays import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.data.couchbase.config.BeanNames import org.springframework.data.couchbase.core.convert.CouchbaseCustomConversions @Configuration(proxyBeanMethods = false) class MyCouchbaseConfiguration { @Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS) fun myCustomConversions(): CouchbaseCustomConversions { return CouchbaseCustomConversions(Arrays.asList(MyConverter())) } } LDAP: LDAP(https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol) (Lightweight Directory Access Protocol) is an open, vendor-neutral, industry standard application protocol for accessing and maintaining distributed directory information services over an IP network. Spring Boot offers auto-configuration for any compliant LDAP server as well as support for the embedded in-memory LDAP server from UnboundID(https://ldap.com/unboundid-ldap-sdk-for-java/) . LDAP abstractions are provided by Spring Data LDAP(https://github.com/spring-projects/spring-data-ldap) . There is a spring-boot-starter-data-ldap starter for collecting the dependencies in a convenient way. Connecting to an LDAP Server: To connect to an LDAP server, make sure you declare a dependency on the spring-boot-starter-data-ldap starter or spring-ldap-core and then declare the URLs of your server in your application.properties, as shown in the following example: Properties YAML spring.ldap.urls=ldap://myserver:1235 spring.ldap.username=admin spring.ldap.password=secret spring: ldap: urls: ""ldap://myserver:1235"" username: ""admin"" password: ""secret"" If you need to customize connection settings, you can use the spring.ldap.base and spring.ldap.base-environment properties. An LdapContextSource is auto-configured based on these settings. If a DirContextAuthenticationStrategy bean is available, it is associated to the auto-configured LdapContextSource . If you need to customize it, for instance to use a PooledContextSource , you can still inject the auto-configured LdapContextSource . Make sure to flag your customized ContextSource as @Primary so that the auto-configured LdapTemplate uses it. Spring Data LDAP Repositories: Spring Data includes repository support for LDAP. Repositories and documents are found through scanning. By default, the auto-configuration packages(../using/auto-configuration.html#using.auto-configuration.packages) are scanned. You can customize the locations to look for repositories and documents by using @EnableLdapRepositories and @EntityScan respectively. For complete details of Spring Data LDAP, see the reference documentation(https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/) . You can also inject an auto-configured LdapTemplate instance as you would with any other Spring Bean, as shown in the following example: Java Kotlin import java.util.List; import org.springframework.ldap.core.LdapTemplate; import org.springframework.stereotype.Component; @Component public class MyBean { private final LdapTemplate template; public MyBean(LdapTemplate template) { this.template = template; } // ... public List<User> someMethod() { return this.template.findAll(User.class); } } import org.springframework.ldap.core.LdapTemplate import org.springframework.stereotype.Component @Component class MyBean(private val template: LdapTemplate) { // ... fun someMethod(): List<User> { return template.findAll(User::class.java) } } Embedded In-memory LDAP Server: For testing purposes, Spring Boot supports auto-configuration of an in-memory LDAP server from UnboundID(https://ldap.com/unboundid-ldap-sdk-for-java/) . To configure the server, add a dependency to com.unboundid:unboundid-ldapsdk and declare a spring.ldap.embedded.base-dn property, as follows: Properties YAML spring.ldap.embedded.base-dn=dc=spring,dc=io spring: ldap: embedded: base-dn: ""dc=spring,dc=io"" It is possible to define multiple base-dn values, however, since distinguished names usually contain commas, they must be defined using the correct notation. In yaml files, you can use the yaml list notation. In properties files, you must include the index as part of the property name: Properties YAML spring.ldap.embedded.base-dn[0]=dc=spring,dc=io spring.ldap.embedded.base-dn[1]=dc=vmware,dc=com spring.ldap.embedded.base-dn: - ""dc=spring,dc=io"" - ""dc=vmware,dc=com"" By default, the server starts on a random port and triggers the regular LDAP support. There is no need to specify a spring.ldap.urls property. If there is a schema.ldif file on your classpath, it is used to initialize the server. If you want to load the initialization script from a different resource, you can also use the spring.ldap.embedded.ldif property. By default, a standard schema is used to validate LDIF files. You can turn off validation altogether by setting the spring.ldap.embedded.validation.enabled property. If you have custom attributes, you can use spring.ldap.embedded.validation.schema to define your custom attribute types or object classes. InfluxDB: Auto-configuration for InfluxDB is deprecated and scheduled for removal in Spring Boot 3.4 in favor of the new InfluxDB Java client(https://github.com/influxdata/influxdb-client-java) that provides its own Spring Boot integration. InfluxDB(https://www.influxdata.com/) is an open-source time series database optimized for fast, high-availability storage and retrieval of time series data in fields such as operations monitoring, application metrics, Internet-of-Things sensor data, and real-time analytics. Connecting to InfluxDB: Spring Boot auto-configures an InfluxDB instance, provided the influxdb-java client is on the classpath and the URL of the database is set using spring.influx.url . If the connection to InfluxDB requires a user and password, you can set the spring.influx.user and spring.influx.password properties accordingly. InfluxDB relies on OkHttp. If you need to tune the http client InfluxDB uses behind the scenes, you can register an InfluxDbOkHttpClientBuilderProvider bean. If you need more control over the configuration, consider registering an InfluxDbCustomizer bean."
"https://docs.spring.io/spring-boot/reference/io/index.html","IO: Most applications will need to deal with input and output concerns at some point. Spring Boot provides utilities and integrations with a range of technologies to help when you need IO capabilities. This section covers standard IO features such as caching and validation as well as more advanced topics such as scheduling and distributed transactions. We will also cover calling remote REST or SOAP services and sending email."
"https://docs.spring.io/spring-boot/reference/io/caching.html","Caching: The Spring Framework provides support for transparently adding caching to an application. At its core, the abstraction applies caching to methods, thus reducing the number of executions based on the information available in the cache. The caching logic is applied transparently, without any interference to the invoker. Spring Boot auto-configures the cache infrastructure as long as caching support is enabled by using the @EnableCaching annotation. Check the relevant section(https://docs.spring.io/spring-framework/reference/6.1/integration/cache.html) of the Spring Framework reference for more details. In a nutshell, to add caching to an operation of your service add the relevant annotation to its method, as shown in the following example: Java Kotlin import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Component; @Component public class MyMathService { @Cacheable(""piDecimals"") public int computePiDecimal(int precision) { ... } } import org.springframework.cache.annotation.Cacheable import org.springframework.stereotype.Component @Component class MyMathService { @Cacheable(""piDecimals"") fun computePiDecimal(precision: Int): Int { ... } } This example demonstrates the use of caching on a potentially costly operation. Before invoking computePiDecimal , the abstraction looks for an entry in the piDecimals cache that matches the i argument. If an entry is found, the content in the cache is immediately returned to the caller, and the method is not invoked. Otherwise, the method is invoked, and the cache is updated before returning the value. You can also use the standard JSR-107 (JCache) annotations (such as @CacheResult ) transparently. However, we strongly advise you to not mix and match the Spring Cache and JCache annotations. If you do not add any specific cache library, Spring Boot auto-configures a simple provider(#io.caching.provider.simple) that uses concurrent maps in memory. When a cache is required (such as piDecimals in the preceding example), this provider creates it for you. The simple provider is not really recommended for production usage, but it is great for getting started and making sure that you understand the features. When you have made up your mind about the cache provider to use, please make sure to read its documentation to figure out how to configure the caches that your application uses. Nearly all providers require you to explicitly configure every cache that you use in the application. Some offer a way to customize the default caches defined by the spring.cache.cache-names property. It is also possible to transparently update(https://docs.spring.io/spring-framework/reference/6.1/integration/cache/annotations.html#cache-annotations-put) or evict(https://docs.spring.io/spring-framework/reference/6.1/integration/cache/annotations.html#cache-annotations-evict) data from the cache. Supported Cache Providers: The cache abstraction does not provide an actual store and relies on abstraction materialized by the org.springframework.cache.Cache and org.springframework.cache.CacheManager interfaces. If you have not defined a bean of type CacheManager or a CacheResolver named cacheResolver (see CachingConfigurer(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html) ), Spring Boot tries to detect the following providers (in the indicated order): Generic(#io.caching.provider.generic) JCache (JSR-107)(#io.caching.provider.jcache) (EhCache 3, Hazelcast, Infinispan, and others) Hazelcast(#io.caching.provider.hazelcast) Infinispan(#io.caching.provider.infinispan) Couchbase(#io.caching.provider.couchbase) Redis(#io.caching.provider.redis) Caffeine(#io.caching.provider.caffeine) Cache2k(#io.caching.provider.cache2k) Simple(#io.caching.provider.simple) Additionally, Spring Boot for Apache Geode(https://github.com/spring-projects/spring-boot-data-geode) provides auto-configuration for using Apache Geode as a cache provider(https://docs.spring.io/spring-boot-data-geode-build/2.0.x/reference/html5#geode-caching-provider) . If the CacheManager is auto-configured by Spring Boot, it is possible to force a particular cache provider by setting the spring.cache.type property. Use this property if you need to use no-op caches(#io.caching.provider.none) in certain environments (such as tests). Use the spring-boot-starter-cache starter to quickly add basic caching dependencies. The starter brings in spring-context-support . If you add dependencies manually, you must include spring-context-support in order to use the JCache or Caffeine support. If the CacheManager is auto-configured by Spring Boot, you can further tune its configuration before it is fully initialized by exposing a bean that implements the CacheManagerCustomizer interface. The following example sets a flag to say that null values should not be passed down to the underlying map: Java Kotlin import org.springframework.boot.autoconfigure.cache.CacheManagerCustomizer; import org.springframework.cache.concurrent.ConcurrentMapCacheManager; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyCacheManagerConfiguration { @Bean public CacheManagerCustomizer<ConcurrentMapCacheManager> cacheManagerCustomizer() { return (cacheManager) -> cacheManager.setAllowNullValues(false); } } import org.springframework.boot.autoconfigure.cache.CacheManagerCustomizer import org.springframework.cache.concurrent.ConcurrentMapCacheManager import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyCacheManagerConfiguration { @Bean fun cacheManagerCustomizer(): CacheManagerCustomizer<ConcurrentMapCacheManager> { return CacheManagerCustomizer { cacheManager -> cacheManager.isAllowNullValues = false } } } In the preceding example, an auto-configured ConcurrentMapCacheManager is expected. If that is not the case (either you provided your own config or a different cache provider was auto-configured), the customizer is not invoked at all. You can have as many customizers as you want, and you can also order them by using @Order or Ordered . Generic: Generic caching is used if the context defines at least one org.springframework.cache.Cache bean. A CacheManager wrapping all beans of that type is created. JCache (JSR-107): JCache(https://jcp.org/en/jsr/detail?id=107) is bootstrapped through the presence of a javax.cache.spi.CachingProvider on the classpath (that is, a JSR-107 compliant caching library exists on the classpath), and the JCacheCacheManager is provided by the spring-boot-starter-cache starter. Various compliant libraries are available, and Spring Boot provides dependency management for Ehcache 3, Hazelcast, and Infinispan. Any other compliant library can be added as well. It might happen that more than one provider is present, in which case the provider must be explicitly specified. Even if the JSR-107 standard does not enforce a standardized way to define the location of the configuration file, Spring Boot does its best to accommodate setting a cache with implementation details, as shown in the following example: Properties YAML spring.cache.jcache.provider=com.example.MyCachingProvider spring.cache.jcache.config=classpath:example.xml # Only necessary if more than one provider is present spring: cache: jcache: provider: ""com.example.MyCachingProvider"" config: ""classpath:example.xml"" When a cache library offers both a native implementation and JSR-107 support, Spring Boot prefers the JSR-107 support, so that the same features are available if you switch to a different JSR-107 implementation. Spring Boot has general support for Hazelcast(hazelcast.html) . If a single HazelcastInstance is available, it is automatically reused for the CacheManager as well, unless the spring.cache.jcache.config property is specified. There are two ways to customize the underlying javax.cache.cacheManager : Caches can be created on startup by setting the spring.cache.cache-names property. If a custom javax.cache.configuration.Configuration bean is defined, it is used to customize them. org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer beans are invoked with the reference of the CacheManager for full customization. If a standard javax.cache.CacheManager bean is defined, it is wrapped automatically in an org.springframework.cache.CacheManager implementation that the abstraction expects. No further customization is applied to it. Hazelcast: Spring Boot has general support for Hazelcast(hazelcast.html) . If a HazelcastInstance has been auto-configured and com.hazelcast:hazelcast-spring is on the classpath, it is automatically wrapped in a CacheManager . Hazelcast can be used as a JCache compliant cache or as a Spring CacheManager compliant cache. When setting spring.cache.type to hazelcast , Spring Boot will use the CacheManager based implementation. If you want to use Hazelcast as a JCache compliant cache, set spring.cache.type to jcache . If you have multiple JCache compliant cache providers and want to force the use of Hazelcast, you have to explicitly set the JCache provider(#io.caching.provider.jcache) . Infinispan: Infinispan(https://infinispan.org/) has no default configuration file location, so it must be specified explicitly. Otherwise, the default bootstrap is used. Properties YAML spring.cache.infinispan.config=infinispan.xml spring: cache: infinispan: config: ""infinispan.xml"" Caches can be created on startup by setting the spring.cache.cache-names property. If a custom ConfigurationBuilder bean is defined, it is used to customize the caches. To be compatible with Spring Boot’s Jakarta EE 9 baseline, Infinispan’s -jakarta modules must be used. For every module with a -jakarta variant, the variant must be used in place of the standard module. For example, infinispan-core-jakarta and infinispan-commons-jakarta must be used in place of infinispan-core and infinispan-commons respectively. Couchbase: If Spring Data Couchbase is available and Couchbase is configured(../data/nosql.html#data.nosql.couchbase) , a CouchbaseCacheManager is auto-configured. It is possible to create additional caches on startup by setting the spring.cache.cache-names property and cache defaults can be configured by using spring.cache.couchbase.* properties. For instance, the following configuration creates cache1 and cache2 caches with an entry expiration of 10 minutes: Properties YAML spring.cache.cache-names=cache1,cache2 spring.cache.couchbase.expiration=10m spring: cache: cache-names: ""cache1,cache2"" couchbase: expiration: ""10m"" If you need more control over the configuration, consider registering a CouchbaseCacheManagerBuilderCustomizer bean. The following example shows a customizer that configures a specific entry expiration for cache1 and cache2 : Java Kotlin import java.time.Duration; import org.springframework.boot.autoconfigure.cache.CouchbaseCacheManagerBuilderCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.couchbase.cache.CouchbaseCacheConfiguration; @Configuration(proxyBeanMethods = false) public class MyCouchbaseCacheManagerConfiguration { @Bean public CouchbaseCacheManagerBuilderCustomizer myCouchbaseCacheManagerBuilderCustomizer() { return (builder) -> builder .withCacheConfiguration(""cache1"", CouchbaseCacheConfiguration .defaultCacheConfig().entryExpiry(Duration.ofSeconds(10))) .withCacheConfiguration(""cache2"", CouchbaseCacheConfiguration .defaultCacheConfig().entryExpiry(Duration.ofMinutes(1))); } } import org.springframework.boot.autoconfigure.cache.CouchbaseCacheManagerBuilderCustomizer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.data.couchbase.cache.CouchbaseCacheConfiguration import java.time.Duration @Configuration(proxyBeanMethods = false) class MyCouchbaseCacheManagerConfiguration { @Bean fun myCouchbaseCacheManagerBuilderCustomizer(): CouchbaseCacheManagerBuilderCustomizer { return CouchbaseCacheManagerBuilderCustomizer { builder -> builder .withCacheConfiguration( ""cache1"", CouchbaseCacheConfiguration .defaultCacheConfig().entryExpiry(Duration.ofSeconds(10)) ) .withCacheConfiguration( ""cache2"", CouchbaseCacheConfiguration .defaultCacheConfig().entryExpiry(Duration.ofMinutes(1)) ) } } } Redis: If Redis(https://redis.io/) is available and configured, a RedisCacheManager is auto-configured. It is possible to create additional caches on startup by setting the spring.cache.cache-names property and cache defaults can be configured by using spring.cache.redis.* properties. For instance, the following configuration creates cache1 and cache2 caches with a time to live of 10 minutes: Properties YAML spring.cache.cache-names=cache1,cache2 spring.cache.redis.time-to-live=10m spring: cache: cache-names: ""cache1,cache2"" redis: time-to-live: ""10m"" By default, a key prefix is added so that, if two separate caches use the same key, Redis does not have overlapping keys and cannot return invalid values. We strongly recommend keeping this setting enabled if you create your own RedisCacheManager . You can take full control of the default configuration by adding a RedisCacheConfiguration @Bean of your own. This can be useful if you need to customize the default serialization strategy. If you need more control over the configuration, consider registering a RedisCacheManagerBuilderCustomizer bean. The following example shows a customizer that configures a specific time to live for cache1 and cache2 : Java Kotlin import java.time.Duration; import org.springframework.boot.autoconfigure.cache.RedisCacheManagerBuilderCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.cache.RedisCacheConfiguration; @Configuration(proxyBeanMethods = false) public class MyRedisCacheManagerConfiguration { @Bean public RedisCacheManagerBuilderCustomizer myRedisCacheManagerBuilderCustomizer() { return (builder) -> builder .withCacheConfiguration(""cache1"", RedisCacheConfiguration .defaultCacheConfig().entryTtl(Duration.ofSeconds(10))) .withCacheConfiguration(""cache2"", RedisCacheConfiguration .defaultCacheConfig().entryTtl(Duration.ofMinutes(1))); } } import org.springframework.boot.autoconfigure.cache.RedisCacheManagerBuilderCustomizer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.data.redis.cache.RedisCacheConfiguration import java.time.Duration @Configuration(proxyBeanMethods = false) class MyRedisCacheManagerConfiguration { @Bean fun myRedisCacheManagerBuilderCustomizer(): RedisCacheManagerBuilderCustomizer { return RedisCacheManagerBuilderCustomizer { builder -> builder .withCacheConfiguration( ""cache1"", RedisCacheConfiguration .defaultCacheConfig().entryTtl(Duration.ofSeconds(10)) ) .withCacheConfiguration( ""cache2"", RedisCacheConfiguration .defaultCacheConfig().entryTtl(Duration.ofMinutes(1)) ) } } } Caffeine: Caffeine(https://github.com/ben-manes/caffeine) is a Java 8 rewrite of Guava’s cache that supersedes support for Guava. If Caffeine is present, a CaffeineCacheManager (provided by the spring-boot-starter-cache starter) is auto-configured. Caches can be created on startup by setting the spring.cache.cache-names property and can be customized by one of the following (in the indicated order): A cache spec defined by spring.cache.caffeine.spec A com.github.benmanes.caffeine.cache.CaffeineSpec bean is defined A com.github.benmanes.caffeine.cache.Caffeine bean is defined For instance, the following configuration creates cache1 and cache2 caches with a maximum size of 500 and a time to live of 10 minutes Properties YAML spring.cache.cache-names=cache1,cache2 spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s spring: cache: cache-names: ""cache1,cache2"" caffeine: spec: ""maximumSize=500,expireAfterAccess=600s"" If a com.github.benmanes.caffeine.cache.CacheLoader bean is defined, it is automatically associated to the CaffeineCacheManager . Since the CacheLoader is going to be associated with all caches managed by the cache manager, it must be defined as CacheLoader<Object, Object> . The auto-configuration ignores any other generic type. Cache2k: Cache2k(https://cache2k.org/) is an in-memory cache. If the Cache2k spring integration is present, a SpringCache2kCacheManager is auto-configured. Caches can be created on startup by setting the spring.cache.cache-names property. Cache defaults can be customized using a Cache2kBuilderCustomizer bean. The following example shows a customizer that configures the capacity of the cache to 200 entries, with an expiration of 5 minutes: Java Kotlin import java.util.concurrent.TimeUnit; import org.springframework.boot.autoconfigure.cache.Cache2kBuilderCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyCache2kDefaultsConfiguration { @Bean public Cache2kBuilderCustomizer myCache2kDefaultsCustomizer() { return (builder) -> builder.entryCapacity(200) .expireAfterWrite(5, TimeUnit.MINUTES); } } import org.springframework.boot.autoconfigure.cache.Cache2kBuilderCustomizer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import java.util.concurrent.TimeUnit @Configuration(proxyBeanMethods = false) class MyCache2kDefaultsConfiguration { @Bean fun myCache2kDefaultsCustomizer(): Cache2kBuilderCustomizer { return Cache2kBuilderCustomizer { builder -> builder.entryCapacity(200) .expireAfterWrite(5, TimeUnit.MINUTES) } } } Simple: If none of the other providers can be found, a simple implementation using a ConcurrentHashMap as the cache store is configured. This is the default if no caching library is present in your application. By default, caches are created as needed, but you can restrict the list of available caches by setting the cache-names property. For instance, if you want only cache1 and cache2 caches, set the cache-names property as follows: Properties YAML spring.cache.cache-names=cache1,cache2 spring: cache: cache-names: ""cache1,cache2"" If you do so and your application uses a cache not listed, then it fails at runtime when the cache is needed, but not on startup. This is similar to the way the ""real"" cache providers behave if you use an undeclared cache. None: When @EnableCaching is present in your configuration, a suitable cache configuration is expected as well. If you have a custom CacheManager , consider defining it in a separate @Configuration class so that you can override it if necessary. None uses a no-op implementation that is useful in tests, and slice tests use that by default via @AutoConfigureCache . If you need to use a no-op cache rather than the auto-configured cache manager in a certain environment, set the cache type to none , as shown in the following example: Properties YAML spring.cache.type=none spring: cache: type: ""none"""
"https://docs.spring.io/spring-boot/reference/io/hazelcast.html","Hazelcast: If Hazelcast(https://hazelcast.com/) is on the classpath and a suitable configuration is found, Spring Boot auto-configures a HazelcastInstance that you can inject in your application. Spring Boot first attempts to create a client by checking the following configuration options: The presence of a com.hazelcast.client.config.ClientConfig bean. A configuration file defined by the spring.hazelcast.config property. The presence of the hazelcast.client.config system property. A hazelcast-client.xml in the working directory or at the root of the classpath. A hazelcast-client.yaml (or hazelcast-client.yml ) in the working directory or at the root of the classpath. If a client can not be created, Spring Boot attempts to configure an embedded server. If you define a com.hazelcast.config.Config bean, Spring Boot uses that. If your configuration defines an instance name, Spring Boot tries to locate an existing instance rather than creating a new one. You could also specify the Hazelcast configuration file to use through configuration, as shown in the following example: Properties YAML spring.hazelcast.config=classpath:config/my-hazelcast.xml spring: hazelcast: config: ""classpath:config/my-hazelcast.xml"" Otherwise, Spring Boot tries to find the Hazelcast configuration from the default locations: hazelcast.xml in the working directory or at the root of the classpath, or a YAML counterpart in the same locations. We also check if the hazelcast.config system property is set. See the Hazelcast documentation(https://docs.hazelcast.org/docs/latest/manual/html-single/) for more details. By default, @SpringAware on Hazelcast components is supported. The ManagementContext can be overridden by declaring a HazelcastConfigCustomizer bean with an @Order higher than zero. Spring Boot also has explicit caching support for Hazelcast(caching.html#io.caching.provider.hazelcast) . If caching is enabled, the HazelcastInstance is automatically wrapped in a CacheManager implementation."
"https://docs.spring.io/spring-boot/reference/io/quartz.html","Quartz Scheduler: Spring Boot offers several conveniences for working with the Quartz scheduler(https://www.quartz-scheduler.org/) , including the spring-boot-starter-quartz starter. If Quartz is available, a Scheduler is auto-configured (through the SchedulerFactoryBean abstraction). Beans of the following types are automatically picked up and associated with the Scheduler : JobDetail : defines a particular Job. JobDetail instances can be built with the JobBuilder API. Calendar . Trigger : defines when a particular job is triggered. By default, an in-memory JobStore is used. However, it is possible to configure a JDBC-based store if a DataSource bean is available in your application and if the spring.quartz.job-store-type property is configured accordingly, as shown in the following example: Properties YAML spring.quartz.job-store-type=jdbc spring: quartz: job-store-type: ""jdbc"" When the JDBC store is used, the schema can be initialized on startup, as shown in the following example: Properties YAML spring.quartz.jdbc.initialize-schema=always spring: quartz: jdbc: initialize-schema: ""always"" By default, the database is detected and initialized by using the standard scripts provided with the Quartz library. These scripts drop existing tables, deleting all triggers on every restart. It is also possible to provide a custom script by setting the spring.quartz.jdbc.schema property. To have Quartz use a DataSource other than the application’s main DataSource , declare a DataSource bean, annotating its @Bean method with @QuartzDataSource . Doing so ensures that the Quartz-specific DataSource is used by both the SchedulerFactoryBean and for schema initialization. Similarly, to have Quartz use a TransactionManager other than the application’s main TransactionManager declare a TransactionManager bean, annotating its @Bean method with @QuartzTransactionManager . By default, jobs created by configuration will not overwrite already registered jobs that have been read from a persistent job store. To enable overwriting existing job definitions set the spring.quartz.overwrite-existing-jobs property. Quartz Scheduler configuration can be customized using spring.quartz properties and SchedulerFactoryBeanCustomizer beans, which allow programmatic SchedulerFactoryBean customization. Advanced Quartz configuration properties can be customized using spring.quartz.properties.* . In particular, an Executor bean is not associated with the scheduler as Quartz offers a way to configure the scheduler through spring.quartz.properties . If you need to customize the task executor, consider implementing SchedulerFactoryBeanCustomizer . Jobs can define setters to inject data map properties. Regular beans can also be injected in a similar manner, as shown in the following example: Java Kotlin import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; import org.springframework.scheduling.quartz.QuartzJobBean; public class MySampleJob extends QuartzJobBean { // fields ... private MyService myService; private String name; // Inject ""MyService"" bean public void setMyService(MyService myService) { this.myService = myService; } // Inject the ""name"" job data property public void setName(String name) { this.name = name; } @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException { this.myService.someMethod(context.getFireTime(), this.name); } } import org.quartz.JobExecutionContext import org.springframework.scheduling.quartz.QuartzJobBean class MySampleJob : QuartzJobBean() { // fields ... private var myService: MyService? = null private var name: String? = null // Inject ""MyService"" bean fun setMyService(myService: MyService?) { this.myService = myService } // Inject the ""name"" job data property fun setName(name: String?) { this.name = name } override fun executeInternal(context: JobExecutionContext) { myService!!.someMethod(context.fireTime, name) } }"
"https://docs.spring.io/spring-boot/reference/io/email.html","Sending Email: The Spring Framework provides an abstraction for sending email by using the JavaMailSender interface, and Spring Boot provides auto-configuration for it as well as a starter module. See the reference documentation(https://docs.spring.io/spring-framework/reference/6.1/integration/email.html) for a detailed explanation of how you can use JavaMailSender . If spring.mail.host and the relevant libraries (as defined by spring-boot-starter-mail ) are available, a default JavaMailSender is created if none exists. The sender can be further customized by configuration items from the spring.mail namespace. See MailProperties(../../api/java/org/springframework/boot/autoconfigure/mail/MailProperties.html) for more details. In particular, certain default timeout values are infinite, and you may want to change that to avoid having a thread blocked by an unresponsive mail server, as shown in the following example: Properties YAML spring.mail.properties[mail.smtp.connectiontimeout]=5000 spring.mail.properties[mail.smtp.timeout]=3000 spring.mail.properties[mail.smtp.writetimeout]=5000 spring: mail: properties: ""[mail.smtp.connectiontimeout]"": 5000 ""[mail.smtp.timeout]"": 3000 ""[mail.smtp.writetimeout]"": 5000 It is also possible to configure a JavaMailSender with an existing Session from JNDI: Properties YAML spring.mail.jndi-name=mail/Session spring: mail: jndi-name: ""mail/Session"" When a jndi-name is set, it takes precedence over all other Session-related settings."
"https://docs.spring.io/spring-boot/reference/io/validation.html","Validation: The method validation feature supported by Bean Validation 1.1 is automatically enabled as long as a JSR-303 implementation (such as Hibernate validator) is on the classpath. This lets bean methods be annotated with jakarta.validation constraints on their parameters and/or on their return value. Target classes with such annotated methods need to be annotated with the @Validated annotation at the type level for their methods to be searched for inline constraint annotations. For instance, the following service triggers the validation of the first argument, making sure its size is between 8 and 10: Java Kotlin import jakarta.validation.constraints.Size; import org.springframework.stereotype.Service; import org.springframework.validation.annotation.Validated; @Service @Validated public class MyBean { public Archive findByCodeAndAuthor(@Size(min = 8, max = 10) String code, Author author) { return ... } } import jakarta.validation.constraints.Size import org.springframework.stereotype.Service import org.springframework.validation.annotation.Validated @Service @Validated class MyBean { fun findByCodeAndAuthor(code: @Size(min = 8, max = 10) String?, author: Author?): Archive? { return null } } The application’s MessageSource is used when resolving {parameters} in constraint messages. This allows you to use your application’s messages.properties files(../features/internationalization.html) for Bean Validation messages. Once the parameters have been resolved, message interpolation is completed using Bean Validation’s default interpolator. To customize the Configuration used to build the ValidatorFactory , define a ValidationConfigurationCustomizer bean. When multiple customizer beans are defined, they are called in order based on their @Order annotation or Ordered implementation."
"https://docs.spring.io/spring-boot/reference/io/rest-client.html","Calling REST Services: Spring Boot provides various convenient ways to call remote REST services. If you are developing a non-blocking reactive application and you’re using Spring WebFlux, then you can use WebClient . If you prefer blocking APIs then you can use RestClient or RestTemplate . WebClient: If you have Spring WebFlux on your classpath we recommend that you use WebClient to call remote REST services. The WebClient interface provides a functional style API and is fully reactive. You can learn more about the WebClient in the dedicated section in the Spring Framework docs(https://docs.spring.io/spring-framework/reference/6.1/web/webflux-webclient.html) . If you are not writing a reactive Spring WebFlux application you can use the RestClient(#io.rest-client.restclient) instead of a WebClient . This provides a similar functional API, but is blocking rather than reactive. Spring Boot creates and pre-configures a prototype WebClient.Builder bean for you. It is strongly advised to inject it in your components and use it to create WebClient instances. Spring Boot is configuring that builder to share HTTP resources and reflect codecs setup in the same fashion as the server ones (see WebFlux HTTP codecs auto-configuration(../web/reactive.html#web.reactive.webflux.httpcodecs) ), and more. The following code shows a typical example: Java Kotlin import reactor.core.publisher.Mono; import org.springframework.stereotype.Service; import org.springframework.web.reactive.function.client.WebClient; @Service public class MyService { private final WebClient webClient; public MyService(WebClient.Builder webClientBuilder) { this.webClient = webClientBuilder.baseUrl(""https://example.org"").build(); } public Mono<Details> someRestCall(String name) { return this.webClient.get().uri(""/{name}/details"", name).retrieve().bodyToMono(Details.class); } } import org.springframework.stereotype.Service import org.springframework.web.reactive.function.client.WebClient import reactor.core.publisher.Mono @Service class MyService(webClientBuilder: WebClient.Builder) { private val webClient: WebClient init { webClient = webClientBuilder.baseUrl(""https://example.org"").build() } fun someRestCall(name: String?): Mono<Details> { return webClient.get().uri(""/{name}/details"", name) .retrieve().bodyToMono(Details::class.java) } } WebClient Runtime: Spring Boot will auto-detect which ClientHttpConnector to use to drive WebClient depending on the libraries available on the application classpath. In order of preference, the following clients are supported: Reactor Netty Jetty RS client Apache HttpClient JDK HttpClient If multiple clients are available on the classpath, the most preferred client will be used. The spring-boot-starter-webflux starter depends on io.projectreactor.netty:reactor-netty by default, which brings both server and client implementations. If you choose to use Jetty as a reactive server instead, you should add a dependency on the Jetty Reactive HTTP client library, org.eclipse.jetty:jetty-reactive-httpclient . Using the same technology for server and client has its advantages, as it will automatically share HTTP resources between client and server. Developers can override the resource configuration for Jetty and Reactor Netty by providing a custom ReactorResourceFactory or JettyResourceFactory bean - this will be applied to both clients and servers. If you wish to override that choice for the client, you can define your own ClientHttpConnector bean and have full control over the client configuration. You can learn more about the WebClient configuration options in the Spring Framework reference documentation(https://docs.spring.io/spring-framework/reference/6.1/web/webflux-webclient/client-builder.html) . WebClient Customization: There are three main approaches to WebClient customization, depending on how broadly you want the customizations to apply. To make the scope of any customizations as narrow as possible, inject the auto-configured WebClient.Builder and then call its methods as required. WebClient.Builder instances are stateful: Any change on the builder is reflected in all clients subsequently created with it. If you want to create several clients with the same builder, you can also consider cloning the builder with WebClient.Builder other = builder.clone(); . To make an application-wide, additive customization to all WebClient.Builder instances, you can declare WebClientCustomizer beans and change the WebClient.Builder locally at the point of injection. Finally, you can fall back to the original API and use WebClient.create() . In that case, no auto-configuration or WebClientCustomizer is applied. WebClient SSL Support: If you need custom SSL configuration on the ClientHttpConnector used by the WebClient , you can inject a WebClientSsl instance that can be used with the builder’s apply method. The WebClientSsl interface provides access to any SSL bundles(../features/ssl.html#features.ssl.bundles) that you have defined in your application.properties or application.yaml file. The following code shows a typical example: Java Kotlin import reactor.core.publisher.Mono; import org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientSsl; import org.springframework.stereotype.Service; import org.springframework.web.reactive.function.client.WebClient; @Service public class MyService { private final WebClient webClient; public MyService(WebClient.Builder webClientBuilder, WebClientSsl ssl) { this.webClient = webClientBuilder.baseUrl(""https://example.org"").apply(ssl.fromBundle(""mybundle"")).build(); } public Mono<Details> someRestCall(String name) { return this.webClient.get().uri(""/{name}/details"", name).retrieve().bodyToMono(Details.class); } } import org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientSsl import org.springframework.stereotype.Service import org.springframework.web.reactive.function.client.WebClient import reactor.core.publisher.Mono @Service class MyService(webClientBuilder: WebClient.Builder, ssl: WebClientSsl) { private val webClient: WebClient init { webClient = webClientBuilder.baseUrl(""https://example.org"") .apply(ssl.fromBundle(""mybundle"")).build() } fun someRestCall(name: String?): Mono<Details> { return webClient.get().uri(""/{name}/details"", name) .retrieve().bodyToMono(Details::class.java) } } RestClient: If you are not using Spring WebFlux or Project Reactor in your application we recommend that you use RestClient to call remote REST services. The RestClient interface provides a functional style blocking API. Spring Boot creates and pre-configures a prototype RestClient.Builder bean for you. It is strongly advised to inject it in your components and use it to create RestClient instances. Spring Boot is configuring that builder with HttpMessageConverters and an appropriate ClientHttpRequestFactory . The following code shows a typical example: Java Kotlin import org.springframework.stereotype.Service; import org.springframework.web.client.RestClient; @Service public class MyService { private final RestClient restClient; public MyService(RestClient.Builder restClientBuilder) { this.restClient = restClientBuilder.baseUrl(""https://example.org"").build(); } public Details someRestCall(String name) { return this.restClient.get().uri(""/{name}/details"", name).retrieve().body(Details.class); } } import org.springframework.boot.docs.io.restclient.restclient.ssl.Details import org.springframework.stereotype.Service import org.springframework.web.client.RestClient @Service class MyService(restClientBuilder: RestClient.Builder) { private val restClient: RestClient init { restClient = restClientBuilder.baseUrl(""https://example.org"").build() } fun someRestCall(name: String?): Details { return restClient.get().uri(""/{name}/details"", name) .retrieve().body(Details::class.java)!! } } RestClient Customization: There are three main approaches to RestClient customization, depending on how broadly you want the customizations to apply. To make the scope of any customizations as narrow as possible, inject the auto-configured RestClient.Builder and then call its methods as required. RestClient.Builder instances are stateful: Any change on the builder is reflected in all clients subsequently created with it. If you want to create several clients with the same builder, you can also consider cloning the builder with RestClient.Builder other = builder.clone(); . To make an application-wide, additive customization to all RestClient.Builder instances, you can declare RestClientCustomizer beans and change the RestClient.Builder locally at the point of injection. Finally, you can fall back to the original API and use RestClient.create() . In that case, no auto-configuration or RestClientCustomizer is applied. RestClient SSL Support: If you need custom SSL configuration on the ClientHttpRequestFactory used by the RestClient , you can inject a RestClientSsl instance that can be used with the builder’s apply method. The RestClientSsl interface provides access to any SSL bundles(../features/ssl.html#features.ssl.bundles) that you have defined in your application.properties or application.yaml file. The following code shows a typical example: Java Kotlin import org.springframework.boot.autoconfigure.web.client.RestClientSsl; import org.springframework.stereotype.Service; import org.springframework.web.client.RestClient; @Service public class MyService { private final RestClient restClient; public MyService(RestClient.Builder restClientBuilder, RestClientSsl ssl) { this.restClient = restClientBuilder.baseUrl(""https://example.org"").apply(ssl.fromBundle(""mybundle"")).build(); } public Details someRestCall(String name) { return this.restClient.get().uri(""/{name}/details"", name).retrieve().body(Details.class); } } import org.springframework.boot.autoconfigure.web.client.RestClientSsl import org.springframework.boot.docs.io.restclient.restclient.ssl.settings.Details import org.springframework.stereotype.Service import org.springframework.web.client.RestClient @Service class MyService(restClientBuilder: RestClient.Builder, ssl: RestClientSsl) { private val restClient: RestClient init { restClient = restClientBuilder.baseUrl(""https://example.org"") .apply(ssl.fromBundle(""mybundle"")).build() } fun someRestCall(name: String?): Details { return restClient.get().uri(""/{name}/details"", name) .retrieve().body(Details::class.java)!! } } If you need to apply other customization in addition to an SSL bundle, you can use the ClientHttpRequestFactorySettings class with ClientHttpRequestFactories : Java Kotlin import java.time.Duration; import org.springframework.boot.ssl.SslBundles; import org.springframework.boot.web.client.ClientHttpRequestFactories; import org.springframework.boot.web.client.ClientHttpRequestFactorySettings; import org.springframework.http.client.ClientHttpRequestFactory; import org.springframework.stereotype.Service; import org.springframework.web.client.RestClient; @Service public class MyService { private final RestClient restClient; public MyService(RestClient.Builder restClientBuilder, SslBundles sslBundles) { ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.DEFAULTS .withReadTimeout(Duration.ofMinutes(2)) .withSslBundle(sslBundles.getBundle(""mybundle"")); ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories.get(settings); this.restClient = restClientBuilder.baseUrl(""https://example.org"").requestFactory(requestFactory).build(); } public Details someRestCall(String name) { return this.restClient.get().uri(""/{name}/details"", name).retrieve().body(Details.class); } } import org.springframework.boot.ssl.SslBundles import org.springframework.boot.web.client.ClientHttpRequestFactories import org.springframework.boot.web.client.ClientHttpRequestFactorySettings import org.springframework.stereotype.Service import org.springframework.web.client.RestClient import java.time.Duration @Service class MyService(restClientBuilder: RestClient.Builder, sslBundles: SslBundles) { private val restClient: RestClient init { val settings = ClientHttpRequestFactorySettings.DEFAULTS .withReadTimeout(Duration.ofMinutes(2)) .withSslBundle(sslBundles.getBundle(""mybundle"")) val requestFactory = ClientHttpRequestFactories.get(settings) restClient = restClientBuilder .baseUrl(""https://example.org"") .requestFactory(requestFactory).build() } fun someRestCall(name: String?): Details { return restClient.get().uri(""/{name}/details"", name).retrieve().body(Details::class.java)!! } } RestTemplate: Spring Framework’s RestTemplate(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/web/client/RestTemplate.html) class predates RestClient and is the classic way that many applications use to call remote REST services. You might choose to use RestTemplate when you have existing code that you don’t want to migrate to RestClient , or because you’re already familiar with the RestTemplate API. Since RestTemplate instances often need to be customized before being used, Spring Boot does not provide any single auto-configured RestTemplate bean. It does, however, auto-configure a RestTemplateBuilder , which can be used to create RestTemplate instances when needed. The auto-configured RestTemplateBuilder ensures that sensible HttpMessageConverters and an appropriate ClientHttpRequestFactory are applied to RestTemplate instances. The following code shows a typical example: Java Kotlin import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.stereotype.Service; import org.springframework.web.client.RestTemplate; @Service public class MyService { private final RestTemplate restTemplate; public MyService(RestTemplateBuilder restTemplateBuilder) { this.restTemplate = restTemplateBuilder.build(); } public Details someRestCall(String name) { return this.restTemplate.getForObject(""/{name}/details"", Details.class, name); } } import org.springframework.boot.web.client.RestTemplateBuilder import org.springframework.stereotype.Service import org.springframework.web.client.RestTemplate @Service class MyService(restTemplateBuilder: RestTemplateBuilder) { private val restTemplate: RestTemplate init { restTemplate = restTemplateBuilder.build() } fun someRestCall(name: String): Details { return restTemplate.getForObject(""/{name}/details"", Details::class.java, name)!! } } RestTemplateBuilder includes a number of useful methods that can be used to quickly configure a RestTemplate . For example, to add BASIC authentication support, you can use builder.basicAuthentication(""user"", ""password"").build() . RestTemplate Customization: There are three main approaches to RestTemplate customization, depending on how broadly you want the customizations to apply. To make the scope of any customizations as narrow as possible, inject the auto-configured RestTemplateBuilder and then call its methods as required. Each method call returns a new RestTemplateBuilder instance, so the customizations only affect this use of the builder. To make an application-wide, additive customization, use a RestTemplateCustomizer bean. All such beans are automatically registered with the auto-configured RestTemplateBuilder and are applied to any templates that are built with it. The following example shows a customizer that configures the use of a proxy for all hosts except 192.168.0.5 : Java Kotlin import org.apache.hc.client5.http.classic.HttpClient; import org.apache.hc.client5.http.impl.classic.HttpClientBuilder; import org.apache.hc.client5.http.impl.routing.DefaultProxyRoutePlanner; import org.apache.hc.client5.http.routing.HttpRoutePlanner; import org.apache.hc.core5.http.HttpException; import org.apache.hc.core5.http.HttpHost; import org.apache.hc.core5.http.protocol.HttpContext; import org.springframework.boot.web.client.RestTemplateCustomizer; import org.springframework.http.client.HttpComponentsClientHttpRequestFactory; import org.springframework.web.client.RestTemplate; public class MyRestTemplateCustomizer implements RestTemplateCustomizer { @Override public void customize(RestTemplate restTemplate) { HttpRoutePlanner routePlanner = new CustomRoutePlanner(new HttpHost(""proxy.example.com"")); HttpClient httpClient = HttpClientBuilder.create().setRoutePlanner(routePlanner).build(); restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory(httpClient)); } static class CustomRoutePlanner extends DefaultProxyRoutePlanner { CustomRoutePlanner(HttpHost proxy) { super(proxy); } @Override protected HttpHost determineProxy(HttpHost target, HttpContext context) throws HttpException { if (target.getHostName().equals(""192.168.0.5"")) { return null; } return super.determineProxy(target, context); } } } import org.apache.hc.client5.http.classic.HttpClient import org.apache.hc.client5.http.impl.classic.HttpClientBuilder import org.apache.hc.client5.http.impl.routing.DefaultProxyRoutePlanner import org.apache.hc.client5.http.routing.HttpRoutePlanner import org.apache.hc.core5.http.HttpException import org.apache.hc.core5.http.HttpHost import org.apache.hc.core5.http.protocol.HttpContext import org.springframework.boot.web.client.RestTemplateCustomizer import org.springframework.http.client.HttpComponentsClientHttpRequestFactory import org.springframework.web.client.RestTemplate class MyRestTemplateCustomizer : RestTemplateCustomizer { override fun customize(restTemplate: RestTemplate) { val routePlanner: HttpRoutePlanner = CustomRoutePlanner(HttpHost(""proxy.example.com"")) val httpClient: HttpClient = HttpClientBuilder.create().setRoutePlanner(routePlanner).build() restTemplate.requestFactory = HttpComponentsClientHttpRequestFactory(httpClient) } internal class CustomRoutePlanner(proxy: HttpHost?) : DefaultProxyRoutePlanner(proxy) { @Throws(HttpException::class) public override fun determineProxy(target: HttpHost, context: HttpContext): HttpHost? { if (target.hostName == ""192.168.0.5"") { return null } return super.determineProxy(target, context) } } } Finally, you can define your own RestTemplateBuilder bean. Doing so will replace the auto-configured builder. If you want any RestTemplateCustomizer beans to be applied to your custom builder, as the auto-configuration would have done, configure it using a RestTemplateBuilderConfigurer . The following example exposes a RestTemplateBuilder that matches what Spring Boot’s auto-configuration would have done, except that custom connect and read timeouts are also specified: Java Kotlin import java.time.Duration; import org.springframework.boot.autoconfigure.web.client.RestTemplateBuilderConfigurer; import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyRestTemplateBuilderConfiguration { @Bean public RestTemplateBuilder restTemplateBuilder(RestTemplateBuilderConfigurer configurer) { return configurer.configure(new RestTemplateBuilder()) .setConnectTimeout(Duration.ofSeconds(5)) .setReadTimeout(Duration.ofSeconds(2)); } } import org.springframework.boot.autoconfigure.web.client.RestTemplateBuilderConfigurer import org.springframework.boot.web.client.RestTemplateBuilder import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import java.time.Duration @Configuration(proxyBeanMethods = false) class MyRestTemplateBuilderConfiguration { @Bean fun restTemplateBuilder(configurer: RestTemplateBuilderConfigurer): RestTemplateBuilder { return configurer.configure(RestTemplateBuilder()).setConnectTimeout(Duration.ofSeconds(5)) .setReadTimeout(Duration.ofSeconds(2)) } } The most extreme (and rarely used) option is to create your own RestTemplateBuilder bean without using a configurer. In addition to replacing the auto-configured builder, this also prevents any RestTemplateCustomizer beans from being used. RestTemplate SSL Support: If you need custom SSL configuration on the RestTemplate , you can apply an SSL bundle(../features/ssl.html#features.ssl.bundles) to the RestTemplateBuilder as shown in this example: Java Kotlin import org.springframework.boot.docs.io.restclient.resttemplate.Details; import org.springframework.boot.ssl.SslBundles; import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.stereotype.Service; import org.springframework.web.client.RestTemplate; @Service public class MyService { private final RestTemplate restTemplate; public MyService(RestTemplateBuilder restTemplateBuilder, SslBundles sslBundles) { this.restTemplate = restTemplateBuilder.setSslBundle(sslBundles.getBundle(""mybundle"")).build(); } public Details someRestCall(String name) { return this.restTemplate.getForObject(""/{name}/details"", Details.class, name); } } import org.springframework.boot.docs.io.restclient.resttemplate.Details import org.springframework.boot.ssl.SslBundles import org.springframework.boot.web.client.RestTemplateBuilder import org.springframework.stereotype.Service import org.springframework.web.client.RestTemplate @Service class MyService(restTemplateBuilder: RestTemplateBuilder, sslBundles: SslBundles) { private val restTemplate: RestTemplate init { restTemplate = restTemplateBuilder.setSslBundle(sslBundles.getBundle(""mybundle"")).build() } fun someRestCall(name: String): Details { return restTemplate.getForObject(""/{name}/details"", Details::class.java, name)!! } } HTTP Client Detection for RestClient and RestTemplate: Spring Boot will auto-detect which HTTP client to use with RestClient and RestTemplate depending on the libraries available on the application classpath. In order of preference, the following clients are supported: Apache HttpClient Jetty HttpClient OkHttp (deprecated) Simple JDK client ( HttpURLConnection ) If multiple clients are available on the classpath, the most preferred client will be used."
"https://docs.spring.io/spring-boot/reference/io/webservices.html","Web Services: Spring Boot provides Web Services auto-configuration so that all you must do is define your Endpoints . The Spring Web Services features(https://docs.spring.io/spring-ws/docs/4.0.x/reference/html) can be easily accessed with the spring-boot-starter-webservices module. SimpleWsdl11Definition and SimpleXsdSchema beans can be automatically created for your WSDLs and XSDs respectively. To do so, configure their location, as shown in the following example: Properties YAML spring.webservices.wsdl-locations=classpath:/wsdl spring: webservices: wsdl-locations: ""classpath:/wsdl"" Calling Web Services with WebServiceTemplate: If you need to call remote Web services from your application, you can use the WebServiceTemplate(https://docs.spring.io/spring-ws/docs/4.0.x/reference/html#client-web-service-template) class. Since WebServiceTemplate instances often need to be customized before being used, Spring Boot does not provide any single auto-configured WebServiceTemplate bean. It does, however, auto-configure a WebServiceTemplateBuilder , which can be used to create WebServiceTemplate instances when needed. The following code shows a typical example: Java Kotlin import org.springframework.boot.webservices.client.WebServiceTemplateBuilder; import org.springframework.stereotype.Service; import org.springframework.ws.client.core.WebServiceTemplate; import org.springframework.ws.soap.client.core.SoapActionCallback; @Service public class MyService { private final WebServiceTemplate webServiceTemplate; public MyService(WebServiceTemplateBuilder webServiceTemplateBuilder) { this.webServiceTemplate = webServiceTemplateBuilder.build(); } public SomeResponse someWsCall(SomeRequest detailsReq) { return (SomeResponse) this.webServiceTemplate.marshalSendAndReceive(detailsReq, new SoapActionCallback(""https://ws.example.com/action"")); } } import org.springframework.boot.webservices.client.WebServiceTemplateBuilder import org.springframework.stereotype.Service import org.springframework.ws.client.core.WebServiceTemplate import org.springframework.ws.soap.client.core.SoapActionCallback @Service class MyService(webServiceTemplateBuilder: WebServiceTemplateBuilder) { private val webServiceTemplate: WebServiceTemplate init { webServiceTemplate = webServiceTemplateBuilder.build() } fun someWsCall(detailsReq: SomeRequest?): SomeResponse { return webServiceTemplate.marshalSendAndReceive( detailsReq, SoapActionCallback(""https://ws.example.com/action"") ) as SomeResponse } } By default, WebServiceTemplateBuilder detects a suitable HTTP-based WebServiceMessageSender using the available HTTP client libraries on the classpath. You can also customize read and connection timeouts as follows: Java Kotlin import java.time.Duration; import org.springframework.boot.webservices.client.HttpWebServiceMessageSenderBuilder; import org.springframework.boot.webservices.client.WebServiceTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.ws.client.core.WebServiceTemplate; import org.springframework.ws.transport.WebServiceMessageSender; @Configuration(proxyBeanMethods = false) public class MyWebServiceTemplateConfiguration { @Bean public WebServiceTemplate webServiceTemplate(WebServiceTemplateBuilder builder) { WebServiceMessageSender sender = new HttpWebServiceMessageSenderBuilder() .setConnectTimeout(Duration.ofSeconds(5)) .setReadTimeout(Duration.ofSeconds(2)) .build(); return builder.messageSenders(sender).build(); } } import org.springframework.boot.webservices.client.HttpWebServiceMessageSenderBuilder import org.springframework.boot.webservices.client.WebServiceTemplateBuilder import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.ws.client.core.WebServiceTemplate import java.time.Duration @Configuration(proxyBeanMethods = false) class MyWebServiceTemplateConfiguration { @Bean fun webServiceTemplate(builder: WebServiceTemplateBuilder): WebServiceTemplate { val sender = HttpWebServiceMessageSenderBuilder() .setConnectTimeout(Duration.ofSeconds(5)) .setReadTimeout(Duration.ofSeconds(2)) .build() return builder.messageSenders(sender).build() } }"
"https://docs.spring.io/spring-boot/reference/io/jta.html","Distributed Transactions With JTA: Spring Boot supports distributed JTA transactions across multiple XA resources by using a transaction manager retrieved from JNDI. When a JTA environment is detected, Spring’s JtaTransactionManager is used to manage transactions. Auto-configured JMS, DataSource, and JPA beans are upgraded to support XA transactions. You can use standard Spring idioms, such as @Transactional , to participate in a distributed transaction. If you are within a JTA environment and still want to use local transactions, you can set the spring.jta.enabled property to false to disable the JTA auto-configuration. Using a Jakarta EE Managed Transaction Manager: If you package your Spring Boot application as a war or ear file and deploy it to a Jakarta EE application server, you can use your application server’s built-in transaction manager. Spring Boot tries to auto-configure a transaction manager by looking at common JNDI locations ( java:comp/UserTransaction , java:comp/TransactionManager , and so on). When using a transaction service provided by your application server, you generally also want to ensure that all resources are managed by the server and exposed over JNDI. Spring Boot tries to auto-configure JMS by looking for a ConnectionFactory at the JNDI path ( java:/JmsXA or java:/XAConnectionFactory ), and you can use the spring.datasource.jndi-name property(../data/sql.html#data.sql.datasource.jndi) to configure your DataSource . Mixing XA and Non-XA JMS Connections: When using JTA, the primary JMS ConnectionFactory bean is XA-aware and participates in distributed transactions. You can inject into your bean without needing to use any @Qualifier : Java Kotlin public MyBean(ConnectionFactory connectionFactory) { // ... } In some situations, you might want to process certain JMS messages by using a non-XA ConnectionFactory . For example, your JMS processing logic might take longer than the XA timeout. If you want to use a non-XA ConnectionFactory , you can the nonXaJmsConnectionFactory bean: Java Kotlin public MyBean(@Qualifier(""nonXaJmsConnectionFactory"") ConnectionFactory connectionFactory) { // ... } For consistency, the jmsConnectionFactory bean is also provided by using the bean alias xaJmsConnectionFactory : Java Kotlin public MyBean(@Qualifier(""xaJmsConnectionFactory"") ConnectionFactory connectionFactory) { // ... } Supporting an Embedded Transaction Manager: The XAConnectionFactoryWrapper(../../api/java/org/springframework/boot/jms/XAConnectionFactoryWrapper.html) and XADataSourceWrapper(../../api/java/org/springframework/boot/jdbc/XADataSourceWrapper.html) interfaces can be used to support embedded transaction managers. The interfaces are responsible for wrapping XAConnectionFactory and XADataSource beans and exposing them as regular ConnectionFactory and DataSource beans, which transparently enroll in the distributed transaction. DataSource and JMS auto-configuration use JTA variants, provided you have a JtaTransactionManager bean and appropriate XA wrapper beans registered within your ApplicationContext ."
"https://docs.spring.io/spring-boot/reference/messaging/index.html","Messaging: The Spring Framework provides extensive support for integrating with messaging systems, from simplified use of the JMS API using JmsTemplate to a complete infrastructure to receive messages asynchronously. Spring AMQP provides a similar feature set for the Advanced Message Queuing Protocol. Spring Boot also provides auto-configuration options for RabbitTemplate and RabbitMQ. Spring WebSocket natively includes support for STOMP messaging, and Spring Boot has support for that through starters and a small amount of auto-configuration. Spring Boot also has support for Apache Kafka and Apache Pulsar."
"https://docs.spring.io/spring-boot/reference/messaging/jms.html","JMS: The jakarta.jms.ConnectionFactory interface provides a standard method of creating a jakarta.jms.Connection for interacting with a JMS broker. Although Spring needs a ConnectionFactory to work with JMS, you generally need not use it directly yourself and can instead rely on higher level messaging abstractions. (See the relevant section(https://docs.spring.io/spring-framework/reference/6.1/integration/jms.html) of the Spring Framework reference documentation for details.) Spring Boot also auto-configures the necessary infrastructure to send and receive messages. ActiveMQ ""Classic"" Support: When ActiveMQ ""Classic""(https://activemq.apache.org/components/classic) is available on the classpath, Spring Boot can configure a ConnectionFactory . If you use spring-boot-starter-activemq , the necessary dependencies to connect to an ActiveMQ ""Classic"" instance are provided, as is the Spring infrastructure to integrate with JMS. ActiveMQ ""Classic"" configuration is controlled by external configuration properties in spring.activemq.* . By default, ActiveMQ ""Classic"" is auto-configured to use the TCP transport(https://activemq.apache.org/tcp-transport-reference) , connecting by default to tcp://localhost:61616 . The following example shows how to change the default broker URL: Properties YAML spring.activemq.broker-url=tcp://192.168.1.210:9876 spring.activemq.user=admin spring.activemq.password=secret spring: activemq: broker-url: ""tcp://192.168.1.210:9876"" user: ""admin"" password: ""secret"" By default, a CachingConnectionFactory wraps the native ConnectionFactory with sensible settings that you can control by external configuration properties in spring.jms.* : Properties YAML spring.jms.cache.session-cache-size=5 spring: jms: cache: session-cache-size: 5 If you’d rather use native pooling, you can do so by adding a dependency to org.messaginghub:pooled-jms and configuring the JmsPoolConnectionFactory accordingly, as shown in the following example: Properties YAML spring.activemq.pool.enabled=true spring.activemq.pool.max-connections=50 spring: activemq: pool: enabled: true max-connections: 50 See ActiveMQProperties(../../api/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.html) for more of the supported options. You can also register an arbitrary number of beans that implement ActiveMQConnectionFactoryCustomizer for more advanced customizations. By default, ActiveMQ ""Classic"" creates a destination if it does not yet exist so that destinations are resolved against their provided names. ActiveMQ Artemis Support: Spring Boot can auto-configure a ConnectionFactory when it detects that ActiveMQ Artemis(https://activemq.apache.org/components/artemis/) is available on the classpath. If the broker is present, an embedded broker is automatically started and configured (unless the mode property has been explicitly set). The supported modes are embedded (to make explicit that an embedded broker is required and that an error should occur if the broker is not available on the classpath) and native (to connect to a broker using the netty transport protocol). When the latter is configured, Spring Boot configures a ConnectionFactory that connects to a broker running on the local machine with the default settings. If you use spring-boot-starter-artemis , the necessary dependencies to connect to an existing ActiveMQ Artemis instance are provided, as well as the Spring infrastructure to integrate with JMS. Adding org.apache.activemq:artemis-jakarta-server to your application lets you use embedded mode. ActiveMQ Artemis configuration is controlled by external configuration properties in spring.artemis.* . For example, you might declare the following section in application.properties : Properties YAML spring.artemis.mode=native spring.artemis.broker-url=tcp://192.168.1.210:9876 spring.artemis.user=admin spring.artemis.password=secret spring: artemis: mode: native broker-url: ""tcp://192.168.1.210:9876"" user: ""admin"" password: ""secret"" When embedding the broker, you can choose if you want to enable persistence and list the destinations that should be made available. These can be specified as a comma-separated list to create them with the default options, or you can define bean(s) of type org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration or org.apache.activemq.artemis.jms.server.config.TopicConfiguration , for advanced queue and topic configurations, respectively. By default, a CachingConnectionFactory wraps the native ConnectionFactory with sensible settings that you can control by external configuration properties in spring.jms.* : Properties YAML spring.jms.cache.session-cache-size=5 spring: jms: cache: session-cache-size: 5 If you’d rather use native pooling, you can do so by adding a dependency on org.messaginghub:pooled-jms and configuring the JmsPoolConnectionFactory accordingly, as shown in the following example: Properties YAML spring.artemis.pool.enabled=true spring.artemis.pool.max-connections=50 spring: artemis: pool: enabled: true max-connections: 50 See ArtemisProperties(../../api/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.html) for more supported options. No JNDI lookup is involved, and destinations are resolved against their names, using either the name attribute in the ActiveMQ Artemis configuration or the names provided through configuration. Using a JNDI ConnectionFactory: If you are running your application in an application server, Spring Boot tries to locate a JMS ConnectionFactory by using JNDI. By default, the java:/JmsXA and java:/XAConnectionFactory location are checked. You can use the spring.jms.jndi-name property if you need to specify an alternative location, as shown in the following example: Properties YAML spring.jms.jndi-name=java:/MyConnectionFactory spring: jms: jndi-name: ""java:/MyConnectionFactory"" Sending a Message: Spring’s JmsTemplate is auto-configured, and you can autowire it directly into your own beans, as shown in the following example: Java Kotlin import org.springframework.jms.core.JmsTemplate; import org.springframework.stereotype.Component; @Component public class MyBean { private final JmsTemplate jmsTemplate; public MyBean(JmsTemplate jmsTemplate) { this.jmsTemplate = jmsTemplate; } // ... public void someMethod() { this.jmsTemplate.convertAndSend(""hello""); } } import org.springframework.jms.core.JmsTemplate import org.springframework.stereotype.Component @Component class MyBean(private val jmsTemplate: JmsTemplate) { // ... fun someMethod() { jmsTemplate.convertAndSend(""hello"") } } JmsMessagingTemplate(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/jms/core/JmsMessagingTemplate.html) can be injected in a similar manner. If a DestinationResolver or a MessageConverter bean is defined, it is associated automatically to the auto-configured JmsTemplate . Receiving a Message: When the JMS infrastructure is present, any bean can be annotated with @JmsListener to create a listener endpoint. If no JmsListenerContainerFactory has been defined, a default one is configured automatically. If a DestinationResolver , a MessageConverter , or a jakarta.jms.ExceptionListener beans are defined, they are associated automatically with the default factory. By default, the default factory is transactional. If you run in an infrastructure where a JtaTransactionManager is present, it is associated to the listener container by default. If not, the sessionTransacted flag is enabled. In that latter scenario, you can associate your local data store transaction to the processing of an incoming message by adding @Transactional on your listener method (or a delegate thereof). This ensures that the incoming message is acknowledged, once the local transaction has completed. This also includes sending response messages that have been performed on the same JMS session. The following component creates a listener endpoint on the someQueue destination: Java Kotlin import org.springframework.jms.annotation.JmsListener; import org.springframework.stereotype.Component; @Component public class MyBean { @JmsListener(destination = ""someQueue"") public void processMessage(String content) { // ... } } import org.springframework.jms.annotation.JmsListener import org.springframework.stereotype.Component @Component class MyBean { @JmsListener(destination = ""someQueue"") fun processMessage(content: String?) { // ... } } See the @EnableJms(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/jms/annotation/EnableJms.html) API documentation for more details. If you need to create more JmsListenerContainerFactory instances or if you want to override the default, Spring Boot provides a DefaultJmsListenerContainerFactoryConfigurer that you can use to initialize a DefaultJmsListenerContainerFactory with the same settings as the one that is auto-configured. For instance, the following example exposes another factory that uses a specific MessageConverter : Java Kotlin import jakarta.jms.ConnectionFactory; import org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.jms.config.DefaultJmsListenerContainerFactory; @Configuration(proxyBeanMethods = false) public class MyJmsConfiguration { @Bean public DefaultJmsListenerContainerFactory myFactory(DefaultJmsListenerContainerFactoryConfigurer configurer) { DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory(); ConnectionFactory connectionFactory = getCustomConnectionFactory(); configurer.configure(factory, connectionFactory); factory.setMessageConverter(new MyMessageConverter()); return factory; } private ConnectionFactory getCustomConnectionFactory() { return ... } } import jakarta.jms.ConnectionFactory import org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.jms.config.DefaultJmsListenerContainerFactory @Configuration(proxyBeanMethods = false) class MyJmsConfiguration { @Bean fun myFactory(configurer: DefaultJmsListenerContainerFactoryConfigurer): DefaultJmsListenerContainerFactory { val factory = DefaultJmsListenerContainerFactory() val connectionFactory = getCustomConnectionFactory() configurer.configure(factory, connectionFactory) factory.setMessageConverter(MyMessageConverter()) return factory } fun getCustomConnectionFactory() : ConnectionFactory? { return ... } } Then you can use the factory in any @JmsListener -annotated method as follows: Java Kotlin import org.springframework.jms.annotation.JmsListener; import org.springframework.stereotype.Component; @Component public class MyBean { @JmsListener(destination = ""someQueue"", containerFactory = ""myFactory"") public void processMessage(String content) { // ... } } import org.springframework.jms.annotation.JmsListener import org.springframework.stereotype.Component @Component class MyBean { @JmsListener(destination = ""someQueue"", containerFactory = ""myFactory"") fun processMessage(content: String?) { // ... } }"
"https://docs.spring.io/spring-boot/reference/messaging/amqp.html","AMQP: The Advanced Message Queuing Protocol (AMQP) is a platform-neutral, wire-level protocol for message-oriented middleware. The Spring AMQP project applies core Spring concepts to the development of AMQP-based messaging solutions. Spring Boot offers several conveniences for working with AMQP through RabbitMQ, including the spring-boot-starter-amqp starter. RabbitMQ Support: RabbitMQ(https://www.rabbitmq.com/) is a lightweight, reliable, scalable, and portable message broker based on the AMQP protocol. Spring uses RabbitMQ to communicate through the AMQP protocol. RabbitMQ configuration is controlled by external configuration properties in spring.rabbitmq.* . For example, you might declare the following section in application.properties : Properties YAML spring.rabbitmq.host=localhost spring.rabbitmq.port=5672 spring.rabbitmq.username=admin spring.rabbitmq.password=secret spring: rabbitmq: host: ""localhost"" port: 5672 username: ""admin"" password: ""secret"" Alternatively, you could configure the same connection using the addresses attribute: Properties YAML spring.rabbitmq.addresses=amqp://admin:secret@localhost spring: rabbitmq: addresses: ""amqp://admin:secret@localhost"" When specifying addresses that way, the host and port properties are ignored. If the address uses the amqps protocol, SSL support is enabled automatically. See RabbitProperties(../../api/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.html) for more of the supported property-based configuration options. To configure lower-level details of the RabbitMQ ConnectionFactory that is used by Spring AMQP, define a ConnectionFactoryCustomizer bean. If a ConnectionNameStrategy bean exists in the context, it will be automatically used to name connections created by the auto-configured CachingConnectionFactory . To make an application-wide, additive customization to the RabbitTemplate , use a RabbitTemplateCustomizer bean. See Understanding AMQP, the protocol used by RabbitMQ(https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/) for more details. Sending a Message: Spring’s AmqpTemplate and AmqpAdmin are auto-configured, and you can autowire them directly into your own beans, as shown in the following example: Java Kotlin import org.springframework.amqp.core.AmqpAdmin; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.stereotype.Component; @Component public class MyBean { private final AmqpAdmin amqpAdmin; private final AmqpTemplate amqpTemplate; public MyBean(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate) { this.amqpAdmin = amqpAdmin; this.amqpTemplate = amqpTemplate; } // ... public void someMethod() { this.amqpAdmin.getQueueInfo(""someQueue""); } public void someOtherMethod() { this.amqpTemplate.convertAndSend(""hello""); } } import org.springframework.amqp.core.AmqpAdmin import org.springframework.amqp.core.AmqpTemplate import org.springframework.stereotype.Component @Component class MyBean(private val amqpAdmin: AmqpAdmin, private val amqpTemplate: AmqpTemplate) { // ... fun someMethod() { amqpAdmin.getQueueInfo(""someQueue"") } fun someOtherMethod() { amqpTemplate.convertAndSend(""hello"") } } RabbitMessagingTemplate(https://docs.spring.io/spring-amqp/docs/3.1.x/api/org/springframework/amqp/rabbit/core/RabbitMessagingTemplate.html) can be injected in a similar manner. If a MessageConverter bean is defined, it is associated automatically to the auto-configured AmqpTemplate . If necessary, any org.springframework.amqp.core.Queue that is defined as a bean is automatically used to declare a corresponding queue on the RabbitMQ instance. To retry operations, you can enable retries on the AmqpTemplate (for example, in the event that the broker connection is lost): Properties YAML spring.rabbitmq.template.retry.enabled=true spring.rabbitmq.template.retry.initial-interval=2s spring: rabbitmq: template: retry: enabled: true initial-interval: ""2s"" Retries are disabled by default. You can also customize the RetryTemplate programmatically by declaring a RabbitRetryTemplateCustomizer bean. If you need to create more RabbitTemplate instances or if you want to override the default, Spring Boot provides a RabbitTemplateConfigurer bean that you can use to initialize a RabbitTemplate with the same settings as the factories used by the auto-configuration. Sending a Message To A Stream: To send a message to a particular stream, specify the name of the stream, as shown in the following example: Properties YAML spring.rabbitmq.stream.name=my-stream spring: rabbitmq: stream: name: ""my-stream"" If a MessageConverter , StreamMessageConverter , or ProducerCustomizer bean is defined, it is associated automatically to the auto-configured RabbitStreamTemplate . If you need to create more RabbitStreamTemplate instances or if you want to override the default, Spring Boot provides a RabbitStreamTemplateConfigurer bean that you can use to initialize a RabbitStreamTemplate with the same settings as the factories used by the auto-configuration. Receiving a Message: When the Rabbit infrastructure is present, any bean can be annotated with @RabbitListener to create a listener endpoint. If no RabbitListenerContainerFactory has been defined, a default SimpleRabbitListenerContainerFactory is automatically configured and you can switch to a direct container using the spring.rabbitmq.listener.type property. If a MessageConverter or a MessageRecoverer bean is defined, it is automatically associated with the default factory. The following sample component creates a listener endpoint on the someQueue queue: Java Kotlin import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component public class MyBean { @RabbitListener(queues = ""someQueue"") public void processMessage(String content) { // ... } } import org.springframework.amqp.rabbit.annotation.RabbitListener import org.springframework.stereotype.Component @Component class MyBean { @RabbitListener(queues = [""someQueue""]) fun processMessage(content: String?) { // ... } } See @html(https://docs.spring.io/spring-amqp/docs/3.1.x/api/org/springframework/amqp/rabbit/annotation/EnableRabbit/html.html) for more details. If you need to create more RabbitListenerContainerFactory instances or if you want to override the default, Spring Boot provides a SimpleRabbitListenerContainerFactoryConfigurer and a DirectRabbitListenerContainerFactoryConfigurer that you can use to initialize a SimpleRabbitListenerContainerFactory and a DirectRabbitListenerContainerFactory with the same settings as the factories used by the auto-configuration. It does not matter which container type you chose. Those two beans are exposed by the auto-configuration. For instance, the following configuration class exposes another factory that uses a specific MessageConverter : Java Kotlin import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory; import org.springframework.amqp.rabbit.connection.ConnectionFactory; import org.springframework.boot.autoconfigure.amqp.SimpleRabbitListenerContainerFactoryConfigurer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyRabbitConfiguration { @Bean public SimpleRabbitListenerContainerFactory myFactory(SimpleRabbitListenerContainerFactoryConfigurer configurer) { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); ConnectionFactory connectionFactory = getCustomConnectionFactory(); configurer.configure(factory, connectionFactory); factory.setMessageConverter(new MyMessageConverter()); return factory; } private ConnectionFactory getCustomConnectionFactory() { return ... } } import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory import org.springframework.amqp.rabbit.connection.ConnectionFactory import org.springframework.boot.autoconfigure.amqp.SimpleRabbitListenerContainerFactoryConfigurer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyRabbitConfiguration { @Bean fun myFactory(configurer: SimpleRabbitListenerContainerFactoryConfigurer): SimpleRabbitListenerContainerFactory { val factory = SimpleRabbitListenerContainerFactory() val connectionFactory = getCustomConnectionFactory() configurer.configure(factory, connectionFactory) factory.setMessageConverter(MyMessageConverter()) return factory } fun getCustomConnectionFactory() : ConnectionFactory? { return ... } } Then you can use the factory in any @RabbitListener -annotated method, as follows: Java Kotlin import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component public class MyBean { @RabbitListener(queues = ""someQueue"", containerFactory = ""myFactory"") public void processMessage(String content) { // ... } } import org.springframework.amqp.rabbit.annotation.RabbitListener import org.springframework.stereotype.Component @Component class MyBean { @RabbitListener(queues = [""someQueue""], containerFactory = ""myFactory"") fun processMessage(content: String?) { // ... } } You can enable retries to handle situations where your listener throws an exception. By default, RejectAndDontRequeueRecoverer is used, but you can define a MessageRecoverer of your own. When retries are exhausted, the message is rejected and either dropped or routed to a dead-letter exchange if the broker is configured to do so. By default, retries are disabled. You can also customize the RetryTemplate programmatically by declaring a RabbitRetryTemplateCustomizer bean. By default, if retries are disabled and the listener throws an exception, the delivery is retried indefinitely. You can modify this behavior in two ways: Set the defaultRequeueRejected property to false so that zero re-deliveries are attempted or throw an AmqpRejectAndDontRequeueException to signal the message should be rejected. The latter is the mechanism used when retries are enabled and the maximum number of delivery attempts is reached."
"https://docs.spring.io/spring-boot/reference/messaging/kafka.html","Apache Kafka Support: Apache Kafka(https://kafka.apache.org/) is supported by providing auto-configuration of the spring-kafka project. Kafka configuration is controlled by external configuration properties in spring.kafka.* . For example, you might declare the following section in application.properties : Properties YAML spring.kafka.bootstrap-servers=localhost:9092 spring.kafka.consumer.group-id=myGroup spring: kafka: bootstrap-servers: ""localhost:9092"" consumer: group-id: ""myGroup"" To create a topic on startup, add a bean of type NewTopic . If the topic already exists, the bean is ignored. See KafkaProperties(../../api/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.html) for more supported options. Sending a Message: Spring’s KafkaTemplate is auto-configured, and you can autowire it directly in your own beans, as shown in the following example: Java Kotlin import org.springframework.kafka.core.KafkaTemplate; import org.springframework.stereotype.Component; @Component public class MyBean { private final KafkaTemplate<String, String> kafkaTemplate; public MyBean(KafkaTemplate<String, String> kafkaTemplate) { this.kafkaTemplate = kafkaTemplate; } // ... public void someMethod() { this.kafkaTemplate.send(""someTopic"", ""Hello""); } } import org.springframework.kafka.core.KafkaTemplate import org.springframework.stereotype.Component @Component class MyBean(private val kafkaTemplate: KafkaTemplate<String, String>) { // ... fun someMethod() { kafkaTemplate.send(""someTopic"", ""Hello"") } } If the property spring.kafka.producer.transaction-id-prefix is defined, a KafkaTransactionManager is automatically configured. Also, if a RecordMessageConverter bean is defined, it is automatically associated to the auto-configured KafkaTemplate . Receiving a Message: When the Apache Kafka infrastructure is present, any bean can be annotated with @KafkaListener to create a listener endpoint. If no KafkaListenerContainerFactory has been defined, a default one is automatically configured with keys defined in spring.kafka.listener.* . The following component creates a listener endpoint on the someTopic topic: Java Kotlin import org.springframework.kafka.annotation.KafkaListener; import org.springframework.stereotype.Component; @Component public class MyBean { @KafkaListener(topics = ""someTopic"") public void processMessage(String content) { // ... } } import org.springframework.kafka.annotation.KafkaListener import org.springframework.stereotype.Component @Component class MyBean { @KafkaListener(topics = [""someTopic""]) fun processMessage(content: String?) { // ... } } If a KafkaTransactionManager bean is defined, it is automatically associated to the container factory. Similarly, if a RecordFilterStrategy , CommonErrorHandler , AfterRollbackProcessor or ConsumerAwareRebalanceListener bean is defined, it is automatically associated to the default factory. Depending on the listener type, a RecordMessageConverter or BatchMessageConverter bean is associated to the default factory. If only a RecordMessageConverter bean is present for a batch listener, it is wrapped in a BatchMessageConverter . A custom ChainedKafkaTransactionManager must be marked @Primary as it usually references the auto-configured KafkaTransactionManager bean. Kafka Streams: Spring for Apache Kafka provides a factory bean to create a StreamsBuilder object and manage the lifecycle of its streams. Spring Boot auto-configures the required KafkaStreamsConfiguration bean as long as kafka-streams is on the classpath and Kafka Streams is enabled by the @EnableKafkaStreams annotation. Enabling Kafka Streams means that the application id and bootstrap servers must be set. The former can be configured using spring.kafka.streams.application-id , defaulting to spring.application.name if not set. The latter can be set globally or specifically overridden only for streams. Several additional properties are available using dedicated properties; other arbitrary Kafka properties can be set using the spring.kafka.streams.properties namespace. See also Additional Kafka Properties(#messaging.kafka.additional-properties) for more information. To use the factory bean, wire StreamsBuilder into your @Bean as shown in the following example: Java Kotlin import org.apache.kafka.common.serialization.Serdes; import org.apache.kafka.streams.KeyValue; import org.apache.kafka.streams.StreamsBuilder; import org.apache.kafka.streams.kstream.KStream; import org.apache.kafka.streams.kstream.Produced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.kafka.annotation.EnableKafkaStreams; import org.springframework.kafka.support.serializer.JsonSerde; @Configuration(proxyBeanMethods = false) @EnableKafkaStreams public class MyKafkaStreamsConfiguration { @Bean public KStream<Integer, String> kStream(StreamsBuilder streamsBuilder) { KStream<Integer, String> stream = streamsBuilder.stream(""ks1In""); stream.map(this::uppercaseValue).to(""ks1Out"", Produced.with(Serdes.Integer(), new JsonSerde<>())); return stream; } private KeyValue<Integer, String> uppercaseValue(Integer key, String value) { return new KeyValue<>(key, value.toUpperCase()); } } import org.apache.kafka.common.serialization.Serdes import org.apache.kafka.streams.KeyValue import org.apache.kafka.streams.StreamsBuilder import org.apache.kafka.streams.kstream.KStream import org.apache.kafka.streams.kstream.Produced import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.kafka.annotation.EnableKafkaStreams import org.springframework.kafka.support.serializer.JsonSerde @Configuration(proxyBeanMethods = false) @EnableKafkaStreams class MyKafkaStreamsConfiguration { @Bean fun kStream(streamsBuilder: StreamsBuilder): KStream<Int, String> { val stream = streamsBuilder.stream<Int, String>(""ks1In"") stream.map(this::uppercaseValue).to(""ks1Out"", Produced.with(Serdes.Integer(), JsonSerde())) return stream } private fun uppercaseValue(key: Int, value: String): KeyValue<Int?, String?> { return KeyValue(key, value.uppercase()) } } By default, the streams managed by the StreamBuilder object are started automatically. You can customize this behavior using the spring.kafka.streams.auto-startup property. Additional Kafka Properties: The properties supported by auto configuration are shown in the Integration Properties(../../appendix/application-properties/index.html#appendix.application-properties.integration) section of the Appendix. Note that, for the most part, these properties (hyphenated or camelCase) map directly to the Apache Kafka dotted properties. See the Apache Kafka documentation for details. Properties that don’t include a client type ( producer , consumer , admin , or streams ) in their name are considered to be common and apply to all clients. Most of these common properties can be overridden for one or more of the client types, if needed. Apache Kafka designates properties with an importance of HIGH, MEDIUM, or LOW. Spring Boot auto-configuration supports all HIGH importance properties, some selected MEDIUM and LOW properties, and any properties that do not have a default value. Only a subset of the properties supported by Kafka are available directly through the KafkaProperties class. If you wish to configure the individual client types with additional properties that are not directly supported, use the following properties: Properties YAML spring.kafka.properties[prop.one]=first spring.kafka.admin.properties[prop.two]=second spring.kafka.consumer.properties[prop.three]=third spring.kafka.producer.properties[prop.four]=fourth spring.kafka.streams.properties[prop.five]=fifth spring: kafka: properties: ""[prop.one]"": ""first"" admin: properties: ""[prop.two]"": ""second"" consumer: properties: ""[prop.three]"": ""third"" producer: properties: ""[prop.four]"": ""fourth"" streams: properties: ""[prop.five]"": ""fifth"" This sets the common prop.one Kafka property to first (applies to producers, consumers, admins, and streams), the prop.two admin property to second , the prop.three consumer property to third , the prop.four producer property to fourth and the prop.five streams property to fifth . You can also configure the Spring Kafka JsonDeserializer as follows: Properties YAML spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer spring.kafka.consumer.properties[spring.json.value.default.type]=com.example.Invoice spring.kafka.consumer.properties[spring.json.trusted.packages]=com.example.main,com.example.another spring: kafka: consumer: value-deserializer: ""org.springframework.kafka.support.serializer.JsonDeserializer"" properties: ""[spring.json.value.default.type]"": ""com.example.Invoice"" ""[spring.json.trusted.packages]"": ""com.example.main,com.example.another"" Similarly, you can disable the JsonSerializer default behavior of sending type information in headers: Properties YAML spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer spring.kafka.producer.properties[spring.json.add.type.headers]=false spring: kafka: producer: value-serializer: ""org.springframework.kafka.support.serializer.JsonSerializer"" properties: ""[spring.json.add.type.headers]"": false Properties set in this way override any configuration item that Spring Boot explicitly supports. Testing with Embedded Kafka: Spring for Apache Kafka provides a convenient way to test projects with an embedded Apache Kafka broker. To use this feature, annotate a test class with @EmbeddedKafka from the spring-kafka-test module. For more information, please see the Spring for Apache Kafka reference manual(https://docs.spring.io/spring-kafka/reference/3.2/testing.html#ekb) . To make Spring Boot auto-configuration work with the aforementioned embedded Apache Kafka broker, you need to remap a system property for embedded broker addresses (populated by the EmbeddedKafkaBroker ) into the Spring Boot configuration property for Apache Kafka. There are several ways to do that: Provide a system property to map embedded broker addresses into spring.kafka.bootstrap-servers in the test class: Java Kotlin static { System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, ""spring.kafka.bootstrap-servers""); } init { System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, ""spring.kafka.bootstrap-servers"") } Configure a property name on the @EmbeddedKafka annotation: Java Kotlin import org.springframework.boot.test.context.SpringBootTest; import org.springframework.kafka.test.context.EmbeddedKafka; @SpringBootTest @EmbeddedKafka(topics = ""someTopic"", bootstrapServersProperty = ""spring.kafka.bootstrap-servers"") class MyTest { // ... } import org.springframework.boot.test.context.SpringBootTest import org.springframework.kafka.test.context.EmbeddedKafka @SpringBootTest @EmbeddedKafka(topics = [""someTopic""], bootstrapServersProperty = ""spring.kafka.bootstrap-servers"") class MyTest { // ... } Use a placeholder in configuration properties: Properties YAML spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers} spring: kafka: bootstrap-servers: ""${spring.embedded.kafka.brokers}"""
"https://docs.spring.io/spring-boot/reference/messaging/pulsar.html","Apache Pulsar Support: Apache Pulsar(https://pulsar.apache.org/) is supported by providing auto-configuration of the Spring for Apache Pulsar(https://spring.io/projects/spring-pulsar) project. Spring Boot will auto-configure and register the classic (imperative) Spring for Apache Pulsar components when org.springframework.pulsar:spring-pulsar is on the classpath. It will do the same for the reactive components when org.springframework.pulsar:spring-pulsar-reactive is on the classpath. There are spring-boot-starter-pulsar and spring-boot-starter-pulsar-reactive starters for conveniently collecting the dependencies for imperative and reactive use, respectively. Connecting to Pulsar: When you use the Pulsar starter, Spring Boot will auto-configure and register a PulsarClient bean. By default, the application tries to connect to a local Pulsar instance at pulsar://localhost:6650 . This can be adjusted by setting the spring.pulsar.client.service-url property to a different value. The value must be a valid Pulsar Protocol(https://pulsar.apache.org/docs/client-libraries-java/#connection-urls) URL You can configure the client by specifying any of the spring.pulsar.client.* prefixed application properties. If you need more control over the configuration, consider registering one or more PulsarClientBuilderCustomizer beans. Authentication: To connect to a Pulsar cluster that requires authentication, you need to specify which authentication plugin to use by setting the pluginClassName and any parameters required by the plugin. You can set the parameters as a map of parameter names to parameter values. The following example shows how to configure the AuthenticationOAuth2 plugin. Properties YAML spring.pulsar.client.authentication.plugin-class-name=org.apache.pulsar.client.impl.auth.oauth2.AuthenticationOAuth2 spring.pulsar.client.authentication.param.issuerUrl=https://auth.server.cloud/ spring.pulsar.client.authentication.param.privateKey=file:///Users/some-key.json spring.pulsar.client.authentication.param.audience=urn:sn:acme:dev:my-instance spring: pulsar: client: authentication: plugin-class-name: org.apache.pulsar.client.impl.auth.oauth2.AuthenticationOAuth2 param: issuerUrl: https://auth.server.cloud/ privateKey: file:///Users/some-key.json audience: urn:sn:acme:dev:my-instance You need to ensure that names defined under spring.pulsar.client.authentication.param.* exactly match those expected by your auth plugin (which is typically camel cased). Spring Boot will not attempt any kind of relaxed binding for these entries. For example, if you want to configure the issuer url for the AuthenticationOAuth2 auth plugin you must use spring.pulsar.client.authentication.param.issuerUrl . If you use other forms, such as issuerurl or issuer-url , the setting will not be applied to the plugin. This lack of relaxed binding also makes using environment variables for authentication parameters problematic because the case sensitivity is lost during translation. If you use environment variables for the parameters then you will need to follow these steps(https://docs.spring.io/spring-pulsar/docs/1.1.x/reference/reference/pulsar/pulsar-client.html#client-authentication-env-vars) in the Spring for Apache Pulsar reference documentation for it to work properly. SSL: By default, Pulsar clients communicate with Pulsar services in plain text. You can follow these steps(https://docs.spring.io/spring-pulsar/docs/1.1.x/reference/reference/pulsar/pulsar-client.html#tls-encryption) in the Spring for Apache Pulsar reference documentation to enable TLS encryption. For complete details on the client and authentication see the Spring for Apache Pulsar reference documentation(https://docs.spring.io/spring-pulsar/docs/1.1.x/reference/reference/pulsar/pulsar-client.html) . Connecting to Pulsar Reactively: When the Reactive auto-configuration is activated, Spring Boot will auto-configure and register a ReactivePulsarClient bean. The ReactivePulsarClient adapts an instance of the previously described PulsarClient . Therefore, follow the previous section to configure the PulsarClient used by the ReactivePulsarClient . Connecting to Pulsar Administration: Spring for Apache Pulsar’s PulsarAdministration client is also auto-configured. By default, the application tries to connect to a local Pulsar instance at http://localhost:8080 . This can be adjusted by setting the spring.pulsar.admin.service-url property to a different value in the form (http|https)://<host>:<port> . If you need more control over the configuration, consider registering one or more PulsarAdminBuilderCustomizer beans. Authentication: When accessing a Pulsar cluster that requires authentication, the admin client requires the same security configuration as the regular Pulsar client. You can use the aforementioned authentication configuration(#messaging.pulsar.connecting.auth) by replacing spring.pulsar.client.authentication with spring.pulsar.admin.authentication . To create a topic on startup, add a bean of type PulsarTopic . If the topic already exists, the bean is ignored. Sending a Message: Spring’s PulsarTemplate is auto-configured, and you can use it to send messages, as shown in the following example: Java Kotlin import org.springframework.pulsar.core.PulsarTemplate; import org.springframework.stereotype.Component; @Component public class MyBean { private final PulsarTemplate<String> pulsarTemplate; public MyBean(PulsarTemplate<String> pulsarTemplate) { this.pulsarTemplate = pulsarTemplate; } public void someMethod() { this.pulsarTemplate.send(""someTopic"", ""Hello""); } } import org.apache.pulsar.client.api.PulsarClientException import org.springframework.pulsar.core.PulsarTemplate import org.springframework.stereotype.Component @Component class MyBean(private val pulsarTemplate: PulsarTemplate<String>) { @Throws(PulsarClientException::class) fun someMethod() { pulsarTemplate.send(""someTopic"", ""Hello"") } } The PulsarTemplate relies on a PulsarProducerFactory to create the underlying Pulsar producer. Spring Boot auto-configuration also provides this producer factory, which by default, caches the producers that it creates. You can configure the producer factory and cache settings by specifying any of the spring.pulsar.producer.* and spring.pulsar.producer.cache.* prefixed application properties. If you need more control over the producer factory configuration, consider registering one or more ProducerBuilderCustomizer beans. These customizers are applied to all created producers. You can also pass in a ProducerBuilderCustomizer when sending a message to only affect the current producer. If you need more control over the message being sent, you can pass in a TypedMessageBuilderCustomizer when sending a message. Sending a Message Reactively: When the Reactive auto-configuration is activated, Spring’s ReactivePulsarTemplate is auto-configured, and you can use it to send messages, as shown in the following example: Java Kotlin import org.springframework.pulsar.reactive.core.ReactivePulsarTemplate; import org.springframework.stereotype.Component; @Component public class MyBean { private final ReactivePulsarTemplate<String> pulsarTemplate; public MyBean(ReactivePulsarTemplate<String> pulsarTemplate) { this.pulsarTemplate = pulsarTemplate; } public void someMethod() { this.pulsarTemplate.send(""someTopic"", ""Hello"").subscribe(); } } import org.springframework.pulsar.reactive.core.ReactivePulsarTemplate import org.springframework.stereotype.Component @Component class MyBean(private val pulsarTemplate: ReactivePulsarTemplate<String>) { fun someMethod() { pulsarTemplate.send(""someTopic"", ""Hello"").subscribe() } } The ReactivePulsarTemplate relies on a ReactivePulsarSenderFactory to actually create the underlying sender. Spring Boot auto-configuration also provides this sender factory, which by default, caches the producers that it creates. You can configure the sender factory and cache settings by specifying any of the spring.pulsar.producer.* and spring.pulsar.producer.cache.* prefixed application properties. If you need more control over the sender factory configuration, consider registering one or more ReactiveMessageSenderBuilderCustomizer beans. These customizers are applied to all created senders. You can also pass in a ReactiveMessageSenderBuilderCustomizer when sending a message to only affect the current sender. If you need more control over the message being sent, you can pass in a MessageSpecBuilderCustomizer when sending a message. Receiving a Message: When the Apache Pulsar infrastructure is present, any bean can be annotated with @PulsarListener to create a listener endpoint. The following component creates a listener endpoint on the someTopic topic: Java Kotlin import org.springframework.pulsar.annotation.PulsarListener; import org.springframework.stereotype.Component; @Component public class MyBean { @PulsarListener(topics = ""someTopic"") public void processMessage(String content) { // ... } } import org.springframework.pulsar.annotation.PulsarListener import org.springframework.stereotype.Component @Component class MyBean { @PulsarListener(topics = [""someTopic""]) fun processMessage(content: String?) { // ... } } Spring Boot auto-configuration provides all the components necessary for PulsarListener , such as the PulsarListenerContainerFactory and the consumer factory it uses to construct the underlying Pulsar consumers. You can configure these components by specifying any of the spring.pulsar.listener.* and spring.pulsar.consumer.* prefixed application properties. If you need more control over the consumer factory configuration, consider registering one or more ConsumerBuilderCustomizer beans. These customizers are applied to all consumers created by the factory, and therefore all @PulsarListener instances. You can also customize a single listener by setting the consumerCustomizer attribute of the @PulsarListener annotation. Receiving a Message Reactively: When the Apache Pulsar infrastructure is present and the Reactive auto-configuration is activated, any bean can be annotated with @ReactivePulsarListener to create a reactive listener endpoint. The following component creates a reactive listener endpoint on the someTopic topic: Java Kotlin import reactor.core.publisher.Mono; import org.springframework.pulsar.reactive.config.annotation.ReactivePulsarListener; import org.springframework.stereotype.Component; @Component public class MyBean { @ReactivePulsarListener(topics = ""someTopic"") public Mono<Void> processMessage(String content) { // ... return Mono.empty(); } } import org.springframework.pulsar.reactive.config.annotation.ReactivePulsarListener import org.springframework.stereotype.Component import reactor.core.publisher.Mono @Component class MyBean { @ReactivePulsarListener(topics = [""someTopic""]) fun processMessage(content: String?): Mono<Void> { // ... return Mono.empty() } } Spring Boot auto-configuration provides all the components necessary for ReactivePulsarListener , such as the ReactivePulsarListenerContainerFactory and the consumer factory it uses to construct the underlying reactive Pulsar consumers. You can configure these components by specifying any of the spring.pulsar.listener.* and spring.pulsar.consumer.* prefixed application properties. If you need more control over the consumer factory configuration, consider registering one or more ReactiveMessageConsumerBuilderCustomizer beans. These customizers are applied to all consumers created by the factory, and therefore all @ReactivePulsarListener instances. You can also customize a single listener by setting the consumerCustomizer attribute of the @ReactivePulsarListener annotation. Reading a Message: The Pulsar reader interface enables applications to manually manage cursors. When you use a reader to connect to a topic you need to specify which message the reader begins reading from when it connects to a topic. When the Apache Pulsar infrastructure is present, any bean can be annotated with @PulsarReader to consume messages using a reader. The following component creates a reader endpoint that starts reading messages from the beginning of the someTopic topic: Java Kotlin import org.springframework.pulsar.annotation.PulsarReader; import org.springframework.stereotype.Component; @Component public class MyBean { @PulsarReader(topics = ""someTopic"", startMessageId = ""earliest"") public void processMessage(String content) { // ... } } import org.springframework.pulsar.annotation.PulsarReader import org.springframework.stereotype.Component @Component class MyBean { @PulsarReader(topics = [""someTopic""], startMessageId = ""earliest"") fun processMessage(content: String?) { // ... } } The @PulsarReader relies on a PulsarReaderFactory to create the underlying Pulsar reader. Spring Boot auto-configuration provides this reader factory which can be customized by setting any of the spring.pulsar.reader.* prefixed application properties. If you need more control over the reader factory configuration, consider registering one or more ReaderBuilderCustomizer beans. These customizers are applied to all readers created by the factory, and therefore all @PulsarReader instances. You can also customize a single listener by setting the readerCustomizer attribute of the @PulsarReader annotation. Reading a Message Reactively: When the Apache Pulsar infrastructure is present and the Reactive auto-configuration is activated, Spring’s ReactivePulsarReaderFactory is provided, and you can use it to create a reader in order to read messages in a reactive fashion. The following component creates a reader using the provided factory and reads a single message from 5 minutes ago from the someTopic topic: Java Kotlin import java.time.Instant; import java.util.List; import org.apache.pulsar.client.api.Message; import org.apache.pulsar.client.api.Schema; import org.apache.pulsar.reactive.client.api.StartAtSpec; import reactor.core.publisher.Mono; import org.springframework.pulsar.reactive.core.ReactiveMessageReaderBuilderCustomizer; import org.springframework.pulsar.reactive.core.ReactivePulsarReaderFactory; import org.springframework.stereotype.Component; @Component public class MyBean { private final ReactivePulsarReaderFactory<String> pulsarReaderFactory; public MyBean(ReactivePulsarReaderFactory<String> pulsarReaderFactory) { this.pulsarReaderFactory = pulsarReaderFactory; } public void someMethod() { ReactiveMessageReaderBuilderCustomizer<String> readerBuilderCustomizer = (readerBuilder) -> readerBuilder .topic(""someTopic"") .startAtSpec(StartAtSpec.ofInstant(Instant.now().minusSeconds(5))); Mono<Message<String>> message = this.pulsarReaderFactory .createReader(Schema.STRING, List.of(readerBuilderCustomizer)) .readOne(); // ... } } import org.apache.pulsar.client.api.Schema import org.apache.pulsar.reactive.client.api.ReactiveMessageReaderBuilder import org.apache.pulsar.reactive.client.api.StartAtSpec import org.springframework.pulsar.reactive.core.ReactiveMessageReaderBuilderCustomizer import org.springframework.pulsar.reactive.core.ReactivePulsarReaderFactory import org.springframework.stereotype.Component import java.time.Instant @Component class MyBean(private val pulsarReaderFactory: ReactivePulsarReaderFactory<String>) { fun someMethod() { val readerBuilderCustomizer = ReactiveMessageReaderBuilderCustomizer { readerBuilder: ReactiveMessageReaderBuilder<String> -> readerBuilder .topic(""someTopic"") .startAtSpec(StartAtSpec.ofInstant(Instant.now().minusSeconds(5))) } val message = pulsarReaderFactory .createReader(Schema.STRING, listOf(readerBuilderCustomizer)) .readOne() // ... } } Spring Boot auto-configuration provides this reader factory which can be customized by setting any of the spring.pulsar.reader.* prefixed application properties. If you need more control over the reader factory configuration, consider passing in one or more ReactiveMessageReaderBuilderCustomizer instances when using the factory to create a reader. If you need more control over the reader factory configuration, consider registering one or more ReactiveMessageReaderBuilderCustomizer beans. These customizers are applied to all created readers. You can also pass one or more ReactiveMessageReaderBuilderCustomizer when creating a reader to only apply the customizations to the created reader. For more details on any of the above components and to discover other available features, see the Spring for Apache Pulsar reference documentation(https://docs.spring.io/spring-pulsar/docs/1.1.x/reference) . Transaction Support: Spring for Apache Pulsar supports transactions when using PulsarTemplate and @PulsarListener . Transactions are not currently supported when using the reactive variants. Setting the spring.pulsar.transaction.enabled property to true will: Configure a PulsarTransactionManager bean Enable transaction support for PulsarTemplate Enable transaction support for @PulsarListener methods The transactional attribute of @PulsarListener can be used to fine-tune when transactions should be used with listeners. For more control of the Spring for Apache Pulsar transaction features you should define your own PulsarTemplate and/or ConcurrentPulsarListenerContainerFactory beans. You can also define a PulsarAwareTransactionManager bean if the default auto-configured PulsarTransactionManager is not suitable. Additional Pulsar Properties: The properties supported by auto-configuration are shown in the Integration Properties(../../appendix/application-properties/index.html#appendix.application-properties.integration) section of the Appendix. Note that, for the most part, these properties (hyphenated or camelCase) map directly to the Apache Pulsar configuration properties. See the Apache Pulsar documentation for details. Only a subset of the properties supported by Pulsar are available directly through the PulsarProperties class. If you wish to tune the auto-configured components with additional properties that are not directly supported, you can use the customizer supported by each aforementioned component."
"https://docs.spring.io/spring-boot/reference/messaging/rsocket.html","RSocket: RSocket(https://rsocket.io) is a binary protocol for use on byte stream transports. It enables symmetric interaction models through async message passing over a single connection. The spring-messaging module of the Spring Framework provides support for RSocket requesters and responders, both on the client and on the server side. See the RSocket section(https://docs.spring.io/spring-framework/reference/6.1/rsocket.html#rsocket-spring) of the Spring Framework reference for more details, including an overview of the RSocket protocol. RSocket Strategies Auto-configuration: Spring Boot auto-configures an RSocketStrategies bean that provides all the required infrastructure for encoding and decoding RSocket payloads. By default, the auto-configuration will try to configure the following (in order): CBOR(https://cbor.io/) codecs with Jackson JSON codecs with Jackson The spring-boot-starter-rsocket starter provides both dependencies. See the Jackson support section(../features/json.html#features.json.jackson) to know more about customization possibilities. Developers can customize the RSocketStrategies component by creating beans that implement the RSocketStrategiesCustomizer interface. Note that their @Order is important, as it determines the order of codecs. RSocket Server Auto-configuration: Spring Boot provides RSocket server auto-configuration. The required dependencies are provided by the spring-boot-starter-rsocket . Spring Boot allows exposing RSocket over WebSocket from a WebFlux server, or standing up an independent RSocket server. This depends on the type of application and its configuration. For WebFlux application (that is of type WebApplicationType.REACTIVE ), the RSocket server will be plugged into the Web Server only if the following properties match: Properties YAML spring.rsocket.server.mapping-path=/rsocket spring.rsocket.server.transport=websocket spring: rsocket: server: mapping-path: ""/rsocket"" transport: ""websocket"" Plugging RSocket into a web server is only supported with Reactor Netty, as RSocket itself is built with that library. Alternatively, an RSocket TCP or websocket server is started as an independent, embedded server. Besides the dependency requirements, the only required configuration is to define a port for that server: Properties YAML spring.rsocket.server.port=9898 spring: rsocket: server: port: 9898 Spring Messaging RSocket Support: Spring Boot will auto-configure the Spring Messaging infrastructure for RSocket. This means that Spring Boot will create a RSocketMessageHandler bean that will handle RSocket requests to your application. Calling RSocket Services with RSocketRequester: Once the RSocket channel is established between server and client, any party can send or receive requests to the other. As a server, you can get injected with an RSocketRequester instance on any handler method of an RSocket @Controller . As a client, you need to configure and establish an RSocket connection first. Spring Boot auto-configures an RSocketRequester.Builder for such cases with the expected codecs and applies any RSocketConnectorConfigurer bean. The RSocketRequester.Builder instance is a prototype bean, meaning each injection point will provide you with a new instance . This is done on purpose since this builder is stateful and you should not create requesters with different setups using the same instance. The following code shows a typical example: Java Kotlin import reactor.core.publisher.Mono; import org.springframework.messaging.rsocket.RSocketRequester; import org.springframework.stereotype.Service; @Service public class MyService { private final RSocketRequester rsocketRequester; public MyService(RSocketRequester.Builder rsocketRequesterBuilder) { this.rsocketRequester = rsocketRequesterBuilder.tcp(""example.org"", 9898); } public Mono<User> someRSocketCall(String name) { return this.rsocketRequester.route(""user"").data(name).retrieveMono(User.class); } } import org.springframework.messaging.rsocket.RSocketRequester import org.springframework.stereotype.Service import reactor.core.publisher.Mono @Service class MyService(rsocketRequesterBuilder: RSocketRequester.Builder) { private val rsocketRequester: RSocketRequester init { rsocketRequester = rsocketRequesterBuilder.tcp(""example.org"", 9898) } fun someRSocketCall(name: String): Mono<User> { return rsocketRequester.route(""user"").data(name).retrieveMono( User::class.java ) } }"
"https://docs.spring.io/spring-boot/reference/messaging/spring-integration.html","Spring Integration: Spring Boot offers several conveniences for working with Spring Integration(https://spring.io/projects/spring-integration) , including the spring-boot-starter-integration starter. Spring Integration provides abstractions over messaging and also other transports such as HTTP, TCP, and others. If Spring Integration is available on your classpath, it is initialized through the @EnableIntegration annotation. Spring Integration polling logic relies on the auto-configured TaskScheduler(../features/task-execution-and-scheduling.html) . The default PollerMetadata (poll unbounded number of messages every second) can be customized with spring.integration.poller.* configuration properties. Spring Boot also configures some features that are triggered by the presence of additional Spring Integration modules. If spring-integration-jmx is also on the classpath, message processing statistics are published over JMX. If spring-integration-jdbc is available, the default database schema can be created on startup, as shown in the following line: Properties YAML spring.integration.jdbc.initialize-schema=always spring: integration: jdbc: initialize-schema: ""always"" If spring-integration-rsocket is available, developers can configure an RSocket server using spring.rsocket.server.* properties and let it use IntegrationRSocketEndpoint or RSocketOutboundGateway components to handle incoming RSocket messages. This infrastructure can handle Spring Integration RSocket channel adapters and @MessageMapping handlers (given spring.integration.rsocket.server.message-mapping-enabled is configured). Spring Boot can also auto-configure an ClientRSocketConnector using configuration properties: Properties YAML spring.integration.rsocket.client.host=example.org spring.integration.rsocket.client.port=9898 # Connecting to a RSocket server over TCP spring: integration: rsocket: client: host: ""example.org"" port: 9898 Properties YAML spring.integration.rsocket.client.uri=ws://example.org # Connecting to a RSocket Server over WebSocket spring: integration: rsocket: client: uri: ""ws://example.org"" See the IntegrationAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java) and IntegrationProperties(../../api/java/org/springframework/boot/autoconfigure/integration/IntegrationProperties.html) classes for more details."
"https://docs.spring.io/spring-boot/reference/messaging/websockets.html","WebSockets: Spring Boot provides WebSockets auto-configuration for embedded Tomcat, Jetty, and Undertow. If you deploy a war file to a standalone container, Spring Boot assumes that the container is responsible for the configuration of its WebSocket support. Spring Framework provides rich WebSocket support(https://docs.spring.io/spring-framework/reference/6.1/web/websocket.html) for MVC web applications that can be easily accessed through the spring-boot-starter-websocket module. WebSocket support is also available for reactive web applications(https://docs.spring.io/spring-framework/reference/6.1/web/webflux-websocket.html) and requires to include the WebSocket API alongside spring-boot-starter-webflux : <dependency> <groupId>jakarta.websocket</groupId> <artifactId>jakarta.websocket-api</artifactId> </dependency>"
"https://docs.spring.io/spring-boot/reference/testing/index.html","Testing: Spring Boot provides a number of utilities and annotations to help when testing your application. Test support is provided by two modules: spring-boot-test contains core items, and spring-boot-test-autoconfigure supports auto-configuration for tests. Most developers use the spring-boot-starter-test starter, which imports both Spring Boot test modules as well as JUnit Jupiter, AssertJ, Hamcrest, and a number of other useful libraries. If you have tests that use JUnit 4, JUnit 5’s vintage engine can be used to run them. To use the vintage engine, add a dependency on junit-vintage-engine , as shown in the following example: <dependency> <groupId>org.junit.vintage</groupId> <artifactId>junit-vintage-engine</artifactId> <scope>test</scope> <exclusions> <exclusion> <groupId>org.hamcrest</groupId> <artifactId>hamcrest-core</artifactId> </exclusion> </exclusions> </dependency> hamcrest-core is excluded in favor of org.hamcrest:hamcrest that is part of spring-boot-starter-test ."
"https://docs.spring.io/spring-boot/reference/testing/test-scope-dependencies.html","Test Scope Dependencies: The spring-boot-starter-test starter (in the test scope ) contains the following provided libraries: JUnit 5(https://junit.org/junit5/) : The de-facto standard for unit testing Java applications. Spring Test(https://docs.spring.io/spring-framework/reference/6.1/testing/integration.html) & Spring Boot Test: Utilities and integration test support for Spring Boot applications. AssertJ(https://assertj.github.io/doc/) : A fluent assertion library. Hamcrest(https://github.com/hamcrest/JavaHamcrest) : A library of matcher objects (also known as constraints or predicates). Mockito(https://site.mockito.org/) : A Java mocking framework. JSONassert(https://github.com/skyscreamer/JSONassert) : An assertion library for JSON. JsonPath(https://github.com/jayway/JsonPath) : XPath for JSON. Awaitility(https://github.com/awaitility/awaitility) : A library for testing asynchronous systems. We generally find these common libraries to be useful when writing tests. If these libraries do not suit your needs, you can add additional test dependencies of your own."
"https://docs.spring.io/spring-boot/reference/testing/spring-applications.html","Testing Spring Applications: One of the major advantages of dependency injection is that it should make your code easier to unit test. You can instantiate objects by using the new operator without even involving Spring. You can also use mock objects instead of real dependencies. Often, you need to move beyond unit testing and start integration testing (with a Spring ApplicationContext ). It is useful to be able to perform integration testing without requiring deployment of your application or needing to connect to other infrastructure. The Spring Framework includes a dedicated test module for such integration testing. You can declare a dependency directly to org.springframework:spring-test or use the spring-boot-starter-test starter to pull it in transitively. If you have not used the spring-test module before, you should start by reading the relevant section(https://docs.spring.io/spring-framework/reference/6.1/testing.html) of the Spring Framework reference documentation."
"https://docs.spring.io/spring-boot/reference/testing/spring-boot-applications.html","Testing Spring Boot Applications: A Spring Boot application is a Spring ApplicationContext , so nothing very special has to be done to test it beyond what you would normally do with a vanilla Spring context. External properties, logging, and other features of Spring Boot are installed in the context by default only if you use SpringApplication to create it. Spring Boot provides a @SpringBootTest annotation, which can be used as an alternative to the standard spring-test @ContextConfiguration annotation when you need Spring Boot features. The annotation works by creating the ApplicationContext used in your tests through SpringApplication(#testing.spring-boot-applications.detecting-configuration) . In addition to @SpringBootTest a number of other annotations are also provided for testing more specific slices(#testing.spring-boot-applications.autoconfigured-tests) of an application. If you are using JUnit 4, do not forget to also add @RunWith(SpringRunner.class) to your test, otherwise the annotations will be ignored. If you are using JUnit 5, there is no need to add the equivalent @ExtendWith(SpringExtension.class) as @SpringBootTest and the other @…​Test annotations are already annotated with it. By default, @SpringBootTest will not start a server. You can use the webEnvironment attribute of @SpringBootTest to further refine how your tests run: MOCK (Default) : Loads a web ApplicationContext and provides a mock web environment. Embedded servers are not started when using this annotation. If a web environment is not available on your classpath, this mode transparently falls back to creating a regular non-web ApplicationContext . It can be used in conjunction with @AutoConfigureMockMvc or @AutoConfigureWebTestClient(#testing.spring-boot-applications.with-mock-environment) for mock-based testing of your web application. RANDOM_PORT : Loads a WebServerApplicationContext and provides a real web environment. Embedded servers are started and listen on a random port. DEFINED_PORT : Loads a WebServerApplicationContext and provides a real web environment. Embedded servers are started and listen on a defined port (from your application.properties ) or on the default port of 8080 . NONE : Loads an ApplicationContext by using SpringApplication but does not provide any web environment (mock or otherwise). If your test is @Transactional , it rolls back the transaction at the end of each test method by default. However, as using this arrangement with either RANDOM_PORT or DEFINED_PORT implicitly provides a real servlet environment, the HTTP client and server run in separate threads and, thus, in separate transactions. Any transaction initiated on the server does not roll back in this case. @SpringBootTest with webEnvironment = WebEnvironment.RANDOM_PORT will also start the management server on a separate random port if your application uses a different port for the management server. Detecting Web Application Type: If Spring MVC is available, a regular MVC-based application context is configured. If you have only Spring WebFlux, we will detect that and configure a WebFlux-based application context instead. If both are present, Spring MVC takes precedence. If you want to test a reactive web application in this scenario, you must set the spring.main.web-application-type property: Java Kotlin import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest(properties = ""spring.main.web-application-type=reactive"") class MyWebFluxTests { // ... } import org.springframework.boot.test.context.SpringBootTest @SpringBootTest(properties = [""spring.main.web-application-type=reactive""]) class MyWebFluxTests { // ... } Detecting Test Configuration: If you are familiar with the Spring Test Framework, you may be used to using @ContextConfiguration(classes=…​) in order to specify which Spring @Configuration to load. Alternatively, you might have often used nested @Configuration classes within your test. When testing Spring Boot applications, this is often not required. Spring Boot’s @*Test annotations search for your primary configuration automatically whenever you do not explicitly define one. The search algorithm works up from the package that contains the test until it finds a class annotated with @SpringBootApplication or @SpringBootConfiguration . As long as you structured your code(../using/structuring-your-code.html) in a sensible way, your main configuration is usually found. If you use a test annotation to test a more specific slice of your application(#testing.spring-boot-applications.autoconfigured-tests) , you should avoid adding configuration settings that are specific to a particular area on the main method’s application class(#testing.spring-boot-applications.user-configuration-and-slicing) . The underlying component scan configuration of @SpringBootApplication defines exclude filters that are used to make sure slicing works as expected. If you are using an explicit @ComponentScan directive on your @SpringBootApplication -annotated class, be aware that those filters will be disabled. If you are using slicing, you should define them again. If you want to customize the primary configuration, you can use a nested @TestConfiguration class. Unlike a nested @Configuration class, which would be used instead of your application’s primary configuration, a nested @TestConfiguration class is used in addition to your application’s primary configuration. Spring’s test framework caches application contexts between tests. Therefore, as long as your tests share the same configuration (no matter how it is discovered), the potentially time-consuming process of loading the context happens only once. Using the Test Configuration Main Method: Typically the test configuration discovered by @SpringBootTest will be your main @SpringBootApplication . In most well structured applications, this configuration class will also include the main method used to launch the application. For example, the following is a very common code pattern for a typical Spring Boot application: Java Kotlin import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.docs.using.structuringyourcode.locatingthemainclass.MyApplication import org.springframework.boot.runApplication @SpringBootApplication class MyApplication fun main(args: Array<String>) { runApplication<MyApplication>(*args) } In the example above, the main method doesn’t do anything other than delegate to SpringApplication.run . It is, however, possible to have a more complex main method that applies customizations before calling SpringApplication.run . For example, here is an application that changes the banner mode and sets additional profiles: Java Kotlin import org.springframework.boot.Banner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication application = new SpringApplication(MyApplication.class); application.setBannerMode(Banner.Mode.OFF); application.setAdditionalProfiles(""myprofile""); application.run(args); } } import org.springframework.boot.Banner import org.springframework.boot.runApplication import org.springframework.boot.autoconfigure.SpringBootApplication @SpringBootApplication class MyApplication fun main(args: Array<String>) { runApplication<MyApplication>(*args) { setBannerMode(Banner.Mode.OFF) setAdditionalProfiles(""myprofile"") } } Since customizations in the main method can affect the resulting ApplicationContext , it’s possible that you might also want to use the main method to create the ApplicationContext used in your tests. By default, @SpringBootTest will not call your main method, and instead the class itself is used directly to create the ApplicationContext If you want to change this behavior, you can change the useMainMethod attribute of @SpringBootTest to UseMainMethod.ALWAYS or UseMainMethod.WHEN_AVAILABLE . When set to ALWAYS , the test will fail if no main method can be found. When set to WHEN_AVAILABLE the main method will be used if it is available, otherwise the standard loading mechanism will be used. For example, the following test will invoke the main method of MyApplication in order to create the ApplicationContext . If the main method sets additional profiles then those will be active when the ApplicationContext starts. Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.context.SpringBootTest.UseMainMethod; @SpringBootTest(useMainMethod = UseMainMethod.ALWAYS) class MyApplicationTests { @Test void exampleTest() { // ... } } import org.junit.jupiter.api.Test import org.springframework.boot.test.context.SpringBootTest import org.springframework.boot.test.context.SpringBootTest.UseMainMethod @SpringBootTest(useMainMethod = UseMainMethod.ALWAYS) class MyApplicationTests { @Test fun exampleTest() { // ... } } Excluding Test Configuration: If your application uses component scanning (for example, if you use @SpringBootApplication or @ComponentScan ), you may find top-level configuration classes that you created only for specific tests accidentally get picked up everywhere. As we have seen earlier(#testing.spring-boot-applications.detecting-configuration) , @TestConfiguration can be used on an inner class of a test to customize the primary configuration. @TestConfiguration can also be used on a top-level class. Doing so indicates that the class should not be picked up by scanning. You can then import the class explicitly where it is required, as shown in the following example: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.context.annotation.Import; @SpringBootTest @Import(MyTestsConfiguration.class) class MyTests { @Test void exampleTest() { // ... } } import org.junit.jupiter.api.Test import org.springframework.boot.test.context.SpringBootTest import org.springframework.context.annotation.Import @SpringBootTest @Import(MyTestsConfiguration::class) class MyTests { @Test fun exampleTest() { // ... } } If you directly use @ComponentScan (that is, not through @SpringBootApplication ) you need to register the TypeExcludeFilter with it. See the TypeExcludeFilter(../../api/java/org/springframework/boot/context/TypeExcludeFilter.html) API documentation for details. An imported @TestConfiguration is processed earlier than an inner-class @TestConfiguration and an imported @TestConfiguration will be processed before any configuration found through component scanning. Generally speaking, this difference in ordering has no noticeable effect but it is something to be aware of if you’re relying on bean overriding. Using Application Arguments: If your application expects arguments(../features/spring-application.html#features.spring-application.application-arguments) , you can have @SpringBootTest inject them using the args attribute. Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.test.context.SpringBootTest; import static org.assertj.core.api.Assertions.assertThat; @SpringBootTest(args = ""--app.test=one"") class MyApplicationArgumentTests { @Test void applicationArgumentsPopulated(@Autowired ApplicationArguments args) { assertThat(args.getOptionNames()).containsOnly(""app.test""); assertThat(args.getOptionValues(""app.test"")).containsOnly(""one""); } } import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.ApplicationArguments import org.springframework.boot.test.context.SpringBootTest @SpringBootTest(args = [""--app.test=one""]) class MyApplicationArgumentTests { @Test fun applicationArgumentsPopulated(@Autowired args: ApplicationArguments) { assertThat(args.optionNames).containsOnly(""app.test"") assertThat(args.getOptionValues(""app.test"")).containsOnly(""one"") } } Testing With a Mock Environment: By default, @SpringBootTest does not start the server but instead sets up a mock environment for testing web endpoints. With Spring MVC, we can query our web endpoints using MockMvc(https://docs.spring.io/spring-framework/reference/6.1/testing/spring-mvc-test-framework.html) or WebTestClient , as shown in the following example: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.web.reactive.server.WebTestClient; import org.springframework.test.web.servlet.MockMvc; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; @SpringBootTest @AutoConfigureMockMvc class MyMockMvcTests { @Test void testWithMockMvc(@Autowired MockMvc mvc) throws Exception { mvc.perform(get(""/"")).andExpect(status().isOk()).andExpect(content().string(""Hello World"")); } // If Spring WebFlux is on the classpath, you can drive MVC tests with a WebTestClient @Test void testWithWebTestClient(@Autowired WebTestClient webClient) { webClient .get().uri(""/"") .exchange() .expectStatus().isOk() .expectBody(String.class).isEqualTo(""Hello World""); } } import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc import org.springframework.boot.test.context.SpringBootTest import org.springframework.test.web.reactive.server.WebTestClient import org.springframework.test.web.reactive.server.expectBody import org.springframework.test.web.servlet.MockMvc import org.springframework.test.web.servlet.request.MockMvcRequestBuilders import org.springframework.test.web.servlet.result.MockMvcResultMatchers @SpringBootTest @AutoConfigureMockMvc class MyMockMvcTests { @Test fun testWithMockMvc(@Autowired mvc: MockMvc) { mvc.perform(MockMvcRequestBuilders.get(""/"")).andExpect(MockMvcResultMatchers.status().isOk) .andExpect(MockMvcResultMatchers.content().string(""Hello World"")) } // If Spring WebFlux is on the classpath, you can drive MVC tests with a WebTestClient @Test fun testWithWebTestClient(@Autowired webClient: WebTestClient) { webClient .get().uri(""/"") .exchange() .expectStatus().isOk .expectBody<String>().isEqualTo(""Hello World"") } } If you want to focus only on the web layer and not start a complete ApplicationContext , consider using @WebMvcTest instead(#testing.spring-boot-applications.spring-mvc-tests) . With Spring WebFlux endpoints, you can use WebTestClient(https://docs.spring.io/spring-framework/reference/6.1/testing/webtestclient.html) as shown in the following example: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.web.reactive.server.WebTestClient; @SpringBootTest @AutoConfigureWebTestClient class MyMockWebTestClientTests { @Test void exampleTest(@Autowired WebTestClient webClient) { webClient .get().uri(""/"") .exchange() .expectStatus().isOk() .expectBody(String.class).isEqualTo(""Hello World""); } } import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient import org.springframework.boot.test.context.SpringBootTest import org.springframework.test.web.reactive.server.WebTestClient import org.springframework.test.web.reactive.server.expectBody @SpringBootTest @AutoConfigureWebTestClient class MyMockWebTestClientTests { @Test fun exampleTest(@Autowired webClient: WebTestClient) { webClient .get().uri(""/"") .exchange() .expectStatus().isOk .expectBody<String>().isEqualTo(""Hello World"") } } Testing within a mocked environment is usually faster than running with a full servlet container. However, since mocking occurs at the Spring MVC layer, code that relies on lower-level servlet container behavior cannot be directly tested with MockMvc. For example, Spring Boot’s error handling is based on the “error page” support provided by the servlet container. This means that, whilst you can test your MVC layer throws and handles exceptions as expected, you cannot directly test that a specific custom error page(../web/servlet.html#web.servlet.spring-mvc.error-handling.error-pages) is rendered. If you need to test these lower-level concerns, you can start a fully running server as described in the next section. Testing With a Running Server: If you need to start a full running server, we recommend that you use random ports. If you use @SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT) , an available port is picked at random each time your test runs. The @LocalServerPort annotation can be used to inject the actual port used(../../how-to/webserver.html#howto.webserver.discover-port) into your test. For convenience, tests that need to make REST calls to the started server can additionally @Autowire a WebTestClient(https://docs.spring.io/spring-framework/reference/6.1/testing/webtestclient.html) , which resolves relative links to the running server and comes with a dedicated API for verifying responses, as shown in the following example: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.context.SpringBootTest.WebEnvironment; import org.springframework.test.web.reactive.server.WebTestClient; @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) class MyRandomPortWebTestClientTests { @Test void exampleTest(@Autowired WebTestClient webClient) { webClient .get().uri(""/"") .exchange() .expectStatus().isOk() .expectBody(String.class).isEqualTo(""Hello World""); } } import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.context.SpringBootTest import org.springframework.boot.test.context.SpringBootTest.WebEnvironment import org.springframework.test.web.reactive.server.WebTestClient import org.springframework.test.web.reactive.server.expectBody @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) class MyRandomPortWebTestClientTests { @Test fun exampleTest(@Autowired webClient: WebTestClient) { webClient .get().uri(""/"") .exchange() .expectStatus().isOk .expectBody<String>().isEqualTo(""Hello World"") } } WebTestClient can also used with a mock environment(#testing.spring-boot-applications.with-mock-environment) , removing the need for a running server, by annotating your test class with @AutoConfigureWebTestClient . This setup requires spring-webflux on the classpath. If you can not or will not add webflux, Spring Boot also provides a TestRestTemplate facility: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.context.SpringBootTest.WebEnvironment; import org.springframework.boot.test.web.client.TestRestTemplate; import static org.assertj.core.api.Assertions.assertThat; @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) class MyRandomPortTestRestTemplateTests { @Test void exampleTest(@Autowired TestRestTemplate restTemplate) { String body = restTemplate.getForObject(""/"", String.class); assertThat(body).isEqualTo(""Hello World""); } } import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.context.SpringBootTest import org.springframework.boot.test.context.SpringBootTest.WebEnvironment import org.springframework.boot.test.web.client.TestRestTemplate @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) class MyRandomPortTestRestTemplateTests { @Test fun exampleTest(@Autowired restTemplate: TestRestTemplate) { val body = restTemplate.getForObject(""/"", String::class.java) assertThat(body).isEqualTo(""Hello World"") } } Customizing WebTestClient: To customize the WebTestClient bean, configure a WebTestClientBuilderCustomizer bean. Any such beans are called with the WebTestClient.Builder that is used to create the WebTestClient . Using JMX: As the test context framework caches context, JMX is disabled by default to prevent identical components to register on the same domain. If such test needs access to an MBeanServer , consider marking it dirty as well: Java Kotlin import javax.management.MBeanServer; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.annotation.DirtiesContext; import static org.assertj.core.api.Assertions.assertThat; @SpringBootTest(properties = ""spring.jmx.enabled=true"") @DirtiesContext class MyJmxTests { @Autowired private MBeanServer mBeanServer; @Test void exampleTest() { assertThat(this.mBeanServer.getDomains()).contains(""java.lang""); // ... } } import javax.management.MBeanServer import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.context.SpringBootTest import org.springframework.test.annotation.DirtiesContext @SpringBootTest(properties = [""spring.jmx.enabled=true""]) @DirtiesContext class MyJmxTests(@Autowired val mBeanServer: MBeanServer) { @Test fun exampleTest() { assertThat(mBeanServer.domains).contains(""java.lang"") // ... } } Using Observations: If you annotate a sliced test(#testing.spring-boot-applications.autoconfigured-tests) with @AutoConfigureObservability , it auto-configures an ObservationRegistry . Using Metrics: Regardless of your classpath, meter registries, except the in-memory backed, are not auto-configured when using @SpringBootTest . If you need to export metrics to a different backend as part of an integration test, annotate it with @AutoConfigureObservability . If you annotate a sliced test(#testing.spring-boot-applications.autoconfigured-tests) with @AutoConfigureObservability , it auto-configures an in-memory MeterRegistry . Data exporting in sliced tests is not supported with the @AutoConfigureObservability annotation. Using Tracing: Regardless of your classpath, tracing components which are reporting data are not auto-configured when using @SpringBootTest . If you need those components as part of an integration test, annotate the test with @AutoConfigureObservability . If you have created your own reporting components (e.g. a custom SpanExporter or SpanHandler ) and you don’t want them to be active in tests, you can use the @ConditionalOnEnabledTracing annotation to disable them. If you annotate a sliced test(#testing.spring-boot-applications.autoconfigured-tests) with @AutoConfigureObservability , it auto-configures a no-op Tracer . Data exporting in sliced tests is not supported with the @AutoConfigureObservability annotation. Mocking and Spying Beans: When running tests, it is sometimes necessary to mock certain components within your application context. For example, you may have a facade over some remote service that is unavailable during development. Mocking can also be useful when you want to simulate failures that might be hard to trigger in a real environment. Spring Boot includes a @MockBean annotation that can be used to define a Mockito mock for a bean inside your ApplicationContext . You can use the annotation to add new beans or replace a single existing bean definition. The annotation can be used directly on test classes, on fields within your test, or on @Configuration classes and fields. When used on a field, the instance of the created mock is also injected. Mock beans are automatically reset after each test method. If your test uses one of Spring Boot’s test annotations (such as @SpringBootTest ), this feature is automatically enabled. To use this feature with a different arrangement, listeners must be explicitly added, as shown in the following example: Java Kotlin import org.springframework.boot.test.mock.mockito.MockitoTestExecutionListener; import org.springframework.boot.test.mock.mockito.ResetMocksTestExecutionListener; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.TestExecutionListeners; @ContextConfiguration(classes = MyConfig.class) @TestExecutionListeners({ MockitoTestExecutionListener.class, ResetMocksTestExecutionListener.class }) class MyTests { // ... } import org.springframework.boot.test.mock.mockito.MockitoTestExecutionListener import org.springframework.boot.test.mock.mockito.ResetMocksTestExecutionListener import org.springframework.test.context.ContextConfiguration import org.springframework.test.context.TestExecutionListeners @ContextConfiguration(classes = [MyConfig::class]) @TestExecutionListeners( MockitoTestExecutionListener::class, ResetMocksTestExecutionListener::class ) class MyTests { // ... } The following example replaces an existing RemoteService bean with a mock implementation: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.mock.mockito.MockBean; import static org.assertj.core.api.Assertions.assertThat; import static org.mockito.BDDMockito.given; @SpringBootTest class MyTests { @Autowired private Reverser reverser; @MockBean private RemoteService remoteService; @Test void exampleTest() { given(this.remoteService.getValue()).willReturn(""spring""); String reverse = this.reverser.getReverseValue(); // Calls injected RemoteService assertThat(reverse).isEqualTo(""gnirps""); } } import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.mockito.BDDMockito.given import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.context.SpringBootTest import org.springframework.boot.test.mock.mockito.MockBean @SpringBootTest class MyTests(@Autowired val reverser: Reverser, @MockBean val remoteService: RemoteService) { @Test fun exampleTest() { given(remoteService.value).willReturn(""spring"") val reverse = reverser.reverseValue // Calls injected RemoteService assertThat(reverse).isEqualTo(""gnirps"") } } @MockBean cannot be used to mock the behavior of a bean that is exercised during application context refresh. By the time the test is executed, the application context refresh has completed and it is too late to configure the mocked behavior. We recommend using a @Bean method to create and configure the mock in this situation. Additionally, you can use @SpyBean to wrap any existing bean with a Mockito spy . See the SpyBean(../../api/java/org/springframework/boot/test/mock/mockito/SpyBean.html) API documentation for full details. While Spring’s test framework caches application contexts between tests and reuses a context for tests sharing the same configuration, the use of @MockBean or @SpyBean influences the cache key, which will most likely increase the number of contexts. If you are using @SpyBean to spy on a bean with @Cacheable methods that refer to parameters by name, your application must be compiled with -parameters . This ensures that the parameter names are available to the caching infrastructure once the bean has been spied upon. When you are using @SpyBean to spy on a bean that is proxied by Spring, you may need to remove Spring’s proxy in some situations, for example when setting expectations using given or when . Use AopTestUtils.getTargetObject(yourProxiedSpy) to do so. Auto-configured Tests: Spring Boot’s auto-configuration system works well for applications but can sometimes be a little too much for tests. It often helps to load only the parts of the configuration that are required to test a “slice” of your application. For example, you might want to test that Spring MVC controllers are mapping URLs correctly, and you do not want to involve database calls in those tests, or you might want to test JPA entities, and you are not interested in the web layer when those tests run. The spring-boot-test-autoconfigure module includes a number of annotations that can be used to automatically configure such “slices”. Each of them works in a similar way, providing a @…​Test annotation that loads the ApplicationContext and one or more @AutoConfigure…​ annotations that can be used to customize auto-configuration settings. Each slice restricts component scan to appropriate components and loads a very restricted set of auto-configuration classes. If you need to exclude one of them, most @…​Test annotations provide an excludeAutoConfiguration attribute. Alternatively, you can use @ImportAutoConfiguration#exclude . Including multiple “slices” by using several @…​Test annotations in one test is not supported. If you need multiple “slices”, pick one of the @…​Test annotations and include the @AutoConfigure…​ annotations of the other “slices” by hand. It is also possible to use the @AutoConfigure…​ annotations with the standard @SpringBootTest annotation. You can use this combination if you are not interested in “slicing” your application but you want some of the auto-configured test beans. Auto-configured JSON Tests: To test that object JSON serialization and deserialization is working as expected, you can use the @JsonTest annotation. @JsonTest auto-configures the available supported JSON mapper, which can be one of the following libraries: Jackson ObjectMapper , any @JsonComponent beans and any Jackson Module s Gson Jsonb A list of the auto-configurations that are enabled by @JsonTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . If you need to configure elements of the auto-configuration, you can use the @AutoConfigureJsonTesters annotation. Spring Boot includes AssertJ-based helpers that work with the JSONAssert and JsonPath libraries to check that JSON appears as expected. The JacksonTester , GsonTester , JsonbTester , and BasicJsonTester classes can be used for Jackson, Gson, Jsonb, and Strings respectively. Any helper fields on the test class can be @Autowired when using @JsonTest . The following example shows a test class for Jackson: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.json.JsonTest; import org.springframework.boot.test.json.JacksonTester; import static org.assertj.core.api.Assertions.assertThat; @JsonTest class MyJsonTests { @Autowired private JacksonTester<VehicleDetails> json; @Test void serialize() throws Exception { VehicleDetails details = new VehicleDetails(""Honda"", ""Civic""); // Assert against a `.json` file in the same package as the test assertThat(this.json.write(details)).isEqualToJson(""expected.json""); // Or use JSON path based assertions assertThat(this.json.write(details)).hasJsonPathStringValue(""@.make""); assertThat(this.json.write(details)).extractingJsonPathStringValue(""@.make"").isEqualTo(""Honda""); } @Test void deserialize() throws Exception { String content = ""{\""make\"":\""Ford\"",\""model\"":\""Focus\""}""; assertThat(this.json.parse(content)).isEqualTo(new VehicleDetails(""Ford"", ""Focus"")); assertThat(this.json.parseObject(content).getMake()).isEqualTo(""Ford""); } } import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.json.JsonTest import org.springframework.boot.test.json.JacksonTester @JsonTest class MyJsonTests(@Autowired val json: JacksonTester<VehicleDetails>) { @Test fun serialize() { val details = VehicleDetails(""Honda"", ""Civic"") // Assert against a `.json` file in the same package as the test assertThat(json.write(details)).isEqualToJson(""expected.json"") // Or use JSON path based assertions assertThat(json.write(details)).hasJsonPathStringValue(""@.make"") assertThat(json.write(details)).extractingJsonPathStringValue(""@.make"").isEqualTo(""Honda"") } @Test fun deserialize() { val content = ""{\""make\"":\""Ford\"",\""model\"":\""Focus\""}"" assertThat(json.parse(content)).isEqualTo(VehicleDetails(""Ford"", ""Focus"")) assertThat(json.parseObject(content).make).isEqualTo(""Ford"") } } JSON helper classes can also be used directly in standard unit tests. To do so, call the initFields method of the helper in your @Before method if you do not use @JsonTest . If you use Spring Boot’s AssertJ-based helpers to assert on a number value at a given JSON path, you might not be able to use isEqualTo depending on the type. Instead, you can use AssertJ’s satisfies to assert that the value matches the given condition. For instance, the following example asserts that the actual number is a float value close to 0.15 within an offset of 0.01 . Java Kotlin @Test void someTest() throws Exception { SomeObject value = new SomeObject(0.152f); assertThat(this.json.write(value)).extractingJsonPathNumberValue(""@.test.numberValue"") .satisfies((number) -> assertThat(number.floatValue()).isCloseTo(0.15f, within(0.01f))); } @Test fun someTest() { val value = SomeObject(0.152f) assertThat(json.write(value)).extractingJsonPathNumberValue(""@.test.numberValue"") .satisfies(ThrowingConsumer { number -> assertThat(number.toFloat()).isCloseTo(0.15f, within(0.01f)) }) } Auto-configured Spring MVC Tests: To test whether Spring MVC controllers are working as expected, use the @WebMvcTest annotation. @WebMvcTest auto-configures the Spring MVC infrastructure and limits scanned beans to @Controller , @ControllerAdvice , @JsonComponent , Converter , GenericConverter , Filter , HandlerInterceptor , WebMvcConfigurer , WebMvcRegistrations , and HandlerMethodArgumentResolver . Regular @Component and @ConfigurationProperties beans are not scanned when the @WebMvcTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. A list of the auto-configuration settings that are enabled by @WebMvcTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . If you need to register extra components, such as the Jackson Module , you can import additional configuration classes by using @Import on your test. Often, @WebMvcTest is limited to a single controller and is used in combination with @MockBean to provide mock implementations for required collaborators. @WebMvcTest also auto-configures MockMvc . Mock MVC offers a powerful way to quickly test MVC controllers without needing to start a full HTTP server. You can also auto-configure MockMvc in a non- @WebMvcTest (such as @SpringBootTest ) by annotating it with @AutoConfigureMockMvc . The following example uses MockMvc : Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.http.MediaType; import org.springframework.test.web.servlet.MockMvc; import static org.mockito.BDDMockito.given; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; @WebMvcTest(UserVehicleController.class) class MyControllerTests { @Autowired private MockMvc mvc; @MockBean private UserVehicleService userVehicleService; @Test void testExample() throws Exception { given(this.userVehicleService.getVehicleDetails(""sboot"")) .willReturn(new VehicleDetails(""Honda"", ""Civic"")); this.mvc.perform(get(""/sboot/vehicle"").accept(MediaType.TEXT_PLAIN)) .andExpect(status().isOk()) .andExpect(content().string(""Honda Civic"")); } } import org.junit.jupiter.api.Test import org.mockito.BDDMockito.given import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest import org.springframework.boot.test.mock.mockito.MockBean import org.springframework.http.MediaType import org.springframework.test.web.servlet.MockMvc import org.springframework.test.web.servlet.request.MockMvcRequestBuilders import org.springframework.test.web.servlet.result.MockMvcResultMatchers @WebMvcTest(UserVehicleController::class) class MyControllerTests(@Autowired val mvc: MockMvc) { @MockBean lateinit var userVehicleService: UserVehicleService @Test fun testExample() { given(userVehicleService.getVehicleDetails(""sboot"")) .willReturn(VehicleDetails(""Honda"", ""Civic"")) mvc.perform(MockMvcRequestBuilders.get(""/sboot/vehicle"").accept(MediaType.TEXT_PLAIN)) .andExpect(MockMvcResultMatchers.status().isOk) .andExpect(MockMvcResultMatchers.content().string(""Honda Civic"")) } } If you need to configure elements of the auto-configuration (for example, when servlet filters should be applied) you can use attributes in the @AutoConfigureMockMvc annotation. If you use HtmlUnit and Selenium, auto-configuration also provides an HtmlUnit WebClient bean and/or a Selenium WebDriver bean. The following example uses HtmlUnit: Java Kotlin import com.gargoylesoftware.htmlunit.WebClient; import com.gargoylesoftware.htmlunit.html.HtmlPage; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.boot.test.mock.mockito.MockBean; import static org.assertj.core.api.Assertions.assertThat; import static org.mockito.BDDMockito.given; @WebMvcTest(UserVehicleController.class) class MyHtmlUnitTests { @Autowired private WebClient webClient; @MockBean private UserVehicleService userVehicleService; @Test void testExample() throws Exception { given(this.userVehicleService.getVehicleDetails(""sboot"")).willReturn(new VehicleDetails(""Honda"", ""Civic"")); HtmlPage page = this.webClient.getPage(""/sboot/vehicle.html""); assertThat(page.getBody().getTextContent()).isEqualTo(""Honda Civic""); } } import com.gargoylesoftware.htmlunit.WebClient import com.gargoylesoftware.htmlunit.html.HtmlPage import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.mockito.BDDMockito.given import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest import org.springframework.boot.test.mock.mockito.MockBean @WebMvcTest(UserVehicleController::class) class MyHtmlUnitTests(@Autowired val webClient: WebClient) { @MockBean lateinit var userVehicleService: UserVehicleService @Test fun testExample() { given(userVehicleService.getVehicleDetails(""sboot"")).willReturn(VehicleDetails(""Honda"", ""Civic"")) val page = webClient.getPage<HtmlPage>(""/sboot/vehicle.html"") assertThat(page.body.textContent).isEqualTo(""Honda Civic"") } } By default, Spring Boot puts WebDriver beans in a special “scope” to ensure that the driver exits after each test and that a new instance is injected. If you do not want this behavior, you can add @Scope(""singleton"") to your WebDriver @Bean definition. The webDriver scope created by Spring Boot will replace any user defined scope of the same name. If you define your own webDriver scope you may find it stops working when you use @WebMvcTest . If you have Spring Security on the classpath, @WebMvcTest will also scan WebSecurityConfigurer beans. Instead of disabling security completely for such tests, you can use Spring Security’s test support. More details on how to use Spring Security’s MockMvc support can be found in this Testing With Spring Security(../../how-to/testing.html#howto.testing.with-spring-security) “How-to Guides” section. Sometimes writing Spring MVC tests is not enough; Spring Boot can help you run full end-to-end tests with an actual server(#testing.spring-boot-applications.with-running-server) . Auto-configured Spring WebFlux Tests: To test that Spring WebFlux(https://docs.spring.io/spring-framework/reference/6.1/web-reactive.html) controllers are working as expected, you can use the @WebFluxTest annotation. @WebFluxTest auto-configures the Spring WebFlux infrastructure and limits scanned beans to @Controller , @ControllerAdvice , @JsonComponent , Converter , GenericConverter , WebFilter , and WebFluxConfigurer . Regular @Component and @ConfigurationProperties beans are not scanned when the @WebFluxTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. A list of the auto-configurations that are enabled by @WebFluxTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . If you need to register extra components, such as Jackson Module , you can import additional configuration classes using @Import on your test. Often, @WebFluxTest is limited to a single controller and used in combination with the @MockBean annotation to provide mock implementations for required collaborators. @WebFluxTest also auto-configures WebTestClient(https://docs.spring.io/spring-framework/reference/6.1/testing/webtestclient.html) , which offers a powerful way to quickly test WebFlux controllers without needing to start a full HTTP server. You can also auto-configure WebTestClient in a non- @WebFluxTest (such as @SpringBootTest ) by annotating it with @AutoConfigureWebTestClient . The following example shows a class that uses both @WebFluxTest and a WebTestClient : Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.http.MediaType; import org.springframework.test.web.reactive.server.WebTestClient; import static org.mockito.BDDMockito.given; @WebFluxTest(UserVehicleController.class) class MyControllerTests { @Autowired private WebTestClient webClient; @MockBean private UserVehicleService userVehicleService; @Test void testExample() { given(this.userVehicleService.getVehicleDetails(""sboot"")) .willReturn(new VehicleDetails(""Honda"", ""Civic"")); this.webClient.get().uri(""/sboot/vehicle"").accept(MediaType.TEXT_PLAIN).exchange() .expectStatus().isOk() .expectBody(String.class).isEqualTo(""Honda Civic""); } } import org.junit.jupiter.api.Test import org.mockito.BDDMockito.given import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest import org.springframework.boot.test.mock.mockito.MockBean import org.springframework.http.MediaType import org.springframework.test.web.reactive.server.WebTestClient import org.springframework.test.web.reactive.server.expectBody @WebFluxTest(UserVehicleController::class) class MyControllerTests(@Autowired val webClient: WebTestClient) { @MockBean lateinit var userVehicleService: UserVehicleService @Test fun testExample() { given(userVehicleService.getVehicleDetails(""sboot"")) .willReturn(VehicleDetails(""Honda"", ""Civic"")) webClient.get().uri(""/sboot/vehicle"").accept(MediaType.TEXT_PLAIN).exchange() .expectStatus().isOk .expectBody<String>().isEqualTo(""Honda Civic"") } } This setup is only supported by WebFlux applications as using WebTestClient in a mocked web application only works with WebFlux at the moment. @WebFluxTest cannot detect routes registered through the functional web framework. For testing RouterFunction beans in the context, consider importing your RouterFunction yourself by using @Import or by using @SpringBootTest . @WebFluxTest cannot detect custom security configuration registered as a @Bean of type SecurityWebFilterChain . To include that in your test, you will need to import the configuration that registers the bean by using @Import or by using @SpringBootTest . Sometimes writing Spring WebFlux tests is not enough; Spring Boot can help you run full end-to-end tests with an actual server(#testing.spring-boot-applications.with-running-server) . Auto-configured Spring GraphQL Tests: Spring GraphQL offers a dedicated testing support module; you’ll need to add it to your project: Maven <dependencies> <dependency> <groupId>org.springframework.graphql</groupId> <artifactId>spring-graphql-test</artifactId> <scope>test</scope> </dependency> <!-- Unless already present in the compile scope --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-webflux</artifactId> <scope>test</scope> </dependency> </dependencies> Gradle dependencies { testImplementation(""org.springframework.graphql:spring-graphql-test"") // Unless already present in the implementation configuration testImplementation(""org.springframework.boot:spring-boot-starter-webflux"") } This testing module ships the GraphQlTester(https://docs.spring.io/spring-graphql/reference/1.3/testing.html#testing.graphqltester) . The tester is heavily used in test, so be sure to become familiar with using it. There are GraphQlTester variants and Spring Boot will auto-configure them depending on the type of tests: the ExecutionGraphQlServiceTester performs tests on the server side, without a client nor a transport the HttpGraphQlTester performs tests with a client that connects to a server, with or without a live server Spring Boot helps you to test your Spring GraphQL Controllers(https://docs.spring.io/spring-graphql/reference/1.3/controllers.html) with the @GraphQlTest annotation. @GraphQlTest auto-configures the Spring GraphQL infrastructure, without any transport nor server being involved. This limits scanned beans to @Controller , RuntimeWiringConfigurer , JsonComponent , Converter , GenericConverter , DataFetcherExceptionResolver , Instrumentation and GraphQlSourceBuilderCustomizer . Regular @Component and @ConfigurationProperties beans are not scanned when the @GraphQlTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. A list of the auto-configurations that are enabled by @GraphQlTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . Often, @GraphQlTest is limited to a set of controllers and used in combination with the @MockBean annotation to provide mock implementations for required collaborators. Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.docs.web.graphql.runtimewiring.GreetingController; import org.springframework.boot.test.autoconfigure.graphql.GraphQlTest; import org.springframework.graphql.test.tester.GraphQlTester; @GraphQlTest(GreetingController.class) class GreetingControllerTests { @Autowired private GraphQlTester graphQlTester; @Test void shouldGreetWithSpecificName() { this.graphQlTester.document(""{ greeting(name: \""Alice\"") } "") .execute() .path(""greeting"") .entity(String.class) .isEqualTo(""Hello, Alice!""); } @Test void shouldGreetWithDefaultName() { this.graphQlTester.document(""{ greeting } "") .execute() .path(""greeting"") .entity(String.class) .isEqualTo(""Hello, Spring!""); } } import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.docs.web.graphql.runtimewiring.GreetingController import org.springframework.boot.test.autoconfigure.graphql.GraphQlTest import org.springframework.graphql.test.tester.GraphQlTester @GraphQlTest(GreetingController::class) internal class GreetingControllerTests { @Autowired lateinit var graphQlTester: GraphQlTester @Test fun shouldGreetWithSpecificName() { graphQlTester.document(""{ greeting(name: \""Alice\"") } "").execute().path(""greeting"").entity(String::class.java) .isEqualTo(""Hello, Alice!"") } @Test fun shouldGreetWithDefaultName() { graphQlTester.document(""{ greeting } "").execute().path(""greeting"").entity(String::class.java) .isEqualTo(""Hello, Spring!"") } } @SpringBootTest tests are full integration tests and involve the entire application. When using a random or defined port, a live server is configured and an HttpGraphQlTester bean is contributed automatically so you can use it to test your server. When a MOCK environment is configured, you can also request an HttpGraphQlTester bean by annotating your test class with @AutoConfigureHttpGraphQlTester : Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.graphql.tester.AutoConfigureHttpGraphQlTester; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.graphql.test.tester.HttpGraphQlTester; @AutoConfigureHttpGraphQlTester @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK) class GraphQlIntegrationTests { @Test void shouldGreetWithSpecificName(@Autowired HttpGraphQlTester graphQlTester) { HttpGraphQlTester authenticatedTester = graphQlTester.mutate() .webTestClient((client) -> client.defaultHeaders((headers) -> headers.setBasicAuth(""admin"", ""ilovespring""))) .build(); authenticatedTester.document(""{ greeting(name: \""Alice\"") } "") .execute() .path(""greeting"") .entity(String.class) .isEqualTo(""Hello, Alice!""); } } import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.graphql.tester.AutoConfigureHttpGraphQlTester import org.springframework.boot.test.context.SpringBootTest import org.springframework.graphql.test.tester.HttpGraphQlTester import org.springframework.http.HttpHeaders import org.springframework.test.web.reactive.server.WebTestClient @AutoConfigureHttpGraphQlTester @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK) class GraphQlIntegrationTests { @Test fun shouldGreetWithSpecificName(@Autowired graphQlTester: HttpGraphQlTester) { val authenticatedTester = graphQlTester.mutate() .webTestClient { client: WebTestClient.Builder -> client.defaultHeaders { headers: HttpHeaders -> headers.setBasicAuth(""admin"", ""ilovespring"") } }.build() authenticatedTester.document(""{ greeting(name: \""Alice\"") } "").execute() .path(""greeting"").entity(String::class.java).isEqualTo(""Hello, Alice!"") } } Auto-configured Data Cassandra Tests: You can use @DataCassandraTest to test Cassandra applications. By default, it configures a CassandraTemplate , scans for @Table classes, and configures Spring Data Cassandra repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataCassandraTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using Cassandra with Spring Boot, see Cassandra(../data/nosql.html#data.nosql.cassandra) .) A list of the auto-configuration settings that are enabled by @DataCassandraTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . The following example shows a typical setup for using Cassandra tests in Spring Boot: Java Kotlin import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.data.cassandra.DataCassandraTest; @DataCassandraTest class MyDataCassandraTests { @Autowired private SomeRepository repository; } import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.data.cassandra.DataCassandraTest @DataCassandraTest class MyDataCassandraTests(@Autowired val repository: SomeRepository) Auto-configured Data Couchbase Tests: You can use @DataCouchbaseTest to test Couchbase applications. By default, it configures a CouchbaseTemplate or ReactiveCouchbaseTemplate , scans for @Document classes, and configures Spring Data Couchbase repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataCouchbaseTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using Couchbase with Spring Boot, see Couchbase(../data/nosql.html#data.nosql.couchbase) , earlier in this chapter.) A list of the auto-configuration settings that are enabled by @DataCouchbaseTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . The following example shows a typical setup for using Couchbase tests in Spring Boot: Java Kotlin import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.data.couchbase.DataCouchbaseTest; @DataCouchbaseTest class MyDataCouchbaseTests { @Autowired private SomeRepository repository; // ... } import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.data.couchbase.DataCouchbaseTest @DataCouchbaseTest class MyDataCouchbaseTests(@Autowired val repository: SomeRepository) { // ... } Auto-configured Data Elasticsearch Tests: You can use @DataElasticsearchTest to test Elasticsearch applications. By default, it configures an ElasticsearchRestTemplate , scans for @Document classes, and configures Spring Data Elasticsearch repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataElasticsearchTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using Elasticsearch with Spring Boot, see Elasticsearch(../data/nosql.html#data.nosql.elasticsearch) , earlier in this chapter.) A list of the auto-configuration settings that are enabled by @DataElasticsearchTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . The following example shows a typical setup for using Elasticsearch tests in Spring Boot: Java Kotlin import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.data.elasticsearch.DataElasticsearchTest; @DataElasticsearchTest class MyDataElasticsearchTests { @Autowired private SomeRepository repository; // ... } import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.data.elasticsearch.DataElasticsearchTest @DataElasticsearchTest class MyDataElasticsearchTests(@Autowired val repository: SomeRepository) { // ... } Auto-configured Data JPA Tests: You can use the @DataJpaTest annotation to test JPA applications. By default, it scans for @Entity classes and configures Spring Data JPA repositories. If an embedded database is available on the classpath, it configures one as well. SQL queries are logged by default by setting the spring.jpa.show-sql property to true . This can be disabled using the showSql attribute of the annotation. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataJpaTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. A list of the auto-configuration settings that are enabled by @DataJpaTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . By default, data JPA tests are transactional and roll back at the end of each test. See the relevant section(https://docs.spring.io/spring-framework/reference/6.1/testing/testcontext-framework/tx.html#testcontext-tx-enabling-transactions) in the Spring Framework Reference Documentation for more details. If that is not what you want, you can disable transaction management for a test or for the whole class as follows: Java Kotlin import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional; @DataJpaTest @Transactional(propagation = Propagation.NOT_SUPPORTED) class MyNonTransactionalTests { // ... } import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest import org.springframework.transaction.annotation.Propagation import org.springframework.transaction.annotation.Transactional @DataJpaTest @Transactional(propagation = Propagation.NOT_SUPPORTED) class MyNonTransactionalTests { // ... } Data JPA tests may also inject a TestEntityManager(../../api/java/org/springframework/boot/test/autoconfigure/orm/jpa/TestEntityManager.html) bean, which provides an alternative to the standard JPA EntityManager that is specifically designed for tests. TestEntityManager can also be auto-configured to any of your Spring-based test class by adding @AutoConfigureTestEntityManager . When doing so, make sure that your test is running in a transaction, for instance by adding @Transactional on your test class or method. A JdbcTemplate is also available if you need that. The following example shows the @DataJpaTest annotation in use: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest; import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager; import static org.assertj.core.api.Assertions.assertThat; @DataJpaTest class MyRepositoryTests { @Autowired private TestEntityManager entityManager; @Autowired private UserRepository repository; @Test void testExample() { this.entityManager.persist(new User(""sboot"", ""1234"")); User user = this.repository.findByUsername(""sboot""); assertThat(user.getUsername()).isEqualTo(""sboot""); assertThat(user.getEmployeeNumber()).isEqualTo(""1234""); } } import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager @DataJpaTest class MyRepositoryTests(@Autowired val entityManager: TestEntityManager, @Autowired val repository: UserRepository) { @Test fun testExample() { entityManager.persist(User(""sboot"", ""1234"")) val user = repository.findByUsername(""sboot"") assertThat(user?.username).isEqualTo(""sboot"") assertThat(user?.employeeNumber).isEqualTo(""1234"") } } In-memory embedded databases generally work well for tests, since they are fast and do not require any installation. If, however, you prefer to run tests against a real database you can use the @AutoConfigureTestDatabase annotation, as shown in the following example: Java Kotlin import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase; import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase.Replace; import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest; @DataJpaTest @AutoConfigureTestDatabase(replace = Replace.NONE) class MyRepositoryTests { // ... } import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest @DataJpaTest @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) class MyRepositoryTests { // ... } Auto-configured JDBC Tests: @JdbcTest is similar to @DataJpaTest but is for tests that only require a DataSource and do not use Spring Data JDBC. By default, it configures an in-memory embedded database and a JdbcTemplate . Regular @Component and @ConfigurationProperties beans are not scanned when the @JdbcTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. A list of the auto-configurations that are enabled by @JdbcTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . By default, JDBC tests are transactional and roll back at the end of each test. See the relevant section(https://docs.spring.io/spring-framework/reference/6.1/testing/testcontext-framework/tx.html#testcontext-tx-enabling-transactions) in the Spring Framework Reference Documentation for more details. If that is not what you want, you can disable transaction management for a test or for the whole class, as follows: Java Kotlin import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional; @JdbcTest @Transactional(propagation = Propagation.NOT_SUPPORTED) class MyTransactionalTests { } import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest import org.springframework.transaction.annotation.Propagation import org.springframework.transaction.annotation.Transactional @JdbcTest @Transactional(propagation = Propagation.NOT_SUPPORTED) class MyTransactionalTests If you prefer your test to run against a real database, you can use the @AutoConfigureTestDatabase annotation in the same way as for @DataJpaTest . (See Auto-configured Data JPA Tests(#testing.spring-boot-applications.autoconfigured-spring-data-jpa) .) Auto-configured Data JDBC Tests: @DataJdbcTest is similar to @JdbcTest but is for tests that use Spring Data JDBC repositories. By default, it configures an in-memory embedded database, a JdbcTemplate , and Spring Data JDBC repositories. Only AbstractJdbcConfiguration subclasses are scanned when the @DataJdbcTest annotation is used, regular @Component and @ConfigurationProperties beans are not scanned. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. A list of the auto-configurations that are enabled by @DataJdbcTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . By default, Data JDBC tests are transactional and roll back at the end of each test. See the relevant section(https://docs.spring.io/spring-framework/reference/6.1/testing/testcontext-framework/tx.html#testcontext-tx-enabling-transactions) in the Spring Framework Reference Documentation for more details. If that is not what you want, you can disable transaction management for a test or for the whole test class as shown in the JDBC example(#testing.spring-boot-applications.autoconfigured-jdbc) . If you prefer your test to run against a real database, you can use the @AutoConfigureTestDatabase annotation in the same way as for @DataJpaTest . (See Auto-configured Data JPA Tests(#testing.spring-boot-applications.autoconfigured-spring-data-jpa) .) Auto-configured Data R2DBC Tests: @DataR2dbcTest is similar to @DataJdbcTest but is for tests that use Spring Data R2DBC repositories. By default, it configures an in-memory embedded database, an R2dbcEntityTemplate , and Spring Data R2DBC repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataR2dbcTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. A list of the auto-configurations that are enabled by @DataR2dbcTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . By default, Data R2DBC tests are not transactional. If you prefer your test to run against a real database, you can use the @AutoConfigureTestDatabase annotation in the same way as for @DataJpaTest . (See Auto-configured Data JPA Tests(#testing.spring-boot-applications.autoconfigured-spring-data-jpa) .) Auto-configured jOOQ Tests: You can use @JooqTest in a similar fashion as @JdbcTest but for jOOQ-related tests. As jOOQ relies heavily on a Java-based schema that corresponds with the database schema, the existing DataSource is used. If you want to replace it with an in-memory database, you can use @AutoConfigureTestDatabase to override those settings. (For more about using jOOQ with Spring Boot, see Using jOOQ(../data/sql.html#data.sql.jooq) .) Regular @Component and @ConfigurationProperties beans are not scanned when the @JooqTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. A list of the auto-configurations that are enabled by @JooqTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . @JooqTest configures a DSLContext . The following example shows the @JooqTest annotation in use: Java Kotlin import org.jooq.DSLContext; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.jooq.JooqTest; @JooqTest class MyJooqTests { @Autowired private DSLContext dslContext; // ... } import org.jooq.DSLContext import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.jooq.JooqTest @JooqTest class MyJooqTests(@Autowired val dslContext: DSLContext) { // ... } JOOQ tests are transactional and roll back at the end of each test by default. If that is not what you want, you can disable transaction management for a test or for the whole test class as shown in the JDBC example(#testing.spring-boot-applications.autoconfigured-jdbc) . Auto-configured Data MongoDB Tests: You can use @DataMongoTest to test MongoDB applications. By default, it configures a MongoTemplate , scans for @Document classes, and configures Spring Data MongoDB repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataMongoTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using MongoDB with Spring Boot, see MongoDB(../data/nosql.html#data.nosql.mongodb) .) A list of the auto-configuration settings that are enabled by @DataMongoTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . The following class shows the @DataMongoTest annotation in use: Java Kotlin import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest; import org.springframework.data.mongodb.core.MongoTemplate; @DataMongoTest class MyDataMongoDbTests { @Autowired private MongoTemplate mongoTemplate; // ... } import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest import org.springframework.data.mongodb.core.MongoTemplate @DataMongoTest class MyDataMongoDbTests(@Autowired val mongoTemplate: MongoTemplate) { // ... } Auto-configured Data Neo4j Tests: You can use @DataNeo4jTest to test Neo4j applications. By default, it scans for @Node classes, and configures Spring Data Neo4j repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataNeo4jTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using Neo4J with Spring Boot, see Neo4j(../data/nosql.html#data.nosql.neo4j) .) A list of the auto-configuration settings that are enabled by @DataNeo4jTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . The following example shows a typical setup for using Neo4J tests in Spring Boot: Java Kotlin import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest; @DataNeo4jTest class MyDataNeo4jTests { @Autowired private SomeRepository repository; // ... } import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest @DataNeo4jTest class MyDataNeo4jTests(@Autowired val repository: SomeRepository) { // ... } By default, Data Neo4j tests are transactional and roll back at the end of each test. See the relevant section(https://docs.spring.io/spring-framework/reference/6.1/testing/testcontext-framework/tx.html#testcontext-tx-enabling-transactions) in the Spring Framework Reference Documentation for more details. If that is not what you want, you can disable transaction management for a test or for the whole class, as follows: Java Kotlin import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional; @DataNeo4jTest @Transactional(propagation = Propagation.NOT_SUPPORTED) class MyDataNeo4jTests { } import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest import org.springframework.transaction.annotation.Propagation import org.springframework.transaction.annotation.Transactional @DataNeo4jTest @Transactional(propagation = Propagation.NOT_SUPPORTED) class MyDataNeo4jTests Transactional tests are not supported with reactive access. If you are using this style, you must configure @DataNeo4jTest tests as described above. Auto-configured Data Redis Tests: You can use @DataRedisTest to test Redis applications. By default, it scans for @RedisHash classes and configures Spring Data Redis repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataRedisTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using Redis with Spring Boot, see Redis(../data/nosql.html#data.nosql.redis) .) A list of the auto-configuration settings that are enabled by @DataRedisTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . The following example shows the @DataRedisTest annotation in use: Java Kotlin import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest; @DataRedisTest class MyDataRedisTests { @Autowired private SomeRepository repository; // ... } import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest @DataRedisTest class MyDataRedisTests(@Autowired val repository: SomeRepository) { // ... } Auto-configured Data LDAP Tests: You can use @DataLdapTest to test LDAP applications. By default, it configures an in-memory embedded LDAP (if available), configures an LdapTemplate , scans for @Entry classes, and configures Spring Data LDAP repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataLdapTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using LDAP with Spring Boot, see LDAP(../data/nosql.html#data.nosql.ldap) .) A list of the auto-configuration settings that are enabled by @DataLdapTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . The following example shows the @DataLdapTest annotation in use: Java Kotlin import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest; import org.springframework.ldap.core.LdapTemplate; @DataLdapTest class MyDataLdapTests { @Autowired private LdapTemplate ldapTemplate; // ... } import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest import org.springframework.ldap.core.LdapTemplate @DataLdapTest class MyDataLdapTests(@Autowired val ldapTemplate: LdapTemplate) { // ... } In-memory embedded LDAP generally works well for tests, since it is fast and does not require any developer installation. If, however, you prefer to run tests against a real LDAP server, you should exclude the embedded LDAP auto-configuration, as shown in the following example: Java Kotlin import org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration; import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest; @DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class) class MyDataLdapTests { // ... } import org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest @DataLdapTest(excludeAutoConfiguration = [EmbeddedLdapAutoConfiguration::class]) class MyDataLdapTests { // ... } Auto-configured REST Clients: You can use the @RestClientTest annotation to test REST clients. By default, it auto-configures Jackson, GSON, and Jsonb support, configures a RestTemplateBuilder and a RestClient.Builder , and adds support for MockRestServiceServer . Regular @Component and @ConfigurationProperties beans are not scanned when the @RestClientTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. A list of the auto-configuration settings that are enabled by @RestClientTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . The specific beans that you want to test should be specified by using the value or components attribute of @RestClientTest . When using a RestTemplateBuilder in the beans under test and RestTemplateBuilder.rootUri(String rootUri) has been called when building the RestTemplate , then the root URI should be omitted from the MockRestServiceServer expectations as shown in the following example: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.client.RestClientTest; import org.springframework.http.MediaType; import org.springframework.test.web.client.MockRestServiceServer; import static org.assertj.core.api.Assertions.assertThat; import static org.springframework.test.web.client.match.MockRestRequestMatchers.requestTo; import static org.springframework.test.web.client.response.MockRestResponseCreators.withSuccess; @RestClientTest(org.springframework.boot.docs.testing.springbootapplications.autoconfiguredrestclient.RemoteVehicleDetailsService.class) class MyRestTemplateServiceTests { @Autowired private RemoteVehicleDetailsService service; @Autowired private MockRestServiceServer server; @Test void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails() { this.server.expect(requestTo(""/greet/details"")).andRespond(withSuccess(""hello"", MediaType.TEXT_PLAIN)); String greeting = this.service.callRestService(); assertThat(greeting).isEqualTo(""hello""); } } import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.web.client.RestClientTest import org.springframework.http.MediaType import org.springframework.test.web.client.MockRestServiceServer import org.springframework.test.web.client.match.MockRestRequestMatchers import org.springframework.test.web.client.response.MockRestResponseCreators @RestClientTest(RemoteVehicleDetailsService::class) class MyRestTemplateServiceTests( @Autowired val service: RemoteVehicleDetailsService, @Autowired val server: MockRestServiceServer) { @Test fun getVehicleDetailsWhenResultIsSuccessShouldReturnDetails() { server.expect(MockRestRequestMatchers.requestTo(""/greet/details"")) .andRespond(MockRestResponseCreators.withSuccess(""hello"", MediaType.TEXT_PLAIN)) val greeting = service.callRestService() assertThat(greeting).isEqualTo(""hello"") } } When using a RestClient.Builder in the beans under test, or when using a RestTemplateBuilder without calling rootUri(String rootURI) , the full URI must be used in the MockRestServiceServer expectations as shown in the following example: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.client.RestClientTest; import org.springframework.http.MediaType; import org.springframework.test.web.client.MockRestServiceServer; import static org.assertj.core.api.Assertions.assertThat; import static org.springframework.test.web.client.match.MockRestRequestMatchers.requestTo; import static org.springframework.test.web.client.response.MockRestResponseCreators.withSuccess; @RestClientTest(RemoteVehicleDetailsService.class) class MyRestClientServiceTests { @Autowired private RemoteVehicleDetailsService service; @Autowired private MockRestServiceServer server; @Test void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails() { this.server.expect(requestTo(""https://example.com/greet/details"")) .andRespond(withSuccess(""hello"", MediaType.TEXT_PLAIN)); String greeting = this.service.callRestService(); assertThat(greeting).isEqualTo(""hello""); } } import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.web.client.RestClientTest import org.springframework.http.MediaType import org.springframework.test.web.client.MockRestServiceServer import org.springframework.test.web.client.match.MockRestRequestMatchers import org.springframework.test.web.client.response.MockRestResponseCreators @RestClientTest(RemoteVehicleDetailsService::class) class MyRestClientServiceTests( @Autowired val service: RemoteVehicleDetailsService, @Autowired val server: MockRestServiceServer) { @Test fun getVehicleDetailsWhenResultIsSuccessShouldReturnDetails() { server.expect(MockRestRequestMatchers.requestTo(""https://example.com/greet/details"")) .andRespond(MockRestResponseCreators.withSuccess(""hello"", MediaType.TEXT_PLAIN)) val greeting = service.callRestService() assertThat(greeting).isEqualTo(""hello"") } } Auto-configured Spring REST Docs Tests: You can use the @AutoConfigureRestDocs annotation to use Spring REST Docs(https://spring.io/projects/spring-restdocs) in your tests with Mock MVC, REST Assured, or WebTestClient. It removes the need for the JUnit extension in Spring REST Docs. @AutoConfigureRestDocs can be used to override the default output directory ( target/generated-snippets if you are using Maven or build/generated-snippets if you are using Gradle). It can also be used to configure the host, scheme, and port that appears in any documented URIs. Auto-configured Spring REST Docs Tests With Mock MVC: @AutoConfigureRestDocs customizes the MockMvc bean to use Spring REST Docs when testing servlet-based web applications. You can inject it by using @Autowired and use it in your tests as you normally would when using Mock MVC and Spring REST Docs, as shown in the following example: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.http.MediaType; import org.springframework.test.web.servlet.MockMvc; import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; @WebMvcTest(UserController.class) @AutoConfigureRestDocs class MyUserDocumentationTests { @Autowired private MockMvc mvc; @Test void listUsers() throws Exception { this.mvc.perform(get(""/users"").accept(MediaType.TEXT_PLAIN)) .andExpect(status().isOk()) .andDo(document(""list-users"")); } } import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest import org.springframework.http.MediaType import org.springframework.restdocs.mockmvc.MockMvcRestDocumentation import org.springframework.test.web.servlet.MockMvc import org.springframework.test.web.servlet.request.MockMvcRequestBuilders import org.springframework.test.web.servlet.result.MockMvcResultMatchers @WebMvcTest(UserController::class) @AutoConfigureRestDocs class MyUserDocumentationTests(@Autowired val mvc: MockMvc) { @Test fun listUsers() { mvc.perform(MockMvcRequestBuilders.get(""/users"").accept(MediaType.TEXT_PLAIN)) .andExpect(MockMvcResultMatchers.status().isOk) .andDo(MockMvcRestDocumentation.document(""list-users"")) } } If you require more control over Spring REST Docs configuration than offered by the attributes of @AutoConfigureRestDocs , you can use a RestDocsMockMvcConfigurationCustomizer bean, as shown in the following example: Java Kotlin import org.springframework.boot.test.autoconfigure.restdocs.RestDocsMockMvcConfigurationCustomizer; import org.springframework.boot.test.context.TestConfiguration; import org.springframework.restdocs.mockmvc.MockMvcRestDocumentationConfigurer; import org.springframework.restdocs.templates.TemplateFormats; @TestConfiguration(proxyBeanMethods = false) public class MyRestDocsConfiguration implements RestDocsMockMvcConfigurationCustomizer { @Override public void customize(MockMvcRestDocumentationConfigurer configurer) { configurer.snippets().withTemplateFormat(TemplateFormats.markdown()); } } import org.springframework.boot.test.autoconfigure.restdocs.RestDocsMockMvcConfigurationCustomizer import org.springframework.boot.test.context.TestConfiguration import org.springframework.restdocs.mockmvc.MockMvcRestDocumentationConfigurer import org.springframework.restdocs.templates.TemplateFormats @TestConfiguration(proxyBeanMethods = false) class MyRestDocsConfiguration : RestDocsMockMvcConfigurationCustomizer { override fun customize(configurer: MockMvcRestDocumentationConfigurer) { configurer.snippets().withTemplateFormat(TemplateFormats.markdown()) } } If you want to make use of Spring REST Docs support for a parameterized output directory, you can create a RestDocumentationResultHandler bean. The auto-configuration calls alwaysDo with this result handler, thereby causing each MockMvc call to automatically generate the default snippets. The following example shows a RestDocumentationResultHandler being defined: Java Kotlin import org.springframework.boot.test.context.TestConfiguration; import org.springframework.context.annotation.Bean; import org.springframework.restdocs.mockmvc.MockMvcRestDocumentation; import org.springframework.restdocs.mockmvc.RestDocumentationResultHandler; @TestConfiguration(proxyBeanMethods = false) public class MyResultHandlerConfiguration { @Bean public RestDocumentationResultHandler restDocumentation() { return MockMvcRestDocumentation.document(""{method-name}""); } } import org.springframework.boot.test.context.TestConfiguration import org.springframework.context.annotation.Bean import org.springframework.restdocs.mockmvc.MockMvcRestDocumentation import org.springframework.restdocs.mockmvc.RestDocumentationResultHandler @TestConfiguration(proxyBeanMethods = false) class MyResultHandlerConfiguration { @Bean fun restDocumentation(): RestDocumentationResultHandler { return MockMvcRestDocumentation.document(""{method-name}"") } } Auto-configured Spring REST Docs Tests With WebTestClient: @AutoConfigureRestDocs can also be used with WebTestClient when testing reactive web applications. You can inject it by using @Autowired and use it in your tests as you normally would when using @WebFluxTest and Spring REST Docs, as shown in the following example: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs; import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest; import org.springframework.test.web.reactive.server.WebTestClient; import static org.springframework.restdocs.webtestclient.WebTestClientRestDocumentation.document; @WebFluxTest @AutoConfigureRestDocs class MyUsersDocumentationTests { @Autowired private WebTestClient webTestClient; @Test void listUsers() { this.webTestClient .get().uri(""/"") .exchange() .expectStatus() .isOk() .expectBody() .consumeWith(document(""list-users"")); } } import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest import org.springframework.restdocs.webtestclient.WebTestClientRestDocumentation import org.springframework.test.web.reactive.server.WebTestClient @WebFluxTest @AutoConfigureRestDocs class MyUsersDocumentationTests(@Autowired val webTestClient: WebTestClient) { @Test fun listUsers() { webTestClient .get().uri(""/"") .exchange() .expectStatus() .isOk .expectBody() .consumeWith(WebTestClientRestDocumentation.document(""list-users"")) } } If you require more control over Spring REST Docs configuration than offered by the attributes of @AutoConfigureRestDocs , you can use a RestDocsWebTestClientConfigurationCustomizer bean, as shown in the following example: Java Kotlin import org.springframework.boot.test.autoconfigure.restdocs.RestDocsWebTestClientConfigurationCustomizer; import org.springframework.boot.test.context.TestConfiguration; import org.springframework.restdocs.webtestclient.WebTestClientRestDocumentationConfigurer; @TestConfiguration(proxyBeanMethods = false) public class MyRestDocsConfiguration implements RestDocsWebTestClientConfigurationCustomizer { @Override public void customize(WebTestClientRestDocumentationConfigurer configurer) { configurer.snippets().withEncoding(""UTF-8""); } } import org.springframework.boot.test.autoconfigure.restdocs.RestDocsWebTestClientConfigurationCustomizer import org.springframework.boot.test.context.TestConfiguration import org.springframework.restdocs.webtestclient.WebTestClientRestDocumentationConfigurer @TestConfiguration(proxyBeanMethods = false) class MyRestDocsConfiguration : RestDocsWebTestClientConfigurationCustomizer { override fun customize(configurer: WebTestClientRestDocumentationConfigurer) { configurer.snippets().withEncoding(""UTF-8"") } } If you want to make use of Spring REST Docs support for a parameterized output directory, you can use a WebTestClientBuilderCustomizer to configure a consumer for every entity exchange result. The following example shows such a WebTestClientBuilderCustomizer being defined: Java Kotlin import org.springframework.boot.test.context.TestConfiguration; import org.springframework.boot.test.web.reactive.server.WebTestClientBuilderCustomizer; import org.springframework.context.annotation.Bean; import static org.springframework.restdocs.webtestclient.WebTestClientRestDocumentation.document; @TestConfiguration(proxyBeanMethods = false) public class MyWebTestClientBuilderCustomizerConfiguration { @Bean public WebTestClientBuilderCustomizer restDocumentation() { return (builder) -> builder.entityExchangeResultConsumer(document(""{method-name}"")); } } import org.springframework.boot.test.context.TestConfiguration import org.springframework.boot.test.web.reactive.server.WebTestClientBuilderCustomizer import org.springframework.context.annotation.Bean import org.springframework.restdocs.webtestclient.WebTestClientRestDocumentation import org.springframework.test.web.reactive.server.WebTestClient @TestConfiguration(proxyBeanMethods = false) class MyWebTestClientBuilderCustomizerConfiguration { @Bean fun restDocumentation(): WebTestClientBuilderCustomizer { return WebTestClientBuilderCustomizer { builder: WebTestClient.Builder -> builder.entityExchangeResultConsumer( WebTestClientRestDocumentation.document(""{method-name}"") ) } } } Auto-configured Spring REST Docs Tests With REST Assured: @AutoConfigureRestDocs makes a RequestSpecification bean, preconfigured to use Spring REST Docs, available to your tests. You can inject it by using @Autowired and use it in your tests as you normally would when using REST Assured and Spring REST Docs, as shown in the following example: Java Kotlin import io.restassured.specification.RequestSpecification; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.context.SpringBootTest.WebEnvironment; import org.springframework.boot.test.web.server.LocalServerPort; import static io.restassured.RestAssured.given; import static org.hamcrest.Matchers.is; import static org.springframework.restdocs.restassured.RestAssuredRestDocumentation.document; @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) @AutoConfigureRestDocs class MyUserDocumentationTests { @Test void listUsers(@Autowired RequestSpecification documentationSpec, @LocalServerPort int port) { given(documentationSpec) .filter(document(""list-users"")) .when() .port(port) .get(""/"") .then().assertThat() .statusCode(is(200)); } } import io.restassured.RestAssured import io.restassured.specification.RequestSpecification import org.hamcrest.Matchers import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs import org.springframework.boot.test.context.SpringBootTest import org.springframework.boot.test.context.SpringBootTest.WebEnvironment import org.springframework.boot.test.web.server.LocalServerPort import org.springframework.restdocs.restassured.RestAssuredRestDocumentation @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) @AutoConfigureRestDocs class MyUserDocumentationTests { @Test fun listUsers(@Autowired documentationSpec: RequestSpecification?, @LocalServerPort port: Int) { RestAssured.given(documentationSpec) .filter(RestAssuredRestDocumentation.document(""list-users"")) .`when`() .port(port)[""/""] .then().assertThat() .statusCode(Matchers.`is`(200)) } } If you require more control over Spring REST Docs configuration than offered by the attributes of @AutoConfigureRestDocs , a RestDocsRestAssuredConfigurationCustomizer bean can be used, as shown in the following example: Java Kotlin import org.springframework.boot.test.autoconfigure.restdocs.RestDocsRestAssuredConfigurationCustomizer; import org.springframework.boot.test.context.TestConfiguration; import org.springframework.restdocs.restassured.RestAssuredRestDocumentationConfigurer; import org.springframework.restdocs.templates.TemplateFormats; @TestConfiguration(proxyBeanMethods = false) public class MyRestDocsConfiguration implements RestDocsRestAssuredConfigurationCustomizer { @Override public void customize(RestAssuredRestDocumentationConfigurer configurer) { configurer.snippets().withTemplateFormat(TemplateFormats.markdown()); } } import org.springframework.boot.test.autoconfigure.restdocs.RestDocsRestAssuredConfigurationCustomizer import org.springframework.boot.test.context.TestConfiguration import org.springframework.restdocs.restassured.RestAssuredRestDocumentationConfigurer import org.springframework.restdocs.templates.TemplateFormats @TestConfiguration(proxyBeanMethods = false) class MyRestDocsConfiguration : RestDocsRestAssuredConfigurationCustomizer { override fun customize(configurer: RestAssuredRestDocumentationConfigurer) { configurer.snippets().withTemplateFormat(TemplateFormats.markdown()) } } Auto-configured Spring Web Services Tests: Auto-configured Spring Web Services Client Tests: You can use @WebServiceClientTest to test applications that call web services using the Spring Web Services project. By default, it configures a mock WebServiceServer bean and automatically customizes your WebServiceTemplateBuilder . (For more about using Web Services with Spring Boot, see Web Services(../io/webservices.html) .) A list of the auto-configuration settings that are enabled by @WebServiceClientTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . The following example shows the @WebServiceClientTest annotation in use: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.webservices.client.WebServiceClientTest; import org.springframework.ws.test.client.MockWebServiceServer; import org.springframework.xml.transform.StringSource; import static org.assertj.core.api.Assertions.assertThat; import static org.springframework.ws.test.client.RequestMatchers.payload; import static org.springframework.ws.test.client.ResponseCreators.withPayload; @WebServiceClientTest(SomeWebService.class) class MyWebServiceClientTests { @Autowired private MockWebServiceServer server; @Autowired private SomeWebService someWebService; @Test void mockServerCall() { this.server .expect(payload(new StringSource(""<request/>""))) .andRespond(withPayload(new StringSource(""<response><status>200</status></response>""))); assertThat(this.someWebService.test()) .extracting(Response::getStatus) .isEqualTo(200); } } import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.webservices.client.WebServiceClientTest import org.springframework.ws.test.client.MockWebServiceServer import org.springframework.ws.test.client.RequestMatchers import org.springframework.ws.test.client.ResponseCreators import org.springframework.xml.transform.StringSource @WebServiceClientTest(SomeWebService::class) class MyWebServiceClientTests(@Autowired val server: MockWebServiceServer, @Autowired val someWebService: SomeWebService) { @Test fun mockServerCall() { server .expect(RequestMatchers.payload(StringSource(""<request/>""))) .andRespond(ResponseCreators.withPayload(StringSource(""<response><status>200</status></response>""))) assertThat(this.someWebService.test()).extracting(Response::status).isEqualTo(200) } } Auto-configured Spring Web Services Server Tests: You can use @WebServiceServerTest to test applications that implement web services using the Spring Web Services project. By default, it configures a MockWebServiceClient bean that can be used to call your web service endpoints. (For more about using Web Services with Spring Boot, see Web Services(../io/webservices.html) .) A list of the auto-configuration settings that are enabled by @WebServiceServerTest can be found in the appendix(../../appendix/test-auto-configuration/index.html) . The following example shows the @WebServiceServerTest annotation in use: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.webservices.server.WebServiceServerTest; import org.springframework.ws.test.server.MockWebServiceClient; import org.springframework.ws.test.server.RequestCreators; import org.springframework.ws.test.server.ResponseMatchers; import org.springframework.xml.transform.StringSource; @WebServiceServerTest(ExampleEndpoint.class) class MyWebServiceServerTests { @Autowired private MockWebServiceClient client; @Test void mockServerCall() { this.client .sendRequest(RequestCreators.withPayload(new StringSource(""<ExampleRequest/>""))) .andExpect(ResponseMatchers.payload(new StringSource(""<ExampleResponse>42</ExampleResponse>""))); } } import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.webservices.server.WebServiceServerTest import org.springframework.ws.test.server.MockWebServiceClient import org.springframework.ws.test.server.RequestCreators import org.springframework.ws.test.server.ResponseMatchers import org.springframework.xml.transform.StringSource @WebServiceServerTest(ExampleEndpoint::class) class MyWebServiceServerTests(@Autowired val client: MockWebServiceClient) { @Test fun mockServerCall() { client .sendRequest(RequestCreators.withPayload(StringSource(""<ExampleRequest/>""))) .andExpect(ResponseMatchers.payload(StringSource(""<ExampleResponse>42</ExampleResponse>""))) } } Additional Auto-configuration and Slicing: Each slice provides one or more @AutoConfigure…​ annotations that namely defines the auto-configurations that should be included as part of a slice. Additional auto-configurations can be added on a test-by-test basis by creating a custom @AutoConfigure…​ annotation or by adding @ImportAutoConfiguration to the test as shown in the following example: Java Kotlin import org.springframework.boot.autoconfigure.ImportAutoConfiguration; import org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration; import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest; @JdbcTest @ImportAutoConfiguration(IntegrationAutoConfiguration.class) class MyJdbcTests { } import org.springframework.boot.autoconfigure.ImportAutoConfiguration import org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest @JdbcTest @ImportAutoConfiguration(IntegrationAutoConfiguration::class) class MyJdbcTests Make sure to not use the regular @Import annotation to import auto-configurations as they are handled in a specific way by Spring Boot. Alternatively, additional auto-configurations can be added for any use of a slice annotation by registering them in a file stored in META-INF/spring as shown in the following example: META-INF/spring/org.springframework.boot.test.autoconfigure.jdbc.JdbcTest.imports com.example.IntegrationAutoConfiguration In this example, the com.example.IntegrationAutoConfiguration is enabled on every test annotated with @JdbcTest . You can use comments with # in this file. A slice or @AutoConfigure…​ annotation can be customized this way as long as it is meta-annotated with @ImportAutoConfiguration . User Configuration and Slicing: If you structure your code(../using/structuring-your-code.html) in a sensible way, your @SpringBootApplication class is used by default(#testing.spring-boot-applications.detecting-configuration) as the configuration of your tests. It then becomes important not to litter the application’s main class with configuration settings that are specific to a particular area of its functionality. Assume that you are using Spring Data MongoDB, you rely on the auto-configuration for it, and you have enabled auditing. You could define your @SpringBootApplication as follows: Java Kotlin import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.data.mongodb.config.EnableMongoAuditing; @SpringBootApplication @EnableMongoAuditing public class MyApplication { // ... } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.data.mongodb.config.EnableMongoAuditing @SpringBootApplication @EnableMongoAuditing class MyApplication { // ... } Because this class is the source configuration for the test, any slice test actually tries to enable Mongo auditing, which is definitely not what you want to do. A recommended approach is to move that area-specific configuration to a separate @Configuration class at the same level as your application, as shown in the following example: Java Kotlin import org.springframework.context.annotation.Configuration; import org.springframework.data.mongodb.config.EnableMongoAuditing; @Configuration(proxyBeanMethods = false) @EnableMongoAuditing public class MyMongoConfiguration { // ... } import org.springframework.context.annotation.Configuration import org.springframework.data.mongodb.config.EnableMongoAuditing @Configuration(proxyBeanMethods = false) @EnableMongoAuditing class MyMongoConfiguration { // ... } Depending on the complexity of your application, you may either have a single @Configuration class for your customizations or one class per domain area. The latter approach lets you enable it in one of your tests, if necessary, with the @Import annotation. See this how-to section(../../how-to/testing.html#howto.testing.slice-tests) for more details on when you might want to enable specific @Configuration classes for slice tests. Test slices exclude @Configuration classes from scanning. For example, for a @WebMvcTest , the following configuration will not include the given WebMvcConfigurer bean in the application context loaded by the test slice: Java Kotlin import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration(proxyBeanMethods = false) public class MyWebConfiguration { @Bean public WebMvcConfigurer testConfigurer() { return new WebMvcConfigurer() { // ... }; } } import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.web.servlet.config.annotation.WebMvcConfigurer @Configuration(proxyBeanMethods = false) class MyWebConfiguration { @Bean fun testConfigurer(): WebMvcConfigurer { return object : WebMvcConfigurer { // ... } } } The configuration below will, however, cause the custom WebMvcConfigurer to be loaded by the test slice. Java Kotlin import org.springframework.stereotype.Component; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Component public class MyWebMvcConfigurer implements WebMvcConfigurer { // ... } import org.springframework.stereotype.Component import org.springframework.web.servlet.config.annotation.WebMvcConfigurer @Component class MyWebMvcConfigurer : WebMvcConfigurer { // ... } Another source of confusion is classpath scanning. Assume that, while you structured your code in a sensible way, you need to scan an additional package. Your application may resemble the following code: Java Kotlin import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.ComponentScan; @SpringBootApplication @ComponentScan({ ""com.example.app"", ""com.example.another"" }) public class MyApplication { // ... } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.context.annotation.ComponentScan @SpringBootApplication @ComponentScan(""com.example.app"", ""com.example.another"") class MyApplication { // ... } Doing so effectively overrides the default component scan directive with the side effect of scanning those two packages regardless of the slice that you chose. For instance, a @DataJpaTest seems to suddenly scan components and user configurations of your application. Again, moving the custom directive to a separate class is a good way to fix this issue. If this is not an option for you, you can create a @SpringBootConfiguration somewhere in the hierarchy of your test so that it is used instead. Alternatively, you can specify a source for your test, which disables the behavior of finding a default one. Using Spock to Test Spring Boot Applications: Spock 2.2 or later can be used to test a Spring Boot application. To do so, add a dependency on a -groovy-4.0 version of Spock’s spock-spring module to your application’s build. spock-spring integrates Spring’s test framework into Spock. See the documentation for Spock’s Spring module(https://spockframework.org/spock/docs/2.2-M1/modules.html#_spring_module) for further details."
"https://docs.spring.io/spring-boot/reference/testing/testcontainers.html","Testcontainers: The Testcontainers(https://www.testcontainers.org/) library provides a way to manage services running inside Docker containers. It integrates with JUnit, allowing you to write a test class that can start up a container before any of the tests run. Testcontainers is especially useful for writing integration tests that talk to a real backend service such as MySQL, MongoDB, Cassandra and others. Testcontainers can be used in a Spring Boot test as follows: Java Kotlin import org.junit.jupiter.api.Test; import org.testcontainers.containers.Neo4jContainer; import org.testcontainers.junit.jupiter.Container; import org.testcontainers.junit.jupiter.Testcontainers; import org.springframework.boot.test.context.SpringBootTest; @Testcontainers @SpringBootTest class MyIntegrationTests { @Container static Neo4jContainer<?> neo4j = new Neo4jContainer<>(""neo4j:5""); @Test void myTest() { // ... } } import org.junit.jupiter.api.Test; import org.testcontainers.containers.Neo4jContainer; import org.testcontainers.junit.jupiter.Container; import org.testcontainers.junit.jupiter.Testcontainers; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.testcontainers.service.connection.ServiceConnection @Testcontainers @SpringBootTest class MyIntegrationTests { @Test fun myTest() { // ... } companion object { @Container @JvmStatic val neo4j = Neo4jContainer(""neo4j:5""); } } This will start up a docker container running Neo4j (if Docker is running locally) before any of the tests are run. In most cases, you will need to configure the application to connect to the service running in the container. Service Connections: A service connection is a connection to any remote service. Spring Boot’s auto-configuration can consume the details of a service connection and use them to establish a connection to a remote service. When doing so, the connection details take precedence over any connection-related configuration properties. When using Testcontainers, connection details can be automatically created for a service running in a container by annotating the container field in the test class. Java Kotlin import org.junit.jupiter.api.Test; import org.testcontainers.containers.Neo4jContainer; import org.testcontainers.junit.jupiter.Container; import org.testcontainers.junit.jupiter.Testcontainers; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.testcontainers.service.connection.ServiceConnection; @Testcontainers @SpringBootTest class MyIntegrationTests { @Container @ServiceConnection static Neo4jContainer<?> neo4j = new Neo4jContainer<>(""neo4j:5""); @Test void myTest() { // ... } } import org.junit.jupiter.api.Test; import org.testcontainers.containers.Neo4jContainer; import org.testcontainers.junit.jupiter.Container; import org.testcontainers.junit.jupiter.Testcontainers; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.testcontainers.service.connection.ServiceConnection; @Testcontainers @SpringBootTest class MyIntegrationTests { @Test fun myTest() { // ... } companion object { @Container @ServiceConnection @JvmStatic val neo4j = Neo4jContainer(""neo4j:5""); } } Thanks to @ServiceConnection , the above configuration allows Neo4j-related beans in the application to communicate with Neo4j running inside the Testcontainers-managed Docker container. This is done by automatically defining a Neo4jConnectionDetails bean which is then used by the Neo4j auto-configuration, overriding any connection-related configuration properties. You’ll need to add the spring-boot-testcontainers module as a test dependency in order to use service connections with Testcontainers. Service connection annotations are processed by ContainerConnectionDetailsFactory classes registered with spring.factories . A ContainerConnectionDetailsFactory can create a ConnectionDetails bean based on a specific Container subclass, or the Docker image name. The following service connection factories are provided in the spring-boot-testcontainers jar: Connection Details Matched on ActiveMQConnectionDetails Containers named ""symptoma/activemq"" or ActiveMQContainer ArtemisConnectionDetails Containers of type ArtemisContainer CassandraConnectionDetails Containers of type CassandraContainer CouchbaseConnectionDetails Containers of type CouchbaseContainer ElasticsearchConnectionDetails Containers of type ElasticsearchContainer FlywayConnectionDetails Containers of type JdbcDatabaseContainer JdbcConnectionDetails Containers of type JdbcDatabaseContainer KafkaConnectionDetails Containers of type org.testcontainers.containers.KafkaContainer or RedpandaContainer LiquibaseConnectionDetails Containers of type JdbcDatabaseContainer MongoConnectionDetails Containers of type MongoDBContainer Neo4jConnectionDetails Containers of type Neo4jContainer OtlpMetricsConnectionDetails Containers named ""otel/opentelemetry-collector-contrib"" OtlpTracingConnectionDetails Containers named ""otel/opentelemetry-collector-contrib"" PulsarConnectionDetails Containers of type PulsarContainer R2dbcConnectionDetails Containers of type MariaDBContainer , MSSQLServerContainer , MySQLContainer , OracleContainer , or PostgreSQLContainer RabbitConnectionDetails Containers of type RabbitMQContainer RedisConnectionDetails Containers named ""redis"" ZipkinConnectionDetails Containers named ""openzipkin/zipkin"" By default all applicable connection details beans will be created for a given Container . For example, a PostgreSQLContainer will create both JdbcConnectionDetails and R2dbcConnectionDetails . If you want to create only a subset of the applicable types, you can use the type attribute of @ServiceConnection . By default Container.getDockerImageName().getRepository() is used to obtain the name used to find connection details. The repository portion of the Docker image name ignores any registry and the version. This works as long as Spring Boot is able to get the instance of the Container , which is the case when using a static field like in the example above. If you’re using a @Bean method, Spring Boot won’t call the bean method to get the Docker image name, because this would cause eager initialization issues. Instead, the return type of the bean method is used to find out which connection detail should be used. This works as long as you’re using typed containers, e.g. Neo4jContainer or RabbitMQContainer . This stops working if you’re using GenericContainer , e.g. with Redis, as shown in the following example: Java Kotlin import org.testcontainers.containers.GenericContainer; import org.springframework.boot.test.context.TestConfiguration; import org.springframework.boot.testcontainers.service.connection.ServiceConnection; import org.springframework.context.annotation.Bean; @TestConfiguration(proxyBeanMethods = false) public class MyRedisConfiguration { @Bean @ServiceConnection(name = ""redis"") public GenericContainer<?> redisContainer() { return new GenericContainer<>(""redis:7""); } } import org.springframework.boot.test.context.TestConfiguration import org.springframework.boot.testcontainers.service.connection.ServiceConnection import org.springframework.context.annotation.Bean import org.testcontainers.containers.GenericContainer @TestConfiguration(proxyBeanMethods = false) class MyRedisConfiguration { @Bean @ServiceConnection(name = ""redis"") fun redisContainer(): GenericContainer<*> { return GenericContainer(""redis:7"") } } Spring Boot can’t tell from GenericContainer which container image is used, so the name attribute from @ServiceConnection must be used to provide that hint. You can also use the name attribute of @ServiceConnection to override which connection detail will be used, for example when using custom images. If you are using the Docker image registry.mycompany.com/mirror/myredis , you’d use @ServiceConnection(name=""redis"") to ensure RedisConnectionDetails are created. Dynamic Properties: A slightly more verbose but also more flexible alternative to service connections is @DynamicPropertySource . A static @DynamicPropertySource method allows adding dynamic property values to the Spring Environment. Java Kotlin import org.junit.jupiter.api.Test; import org.testcontainers.containers.Neo4jContainer; import org.testcontainers.junit.jupiter.Container; import org.testcontainers.junit.jupiter.Testcontainers; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.DynamicPropertyRegistry; import org.springframework.test.context.DynamicPropertySource; @Testcontainers @SpringBootTest class MyIntegrationTests { @Container static Neo4jContainer<?> neo4j = new Neo4jContainer<>(""neo4j:5""); @Test void myTest() { // ... } @DynamicPropertySource static void neo4jProperties(DynamicPropertyRegistry registry) { registry.add(""spring.neo4j.uri"", neo4j::getBoltUrl); } } import org.junit.jupiter.api.Test import org.springframework.boot.test.context.SpringBootTest import org.springframework.test.context.DynamicPropertyRegistry import org.springframework.test.context.DynamicPropertySource import org.testcontainers.containers.Neo4jContainer import org.testcontainers.junit.jupiter.Container import org.testcontainers.junit.jupiter.Testcontainers @Testcontainers @SpringBootTest class MyIntegrationTests { @Test fun myTest() { // ... } companion object { @Container @JvmStatic val neo4j = Neo4jContainer(""neo4j:5""); @DynamicPropertySource @JvmStatic fun neo4jProperties(registry: DynamicPropertyRegistry) { registry.add(""spring.neo4j.uri"") { neo4j.boltUrl } } } } The above configuration allows Neo4j-related beans in the application to communicate with Neo4j running inside the Testcontainers-managed Docker container."
"https://docs.spring.io/spring-boot/reference/testing/test-utilities.html","Test Utilities: A few test utility classes that are generally useful when testing your application are packaged as part of spring-boot . ConfigDataApplicationContextInitializer: ConfigDataApplicationContextInitializer is an ApplicationContextInitializer that you can apply to your tests to load Spring Boot application.properties files. You can use it when you do not need the full set of features provided by @SpringBootTest , as shown in the following example: Java Kotlin import org.springframework.boot.test.context.ConfigDataApplicationContextInitializer; import org.springframework.test.context.ContextConfiguration; @ContextConfiguration(classes = Config.class, initializers = ConfigDataApplicationContextInitializer.class) class MyConfigFileTests { // ... } import org.springframework.boot.test.context.ConfigDataApplicationContextInitializer import org.springframework.test.context.ContextConfiguration @ContextConfiguration(classes = [Config::class], initializers = [ConfigDataApplicationContextInitializer::class]) class MyConfigFileTests { // ... } Using ConfigDataApplicationContextInitializer alone does not provide support for @Value(""${…​}"") injection. Its only job is to ensure that application.properties files are loaded into Spring’s Environment . For @Value support, you need to either additionally configure a PropertySourcesPlaceholderConfigurer or use @SpringBootTest , which auto-configures one for you. TestPropertyValues: TestPropertyValues lets you quickly add properties to a ConfigurableEnvironment or ConfigurableApplicationContext . You can call it with key=value strings, as follows: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.boot.test.util.TestPropertyValues; import org.springframework.mock.env.MockEnvironment; import static org.assertj.core.api.Assertions.assertThat; class MyEnvironmentTests { @Test void testPropertySources() { MockEnvironment environment = new MockEnvironment(); TestPropertyValues.of(""org=Spring"", ""name=Boot"").applyTo(environment); assertThat(environment.getProperty(""name"")).isEqualTo(""Boot""); } } import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.springframework.boot.test.util.TestPropertyValues import org.springframework.mock.env.MockEnvironment class MyEnvironmentTests { @Test fun testPropertySources() { val environment = MockEnvironment() TestPropertyValues.of(""org=Spring"", ""name=Boot"").applyTo(environment) assertThat(environment.getProperty(""name"")).isEqualTo(""Boot"") } } OutputCapture: OutputCapture is a JUnit Extension that you can use to capture System.out and System.err output. To use it, add @ExtendWith(OutputCaptureExtension.class) and inject CapturedOutput as an argument to your test class constructor or test method as follows: Java Kotlin import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.springframework.boot.test.system.CapturedOutput; import org.springframework.boot.test.system.OutputCaptureExtension; import static org.assertj.core.api.Assertions.assertThat; @ExtendWith(OutputCaptureExtension.class) class MyOutputCaptureTests { @Test void testName(CapturedOutput output) { System.out.println(""Hello World!""); assertThat(output).contains(""World""); } } import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.junit.jupiter.api.extension.ExtendWith import org.springframework.boot.test.system.CapturedOutput import org.springframework.boot.test.system.OutputCaptureExtension @ExtendWith(OutputCaptureExtension::class) class MyOutputCaptureTests { @Test fun testName(output: CapturedOutput?) { println(""Hello World!"") assertThat(output).contains(""World"") } } TestRestTemplate: TestRestTemplate is a convenience alternative to Spring’s RestTemplate that is useful in integration tests. You can get a vanilla template or one that sends Basic HTTP authentication (with a username and password). In either case, the template is fault tolerant. This means that it behaves in a test-friendly way by not throwing exceptions on 4xx and 5xx errors. Instead, such errors can be detected through the returned ResponseEntity and its status code. Spring Framework 5.0 provides a new WebTestClient that works for WebFlux integration tests(spring-boot-applications.html#testing.spring-boot-applications.spring-webflux-tests) and both WebFlux and MVC end-to-end testing(spring-boot-applications.html#testing.spring-boot-applications.with-running-server) . It provides a fluent API for assertions, unlike TestRestTemplate . It is recommended, but not mandatory, to use the Apache HTTP Client (version 5.1 or better). If you have that on your classpath, the TestRestTemplate responds by configuring the client appropriately. If you do use Apache’s HTTP client, some additional test-friendly features are enabled: Redirects are not followed (so you can assert the response location). Cookies are ignored (so the template is stateless). TestRestTemplate can be instantiated directly in your integration tests, as shown in the following example: Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.boot.test.web.client.TestRestTemplate; import org.springframework.http.ResponseEntity; import static org.assertj.core.api.Assertions.assertThat; class MyTests { private final TestRestTemplate template = new TestRestTemplate(); @Test void testRequest() { ResponseEntity<String> headers = this.template.getForEntity(""https://myhost.example.com/example"", String.class); assertThat(headers.getHeaders().getLocation()).hasHost(""other.example.com""); } } import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.springframework.boot.test.web.client.TestRestTemplate class MyTests { private val template = TestRestTemplate() @Test fun testRequest() { val headers = template.getForEntity(""https://myhost.example.com/example"", String::class.java) assertThat(headers.headers.location).hasHost(""other.example.com"") } } Alternatively, if you use the @SpringBootTest annotation with WebEnvironment.RANDOM_PORT or WebEnvironment.DEFINED_PORT , you can inject a fully configured TestRestTemplate and start using it. If necessary, additional customizations can be applied through the RestTemplateBuilder bean. Any URLs that do not specify a host and port automatically connect to the embedded server, as shown in the following example: Java Kotlin import java.time.Duration; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.context.SpringBootTest.WebEnvironment; import org.springframework.boot.test.context.TestConfiguration; import org.springframework.boot.test.web.client.TestRestTemplate; import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.http.HttpHeaders; import static org.assertj.core.api.Assertions.assertThat; @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) class MySpringBootTests { @Autowired private TestRestTemplate template; @Test void testRequest() { HttpHeaders headers = this.template.getForEntity(""/example"", String.class).getHeaders(); assertThat(headers.getLocation()).hasHost(""other.example.com""); } @TestConfiguration(proxyBeanMethods = false) static class RestTemplateBuilderConfiguration { @Bean RestTemplateBuilder restTemplateBuilder() { return new RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(1)) .setReadTimeout(Duration.ofSeconds(1)); } } } import org.assertj.core.api.Assertions.assertThat import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.context.SpringBootTest import org.springframework.boot.test.context.SpringBootTest.WebEnvironment import org.springframework.boot.test.context.TestConfiguration import org.springframework.boot.test.web.client.TestRestTemplate import org.springframework.boot.web.client.RestTemplateBuilder import org.springframework.context.annotation.Bean import java.time.Duration @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) class MySpringBootTests(@Autowired val template: TestRestTemplate) { @Test fun testRequest() { val headers = template.getForEntity(""/example"", String::class.java).headers assertThat(headers.location).hasHost(""other.example.com"") } @TestConfiguration(proxyBeanMethods = false) internal class RestTemplateBuilderConfiguration { @Bean fun restTemplateBuilder(): RestTemplateBuilder { return RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(1)) .setReadTimeout(Duration.ofSeconds(1)) } } }"
"https://docs.spring.io/spring-boot/reference/packaging/index.html","Packaging Spring Boot Applications: Spring Boot supports several technologies for optimizing applications for deployment, including GraalVM native images(native-image/index.html) , Class Data Sharing(class-data-sharing.html) , and Checkpoint and Restore(checkpoint-restore.html) . Spring Boot applications can be packaged in Docker containers using techniques described in Container Images(container-images/index.html) ."
"https://docs.spring.io/spring-boot/reference/packaging/efficient.html","Efficient Deployments: Unpacking the Executable jar: You can run your application using the executable jar, but loading the classes from nested jars has a small startup cost. Depending on the size of the jar, running the application from an exploded structure is faster and recommended in production. Certain PaaS implementations may also choose to extract archives before they run. For example, Cloud Foundry operates this way. Spring Boot supports extracting your application to a directory using different layouts. The default layout is the most efficient, and is CDS friendly(class-data-sharing.html) . In this layout, the libraries are extracted to a lib/ folder, and the application jar contains the application classes and a manifest which references the libraries in the lib/ folder. To unpack the executable jar, run this command: $ java -Djarmode=tools -jar my-app.jar extract And then in production, you can run the extracted jar: $ java -jar my-app/my-app.jar After startup, you should not expect any differences in execution time between running an executable jar and running an extracted jar. Run java -Djarmode=tools -jar my-app.jar help extract to see all possible options."
"https://docs.spring.io/spring-boot/reference/packaging/class-data-sharing.html","Class Data Sharing: Class Data Sharing (CDS) is a JVM feature(https://docs.oracle.com/en/java/javase/17/vm/class-data-sharing.html) that can help reduce the startup time and memory footprint of Java applications. To use it, you should first perform a training run on your application in extracted form: $ java -Djarmode=tools -jar my-app.jar extract --destination application $ cd application $ java -XX:ArchiveClassesAtExit=application.jsa -Dspring.context.exit=onRefresh -jar my-app.jar This creates an application.jsa file that can be reused as long as the application is not updated. To use the cache, you need to add an extra parameter when starting the application: $ java -XX:SharedArchiveFile=application.jsa -jar my-app.jar For more details about CDS, refer to the CDS how-to guide(../../how-to/class-data-sharing.html) and the Spring Framework reference documentation(https://docs.spring.io/spring-framework/reference/6.1/integration/cds.html) ."
"https://docs.spring.io/spring-boot/reference/packaging/aot.html","Ahead-of-Time Processing With the JVM: It’s beneficial for the startup time to run your application using the AOT generated initialization code. First, you need to ensure that the jar you are building includes AOT generated code. CDS and AOT can be combined to further improve startup time. For Maven, this means that you should build with -Pnative to activate the native profile: $ mvn -Pnative package For Gradle, you need to ensure that your build includes the org.springframework.boot.aot plugin. When the JAR has been built, run it with spring.aot.enabled system property set to true . For example: $ java -Dspring.aot.enabled=true -jar myapplication.jar ........ Starting AOT-processed MyApplication ... Beware that using the ahead-of-time processing has drawbacks. It implies the following restrictions: The classpath is fixed and fully defined at build time The beans defined in your application cannot change at runtime, meaning: The Spring @Profile annotation and profile-specific configuration have limitations(../../how-to/aot.html#howto.aot.conditions) . Properties that change if a bean is created are not supported (for example, @ConditionalOnProperty and .enable properties). To learn more about ahead-of-time processing, please see the Understanding Spring Ahead-of-Time Processing(native-image/introducing-graalvm-native-images.html#packaging.native-image.introducing-graalvm-native-images.understanding-aot-processing) section."
"https://docs.spring.io/spring-boot/reference/packaging/native-image/index.html","GraalVM Native Images: GraalVM Native Images(https://www.graalvm.org/native-image/) are standalone executables that can be generated by processing compiled Java applications ahead-of-time. Native Images generally have a smaller memory footprint and start faster than their JVM counterparts."
"https://docs.spring.io/spring-boot/reference/packaging/native-image/introducing-graalvm-native-images.html","Introducing GraalVM Native Images: GraalVM Native Images provide a new way to deploy and run Java applications. Compared to the Java Virtual Machine, native images can run with a smaller memory footprint and with much faster startup times. They are well suited to applications that are deployed using container images and are especially interesting when combined with ""Function as a service"" (FaaS) platforms. Unlike traditional applications written for the JVM, GraalVM Native Image applications require ahead-of-time processing in order to create an executable. This ahead-of-time processing involves statically analyzing your application code from its main entry point. A GraalVM Native Image is a complete, platform-specific executable. You do not need to ship a Java Virtual Machine in order to run a native image. If you just want to get started and experiment with GraalVM you can jump to the Developing Your First GraalVM Native Application(../../../how-to/native-image/developing-your-first-application.html) section and return to this section later. Key Differences with JVM Deployments: The fact that GraalVM Native Images are produced ahead-of-time means that there are some key differences between native and JVM based applications. The main differences are: Static analysis of your application is performed at build-time from the main entry point. Code that cannot be reached when the native image is created will be removed and won’t be part of the executable. GraalVM is not directly aware of dynamic elements of your code and must be told about reflection, resources, serialization, and dynamic proxies. The application classpath is fixed at build time and cannot change. There is no lazy class loading, everything shipped in the executables will be loaded in memory on startup. There are some limitations around some aspects of Java applications that are not fully supported. On top of those differences, Spring uses a process called Spring Ahead-of-Time processing(#packaging.native-image.introducing-graalvm-native-images.understanding-aot-processing) , which imposes further limitations. Please make sure to read at least the beginning of the next section to learn about those. The Native Image Compatibility Guide(https://www.graalvm.org/22.3/reference-manual/native-image/metadata/Compatibility/) section of the GraalVM reference documentation provides more details about GraalVM limitations. Understanding Spring Ahead-of-Time Processing: Typical Spring Boot applications are quite dynamic and configuration is performed at runtime. In fact, the concept of Spring Boot auto-configuration depends heavily on reacting to the state of the runtime in order to configure things correctly. Although it would be possible to tell GraalVM about these dynamic aspects of the application, doing so would undo most of the benefit of static analysis. So instead, when using Spring Boot to create native images, a closed-world is assumed and the dynamic aspects of the application are restricted. A closed-world assumption implies, besides the limitations created by GraalVM itself(#packaging.native-image.introducing-graalvm-native-images.key-differences-with-jvm-deployments) , the following restrictions: The beans defined in your application cannot change at runtime, meaning: The Spring @Profile annotation and profile-specific configuration have limitations(../../../how-to/aot.html#howto.aot.conditions) . Properties that change if a bean is created are not supported (for example, @ConditionalOnProperty and .enable properties). When these restrictions are in place, it becomes possible for Spring to perform ahead-of-time processing during build-time and generate additional assets that GraalVM can use. A Spring AOT processed application will typically generate: Java source code Bytecode (for dynamic proxies etc) GraalVM JSON hint files: Resource hints ( resource-config.json ) Reflection hints ( reflect-config.json ) Serialization hints ( serialization-config.json ) Java Proxy Hints ( proxy-config.json ) JNI Hints ( jni-config.json ) Source Code Generation: Spring applications are composed of Spring Beans. Internally, Spring Framework uses two distinct concepts to manage beans. There are bean instances, which are the actual instances that have been created and can be injected into other beans. There are also bean definitions which are used to define attributes of a bean and how its instance should be created. If we take a typical @Configuration class: import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyConfiguration { @Bean public MyBean myBean() { return new MyBean(); } } The bean definition is created by parsing the @Configuration class and finding the @Bean methods. In the above example, we’re defining a BeanDefinition for a singleton bean named myBean . We’re also creating a BeanDefinition for the MyConfiguration class itself. When the myBean instance is required, Spring knows that it must invoke the myBean() method and use the result. When running on the JVM, @Configuration class parsing happens when your application starts and @Bean methods are invoked using reflection. When creating a native image, Spring operates in a different way. Rather than parsing @Configuration classes and generating bean definitions at runtime, it does it at build-time. Once the bean definitions have been discovered, they are processed and converted into source code that can be analyzed by the GraalVM compiler. The Spring AOT process would convert the configuration class above to code like this: import org.springframework.beans.factory.aot.BeanInstanceSupplier; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.support.RootBeanDefinition; /** * Bean definitions for {@link MyConfiguration}. */ public class MyConfiguration__BeanDefinitions { /** * Get the bean definition for 'myConfiguration'. */ public static BeanDefinition getMyConfigurationBeanDefinition() { Class<?> beanType = MyConfiguration.class; RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType); beanDefinition.setInstanceSupplier(MyConfiguration::new); return beanDefinition; } /** * Get the bean instance supplier for 'myBean'. */ private static BeanInstanceSupplier<MyBean> getMyBeanInstanceSupplier() { return BeanInstanceSupplier.<MyBean>forFactoryMethod(MyConfiguration.class, ""myBean"") .withGenerator((registeredBean) -> registeredBean.getBeanFactory().getBean(MyConfiguration.class).myBean()); } /** * Get the bean definition for 'myBean'. */ public static BeanDefinition getMyBeanBeanDefinition() { Class<?> beanType = MyBean.class; RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType); beanDefinition.setInstanceSupplier(getMyBeanInstanceSupplier()); return beanDefinition; } } The exact code generated may differ depending on the nature of your bean definitions. You can see above that the generated code creates equivalent bean definitions to the @Configuration class, but in a direct way that can be understood by GraalVM. There is a bean definition for the myConfiguration bean, and one for myBean . When a myBean instance is required, a BeanInstanceSupplier is called. This supplier will invoke the myBean() method on the myConfiguration bean. During Spring AOT processing, your application is started up to the point that bean definitions are available. Bean instances are not created during the AOT processing phase. Spring AOT will generate code like this for all your bean definitions. It will also generate code when bean post-processing is required (for example, to call @Autowired methods). An ApplicationContextInitializer will also be generated which will be used by Spring Boot to initialize the ApplicationContext when an AOT processed application is actually run. Although AOT generated source code can be verbose, it is quite readable and can be helpful when debugging an application. Generated source files can be found in target/spring-aot/main/sources when using Maven and build/generated/aotSources with Gradle. Hint File Generation: In addition to generating source files, the Spring AOT engine will also generate hint files that are used by GraalVM. Hint files contain JSON data that describes how GraalVM should deal with things that it can’t understand by directly inspecting the code. For example, you might be using a Spring annotation on a private method. Spring will need to use reflection in order to invoke private methods, even on GraalVM. When such situations arise, Spring can write a reflection hint so that GraalVM knows that even though the private method isn’t called directly, it still needs to be available in the native image. Hint files are generated under META-INF/native-image where they are automatically picked up by GraalVM. Generated hint files can be found in target/spring-aot/main/resources when using Maven and build/generated/aotResources with Gradle. Proxy Class Generation: Spring sometimes needs to generate proxy classes to enhance the code you’ve written with additional features. To do this, it uses the cglib library which directly generates bytecode. When an application is running on the JVM, proxy classes are generated dynamically as the application runs. When creating a native image, these proxies need to be created at build-time so that they can be included by GraalVM. Unlike source code generation, generated bytecode isn’t particularly helpful when debugging an application. However, if you need to inspect the contents of the .class files using a tool such as javap you can find them in target/spring-aot/main/classes for Maven and build/generated/aotClasses for Gradle."
"https://docs.spring.io/spring-boot/reference/packaging/native-image/advanced-topics.html","Advanced Native Images Topics: Nested Configuration Properties: Reflection hints are automatically created for configuration properties by the Spring ahead-of-time engine. Nested configuration properties which are not inner classes, however, must be annotated with @NestedConfigurationProperty , otherwise they won’t be detected and will not be bindable. import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.context.properties.NestedConfigurationProperty; @ConfigurationProperties(prefix = ""my.properties"") public class MyProperties { private String name; @NestedConfigurationProperty private final Nested nested = new Nested(); // getters / setters... public String getName() { return this.name; } public void setName(String name) { this.name = name; } public Nested getNested() { return this.nested; } } where Nested is: public class Nested { private int number; // getters / setters... public int getNumber() { return this.number; } public void setNumber(int number) { this.number = number; } } The example above produces configuration properties for my.properties.name and my.properties.nested.number . Without the @NestedConfigurationProperty annotation on the nested field, the my.properties.nested.number property would not be bindable in a native image. When using constructor binding, you have to annotate the field with @NestedConfigurationProperty : import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.context.properties.NestedConfigurationProperty; @ConfigurationProperties(prefix = ""my.properties"") public class MyPropertiesCtor { private final String name; @NestedConfigurationProperty private final Nested nested; public MyPropertiesCtor(String name, Nested nested) { this.name = name; this.nested = nested; } // getters / setters... public String getName() { return this.name; } public Nested getNested() { return this.nested; } } When using records, you have to annotate the parameter with @NestedConfigurationProperty : import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.context.properties.NestedConfigurationProperty; @ConfigurationProperties(prefix = ""my.properties"") public record MyPropertiesRecord(String name, @NestedConfigurationProperty Nested nested) { } When using Kotlin, you need to annotate the parameter of a data class with @NestedConfigurationProperty : import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.boot.context.properties.NestedConfigurationProperty @ConfigurationProperties(prefix = ""my.properties"") data class MyPropertiesKotlin( val name: String, @NestedConfigurationProperty val nested: Nested ) Please use public getters and setters in all cases, otherwise the properties will not be bindable. Converting a Spring Boot Executable Jar: It is possible to convert a Spring Boot executable jar(../../../specification/executable-jar/index.html) into a native image as long as the jar contains the AOT generated assets. This can be useful for a number of reasons, including: You can keep your regular JVM pipeline and turn the JVM application into a native image on your CI/CD platform. As native-image does not support cross-compilation(https://github.com/oracle/graal/issues/407) , you can keep an OS neutral deployment artifact which you convert later to different OS architectures. You can convert a Spring Boot executable jar into a native image using Cloud Native Buildpacks, or using the native-image tool that is shipped with GraalVM. Your executable jar must include AOT generated assets such as generated classes and JSON hint files. Using Buildpacks: Spring Boot applications usually use Cloud Native Buildpacks through the Maven ( mvn spring-boot:build-image ) or Gradle ( gradle bootBuildImage ) integrations. You can, however, also use pack(https://buildpacks.io//docs/tools/pack/) to turn an AOT processed Spring Boot executable jar into a native container image. First, make sure that a Docker daemon is available (see Get Docker(https://docs.docker.com/installation/#installation) for more details). Configure it to allow non-root user(https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user) if you are on Linux. You also need to install pack by following the installation guide on buildpacks.io(https://buildpacks.io//docs/tools/pack/#install) . Assuming an AOT processed Spring Boot executable jar built as myproject-0.0.1-SNAPSHOT.jar is in the target directory, run: $ pack build --builder paketobuildpacks/builder-jammy-tiny \ --path target/myproject-0.0.1-SNAPSHOT.jar \ --env 'BP_NATIVE_IMAGE=true' \ my-application:0.0.1-SNAPSHOT You do not need to have a local GraalVM installation to generate an image in this way. Once pack has finished, you can launch the application using docker run : $ docker run --rm -p 8080:8080 docker.io/library/myproject:0.0.1-SNAPSHOT Using GraalVM native-image: Another option to turn an AOT processed Spring Boot executable jar into a native executable is to use the GraalVM native-image tool. For this to work, you’ll need a GraalVM distribution on your machine. You can either download it manually on the Liberica Native Image Kit page(https://bell-sw.com/pages/downloads/native-image-kit/#/nik-22-17) or you can use a download manager like SDKMAN!. Assuming an AOT processed Spring Boot executable jar built as myproject-0.0.1-SNAPSHOT.jar is in the target directory, run: $ rm -rf target/native $ mkdir -p target/native $ cd target/native $ jar -xvf ../myproject-0.0.1-SNAPSHOT.jar $ native-image -H:Name=myproject @META-INF/native-image/argfile -cp .:BOOT-INF/classes:`find BOOT-INF/lib | tr '\n' ':'` $ mv myproject ../ These commands work on Linux or macOS machines, but you will need to adapt them for Windows. The @META-INF/native-image/argfile might not be packaged in your jar. It is only included when reachability metadata overrides are needed. The native-image -cp flag does not accept wildcards. You need to ensure that all jars are listed (the command above uses find and tr to do this). Using the Tracing Agent: The GraalVM native image tracing agent(https://www.graalvm.org/22.3/reference-manual/native-image/metadata/AutomaticMetadataCollection) allows you to intercept reflection, resources or proxy usage on the JVM in order to generate the related hints. Spring should generate most of these hints automatically, but the tracing agent can be used to quickly identify the missing entries. When using the agent to generate hints for a native image, there are a couple of approaches: Launch the application directly and exercise it. Run application tests to exercise the application. The first option is interesting for identifying the missing hints when a library or a pattern is not recognized by Spring. The second option sounds more appealing for a repeatable setup, but by default the generated hints will include anything required by the test infrastructure. Some of these will be unnecessary when the application runs for real. To address this problem the agent supports an access-filter file that will cause certain data to be excluded from the generated output. Launch the Application Directly: Use the following command to launch the application with the native image tracing agent attached: $ java -Dspring.aot.enabled=true \ -agentlib:native-image-agent=config-output-dir=/path/to/config-dir/ \ -jar target/myproject-0.0.1-SNAPSHOT.jar Now you can exercise the code paths you want to have hints for and then stop the application with ctrl-c . On application shutdown the native image tracing agent will write the hint files to the given config output directory. You can either manually inspect these files, or use them as input to the native image build process. To use them as input, copy them into the src/main/resources/META-INF/native-image/ directory. The next time you build the native image, GraalVM will take these files into consideration. There are more advanced options which can be set on the native image tracing agent, for example filtering the recorded hints by caller classes, etc. For further reading, please see the official documentation(https://www.graalvm.org/22.3/reference-manual/native-image/metadata/AutomaticMetadataCollection) . Custom Hints: If you need to provide your own hints for reflection, resources, serialization, proxy usage etc. you can use the RuntimeHintsRegistrar API. Create a class that implements the RuntimeHintsRegistrar interface, and then make appropriate calls to the provided RuntimeHints instance: import java.lang.reflect.Method; import org.springframework.aot.hint.ExecutableMode; import org.springframework.aot.hint.RuntimeHints; import org.springframework.aot.hint.RuntimeHintsRegistrar; import org.springframework.util.ReflectionUtils; public class MyRuntimeHints implements RuntimeHintsRegistrar { @Override public void registerHints(RuntimeHints hints, ClassLoader classLoader) { // Register method for reflection Method method = ReflectionUtils.findMethod(MyClass.class, ""sayHello"", String.class); hints.reflection().registerMethod(method, ExecutableMode.INVOKE); // Register resources hints.resources().registerPattern(""my-resource.txt""); // Register serialization hints.serialization().registerType(MySerializableClass.class); // Register proxy hints.proxies().registerJdkProxy(MyInterface.class); } } You can then use @ImportRuntimeHints on any @Configuration class (for example your @SpringBootApplication annotated application class) to activate those hints. If you have classes which need binding (mostly needed when serializing or deserializing JSON), you can use @RegisterReflectionForBinding(https://docs.spring.io/spring-framework/reference/6.1/core/aot.html#aot.hints.register-reflection-for-binding) on any bean. Most of the hints are automatically inferred, for example when accepting or returning data from a @RestController method. But when you work with WebClient , RestClient or RestTemplate directly, you might need to use @RegisterReflectionForBinding . Testing Custom Hints: The RuntimeHintsPredicates API can be used to test your hints. The API provides methods that build a Predicate that can be used to test a RuntimeHints instance. If you’re using AssertJ, your test would look like this: import org.junit.jupiter.api.Test; import org.springframework.aot.hint.RuntimeHints; import org.springframework.aot.hint.predicate.RuntimeHintsPredicates; import org.springframework.boot.docs.packaging.nativeimage.advanced.customhints.MyRuntimeHints; import static org.assertj.core.api.Assertions.assertThat; class MyRuntimeHintsTests { @Test void shouldRegisterHints() { RuntimeHints hints = new RuntimeHints(); new MyRuntimeHints().registerHints(hints, getClass().getClassLoader()); assertThat(RuntimeHintsPredicates.resource().forResource(""my-resource.txt"")).accepts(hints); } } Known Limitations: GraalVM native images are an evolving technology and not all libraries provide support. The GraalVM community is helping by providing reachability metadata(https://github.com/oracle/graalvm-reachability-metadata) for projects that don’t yet ship their own. Spring itself doesn’t contain hints for 3rd party libraries and instead relies on the reachability metadata project. If you encounter problems when generating native images for Spring Boot applications, please check the Spring Boot with GraalVM(https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-with-GraalVM) page of the Spring Boot wiki. You can also contribute issues to the spring-aot-smoke-tests(https://github.com/spring-projects/spring-aot-smoke-tests) project on GitHub which is used to confirm that common application types are working as expected. If you find a library which doesn’t work with GraalVM, please raise an issue on the reachability metadata project(https://github.com/oracle/graalvm-reachability-metadata) ."
"https://docs.spring.io/spring-boot/reference/packaging/checkpoint-restore.html","Checkpoint and Restore With the JVM: Coordinated Restore at Checkpoint(https://wiki.openjdk.org/display/crac/Main) (CRaC) is an OpenJDK project that defines a new Java API to allow you to checkpoint and restore an application on the HotSpot JVM. It is based on CRIU(https://github.com/checkpoint-restore/criu) , a project that implements checkpoint/restore functionality on Linux. The principle is the following: you start your application almost as usual but with a CRaC enabled version of the JDK like BellSoft Liberica JDK with CRaC(https://bell-sw.com/pages/downloads/?package=jdk-crac) or Azul Zulu JDK with CRaC(https://www.azul.com/downloads/?package=jdk-crac#zulu) . Then at some point, potentially after some workloads that will warm up your JVM by executing all common code paths, you trigger a checkpoint using an API call, a jcmd command, an HTTP endpoint, or a different mechanism. A memory representation of the running JVM, including its warmness, is then serialized to disk, allowing a fast restoration at a later point, potentially on another machine with a similar operating system and CPU architecture. The restored process retains all the capabilities of the HotSpot JVM, including further JIT optimizations at runtime. Based on the foundations provided by Spring Framework, Spring Boot provides support for checkpointing and restoring your application, and manages out-of-the-box the lifecycle of resources such as socket, files and thread pools on a limited scope(https://github.com/spring-projects/spring-lifecycle-smoke-tests/blob/main/STATUS.adoc) . Additional lifecycle management is expected for other dependencies and potentially for the application code dealing with such resources. You can find more details about the two modes supported (""on demand checkpoint/restore of a running application"" and ""automatic checkpoint/restore at startup""), how to enable checkpoint and restore support and some guidelines in the Spring Framework JVM Checkpoint Restore support documentation(https://docs.spring.io/spring-framework/reference/6.1/integration/checkpoint-restore.html) ."
"https://docs.spring.io/spring-boot/reference/packaging/container-images/index.html","Container Images: Spring Boot applications can be containerized using Dockerfiles(dockerfiles.html) , or by using Cloud Native Buildpacks(cloud-native-buildpacks.html) to create optimized docker compatible container images that you can run anywhere."
"https://docs.spring.io/spring-boot/reference/packaging/container-images/efficient-images.html","Efficient Container Images: It is easily possible to package a Spring Boot uber jar as a Docker image. However, there are various downsides to copying and running the uber jar as-is in the Docker image. There’s always a certain amount of overhead when running an uber jar without unpacking it, and in a containerized environment this can be noticeable. The other issue is that putting your application’s code and all its dependencies in one layer in the Docker image is not optimal. Since you probably recompile your code more often than you upgrade the version of Spring Boot you use, it’s often better to separate things a bit more. If you put jar files in the layer before your application classes, Docker often only needs to change the very bottom layer and can pick others up from its cache. Layering Docker Images: To make it easier to create optimized Docker images, Spring Boot supports adding a layer index file to the jar. It provides a list of layers and the parts of the jar that should be contained within them. The list of layers in the index is ordered based on the order in which the layers should be added to the Docker/OCI image. Out-of-the-box, the following layers are supported: dependencies (for regular released dependencies) spring-boot-loader (for everything under org/springframework/boot/loader ) snapshot-dependencies (for snapshot dependencies) application (for application classes and resources) The following shows an example of a layers.idx file: - ""dependencies"": - BOOT-INF/lib/library1.jar - BOOT-INF/lib/library2.jar - ""spring-boot-loader"": - org/springframework/boot/loader/launch/JarLauncher.class - ... <other classes> - ""snapshot-dependencies"": - BOOT-INF/lib/library3-SNAPSHOT.jar - ""application"": - META-INF/MANIFEST.MF - BOOT-INF/classes/a/b/C.class This layering is designed to separate code based on how likely it is to change between application builds. Library code is less likely to change between builds, so it is placed in its own layers to allow tooling to re-use the layers from cache. Application code is more likely to change between builds so it is isolated in a separate layer. Spring Boot also supports layering for war files with the help of a layers.idx . For Maven, see the packaging layered jar or war section(../../../maven-plugin/packaging.html#packaging.layers) for more details on adding a layer index to the archive. For Gradle, see the packaging layered jar or war section(../../../gradle-plugin/packaging.html#packaging-executable.configuring.layered-archives) of the Gradle plugin documentation."
"https://docs.spring.io/spring-boot/reference/packaging/container-images/dockerfiles.html","Dockerfiles: While it is possible to convert a Spring Boot uber jar into a Docker image with just a few lines in the Dockerfile , using the layering feature(efficient-images.html#packaging.container-images.efficient-images.layering) will result in an optimized image. When you create a jar containing the layers index file, the spring-boot-jarmode-tools jar will be added as a dependency to your jar. With this jar on the classpath, you can launch your application in a special mode which allows the bootstrap code to run something entirely different from your application, for example, something that extracts the layers. The tools mode can not be used with a fully executable Spring Boot archive(../../../how-to/deployment/installing.html) that includes a launch script. Disable launch script configuration when building a jar file that is intended to be used with layertools . Here’s how you can launch your jar with a tools jar mode: $ java -Djarmode=tools -jar my-app.jar This will provide the following output: Usage: java -Djarmode=tools -jar my-app.jar Available commands: extract Extract the contents from the jar list-layers List layers from the jar that can be extracted help Help about any command The extract command can be used to easily split the application into layers to be added to the Dockerfile . Here is an example of a Dockerfile using jarmode . # Perform the extraction in a separate builder container FROM bellsoft/liberica-openjre-debian:17-cds AS builder WORKDIR /builder # This points to the built jar file in the target folder # Adjust this to 'build/libs/*.jar' if you're using Gradle ARG JAR_FILE=target/*.jar # Copy the jar file to the working directory and rename it to application.jar COPY ${JAR_FILE} application.jar # Extract the jar file using an efficient layout RUN java -Djarmode=tools -jar application.jar extract --layers --destination extracted # This is the runtime container FROM bellsoft/liberica-openjre-debian:17-cds WORKDIR /application # Copy the extracted jar contents from the builder container into the working directory in the runtime container # Every copy step creates a new docker layer # This allows docker to only pull the changes it really needs COPY --from=builder /builder/extracted/dependencies/ ./ COPY --from=builder /builder/extracted/spring-boot-loader/ ./ COPY --from=builder /builder/extracted/snapshot-dependencies/ ./ COPY --from=builder /builder/extracted/application/ ./ # Start the application jar - this is not the uber jar used by the builder # This jar only contains application code and references to the extracted jar files # This layout is efficient to start up and CDS friendly ENTRYPOINT [""java"", ""-jar"", ""application.jar""] Assuming the above Dockerfile is in the current directory, your Docker image can be built with docker build . , or optionally specifying the path to your application jar, as shown in the following example: $ docker build --build-arg JAR_FILE=path/to/myapp.jar . This is a multi-stage Dockerfile . The builder stage extracts the directories that are needed later. Each of the COPY commands relates to the layers extracted by the jarmode. Of course, a Dockerfile can be written without using the jarmode . You can use some combination of unzip and mv to move things to the right layer but jarmode simplifies that. Additionally, the layout created by the jarmode is CDS friendly out of the box. CDS: If you want to additionally enable CDS(../class-data-sharing.html) , you can use this Dockerfile : # Perform the extraction in a separate builder container FROM bellsoft/liberica-openjre-debian:17-cds AS builder WORKDIR /builder # This points to the built jar file in the target folder # Adjust this to 'build/libs/*.jar' if you're using Gradle ARG JAR_FILE=target/*.jar # Copy the jar file to the working directory and rename it to application.jar COPY ${JAR_FILE} application.jar # Extract the jar file using an efficient layout RUN java -Djarmode=tools -jar application.jar extract --layers --destination extracted # This is the runtime container FROM bellsoft/liberica-openjre-debian:17-cds WORKDIR /application # Copy the extracted jar contents from the builder container into the working directory in the runtime container # Every copy step creates a new docker layer # This allows docker to only pull the changes it really needs COPY --from=builder /builder/extracted/dependencies/ ./ COPY --from=builder /builder/extracted/spring-boot-loader/ ./ COPY --from=builder /builder/extracted/snapshot-dependencies/ ./ COPY --from=builder /builder/extracted/application/ ./ # Execute the CDS training run RUN java -XX:ArchiveClassesAtExit=application.jsa -Dspring.context.exit=onRefresh -jar application.jar # Start the application jar with CDS enabled - this is not the uber jar used by the builder # This jar only contains application code and references to the extracted jar files # This layout is efficient to start up and CDS friendly ENTRYPOINT [""java"", ""-XX:SharedArchiveFile=application.jsa"", ""-jar"", ""application.jar""] This is mostly the same as the above Dockerfile . As the last steps, it creates the CDS archive by doing a training run and passes the CDS parameter to java -jar ."
"https://docs.spring.io/spring-boot/reference/packaging/container-images/cloud-native-buildpacks.html","Cloud Native Buildpacks: Docker images can be built directly from your Maven or Gradle plugin using Cloud Native Buildpacks(https://buildpacks.io) . If you’ve ever used an application platform such as Cloud Foundry or Heroku then you’ve probably used a buildpack. Buildpacks are the part of the platform that takes your application and converts it into something that the platform can actually run. For example, Cloud Foundry’s Java buildpack will notice that you’re pushing a .jar file and automatically add a relevant JRE. With Cloud Native Buildpacks, you can create Docker compatible images that you can run anywhere. Spring Boot includes buildpack support directly for both Maven and Gradle. This means you can just type a single command and quickly get a sensible image into your locally running Docker daemon. See the individual plugin documentation on how to use buildpacks with Maven(../../../maven-plugin/build-image.html#build-image) and Gradle(../../../gradle-plugin/packaging-oci-image.html) . The Paketo Spring Boot buildpack(https://github.com/paketo-buildpacks/spring-boot) supports the layers.idx file, so any layer customization(efficient-images.html#packaging.container-images.efficient-images.layering) that is applied to it will be reflected in the image created by the buildpacks. In order to achieve reproducible builds and container image caching, buildpacks can manipulate the application resources metadata (such as the file ""last modified"" information). You should ensure that your application does not rely on that metadata at runtime. Spring Boot can use that information when serving static resources, but this can be disabled with spring.web.resources.cache.use-last-modified ."
"https://docs.spring.io/spring-boot/reference/actuator/index.html","Production-ready Features: Spring Boot includes a number of additional features to help you monitor and manage your application when you push it to production. You can choose to manage and monitor your application by using HTTP endpoints or with JMX. Auditing, health, and metrics gathering can also be automatically applied to your application."
"https://docs.spring.io/spring-boot/reference/actuator/enabling.html","Enabling Production-ready Features: The spring-boot-actuator(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator) module provides all of Spring Boot’s production-ready features. The recommended way to enable the features is to add a dependency on the spring-boot-starter-actuator starter. Definition of Actuator An actuator is a manufacturing term that refers to a mechanical device for moving or controlling something. Actuators can generate a large amount of motion from a small change. To add the actuator to a Maven-based project, add the following starter dependency: <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> </dependencies> For Gradle, use the following declaration: dependencies { implementation 'org.springframework.boot:spring-boot-starter-actuator' }"
"https://docs.spring.io/spring-boot/reference/actuator/endpoints.html","Endpoints: Actuator endpoints let you monitor and interact with your application. Spring Boot includes a number of built-in endpoints and lets you add your own. For example, the health endpoint provides basic application health information. You can enable or disable(#actuator.endpoints.enabling) each individual endpoint and expose them (make them remotely accessible) over HTTP or JMX(#actuator.endpoints.exposing) . An endpoint is considered to be available when it is both enabled and exposed. The built-in endpoints are auto-configured only when they are available. Most applications choose exposure over HTTP, where the ID of the endpoint and a prefix of /actuator is mapped to a URL. For example, by default, the health endpoint is mapped to /actuator/health . To learn more about the Actuator’s endpoints and their request and response formats, see the API documentation(../../api/rest/actuator/index.html) . The following technology-agnostic endpoints are available: ID Description auditevents Exposes audit events information for the current application. Requires an AuditEventRepository bean. beans Displays a complete list of all the Spring beans in your application. caches Exposes available caches. conditions Shows the conditions that were evaluated on configuration and auto-configuration classes and the reasons why they did or did not match. configprops Displays a collated list of all @ConfigurationProperties . Subject to sanitization(#actuator.endpoints.sanitization) . env Exposes properties from Spring’s ConfigurableEnvironment . Subject to sanitization(#actuator.endpoints.sanitization) . flyway Shows any Flyway database migrations that have been applied. Requires one or more Flyway beans. health Shows application health information. httpexchanges Displays HTTP exchange information (by default, the last 100 HTTP request-response exchanges). Requires an HttpExchangeRepository bean. info Displays arbitrary application info. integrationgraph Shows the Spring Integration graph. Requires a dependency on spring-integration-core . loggers Shows and modifies the configuration of loggers in the application. liquibase Shows any Liquibase database migrations that have been applied. Requires one or more Liquibase beans. metrics Shows “metrics” information for the current application. mappings Displays a collated list of all @RequestMapping paths. quartz Shows information about Quartz Scheduler jobs. Subject to sanitization(#actuator.endpoints.sanitization) . scheduledtasks Displays the scheduled tasks in your application. sessions Allows retrieval and deletion of user sessions from a Spring Session-backed session store. Requires a servlet-based web application that uses Spring Session. shutdown Lets the application be gracefully shutdown. Only works when using jar packaging. Disabled by default. startup Shows the startup steps data(../features/spring-application.html#features.spring-application.startup-tracking) collected by the ApplicationStartup . Requires the SpringApplication to be configured with a BufferingApplicationStartup . threaddump Performs a thread dump. If your application is a web application (Spring MVC, Spring WebFlux, or Jersey), you can use the following additional endpoints: ID Description heapdump Returns a heap dump file. On a HotSpot JVM, an HPROF -format file is returned. On an OpenJ9 JVM, a PHD -format file is returned. logfile Returns the contents of the logfile (if the logging.file.name or the logging.file.path property has been set). Supports the use of the HTTP Range header to retrieve part of the log file’s content. prometheus Exposes metrics in a format that can be scraped by a Prometheus server. Requires a dependency on micrometer-registry-prometheus . Enabling Endpoints: By default, all endpoints except for shutdown are enabled. To configure the enablement of an endpoint, use its management.endpoint.<id>.enabled property. The following example enables the shutdown endpoint: Properties YAML management.endpoint.shutdown.enabled=true management: endpoint: shutdown: enabled: true If you prefer endpoint enablement to be opt-in rather than opt-out, set the management.endpoints.enabled-by-default property to false and use individual endpoint enabled properties to opt back in. The following example enables the info endpoint and disables all other endpoints: Properties YAML management.endpoints.enabled-by-default=false management.endpoint.info.enabled=true management: endpoints: enabled-by-default: false endpoint: info: enabled: true Disabled endpoints are removed entirely from the application context. If you want to change only the technologies over which an endpoint is exposed, use the include and exclude properties(#actuator.endpoints.exposing) instead. Exposing Endpoints: By default, only the health endpoint is exposed over HTTP and JMX. Since Endpoints may contain sensitive information, you should carefully consider when to expose them. To change which endpoints are exposed, use the following technology-specific include and exclude properties: Property Default management.endpoints.jmx.exposure.exclude management.endpoints.jmx.exposure.include health management.endpoints.web.exposure.exclude management.endpoints.web.exposure.include health The include property lists the IDs of the endpoints that are exposed. The exclude property lists the IDs of the endpoints that should not be exposed. The exclude property takes precedence over the include property. You can configure both the include and the exclude properties with a list of endpoint IDs. For example, to only expose the health and info endpoints over JMX, use the following property: Properties YAML management.endpoints.jmx.exposure.include=health,info management: endpoints: jmx: exposure: include: ""health,info"" * can be used to select all endpoints. For example, to expose everything over HTTP except the env and beans endpoints, use the following properties: Properties YAML management.endpoints.web.exposure.include=* management.endpoints.web.exposure.exclude=env,beans management: endpoints: web: exposure: include: ""*"" exclude: ""env,beans"" * has a special meaning in YAML, so be sure to add quotation marks if you want to include (or exclude) all endpoints. If your application is exposed publicly, we strongly recommend that you also secure your endpoints(#actuator.endpoints.security) . If you want to implement your own strategy for when endpoints are exposed, you can register an EndpointFilter bean. Security: For security purposes, only the /health endpoint is exposed over HTTP by default. You can use the management.endpoints.web.exposure.include property to configure the endpoints that are exposed. Before setting the management.endpoints.web.exposure.include , ensure that the exposed actuators do not contain sensitive information, are secured by placing them behind a firewall, or are secured by something like Spring Security. If Spring Security is on the classpath and no other SecurityFilterChain bean is present, all actuators other than /health are secured by Spring Boot auto-configuration. If you define a custom SecurityFilterChain bean, Spring Boot auto-configuration backs off and lets you fully control the actuator access rules. If you wish to configure custom security for HTTP endpoints (for example, to allow only users with a certain role to access them), Spring Boot provides some convenient RequestMatcher objects that you can use in combination with Spring Security. A typical Spring Security configuration might look something like the following example: Java Kotlin import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.web.SecurityFilterChain; import static org.springframework.security.config.Customizer.withDefaults; @Configuration(proxyBeanMethods = false) public class MySecurityConfiguration { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.securityMatcher(EndpointRequest.toAnyEndpoint()); http.authorizeHttpRequests((requests) -> requests.anyRequest().hasRole(""ENDPOINT_ADMIN"")); http.httpBasic(withDefaults()); return http.build(); } } import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.security.config.Customizer.withDefaults import org.springframework.security.config.annotation.web.builders.HttpSecurity import org.springframework.security.web.SecurityFilterChain @Configuration(proxyBeanMethods = false) class MySecurityConfiguration { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http.securityMatcher(EndpointRequest.toAnyEndpoint()).authorizeHttpRequests { requests -> requests.anyRequest().hasRole(""ENDPOINT_ADMIN"") } http.httpBasic(withDefaults()) return http.build() } } The preceding example uses EndpointRequest.toAnyEndpoint() to match a request to any endpoint and then ensures that all have the ENDPOINT_ADMIN role. Several other matcher methods are also available on EndpointRequest . See the API documentation(../../api/rest/actuator/index.html) for details. If you deploy applications behind a firewall, you may prefer that all your actuator endpoints can be accessed without requiring authentication. You can do so by changing the management.endpoints.web.exposure.include property, as follows: Properties YAML management.endpoints.web.exposure.include=* management: endpoints: web: exposure: include: ""*"" Additionally, if Spring Security is present, you would need to add custom security configuration that allows unauthenticated access to the endpoints, as the following example shows: Java Kotlin import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.web.SecurityFilterChain; @Configuration(proxyBeanMethods = false) public class MySecurityConfiguration { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.securityMatcher(EndpointRequest.toAnyEndpoint()); http.authorizeHttpRequests((requests) -> requests.anyRequest().permitAll()); return http.build(); } } import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.security.config.annotation.web.builders.HttpSecurity import org.springframework.security.web.SecurityFilterChain @Configuration(proxyBeanMethods = false) class MySecurityConfiguration { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { http.securityMatcher(EndpointRequest.toAnyEndpoint()).authorizeHttpRequests { requests -> requests.anyRequest().permitAll() } return http.build() } } In both of the preceding examples, the configuration applies only to the actuator endpoints. Since Spring Boot’s security configuration backs off completely in the presence of any SecurityFilterChain bean, you need to configure an additional SecurityFilterChain bean with rules that apply to the rest of the application. Cross Site Request Forgery Protection: Since Spring Boot relies on Spring Security’s defaults, CSRF protection is turned on by default. This means that the actuator endpoints that require a POST (shutdown and loggers endpoints), a PUT , or a DELETE get a 403 (forbidden) error when the default security configuration is in use. We recommend disabling CSRF protection completely only if you are creating a service that is used by non-browser clients. You can find additional information about CSRF protection in the Spring Security Reference Guide(https://docs.spring.io/spring-security/reference/6.3/features/exploits/csrf.html) . Configuring Endpoints: Endpoints automatically cache responses to read operations that do not take any parameters. To configure the amount of time for which an endpoint caches a response, use its cache.time-to-live property. The following example sets the time-to-live of the beans endpoint’s cache to 10 seconds: Properties YAML management.endpoint.beans.cache.time-to-live=10s management: endpoint: beans: cache: time-to-live: ""10s"" The management.endpoint.<name> prefix uniquely identifies the endpoint that is being configured. Sanitize Sensitive Values: Information returned by the /env , /configprops and /quartz endpoints can be sensitive, so by default values are always fully sanitized (replaced by ****** ). Values can only be viewed in an unsanitized form when: The show-values property has been set to something other than NEVER No custom SanitizingFunction(../../how-to/actuator.html#howto.actuator.customizing-sanitization) beans apply The show-values property can be configured for sanitizable endpoints to one of the following values: NEVER - values are always fully sanitized (replaced by ****** ) ALWAYS - values are shown to all users (as long as no SanitizingFunction bean applies) WHEN_AUTHORIZED - values are shown only to authorized users (as long as no SanitizingFunction bean applies) For HTTP endpoints, a user is considered to be authorized if they have authenticated and have the roles configured by the endpoint’s roles property. By default, any authenticated user is authorized. For JMX endpoints, all users are always authorized. The following example allows all users with the admin role to view values from the /env endpoint in their original form. Unauthorized users, or users without the admin role, will see only sanitized values. Properties YAML management.endpoint.env.show-values=WHEN_AUTHORIZED management.endpoint.env.roles=admin management: endpoint: env: show-values: WHEN_AUTHORIZED roles: ""admin"" This example assumes that no SanitizingFunction(../../how-to/actuator.html#howto.actuator.customizing-sanitization) beans have been defined. Hypermedia for Actuator Web Endpoints: A “discovery page” is added with links to all the endpoints. The “discovery page” is available on /actuator by default. To disable the “discovery page”, add the following property to your application properties: Properties YAML management.endpoints.web.discovery.enabled=false management: endpoints: web: discovery: enabled: false When a custom management context path is configured, the “discovery page” automatically moves from /actuator to the root of the management context. For example, if the management context path is /management , the discovery page is available from /management . When the management context path is set to / , the discovery page is disabled to prevent the possibility of a clash with other mappings. CORS Support: Cross-origin resource sharing(https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) (CORS) is a W3C specification(https://www.w3.org/TR/cors/) that lets you specify in a flexible way what kind of cross-domain requests are authorized. If you use Spring MVC or Spring WebFlux, you can configure Actuator’s web endpoints to support such scenarios. CORS support is disabled by default and is only enabled once you have set the management.endpoints.web.cors.allowed-origins property. The following configuration permits GET and POST calls from the example.com domain: Properties YAML management.endpoints.web.cors.allowed-origins=https://example.com management.endpoints.web.cors.allowed-methods=GET,POST management: endpoints: web: cors: allowed-origins: ""https://example.com"" allowed-methods: ""GET,POST"" See CorsEndpointProperties(../../api/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.html) for a complete list of options. Implementing Custom Endpoints: If you add a @Bean annotated with @Endpoint , any methods annotated with @ReadOperation , @WriteOperation , or @DeleteOperation are automatically exposed over JMX and, in a web application, over HTTP as well. Endpoints can be exposed over HTTP by using Jersey, Spring MVC, or Spring WebFlux. If both Jersey and Spring MVC are available, Spring MVC is used. The following example exposes a read operation that returns a custom object: Java Kotlin @ReadOperation public CustomData getData() { return new CustomData(""test"", 5); } @ReadOperation fun getData(): CustomData { return CustomData(""test"", 5) } You can also write technology-specific endpoints by using @JmxEndpoint or @WebEndpoint . These endpoints are restricted to their respective technologies. For example, @WebEndpoint is exposed only over HTTP and not over JMX. You can write technology-specific extensions by using @EndpointWebExtension and @EndpointJmxExtension . These annotations let you provide technology-specific operations to augment an existing endpoint. Finally, if you need access to web-framework-specific functionality, you can implement servlet or Spring @Controller and @RestController endpoints at the cost of them not being available over JMX or when using a different web framework. Receiving Input: Operations on an endpoint receive input through their parameters. When exposed over the web, the values for these parameters are taken from the URL’s query parameters and from the JSON request body. When exposed over JMX, the parameters are mapped to the parameters of the MBean’s operations. Parameters are required by default. They can be made optional by annotating them with either @javax.annotation.Nullable or @org.springframework.lang.Nullable . You can map each root property in the JSON request body to a parameter of the endpoint. Consider the following JSON request body: { ""name"": ""test"", ""counter"": 42 } You can use this to invoke a write operation that takes String name and int counter parameters, as the following example shows: Java Kotlin @WriteOperation public void updateData(String name, int counter) { // injects ""test"" and 42 } @WriteOperation fun updateData(name: String?, counter: Int) { // injects ""test"" and 42 } Because endpoints are technology agnostic, only simple types can be specified in the method signature. In particular, declaring a single parameter with a CustomData type that defines a name and counter properties is not supported. To let the input be mapped to the operation method’s parameters, Java code that implements an endpoint should be compiled with -parameters , and Kotlin code that implements an endpoint should be compiled with -java-parameters . This will happen automatically if you use Spring Boot’s Gradle plugin or if you use Maven and spring-boot-starter-parent . Input Type Conversion: The parameters passed to endpoint operation methods are, if necessary, automatically converted to the required type. Before calling an operation method, the input received over JMX or HTTP is converted to the required types by using an instance of ApplicationConversionService as well as any Converter or GenericConverter beans qualified with @EndpointConverter . Custom Web Endpoints: Operations on an @Endpoint , @WebEndpoint , or @EndpointWebExtension are automatically exposed over HTTP using Jersey, Spring MVC, or Spring WebFlux. If both Jersey and Spring MVC are available, Spring MVC is used. Web Endpoint Request Predicates: A request predicate is automatically generated for each operation on a web-exposed endpoint. Path: The path of the predicate is determined by the ID of the endpoint and the base path of the web-exposed endpoints. The default base path is /actuator . For example, an endpoint with an ID of sessions uses /actuator/sessions as its path in the predicate. You can further customize the path by annotating one or more parameters of the operation method with @Selector . Such a parameter is added to the path predicate as a path variable. The variable’s value is passed into the operation method when the endpoint operation is invoked. If you want to capture all remaining path elements, you can add @Selector(Match=ALL_REMAINING) to the last parameter and make it a type that is conversion-compatible with a String[] . HTTP method: The HTTP method of the predicate is determined by the operation type, as shown in the following table: Operation HTTP method @ReadOperation GET @WriteOperation POST @DeleteOperation DELETE Consumes: For a @WriteOperation (HTTP POST ) that uses the request body, the consumes clause of the predicate is application/vnd.spring-boot.actuator.v2+json, application/json . For all other operations, the consumes clause is empty. Produces: The produces clause of the predicate can be determined by the produces attribute of the @DeleteOperation , @ReadOperation , and @WriteOperation annotations. The attribute is optional. If it is not used, the produces clause is determined automatically. If the operation method returns void or Void , the produces clause is empty. If the operation method returns a org.springframework.core.io.Resource , the produces clause is application/octet-stream . For all other operations, the produces clause is application/vnd.spring-boot.actuator.v2+json, application/json . Web Endpoint Response Status: The default response status for an endpoint operation depends on the operation type (read, write, or delete) and what, if anything, the operation returns. If a @ReadOperation returns a value, the response status will be 200 (OK). If it does not return a value, the response status will be 404 (Not Found). If a @WriteOperation or @DeleteOperation returns a value, the response status will be 200 (OK). If it does not return a value, the response status will be 204 (No Content). If an operation is invoked without a required parameter or with a parameter that cannot be converted to the required type, the operation method is not called, and the response status will be 400 (Bad Request). Web Endpoint Range Requests: You can use an HTTP range request to request part of an HTTP resource. When using Spring MVC or Spring Web Flux, operations that return a org.springframework.core.io.Resource automatically support range requests. Range requests are not supported when using Jersey. Web Endpoint Security: An operation on a web endpoint or a web-specific endpoint extension can receive the current java.security.Principal or org.springframework.boot.actuate.endpoint.SecurityContext as a method parameter. The former is typically used in conjunction with @Nullable to provide different behavior for authenticated and unauthenticated users. The latter is typically used to perform authorization checks by using its isUserInRole(String) method. Health Information: You can use health information to check the status of your running application. It is often used by monitoring software to alert someone when a production system goes down. The information exposed by the health endpoint depends on the management.endpoint.health.show-details and management.endpoint.health.show-components properties, which can be configured with one of the following values: Name Description never Details are never shown. when-authorized Details are shown only to authorized users. Authorized roles can be configured by using management.endpoint.health.roles . always Details are shown to all users. The default value is never . A user is considered to be authorized when they are in one or more of the endpoint’s roles. If the endpoint has no configured roles (the default), all authenticated users are considered to be authorized. You can configure the roles by using the management.endpoint.health.roles property. If you have secured your application and wish to use always , your security configuration must permit access to the health endpoint for both authenticated and unauthenticated users. Health information is collected from the content of a HealthContributorRegistry(../../api/java/org/springframework/boot/actuate/health/HealthContributorRegistry.html) (by default, all HealthContributor(../../api/java/org/springframework/boot/actuate/health/HealthContributor.html) instances defined in your ApplicationContext ). Spring Boot includes a number of auto-configured HealthContributors , and you can also write your own. A HealthContributor can be either a HealthIndicator or a CompositeHealthContributor . A HealthIndicator provides actual health information, including a Status . A CompositeHealthContributor provides a composite of other HealthContributors . Taken together, contributors form a tree structure to represent the overall system health. By default, the final system health is derived by a StatusAggregator , which sorts the statuses from each HealthIndicator based on an ordered list of statuses. The first status in the sorted list is used as the overall health status. If no HealthIndicator returns a status that is known to the StatusAggregator , an UNKNOWN status is used. You can use the HealthContributorRegistry to register and unregister health indicators at runtime. Auto-configured HealthIndicators: When appropriate, Spring Boot auto-configures the HealthIndicators listed in the following table. You can also enable or disable selected indicators by configuring management.health.key.enabled , with the key listed in the following table: Key Name Description cassandra CassandraDriverHealthIndicator(../../api/java/org/springframework/boot/actuate/cassandra/CassandraDriverHealthIndicator.html) Checks that a Cassandra database is up. couchbase CouchbaseHealthIndicator(../../api/java/org/springframework/boot/actuate/couchbase/CouchbaseHealthIndicator.html) Checks that a Couchbase cluster is up. db DataSourceHealthIndicator(../../api/java/org/springframework/boot/actuate/jdbc/DataSourceHealthIndicator.html) Checks that a connection to DataSource can be obtained. diskspace DiskSpaceHealthIndicator(../../api/java/org/springframework/boot/actuate/system/DiskSpaceHealthIndicator.html) Checks for low disk space. elasticsearch ElasticsearchRestClientHealthIndicator(../../api/java/org/springframework/boot/actuate/elasticsearch/ElasticsearchRestClientHealthIndicator.html) Checks that an Elasticsearch cluster is up. hazelcast HazelcastHealthIndicator(../../api/java/org/springframework/boot/actuate/hazelcast/HazelcastHealthIndicator.html) Checks that a Hazelcast server is up. influxdb InfluxDbHealthIndicator(../../api/java/org/springframework/boot/actuate/influx/InfluxDbHealthIndicator.html) Checks that an InfluxDB server is up. jms JmsHealthIndicator(../../api/java/org/springframework/boot/actuate/jms/JmsHealthIndicator.html) Checks that a JMS broker is up. ldap LdapHealthIndicator(../../api/java/org/springframework/boot/actuate/ldap/LdapHealthIndicator.html) Checks that an LDAP server is up. mail MailHealthIndicator(../../api/java/org/springframework/boot/actuate/mail/MailHealthIndicator.html) Checks that a mail server is up. mongo MongoHealthIndicator(../../api/java/org/springframework/boot/actuate/data/mongo/MongoHealthIndicator.html) Checks that a Mongo database is up. neo4j Neo4jHealthIndicator(../../api/java/org/springframework/boot/actuate/neo4j/Neo4jHealthIndicator.html) Checks that a Neo4j database is up. ping PingHealthIndicator(../../api/java/org/springframework/boot/actuate/health/PingHealthIndicator.html) Always responds with UP . rabbit RabbitHealthIndicator(../../api/java/org/springframework/boot/actuate/amqp/RabbitHealthIndicator.html) Checks that a Rabbit server is up. redis RedisHealthIndicator(../../api/java/org/springframework/boot/actuate/data/redis/RedisHealthIndicator.html) Checks that a Redis server is up. You can disable them all by setting the management.health.defaults.enabled property. Additional HealthIndicators are available but are not enabled by default: Key Name Description livenessstate LivenessStateHealthIndicator(../../api/java/org/springframework/boot/actuate/availability/LivenessStateHealthIndicator.html) Exposes the “Liveness” application availability state. readinessstate ReadinessStateHealthIndicator(../../api/java/org/springframework/boot/actuate/availability/ReadinessStateHealthIndicator.html) Exposes the “Readiness” application availability state. Writing Custom HealthIndicators: To provide custom health information, you can register Spring beans that implement the HealthIndicator(../../api/java/org/springframework/boot/actuate/health/HealthIndicator.html) interface. You need to provide an implementation of the health() method and return a Health response. The Health response should include a status and can optionally include additional details to be displayed. The following code shows a sample HealthIndicator implementation: Java Kotlin import org.springframework.boot.actuate.health.Health; import org.springframework.boot.actuate.health.HealthIndicator; import org.springframework.stereotype.Component; @Component public class MyHealthIndicator implements HealthIndicator { @Override public Health health() { int errorCode = check(); if (errorCode != 0) { return Health.down().withDetail(""Error Code"", errorCode).build(); } return Health.up().build(); } private int check() { // perform some specific health check return ... } } import org.springframework.boot.actuate.health.Health import org.springframework.boot.actuate.health.HealthIndicator import org.springframework.stereotype.Component @Component class MyHealthIndicator : HealthIndicator { override fun health(): Health { val errorCode = check() if (errorCode != 0) { return Health.down().withDetail(""Error Code"", errorCode).build() } return Health.up().build() } private fun check(): Int { // perform some specific health check return ... } } The identifier for a given HealthIndicator is the name of the bean without the HealthIndicator suffix, if it exists. In the preceding example, the health information is available in an entry named my . Health indicators are usually called over HTTP and need to respond before any connection timeouts. Spring Boot will log a warning message for any health indicator that takes longer than 10 seconds to respond. If you want to configure this threshold, you can use the management.endpoint.health.logging.slow-indicator-threshold property. In addition to Spring Boot’s predefined Status(../../api/java/org/springframework/boot/actuate/health/Status.html) types, Health can return a custom Status that represents a new system state. In such cases, you also need to provide a custom implementation of the StatusAggregator(../../api/java/org/springframework/boot/actuate/health/StatusAggregator.html) interface, or you must configure the default implementation by using the management.endpoint.health.status.order configuration property. For example, assume a new Status with a code of FATAL is being used in one of your HealthIndicator implementations. To configure the severity order, add the following property to your application properties: Properties YAML management.endpoint.health.status.order=fatal,down,out-of-service,unknown,up management: endpoint: health: status: order: ""fatal,down,out-of-service,unknown,up"" The HTTP status code in the response reflects the overall health status. By default, OUT_OF_SERVICE and DOWN map to 503. Any unmapped health statuses, including UP , map to 200. You might also want to register custom status mappings if you access the health endpoint over HTTP. Configuring a custom mapping disables the defaults mappings for DOWN and OUT_OF_SERVICE . If you want to retain the default mappings, you must explicitly configure them, alongside any custom mappings. For example, the following property maps FATAL to 503 (service unavailable) and retains the default mappings for DOWN and OUT_OF_SERVICE : Properties YAML management.endpoint.health.status.http-mapping.down=503 management.endpoint.health.status.http-mapping.fatal=503 management.endpoint.health.status.http-mapping.out-of-service=503 management: endpoint: health: status: http-mapping: down: 503 fatal: 503 out-of-service: 503 If you need more control, you can define your own HttpCodeStatusMapper bean. The following table shows the default status mappings for the built-in statuses: Status Mapping DOWN SERVICE_UNAVAILABLE ( 503 ) OUT_OF_SERVICE SERVICE_UNAVAILABLE ( 503 ) UP No mapping by default, so HTTP status is 200 UNKNOWN No mapping by default, so HTTP status is 200 Reactive Health Indicators: For reactive applications, such as those that use Spring WebFlux, ReactiveHealthContributor provides a non-blocking contract for getting application health. Similar to a traditional HealthContributor , health information is collected from the content of a ReactiveHealthContributorRegistry(../../api/java/org/springframework/boot/actuate/health/ReactiveHealthContributorRegistry.html) (by default, all HealthContributor(../../api/java/org/springframework/boot/actuate/health/HealthContributor.html) and ReactiveHealthContributor(../../api/java/org/springframework/boot/actuate/health/ReactiveHealthContributor.html) instances defined in your ApplicationContext ). Regular HealthContributors that do not check against a reactive API are executed on the elastic scheduler. In a reactive application, you should use the ReactiveHealthContributorRegistry to register and unregister health indicators at runtime. If you need to register a regular HealthContributor , you should wrap it with ReactiveHealthContributor#adapt . To provide custom health information from a reactive API, you can register Spring beans that implement the ReactiveHealthIndicator(../../api/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.html) interface. The following code shows a sample ReactiveHealthIndicator implementation: Java Kotlin import reactor.core.publisher.Mono; import org.springframework.boot.actuate.health.Health; import org.springframework.boot.actuate.health.ReactiveHealthIndicator; import org.springframework.stereotype.Component; @Component public class MyReactiveHealthIndicator implements ReactiveHealthIndicator { @Override public Mono<Health> health() { return doHealthCheck().onErrorResume((exception) -> Mono.just(new Health.Builder().down(exception).build())); } private Mono<Health> doHealthCheck() { // perform some specific health check return ... } } import org.springframework.boot.actuate.health.Health import org.springframework.boot.actuate.health.ReactiveHealthIndicator import org.springframework.stereotype.Component import reactor.core.publisher.Mono @Component class MyReactiveHealthIndicator : ReactiveHealthIndicator { override fun health(): Mono<Health> { return doHealthCheck()!!.onErrorResume { exception: Throwable? -> Mono.just(Health.Builder().down(exception).build()) } } private fun doHealthCheck(): Mono<Health>? { // perform some specific health check return ... } } To handle the error automatically, consider extending from AbstractReactiveHealthIndicator . Auto-configured ReactiveHealthIndicators: When appropriate, Spring Boot auto-configures the following ReactiveHealthIndicators : Key Name Description cassandra CassandraDriverReactiveHealthIndicator(../../api/java/org/springframework/boot/actuate/cassandra/CassandraDriverReactiveHealthIndicator.html) Checks that a Cassandra database is up. couchbase CouchbaseReactiveHealthIndicator(../../api/java/org/springframework/boot/actuate/couchbase/CouchbaseReactiveHealthIndicator.html) Checks that a Couchbase cluster is up. elasticsearch ElasticsearchReactiveHealthIndicator(../../api/java/org/springframework/boot/actuate/data/elasticsearch/ElasticsearchReactiveHealthIndicator.html) Checks that an Elasticsearch cluster is up. mongo MongoReactiveHealthIndicator(../../api/java/org/springframework/boot/actuate/data/mongo/MongoReactiveHealthIndicator.html) Checks that a Mongo database is up. neo4j Neo4jReactiveHealthIndicator(../../api/java/org/springframework/boot/actuate/neo4j/Neo4jReactiveHealthIndicator.html) Checks that a Neo4j database is up. redis RedisReactiveHealthIndicator(../../api/java/org/springframework/boot/actuate/data/redis/RedisReactiveHealthIndicator.html) Checks that a Redis server is up. If necessary, reactive indicators replace the regular ones. Also, any HealthIndicator that is not handled explicitly is wrapped automatically. Health Groups: It is sometimes useful to organize health indicators into groups that you can use for different purposes. To create a health indicator group, you can use the management.endpoint.health.group.<name> property and specify a list of health indicator IDs to include or exclude . For example, to create a group that includes only database indicators you can define the following: Properties YAML management.endpoint.health.group.custom.include=db management: endpoint: health: group: custom: include: ""db"" You can then check the result by hitting localhost:8080/actuator/health/custom(http://localhost:8080/actuator/health/custom) . Similarly, to create a group that excludes the database indicators from the group and includes all the other indicators, you can define the following: Properties YAML management.endpoint.health.group.custom.exclude=db management: endpoint: health: group: custom: exclude: ""db"" By default, startup will fail if a health group includes or excludes a health indicator that does not exist. To disable this behavior set management.endpoint.health.validate-group-membership to false . By default, groups inherit the same StatusAggregator and HttpCodeStatusMapper settings as the system health. However, you can also define these on a per-group basis. You can also override the show-details and roles properties if required: Properties YAML management.endpoint.health.group.custom.show-details=when-authorized management.endpoint.health.group.custom.roles=admin management.endpoint.health.group.custom.status.order=fatal,up management.endpoint.health.group.custom.status.http-mapping.fatal=500 management.endpoint.health.group.custom.status.http-mapping.out-of-service=500 management: endpoint: health: group: custom: show-details: ""when-authorized"" roles: ""admin"" status: order: ""fatal,up"" http-mapping: fatal: 500 out-of-service: 500 You can use @Qualifier(""groupname"") if you need to register custom StatusAggregator or HttpCodeStatusMapper beans for use with the group. A health group can also include/exclude a CompositeHealthContributor . You can also include/exclude only a certain component of a CompositeHealthContributor . This can be done using the fully qualified name of the component as follows: management.endpoint.health.group.custom.include=""test/primary"" management.endpoint.health.group.custom.exclude=""test/primary/b"" In the example above, the custom group will include the HealthContributor with the name primary which is a component of the composite test . Here, primary itself is a composite and the HealthContributor with the name b will be excluded from the custom group. Health groups can be made available at an additional path on either the main or management port. This is useful in cloud environments such as Kubernetes, where it is quite common to use a separate management port for the actuator endpoints for security purposes. Having a separate port could lead to unreliable health checks because the main application might not work properly even if the health check is successful. The health group can be configured with an additional path as follows: management.endpoint.health.group.live.additional-path=""server:/healthz"" This would make the live health group available on the main server port at /healthz . The prefix is mandatory and must be either server: (represents the main server port) or management: (represents the management port, if configured.) The path must be a single path segment. DataSource Health: The DataSource health indicator shows the health of both standard data sources and routing data source beans. The health of a routing data source includes the health of each of its target data sources. In the health endpoint’s response, each of a routing data source’s targets is named by using its routing key. If you prefer not to include routing data sources in the indicator’s output, set management.health.db.ignore-routing-data-sources to true . Kubernetes Probes: Applications deployed on Kubernetes can provide information about their internal state with Container Probes(https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes) . Depending on your Kubernetes configuration(https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/) , the kubelet calls those probes and reacts to the result. By default, Spring Boot manages your Application Availability(../features/spring-application.html#features.spring-application.application-availability) state. If deployed in a Kubernetes environment, actuator gathers the “Liveness” and “Readiness” information from the ApplicationAvailability interface and uses that information in dedicated health indicators(#actuator.endpoints.health.auto-configured-health-indicators) : LivenessStateHealthIndicator and ReadinessStateHealthIndicator . These indicators are shown on the global health endpoint ( ""/actuator/health"" ). They are also exposed as separate HTTP Probes by using health groups(#actuator.endpoints.health.groups) : ""/actuator/health/liveness"" and ""/actuator/health/readiness"" . You can then configure your Kubernetes infrastructure with the following endpoint information: livenessProbe: httpGet: path: ""/actuator/health/liveness"" port: <actuator-port> failureThreshold: ... periodSeconds: ... readinessProbe: httpGet: path: ""/actuator/health/readiness"" port: <actuator-port> failureThreshold: ... periodSeconds: ... <actuator-port> should be set to the port that the actuator endpoints are available on. It could be the main web server port or a separate management port if the ""management.server.port"" property has been set. These health groups are automatically enabled only if the application runs in a Kubernetes environment(../../how-to/deployment/cloud.html#howto.deployment.cloud.kubernetes) . You can enable them in any environment by using the management.endpoint.health.probes.enabled configuration property. If an application takes longer to start than the configured liveness period, Kubernetes mentions the ""startupProbe"" as a possible solution. Generally speaking, the ""startupProbe"" is not necessarily needed here, as the ""readinessProbe"" fails until all startup tasks are done. This means your application will not receive traffic until it is ready. However, if your application takes a long time to start, consider using a ""startupProbe"" to make sure that Kubernetes won’t kill your application while it is in the process of starting. See the section that describes how probes behave during the application lifecycle(#actuator.endpoints.kubernetes-probes.lifecycle) . If your Actuator endpoints are deployed on a separate management context, the endpoints do not use the same web infrastructure (port, connection pools, framework components) as the main application. In this case, a probe check could be successful even if the main application does not work properly (for example, it cannot accept new connections). For this reason, it is a good idea to make the liveness and readiness health groups available on the main server port. This can be done by setting the following property: management.endpoint.health.probes.add-additional-paths=true This would make the liveness group available at /livez and the readiness group available at /readyz on the main server port. Paths can be customized using the additional-path property on each group, see health groups(#actuator.endpoints.health.groups) for details. Checking External State With Kubernetes Probes: Actuator configures the “liveness” and “readiness” probes as Health Groups. This means that all the health groups features(#actuator.endpoints.health.groups) are available for them. You can, for example, configure additional Health Indicators: Properties YAML management.endpoint.health.group.readiness.include=readinessState,customCheck management: endpoint: health: group: readiness: include: ""readinessState,customCheck"" By default, Spring Boot does not add other health indicators to these groups. The “liveness” probe should not depend on health checks for external systems. If the liveness state of an application(../features/spring-application.html#features.spring-application.application-availability.liveness) is broken, Kubernetes tries to solve that problem by restarting the application instance. This means that if an external system (such as a database, a Web API, or an external cache) fails, Kubernetes might restart all application instances and create cascading failures. As for the “readiness” probe, the choice of checking external systems must be made carefully by the application developers. For this reason, Spring Boot does not include any additional health checks in the readiness probe. If the readiness state of an application instance(../features/spring-application.html#features.spring-application.application-availability.readiness) is unready, Kubernetes does not route traffic to that instance. Some external systems might not be shared by application instances, in which case they could be included in a readiness probe. Other external systems might not be essential to the application (the application could have circuit breakers and fallbacks), in which case they definitely should not be included. Unfortunately, an external system that is shared by all application instances is common, and you have to make a judgement call: Include it in the readiness probe and expect that the application is taken out of service when the external service is down or leave it out and deal with failures higher up the stack, perhaps by using a circuit breaker in the caller. If all instances of an application are unready, a Kubernetes Service with type=ClusterIP or NodePort does not accept any incoming connections. There is no HTTP error response (503 and so on), since there is no connection. A service with type=LoadBalancer might or might not accept connections, depending on the provider. A service that has an explicit ingress(https://kubernetes.io/docs/concepts/services-networking/ingress/) also responds in a way that depends on the implementation — the ingress service itself has to decide how to handle the “connection refused” from downstream. HTTP 503 is quite likely in the case of both load balancer and ingress. Also, if an application uses Kubernetes autoscaling(https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/) , it may react differently to applications being taken out of the load-balancer, depending on its autoscaler configuration. Application Lifecycle and Probe States: An important aspect of the Kubernetes Probes support is its consistency with the application lifecycle. There is a significant difference between the AvailabilityState (which is the in-memory, internal state of the application) and the actual probe (which exposes that state). Depending on the phase of application lifecycle, the probe might not be available. Spring Boot publishes application events during startup and shutdown(../features/spring-application.html#features.spring-application.application-events-and-listeners) , and probes can listen to such events and expose the AvailabilityState information. The following tables show the AvailabilityState and the state of HTTP connectors at different stages. When a Spring Boot application starts: Startup phase LivenessState ReadinessState HTTP server Notes Starting BROKEN REFUSING_TRAFFIC Not started Kubernetes checks the ""liveness"" Probe and restarts the application if it takes too long. Started CORRECT REFUSING_TRAFFIC Refuses requests The application context is refreshed. The application performs startup tasks and does not receive traffic yet. Ready CORRECT ACCEPTING_TRAFFIC Accepts requests Startup tasks are finished. The application is receiving traffic. When a Spring Boot application shuts down: Shutdown phase Liveness State Readiness State HTTP server Notes Running CORRECT ACCEPTING_TRAFFIC Accepts requests Shutdown has been requested. Graceful shutdown CORRECT REFUSING_TRAFFIC New requests are rejected If enabled, graceful shutdown processes in-flight requests(../web/graceful-shutdown.html) . Shutdown complete N/A N/A Server is shut down The application context is closed and the application is shut down. See Kubernetes Container Lifecycle(../../how-to/deployment/cloud.html#howto.deployment.cloud.kubernetes.container-lifecycle) for more information about Kubernetes deployment. Application Information: Application information exposes various information collected from all InfoContributor(../../api/java/org/springframework/boot/actuate/info/InfoContributor.html) beans defined in your ApplicationContext . Spring Boot includes a number of auto-configured InfoContributor beans, and you can write your own. Auto-configured InfoContributors: When appropriate, Spring auto-configures the following InfoContributor beans: ID Name Description Prerequisites build BuildInfoContributor(../../api/java/org/springframework/boot/actuate/info/BuildInfoContributor.html) Exposes build information. A META-INF/build-info.properties resource. env EnvironmentInfoContributor(../../api/java/org/springframework/boot/actuate/info/EnvironmentInfoContributor.html) Exposes any property from the Environment whose name starts with info. . None. git GitInfoContributor(../../api/java/org/springframework/boot/actuate/info/GitInfoContributor.html) Exposes git information. A git.properties resource. java JavaInfoContributor(../../api/java/org/springframework/boot/actuate/info/JavaInfoContributor.html) Exposes Java runtime information. None. os OsInfoContributor(../../api/java/org/springframework/boot/actuate/info/OsInfoContributor.html) Exposes Operating System information. None. process ProcessInfoContributor(../../api/java/org/springframework/boot/actuate/info/ProcessInfoContributor.html) Exposes process information. None. Whether an individual contributor is enabled is controlled by its management.info.<id>.enabled property. Different contributors have different defaults for this property, depending on their prerequisites and the nature of the information that they expose. With no prerequisites to indicate that they should be enabled, the env , java , os , and process contributors are disabled by default. Each can be enabled by setting its management.info.<id>.enabled property to true . The build and git info contributors are enabled by default. Each can be disabled by setting its management.info.<id>.enabled property to false . Alternatively, to disable every contributor that is usually enabled by default, set the management.info.defaults.enabled property to false . Custom Application Information: When the env contributor is enabled, you can customize the data exposed by the info endpoint by setting info.* Spring properties. All Environment properties under the info key are automatically exposed. For example, you could add the following settings to your application.properties file: Properties YAML info.app.encoding=UTF-8 info.app.java.source=17 info.app.java.target=17 info: app: encoding: ""UTF-8"" java: source: ""17"" target: ""17"" Rather than hardcoding those values, you could also expand info properties at build time(../../how-to/properties-and-configuration.html#howto.properties-and-configuration.expand-properties) . Assuming you use Maven, you could rewrite the preceding example as follows: Properties YAML [email protected](/cdn-cgi/l/email-protection) @ [email protected](/cdn-cgi/l/email-protection) @ [email protected](/cdn-cgi/l/email-protection) @ info: app: encoding: ""@project.build.sourceEncoding@"" java: source: ""@java.version@"" target: ""@java.version@"" Git Commit Information: Another useful feature of the info endpoint is its ability to publish information about the state of your git source code repository when the project was built. If a GitProperties bean is available, you can use the info endpoint to expose these properties. A GitProperties bean is auto-configured if a git.properties file is available at the root of the classpath. See Generate Git Information(../../how-to/build.html#howto.build.generate-git-info) for more detail. By default, the endpoint exposes git.branch , git.commit.id , and git.commit.time properties, if present. If you do not want any of these properties in the endpoint response, they need to be excluded from the git.properties file. If you want to display the full git information (that is, the full content of git.properties ), use the management.info.git.mode property, as follows: Properties YAML management.info.git.mode=full management: info: git: mode: ""full"" To disable the git commit information from the info endpoint completely, set the management.info.git.enabled property to false , as follows: Properties YAML management.info.git.enabled=false management: info: git: enabled: false Build Information: If a BuildProperties bean is available, the info endpoint can also publish information about your build. This happens if a META-INF/build-info.properties file is available in the classpath. The Maven and Gradle plugins can both generate that file. See Generate Build Information(../../how-to/build.html#howto.build.generate-info) for more details. Java Information: The info endpoint publishes information about your Java runtime environment, see JavaInfo(../../api/java/org/springframework/boot/info/JavaInfo.html) for more details. OS Information: The info endpoint publishes information about your Operating System, see OsInfo(../../api/java/org/springframework/boot/info/OsInfo.html) for more details. Process Information: The info endpoint publishes information about your process, see ProcessInfo(../../api/java/org/springframework/boot/info/ProcessInfo.html) for more details. Writing Custom InfoContributors: To provide custom application information, you can register Spring beans that implement the InfoContributor(../../api/java/org/springframework/boot/actuate/info/InfoContributor.html) interface. The following example contributes an example entry with a single value: Java Kotlin import java.util.Collections; import org.springframework.boot.actuate.info.Info; import org.springframework.boot.actuate.info.InfoContributor; import org.springframework.stereotype.Component; @Component public class MyInfoContributor implements InfoContributor { @Override public void contribute(Info.Builder builder) { builder.withDetail(""example"", Collections.singletonMap(""key"", ""value"")); } } import org.springframework.boot.actuate.info.Info import org.springframework.boot.actuate.info.InfoContributor import org.springframework.stereotype.Component import java.util.Collections @Component class MyInfoContributor : InfoContributor { override fun contribute(builder: Info.Builder) { builder.withDetail(""example"", Collections.singletonMap(""key"", ""value"")) } } If you reach the info endpoint, you should see a response that contains the following additional entry: { ""example"": { ""key"" : ""value"" } } Software Bill of Materials (SBOM): The sbom endpoint exposes the Software Bill of Materials(https://en.wikipedia.org/wiki/Software_supply_chain) . CycloneDX SBOMs can be auto-detected, but other formats can be manually configured, too. The spring-boot-starter-parent Maven parent and the Spring Boot Gradle plugin configure the CycloneDX Maven plugin(https://github.com/CycloneDX/cyclonedx-maven-plugin) and the CycloneDX Gradle plugin(https://github.com/CycloneDX/cyclonedx-gradle-plugin) respectively. To get a CycloneDX SBOM, you’ll need to add this to your Maven build: <build> <plugins> <plugin> <groupId>org.cyclonedx</groupId> <artifactId>cyclonedx-maven-plugin</artifactId> </plugin> </plugins> </build> For Gradle, you’ll need to apply the CycloneDX Gradle plugin: plugins { id 'org.cyclonedx.bom' version '1.8.2' } The sbom actuator endpoint will then expose an SBOM called ""application"", which describes the contents of your application. Other SBOM formats: If you want to publish an SBOM in a different format, there are some configuration properties which you can use. The configuration property management.endpoint.sbom.application.location sets the location for the application SBOM. For example, setting this to classpath:sbom.json will use the contents of the /sbom.json resource on the classpath. The media type for SBOMs in CycloneDX, SPDX and Syft format is detected automatically. To override the auto-detected media type, use the configuration property management.endpoint.sbom.application.media-type . Additional SBOMs: The actuator endpoint can handle multiple SBOMs. To add SBOMs, use the configuration property management.endpoint.sbom.additional , as shown in this example: Properties YAML management.endpoint.sbom.additional.system.location=optional:file:/system.spdx.json management.endpoint.sbom.additional.system.media-type=application/spdx+json management: endpoint: sbom: additional: system: location: ""optional:file:/system.spdx.json"" media-type: ""application/spdx+json"" This will add an SBOM called ""system"", which is stored in /system.spdx.json . The optional: prefix can be used to prevent a startup failure if the file doesn’t exist."
"https://docs.spring.io/spring-boot/reference/actuator/monitoring.html","Monitoring and Management Over HTTP: If you are developing a web application, Spring Boot Actuator auto-configures all enabled endpoints to be exposed over HTTP. The default convention is to use the id of the endpoint with a prefix of /actuator as the URL path. For example, health is exposed as /actuator/health . Actuator is supported natively with Spring MVC, Spring WebFlux, and Jersey. If both Jersey and Spring MVC are available, Spring MVC is used. Jackson is a required dependency in order to get the correct JSON responses as documented in the API documentation(../../api/rest/actuator/index.html) . Customizing the Management Endpoint Paths: Sometimes, it is useful to customize the prefix for the management endpoints. For example, your application might already use /actuator for another purpose. You can use the management.endpoints.web.base-path property to change the prefix for your management endpoint, as the following example shows: Properties YAML management.endpoints.web.base-path=/manage management: endpoints: web: base-path: ""/manage"" The preceding application.properties example changes the endpoint from /actuator/{id} to /manage/{id} (for example, /manage/info ). Unless the management port has been configured to expose endpoints by using a different HTTP port(#actuator.monitoring.customizing-management-server-port) , management.endpoints.web.base-path is relative to server.servlet.context-path (for servlet web applications) or spring.webflux.base-path (for reactive web applications). If management.server.port is configured, management.endpoints.web.base-path is relative to management.server.base-path . If you want to map endpoints to a different path, you can use the management.endpoints.web.path-mapping property. The following example remaps /actuator/health to /healthcheck : Properties YAML management.endpoints.web.base-path=/ management.endpoints.web.path-mapping.health=healthcheck management: endpoints: web: base-path: ""/"" path-mapping: health: ""healthcheck"" Customizing the Management Server Port: Exposing management endpoints by using the default HTTP port is a sensible choice for cloud-based deployments. If, however, your application runs inside your own data center, you may prefer to expose endpoints by using a different HTTP port. You can set the management.server.port property to change the HTTP port, as the following example shows: Properties YAML management.server.port=8081 management: server: port: 8081 On Cloud Foundry, by default, applications receive requests only on port 8080 for both HTTP and TCP routing. If you want to use a custom management port on Cloud Foundry, you need to explicitly set up the application’s routes to forward traffic to the custom port. Configuring Management-specific SSL: When configured to use a custom port, you can also configure the management server with its own SSL by using the various management.server.ssl.* properties. For example, doing so lets a management server be available over HTTP while the main application uses HTTPS, as the following property settings show: Properties YAML server.port=8443 server.ssl.enabled=true server.ssl.key-store=classpath:store.jks server.ssl.key-password=secret management.server.port=8080 management.server.ssl.enabled=false server: port: 8443 ssl: enabled: true key-store: ""classpath:store.jks"" key-password: ""secret"" management: server: port: 8080 ssl: enabled: false Alternatively, both the main server and the management server can use SSL but with different key stores, as follows: Properties YAML server.port=8443 server.ssl.enabled=true server.ssl.key-store=classpath:main.jks server.ssl.key-password=secret management.server.port=8080 management.server.ssl.enabled=true management.server.ssl.key-store=classpath:management.jks management.server.ssl.key-password=secret server: port: 8443 ssl: enabled: true key-store: ""classpath:main.jks"" key-password: ""secret"" management: server: port: 8080 ssl: enabled: true key-store: ""classpath:management.jks"" key-password: ""secret"" Customizing the Management Server Address: You can customize the address on which the management endpoints are available by setting the management.server.address property. Doing so can be useful if you want to listen only on an internal or ops-facing network or to listen only for connections from localhost . You can listen on a different address only when the port differs from the main server port. The following example application.properties does not allow remote management connections: Properties YAML management.server.port=8081 management.server.address=127.0.0.1 management: server: port: 8081 address: ""127.0.0.1"" Disabling HTTP Endpoints: If you do not want to expose endpoints over HTTP, you can set the management port to -1 , as the following example shows: Properties YAML management.server.port=-1 management: server: port: -1 You can also achieve this by using the management.endpoints.web.exposure.exclude property, as the following example shows: Properties YAML management.endpoints.web.exposure.exclude=* management: endpoints: web: exposure: exclude: ""*"""
"https://docs.spring.io/spring-boot/reference/actuator/jmx.html","Monitoring and Management over JMX: Java Management Extensions (JMX) provide a standard mechanism to monitor and manage applications. By default, this feature is not enabled. You can turn it on by setting the spring.jmx.enabled configuration property to true . Spring Boot exposes the most suitable MBeanServer as a bean with an ID of mbeanServer . Any of your beans that are annotated with Spring JMX annotations ( @ManagedResource , @ManagedAttribute , or @ManagedOperation ) are exposed to it. If your platform provides a standard MBeanServer , Spring Boot uses that and defaults to the VM MBeanServer , if necessary. If all that fails, a new MBeanServer is created. spring.jmx.enabled affects only the management beans provided by Spring. Enabling management beans provided by other libraries (for example Log4j2(https://logging.apache.org/log4j/2.x/manual/jmx.html) or Quartz(https://www.javadoc.io/doc/org.quartz-scheduler/quartz/2.3.2/constant-values.html#org.quartz.impl.StdSchedulerFactory.PROP_SCHED_JMX_EXPORT) ) is independent. See the JmxAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java) class for more details. By default, Spring Boot also exposes management endpoints as JMX MBeans under the org.springframework.boot domain. To take full control over endpoint registration in the JMX domain, consider registering your own EndpointObjectNameFactory implementation. Customizing MBean Names: The name of the MBean is usually generated from the id of the endpoint. For example, the health endpoint is exposed as org.springframework.boot:type=Endpoint,name=Health . If your application contains more than one Spring ApplicationContext , you may find that names clash. To solve this problem, you can set the spring.jmx.unique-names property to true so that MBean names are always unique. You can also customize the JMX domain under which endpoints are exposed. The following settings show an example of doing so in application.properties : Properties YAML spring.jmx.unique-names=true management.endpoints.jmx.domain=com.example.myapp spring: jmx: unique-names: true management: endpoints: jmx: domain: ""com.example.myapp"" Disabling JMX Endpoints: If you do not want to expose endpoints over JMX, you can set the management.endpoints.jmx.exposure.exclude property to * , as the following example shows: Properties YAML management.endpoints.jmx.exposure.exclude=* management: endpoints: jmx: exposure: exclude: ""*"""
"https://docs.spring.io/spring-boot/reference/actuator/observability.html","Observability: Observability is the ability to observe the internal state of a running system from the outside. It consists of the three pillars: logging, metrics and traces. For metrics and traces, Spring Boot uses Micrometer Observation(https://docs.micrometer.io/micrometer/reference/1.13/observation) . To create your own observations (which will lead to metrics and traces), you can inject an ObservationRegistry . import io.micrometer.observation.Observation; import io.micrometer.observation.ObservationRegistry; import org.springframework.stereotype.Component; @Component public class MyCustomObservation { private final ObservationRegistry observationRegistry; public MyCustomObservation(ObservationRegistry observationRegistry) { this.observationRegistry = observationRegistry; } public void doSomething() { Observation.createNotStarted(""doSomething"", this.observationRegistry) .lowCardinalityKeyValue(""locale"", ""en-US"") .highCardinalityKeyValue(""userId"", ""42"") .observe(() -> { // Execute business logic here }); } } Low cardinality tags will be added to metrics and traces, while high cardinality tags will only be added to traces. Beans of type ObservationPredicate , GlobalObservationConvention , ObservationFilter and ObservationHandler will be automatically registered on the ObservationRegistry . You can additionally register any number of ObservationRegistryCustomizer beans to further configure the registry. Observability support relies on the Context Propagation library(https://github.com/micrometer-metrics/context-propagation) for forwarding the current observation across threads and reactive pipelines. By default, ThreadLocal values are not automatically reinstated in reactive operators. This behavior is controlled with the spring.reactor.context-propagation property, which can be set to auto to enable automatic propagation. For more details about observations please see the Micrometer Observation documentation(https://docs.micrometer.io/micrometer/reference/1.13/observation) . Observability for JDBC can be configured using a separate project. The Datasource Micrometer project(https://github.com/jdbc-observations/datasource-micrometer) provides a Spring Boot starter which automatically creates observations when JDBC operations are invoked. Read more about it in the reference documentation(https://jdbc-observations.github.io/datasource-micrometer/docs/current/docs/html/) . Observability for R2DBC is built into Spring Boot. To enable it, add the io.r2dbc:r2dbc-proxy dependency to your project. Common Tags: Common tags are generally used for dimensional drill-down on the operating environment, such as host, instance, region, stack, and others. Common tags are applied to all observations as low cardinality tags and can be configured, as the following example shows: Properties YAML management.observations.key-values.region=us-east-1 management.observations.key-values.stack=prod management: observations: key-values: region: ""us-east-1"" stack: ""prod"" The preceding example adds region and stack tags to all observations with a value of us-east-1 and prod , respectively. Preventing Observations: If you’d like to prevent some observations from being reported, you can use the management.observations.enable properties: Properties YAML management.observations.enable.denied.prefix=false management.observations.enable.another.denied.prefix=false management: observations: enable: denied: prefix: false another: denied: prefix: false The preceding example will prevent all observations with a name starting with denied.prefix or another.denied.prefix . If you want to prevent Spring Security from reporting observations, set the property management.observations.enable.spring.security to false . If you need greater control over the prevention of observations, you can register beans of type ObservationPredicate . Observations are only reported if all the ObservationPredicate beans return true for that observation. import io.micrometer.observation.Observation.Context; import io.micrometer.observation.ObservationPredicate; import org.springframework.stereotype.Component; @Component class MyObservationPredicate implements ObservationPredicate { @Override public boolean test(String name, Context context) { return !name.contains(""denied""); } } The preceding example will prevent all observations whose name contains ""denied"". OpenTelemetry Support: There are several ways to support OpenTelemetry(https://opentelemetry.io/) in your application. You can use the OpenTelemetry Java Agent(https://opentelemetry.io/docs/zero-code/java/agent/) or the OpenTelemetry Spring Boot Starter(https://opentelemetry.io/docs/zero-code/java/spring-boot-starter/) , which are supported by the OTel community; the metrics and traces use the semantic conventions defined by OTel libraries. This documentation describes OpenTelemetry as officially supported by the Spring team, using Micrometer and the OTLP exporter; the metrics and traces use the semantic conventions described in the Spring projects documentation, such as Spring Framework(https://docs.spring.io/spring-framework/reference/6.1/integration/observability.html) . Spring Boot’s actuator module includes basic support for OpenTelemetry. It provides a bean of type OpenTelemetry , and if there are beans of type SdkTracerProvider , ContextPropagators , SdkLoggerProvider or SdkMeterProvider in the application context, they automatically get registered. Additionally, it provides a Resource bean. The attributes of the auto-configured Resource can be configured via the management.opentelemetry.resource-attributes configuration property. If you have defined your own Resource bean, this will no longer be the case. Spring Boot does not provide auto-configuration for OpenTelemetry metrics or logging. OpenTelemetry tracing is only auto-configured when used together with Micrometer Tracing(tracing.html) . The next sections will provide more details about logging, metrics and traces. Micrometer Observation Annotations support: To enable scanning of metrics and tracing annotations like @Timed , @Counted , @MeterTag and @NewSpan annotations, you will need to set the management.observations.annotations.enabled property to true . This feature is supported Micrometer directly. Please refer to the Micrometer(https://docs.micrometer.io/micrometer/reference/1.13/concepts#_the_timed_annotation) and Micrometer Tracing(https://docs.micrometer.io/tracing/reference/1.3/api.html#_aspect_oriented_programming) reference docs."
"https://docs.spring.io/spring-boot/reference/actuator/loggers.html","Loggers: Spring Boot Actuator includes the ability to view and configure the log levels of your application at runtime. You can view either the entire list or an individual logger’s configuration, which is made up of both the explicitly configured logging level as well as the effective logging level given to it by the logging framework. These levels can be one of: TRACE DEBUG INFO WARN ERROR FATAL OFF null null indicates that there is no explicit configuration. Configure a Logger: To configure a given logger, POST a partial entity to the resource’s URI, as the following example shows: { ""configuredLevel"": ""DEBUG"" } To “reset” the specific level of the logger (and use the default configuration instead), you can pass a value of null as the configuredLevel ."
"https://docs.spring.io/spring-boot/reference/actuator/metrics.html","Metrics: Spring Boot Actuator provides dependency management and auto-configuration for Micrometer(https://micrometer.io) , an application metrics facade that supports numerous monitoring systems(https://docs.micrometer.io/micrometer/reference/1.13) , including: AppOptics(#actuator.metrics.export.appoptics) Atlas(#actuator.metrics.export.atlas) Datadog(#actuator.metrics.export.datadog) Dynatrace(#actuator.metrics.export.dynatrace) Elastic(#actuator.metrics.export.elastic) Ganglia(#actuator.metrics.export.ganglia) Graphite(#actuator.metrics.export.graphite) Humio(#actuator.metrics.export.humio) Influx(#actuator.metrics.export.influx) JMX(#actuator.metrics.export.jmx) KairosDB(#actuator.metrics.export.kairos) New Relic(#actuator.metrics.export.newrelic) OpenTelemetry(#actuator.metrics.export.otlp) Prometheus(#actuator.metrics.export.prometheus) SignalFx(#actuator.metrics.export.signalfx) Simple(#actuator.metrics.export.simple) (in-memory) Stackdriver(#actuator.metrics.export.stackdriver) StatsD(#actuator.metrics.export.statsd) Wavefront(#actuator.metrics.export.wavefront) To learn more about Micrometer’s capabilities, see its reference documentation(https://docs.micrometer.io/micrometer/reference/1.13) , in particular the concepts section(https://docs.micrometer.io/micrometer/reference/1.13/concepts) . Getting Started: Spring Boot auto-configures a composite MeterRegistry and adds a registry to the composite for each of the supported implementations that it finds on the classpath. Having a dependency on micrometer-registry-{system} in your runtime classpath is enough for Spring Boot to configure the registry. Most registries share common features. For instance, you can disable a particular registry even if the Micrometer registry implementation is on the classpath. The following example disables Datadog: Properties YAML management.datadog.metrics.export.enabled=false management: datadog: metrics: export: enabled: false You can also disable all registries unless stated otherwise by the registry-specific property, as the following example shows: Properties YAML management.defaults.metrics.export.enabled=false management: defaults: metrics: export: enabled: false Spring Boot also adds any auto-configured registries to the global static composite registry on the Metrics class, unless you explicitly tell it not to: Properties YAML management.metrics.use-global-registry=false management: metrics: use-global-registry: false You can register any number of MeterRegistryCustomizer beans to further configure the registry, such as applying common tags, before any meters are registered with the registry: Java Kotlin import io.micrometer.core.instrument.MeterRegistry; import org.springframework.boot.actuate.autoconfigure.metrics.MeterRegistryCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyMeterRegistryConfiguration { @Bean public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() { return (registry) -> registry.config().commonTags(""region"", ""us-east-1""); } } import io.micrometer.core.instrument.MeterRegistry import org.springframework.boot.actuate.autoconfigure.metrics.MeterRegistryCustomizer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyMeterRegistryConfiguration { @Bean fun metricsCommonTags(): MeterRegistryCustomizer<MeterRegistry> { return MeterRegistryCustomizer { registry -> registry.config().commonTags(""region"", ""us-east-1"") } } } You can apply customizations to particular registry implementations by being more specific about the generic type: Java Kotlin import io.micrometer.core.instrument.Meter; import io.micrometer.core.instrument.config.NamingConvention; import io.micrometer.graphite.GraphiteMeterRegistry; import org.springframework.boot.actuate.autoconfigure.metrics.MeterRegistryCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyMeterRegistryConfiguration { @Bean public MeterRegistryCustomizer<GraphiteMeterRegistry> graphiteMetricsNamingConvention() { return (registry) -> registry.config().namingConvention(this::name); } private String name(String name, Meter.Type type, String baseUnit) { return ... } } import io.micrometer.core.instrument.Meter import io.micrometer.core.instrument.config.NamingConvention import io.micrometer.graphite.GraphiteMeterRegistry import org.springframework.boot.actuate.autoconfigure.metrics.MeterRegistryCustomizer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyMeterRegistryConfiguration { @Bean fun graphiteMetricsNamingConvention(): MeterRegistryCustomizer<GraphiteMeterRegistry> { return MeterRegistryCustomizer { registry: GraphiteMeterRegistry -> registry.config().namingConvention(this::name) } } private fun name(name: String, type: Meter.Type, baseUnit: String?): String { return ... } } Spring Boot also configures built-in instrumentation(#actuator.metrics.supported) that you can control through configuration or dedicated annotation markers. Supported Monitoring Systems: This section briefly describes each of the supported monitoring systems. AppOptics: By default, the AppOptics registry periodically pushes metrics to api.appoptics.com/v1/measurements(https://api.appoptics.com/v1/measurements) . To export metrics to SaaS AppOptics(https://docs.micrometer.io/micrometer/reference/1.13/implementations/appOptics) , your API token must be provided: Properties YAML management.appoptics.metrics.export.api-token=YOUR_TOKEN management: appoptics: metrics: export: api-token: ""YOUR_TOKEN"" Atlas: By default, metrics are exported to Atlas(https://docs.micrometer.io/micrometer/reference/1.13/implementations/atlas) running on your local machine. You can provide the location of the Atlas server(https://github.com/Netflix/atlas) : Properties YAML management.atlas.metrics.export.uri=https://atlas.example.com:7101/api/v1/publish management: atlas: metrics: export: uri: ""https://atlas.example.com:7101/api/v1/publish"" Datadog: A Datadog registry periodically pushes metrics to datadoghq(https://www.datadoghq.com) . To export metrics to Datadog(https://docs.micrometer.io/micrometer/reference/1.13/implementations/datadog) , you must provide your API key: Properties YAML management.datadog.metrics.export.api-key=YOUR_KEY management: datadog: metrics: export: api-key: ""YOUR_KEY"" If you additionally provide an application key (optional), then metadata such as meter descriptions, types, and base units will also be exported: Properties YAML management.datadog.metrics.export.api-key=YOUR_API_KEY management.datadog.metrics.export.application-key=YOUR_APPLICATION_KEY management: datadog: metrics: export: api-key: ""YOUR_API_KEY"" application-key: ""YOUR_APPLICATION_KEY"" By default, metrics are sent to the Datadog US site(https://docs.datadoghq.com/getting_started/site) ( api.datadoghq.com(https://api.datadoghq.com) ). If your Datadog project is hosted on one of the other sites, or you need to send metrics through a proxy, configure the URI accordingly: Properties YAML management.datadog.metrics.export.uri=https://api.datadoghq.eu management: datadog: metrics: export: uri: ""https://api.datadoghq.eu"" You can also change the interval at which metrics are sent to Datadog: Properties YAML management.datadog.metrics.export.step=30s management: datadog: metrics: export: step: ""30s"" Dynatrace: Dynatrace offers two metrics ingest APIs, both of which are implemented for Micrometer(https://docs.micrometer.io/micrometer/reference/1.13/implementations/dynatrace) . You can find the Dynatrace documentation on Micrometer metrics ingest here(https://docs.dynatrace.com/docs/shortlink/micrometer-metrics-ingest) . Configuration properties in the v1 namespace apply only when exporting to the Timeseries v1 API(https://docs.dynatrace.com/docs/shortlink/api-metrics) . Configuration properties in the v2 namespace apply only when exporting to the Metrics v2 API(https://docs.dynatrace.com/docs/shortlink/api-metrics-v2-post-datapoints) . Note that this integration can export only to either the v1 or v2 version of the API at a time, with v2 being preferred. If the device-id (required for v1 but not used in v2) is set in the v1 namespace, metrics are exported to the v1 endpoint. Otherwise, v2 is assumed. v2 API: You can use the v2 API in two ways. Auto-configuration: Dynatrace auto-configuration is available for hosts that are monitored by the OneAgent or by the Dynatrace Operator for Kubernetes. Local OneAgent: If a OneAgent is running on the host, metrics are automatically exported to the local OneAgent ingest endpoint(https://docs.dynatrace.com/docs/shortlink/local-api) . The ingest endpoint forwards the metrics to the Dynatrace backend. Dynatrace Kubernetes Operator: When running in Kubernetes with the Dynatrace Operator installed, the registry will automatically pick up your endpoint URI and API token from the operator instead. This is the default behavior and requires no special setup beyond a dependency on io.micrometer:micrometer-registry-dynatrace . Manual Configuration: If no auto-configuration is available, the endpoint of the Metrics v2 API(https://docs.dynatrace.com/docs/shortlink/api-metrics-v2-post-datapoints) and an API token are required. The API token(https://docs.dynatrace.com/docs/shortlink/api-authentication) must have the “Ingest metrics” ( metrics.ingest ) permission set. We recommend limiting the scope of the token to this one permission. You must ensure that the endpoint URI contains the path (for example, /api/v2/metrics/ingest ): The URL of the Metrics API v2 ingest endpoint is different according to your deployment option: SaaS: https://{your-environment-id}.live.dynatrace.com/api/v2/metrics/ingest Managed deployments: https://{your-domain}/e/{your-environment-id}/api/v2/metrics/ingest The example below configures metrics export using the example environment id: Properties YAML management.dynatrace.metrics.export.uri=https://example.live.dynatrace.com/api/v2/metrics/ingest management.dynatrace.metrics.export.api-token=YOUR_TOKEN management: dynatrace: metrics: export: uri: ""https://example.live.dynatrace.com/api/v2/metrics/ingest"" api-token: ""YOUR_TOKEN"" When using the Dynatrace v2 API, the following optional features are available (more details can be found in the Dynatrace documentation(https://docs.dynatrace.com/docs/shortlink/micrometer-metrics-ingest#dt-configuration-properties) ): Metric key prefix: Sets a prefix that is prepended to all exported metric keys. Enrich with Dynatrace metadata: If a OneAgent or Dynatrace operator is running, enrich metrics with additional metadata (for example, about the host, process, or pod). Default dimensions: Specify key-value pairs that are added to all exported metrics. If tags with the same key are specified with Micrometer, they overwrite the default dimensions. Use Dynatrace Summary instruments: In some cases the Micrometer Dynatrace registry created metrics that were rejected. In Micrometer 1.9.x, this was fixed by introducing Dynatrace-specific summary instruments. Setting this toggle to false forces Micrometer to fall back to the behavior that was the default before 1.9.x. It should only be used when encountering problems while migrating from Micrometer 1.8.x to 1.9.x. Export meter metadata: Starting from Micrometer 1.12.0, the Dynatrace exporter will also export meter metadata, such as unit and description by default. Use the export-meter-metadata toggle to turn this feature off. It is possible to not specify a URI and API token, as shown in the following example. In this scenario, the automatically configured endpoint is used: Properties YAML management.dynatrace.metrics.export.v2.metric-key-prefix=your.key.prefix management.dynatrace.metrics.export.v2.enrich-with-dynatrace-metadata=true management.dynatrace.metrics.export.v2.default-dimensions.key1=value1 management.dynatrace.metrics.export.v2.default-dimensions.key2=value2 management.dynatrace.metrics.export.v2.use-dynatrace-summary-instruments=true management.dynatrace.metrics.export.v2.export-meter-metadata=true management: dynatrace: metrics: export: # Specify uri and api-token here if not using the local OneAgent endpoint. v2: metric-key-prefix: ""your.key.prefix"" enrich-with-dynatrace-metadata: true default-dimensions: key1: ""value1"" key2: ""value2"" use-dynatrace-summary-instruments: true # (default: true) export-meter-metadata: true # (default: true) v1 API (Legacy): The Dynatrace v1 API metrics registry pushes metrics to the configured URI periodically by using the Timeseries v1 API(https://docs.dynatrace.com/docs/shortlink/api-metrics) . For backwards-compatibility with existing setups, when device-id is set (required for v1, but not used in v2), metrics are exported to the Timeseries v1 endpoint. To export metrics to Dynatrace(https://docs.micrometer.io/micrometer/reference/1.13/implementations/dynatrace) , your API token, device ID, and URI must be provided: Properties YAML management.dynatrace.metrics.export.uri=https://{your-environment-id}.live.dynatrace.com management.dynatrace.metrics.export.api-token=YOUR_TOKEN management.dynatrace.metrics.export.v1.device-id=YOUR_DEVICE_ID management: dynatrace: metrics: export: uri: ""https://{your-environment-id}.live.dynatrace.com"" api-token: ""YOUR_TOKEN"" v1: device-id: ""YOUR_DEVICE_ID"" For the v1 API, you must specify the base environment URI without a path, as the v1 endpoint path is added automatically. Version-independent Settings: In addition to the API endpoint and token, you can also change the interval at which metrics are sent to Dynatrace. The default export interval is 60s . The following example sets the export interval to 30 seconds: Properties YAML management.dynatrace.metrics.export.step=30s management: dynatrace: metrics: export: step: ""30s"" You can find more information on how to set up the Dynatrace exporter for Micrometer in the Micrometer documentation(https://docs.micrometer.io/micrometer/reference/1.13/implementations/dynatrace) and the Dynatrace documentation(https://docs.dynatrace.com/docs/shortlink/micrometer-metrics-ingest) . Elastic: By default, metrics are exported to Elastic(https://docs.micrometer.io/micrometer/reference/1.13/implementations/elastic) running on your local machine. You can provide the location of the Elastic server to use by using the following property: Properties YAML management.elastic.metrics.export.host=https://elastic.example.com:8086 management: elastic: metrics: export: host: ""https://elastic.example.com:8086"" Ganglia: By default, metrics are exported to Ganglia(https://docs.micrometer.io/micrometer/reference/1.13/implementations/ganglia) running on your local machine. You can provide the Ganglia server(http://ganglia.sourceforge.net) host and port, as the following example shows: Properties YAML management.ganglia.metrics.export.host=ganglia.example.com management.ganglia.metrics.export.port=9649 management: ganglia: metrics: export: host: ""ganglia.example.com"" port: 9649 Graphite: By default, metrics are exported to Graphite(https://docs.micrometer.io/micrometer/reference/1.13/implementations/graphite) running on your local machine. You can provide the Graphite server(https://graphiteapp.org) host and port, as the following example shows: Properties YAML management.graphite.metrics.export.host=graphite.example.com management.graphite.metrics.export.port=9004 management: graphite: metrics: export: host: ""graphite.example.com"" port: 9004 Micrometer provides a default HierarchicalNameMapper that governs how a dimensional meter ID is mapped to flat hierarchical names(https://docs.micrometer.io/micrometer/reference/1.13/implementations/graphite#_hierarchical_name_mapping) . To take control over this behavior, define your GraphiteMeterRegistry and supply your own HierarchicalNameMapper . An auto-configured GraphiteConfig and Clock beans are provided unless you define your own: Java Kotlin import io.micrometer.core.instrument.Clock; import io.micrometer.core.instrument.Meter; import io.micrometer.core.instrument.config.NamingConvention; import io.micrometer.core.instrument.util.HierarchicalNameMapper; import io.micrometer.graphite.GraphiteConfig; import io.micrometer.graphite.GraphiteMeterRegistry; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyGraphiteConfiguration { @Bean public GraphiteMeterRegistry graphiteMeterRegistry(GraphiteConfig config, Clock clock) { return new GraphiteMeterRegistry(config, clock, this::toHierarchicalName); } private String toHierarchicalName(Meter.Id id, NamingConvention convention) { return ... } } import io.micrometer.core.instrument.Clock import io.micrometer.core.instrument.Meter import io.micrometer.core.instrument.config.NamingConvention import io.micrometer.core.instrument.util.HierarchicalNameMapper import io.micrometer.graphite.GraphiteConfig import io.micrometer.graphite.GraphiteMeterRegistry import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyGraphiteConfiguration { @Bean fun graphiteMeterRegistry(config: GraphiteConfig, clock: Clock): GraphiteMeterRegistry { return GraphiteMeterRegistry(config, clock, this::toHierarchicalName) } private fun toHierarchicalName(id: Meter.Id, convention: NamingConvention): String { return ... } } Humio: By default, the Humio registry periodically pushes metrics to cloud.humio.com(https://cloud.humio.com) . To export metrics to SaaS Humio(https://docs.micrometer.io/micrometer/reference/1.13/implementations/humio) , you must provide your API token: Properties YAML management.humio.metrics.export.api-token=YOUR_TOKEN management: humio: metrics: export: api-token: ""YOUR_TOKEN"" You should also configure one or more tags to identify the data source to which metrics are pushed: Properties YAML management.humio.metrics.export.tags.alpha=a management.humio.metrics.export.tags.bravo=b management: humio: metrics: export: tags: alpha: ""a"" bravo: ""b"" Influx: By default, metrics are exported to an Influx(https://docs.micrometer.io/micrometer/reference/1.13/implementations/influx) v1 instance running on your local machine with the default configuration. To export metrics to InfluxDB v2, configure the org , bucket , and authentication token for writing metrics. You can provide the location of the Influx server(https://www.influxdata.com) to use by using: Properties YAML management.influx.metrics.export.uri=https://influx.example.com:8086 management: influx: metrics: export: uri: ""https://influx.example.com:8086"" JMX: Micrometer provides a hierarchical mapping to JMX(https://docs.micrometer.io/micrometer/reference/1.13/implementations/jmx) , primarily as a cheap and portable way to view metrics locally. By default, metrics are exported to the metrics JMX domain. You can provide the domain to use by using: Properties YAML management.jmx.metrics.export.domain=com.example.app.metrics management: jmx: metrics: export: domain: ""com.example.app.metrics"" Micrometer provides a default HierarchicalNameMapper that governs how a dimensional meter ID is mapped to flat hierarchical names(https://docs.micrometer.io/micrometer/reference/1.13/implementations/jmx#_hierarchical_name_mapping) . To take control over this behavior, define your JmxMeterRegistry and supply your own HierarchicalNameMapper . An auto-configured JmxConfig and Clock beans are provided unless you define your own: Java Kotlin import io.micrometer.core.instrument.Clock; import io.micrometer.core.instrument.Meter; import io.micrometer.core.instrument.config.NamingConvention; import io.micrometer.core.instrument.util.HierarchicalNameMapper; import io.micrometer.jmx.JmxConfig; import io.micrometer.jmx.JmxMeterRegistry; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyJmxConfiguration { @Bean public JmxMeterRegistry jmxMeterRegistry(JmxConfig config, Clock clock) { return new JmxMeterRegistry(config, clock, this::toHierarchicalName); } private String toHierarchicalName(Meter.Id id, NamingConvention convention) { return ... } } import io.micrometer.core.instrument.Clock import io.micrometer.core.instrument.Meter import io.micrometer.core.instrument.config.NamingConvention import io.micrometer.core.instrument.util.HierarchicalNameMapper import io.micrometer.jmx.JmxConfig import io.micrometer.jmx.JmxMeterRegistry import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyJmxConfiguration { @Bean fun jmxMeterRegistry(config: JmxConfig, clock: Clock): JmxMeterRegistry { return JmxMeterRegistry(config, clock, this::toHierarchicalName) } private fun toHierarchicalName(id: Meter.Id, convention: NamingConvention): String { return ... } } KairosDB: By default, metrics are exported to KairosDB(https://docs.micrometer.io/micrometer/reference/1.13/implementations/kairos) running on your local machine. You can provide the location of the KairosDB server(https://kairosdb.github.io/) to use by using: Properties YAML management.kairos.metrics.export.uri=https://kairosdb.example.com:8080/api/v1/datapoints management: kairos: metrics: export: uri: ""https://kairosdb.example.com:8080/api/v1/datapoints"" New Relic: A New Relic registry periodically pushes metrics to New Relic(https://docs.micrometer.io/micrometer/reference/1.13/implementations/new-relic) . To export metrics to New Relic(https://newrelic.com) , you must provide your API key and account ID: Properties YAML management.newrelic.metrics.export.api-key=YOUR_KEY management.newrelic.metrics.export.account-id=YOUR_ACCOUNT_ID management: newrelic: metrics: export: api-key: ""YOUR_KEY"" account-id: ""YOUR_ACCOUNT_ID"" You can also change the interval at which metrics are sent to New Relic: Properties YAML management.newrelic.metrics.export.step=30s management: newrelic: metrics: export: step: ""30s"" By default, metrics are published through REST calls, but you can also use the Java Agent API if you have it on the classpath: Properties YAML management.newrelic.metrics.export.client-provider-type=insights-agent management: newrelic: metrics: export: client-provider-type: ""insights-agent"" Finally, you can take full control by defining your own NewRelicClientProvider bean. OpenTelemetry: By default, metrics are exported to OpenTelemetry(https://docs.micrometer.io/micrometer/reference/1.13/implementations/otlp) running on your local machine. You can provide the location of the OpenTelemetry metric endpoint(https://opentelemetry.io/) to use by using: Properties YAML management.otlp.metrics.export.url=https://otlp.example.com:4318/v1/metrics management: otlp: metrics: export: url: ""https://otlp.example.com:4318/v1/metrics"" Prometheus: Prometheus(https://docs.micrometer.io/micrometer/reference/1.13/implementations/prometheus) expects to scrape or poll individual application instances for metrics. Spring Boot provides an actuator endpoint at /actuator/prometheus to present a Prometheus scrape(https://prometheus.io) with the appropriate format. By default, the endpoint is not available and must be exposed. See exposing endpoints(endpoints.html#actuator.endpoints.exposing) for more details. The following example scrape_config adds to prometheus.yml : scrape_configs: - job_name: ""spring"" metrics_path: ""/actuator/prometheus"" static_configs: - targets: [""HOST:PORT""] Prometheus Exemplars(https://prometheus.io/docs/prometheus/latest/feature_flags/#exemplars-storage) are also supported. To enable this feature, a SpanContext bean should be present. If you’re using the deprecated Prometheus simpleclient support and want to enable that feature, a SpanContextSupplier bean should be present. If you use Micrometer Tracing(https://docs.micrometer.io/tracing/reference/1.3) , this will be auto-configured for you, but you can always create your own if you want. Please check the Prometheus Docs(https://prometheus.io/docs/prometheus/latest/feature_flags/#exemplars-storage) , since this feature needs to be explicitly enabled on Prometheus' side, and it is only supported using the OpenMetrics(https://github.com/OpenObservability/OpenMetrics/blob/v1.0.0/specification/OpenMetrics.md#exemplars) format. For ephemeral or batch jobs that may not exist long enough to be scraped, you can use Prometheus Pushgateway(https://github.com/prometheus/pushgateway) support to expose the metrics to Prometheus. The Prometheus Pushgateway only works with the deprecated Prometheus simpleclient for now, until the Prometheus 1.x client adds support for it. To switch to the simpleclient, remove io.micrometer:micrometer-registry-prometheus from your project and add io.micrometer:micrometer-registry-prometheus-simpleclient instead. To enable Prometheus Pushgateway support, add the following dependency to your project: <dependency> <groupId>io.prometheus</groupId> <artifactId>simpleclient_pushgateway</artifactId> </dependency> When the Prometheus Pushgateway dependency is present on the classpath and the management.prometheus.metrics.export.pushgateway.enabled property is set to true , a PrometheusPushGatewayManager bean is auto-configured. This manages the pushing of metrics to a Prometheus Pushgateway. You can tune the PrometheusPushGatewayManager by using properties under management.prometheus.metrics.export.pushgateway . For advanced configuration, you can also provide your own PrometheusPushGatewayManager bean. SignalFx: SignalFx registry periodically pushes metrics to SignalFx(https://docs.micrometer.io/micrometer/reference/1.13/implementations/signalFx) . To export metrics to SignalFx(https://www.signalfx.com) , you must provide your access token: Properties YAML management.signalfx.metrics.export.access-token=YOUR_ACCESS_TOKEN management: signalfx: metrics: export: access-token: ""YOUR_ACCESS_TOKEN"" You can also change the interval at which metrics are sent to SignalFx: Properties YAML management.signalfx.metrics.export.step=30s management: signalfx: metrics: export: step: ""30s"" Simple: Micrometer ships with a simple, in-memory backend that is automatically used as a fallback if no other registry is configured. This lets you see what metrics are collected in the metrics endpoint(#actuator.metrics.endpoint) . The in-memory backend disables itself as soon as you use any other available backend. You can also disable it explicitly: Properties YAML management.simple.metrics.export.enabled=false management: simple: metrics: export: enabled: false Stackdriver: The Stackdriver registry periodically pushes metrics to Stackdriver(https://cloud.google.com/stackdriver/) . To export metrics to SaaS Stackdriver(https://docs.micrometer.io/micrometer/reference/1.13/implementations/stackdriver) , you must provide your Google Cloud project ID: Properties YAML management.stackdriver.metrics.export.project-id=my-project management: stackdriver: metrics: export: project-id: ""my-project"" You can also change the interval at which metrics are sent to Stackdriver: Properties YAML management.stackdriver.metrics.export.step=30s management: stackdriver: metrics: export: step: ""30s"" StatsD: The StatsD registry eagerly pushes metrics over UDP to a StatsD agent. By default, metrics are exported to a StatsD(https://docs.micrometer.io/micrometer/reference/1.13/implementations/statsD) agent running on your local machine. You can provide the StatsD agent host, port, and protocol to use by using: Properties YAML management.statsd.metrics.export.host=statsd.example.com management.statsd.metrics.export.port=9125 management.statsd.metrics.export.protocol=udp management: statsd: metrics: export: host: ""statsd.example.com"" port: 9125 protocol: ""udp"" You can also change the StatsD line protocol to use (it defaults to Datadog): Properties YAML management.statsd.metrics.export.flavor=etsy management: statsd: metrics: export: flavor: ""etsy"" Wavefront: The Wavefront registry periodically pushes metrics to Wavefront(https://docs.micrometer.io/micrometer/reference/1.13/implementations/wavefront) . If you are exporting metrics to Wavefront(https://www.wavefront.com/) directly, you must provide your API token: Properties YAML management.wavefront.api-token=YOUR_API_TOKEN management: wavefront: api-token: ""YOUR_API_TOKEN"" Alternatively, you can use a Wavefront sidecar or an internal proxy in your environment to forward metrics data to the Wavefront API host: Properties YAML management.wavefront.uri=proxy://localhost:2878 management: wavefront: uri: ""proxy://localhost:2878"" If you publish metrics to a Wavefront proxy (as described in the Wavefront documentation(https://docs.wavefront.com/proxies_installing.html) ), the host must be in the proxy://HOST:PORT format. You can also change the interval at which metrics are sent to Wavefront: Properties YAML management.wavefront.metrics.export.step=30s management: wavefront: metrics: export: step: ""30s"" Supported Metrics and Meters: Spring Boot provides automatic meter registration for a wide variety of technologies. In most situations, the defaults provide sensible metrics that can be published to any of the supported monitoring systems. JVM Metrics: Auto-configuration enables JVM Metrics by using core Micrometer classes. JVM metrics are published under the jvm. meter name. The following JVM metrics are provided: Various memory and buffer pool details Statistics related to garbage collection Thread utilization The number of classes loaded and unloaded JVM version information JIT compilation time System Metrics: Auto-configuration enables system metrics by using core Micrometer classes. System metrics are published under the system. , process. , and disk. meter names. The following system metrics are provided: CPU metrics File descriptor metrics Uptime metrics (both the amount of time the application has been running and a fixed gauge of the absolute start time) Disk space available Application Startup Metrics: Auto-configuration exposes application startup time metrics: application.started.time : time taken to start the application. application.ready.time : time taken for the application to be ready to service requests. Metrics are tagged by the fully qualified name of the application class. Logger Metrics: Auto-configuration enables the event metrics for both Logback and Log4J2. The details are published under the log4j2.events. or logback.events. meter names. Task Execution and Scheduling Metrics: Auto-configuration enables the instrumentation of all available ThreadPoolTaskExecutor and ThreadPoolTaskScheduler beans, as long as the underling ThreadPoolExecutor is available. Metrics are tagged by the name of the executor, which is derived from the bean name. JMS Metrics: Auto-configuration enables the instrumentation of all available JmsTemplate beans and @JmsListener annotated methods. This will produce ""jms.message.publish"" and ""jms.message.process"" metrics respectively. See the Spring Framework reference documentation for more information on produced observations(https://docs.spring.io/spring-framework/reference/6.1/integration/observability.html#observability.jms) . Spring MVC Metrics: Auto-configuration enables the instrumentation of all requests handled by Spring MVC controllers and functional handlers. By default, metrics are generated with the name, http.server.requests . You can customize the name by setting the management.observations.http.server.requests.name property. See the Spring Framework reference documentation for more information on produced observations(https://docs.spring.io/spring-framework/reference/6.1/integration/observability.html#observability.http-server.servlet) . To add to the default tags, provide a @Bean that extends DefaultServerRequestObservationConvention from the org.springframework.http.server.observation package. To replace the default tags, provide a @Bean that implements ServerRequestObservationConvention . In some cases, exceptions handled in web controllers are not recorded as request metrics tags. Applications can opt in and record exceptions by setting handled exceptions as request attributes(../web/servlet.html#web.servlet.spring-mvc.error-handling) . By default, all requests are handled. To customize the filter, provide a @Bean that implements FilterRegistrationBean<ServerHttpObservationFilter> . Spring WebFlux Metrics: Auto-configuration enables the instrumentation of all requests handled by Spring WebFlux controllers and functional handlers. By default, metrics are generated with the name, http.server.requests . You can customize the name by setting the management.observations.http.server.requests.name property. See the Spring Framework reference documentation for more information on produced observations(https://docs.spring.io/spring-framework/reference/6.1/integration/observability.html#observability.http-server.reactive) . To add to the default tags, provide a @Bean that extends DefaultServerRequestObservationConvention from the org.springframework.http.server.reactive.observation package. To replace the default tags, provide a @Bean that implements ServerRequestObservationConvention . In some cases, exceptions handled in controllers and handler functions are not recorded as request metrics tags. Applications can opt in and record exceptions by setting handled exceptions as request attributes(../web/reactive.html#web.reactive.webflux.error-handling) . Jersey Server Metrics: Auto-configuration enables the instrumentation of all requests handled by the Jersey JAX-RS implementation. By default, metrics are generated with the name, http.server.requests . You can customize the name by setting the management.observations.http.server.requests.name property. By default, Jersey server metrics are tagged with the following information: Tag Description exception The simple class name of any exception that was thrown while handling the request. method The request’s method (for example, GET or POST ) outcome The request’s outcome, based on the status code of the response. 1xx is INFORMATIONAL , 2xx is SUCCESS , 3xx is REDIRECTION , 4xx is CLIENT_ERROR , and 5xx is SERVER_ERROR status The response’s HTTP status code (for example, 200 or 500 ) uri The request’s URI template prior to variable substitution, if possible (for example, /api/person/{id} ) To customize the tags, provide a @Bean that implements JerseyObservationConvention . HTTP Client Metrics: Spring Boot Actuator manages the instrumentation of RestTemplate , WebClient and RestClient . For that, you have to inject the auto-configured builder and use it to create instances: RestTemplateBuilder for RestTemplate WebClient.Builder for WebClient RestClient.Builder for RestClient You can also manually apply the customizers responsible for this instrumentation, namely ObservationRestTemplateCustomizer , ObservationWebClientCustomizer and ObservationRestClientCustomizer . By default, metrics are generated with the name, http.client.requests . You can customize the name by setting the management.observations.http.client.requests.name property. See the Spring Framework reference documentation for more information on produced observations(https://docs.spring.io/spring-framework/reference/6.1/integration/observability.html#observability.http-client) . To customize the tags when using RestTemplate or RestClient , provide a @Bean that implements ClientRequestObservationConvention from the org.springframework.http.client.observation package. To customize the tags when using WebClient , provide a @Bean that implements ClientRequestObservationConvention from the org.springframework.web.reactive.function.client package. Tomcat Metrics: Auto-configuration enables the instrumentation of Tomcat only when an MBeanRegistry is enabled. By default, the MBeanRegistry is disabled, but you can enable it by setting server.tomcat.mbeanregistry.enabled to true . Tomcat metrics are published under the tomcat. meter name. Cache Metrics: Auto-configuration enables the instrumentation of all available Cache instances on startup, with metrics prefixed with cache . Cache instrumentation is standardized for a basic set of metrics. Additional, cache-specific metrics are also available. The following cache libraries are supported: Cache2k Caffeine Hazelcast Any compliant JCache (JSR-107) implementation Redis Metrics are tagged by the name of the cache and by the name of the CacheManager , which is derived from the bean name. Only caches that are configured on startup are bound to the registry. For caches not defined in the cache’s configuration, such as caches created on the fly or programmatically after the startup phase, an explicit registration is required. A CacheMetricsRegistrar bean is made available to make that process easier. Spring Batch Metrics: See the Spring Batch reference documentation(https://docs.spring.io/spring-batch/reference/5.1/monitoring-and-metrics.html) . Spring GraphQL Metrics: See the Spring GraphQL reference documentation(https://docs.spring.io/spring-graphql/reference/1.3/observability.html) . DataSource Metrics: Auto-configuration enables the instrumentation of all available DataSource objects with metrics prefixed with jdbc.connections . Data source instrumentation results in gauges that represent the currently active, idle, maximum allowed, and minimum allowed connections in the pool. Metrics are also tagged by the name of the DataSource computed based on the bean name. By default, Spring Boot provides metadata for all supported data sources. You can add additional DataSourcePoolMetadataProvider beans if your favorite data source is not supported. See DataSourcePoolMetadataProvidersConfiguration for examples. Also, Hikari-specific metrics are exposed with a hikaricp prefix. Each metric is tagged by the name of the pool (you can control it with spring.datasource.name ). Hibernate Metrics: If org.hibernate.orm:hibernate-micrometer is on the classpath, all available Hibernate EntityManagerFactory instances that have statistics enabled are instrumented with a metric named hibernate . Metrics are also tagged by the name of the EntityManagerFactory , which is derived from the bean name. To enable statistics, the standard JPA property hibernate.generate_statistics must be set to true . You can enable that on the auto-configured EntityManagerFactory : Properties YAML spring.jpa.properties[hibernate.generate_statistics]=true spring: jpa: properties: ""[hibernate.generate_statistics]"": true Spring Data Repository Metrics: Auto-configuration enables the instrumentation of all Spring Data Repository method invocations. By default, metrics are generated with the name, spring.data.repository.invocations . You can customize the name by setting the management.metrics.data.repository.metric-name property. The @Timed annotation from the io.micrometer.core.annotation package is supported on Repository interfaces and methods. If you do not want to record metrics for all Repository invocations, you can set management.metrics.data.repository.autotime.enabled to false and exclusively use @Timed annotations instead. A @Timed annotation with longTask = true enables a long task timer for the method. Long task timers require a separate metric name and can be stacked with a short task timer. By default, repository invocation related metrics are tagged with the following information: Tag Description repository The simple class name of the source Repository . method The name of the Repository method that was invoked. state The result state ( SUCCESS , ERROR , CANCELED , or RUNNING ). exception The simple class name of any exception that was thrown from the invocation. To replace the default tags, provide a @Bean that implements RepositoryTagsProvider . RabbitMQ Metrics: Auto-configuration enables the instrumentation of all available RabbitMQ connection factories with a metric named rabbitmq . Spring Integration Metrics: Spring Integration automatically provides Micrometer support(https://docs.spring.io/spring-integration/reference/6.3/metrics.html#micrometer-integration) whenever a MeterRegistry bean is available. Metrics are published under the spring.integration. meter name. Kafka Metrics: Auto-configuration registers a MicrometerConsumerListener and MicrometerProducerListener for the auto-configured consumer factory and producer factory, respectively. It also registers a KafkaStreamsMicrometerListener for StreamsBuilderFactoryBean . For more detail, see the Micrometer Native Metrics(https://docs.spring.io/spring-kafka/reference/3.2/kafka/micrometer.html#micrometer-native) section of the Spring Kafka documentation. MongoDB Metrics: This section briefly describes the available metrics for MongoDB. MongoDB Command Metrics: Auto-configuration registers a MongoMetricsCommandListener with the auto-configured MongoClient . A timer metric named mongodb.driver.commands is created for each command issued to the underlying MongoDB driver. Each metric is tagged with the following information by default: Tag Description command The name of the command issued. cluster.id The identifier of the cluster to which the command was sent. server.address The address of the server to which the command was sent. status The outcome of the command ( SUCCESS or FAILED ). To replace the default metric tags, define a MongoCommandTagsProvider bean, as the following example shows: Java Kotlin import io.micrometer.core.instrument.binder.mongodb.MongoCommandTagsProvider; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyCommandTagsProviderConfiguration { @Bean public MongoCommandTagsProvider customCommandTagsProvider() { return new CustomCommandTagsProvider(); } } import io.micrometer.core.instrument.binder.mongodb.MongoCommandTagsProvider import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyCommandTagsProviderConfiguration { @Bean fun customCommandTagsProvider(): MongoCommandTagsProvider? { return CustomCommandTagsProvider() } } To disable the auto-configured command metrics, set the following property: Properties YAML management.metrics.mongo.command.enabled=false management: metrics: mongo: command: enabled: false MongoDB Connection Pool Metrics: Auto-configuration registers a MongoMetricsConnectionPoolListener with the auto-configured MongoClient . The following gauge metrics are created for the connection pool: mongodb.driver.pool.size reports the current size of the connection pool, including idle and in-use members. mongodb.driver.pool.checkedout reports the count of connections that are currently in use. mongodb.driver.pool.waitqueuesize reports the current size of the wait queue for a connection from the pool. Each metric is tagged with the following information by default: Tag Description cluster.id The identifier of the cluster to which the connection pool corresponds. server.address The address of the server to which the connection pool corresponds. To replace the default metric tags, define a MongoConnectionPoolTagsProvider bean: Java Kotlin import io.micrometer.core.instrument.binder.mongodb.MongoConnectionPoolTagsProvider; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyConnectionPoolTagsProviderConfiguration { @Bean public MongoConnectionPoolTagsProvider customConnectionPoolTagsProvider() { return new CustomConnectionPoolTagsProvider(); } } import io.micrometer.core.instrument.binder.mongodb.MongoConnectionPoolTagsProvider import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyConnectionPoolTagsProviderConfiguration { @Bean fun customConnectionPoolTagsProvider(): MongoConnectionPoolTagsProvider { return CustomConnectionPoolTagsProvider() } } To disable the auto-configured connection pool metrics, set the following property: Properties YAML management.metrics.mongo.connectionpool.enabled=false management: metrics: mongo: connectionpool: enabled: false Jetty Metrics: Auto-configuration binds metrics for Jetty’s ThreadPool by using Micrometer’s JettyServerThreadPoolMetrics . Metrics for Jetty’s Connector instances are bound by using Micrometer’s JettyConnectionMetrics and, when server.ssl.enabled is set to true , Micrometer’s JettySslHandshakeMetrics . @Timed Annotation Support: To enable scanning of @Timed annotations, you will need to set the management.observations.annotations.enabled property to true . Please refer to the Micrometer documentation(https://docs.micrometer.io/micrometer/reference/1.13/concepts#_the_timed_annotation) . Redis Metrics: Auto-configuration registers a MicrometerCommandLatencyRecorder for the auto-configured LettuceConnectionFactory . For more detail, see the Micrometer Metrics section(https://lettuce.io/core/6.3.2.RELEASE/reference/index.html#command.latency.metrics.micrometer) of the Lettuce documentation. Registering Custom Metrics: To register custom metrics, inject MeterRegistry into your component: Java Kotlin import io.micrometer.core.instrument.MeterRegistry; import io.micrometer.core.instrument.Tags; import org.springframework.stereotype.Component; @Component public class MyBean { private final Dictionary dictionary; public MyBean(MeterRegistry registry) { this.dictionary = Dictionary.load(); registry.gauge(""dictionary.size"", Tags.empty(), this.dictionary.getWords().size()); } } import io.micrometer.core.instrument.MeterRegistry import io.micrometer.core.instrument.Tags import org.springframework.stereotype.Component @Component class MyBean(registry: MeterRegistry) { private val dictionary: Dictionary init { dictionary = Dictionary.load() registry.gauge(""dictionary.size"", Tags.empty(), dictionary.words.size) } } If your metrics depend on other beans, we recommend that you use a MeterBinder to register them: Java Kotlin import io.micrometer.core.instrument.Gauge; import io.micrometer.core.instrument.binder.MeterBinder; import org.springframework.context.annotation.Bean; public class MyMeterBinderConfiguration { @Bean public MeterBinder queueSize(Queue queue) { return (registry) -> Gauge.builder(""queueSize"", queue::size).register(registry); } } import io.micrometer.core.instrument.Gauge import io.micrometer.core.instrument.binder.MeterBinder import org.springframework.context.annotation.Bean class MyMeterBinderConfiguration { @Bean fun queueSize(queue: Queue): MeterBinder { return MeterBinder { registry -> Gauge.builder(""queueSize"", queue::size).register(registry) } } } Using a MeterBinder ensures that the correct dependency relationships are set up and that the bean is available when the metric’s value is retrieved. A MeterBinder implementation can also be useful if you find that you repeatedly instrument a suite of metrics across components or applications. By default, metrics from all MeterBinder beans are automatically bound to the Spring-managed MeterRegistry . Customizing Individual Metrics: If you need to apply customizations to specific Meter instances, you can use the io.micrometer.core.instrument.config.MeterFilter interface. For example, if you want to rename the mytag.region tag to mytag.area for all meter IDs beginning with com.example , you can do the following: Java Kotlin import io.micrometer.core.instrument.config.MeterFilter; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyMetricsFilterConfiguration { @Bean public MeterFilter renameRegionTagMeterFilter() { return MeterFilter.renameTag(""com.example"", ""mytag.region"", ""mytag.area""); } } import io.micrometer.core.instrument.config.MeterFilter import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyMetricsFilterConfiguration { @Bean fun renameRegionTagMeterFilter(): MeterFilter { return MeterFilter.renameTag(""com.example"", ""mytag.region"", ""mytag.area"") } } By default, all MeterFilter beans are automatically bound to the Spring-managed MeterRegistry . Make sure to register your metrics by using the Spring-managed MeterRegistry and not any of the static methods on Metrics . These use the global registry that is not Spring-managed. Common Tags: Common tags are generally used for dimensional drill-down on the operating environment, such as host, instance, region, stack, and others. Commons tags are applied to all meters and can be configured, as the following example shows: Properties YAML management.metrics.tags.region=us-east-1 management.metrics.tags.stack=prod management: metrics: tags: region: ""us-east-1"" stack: ""prod"" The preceding example adds region and stack tags to all meters with a value of us-east-1 and prod , respectively. The order of common tags is important if you use Graphite. As the order of common tags cannot be guaranteed by using this approach, Graphite users are advised to define a custom MeterFilter instead. Per-meter Properties: In addition to MeterFilter beans, you can apply a limited set of customization on a per-meter basis using properties. Per-meter customizations are applied, using Spring Boot’s PropertiesMeterFilter , to any meter IDs that start with the given name. The following example filters out any meters that have an ID starting with example.remote . Properties YAML management.metrics.enable.example.remote=false management: metrics: enable: example: remote: false The following properties allow per-meter customization: Table 1. Per-meter customizations Property Description management.metrics.enable Whether to accept meters with certain IDs. Meters that are not accepted are filtered from the MeterRegistry . management.metrics.distribution.percentiles-histogram Whether to publish a histogram suitable for computing aggregable (across dimension) percentile approximations. management.metrics.distribution.minimum-expected-value , management.metrics.distribution.maximum-expected-value Publish fewer histogram buckets by clamping the range of expected values. management.metrics.distribution.percentiles Publish percentile values computed in your application management.metrics.distribution.expiry , management.metrics.distribution.buffer-length Give greater weight to recent samples by accumulating them in ring buffers which rotate after a configurable expiry, with a configurable buffer length. management.metrics.distribution.slo Publish a cumulative histogram with buckets defined by your service-level objectives. For more details on the concepts behind percentiles-histogram , percentiles , and slo , see the Histograms and percentiles(https://docs.micrometer.io/micrometer/reference/1.13/concepts#_histograms_and_percentiles) section of the Micrometer documentation. Metrics Endpoint: Spring Boot provides a metrics endpoint that you can use diagnostically to examine the metrics collected by an application. The endpoint is not available by default and must be exposed. See exposing endpoints(endpoints.html#actuator.endpoints.exposing) for more details. Navigating to /actuator/metrics displays a list of available meter names. You can drill down to view information about a particular meter by providing its name as a selector — for example, /actuator/metrics/jvm.memory.max . The name you use here should match the name used in the code, not the name after it has been naming-convention normalized for a monitoring system to which it is shipped. In other words, if jvm.memory.max appears as jvm_memory_max in Prometheus because of its snake case naming convention, you should still use jvm.memory.max as the selector when inspecting the meter in the metrics endpoint. You can also add any number of tag=KEY:VALUE query parameters to the end of the URL to dimensionally drill down on a meter — for example, /actuator/metrics/jvm.memory.max?tag=area:nonheap . The reported measurements are the sum of the statistics of all meters that match the meter name and any tags that have been applied. In the preceding example, the returned Value statistic is the sum of the maximum memory footprints of the “Code Cache”, “Compressed Class Space”, and “Metaspace” areas of the heap. If you wanted to see only the maximum size for the “Metaspace”, you could add an additional tag=id:Metaspace — that is, /actuator/metrics/jvm.memory.max?tag=area:nonheap&tag=id:Metaspace . Integration with Micrometer Observation: A DefaultMeterObservationHandler is automatically registered on the ObservationRegistry , which creates metrics for every completed observation."
"https://docs.spring.io/spring-boot/reference/actuator/tracing.html","Tracing: Spring Boot Actuator provides dependency management and auto-configuration for Micrometer Tracing(https://docs.micrometer.io/tracing/reference/1.3) , a facade for popular tracer libraries. To learn more about Micrometer Tracing capabilities, see its reference documentation(https://docs.micrometer.io/tracing/reference/1.3) . Supported Tracers: Spring Boot ships auto-configuration for the following tracers: OpenTelemetry(https://opentelemetry.io/) with Zipkin(https://zipkin.io/) , Wavefront(https://docs.wavefront.com/) , or OTLP(https://opentelemetry.io/docs/reference/specification/protocol/) OpenZipkin Brave(https://github.com/openzipkin/brave) with Zipkin(https://zipkin.io/) or Wavefront(https://docs.wavefront.com/) Getting Started: We need an example application that we can use to get started with tracing. For our purposes, the simple “Hello World!” web application that’s covered in the Developing Your First Spring Boot Application(../../tutorial/first-application/index.html) section will suffice. We’re going to use the OpenTelemetry tracer with Zipkin as trace backend. To recap, our main application code looks like this: import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @SpringBootApplication public class MyApplication { private static final Log logger = LogFactory.getLog(MyApplication.class); @RequestMapping(""/"") String home() { logger.info(""home() has been called""); return ""Hello World!""; } public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } There’s an added logger statement in the home() method, which will be important later. Now we have to add the following dependencies: org.springframework.boot:spring-boot-starter-actuator io.micrometer:micrometer-tracing-bridge-otel - bridges the Micrometer Observation API to OpenTelemetry. io.opentelemetry:opentelemetry-exporter-zipkin - reports traces(https://docs.micrometer.io/tracing/reference/1.3/glossary) to Zipkin. Add the following application properties: Properties YAML management.tracing.sampling.probability=1 management: tracing: sampling: probability: 1.0 By default, Spring Boot samples only 10% of requests to prevent overwhelming the trace backend. This property switches it to 100% so that every request is sent to the trace backend. To collect and visualize the traces, we need a running trace backend. We use Zipkin as our trace backend here. The Zipkin Quickstart guide(https://zipkin.io/pages/quickstart) provides instructions how to start Zipkin locally. After Zipkin is running, you can start your application. If you open a web browser to localhost:8080(http://localhost:8080) , you should see the following output: Hello World! Behind the scenes, an observation has been created for the HTTP request, which in turn gets bridged to OpenTelemetry, which reports a new trace to Zipkin. Now open the Zipkin UI at localhost:9411(http://localhost:9411) and press the ""Run Query"" button to list all collected traces. You should see one trace. Press the ""Show"" button to see the details of that trace. Logging Correlation IDs: Correlation IDs provide a helpful way to link lines in your log files to spans/traces. If you are using Micrometer Tracing, Spring Boot will include correlation IDs in your logs by default. The default correlation ID is built from traceId and spanId MDC(https://logback.qos.ch/manual/mdc.html) values. For example, if Micrometer Tracing has added an MDC traceId of 803B448A0489F84084905D3093480352 and an MDC spanId of 3425F23BB2432450 the log output will include the correlation ID [803B448A0489F84084905D3093480352-3425F23BB2432450] . If you prefer to use a different format for your correlation ID, you can use the logging.pattern.correlation property to define one. For example, the following will provide a correlation ID for Logback in format previously used by Spring Cloud Sleuth: Properties YAML logging.pattern.correlation=[${spring.application.name:},%X{traceId:-},%X{spanId:-}] logging.include-application-name=false logging: pattern: correlation: ""[${spring.application.name:},%X{traceId:-},%X{spanId:-}] "" include-application-name: false In the example above, logging.include-application-name is set to false to avoid the application name being duplicated in the log messages ( logging.pattern.correlation already contains it). It’s also worth mentioning that logging.pattern.correlation contains a trailing space so that it is separated from the logger name that comes right after it by default. Propagating Traces: To automatically propagate traces over the network, use the auto-configured RestTemplateBuilder(../io/rest-client.html#io.rest-client.resttemplate) , RestClient.Builder(../io/rest-client.html#io.rest-client.restclient) or WebClient.Builder(../io/rest-client.html#io.rest-client.webclient) to construct the client. If you create the RestTemplate , the RestClient or the WebClient without using the auto-configured builders, automatic trace propagation won’t work! Tracer Implementations: As Micrometer Tracer supports multiple tracer implementations, there are multiple dependency combinations possible with Spring Boot. All tracer implementations need the org.springframework.boot:spring-boot-starter-actuator dependency. OpenTelemetry With Zipkin: Tracing with OpenTelemetry and reporting to Zipkin requires the following dependencies: io.micrometer:micrometer-tracing-bridge-otel - bridges the Micrometer Observation API to OpenTelemetry. io.opentelemetry:opentelemetry-exporter-zipkin - reports traces to Zipkin. Use the management.zipkin.tracing.* configuration properties to configure reporting to Zipkin. OpenTelemetry With Wavefront: Tracing with OpenTelemetry and reporting to Wavefront requires the following dependencies: io.micrometer:micrometer-tracing-bridge-otel - bridges the Micrometer Observation API to OpenTelemetry. io.micrometer:micrometer-tracing-reporter-wavefront - reports traces to Wavefront. Use the management.wavefront.* configuration properties to configure reporting to Wavefront. OpenTelemetry With OTLP: Tracing with OpenTelemetry and reporting using OTLP requires the following dependencies: io.micrometer:micrometer-tracing-bridge-otel - bridges the Micrometer Observation API to OpenTelemetry. io.opentelemetry:opentelemetry-exporter-otlp - reports traces to a collector that can accept OTLP. Use the management.otlp.tracing.* configuration properties to configure reporting using OTLP. OpenZipkin Brave With Zipkin: Tracing with OpenZipkin Brave and reporting to Zipkin requires the following dependencies: io.micrometer:micrometer-tracing-bridge-brave - bridges the Micrometer Observation API to Brave. io.zipkin.reporter2:zipkin-reporter-brave - reports traces to Zipkin. Use the management.zipkin.tracing.* configuration properties to configure reporting to Zipkin. OpenZipkin Brave With Wavefront: Tracing with OpenZipkin Brave and reporting to Wavefront requires the following dependencies: io.micrometer:micrometer-tracing-bridge-brave - bridges the Micrometer Observation API to Brave. io.micrometer:micrometer-tracing-reporter-wavefront - reports traces to Wavefront. Use the management.wavefront.* configuration properties to configure reporting to Wavefront. Integration with Micrometer Observation: A TracingAwareMeterObservationHandler is automatically registered on the ObservationRegistry , which creates spans for every completed observation. Creating Custom Spans: You can create your own spans by starting an observation. For this, inject ObservationRegistry into your component: import io.micrometer.observation.Observation; import io.micrometer.observation.ObservationRegistry; import org.springframework.stereotype.Component; @Component class CustomObservation { private final ObservationRegistry observationRegistry; CustomObservation(ObservationRegistry observationRegistry) { this.observationRegistry = observationRegistry; } void someOperation() { Observation observation = Observation.createNotStarted(""some-operation"", this.observationRegistry); observation.lowCardinalityKeyValue(""some-tag"", ""some-value""); observation.observe(() -> { // Business logic ... }); } } This will create an observation named ""some-operation"" with the tag ""some-tag=some-value"". If you want to create a span without creating a metric, you need to use the lower-level Tracer API(https://docs.micrometer.io/tracing/reference/1.3/api) from Micrometer. Baggage: You can create baggage with the Tracer API: import io.micrometer.tracing.BaggageInScope; import io.micrometer.tracing.Tracer; import org.springframework.stereotype.Component; @Component class CreatingBaggage { private final Tracer tracer; CreatingBaggage(Tracer tracer) { this.tracer = tracer; } void doSomething() { try (BaggageInScope scope = this.tracer.createBaggageInScope(""baggage1"", ""value1"")) { // Business logic } } } This example creates baggage named baggage1 with the value value1 . The baggage is automatically propagated over the network if you’re using W3C propagation. If you’re using B3 propagation, baggage is not automatically propagated. To manually propagate baggage over the network, use the management.tracing.baggage.remote-fields configuration property (this works for W3C, too). For the example above, setting this property to baggage1 results in an HTTP header baggage1: value1 . If you want to propagate the baggage to the MDC, use the management.tracing.baggage.correlation.fields configuration property. For the example above, setting this property to baggage1 results in an MDC entry named baggage1 . Tests: Tracing components which are reporting data are not auto-configured when using @SpringBootTest . See Using Tracing(../testing/spring-boot-applications.html#testing.spring-boot-applications.tracing) for more details."
"https://docs.spring.io/spring-boot/reference/actuator/auditing.html","Auditing: Once Spring Security is in play, Spring Boot Actuator has a flexible audit framework that publishes events (by default, “authentication success”, “failure” and “access denied” exceptions). This feature can be very useful for reporting and for implementing a lock-out policy based on authentication failures. You can enable auditing by providing a bean of type AuditEventRepository in your application’s configuration. For convenience, Spring Boot offers an InMemoryAuditEventRepository . InMemoryAuditEventRepository has limited capabilities, and we recommend using it only for development environments. For production environments, consider creating your own alternative AuditEventRepository implementation. Custom Auditing: To customize published security events, you can provide your own implementations of AbstractAuthenticationAuditListener and AbstractAuthorizationAuditListener . You can also use the audit services for your own business events. To do so, either inject the AuditEventRepository bean into your own components and use that directly or publish an AuditApplicationEvent with the Spring ApplicationEventPublisher (by implementing ApplicationEventPublisherAware )."
"https://docs.spring.io/spring-boot/reference/actuator/http-exchanges.html","Recording HTTP Exchanges: You can enable recording of HTTP exchanges by providing a bean of type HttpExchangeRepository in your application’s configuration. For convenience, Spring Boot offers InMemoryHttpExchangeRepository , which, by default, stores the last 100 request-response exchanges. InMemoryHttpExchangeRepository is limited compared to tracing solutions, and we recommend using it only for development environments. For production environments, we recommend using a production-ready tracing or observability solution, such as Zipkin or OpenTelemetry. Alternatively, you can create your own HttpExchangeRepository . You can use the httpexchanges endpoint to obtain information about the request-response exchanges that are stored in the HttpExchangeRepository . Custom HTTP Exchange Recording: To customize the items that are included in each recorded exchange, use the management.httpexchanges.recording.include configuration property. To disable recoding entirely, set management.httpexchanges.recording.enabled to false ."
"https://docs.spring.io/spring-boot/reference/actuator/process-monitoring.html","Process Monitoring: In the spring-boot module, you can find two classes to create files that are often useful for process monitoring: ApplicationPidFileWriter creates a file that contains the application PID (by default, in the application directory with a file name of application.pid ). WebServerPortFileWriter creates a file (or files) that contain the ports of the running web server (by default, in the application directory with a file name of application.port ). By default, these writers are not activated, but you can enable them: Extending Configuration(#actuator.process-monitoring.configuration) Programmatically Enabling Process Monitoring(#actuator.process-monitoring.programmatically) Extending Configuration: In the META-INF/spring.factories file, you can activate the listener (or listeners) that writes a PID file: org.springframework.context.ApplicationListener=\ org.springframework.boot.context.ApplicationPidFileWriter,\ org.springframework.boot.web.context.WebServerPortFileWriter Programmatically Enabling Process Monitoring: You can also activate a listener by invoking the SpringApplication.addListeners(…​) method and passing the appropriate Writer object. This method also lets you customize the file name and path in the Writer constructor."
"https://docs.spring.io/spring-boot/reference/actuator/cloud-foundry.html","Cloud Foundry Support: Spring Boot’s actuator module includes additional support that is activated when you deploy to a compatible Cloud Foundry instance. The /cloudfoundryapplication path provides an alternative secured route to all @Endpoint beans. The extended support lets Cloud Foundry management UIs (such as the web application that you can use to view deployed applications) be augmented with Spring Boot actuator information. For example, an application status page can include full health information instead of the typical “running” or “stopped” status. The /cloudfoundryapplication path is not directly accessible to regular users. To use the endpoint, you must pass a valid UAA token with the request. Disabling Extended Cloud Foundry Actuator Support: If you want to fully disable the /cloudfoundryapplication endpoints, you can add the following setting to your application.properties file: Properties YAML management.cloudfoundry.enabled=false management: cloudfoundry: enabled: false Cloud Foundry Self-signed Certificates: By default, the security verification for /cloudfoundryapplication endpoints makes SSL calls to various Cloud Foundry services. If your Cloud Foundry UAA or Cloud Controller services use self-signed certificates, you need to set the following property: Properties YAML management.cloudfoundry.skip-ssl-validation=true management: cloudfoundry: skip-ssl-validation: true Custom Context Path: If the server’s context-path has been configured to anything other than / , the Cloud Foundry endpoints are not available at the root of the application. For example, if server.servlet.context-path=/app , Cloud Foundry endpoints are available at /app/cloudfoundryapplication/* . If you expect the Cloud Foundry endpoints to always be available at /cloudfoundryapplication/* , regardless of the server’s context-path, you need to explicitly configure that in your application. The configuration differs, depending on the web server in use. For Tomcat, you can add the following configuration: Java Kotlin import java.io.IOException; import java.util.Collections; import jakarta.servlet.GenericServlet; import jakarta.servlet.Servlet; import jakarta.servlet.ServletContainerInitializer; import jakarta.servlet.ServletContext; import jakarta.servlet.ServletException; import jakarta.servlet.ServletRequest; import jakarta.servlet.ServletResponse; import org.apache.catalina.Host; import org.apache.catalina.core.StandardContext; import org.apache.catalina.startup.Tomcat; import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory; import org.springframework.boot.web.servlet.ServletContextInitializer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyCloudFoundryConfiguration { @Bean public TomcatServletWebServerFactory servletWebServerFactory() { return new TomcatServletWebServerFactory() { @Override protected void prepareContext(Host host, ServletContextInitializer[] initializers) { super.prepareContext(host, initializers); StandardContext child = new StandardContext(); child.addLifecycleListener(new Tomcat.FixContextListener()); child.setPath(""/cloudfoundryapplication""); ServletContainerInitializer initializer = getServletContextInitializer(getContextPath()); child.addServletContainerInitializer(initializer, Collections.emptySet()); child.setCrossContext(true); host.addChild(child); } }; } private ServletContainerInitializer getServletContextInitializer(String contextPath) { return (classes, context) -> { Servlet servlet = new GenericServlet() { @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { ServletContext context = req.getServletContext().getContext(contextPath); context.getRequestDispatcher(""/cloudfoundryapplication"").forward(req, res); } }; context.addServlet(""cloudfoundry"", servlet).addMapping(""/*""); }; } } import jakarta.servlet.GenericServlet import jakarta.servlet.Servlet import jakarta.servlet.ServletContainerInitializer import jakarta.servlet.ServletContext import jakarta.servlet.ServletException import jakarta.servlet.ServletRequest import jakarta.servlet.ServletResponse import org.apache.catalina.Host import org.apache.catalina.core.StandardContext import org.apache.catalina.startup.Tomcat.FixContextListener import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory import org.springframework.boot.web.servlet.ServletContextInitializer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import java.io.IOException import java.util.Collections.emptySet @Configuration(proxyBeanMethods = false) class MyCloudFoundryConfiguration { @Bean fun servletWebServerFactory(): TomcatServletWebServerFactory { return object : TomcatServletWebServerFactory() { override fun prepareContext(host: Host, initializers: Array<ServletContextInitializer>) { super.prepareContext(host, initializers) val child = StandardContext() child.addLifecycleListener(FixContextListener()) child.path = ""/cloudfoundryapplication"" val initializer = getServletContextInitializer(contextPath) child.addServletContainerInitializer(initializer, emptySet()) child.crossContext = true host.addChild(child) } } } private fun getServletContextInitializer(contextPath: String): ServletContainerInitializer { return ServletContainerInitializer { classes: Set<Class<*>?>?, context: ServletContext -> val servlet: Servlet = object : GenericServlet() { @Throws(ServletException::class, IOException::class) override fun service(req: ServletRequest, res: ServletResponse) { val servletContext = req.servletContext.getContext(contextPath) servletContext.getRequestDispatcher(""/cloudfoundryapplication"").forward(req, res) } } context.addServlet(""cloudfoundry"", servlet).addMapping(""/*"") } } } If you’re using a Webflux based application, you can use the following configuration: Java Kotlin import java.util.Map; import reactor.core.publisher.Mono; import org.springframework.boot.autoconfigure.web.reactive.WebFluxProperties; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.server.reactive.ContextPathCompositeHandler; import org.springframework.http.server.reactive.HttpHandler; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.http.server.reactive.ServerHttpResponse; import org.springframework.web.server.adapter.WebHttpHandlerBuilder; @Configuration(proxyBeanMethods = false) @EnableConfigurationProperties(WebFluxProperties.class) public class MyReactiveCloudFoundryConfiguration { @Bean public HttpHandler httpHandler(ApplicationContext applicationContext, WebFluxProperties properties) { HttpHandler httpHandler = WebHttpHandlerBuilder.applicationContext(applicationContext).build(); return new CloudFoundryHttpHandler(properties.getBasePath(), httpHandler); } private static final class CloudFoundryHttpHandler implements HttpHandler { private final HttpHandler delegate; private final ContextPathCompositeHandler contextPathDelegate; private CloudFoundryHttpHandler(String basePath, HttpHandler delegate) { this.delegate = delegate; this.contextPathDelegate = new ContextPathCompositeHandler(Map.of(basePath, delegate)); } @Override public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) { // Remove underlying context path first (e.g. Servlet container) String path = request.getPath().pathWithinApplication().value(); if (path.startsWith(""/cloudfoundryapplication"")) { return this.delegate.handle(request, response); } else { return this.contextPathDelegate.handle(request, response); } } } } import org.springframework.boot.autoconfigure.web.reactive.WebFluxProperties import org.springframework.boot.context.properties.EnableConfigurationProperties import org.springframework.context.ApplicationContext import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.http.server.reactive.ContextPathCompositeHandler import org.springframework.http.server.reactive.HttpHandler import org.springframework.http.server.reactive.ServerHttpRequest import org.springframework.http.server.reactive.ServerHttpResponse import org.springframework.web.server.adapter.WebHttpHandlerBuilder import reactor.core.publisher.Mono @Configuration(proxyBeanMethods = false) @EnableConfigurationProperties(WebFluxProperties::class) class MyReactiveCloudFoundryConfiguration { @Bean fun httpHandler(applicationContext: ApplicationContext, properties: WebFluxProperties): HttpHandler { val httpHandler = WebHttpHandlerBuilder.applicationContext(applicationContext).build() return CloudFoundryHttpHandler(properties.basePath, httpHandler) } private class CloudFoundryHttpHandler(basePath: String, private val delegate: HttpHandler) : HttpHandler { private val contextPathDelegate = ContextPathCompositeHandler(mapOf(basePath to delegate)) override fun handle(request: ServerHttpRequest, response: ServerHttpResponse): Mono<Void> { // Remove underlying context path first (e.g. Servlet container) val path = request.path.pathWithinApplication().value() return if (path.startsWith(""/cloudfoundryapplication"")) { delegate.handle(request, response) } else { contextPathDelegate.handle(request, response) } } } }"
"https://docs.spring.io/spring-boot/how-to/index.html","How-to Guides: This section provides answers to some common ‘how do I do that…​’ questions that often arise when using Spring Boot. Its coverage is not exhaustive, but it does cover quite a lot. If you have a specific problem that we do not cover here, you might want to check stackoverflow.com(https://stackoverflow.com/tags/spring-boot) to see if someone has already provided an answer. This is also a great place to ask new questions (please use the spring-boot tag). We are also more than happy to extend this section. If you want to add a ‘how-to’, send us a pull request(https://github.com/spring-projects/spring-boot) ."
"https://docs.spring.io/spring-boot/how-to/application.html","Spring Boot Application: This section includes topics relating directly to Spring Boot applications. Create Your Own FailureAnalyzer: FailureAnalyzer(../api/java/org/springframework/boot/diagnostics/FailureAnalyzer.html) is a great way to intercept an exception on startup and turn it into a human-readable message, wrapped in a FailureAnalysis(../api/java/org/springframework/boot/diagnostics/FailureAnalysis.html) . Spring Boot provides such an analyzer for application-context-related exceptions, JSR-303 validations, and more. You can also create your own. AbstractFailureAnalyzer is a convenient extension of FailureAnalyzer that checks the presence of a specified exception type in the exception to handle. You can extend from that so that your implementation gets a chance to handle the exception only when it is actually present. If, for whatever reason, you cannot handle the exception, return null to give another implementation a chance to handle the exception. FailureAnalyzer implementations must be registered in META-INF/spring.factories . The following example registers ProjectConstraintViolationFailureAnalyzer : org.springframework.boot.diagnostics.FailureAnalyzer=\ com.example.ProjectConstraintViolationFailureAnalyzer If you need access to the BeanFactory or the Environment , declare them as constructor arguments in your FailureAnalyzer implementation. Troubleshoot Auto-configuration: The Spring Boot auto-configuration tries its best to “do the right thing”, but sometimes things fail, and it can be hard to tell why. There is a really useful ConditionEvaluationReport available in any Spring Boot ApplicationContext . You can see it if you enable DEBUG logging output. If you use the spring-boot-actuator (see the Actuator(actuator.html) section), there is also a conditions endpoint that renders the report in JSON. Use that endpoint to debug the application and see what features have been added (and which have not been added) by Spring Boot at runtime. Many more questions can be answered by looking at the source code and the API documentation. When reading the code, remember the following rules of thumb: Look for classes called *AutoConfiguration and read their sources. Pay special attention to the @Conditional* annotations to find out what features they enable and when. Add --debug to the command line or the System property -Ddebug to get a log on the console of all the auto-configuration decisions that were made in your app. In a running application with actuator enabled, look at the conditions endpoint ( /actuator/conditions or the JMX equivalent) for the same information. Look for classes that are @ConfigurationProperties (such as ServerProperties(../api/java/org/springframework/boot/autoconfigure/web/ServerProperties.html) ) and read from there the available external configuration options. The @ConfigurationProperties annotation has a name attribute that acts as a prefix to external properties. Thus, ServerProperties has prefix=""server"" and its configuration properties are server.port , server.address , and others. In a running application with actuator enabled, look at the configprops endpoint. Look for uses of the bind method on the Binder to pull configuration values explicitly out of the Environment in a relaxed manner. It is often used with a prefix. Look for @Value annotations that bind directly to the Environment . Look for @ConditionalOnExpression annotations that switch features on and off in response to SpEL expressions, normally evaluated with placeholders resolved from the Environment . Customize the Environment or ApplicationContext Before It Starts: A SpringApplication has ApplicationListeners and ApplicationContextInitializers that are used to apply customizations to the context or environment. Spring Boot loads a number of such customizations for use internally from META-INF/spring.factories . There is more than one way to register additional customizations: Programmatically, per application, by calling the addListeners and addInitializers methods on SpringApplication before you run it. Declaratively, for all applications, by adding a META-INF/spring.factories and packaging a jar file that the applications all use as a library. The SpringApplication sends some special ApplicationEvents to the listeners (some even before the context is created) and then registers the listeners for events published by the ApplicationContext as well. See Application Events and Listeners(../reference/features/spring-application.html#features.spring-application.application-events-and-listeners) in the “Spring Boot Features” section for a complete list. It is also possible to customize the Environment before the application context is refreshed by using EnvironmentPostProcessor . Each implementation should be registered in META-INF/spring.factories , as shown in the following example: org.springframework.boot.env.EnvironmentPostProcessor=com.example.YourEnvironmentPostProcessor The implementation can load arbitrary files and add them to the Environment . For instance, the following example loads a YAML configuration file from the classpath: Java Kotlin import java.io.IOException; import org.springframework.boot.SpringApplication; import org.springframework.boot.env.EnvironmentPostProcessor; import org.springframework.boot.env.YamlPropertySourceLoader; import org.springframework.core.env.ConfigurableEnvironment; import org.springframework.core.env.PropertySource; import org.springframework.core.io.ClassPathResource; import org.springframework.core.io.Resource; import org.springframework.util.Assert; public class MyEnvironmentPostProcessor implements EnvironmentPostProcessor { private final YamlPropertySourceLoader loader = new YamlPropertySourceLoader(); @Override public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) { Resource path = new ClassPathResource(""com/example/myapp/config.yml""); PropertySource<?> propertySource = loadYaml(path); environment.getPropertySources().addLast(propertySource); } private PropertySource<?> loadYaml(Resource path) { Assert.isTrue(path.exists(), () -> ""Resource "" + path + "" does not exist""); try { return this.loader.load(""custom-resource"", path).get(0); } catch (IOException ex) { throw new IllegalStateException(""Failed to load yaml configuration from "" + path, ex); } } } import org.springframework.boot.SpringApplication import org.springframework.boot.env.EnvironmentPostProcessor import org.springframework.boot.env.YamlPropertySourceLoader import org.springframework.core.env.ConfigurableEnvironment import org.springframework.core.env.PropertySource import org.springframework.core.io.ClassPathResource import org.springframework.core.io.Resource import org.springframework.util.Assert import java.io.IOException class MyEnvironmentPostProcessor : EnvironmentPostProcessor { private val loader = YamlPropertySourceLoader() override fun postProcessEnvironment(environment: ConfigurableEnvironment, application: SpringApplication) { val path: Resource = ClassPathResource(""com/example/myapp/config.yml"") val propertySource = loadYaml(path) environment.propertySources.addLast(propertySource) } private fun loadYaml(path: Resource): PropertySource<*> { Assert.isTrue(path.exists()) { ""Resource $path does not exist"" } return try { loader.load(""custom-resource"", path)[0] } catch (ex: IOException) { throw IllegalStateException(""Failed to load yaml configuration from $path"", ex) } } } The Environment has already been prepared with all the usual property sources that Spring Boot loads by default. It is therefore possible to get the location of the file from the environment. The preceding example adds the custom-resource property source at the end of the list so that a key defined in any of the usual other locations takes precedence. A custom implementation may define another order. While using @PropertySource on your @SpringBootApplication may seem to be a convenient way to load a custom resource in the Environment , we do not recommend it. Such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins. Build an ApplicationContext Hierarchy (Adding a Parent or Root Context): You can use the ApplicationBuilder class to create parent/child ApplicationContext hierarchies. See Fluent Builder API(../reference/features/spring-application.html#features.spring-application.fluent-builder-api) in the “Spring Boot Features” section for more information. Create a Non-web Application: Not all Spring applications have to be web applications (or web services). If you want to execute some code in a main method but also bootstrap a Spring application to set up the infrastructure to use, you can use the SpringApplication features of Spring Boot. A SpringApplication changes its ApplicationContext class, depending on whether it thinks it needs a web application or not. The first thing you can do to help it is to leave server-related dependencies (such as the servlet API) off the classpath. If you cannot do that (for example, if you run two applications from the same code base) then you can explicitly call setWebApplicationType(WebApplicationType.NONE) on your SpringApplication instance or set the applicationContextClass property (through the Java API or with external properties). Application code that you want to run as your business logic can be implemented as a CommandLineRunner and dropped into the context as a @Bean definition."
"https://docs.spring.io/spring-boot/how-to/properties-and-configuration.html","Properties and Configuration: This section includes topics about setting and reading properties and configuration settings and their interaction with Spring Boot applications. Automatically Expand Properties at Build Time: Rather than hardcoding some properties that are also specified in your project’s build configuration, you can automatically expand them by instead using the existing build configuration. This is possible in both Maven and Gradle. Automatic Property Expansion Using Maven: You can automatically expand properties in the Maven project by using resource filtering. If you use the spring-boot-starter-parent , you can then refer to your Maven ‘project properties’ with @..@ placeholders, as shown in the following example: Properties YAML [email protected](/cdn-cgi/l/email-protection) @ [email protected](/cdn-cgi/l/email-protection) @ app: encoding: ""@project.build.sourceEncoding@"" java: version: ""@java.version@"" Only production configuration is filtered that way (in other words, no filtering is applied on src/test/resources ). If you enable the addResources flag, the spring-boot:run goal can add src/main/resources directly to the classpath (for hot reloading purposes). Doing so circumvents the resource filtering and this feature. Instead, you can use the exec:java goal or customize the plugin’s configuration. See the plugin usage page(../maven-plugin/using.html) for more details. If you do not use the starter parent, you need to include the following element inside the <build/> element of your pom.xml : <resources> <resource> <directory>src/main/resources</directory> <filtering>true</filtering> </resource> </resources> You also need to include the following element inside <plugins/> : <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-resources-plugin</artifactId> <version>2.7</version> <configuration> <delimiters> <delimiter>@</delimiter> </delimiters> <useDefaultDelimiters>false</useDefaultDelimiters> </configuration> </plugin> The useDefaultDelimiters property is important if you use standard Spring placeholders (such as ${placeholder} ) in your configuration. If that property is not set to false , these may be expanded by the build. Automatic Property Expansion Using Gradle: You can automatically expand properties from the Gradle project by configuring the Java plugin’s processResources task to do so, as shown in the following example: tasks.named('processResources') { expand(project.properties) } You can then refer to your Gradle project’s properties by using placeholders, as shown in the following example: Properties YAML app.name=${name} app.description=${description} app: name: ""${name}"" description: ""${description}"" Gradle’s expand method uses Groovy’s SimpleTemplateEngine , which transforms ${..} tokens. The ${..} style conflicts with Spring’s own property placeholder mechanism. To use Spring property placeholders together with automatic expansion, escape the Spring property placeholders as follows: \${..} . Externalize the Configuration of SpringApplication: A SpringApplication has bean property setters, so you can use its Java API as you create the application to modify its behavior. Alternatively, you can externalize the configuration by setting properties in spring.main.* . For example, in application.properties , you might have the following settings: Properties YAML spring.main.web-application-type=none spring.main.banner-mode=off spring: main: web-application-type: ""none"" banner-mode: ""off"" Then the Spring Boot banner is not printed on startup, and the application is not starting an embedded web server. Properties defined in external configuration override and replace the values specified with the Java API, with the notable exception of the primary sources. Primary sources are those provided to the SpringApplication constructor: Java Kotlin import org.springframework.boot.Banner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication application = new SpringApplication(MyApplication.class); application.setBannerMode(Banner.Mode.OFF); application.run(args); } } import org.springframework.boot.Banner import org.springframework.boot.SpringApplication import org.springframework.boot.autoconfigure.SpringBootApplication @SpringBootApplication object MyApplication { @JvmStatic fun main(args: Array<String>) { val application = SpringApplication(MyApplication::class.java) application.setBannerMode(Banner.Mode.OFF) application.run(*args) } } Or to sources(…​) method of a SpringApplicationBuilder : Java Kotlin import org.springframework.boot.Banner; import org.springframework.boot.builder.SpringApplicationBuilder; public class MyApplication { public static void main(String[] args) { new SpringApplicationBuilder() .bannerMode(Banner.Mode.OFF) .sources(MyApplication.class) .run(args); } } import org.springframework.boot.Banner import org.springframework.boot.builder.SpringApplicationBuilder object MyApplication { @JvmStatic fun main(args: Array<String>) { SpringApplicationBuilder() .bannerMode(Banner.Mode.OFF) .sources(MyApplication::class.java) .run(*args) } } Given the examples above, if we have the following configuration: Properties YAML spring.main.sources=com.example.MyDatabaseConfig,com.example.MyJmsConfig spring.main.banner-mode=console spring: main: sources: ""com.example.MyDatabaseConfig,com.example.MyJmsConfig"" banner-mode: ""console"" The actual application will show the banner (as overridden by configuration) and use three sources for the ApplicationContext . The application sources are: MyApplication (from the code) MyDatabaseConfig (from the external config) MyJmsConfig (from the external config) Change the Location of External Properties of an Application: By default, properties from different sources are added to the Spring Environment in a defined order (see Externalized Configuration(../reference/features/external-config.html) in the “Spring Boot Features” section for the exact order). You can also provide the following System properties (or environment variables) to change the behavior: spring.config.name ( SPRING_CONFIG_NAME ): Defaults to application as the root of the file name. spring.config.location ( SPRING_CONFIG_LOCATION ): The file to load (such as a classpath resource or a URL). A separate Environment property source is set up for this document and it can be overridden by system properties, environment variables, or the command line. No matter what you set in the environment, Spring Boot always loads application.properties as described above. By default, if YAML is used, then files with the ‘.yaml’ and ‘.yml’ extensions are also added to the list. If you want detailed information about the files that are being loaded you can set the logging level(../reference/features/logging.html#features.logging.log-levels) of org.springframework.boot.context.config to trace . Use ‘Short’ Command Line Arguments: Some people like to use (for example) --port=9000 instead of --server.port=9000 to set configuration properties on the command line. You can enable this behavior by using placeholders in application.properties , as shown in the following example: Properties YAML server.port=${port:8080} server: port: ""${port:8080}"" If you inherit from the spring-boot-starter-parent POM, the default filter token of the maven-resources-plugins has been changed from ${*} to @ (that is, @maven.token@ instead of ${maven.token} ) to prevent conflicts with Spring-style placeholders. If you have enabled Maven filtering for the application.properties directly, you may want to also change the default filter token to use other delimiters(https://maven.apache.org/plugins/maven-resources-plugin/resources-mojo.html#delimiters) . In this specific case, the port binding works in a PaaS environment such as Heroku or Cloud Foundry. On those two platforms, the PORT environment variable is set automatically and Spring can bind to capitalized synonyms for Environment properties. Use YAML for External Properties: YAML is a superset of JSON and, as such, is a convenient syntax for storing external properties in a hierarchical format, as shown in the following example: spring: application: name: ""cruncher"" datasource: driver-class-name: ""com.mysql.jdbc.Driver"" url: ""jdbc:mysql://localhost/test"" server: port: 9000 Create a file called application.yaml and put it in the root of your classpath. Then add snakeyaml to your dependencies (Maven coordinates org.yaml:snakeyaml , already included if you use the spring-boot-starter ). A YAML file is parsed to a Java Map<String,Object> (like a JSON object), and Spring Boot flattens the map so that it is one level deep and has period-separated keys, as many people are used to with Properties files in Java. The preceding example YAML corresponds to the following application.properties file: spring.application.name=cruncher spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost/test server.port=9000 See Working With YAML(../reference/features/external-config.html#features.external-config.yaml) in the ""`Spring Boot Features'"" section for more information about YAML. Set the Active Spring Profiles: The Spring Environment has an API for this, but you would normally set a System property ( spring.profiles.active ) or an OS environment variable ( SPRING_PROFILES_ACTIVE ). Also, you can launch your application with a -D argument (remember to put it before the main class or jar archive), as follows: $ java -jar -Dspring.profiles.active=production demo-0.0.1-SNAPSHOT.jar In Spring Boot, you can also set the active profile in application.properties , as shown in the following example: Properties YAML spring.profiles.active=production spring: profiles: active: ""production"" A value set this way is replaced by the System property or environment variable setting but not by the SpringApplicationBuilder.profiles() method. Thus, the latter Java API can be used to augment the profiles without changing the defaults. See Profiles(../reference/features/profiles.html) in the “Spring Boot Features” section for more information. Set the Default Profile Name: The default profile is a profile that is enabled if no profile is active. By default, the name of the default profile is default , but it could be changed using a System property ( spring.profiles.default ) or an OS environment variable ( SPRING_PROFILES_DEFAULT ). In Spring Boot, you can also set the default profile name in application.properties , as shown in the following example: Properties YAML spring.profiles.default=dev spring: profiles: default: ""dev"" See Profiles(../reference/features/profiles.html) in the “Spring Boot Features” section for more information. Change Configuration Depending on the Environment: Spring Boot supports multi-document YAML and Properties files (see Working With Multi-Document Files(../reference/features/external-config.html#features.external-config.files.multi-document) for details) which can be activated conditionally based on the active profiles. If a document contains a spring.config.activate.on-profile key, then the profiles value (a comma-separated list of profiles or a profile expression) is fed into the Spring Environment.acceptsProfiles() method. If the profile expression matches, then that document is included in the final merge (otherwise, it is not), as shown in the following example: Properties YAML server.port=9000 #--- spring.config.activate.on-profile=development server.port=9001 #--- spring.config.activate.on-profile=production server.port=0 server: port: 9000 --- spring: config: activate: on-profile: ""development"" server: port: 9001 --- spring: config: activate: on-profile: ""production"" server: port: 0 In the preceding example, the default port is 9000. However, if the Spring profile called ‘development’ is active, then the port is 9001. If ‘production’ is active, then the port is 0. The documents are merged in the order in which they are encountered. Later values override earlier values. Discover Built-in Options for External Properties: Spring Boot binds external properties from application.properties (or YAML files and other places) into an application at runtime. There is not (and technically cannot be) an exhaustive list of all supported properties in a single location, because contributions can come from additional jar files on your classpath. A running application with the Actuator features has a configprops endpoint that shows all the bound and bindable properties available through @ConfigurationProperties . The appendix includes an application.properties(../appendix/application-properties/index.html) example with a list of the most common properties supported by Spring Boot. The definitive list comes from searching the source code for @ConfigurationProperties and @Value annotations as well as the occasional use of Binder . For more about the exact ordering of loading properties, see Externalized Configuration(../reference/features/external-config.html) ."
"https://docs.spring.io/spring-boot/how-to/webserver.html","Embedded Web Servers: Each Spring Boot web application includes an embedded web server. This feature leads to a number of how-to questions, including how to change the embedded server and how to configure the embedded server. This section answers those questions. Use Another Web Server: Many Spring Boot starters include default embedded containers. For servlet stack applications, the spring-boot-starter-web includes Tomcat by including spring-boot-starter-tomcat , but you can use spring-boot-starter-jetty or spring-boot-starter-undertow instead. For reactive stack applications, the spring-boot-starter-webflux includes Reactor Netty by including spring-boot-starter-reactor-netty , but you can use spring-boot-starter-tomcat , spring-boot-starter-jetty , or spring-boot-starter-undertow instead. When switching to a different HTTP server, you need to swap the default dependencies for those that you need instead. To help with this process, Spring Boot provides a separate starter for each of the supported HTTP servers. The following Maven example shows how to exclude Tomcat and include Jetty for Spring MVC: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> <exclusions> <!-- Exclude the Tomcat dependency --> <exclusion> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-tomcat</artifactId> </exclusion> </exclusions> </dependency> <!-- Use Jetty instead --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-jetty</artifactId> </dependency> The following Gradle example configures the necessary dependencies and a module replacement(https://docs.gradle.org/current/userguide/resolution_rules.html#sec:module_replacement) to use Undertow in place of Reactor Netty for Spring WebFlux: dependencies { implementation ""org.springframework.boot:spring-boot-starter-undertow"" implementation ""org.springframework.boot:spring-boot-starter-webflux"" modules { module(""org.springframework.boot:spring-boot-starter-reactor-netty"") { replacedBy(""org.springframework.boot:spring-boot-starter-undertow"", ""Use Undertow instead of Reactor Netty"") } } } spring-boot-starter-reactor-netty is required to use the WebClient class, so you may need to keep a dependency on Netty even when you need to include a different HTTP server. Disabling the Web Server: If your classpath contains the necessary bits to start a web server, Spring Boot will automatically start it. To disable this behavior configure the WebApplicationType in your application.properties , as shown in the following example: Properties YAML spring.main.web-application-type=none spring: main: web-application-type: ""none"" Change the HTTP Port: In a standalone application, the main HTTP port defaults to 8080 but can be set with server.port (for example, in application.properties or as a System property). Thanks to relaxed binding of Environment values, you can also use SERVER_PORT (for example, as an OS environment variable). To switch off the HTTP endpoints completely but still create a WebApplicationContext , use server.port=-1 (doing so is sometimes useful for testing). For more details, see Customizing Embedded Servlet Containers(../reference/web/servlet.html#web.servlet.embedded-container.customizing) in the ‘Spring Boot Features’ section, or the ServerProperties(../api/java/org/springframework/boot/autoconfigure/web/ServerProperties.html) class. Use a Random Unassigned HTTP Port: To scan for a free port (using OS natives to prevent clashes) use server.port=0 . Discover the HTTP Port at Runtime: You can access the port the server is running on from log output or from the WebServerApplicationContext through its WebServer . The best way to get that and be sure it has been initialized is to add a @Bean of type ApplicationListener<WebServerInitializedEvent> and pull the container out of the event when it is published. Tests that use @SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT) can also inject the actual port into a field by using the @LocalServerPort annotation, as shown in the following example: Java Kotlin import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.context.SpringBootTest.WebEnvironment; import org.springframework.boot.test.web.server.LocalServerPort; @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) class MyWebIntegrationTests { @LocalServerPort int port; // ... } import org.springframework.boot.test.context.SpringBootTest import org.springframework.boot.test.context.SpringBootTest.WebEnvironment import org.springframework.boot.test.web.server.LocalServerPort @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) class MyWebIntegrationTests { @LocalServerPort var port = 0 // ... } @LocalServerPort is a meta-annotation for @Value(""${local.server.port}"") . Do not try to inject the port in a regular application. As we just saw, the value is set only after the container has been initialized. Contrary to a test, application code callbacks are processed early (before the value is actually available). Enable HTTP Response Compression: HTTP response compression is supported by Jetty, Tomcat, Reactor Netty, and Undertow. It can be enabled in application.properties , as follows: Properties YAML server.compression.enabled=true server: compression: enabled: true By default, responses must be at least 2048 bytes in length for compression to be performed. You can configure this behavior by setting the server.compression.min-response-size property. By default, responses are compressed only if their content type is one of the following: text/html text/xml text/plain text/css text/javascript application/javascript application/json application/xml You can configure this behavior by setting the server.compression.mime-types property. Configure SSL: SSL can be configured declaratively by setting the various server.ssl.* properties, typically in application.properties or application.yaml . See Ssl(../api/java/org/springframework/boot/web/server/Ssl.html) for details of all of the supported properties. The following example shows setting SSL properties using a Java KeyStore file: Properties YAML server.port=8443 server.ssl.key-store=classpath:keystore.jks server.ssl.key-store-password=secret server.ssl.key-password=another-secret server: port: 8443 ssl: key-store: ""classpath:keystore.jks"" key-store-password: ""secret"" key-password: ""another-secret"" Using configuration such as the preceding example means the application no longer supports a plain HTTP connector at port 8080. Spring Boot does not support the configuration of both an HTTP connector and an HTTPS connector through application.properties . If you want to have both, you need to configure one of them programmatically. We recommend using application.properties to configure HTTPS, as the HTTP connector is the easier of the two to configure programmatically. Using PEM-encoded files: You can use PEM-encoded files instead of Java KeyStore files. You should use PKCS#8 key files wherever possible. PEM-encoded PKCS#8 key files start with a -----BEGIN PRIVATE KEY----- or -----BEGIN ENCRYPTED PRIVATE KEY----- header. If you have files in other formats, e.g., PKCS#1 ( -----BEGIN RSA PRIVATE KEY----- ) or SEC 1 ( -----BEGIN EC PRIVATE KEY----- ), you can convert them to PKCS#8 using OpenSSL: openssl pkcs8 -topk8 -nocrypt -in <input file> -out <output file> The following example shows setting SSL properties using PEM-encoded certificate and private key files: Properties YAML server.port=8443 server.ssl.certificate=classpath:my-cert.crt server.ssl.certificate-private-key=classpath:my-cert.key server.ssl.trust-certificate=classpath:ca-cert.crt server: port: 8443 ssl: certificate: ""classpath:my-cert.crt"" certificate-private-key: ""classpath:my-cert.key"" trust-certificate: ""classpath:ca-cert.crt"" Using SSL Bundles: Alternatively, the SSL trust material can be configured in an SSL bundle(../reference/features/ssl.html) and applied to the web server as shown in this example: Properties YAML server.port=8443 server.ssl.bundle=example server: port: 8443 ssl: bundle: ""example"" The server.ssl.bundle property can not be combined with the discrete Java KeyStore or PEM property options under server.ssl . Configure Server Name Indication: Tomcat, Netty, and Undertow can be configured to use unique SSL trust material for individual host names to support Server Name Indication (SNI). SNI configuration is not supported with Jetty, but Jetty can automatically set up SNI(https://eclipse.dev/jetty/documentation/jetty-12/operations-guide/index.html#og-protocols-ssl-sni) if multiple certificates are provided to it. Assuming SSL bundles(../reference/features/ssl.html) named web , web-alt1 , and web-alt2 have been configured, the following configuration can be used to assign each bundle to a host name served by the embedded web server: Properties YAML server.port=8443 server.ssl.bundle=web server.ssl.server-name-bundles[0].server-name=alt1.example.com server.ssl.server-name-bundles[0].bundle=web-alt1 server.ssl.server-name-bundles[1].server-name=alt2.example.com server.ssl.server-name-bundles[1].bundle=web-alt2 server: port: 8443 ssl: bundle: ""web"" server-name-bundles: - server-name: ""alt1.example.com"" bundle: ""web-alt1"" - server-name: ""alt2.example.com"" bundle: ""web-alt2"" The bundle specified with server.ssl.bundle will be used for the default host, and for any client that does support SNI. This default bundle must be configured if any server.ssl.server-name-bundles are configured. Configure HTTP/2: You can enable HTTP/2 support in your Spring Boot application with the server.http2.enabled configuration property. Both h2 (HTTP/2 over TLS) and h2c (HTTP/2 over TCP) are supported. To use h2 , SSL must also be enabled. When SSL is not enabled, h2c will be used. You may, for example, want to use h2c when your application is running behind a proxy server(#howto.webserver.use-behind-a-proxy-server) that is performing TLS termination. HTTP/2 With Tomcat: Spring Boot ships by default with Tomcat 10.1.x which supports h2c and h2 out of the box. Alternatively, you can use libtcnative for h2 support if the library and its dependencies are installed on the host operating system. The library directory must be made available, if not already, to the JVM library path. You can do so with a JVM argument such as -Djava.library.path=/usr/local/opt/tomcat-native/lib . More on this in the official Tomcat documentation(https://tomcat.apache.org/tomcat-10.1-doc/apr.html) . HTTP/2 With Jetty: For HTTP/2 support, Jetty requires the additional org.eclipse.jetty.http2:jetty-http2-server dependency. To use h2c no other dependencies are required. To use h2 , you also need to choose one of the following dependencies, depending on your deployment: org.eclipse.jetty:jetty-alpn-java-server to use the JDK built-in support org.eclipse.jetty:jetty-alpn-conscrypt-server and the Conscrypt library(https://www.conscrypt.org/) HTTP/2 With Reactor Netty: The spring-boot-webflux-starter is using by default Reactor Netty as a server. Reactor Netty supports h2c and h2 out of the box. For optimal runtime performance, this server also supports h2 with native libraries. To enable that, your application needs to have an additional dependency. Spring Boot manages the version for the io.netty:netty-tcnative-boringssl-static ""uber jar"", containing native libraries for all platforms. Developers can choose to import only the required dependencies using a classifier (see the Netty official documentation(https://netty.io/wiki/forked-tomcat-native.html) ). HTTP/2 With Undertow: Undertow supports h2c and h2 out of the box. Configure the Web Server: Generally, you should first consider using one of the many available configuration keys and customize your web server by adding new entries in your application.properties or application.yaml file. See Discover Built-in Options for External Properties(properties-and-configuration.html#howto.properties-and-configuration.discover-build-in-options-for-external-properties) ). The server.* namespace is quite useful here, and it includes namespaces like server.tomcat.* , server.jetty.* and others, for server-specific features. See the list of Common Application Properties(../appendix/application-properties/index.html) . The previous sections covered already many common use cases, such as compression, SSL or HTTP/2. However, if a configuration key does not exist for your use case, you should then look at WebServerFactoryCustomizer(../api/java/org/springframework/boot/web/server/WebServerFactoryCustomizer.html) . You can declare such a component and get access to the server factory relevant to your choice: you should select the variant for the chosen Server (Tomcat, Jetty, Reactor Netty, Undertow) and the chosen web stack (servlet or reactive). The example below is for Tomcat with the spring-boot-starter-web (servlet stack): Java Kotlin import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory; import org.springframework.boot.web.server.WebServerFactoryCustomizer; import org.springframework.stereotype.Component; @Component public class MyTomcatWebServerCustomizer implements WebServerFactoryCustomizer<TomcatServletWebServerFactory> { @Override public void customize(TomcatServletWebServerFactory factory) { // customize the factory here } } import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory import org.springframework.boot.web.server.WebServerFactoryCustomizer import org.springframework.stereotype.Component @Component class MyTomcatWebServerCustomizer : WebServerFactoryCustomizer<TomcatServletWebServerFactory?> { override fun customize(factory: TomcatServletWebServerFactory?) { // customize the factory here } } Spring Boot uses that infrastructure internally to auto-configure the server. Auto-configured WebServerFactoryCustomizer beans have an order of 0 and will be processed before any user-defined customizers, unless it has an explicit order that states otherwise. Once you have got access to a WebServerFactory using the customizer, you can use it to configure specific parts, like connectors, server resources, or the server itself - all using server-specific APIs. In addition Spring Boot provides: Server Servlet stack Reactive stack Tomcat TomcatServletWebServerFactory TomcatReactiveWebServerFactory Jetty JettyServletWebServerFactory JettyReactiveWebServerFactory Undertow UndertowServletWebServerFactory UndertowReactiveWebServerFactory Reactor N/A NettyReactiveWebServerFactory As a last resort, you can also declare your own WebServerFactory bean, which will override the one provided by Spring Boot. When you do so, auto-configured customizers are still applied on your custom factory, so use that option carefully. Add a Servlet, Filter, or Listener to an Application: In a servlet stack application, that is with the spring-boot-starter-web , there are two ways to add Servlet , Filter , ServletContextListener , and the other listeners supported by the Servlet API to your application: Add a Servlet, Filter, or Listener by Using a Spring Bean(#howto.webserver.add-servlet-filter-listener.spring-bean) Add Servlets, Filters, and Listeners by Using Classpath Scanning(#howto.webserver.add-servlet-filter-listener.using-scanning) Add a Servlet, Filter, or Listener by Using a Spring Bean: To add a Servlet , Filter , or servlet *Listener by using a Spring bean, you must provide a @Bean definition for it. Doing so can be very useful when you want to inject configuration or dependencies. However, you must be very careful that they do not cause eager initialization of too many other beans, because they have to be installed in the container very early in the application lifecycle. (For example, it is not a good idea to have them depend on your DataSource or JPA configuration.) You can work around such restrictions by initializing the beans lazily when first used instead of on initialization. In the case of filters and servlets, you can also add mappings and init parameters by adding a FilterRegistrationBean or a ServletRegistrationBean instead of or in addition to the underlying component. If no dispatcherType is specified on a filter registration, REQUEST is used. This aligns with the servlet specification’s default dispatcher type. Like any other Spring bean, you can define the order of servlet filter beans; please make sure to check the Registering Servlets, Filters, and Listeners as Spring Beans(../reference/web/servlet.html#web.servlet.embedded-container.servlets-filters-listeners.beans) section. Disable Registration of a Servlet or Filter: As described earlier(#howto.webserver.add-servlet-filter-listener.spring-bean) , any Servlet or Filter beans are registered with the servlet container automatically. To disable registration of a particular Filter or Servlet bean, create a registration bean for it and mark it as disabled, as shown in the following example: Java Kotlin import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyFilterConfiguration { @Bean public FilterRegistrationBean<MyFilter> registration(MyFilter filter) { FilterRegistrationBean<MyFilter> registration = new FilterRegistrationBean<>(filter); registration.setEnabled(false); return registration; } } import org.springframework.boot.web.servlet.FilterRegistrationBean import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyFilterConfiguration { @Bean fun registration(filter: MyFilter): FilterRegistrationBean<MyFilter> { val registration = FilterRegistrationBean(filter) registration.isEnabled = false return registration } } Add Servlets, Filters, and Listeners by Using Classpath Scanning: @WebServlet , @WebFilter , and @WebListener annotated classes can be automatically registered with an embedded servlet container by annotating a @Configuration class with @ServletComponentScan and specifying the package(s) containing the components that you want to register. By default, @ServletComponentScan scans from the package of the annotated class. Configure Access Logging: Access logs can be configured for Tomcat, Undertow, and Jetty through their respective namespaces. For instance, the following settings log access on Tomcat with a custom pattern(https://tomcat.apache.org/tomcat-10.1-doc/config/valve.html#Access_Logging) . Properties YAML server.tomcat.basedir=my-tomcat server.tomcat.accesslog.enabled=true server.tomcat.accesslog.pattern=%t %a %r %s (%D microseconds) server: tomcat: basedir: ""my-tomcat"" accesslog: enabled: true pattern: ""%t %a %r %s (%D microseconds)"" The default location for logs is a logs directory relative to the Tomcat base directory. By default, the logs directory is a temporary directory, so you may want to fix Tomcat’s base directory or use an absolute path for the logs. In the preceding example, the logs are available in my-tomcat/logs relative to the working directory of the application. Access logging for Undertow can be configured in a similar fashion, as shown in the following example: Properties YAML server.undertow.accesslog.enabled=true server.undertow.accesslog.pattern=%t %a %r %s (%D milliseconds) server.undertow.options.server.record-request-start-time=true server: undertow: accesslog: enabled: true pattern: ""%t %a %r %s (%D milliseconds)"" options: server: record-request-start-time: true Note that, in addition to enabling access logging and configuring its pattern, recording request start times has also been enabled. This is required when including the response time ( %D ) in the access log pattern. Logs are stored in a logs directory relative to the working directory of the application. You can customize this location by setting the server.undertow.accesslog.dir property. Finally, access logging for Jetty can also be configured as follows: Properties YAML server.jetty.accesslog.enabled=true server.jetty.accesslog.filename=/var/log/jetty-access.log server: jetty: accesslog: enabled: true filename: ""/var/log/jetty-access.log"" By default, logs are redirected to System.err . For more details, see the Jetty documentation. Running Behind a Front-end Proxy Server: If your application is running behind a proxy, a load-balancer or in the cloud, the request information (like the host, port, scheme…​) might change along the way. Your application may be running on 10.10.10.10:8080 , but HTTP clients should only see example.org . RFC7239 ""Forwarded Headers""(https://tools.ietf.org/html/rfc7239) defines the Forwarded HTTP header; proxies can use this header to provide information about the original request. You can configure your application to read those headers and automatically use that information when creating links and sending them to clients in HTTP 302 responses, JSON documents or HTML pages. There are also non-standard headers, like X-Forwarded-Host , X-Forwarded-Port , X-Forwarded-Proto , X-Forwarded-Ssl , and X-Forwarded-Prefix . If the proxy adds the commonly used X-Forwarded-For and X-Forwarded-Proto headers, setting server.forward-headers-strategy to NATIVE is enough to support those. With this option, the Web servers themselves natively support this feature; you can check their specific documentation to learn about specific behavior. If this is not enough, Spring Framework provides a ForwardedHeaderFilter(https://docs.spring.io/spring-framework/reference/6.1/web/webmvc/filters.html#filters-forwarded-headers) for the servlet stack and a ForwardedHeaderTransformer(https://docs.spring.io/spring-framework/reference/6.1/web/webflux/reactive-spring.html#webflux-forwarded-headers) for the reactive stack. You can use them in your application by setting server.forward-headers-strategy to FRAMEWORK . If you are using Tomcat and terminating SSL at the proxy, server.tomcat.redirect-context-root should be set to false . This allows the X-Forwarded-Proto header to be honored before any redirects are performed. If your application runs in a supported Cloud Platform(../api/java/org/springframework/boot/cloud/CloudPlatform.html#enum-constant-summary) , the server.forward-headers-strategy property defaults to NATIVE . In all other instances, it defaults to NONE . Customize Tomcat’s Proxy Configuration: If you use Tomcat, you can additionally configure the names of the headers used to carry “forwarded” information, as shown in the following example: Properties YAML server.tomcat.remoteip.remote-ip-header=x-your-remote-ip-header server.tomcat.remoteip.protocol-header=x-your-protocol-header server: tomcat: remoteip: remote-ip-header: ""x-your-remote-ip-header"" protocol-header: ""x-your-protocol-header"" Tomcat is also configured with a regular expression that matches internal proxies that are to be trusted. See the server.tomcat.remoteip.internal-proxies entry in the appendix(../appendix/application-properties/index.html#application-properties.server.server.tomcat.remoteip.internal-proxies) for its default value. You can customize the valve’s configuration by adding an entry to application.properties , as shown in the following example: Properties YAML server.tomcat.remoteip.internal-proxies=192\.168\.\d{1,3}\.\d{1,3} server: tomcat: remoteip: internal-proxies: ""192\\.168\\.\\d{1,3}\\.\\d{1,3}"" You can trust all proxies by setting the internal-proxies to empty (but do not do so in production). You can take complete control of the configuration of Tomcat’s RemoteIpValve by switching the automatic one off (to do so, set server.forward-headers-strategy=NONE ) and adding a new valve instance using a WebServerFactoryCustomizer bean. Enable Multiple Connectors with Tomcat: You can add an org.apache.catalina.connector.Connector to the TomcatServletWebServerFactory , which can allow multiple connectors, including HTTP and HTTPS connectors, as shown in the following example: Java Kotlin import org.apache.catalina.connector.Connector; import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory; import org.springframework.boot.web.server.WebServerFactoryCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyTomcatConfiguration { @Bean public WebServerFactoryCustomizer<TomcatServletWebServerFactory> connectorCustomizer() { return (tomcat) -> tomcat.addAdditionalTomcatConnectors(createConnector()); } private Connector createConnector() { Connector connector = new Connector(""org.apache.coyote.http11.Http11NioProtocol""); connector.setPort(8081); return connector; } } import org.apache.catalina.connector.Connector import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory import org.springframework.boot.web.server.WebServerFactoryCustomizer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyTomcatConfiguration { @Bean fun connectorCustomizer(): WebServerFactoryCustomizer<TomcatServletWebServerFactory> { return WebServerFactoryCustomizer { tomcat: TomcatServletWebServerFactory -> tomcat.addAdditionalTomcatConnectors( createConnector() ) } } private fun createConnector(): Connector { val connector = Connector(""org.apache.coyote.http11.Http11NioProtocol"") connector.port = 8081 return connector } } Enable Tomcat’s MBean Registry: Embedded Tomcat’s MBean registry is disabled by default. This minimizes Tomcat’s memory footprint. If you want to use Tomcat’s MBeans, for example so that they can be used by Micrometer to expose metrics, you must use the server.tomcat.mbeanregistry.enabled property to do so, as shown in the following example: Properties YAML server.tomcat.mbeanregistry.enabled=true server: tomcat: mbeanregistry: enabled: true Enable Multiple Listeners with Undertow: Add an UndertowBuilderCustomizer to the UndertowServletWebServerFactory and add a listener to the Builder , as shown in the following example: Java Kotlin import io.undertow.Undertow.Builder; import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory; import org.springframework.boot.web.server.WebServerFactoryCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyUndertowConfiguration { @Bean public WebServerFactoryCustomizer<UndertowServletWebServerFactory> undertowListenerCustomizer() { return (factory) -> factory.addBuilderCustomizers(this::addHttpListener); } private Builder addHttpListener(Builder builder) { return builder.addHttpListener(8080, ""0.0.0.0""); } } import io.undertow.Undertow import org.springframework.boot.web.embedded.undertow.UndertowBuilderCustomizer import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory import org.springframework.boot.web.server.WebServerFactoryCustomizer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyUndertowConfiguration { @Bean fun undertowListenerCustomizer(): WebServerFactoryCustomizer<UndertowServletWebServerFactory> { return WebServerFactoryCustomizer { factory: UndertowServletWebServerFactory -> factory.addBuilderCustomizers( UndertowBuilderCustomizer { builder: Undertow.Builder -> addHttpListener(builder) }) } } private fun addHttpListener(builder: Undertow.Builder): Undertow.Builder { return builder.addHttpListener(8080, ""0.0.0.0"") } } Create WebSocket Endpoints Using @ServerEndpoint: If you want to use @ServerEndpoint in a Spring Boot application that used an embedded container, you must declare a single ServerEndpointExporter @Bean , as shown in the following example: Java Kotlin import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.server.standard.ServerEndpointExporter; @Configuration(proxyBeanMethods = false) public class MyWebSocketConfiguration { @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.web.socket.server.standard.ServerEndpointExporter @Configuration(proxyBeanMethods = false) class MyWebSocketConfiguration { @Bean fun serverEndpointExporter(): ServerEndpointExporter { return ServerEndpointExporter() } } The bean shown in the preceding example registers any @ServerEndpoint annotated beans with the underlying WebSocket container. When deployed to a standalone servlet container, this role is performed by a servlet container initializer, and the ServerEndpointExporter bean is not required."
"https://docs.spring.io/spring-boot/how-to/spring-mvc.html","Spring MVC: Spring Boot has a number of starters that include Spring MVC. Note that some starters include a dependency on Spring MVC rather than include it directly. This section answers common questions about Spring MVC and Spring Boot. Write a JSON REST Service: Any Spring @RestController in a Spring Boot application should render JSON response by default as long as Jackson2 is on the classpath, as shown in the following example: Java Kotlin import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class MyController { @RequestMapping(""/thing"") public MyThing thing() { return new MyThing(); } } import org.springframework.web.bind.annotation.RequestMapping import org.springframework.web.bind.annotation.RestController @RestController class MyController { @RequestMapping(""/thing"") fun thing(): MyThing { return MyThing() } } As long as MyThing can be serialized by Jackson2 (true for a normal POJO or Groovy object), then localhost:8080/thing(http://localhost:8080/thing) serves a JSON representation of it by default. Note that, in a browser, you might sometimes see XML responses, because browsers tend to send accept headers that prefer XML. Write an XML REST Service: If you have the Jackson XML extension ( jackson-dataformat-xml ) on the classpath, you can use it to render XML responses. The previous example that we used for JSON would work. To use the Jackson XML renderer, add the following dependency to your project: <dependency> <groupId>com.fasterxml.jackson.dataformat</groupId> <artifactId>jackson-dataformat-xml</artifactId> </dependency> If Jackson’s XML extension is not available and JAXB is available, XML can be rendered with the additional requirement of having MyThing annotated as @XmlRootElement , as shown in the following example: Java Kotlin import jakarta.xml.bind.annotation.XmlRootElement; @XmlRootElement public class MyThing { private String name; // getters/setters ... public String getName() { return this.name; } public void setName(String name) { this.name = name; } } import jakarta.xml.bind.annotation.XmlRootElement @XmlRootElement class MyThing { var name: String? = null } You will need to ensure that the JAXB library is part of your project, for example by adding: <dependency> <groupId>org.glassfish.jaxb</groupId> <artifactId>jaxb-runtime</artifactId> </dependency> To get the server to render XML instead of JSON, you might have to send an Accept: text/xml header (or use a browser). Customize the Jackson ObjectMapper: Spring MVC (client and server side) uses HttpMessageConverters to negotiate content conversion in an HTTP exchange. If Jackson is on the classpath, you already get the default converter(s) provided by Jackson2ObjectMapperBuilder , an instance of which is auto-configured for you. The ObjectMapper (or XmlMapper for Jackson XML converter) instance (created by default) has the following customized properties: MapperFeature.DEFAULT_VIEW_INCLUSION is disabled DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES is disabled SerializationFeature.WRITE_DATES_AS_TIMESTAMPS is disabled SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS is disabled Spring Boot also has some features to make it easier to customize this behavior. You can configure the ObjectMapper and XmlMapper instances by using the environment. Jackson provides an extensive suite of on/off features that can be used to configure various aspects of its processing. These features are described in several enums (in Jackson) that map onto properties in the environment: Enum Property Values com.fasterxml.jackson.databind.cfg.EnumFeature spring.jackson.datatype.enum.<feature_name> true , false com.fasterxml.jackson.databind.cfg.JsonNodeFeature spring.jackson.datatype.json-node.<feature_name> true , false com.fasterxml.jackson.databind.DeserializationFeature spring.jackson.deserialization.<feature_name> true , false com.fasterxml.jackson.core.JsonGenerator.Feature spring.jackson.generator.<feature_name> true , false com.fasterxml.jackson.databind.MapperFeature spring.jackson.mapper.<feature_name> true , false com.fasterxml.jackson.core.JsonParser.Feature spring.jackson.parser.<feature_name> true , false com.fasterxml.jackson.databind.SerializationFeature spring.jackson.serialization.<feature_name> true , false com.fasterxml.jackson.annotation.JsonInclude.Include spring.jackson.default-property-inclusion always , non_null , non_absent , non_default , non_empty For example, to enable pretty print, set spring.jackson.serialization.indent_output=true . Note that, thanks to the use of relaxed binding(../reference/features/external-config.html#features.external-config.typesafe-configuration-properties.relaxed-binding) , the case of indent_output does not have to match the case of the corresponding enum constant, which is INDENT_OUTPUT . This environment-based configuration is applied to the auto-configured Jackson2ObjectMapperBuilder bean and applies to any mappers created by using the builder, including the auto-configured ObjectMapper bean. The context’s Jackson2ObjectMapperBuilder can be customized by one or more Jackson2ObjectMapperBuilderCustomizer beans. Such customizer beans can be ordered (Boot’s own customizer has an order of 0), letting additional customization be applied both before and after Boot’s customization. Any beans of type com.fasterxml.jackson.databind.Module are automatically registered with the auto-configured Jackson2ObjectMapperBuilder and are applied to any ObjectMapper instances that it creates. This provides a global mechanism for contributing custom modules when you add new features to your application. If you want to replace the default ObjectMapper completely, either define a @Bean of that type and mark it as @Primary or, if you prefer the builder-based approach, define a Jackson2ObjectMapperBuilder @Bean . Note that, in either case, doing so disables all auto-configuration of the ObjectMapper . If you provide any @Beans of type MappingJackson2HttpMessageConverter , they replace the default value in the MVC configuration. Also, a convenience bean of type HttpMessageConverters is provided (and is always available if you use the default MVC configuration). It has some useful methods to access the default and user-enhanced message converters. See the Customize the @ResponseBody Rendering(#howto.spring-mvc.customize-responsebody-rendering) section and the WebMvcAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java) source code for more details. Customize the @ResponseBody Rendering: Spring uses HttpMessageConverters to render @ResponseBody (or responses from @RestController ). You can contribute additional converters by adding beans of the appropriate type in a Spring Boot context. If a bean you add is of a type that would have been included by default anyway (such as MappingJackson2HttpMessageConverter for JSON conversions), it replaces the default value. A convenience bean of type HttpMessageConverters is provided and is always available if you use the default MVC configuration. It has some useful methods to access the default and user-enhanced message converters (For example, it can be useful if you want to manually inject them into a custom RestTemplate ). As in normal MVC usage, any WebMvcConfigurer beans that you provide can also contribute converters by overriding the configureMessageConverters method. However, unlike with normal MVC, you can supply only additional converters that you need (because Spring Boot uses the same mechanism to contribute its defaults). Finally, if you opt out of the default Spring Boot MVC configuration by providing your own @EnableWebMvc configuration, you can take control completely and do everything manually by using getMessageConverters from WebMvcConfigurationSupport . See the WebMvcAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java) source code for more details. Handling Multipart File Uploads: Spring Boot embraces the servlet 5 jakarta.servlet.http.Part API to support uploading files. By default, Spring Boot configures Spring MVC with a maximum size of 1MB per file and a maximum of 10MB of file data in a single request. You may override these values, the location to which intermediate data is stored (for example, to the /tmp directory), and the threshold past which data is flushed to disk by using the properties exposed in the MultipartProperties class. For example, if you want to specify that files be unlimited, set the spring.servlet.multipart.max-file-size property to -1 . The multipart support is helpful when you want to receive multipart encoded file data as a @RequestParam -annotated parameter of type MultipartFile in a Spring MVC controller handler method. See the MultipartAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/MultipartAutoConfiguration.java) source for more details. It is recommended to use the container’s built-in support for multipart uploads rather than introduce an additional dependency such as Apache Commons File Upload. Switch Off the Spring MVC DispatcherServlet: By default, all content is served from the root of your application ( / ). If you would rather map to a different path, you can configure one as follows: Properties YAML spring.mvc.servlet.path=/mypath spring: mvc: servlet: path: ""/mypath"" If you have additional servlets you can declare a @Bean of type Servlet or ServletRegistrationBean for each and Spring Boot will register them transparently to the container. Because servlets are registered that way, they can be mapped to a sub-context of the DispatcherServlet without invoking it. Configuring the DispatcherServlet yourself is unusual but if you really need to do it, a @Bean of type DispatcherServletPath must be provided as well to provide the path of your custom DispatcherServlet . Switch Off the Default MVC Configuration: The easiest way to take complete control over MVC configuration is to provide your own @Configuration with the @EnableWebMvc annotation. Doing so leaves all MVC configuration in your hands. Customize ViewResolvers: A ViewResolver is a core component of Spring MVC, translating view names in @Controller to actual View implementations. Note that ViewResolvers are mainly used in UI applications, rather than REST-style services (a View is not used to render a @ResponseBody ). There are many implementations of ViewResolver to choose from, and Spring on its own is not opinionated about which ones you should use. Spring Boot, on the other hand, installs one or two for you, depending on what it finds on the classpath and in the application context. The DispatcherServlet uses all the resolvers it finds in the application context, trying each one in turn until it gets a result. If you add your own, you have to be aware of the order and in which position your resolver is added. WebMvcAutoConfiguration adds the following ViewResolvers to your context: An InternalResourceViewResolver named ‘defaultViewResolver’. This one locates physical resources that can be rendered by using the DefaultServlet (including static resources and JSP pages, if you use those). It applies a prefix and a suffix to the view name and then looks for a physical resource with that path in the servlet context (the defaults are both empty but are accessible for external configuration through spring.mvc.view.prefix and spring.mvc.view.suffix ). You can override it by providing a bean of the same type. A BeanNameViewResolver named ‘beanNameViewResolver’. This is a useful member of the view resolver chain and picks up any beans with the same name as the View being resolved. It should not be necessary to override or replace it. A ContentNegotiatingViewResolver named ‘viewResolver’ is added only if there are actually beans of type View present. This is a composite resolver, delegating to all the others and attempting to find a match to the ‘Accept’ HTTP header sent by the client. There is a useful blog about ContentNegotiatingViewResolver(https://spring.io/blog/2013/06/03/content-negotiation-using-views) that you might like to study to learn more, and you might also look at the source code for detail. You can switch off the auto-configured ContentNegotiatingViewResolver by defining a bean named ‘viewResolver’. If you use Thymeleaf, you also have a ThymeleafViewResolver named ‘thymeleafViewResolver’. It looks for resources by surrounding the view name with a prefix and suffix. The prefix is spring.thymeleaf.prefix , and the suffix is spring.thymeleaf.suffix . The values of the prefix and suffix default to ‘classpath:/templates/’ and ‘.html’, respectively. You can override ThymeleafViewResolver by providing a bean of the same name. If you use FreeMarker, you also have a FreeMarkerViewResolver named ‘freeMarkerViewResolver’. It looks for resources in a loader path (which is externalized to spring.freemarker.templateLoaderPath and has a default value of ‘classpath:/templates/’) by surrounding the view name with a prefix and a suffix. The prefix is externalized to spring.freemarker.prefix , and the suffix is externalized to spring.freemarker.suffix . The default values of the prefix and suffix are empty and ‘.ftlh’, respectively. You can override FreeMarkerViewResolver by providing a bean of the same name. If you use Groovy templates (actually, if groovy-templates is on your classpath), you also have a GroovyMarkupViewResolver named ‘groovyMarkupViewResolver’. It looks for resources in a loader path by surrounding the view name with a prefix and suffix (externalized to spring.groovy.template.prefix and spring.groovy.template.suffix ). The prefix and suffix have default values of ‘classpath:/templates/’ and ‘.tpl’, respectively. You can override GroovyMarkupViewResolver by providing a bean of the same name. If you use Mustache, you also have a MustacheViewResolver named ‘mustacheViewResolver’. It looks for resources by surrounding the view name with a prefix and suffix. The prefix is spring.mustache.prefix , and the suffix is spring.mustache.suffix . The values of the prefix and suffix default to ‘classpath:/templates/’ and ‘.mustache’, respectively. You can override MustacheViewResolver by providing a bean of the same name. For more detail, see the following sections: WebMvcAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java) ThymeleafAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/thymeleaf/ThymeleafAutoConfiguration.java) FreeMarkerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/freemarker/FreeMarkerAutoConfiguration.java) GroovyTemplateAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/groovy/template/GroovyTemplateAutoConfiguration.java)"
"https://docs.spring.io/spring-boot/how-to/jersey.html","Jersey: Secure Jersey Endpoints with Spring Security: Spring Security can be used to secure a Jersey-based web application in much the same way as it can be used to secure a Spring MVC-based web application. However, if you want to use Spring Security’s method-level security with Jersey, you must configure Jersey to use setStatus(int) rather sendError(int) . This prevents Jersey from committing the response before Spring Security has had an opportunity to report an authentication or authorization failure to the client. The jersey.config.server.response.setStatusOverSendError property must be set to true on the application’s ResourceConfig bean, as shown in the following example: import java.util.Collections; import org.glassfish.jersey.server.ResourceConfig; import org.springframework.stereotype.Component; @Component public class JerseySetStatusOverSendErrorConfig extends ResourceConfig { public JerseySetStatusOverSendErrorConfig() { register(Endpoint.class); setProperties(Collections.singletonMap(""jersey.config.server.response.setStatusOverSendError"", true)); } } Use Jersey Alongside Another Web Framework: To use Jersey alongside another web framework, such as Spring MVC, it should be configured so that it will allow the other framework to handle requests that it cannot handle. First, configure Jersey to use a filter rather than a servlet by configuring the spring.jersey.type application property with a value of filter . Second, configure your ResourceConfig to forward requests that would have resulted in a 404, as shown in the following example. import org.glassfish.jersey.server.ResourceConfig; import org.glassfish.jersey.servlet.ServletProperties; import org.springframework.stereotype.Component; @Component public class JerseyConfig extends ResourceConfig { public JerseyConfig() { register(Endpoint.class); property(ServletProperties.FILTER_FORWARD_ON_404, true); } }"
"https://docs.spring.io/spring-boot/how-to/http-clients.html","HTTP Clients: Spring Boot offers a number of starters that work with HTTP clients. This section answers questions related to using them. Configure RestTemplate to Use a Proxy: As described in RestTemplate Customization(../reference/io/rest-client.html#io.rest-client.resttemplate.customization) , you can use a RestTemplateCustomizer with RestTemplateBuilder to build a customized RestTemplate . This is the recommended approach for creating a RestTemplate configured to use a proxy. The exact details of the proxy configuration depend on the underlying client request factory that is being used. Configure the TcpClient used by a Reactor Netty-based WebClient: When Reactor Netty is on the classpath a Reactor Netty-based WebClient is auto-configured. To customize the client’s handling of network connections, provide a ClientHttpConnector bean. The following example configures a 60 second connect timeout and adds a ReadTimeoutHandler : Java Kotlin import io.netty.channel.ChannelOption; import io.netty.handler.timeout.ReadTimeoutHandler; import reactor.netty.http.client.HttpClient; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.client.ReactorResourceFactory; import org.springframework.http.client.reactive.ClientHttpConnector; import org.springframework.http.client.reactive.ReactorClientHttpConnector; @Configuration(proxyBeanMethods = false) public class MyReactorNettyClientConfiguration { @Bean ClientHttpConnector clientHttpConnector(ReactorResourceFactory resourceFactory) { HttpClient httpClient = HttpClient.create(resourceFactory.getConnectionProvider()) .runOn(resourceFactory.getLoopResources()) .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 60000) .doOnConnected((connection) -> connection.addHandlerLast(new ReadTimeoutHandler(60))); return new ReactorClientHttpConnector(httpClient); } } import io.netty.channel.ChannelOption import io.netty.handler.timeout.ReadTimeoutHandler import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.http.client.reactive.ClientHttpConnector import org.springframework.http.client.reactive.ReactorClientHttpConnector import org.springframework.http.client.ReactorResourceFactory import reactor.netty.http.client.HttpClient @Configuration(proxyBeanMethods = false) class MyReactorNettyClientConfiguration { @Bean fun clientHttpConnector(resourceFactory: ReactorResourceFactory): ClientHttpConnector { val httpClient = HttpClient.create(resourceFactory.connectionProvider) .runOn(resourceFactory.loopResources) .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 60000) .doOnConnected { connection -> connection.addHandlerLast(ReadTimeoutHandler(60)) } return ReactorClientHttpConnector(httpClient) } } Note the use of ReactorResourceFactory for the connection provider and event loop resources. This ensures efficient sharing of resources for the server receiving requests and the client making requests."
"https://docs.spring.io/spring-boot/how-to/logging.html","Logging: Spring Boot has no mandatory logging dependency, except for the Commons Logging API, which is typically provided by Spring Framework’s spring-jcl module. To use Logback(https://logback.qos.ch) , you need to include it and spring-jcl on the classpath. The recommended way to do that is through the starters, which all depend on spring-boot-starter-logging . For a web application, you only need spring-boot-starter-web , since it depends transitively on the logging starter. If you use Maven, the following dependency adds logging for you: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> Spring Boot has a LoggingSystem abstraction that attempts to configure logging based on the content of the classpath. If Logback is available, it is the first choice. If the only change you need to make to logging is to set the levels of various loggers, you can do so in application.properties by using the ""logging.level"" prefix, as shown in the following example: Properties YAML logging.level.org.springframework.web=debug logging.level.org.hibernate=error logging: level: org.springframework.web: ""debug"" org.hibernate: ""error"" You can also set the location of a file to which the log will be written (in addition to the console) by using logging.file.name . To configure the more fine-grained settings of a logging system, you need to use the native configuration format supported by the LoggingSystem in question. By default, Spring Boot picks up the native configuration from its default location for the system (such as classpath:logback.xml for Logback), but you can set the location of the config file by using the logging.config property. Configure Logback for Logging: If you need to apply customizations to logback beyond those that can be achieved with application.properties , you will need to add a standard logback configuration file. You can add a logback.xml file to the root of your classpath for logback to find. You can also use logback-spring.xml if you want to use the Spring Boot Logback Extensions(../reference/features/logging.html#features.logging.logback-extensions) . The Logback documentation has a dedicated section that covers configuration(https://logback.qos.ch/manual/configuration.html) in some detail. Spring Boot provides a number of logback configurations that can be included in your own configuration. These includes are designed to allow certain common Spring Boot conventions to be re-applied. The following files are provided under org/springframework/boot/logging/logback/ : defaults.xml - Provides conversion rules, pattern properties and common logger configurations. console-appender.xml - Adds a ConsoleAppender using the CONSOLE_LOG_PATTERN . file-appender.xml - Adds a RollingFileAppender using the FILE_LOG_PATTERN and ROLLING_FILE_NAME_PATTERN with appropriate settings. In addition, a legacy base.xml file is provided for compatibility with earlier versions of Spring Boot. A typical custom logback.xml file would look something like this: <?xml version=""1.0"" encoding=""UTF-8""?> <configuration> <include resource=""org/springframework/boot/logging/logback/defaults.xml""/> <include resource=""org/springframework/boot/logging/logback/console-appender.xml"" /> <root level=""INFO""> <appender-ref ref=""CONSOLE"" /> </root> <logger name=""org.springframework.web"" level=""DEBUG""/> </configuration> Your logback configuration file can also make use of System properties that the LoggingSystem takes care of creating for you: ${PID} : The current process ID. ${LOG_FILE} : Whether logging.file.name was set in Boot’s external configuration. ${LOG_PATH} : Whether logging.file.path (representing a directory for log files to live in) was set in Boot’s external configuration. ${LOG_EXCEPTION_CONVERSION_WORD} : Whether logging.exception-conversion-word was set in Boot’s external configuration. ${ROLLING_FILE_NAME_PATTERN} : Whether logging.pattern.rolling-file-name was set in Boot’s external configuration. Spring Boot also provides some nice ANSI color terminal output on a console (but not in a log file) by using a custom Logback converter. See the CONSOLE_LOG_PATTERN in the defaults.xml configuration for an example. If Groovy is on the classpath, you should be able to configure Logback with logback.groovy as well. If present, this setting is given preference. Spring extensions are not supported with Groovy configuration. Any logback-spring.groovy files will not be detected. Configure Logback for File-only Output: If you want to disable console logging and write output only to a file, you need a custom logback-spring.xml that imports file-appender.xml but not console-appender.xml , as shown in the following example: <?xml version=""1.0"" encoding=""UTF-8""?> <configuration> <include resource=""org/springframework/boot/logging/logback/defaults.xml"" /> <property name=""LOG_FILE"" value=""${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}/}spring.log}""/> <include resource=""org/springframework/boot/logging/logback/file-appender.xml"" /> <root level=""INFO""> <appender-ref ref=""FILE"" /> </root> </configuration> You also need to add logging.file.name to your application.properties or application.yaml , as shown in the following example: Properties YAML logging.file.name=myapplication.log logging: file: name: ""myapplication.log"" Configure Log4j for Logging: Spring Boot supports Log4j 2(https://logging.apache.org/log4j/2.x/) for logging configuration if it is on the classpath. If you use the starters for assembling dependencies, you have to exclude Logback and then include Log4j 2 instead. If you do not use the starters, you need to provide (at least) spring-jcl in addition to Log4j 2. The recommended path is through the starters, even though it requires some jiggling. The following example shows how to set up the starters in Maven: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> <exclusions> <exclusion> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-logging</artifactId> </exclusion> </exclusions> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-log4j2</artifactId> </dependency> Gradle provides a few different ways to set up the starters. One way is to use a module replacement(https://docs.gradle.org/current/userguide/resolution_rules.html#sec:module_replacement) . To do so, declare a dependency on the Log4j 2 starter and tell Gradle that any occurrences of the default logging starter should be replaced by the Log4j 2 starter, as shown in the following example: dependencies { implementation ""org.springframework.boot:spring-boot-starter-log4j2"" modules { module(""org.springframework.boot:spring-boot-starter-logging"") { replacedBy(""org.springframework.boot:spring-boot-starter-log4j2"", ""Use Log4j2 instead of Logback"") } } } The Log4j starters gather together the dependencies for common logging requirements (such as having Tomcat use java.util.logging but configuring the output using Log4j 2). To ensure that debug logging performed using java.util.logging is routed into Log4j 2, configure its JDK logging adapter(https://logging.apache.org/log4j/2.x/log4j-jul.html) by setting the java.util.logging.manager system property to org.apache.logging.log4j.jul.LogManager . Use YAML or JSON to Configure Log4j 2: In addition to its default XML configuration format, Log4j 2 also supports YAML and JSON configuration files. To configure Log4j 2 to use an alternative configuration file format, add the appropriate dependencies to the classpath and name your configuration files to match your chosen file format, as shown in the following example: Format Dependencies File names YAML com.fasterxml.jackson.core:jackson-databind + com.fasterxml.jackson.dataformat:jackson-dataformat-yaml log4j2.yaml + log4j2.yml JSON com.fasterxml.jackson.core:jackson-databind log4j2.json + log4j2.jsn Use Composite Configuration to Configure Log4j 2: Log4j 2 has support for combining multiple configuration files into a single composite configuration. To use this support in Spring Boot, configure logging.log4j2.config.override with the locations of one or more secondary configuration files. The secondary configuration files will be merged with the primary configuration, whether the primary’s source is Spring Boot’s defaults, a standard location such as log4j.xml , or the location configured by the logging.config property."
"https://docs.spring.io/spring-boot/how-to/data-access.html","Data Access: Spring Boot includes a number of starters for working with data sources. This section answers questions related to doing so. Configure a Custom DataSource: To configure your own DataSource , define a @Bean of that type in your configuration. Spring Boot reuses your DataSource anywhere one is required, including database initialization. If you need to externalize some settings, you can bind your DataSource to the environment (see Third-party Configuration(../reference/features/external-config.html#features.external-config.typesafe-configuration-properties.third-party-configuration) ). The following example shows how to define a data source in a bean: Java Kotlin import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyDataSourceConfiguration { @Bean @ConfigurationProperties(prefix = ""app.datasource"") public SomeDataSource dataSource() { return new SomeDataSource(); } } import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyDataSourceConfiguration { @Bean @ConfigurationProperties(prefix = ""app.datasource"") fun dataSource(): SomeDataSource { return SomeDataSource() } } The following example shows how to define a data source by setting its properties: Properties YAML app.datasource.url=jdbc:h2:mem:mydb app.datasource.username=sa app.datasource.pool-size=30 app: datasource: url: ""jdbc:h2:mem:mydb"" username: ""sa"" pool-size: 30 Assuming that SomeDataSource has regular JavaBean properties for the URL, the username, and the pool size, these settings are bound automatically before the DataSource is made available to other components. Spring Boot also provides a utility builder class, called DataSourceBuilder , that can be used to create one of the standard data sources (if it is on the classpath). The builder can detect which one to use based on what is available on the classpath. It also auto-detects the driver based on the JDBC URL. The following example shows how to create a data source by using a DataSourceBuilder : Java Kotlin import javax.sql.DataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.jdbc.DataSourceBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyDataSourceConfiguration { @Bean @ConfigurationProperties(""app.datasource"") public DataSource dataSource() { return DataSourceBuilder.create().build(); } } import javax.sql.DataSource import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.boot.jdbc.DataSourceBuilder import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyDataSourceConfiguration { @Bean @ConfigurationProperties(""app.datasource"") fun dataSource(): DataSource { return DataSourceBuilder.create().build() } } To run an app with that DataSource , all you need is the connection information. Pool-specific settings can also be provided. Check the implementation that is going to be used at runtime for more details. The following example shows how to define a JDBC data source by setting properties: Properties YAML app.datasource.url=jdbc:mysql://localhost/test app.datasource.username=dbuser app.datasource.password=dbpass app.datasource.pool-size=30 app: datasource: url: ""jdbc:mysql://localhost/test"" username: ""dbuser"" password: ""dbpass"" pool-size: 30 However, there is a catch. Because the actual type of the connection pool is not exposed, no keys are generated in the metadata for your custom DataSource and no completion is available in your IDE (because the DataSource interface exposes no properties). Also, if you happen to have Hikari on the classpath, this basic setup does not work, because Hikari has no url property (but does have a jdbcUrl property). In that case, you must rewrite your configuration as follows: Properties YAML app.datasource.jdbc-url=jdbc:mysql://localhost/test app.datasource.username=dbuser app.datasource.password=dbpass app.datasource.pool-size=30 app: datasource: jdbc-url: ""jdbc:mysql://localhost/test"" username: ""dbuser"" password: ""dbpass"" pool-size: 30 You can fix that by forcing the connection pool to use and return a dedicated implementation rather than DataSource . You cannot change the implementation at runtime, but the list of options will be explicit. The following example shows how to create a HikariDataSource with DataSourceBuilder : Java Kotlin import com.zaxxer.hikari.HikariDataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.jdbc.DataSourceBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyDataSourceConfiguration { @Bean @ConfigurationProperties(""app.datasource"") public HikariDataSource dataSource() { return DataSourceBuilder.create().type(HikariDataSource.class).build(); } } import com.zaxxer.hikari.HikariDataSource import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.boot.jdbc.DataSourceBuilder import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyDataSourceConfiguration { @Bean @ConfigurationProperties(""app.datasource"") fun dataSource(): HikariDataSource { return DataSourceBuilder.create().type(HikariDataSource::class.java).build() } } You can even go further by leveraging what DataSourceProperties does for you — that is, by providing a default embedded database with a sensible username and password if no URL is provided. You can easily initialize a DataSourceBuilder from the state of any DataSourceProperties object, so you could also inject the DataSource that Spring Boot creates automatically. However, that would split your configuration into two namespaces: url , username , password , type , and driver on spring.datasource and the rest on your custom namespace ( app.datasource ). To avoid that, you can redefine a custom DataSourceProperties on your custom namespace, as shown in the following example: Java Kotlin import com.zaxxer.hikari.HikariDataSource; import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; @Configuration(proxyBeanMethods = false) public class MyDataSourceConfiguration { @Bean @Primary @ConfigurationProperties(""app.datasource"") public DataSourceProperties dataSourceProperties() { return new DataSourceProperties(); } @Bean @ConfigurationProperties(""app.datasource.configuration"") public HikariDataSource dataSource(DataSourceProperties properties) { return properties.initializeDataSourceBuilder().type(HikariDataSource.class).build(); } } import com.zaxxer.hikari.HikariDataSource import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.context.annotation.Primary @Configuration(proxyBeanMethods = false) class MyDataSourceConfiguration { @Bean @Primary @ConfigurationProperties(""app.datasource"") fun dataSourceProperties(): DataSourceProperties { return DataSourceProperties() } @Bean @ConfigurationProperties(""app.datasource.configuration"") fun dataSource(properties: DataSourceProperties): HikariDataSource { return properties.initializeDataSourceBuilder().type(HikariDataSource::class.java).build() } } This setup puts you in sync with what Spring Boot does for you by default, except that a dedicated connection pool is chosen (in code) and its settings are exposed in the app.datasource.configuration sub namespace. Because DataSourceProperties is taking care of the url / jdbcUrl translation for you, you can configure it as follows: Properties YAML app.datasource.url=jdbc:mysql://localhost/test app.datasource.username=dbuser app.datasource.password=dbpass app.datasource.configuration.maximum-pool-size=30 app: datasource: url: ""jdbc:mysql://localhost/test"" username: ""dbuser"" password: ""dbpass"" configuration: maximum-pool-size: 30 Spring Boot will expose Hikari-specific settings to spring.datasource.hikari . This example uses a more generic configuration sub namespace as the example does not support multiple datasource implementations. Because your custom configuration chooses to go with Hikari, app.datasource.type has no effect. In practice, the builder is initialized with whatever value you might set there and then overridden by the call to .type() . See Configure a DataSource(../reference/data/sql.html#data.sql.datasource) in the “Spring Boot Features” section and the DataSourceAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java) class for more details. Configure Two DataSources: If you need to configure multiple data sources, you can apply the same tricks that were described in the previous section. You must, however, mark one of the DataSource instances as @Primary , because various auto-configurations down the road expect to be able to get one by type. If you create your own DataSource , the auto-configuration backs off. In the following example, we provide the exact same feature set as the auto-configuration provides on the primary data source: Java Kotlin import com.zaxxer.hikari.HikariDataSource; import org.apache.commons.dbcp2.BasicDataSource; import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.jdbc.DataSourceBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; @Configuration(proxyBeanMethods = false) public class MyDataSourcesConfiguration { @Bean @Primary @ConfigurationProperties(""app.datasource.first"") public DataSourceProperties firstDataSourceProperties() { return new DataSourceProperties(); } @Bean @Primary @ConfigurationProperties(""app.datasource.first.configuration"") public HikariDataSource firstDataSource(DataSourceProperties firstDataSourceProperties) { return firstDataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build(); } @Bean @ConfigurationProperties(""app.datasource.second"") public BasicDataSource secondDataSource() { return DataSourceBuilder.create().type(BasicDataSource.class).build(); } } import com.zaxxer.hikari.HikariDataSource import org.apache.commons.dbcp2.BasicDataSource import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.boot.jdbc.DataSourceBuilder import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.context.annotation.Primary @Configuration(proxyBeanMethods = false) class MyDataSourcesConfiguration { @Bean @Primary @ConfigurationProperties(""app.datasource.first"") fun firstDataSourceProperties(): DataSourceProperties { return DataSourceProperties() } @Bean @Primary @ConfigurationProperties(""app.datasource.first.configuration"") fun firstDataSource(firstDataSourceProperties: DataSourceProperties): HikariDataSource { return firstDataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource::class.java).build() } @Bean @ConfigurationProperties(""app.datasource.second"") fun secondDataSource(): BasicDataSource { return DataSourceBuilder.create().type(BasicDataSource::class.java).build() } } firstDataSourceProperties has to be flagged as @Primary so that the database initializer feature uses your copy (if you use the initializer). Both data sources are also bound for advanced customizations. For instance, you could configure them as follows: Properties YAML app.datasource.first.url=jdbc:mysql://localhost/first app.datasource.first.username=dbuser app.datasource.first.password=dbpass app.datasource.first.configuration.maximum-pool-size=30 app.datasource.second.url=jdbc:mysql://localhost/second app.datasource.second.username=dbuser app.datasource.second.password=dbpass app.datasource.second.max-total=30 app: datasource: first: url: ""jdbc:mysql://localhost/first"" username: ""dbuser"" password: ""dbpass"" configuration: maximum-pool-size: 30 second: url: ""jdbc:mysql://localhost/second"" username: ""dbuser"" password: ""dbpass"" max-total: 30 You can apply the same concept to the secondary DataSource as well, as shown in the following example: Java Kotlin import com.zaxxer.hikari.HikariDataSource; import org.apache.commons.dbcp2.BasicDataSource; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; @Configuration(proxyBeanMethods = false) public class MyCompleteDataSourcesConfiguration { @Bean @Primary @ConfigurationProperties(""app.datasource.first"") public DataSourceProperties firstDataSourceProperties() { return new DataSourceProperties(); } @Bean @Primary @ConfigurationProperties(""app.datasource.first.configuration"") public HikariDataSource firstDataSource(DataSourceProperties firstDataSourceProperties) { return firstDataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build(); } @Bean @ConfigurationProperties(""app.datasource.second"") public DataSourceProperties secondDataSourceProperties() { return new DataSourceProperties(); } @Bean @ConfigurationProperties(""app.datasource.second.configuration"") public BasicDataSource secondDataSource( @Qualifier(""secondDataSourceProperties"") DataSourceProperties secondDataSourceProperties) { return secondDataSourceProperties.initializeDataSourceBuilder().type(BasicDataSource.class).build(); } } import com.zaxxer.hikari.HikariDataSource import org.apache.commons.dbcp2.BasicDataSource import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.context.annotation.Primary @Configuration(proxyBeanMethods = false) class MyCompleteDataSourcesConfiguration { @Bean @Primary @ConfigurationProperties(""app.datasource.first"") fun firstDataSourceProperties(): DataSourceProperties { return DataSourceProperties() } @Bean @Primary @ConfigurationProperties(""app.datasource.first.configuration"") fun firstDataSource(firstDataSourceProperties: DataSourceProperties): HikariDataSource { return firstDataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource::class.java).build() } @Bean @ConfigurationProperties(""app.datasource.second"") fun secondDataSourceProperties(): DataSourceProperties { return DataSourceProperties() } @Bean @ConfigurationProperties(""app.datasource.second.configuration"") fun secondDataSource(secondDataSourceProperties: DataSourceProperties): BasicDataSource { return secondDataSourceProperties.initializeDataSourceBuilder().type(BasicDataSource::class.java).build() } } The preceding example configures two data sources on custom namespaces with the same logic as Spring Boot would use in auto-configuration. Note that each configuration sub namespace provides advanced settings based on the chosen implementation. Use Spring Data Repositories: Spring Data can create implementations of Repository interfaces of various flavors. Spring Boot handles all of that for you, as long as those Repository implementations are included in one of the auto-configuration packages(../reference/using/auto-configuration.html#using.auto-configuration.packages) , typically the package (or a sub-package) of your main application class that is annotated with @SpringBootApplication or @EnableAutoConfiguration . For many applications, all you need is to put the right Spring Data dependencies on your classpath. There is a spring-boot-starter-data-jpa for JPA, spring-boot-starter-data-mongodb for Mongodb, and various other starters for supported technologies. To get started, create some repository interfaces to handle your @Entity objects. Spring Boot determines the location of your Repository implementations by scanning the auto-configuration packages(../reference/using/auto-configuration.html#using.auto-configuration.packages) . For more control, use the @Enable…Repositories annotations from Spring Data. For more about Spring Data, see the Spring Data project page(https://spring.io/projects/spring-data) . Separate @Entity Definitions from Spring Configuration: Spring Boot determines the location of your @Entity definitions by scanning the auto-configuration packages(../reference/using/auto-configuration.html#using.auto-configuration.packages) . For more control, use the @EntityScan annotation, as shown in the following example: Java Kotlin import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.boot.autoconfigure.domain.EntityScan; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) @EnableAutoConfiguration @EntityScan(basePackageClasses = City.class) public class MyApplication { // ... } import org.springframework.boot.autoconfigure.EnableAutoConfiguration import org.springframework.boot.autoconfigure.domain.EntityScan import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) @EnableAutoConfiguration @EntityScan(basePackageClasses = [City::class]) class MyApplication { // ... } Filter Scanned @Entity Definitions: It is possible to filter the @Entity definitions using a ManagedClassNameFilter bean. This can be useful in tests when only a sub-set of the available entities should be considered. In the following example, only entities from the com.example.app.customer package are included: Java Kotlin import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.orm.jpa.persistenceunit.ManagedClassNameFilter; @Configuration(proxyBeanMethods = false) public class MyEntityScanConfiguration { @Bean public ManagedClassNameFilter entityScanFilter() { return (className) -> className.startsWith(""com.example.app.customer""); } } import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.orm.jpa.persistenceunit.ManagedClassNameFilter @Configuration(proxyBeanMethods = false) class MyEntityScanConfiguration { @Bean fun entityScanFilter() : ManagedClassNameFilter { return ManagedClassNameFilter { className -> className.startsWith(""com.example.app.customer"") } } } Configure JPA Properties: Spring Data JPA already provides some vendor-independent configuration options (such as those for SQL logging), and Spring Boot exposes those options and a few more for Hibernate as external configuration properties. Some of them are automatically detected according to the context so you should not have to set them. The spring.jpa.hibernate.ddl-auto is a special case, because, depending on runtime conditions, it has different defaults. If an embedded database is used and no schema manager (such as Liquibase or Flyway) is handling the DataSource , it defaults to create-drop . In all other cases, it defaults to none . The dialect to use is detected by the JPA provider. If you prefer to set the dialect yourself, set the spring.jpa.database-platform property. The most common options to set are shown in the following example: Properties YAML spring.jpa.hibernate.naming.physical-strategy=com.example.MyPhysicalNamingStrategy spring.jpa.show-sql=true spring: jpa: hibernate: naming: physical-strategy: ""com.example.MyPhysicalNamingStrategy"" show-sql: true In addition, all properties in spring.jpa.properties.* are passed through as normal JPA properties (with the prefix stripped) when the local EntityManagerFactory is created. You need to ensure that names defined under spring.jpa.properties.* exactly match those expected by your JPA provider. Spring Boot will not attempt any kind of relaxed binding for these entries. For example, if you want to configure Hibernate’s batch size you must use spring.jpa.properties.hibernate.jdbc.batch_size . If you use other forms, such as batchSize or batch-size , Hibernate will not apply the setting. If you need to apply advanced customization to Hibernate properties, consider registering a HibernatePropertiesCustomizer bean that will be invoked prior to creating the EntityManagerFactory . This takes precedence over anything that is applied by the auto-configuration. Configure Hibernate Naming Strategy: Hibernate uses two different naming strategies(https://docs.jboss.org/hibernate/orm/6.5/userguide/html_single/Hibernate_User_Guide.html#naming) to map names from the object model to the corresponding database names. The fully qualified class name of the physical and the implicit strategy implementations can be configured by setting the spring.jpa.hibernate.naming.physical-strategy and spring.jpa.hibernate.naming.implicit-strategy properties, respectively. Alternatively, if ImplicitNamingStrategy or PhysicalNamingStrategy beans are available in the application context, Hibernate will be automatically configured to use them. By default, Spring Boot configures the physical naming strategy with CamelCaseToUnderscoresNamingStrategy . Using this strategy, all dots are replaced by underscores and camel casing is replaced by underscores as well. Additionally, by default, all table names are generated in lower case. For example, a TelephoneNumber entity is mapped to the telephone_number table. If your schema requires mixed-case identifiers, define a custom CamelCaseToUnderscoresNamingStrategy bean, as shown in the following example: Java Kotlin import org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy; import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyHibernateConfiguration { @Bean public CamelCaseToUnderscoresNamingStrategy caseSensitivePhysicalNamingStrategy() { return new CamelCaseToUnderscoresNamingStrategy() { @Override protected boolean isCaseInsensitive(JdbcEnvironment jdbcEnvironment) { return false; } }; } } import org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyHibernateConfiguration { @Bean fun caseSensitivePhysicalNamingStrategy(): CamelCaseToUnderscoresNamingStrategy { return object : CamelCaseToUnderscoresNamingStrategy() { override fun isCaseInsensitive(jdbcEnvironment: JdbcEnvironment): Boolean { return false } } } } If you prefer to use Hibernate’s default instead, set the following property: Properties YAML spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl spring: jpa: hibernate: naming: physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl Alternatively, you can configure the following bean: Java Kotlin import org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) class MyHibernateConfiguration { @Bean PhysicalNamingStrategyStandardImpl caseSensitivePhysicalNamingStrategy() { return new PhysicalNamingStrategyStandardImpl(); } } import org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) internal class MyHibernateConfiguration { @Bean fun caseSensitivePhysicalNamingStrategy(): PhysicalNamingStrategyStandardImpl { return PhysicalNamingStrategyStandardImpl() } } See HibernateJpaAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.java) and JpaBaseConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java) for more details. Configure Hibernate Second-Level Caching: Hibernate second-level cache(https://docs.jboss.org/hibernate/orm/6.5/userguide/html_single/Hibernate_User_Guide.html#caching) can be configured for a range of cache providers. Rather than configuring Hibernate to lookup the cache provider again, it is better to provide the one that is available in the context whenever possible. To do this with JCache, first make sure that org.hibernate.orm:hibernate-jcache is available on the classpath. Then, add a HibernatePropertiesCustomizer bean as shown in the following example: Java Kotlin import org.hibernate.cache.jcache.ConfigSettings; import org.springframework.boot.autoconfigure.orm.jpa.HibernatePropertiesCustomizer; import org.springframework.cache.jcache.JCacheCacheManager; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyHibernateSecondLevelCacheConfiguration { @Bean public HibernatePropertiesCustomizer hibernateSecondLevelCacheCustomizer(JCacheCacheManager cacheManager) { return (properties) -> properties.put(ConfigSettings.CACHE_MANAGER, cacheManager.getCacheManager()); } } import org.hibernate.cache.jcache.ConfigSettings import org.springframework.boot.autoconfigure.orm.jpa.HibernatePropertiesCustomizer import org.springframework.cache.jcache.JCacheCacheManager import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyHibernateSecondLevelCacheConfiguration { @Bean fun hibernateSecondLevelCacheCustomizer(cacheManager: JCacheCacheManager): HibernatePropertiesCustomizer { return HibernatePropertiesCustomizer { properties -> properties[ConfigSettings.CACHE_MANAGER] = cacheManager.cacheManager } } } This customizer will configure Hibernate to use the same CacheManager as the one that the application uses. It is also possible to use separate CacheManager instances. For details, see the Hibernate user guide(https://docs.jboss.org/hibernate/orm/6.5/userguide/html_single/Hibernate_User_Guide.html#caching-provider-jcache) . Use Dependency Injection in Hibernate Components: By default, Spring Boot registers a BeanContainer implementation that uses the BeanFactory so that converters and entity listeners can use regular dependency injection. You can disable or tune this behavior by registering a HibernatePropertiesCustomizer that removes or changes the hibernate.resource.beans.container property. Use a Custom EntityManagerFactory: To take full control of the configuration of the EntityManagerFactory , you need to add a @Bean named ‘entityManagerFactory’. Spring Boot auto-configuration switches off its entity manager in the presence of a bean of that type. Using Multiple EntityManagerFactories: If you need to use JPA against multiple data sources, you likely need one EntityManagerFactory per data source. The LocalContainerEntityManagerFactoryBean from Spring ORM allows you to configure an EntityManagerFactory for your needs. You can also reuse JpaProperties to bind settings for each EntityManagerFactory , as shown in the following example: Java Kotlin import javax.sql.DataSource; import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.orm.jpa.JpaVendorAdapter; import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean; import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter; @Configuration(proxyBeanMethods = false) public class MyEntityManagerFactoryConfiguration { @Bean @ConfigurationProperties(""app.jpa.first"") public JpaProperties firstJpaProperties() { return new JpaProperties(); } @Bean public LocalContainerEntityManagerFactoryBean firstEntityManagerFactory(DataSource firstDataSource, JpaProperties firstJpaProperties) { EntityManagerFactoryBuilder builder = createEntityManagerFactoryBuilder(firstJpaProperties); return builder.dataSource(firstDataSource).packages(Order.class).persistenceUnit(""firstDs"").build(); } private EntityManagerFactoryBuilder createEntityManagerFactoryBuilder(JpaProperties jpaProperties) { JpaVendorAdapter jpaVendorAdapter = createJpaVendorAdapter(jpaProperties); return new EntityManagerFactoryBuilder(jpaVendorAdapter, jpaProperties.getProperties(), null); } private JpaVendorAdapter createJpaVendorAdapter(JpaProperties jpaProperties) { // ... map JPA properties as needed return new HibernateJpaVendorAdapter(); } } import javax.sql.DataSource import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.orm.jpa.JpaVendorAdapter import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter @Configuration(proxyBeanMethods = false) class MyEntityManagerFactoryConfiguration { @Bean @ConfigurationProperties(""app.jpa.first"") fun firstJpaProperties(): JpaProperties { return JpaProperties() } @Bean fun firstEntityManagerFactory( firstDataSource: DataSource?, firstJpaProperties: JpaProperties ): LocalContainerEntityManagerFactoryBean { val builder = createEntityManagerFactoryBuilder(firstJpaProperties) return builder.dataSource(firstDataSource).packages(Order::class.java).persistenceUnit(""firstDs"").build() } private fun createEntityManagerFactoryBuilder(jpaProperties: JpaProperties): EntityManagerFactoryBuilder { val jpaVendorAdapter = createJpaVendorAdapter(jpaProperties) return EntityManagerFactoryBuilder(jpaVendorAdapter, jpaProperties.properties, null) } private fun createJpaVendorAdapter(jpaProperties: JpaProperties): JpaVendorAdapter { // ... map JPA properties as needed return HibernateJpaVendorAdapter() } } The example above creates an EntityManagerFactory using a DataSource bean named firstDataSource . It scans entities located in the same package as Order . It is possible to map additional JPA properties using the app.first.jpa namespace. When you create a bean for LocalContainerEntityManagerFactoryBean yourself, any customization that was applied during the creation of the auto-configured LocalContainerEntityManagerFactoryBean is lost. For example, in the case of Hibernate, any properties under the spring.jpa.hibernate prefix will not be automatically applied to your LocalContainerEntityManagerFactoryBean . If you were relying on these properties for configuring things like the naming strategy or the DDL mode, you will need to explicitly configure that when creating the LocalContainerEntityManagerFactoryBean bean. You should provide a similar configuration for any additional data sources for which you need JPA access. To complete the picture, you need to configure a JpaTransactionManager for each EntityManagerFactory as well. Alternatively, you might be able to use a JTA transaction manager that spans both. If you use Spring Data, you need to configure @EnableJpaRepositories accordingly, as shown in the following examples: Java Kotlin import org.springframework.context.annotation.Configuration; import org.springframework.data.jpa.repository.config.EnableJpaRepositories; @Configuration(proxyBeanMethods = false) @EnableJpaRepositories(basePackageClasses = Order.class, entityManagerFactoryRef = ""firstEntityManagerFactory"") public class OrderConfiguration { } import org.springframework.context.annotation.Configuration import org.springframework.data.jpa.repository.config.EnableJpaRepositories @Configuration(proxyBeanMethods = false) @EnableJpaRepositories(basePackageClasses = [Order::class], entityManagerFactoryRef = ""firstEntityManagerFactory"") class OrderConfiguration Java Kotlin import org.springframework.context.annotation.Configuration; import org.springframework.data.jpa.repository.config.EnableJpaRepositories; @Configuration(proxyBeanMethods = false) @EnableJpaRepositories(basePackageClasses = Customer.class, entityManagerFactoryRef = ""secondEntityManagerFactory"") public class CustomerConfiguration { } import org.springframework.context.annotation.Configuration import org.springframework.data.jpa.repository.config.EnableJpaRepositories @Configuration(proxyBeanMethods = false) @EnableJpaRepositories(basePackageClasses = [Customer::class], entityManagerFactoryRef = ""secondEntityManagerFactory"") class CustomerConfiguration Use a Traditional persistence.xml File: Spring Boot will not search for or use a META-INF/persistence.xml by default. If you prefer to use a traditional persistence.xml , you need to define your own @Bean of type LocalEntityManagerFactoryBean (with an ID of ‘entityManagerFactory’) and set the persistence unit name there. See JpaBaseConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java) for the default settings. Use Spring Data JPA and Mongo Repositories: Spring Data JPA and Spring Data Mongo can both automatically create Repository implementations for you. If they are both present on the classpath, you might have to do some extra configuration to tell Spring Boot which repositories to create. The most explicit way to do that is to use the standard Spring Data @EnableJpaRepositories and @EnableMongoRepositories annotations and provide the location of your Repository interfaces. There are also flags ( spring.data.*.repositories.enabled and spring.data.*.repositories.type ) that you can use to switch the auto-configured repositories on and off in external configuration. Doing so is useful, for instance, in case you want to switch off the Mongo repositories and still use the auto-configured MongoTemplate . The same obstacle and the same features exist for other auto-configured Spring Data repository types (Elasticsearch, Redis, and others). To work with them, change the names of the annotations and flags accordingly. Customize Spring Data’s Web Support: Spring Data provides web support that simplifies the use of Spring Data repositories in a web application. Spring Boot provides properties in the spring.data.web namespace for customizing its configuration. Note that if you are using Spring Data REST, you must use the properties in the spring.data.rest namespace instead. Expose Spring Data Repositories as REST Endpoint: Spring Data REST can expose the Repository implementations as REST endpoints for you, provided Spring MVC has been enabled for the application. Spring Boot exposes a set of useful properties (from the spring.data.rest namespace) that customize the RepositoryRestConfiguration(https://docs.spring.io/spring-data/rest/docs/4.3.x/api/org/springframework/data/rest/core/config/RepositoryRestConfiguration.html) . If you need to provide additional customization, you should use a RepositoryRestConfigurer(https://docs.spring.io/spring-data/rest/docs/4.3.x/api/org/springframework/data/rest/webmvc/config/RepositoryRestConfigurer.html) bean. If you do not specify any order on your custom RepositoryRestConfigurer , it runs after the one Spring Boot uses internally. If you need to specify an order, make sure it is higher than 0. Configure a Component that is Used by JPA: If you want to configure a component that JPA uses, then you need to ensure that the component is initialized before JPA. When the component is auto-configured, Spring Boot takes care of this for you. For example, when Flyway is auto-configured, Hibernate is configured to depend on Flyway so that Flyway has a chance to initialize the database before Hibernate tries to use it. If you are configuring a component yourself, you can use an EntityManagerFactoryDependsOnPostProcessor subclass as a convenient way of setting up the necessary dependencies. For example, if you use Hibernate Search with Elasticsearch as its index manager, any EntityManagerFactory beans must be configured to depend on the elasticsearchClient bean, as shown in the following example: Java Kotlin import jakarta.persistence.EntityManagerFactory; import org.springframework.boot.autoconfigure.orm.jpa.EntityManagerFactoryDependsOnPostProcessor; import org.springframework.stereotype.Component; /** * {@link EntityManagerFactoryDependsOnPostProcessor} that ensures that * {@link EntityManagerFactory} beans depend on the {@code elasticsearchClient} bean. */ @Component public class ElasticsearchEntityManagerFactoryDependsOnPostProcessor extends EntityManagerFactoryDependsOnPostProcessor { public ElasticsearchEntityManagerFactoryDependsOnPostProcessor() { super(""elasticsearchClient""); } } import org.springframework.boot.autoconfigure.orm.jpa.EntityManagerFactoryDependsOnPostProcessor import org.springframework.stereotype.Component @Component class ElasticsearchEntityManagerFactoryDependsOnPostProcessor : EntityManagerFactoryDependsOnPostProcessor(""elasticsearchClient"") Configure jOOQ with Two DataSources: If you need to use jOOQ with multiple data sources, you should create your own DSLContext for each one. See JooqAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jooq/JooqAutoConfiguration.java) for more details. In particular, JooqExceptionTranslator and SpringTransactionProvider can be reused to provide similar features to what the auto-configuration does with a single DataSource ."
"https://docs.spring.io/spring-boot/how-to/data-initialization.html","Database Initialization: An SQL database can be initialized in different ways depending on what your stack is. Of course, you can also do it manually, provided the database is a separate process. It is recommended to use a single mechanism for schema generation. Initialize a Database Using Hibernate: You can set spring.jpa.hibernate.ddl-auto to control Hibernate’s database initialization. Supported values are none , validate , update , create , and create-drop . Spring Boot chooses a default value for you based on whether you are using an embedded database. An embedded database is identified by looking at the Connection type and JDBC url. hsqldb , h2 , or derby are embedded databases and others are not. If an embedded database is identified and no schema manager (Flyway or Liquibase) has been detected, ddl-auto defaults to create-drop . In all other cases, it defaults to none . Be careful when switching from in-memory to a ‘real’ database that you do not make assumptions about the existence of the tables and data in the new platform. You either have to set ddl-auto explicitly or use one of the other mechanisms to initialize the database. You can output the schema creation by enabling the org.hibernate.SQL logger. This is done for you automatically if you enable the debug mode(../reference/features/logging.html#features.logging.console-output) . In addition, a file named import.sql in the root of the classpath is executed on startup if Hibernate creates the schema from scratch (that is, if the ddl-auto property is set to create or create-drop ). This can be useful for demos and for testing if you are careful but is probably not something you want to be on the classpath in production. It is a Hibernate feature (and has nothing to do with Spring). Initialize a Database Using Basic SQL Scripts: Spring Boot can automatically create the schema (DDL scripts) of your JDBC DataSource or R2DBC ConnectionFactory and initialize its data (DML scripts). By default, it loads schema scripts from optional:classpath*:schema.sql and data scripts from optional:classpath*:data.sql . The locations of these schema and data scripts can be customized using spring.sql.init.schema-locations and spring.sql.init.data-locations respectively. The optional: prefix means that the application will start even when the files do not exist. To have the application fail to start when the files are absent, remove the optional: prefix. In addition, Spring Boot processes the optional:classpath*:schema-${platform}.sql and optional:classpath*:data-${platform}.sql files (if present), where ${platform} is the value of spring.sql.init.platform . This allows you to switch to database-specific scripts if necessary. For example, you might choose to set it to the vendor name of the database ( hsqldb , h2 , oracle , mysql , postgresql , and so on). By default, SQL database initialization is only performed when using an embedded in-memory database. To always initialize an SQL database, irrespective of its type, set spring.sql.init.mode to always . Similarly, to disable initialization, set spring.sql.init.mode to never . By default, Spring Boot enables the fail-fast feature of its script-based database initializer. This means that, if the scripts cause exceptions, the application fails to start. You can tune that behavior by setting spring.sql.init.continue-on-error . Script-based DataSource initialization is performed, by default, before any JPA EntityManagerFactory beans are created. schema.sql can be used to create the schema for JPA-managed entities and data.sql can be used to populate it. While we do not recommend using multiple data source initialization technologies, if you want script-based DataSource initialization to be able to build upon the schema creation performed by Hibernate, set spring.jpa.defer-datasource-initialization to true . This will defer data source initialization until after any EntityManagerFactory beans have been created and initialized. schema.sql can then be used to make additions to any schema creation performed by Hibernate and data.sql can be used to populate it. The initialization scripts support -- for single line comments and /* */ for block comments. Other comment formats are not supported. If you are using a higher-level database migration tool(#howto.data-initialization.migration-tool) , like Flyway or Liquibase, you should use them alone to create and initialize the schema. Using the basic schema.sql and data.sql scripts alongside Flyway or Liquibase is not recommended and support will be removed in a future release. If you need to initialize test data using a higher-level database migration tool, please see the sections about Flyway(#howto.data-initialization.migration-tool.flyway-tests) and Liquibase(#howto.data-initialization.migration-tool.liquibase-tests) . Initialize a Spring Batch Database: If you use Spring Batch, it comes pre-packaged with SQL initialization scripts for most popular database platforms. Spring Boot can detect your database type and execute those scripts on startup. If you use an embedded database, this happens by default. You can also enable it for any database type, as shown in the following example: Properties YAML spring.batch.jdbc.initialize-schema=always spring: batch: jdbc: initialize-schema: ""always"" You can also switch off the initialization explicitly by setting spring.batch.jdbc.initialize-schema to never . Use a Higher-level Database Migration Tool: Spring Boot supports two higher-level migration tools: Flyway(https://flywaydb.org/) and Liquibase(https://www.liquibase.org/) . Execute Flyway Database Migrations on Startup: To automatically run Flyway database migrations on startup, add the appropriate Flyway module to your classpath. In-memory and file-based databases are supported by org.flywaydb:flyway-core . Otherwise, a database-specific module is required. For example, use org.flywaydb:flyway-database-postgresql with PostgreSQL and org.flywaydb:flyway-mysql with MySQL. See the Flyway Documentation(https://documentation.red-gate.com/flyway/flyway-cli-and-api/supported-databases) for further details. Typically, migrations are scripts in the form V<VERSION>__<NAME>.sql (with <VERSION> an underscore-separated version, such as ‘1’ or ‘2_1’). By default, they are in a directory called classpath:db/migration , but you can modify that location by setting spring.flyway.locations . This is a comma-separated list of one or more classpath: or filesystem: locations. For example, the following configuration would search for scripts in both the default classpath location and the /opt/migration directory: Properties YAML spring.flyway.locations=classpath:db/migration,filesystem:/opt/migration spring: flyway: locations: ""classpath:db/migration,filesystem:/opt/migration"" You can also add a special {vendor} placeholder to use vendor-specific scripts. Assume the following: Properties YAML spring.flyway.locations=classpath:db/migration/{vendor} spring: flyway: locations: ""classpath:db/migration/{vendor}"" Rather than using db/migration , the preceding configuration sets the directory to use according to the type of the database (such as db/migration/mysql for MySQL). The list of supported databases is available in DatabaseDriver(../api/java/org/springframework/boot/jdbc/DatabaseDriver.html) . Migrations can also be written in Java. Flyway will be auto-configured with any beans that implement JavaMigration . FlywayProperties(../api/java/org/springframework/boot/autoconfigure/flyway/FlywayProperties.html) provides most of Flyway’s settings and a small set of additional properties that can be used to disable the migrations or switch off the location checking. If you need more control over the configuration, consider registering a FlywayConfigurationCustomizer bean. Spring Boot calls Flyway.migrate() to perform the database migration. If you would like more control, provide a @Bean that implements FlywayMigrationStrategy(../api/java/org/springframework/boot/autoconfigure/flyway/FlywayMigrationStrategy.html) . Flyway supports SQL and Java callbacks(https://documentation.red-gate.com/fd/callback-concept-184127466.html) . To use SQL-based callbacks, place the callback scripts in the classpath:db/migration directory. To use Java-based callbacks, create one or more beans that implement Callback . Any such beans are automatically registered with Flyway . They can be ordered by using @Order or by implementing Ordered . Beans that implement the deprecated FlywayCallback interface can also be detected, however they cannot be used alongside Callback beans. By default, Flyway autowires the ( @Primary ) DataSource in your context and uses that for migrations. If you like to use a different DataSource , you can create one and mark its @Bean as @FlywayDataSource . If you do so and want two data sources, remember to create another one and mark it as @Primary . Alternatively, you can use Flyway’s native DataSource by setting spring.flyway.[url,user,password] in external properties. Setting either spring.flyway.url or spring.flyway.user is sufficient to cause Flyway to use its own DataSource . If any of the three properties has not been set, the value of its equivalent spring.datasource property will be used. You can also use Flyway to provide data for specific scenarios. For example, you can place test-specific migrations in src/test/resources and they are run only when your application starts for testing. Also, you can use profile-specific configuration to customize spring.flyway.locations so that certain migrations run only when a particular profile is active. For example, in application-dev.properties , you might specify the following setting: Properties YAML spring.flyway.locations=classpath:/db/migration,classpath:/dev/db/migration spring: flyway: locations: ""classpath:/db/migration,classpath:/dev/db/migration"" With that setup, migrations in dev/db/migration run only when the dev profile is active. Execute Liquibase Database Migrations on Startup: To automatically run Liquibase database migrations on startup, add the org.liquibase:liquibase-core to your classpath. When you add the org.liquibase:liquibase-core to your classpath, database migrations run by default for both during application startup and before your tests run. This behavior can be customized by using the spring.liquibase.enabled property, setting different values in the main and test configurations. It is not possible to use two different ways to initialize the database (for example Liquibase for application startup, JPA for test runs). By default, the master change log is read from db/changelog/db.changelog-master.yaml , but you can change the location by setting spring.liquibase.change-log . In addition to YAML, Liquibase also supports JSON, XML, and SQL change log formats. By default, Liquibase autowires the ( @Primary ) DataSource in your context and uses that for migrations. If you need to use a different DataSource , you can create one and mark its @Bean as @LiquibaseDataSource . If you do so and you want two data sources, remember to create another one and mark it as @Primary . Alternatively, you can use Liquibase’s native DataSource by setting spring.liquibase.[driver-class-name,url,user,password] in external properties. Setting either spring.liquibase.url or spring.liquibase.user is sufficient to cause Liquibase to use its own DataSource . If any of the three properties has not been set, the value of its equivalent spring.datasource property will be used. See LiquibaseProperties(../api/java/org/springframework/boot/autoconfigure/liquibase/LiquibaseProperties.html) for details about available settings such as contexts, the default schema, and others. Use Flyway for Test-only Migrations: If you want to create Flyway migrations which populate your test database, place them in src/test/resources/db/migration . A file named, for example, src/test/resources/db/migration/V9999__test-data.sql will be executed after your production migrations and only if you’re running the tests. You can use this file to create the needed test data. This file will not be packaged in your uber jar or your container. Use Liquibase for Test-only Migrations: If you want to create Liquibase migrations which populate your test database, you have to create a test changelog which also includes the production changelog. First, you need to configure Liquibase to use a different changelog when running the tests. One way to do this is to create a Spring Boot test profile and put the Liquibase properties in there. For that, create a file named src/test/resources/application-test.properties and put the following property in there: Properties YAML spring.liquibase.change-log=classpath:/db/changelog/db.changelog-test.yaml spring: liquibase: change-log: ""classpath:/db/changelog/db.changelog-test.yaml"" This configures Liquibase to use a different changelog when running in the test profile. Now create the changelog file at src/test/resources/db/changelog/db.changelog-test.yaml : databaseChangeLog: - include: file: classpath:/db/changelog/db.changelog-master.yaml - changeSet: runOrder: ""last"" id: ""test"" changes: # Insert your changes here This changelog will be used when the tests are run and it will not be packaged in your uber jar or your container. It includes the production changelog and then declares a new changeset, whose runOrder: last setting specifies that it runs after all the production changesets have been run. You can now use for example the insert changeset(https://docs.liquibase.com/change-types/insert.html) to insert data or the sql changeset(https://docs.liquibase.com/change-types/sql.html) to execute SQL directly. The last thing to do is to configure Spring Boot to activate the test profile when running tests. To do this, you can add the @ActiveProfiles(""test"") annotation to your @SpringBootTest annotated test classes. Depend Upon an Initialized Database: Database initialization is performed while the application is starting up as part of application context refresh. To allow an initialized database to be accessed during startup, beans that act as database initializers and beans that require that database to have been initialized are detected automatically. Beans whose initialization depends upon the database having been initialized are configured to depend upon those that initialize it. If, during startup, your application tries to access the database and it has not been initialized, you can configure additional detection of beans that initialize the database and require the database to have been initialized. Detect a Database Initializer: Spring Boot will automatically detect beans of the following types that initialize an SQL database: DataSourceScriptDatabaseInitializer EntityManagerFactory Flyway FlywayMigrationInitializer R2dbcScriptDatabaseInitializer SpringLiquibase If you are using a third-party starter for a database initialization library, it may provide a detector such that beans of other types are also detected automatically. To have other beans be detected, register an implementation of DatabaseInitializerDetector in META-INF/spring.factories . Detect a Bean That Depends On Database Initialization: Spring Boot will automatically detect beans of the following types that depends upon database initialization: AbstractEntityManagerFactoryBean (unless spring.jpa.defer-datasource-initialization is set to true ) DSLContext (jOOQ) EntityManagerFactory (unless spring.jpa.defer-datasource-initialization is set to true ) JdbcClient JdbcOperations NamedParameterJdbcOperations If you are using a third-party starter data access library, it may provide a detector such that beans of other types are also detected automatically. To have other beans be detected, register an implementation of DependsOnDatabaseInitializationDetector in META-INF/spring.factories . Alternatively, annotate the bean’s class or its @Bean method with @DependsOnDatabaseInitialization ."
"https://docs.spring.io/spring-boot/how-to/nosql.html","NoSQL: Spring Boot offers a number of starters that support NoSQL technologies. This section answers questions that arise from using NoSQL with Spring Boot. Use Jedis Instead of Lettuce: By default, the Spring Boot starter ( spring-boot-starter-data-redis ) uses Lettuce(https://github.com/lettuce-io/lettuce-core/) . You need to exclude that dependency and include the Jedis(https://github.com/xetorthio/jedis/) one instead. Spring Boot manages both of these dependencies, allowing you to switch to Jedis without specifying a version. The following example shows how to accomplish this in Maven: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> <exclusions> <exclusion> <groupId>io.lettuce</groupId> <artifactId>lettuce-core</artifactId> </exclusion> </exclusions> </dependency> <dependency> <groupId>redis.clients</groupId> <artifactId>jedis</artifactId> </dependency> The following example shows how to accomplish this in Gradle: dependencies { implementation('org.springframework.boot:spring-boot-starter-data-redis') { exclude group: 'io.lettuce', module: 'lettuce-core' } implementation 'redis.clients:jedis' // ... }"
"https://docs.spring.io/spring-boot/how-to/messaging.html","Messaging: Spring Boot offers a number of starters to support messaging. This section answers questions that arise from using messaging with Spring Boot. Disable Transacted JMS Session: If your JMS broker does not support transacted sessions, you have to disable the support of transactions altogether. If you create your own JmsListenerContainerFactory , there is nothing to do, since, by default it cannot be transacted. If you want to use the DefaultJmsListenerContainerFactoryConfigurer to reuse Spring Boot’s default, you can disable transacted sessions, as follows: Java Kotlin import jakarta.jms.ConnectionFactory; import org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.jms.config.DefaultJmsListenerContainerFactory; @Configuration(proxyBeanMethods = false) public class MyJmsConfiguration { @Bean public DefaultJmsListenerContainerFactory jmsListenerContainerFactory(ConnectionFactory connectionFactory, DefaultJmsListenerContainerFactoryConfigurer configurer) { DefaultJmsListenerContainerFactory listenerFactory = new DefaultJmsListenerContainerFactory(); configurer.configure(listenerFactory, connectionFactory); listenerFactory.setTransactionManager(null); listenerFactory.setSessionTransacted(false); return listenerFactory; } } import jakarta.jms.ConnectionFactory import org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.jms.config.DefaultJmsListenerContainerFactory @Configuration(proxyBeanMethods = false) class MyJmsConfiguration { @Bean fun jmsListenerContainerFactory(connectionFactory: ConnectionFactory?, configurer: DefaultJmsListenerContainerFactoryConfigurer): DefaultJmsListenerContainerFactory { val listenerFactory = DefaultJmsListenerContainerFactory() configurer.configure(listenerFactory, connectionFactory) listenerFactory.setTransactionManager(null) listenerFactory.setSessionTransacted(false) return listenerFactory } } The preceding example overrides the default factory, and it should be applied to any other factory that your application defines, if any."
"https://docs.spring.io/spring-boot/how-to/batch.html","Batch Applications: A number of questions often arise when people use Spring Batch from within a Spring Boot application. This section addresses those questions. Specifying a Batch Data Source: By default, batch applications require a DataSource to store job details. Spring Batch expects a single DataSource by default. To have it use a DataSource other than the application’s main DataSource , declare a DataSource bean, annotating its @Bean method with @BatchDataSource . If you do so and want two data sources, remember to mark the other one @Primary . To take greater control, add @EnableBatchProcessing to one of your @Configuration classes or extend DefaultBatchConfiguration . See the API documentation of @EnableBatchProcessing(https://docs.spring.io/spring-batch/docs/5.1.x/api/org/springframework/batch/core/configuration/annotation/EnableBatchProcessing.html) and DefaultBatchConfiguration(https://docs.spring.io/spring-batch/docs/5.1.x/api/org/springframework/batch/core/configuration/support/DefaultBatchConfiguration.html) for more details. For more info about Spring Batch, see the Spring Batch project page(https://spring.io/projects/spring-batch) . Specifying a Batch Transaction Manager: Similar to Specifying a Batch Data Source(#howto.batch.specifying-a-data-source) , you can define a PlatformTransactionManager for use in the batch processing by marking it as @BatchTransactionManager . If you do so and want two transaction managers, remember to mark the other one as @Primary . Running Spring Batch Jobs on Startup: Spring Batch auto-configuration is enabled by adding spring-boot-starter-batch to your application’s classpath. If a single Job bean is found in the application context, it is executed on startup (see JobLauncherApplicationRunner(../api/java/org/springframework/boot/autoconfigure/batch/JobLauncherApplicationRunner.html) for details). If multiple Job beans are found, the job that should be executed must be specified using spring.batch.job.name . To disable running a Job found in the application context, set the spring.batch.job.enabled to false . See BatchAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.java) for more details. Running From the Command Line: Spring Boot converts any command line argument starting with -- to a property to add to the Environment , see accessing command line properties(../reference/features/external-config.html#features.external-config.command-line-args) . This should not be used to pass arguments to batch jobs. To specify batch arguments on the command line, use the regular format (that is without -- ), as shown in the following example: $ java -jar myapp.jar someParameter=someValue anotherParameter=anotherValue If you specify a property of the Environment on the command line, it is ignored by the job. Consider the following command: $ java -jar myapp.jar --server.port=7070 someParameter=someValue This provides only one argument to the batch job: someParameter=someValue . Restarting a Stopped or Failed Job: To restart a failed Job , all parameters (identifying and non-identifying) must be re-specified on the command line. Non-identifying parameters are not copied from the previous execution. This allows them to be modified or removed. When you’re using a custom JobParametersIncrementer , you have to gather all parameters managed by the incrementer to restart a failed execution. Storing the Job Repository: Spring Batch requires a data store for the Job repository. If you use Spring Boot, you must use an actual database. Note that it can be an in-memory database, see Configuring a Job Repository(https://docs.spring.io/spring-batch/reference/5.1/job.html#configuringJobRepository) ."
"https://docs.spring.io/spring-boot/how-to/actuator.html","Actuator: Spring Boot includes the Spring Boot Actuator. This section answers questions that often arise from its use. Change the HTTP Port or Address of the Actuator Endpoints: In a standalone application, the Actuator HTTP port defaults to the same as the main HTTP port. To make the application listen on a different port, set the external property: management.server.port . To listen on a completely different network address (such as when you have an internal network for management and an external one for user applications), you can also set management.server.address to a valid IP address to which the server is able to bind. For more detail, see the ManagementServerProperties(../api/java/org/springframework/boot/actuate/autoconfigure/web/server/ManagementServerProperties.html) source code and Customizing the Management Server Port(../reference/actuator/monitoring.html#actuator.monitoring.customizing-management-server-port) in the “Production-Ready Features” section. Customize the ‘whitelabel’ Error Page: Spring Boot installs a ‘whitelabel’ error page that you see in a browser client if you encounter a server error (machine clients consuming JSON and other media types should see a sensible response with the right error code). Set server.error.whitelabel.enabled=false to switch the default error page off. Doing so restores the default of the servlet container that you are using. Note that Spring Boot still tries to resolve the error view, so you should probably add your own error page rather than disabling it completely. Overriding the error page with your own depends on the templating technology that you use. For example, if you use Thymeleaf, you can add an error.html template. If you use FreeMarker, you can add an error.ftlh template. In general, you need a View that resolves with a name of error or a @Controller that handles the /error path. Unless you replaced some of the default configuration, you should find a BeanNameViewResolver in your ApplicationContext , so a @Bean named error would be one way of doing that. See ErrorMvcAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration.java) for more options. See also the section on Error Handling(../reference/web/servlet.html#web.servlet.spring-mvc.error-handling) for details of how to register handlers in the servlet container. Customizing Sanitization: To take control over the sanitization, define a SanitizingFunction bean. The SanitizableData with which the function is called provides access to the key and value as well as the PropertySource from which they came. This allows you to, for example, sanitize every value that comes from a particular property source. Each SanitizingFunction is called in order until a function changes the value of the sanitizable data. Map Health Indicators to Micrometer Metrics: Spring Boot health indicators return a Status type to indicate the overall system health. If you want to monitor or alert on levels of health for a particular application, you can export these statuses as metrics with Micrometer. By default, the status codes “UP”, “DOWN”, “OUT_OF_SERVICE” and “UNKNOWN” are used by Spring Boot. To export these, you will need to convert these states to some set of numbers so that they can be used with a Micrometer Gauge . The following example shows one way to write such an exporter: Java Kotlin import io.micrometer.core.instrument.Gauge; import io.micrometer.core.instrument.MeterRegistry; import org.springframework.boot.actuate.health.HealthEndpoint; import org.springframework.boot.actuate.health.Status; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyHealthMetricsExportConfiguration { public MyHealthMetricsExportConfiguration(MeterRegistry registry, HealthEndpoint healthEndpoint) { // This example presumes common tags (such as the app) are applied elsewhere Gauge.builder(""health"", healthEndpoint, this::getStatusCode).strongReference(true).register(registry); } private int getStatusCode(HealthEndpoint health) { Status status = health.health().getStatus(); if (Status.UP.equals(status)) { return 3; } if (Status.OUT_OF_SERVICE.equals(status)) { return 2; } if (Status.DOWN.equals(status)) { return 1; } return 0; } } import io.micrometer.core.instrument.Gauge import io.micrometer.core.instrument.MeterRegistry import org.springframework.boot.actuate.health.HealthEndpoint import org.springframework.boot.actuate.health.Status import org.springframework.context.annotation.Configuration @Configuration(proxyBeanMethods = false) class MyHealthMetricsExportConfiguration(registry: MeterRegistry, healthEndpoint: HealthEndpoint) { init { // This example presumes common tags (such as the app) are applied elsewhere Gauge.builder(""health"", healthEndpoint) { health -> getStatusCode(health).toDouble() }.strongReference(true).register(registry) } private fun getStatusCode(health: HealthEndpoint) = when (health.health().status) { Status.UP -> 3 Status.OUT_OF_SERVICE -> 2 Status.DOWN -> 1 else -> 0 } }"
"https://docs.spring.io/spring-boot/how-to/security.html","Security: This section addresses questions about security when working with Spring Boot, including questions that arise from using Spring Security with Spring Boot. For more about Spring Security, see the Spring Security project page(https://spring.io/projects/spring-security) . Switch Off the Spring Boot Security Configuration: If you define a @Configuration with a SecurityFilterChain bean in your application, this action switches off the default webapp security settings in Spring Boot. Change the UserDetailsService and Add User Accounts: If you provide a @Bean of type AuthenticationManager , AuthenticationProvider , or UserDetailsService , the default @Bean for InMemoryUserDetailsManager is not created. This means you have the full feature set of Spring Security available (such as various authentication options(https://docs.spring.io/spring-security/reference/6.3/servlet/authentication/index.html) ). The easiest way to add user accounts is by providing your own UserDetailsService bean. Enable HTTPS When Running Behind a Proxy Server: Ensuring that all your main endpoints are only available over HTTPS is an important chore for any application. If you use Tomcat as a servlet container, then Spring Boot adds Tomcat’s own RemoteIpValve automatically if it detects some environment settings, allowing you to rely on the HttpServletRequest to report whether it is secure or not (even downstream of a proxy server that handles the real SSL termination). The standard behavior is determined by the presence or absence of certain request headers ( x-forwarded-for and x-forwarded-proto ), whose names are conventional, so it should work with most front-end proxies. You can switch on the valve by adding some entries to application.properties , as shown in the following example: Properties YAML server.tomcat.remoteip.remote-ip-header=x-forwarded-for server.tomcat.remoteip.protocol-header=x-forwarded-proto server: tomcat: remoteip: remote-ip-header: ""x-forwarded-for"" protocol-header: ""x-forwarded-proto"" (The presence of either of those properties switches on the valve. Alternatively, you can add the RemoteIpValve by customizing the TomcatServletWebServerFactory using a WebServerFactoryCustomizer bean.) To configure Spring Security to require a secure channel for all (or some) requests, consider adding your own SecurityFilterChain bean that adds the following HttpSecurity configuration: Java Kotlin import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.web.SecurityFilterChain; @Configuration public class MySecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { // Customize the application security ... http.requiresChannel((channel) -> channel.anyRequest().requiresSecure()); return http.build(); } } import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.security.config.annotation.web.builders.HttpSecurity import org.springframework.security.web.SecurityFilterChain @Configuration class MySecurityConfig { @Bean fun securityFilterChain(http: HttpSecurity): SecurityFilterChain { // Customize the application security ... http.requiresChannel { requests -> requests.anyRequest().requiresSecure() } return http.build() } }"
"https://docs.spring.io/spring-boot/how-to/hotswapping.html","Hot Swapping: Spring Boot supports hot swapping. This section answers questions about how it works. Reload Static Content: There are several options for hot reloading. The recommended approach is to use spring-boot-devtools(../reference/using/devtools.html) , as it provides additional development-time features, such as support for fast application restarts and LiveReload as well as sensible development-time configuration (such as template caching). Devtools works by monitoring the classpath for changes. This means that static resource changes must be ""built"" for the change to take effect. By default, this happens automatically in Eclipse when you save your changes. In IntelliJ IDEA, the Make Project command triggers the necessary build. Due to the default restart exclusions(../reference/using/devtools.html#using.devtools.restart.excluding-resources) , changes to static resources do not trigger a restart of your application. They do, however, trigger a live reload. Alternatively, running in an IDE (especially with debugging on) is a good way to do development (all modern IDEs allow reloading of static resources and usually also allow hot-swapping of Java class changes). Finally, the Maven and Gradle plugins(../build-tool-plugin/index.html) can be configured (see the addResources property) to support running from the command line with reloading of static files directly from source. You can use that with an external css/js compiler process if you are writing that code with higher-level tools. Reload Templates without Restarting the Container: Most of the templating technologies supported by Spring Boot include a configuration option to disable caching (described later in this document). If you use the spring-boot-devtools module, these properties are automatically configured(../reference/using/devtools.html#using.devtools.property-defaults) for you at development time. Thymeleaf Templates: If you use Thymeleaf, set spring.thymeleaf.cache to false . See ThymeleafAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/thymeleaf/ThymeleafAutoConfiguration.java) for other Thymeleaf customization options. FreeMarker Templates: If you use FreeMarker, set spring.freemarker.cache to false . See FreeMarkerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/freemarker/FreeMarkerAutoConfiguration.java) for other FreeMarker customization options. Groovy Templates: If you use Groovy templates, set spring.groovy.template.cache to false . See GroovyTemplateAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/groovy/template/GroovyTemplateAutoConfiguration.java) for other Groovy customization options. Fast Application Restarts: The spring-boot-devtools module includes support for automatic application restarts. While not as fast as technologies such as JRebel(https://www.jrebel.com/products/jrebel) it is usually significantly faster than a “cold start”. You should probably give it a try before investigating some of the more complex reload options discussed later in this document. For more details, see the Developer Tools(../reference/using/devtools.html) section. Reload Java Classes without Restarting the Container: Many modern IDEs (Eclipse, IDEA, and others) support hot swapping of bytecode. Consequently, if you make a change that does not affect class or method signatures, it should reload cleanly with no side effects."
"https://docs.spring.io/spring-boot/how-to/testing.html","Testing: Spring Boot includes a number of testing utilities and support classes as well as a dedicated starter that provides common test dependencies. This section answers common questions about testing. Testing With Spring Security: Spring Security provides support for running tests as a specific user. For example, the test in the snippet below will run with an authenticated user that has the ADMIN role. Java Kotlin import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.security.test.context.support.WithMockUser; import org.springframework.test.web.servlet.MockMvc; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; @WebMvcTest(UserController.class) class MySecurityTests { @Autowired private MockMvc mvc; @Test @WithMockUser(roles = ""ADMIN"") void requestProtectedUrlWithUser() throws Exception { this.mvc.perform(get(""/"")); } } import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest import org.springframework.security.test.context.support.WithMockUser import org.springframework.test.web.servlet.MockMvc import org.springframework.test.web.servlet.request.MockMvcRequestBuilders @WebMvcTest(UserController::class) class MySecurityTests(@Autowired val mvc: MockMvc) { @Test @WithMockUser(roles = [""ADMIN""]) fun requestProtectedUrlWithUser() { mvc.perform(MockMvcRequestBuilders.get(""/"")) } } Spring Security provides comprehensive integration with Spring MVC Test, and this can also be used when testing controllers using the @WebMvcTest slice and MockMvc . For additional details on Spring Security’s testing support, see Spring Security’s reference documentation(https://docs.spring.io/spring-security/reference/6.3/servlet/test/index.html) . Structure @Configuration Classes for Inclusion in Slice Tests: Slice tests work by restricting Spring Framework’s component scanning to a limited set of components based on their type. For any beans that are not created through component scanning, for example, beans that are created using the @Bean annotation, slice tests will not be able to include/exclude them from the application context. Consider this example: import org.apache.commons.dbcp2.BasicDataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.jdbc.DataSourceBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.web.SecurityFilterChain; @Configuration(proxyBeanMethods = false) public class MyConfiguration { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated()); return http.build(); } @Bean @ConfigurationProperties(""app.datasource.second"") public BasicDataSource secondDataSource() { return DataSourceBuilder.create().type(BasicDataSource.class).build(); } } For a @WebMvcTest for an application with the above @Configuration class, you might expect to have the SecurityFilterChain bean in the application context so that you can test if your controller endpoints are secured properly. However, MyConfiguration is not picked up by @WebMvcTest’s component scanning filter because it doesn’t match any of the types specified by the filter. You can include the configuration explicitly by annotating the test class with @Import(MyConfiguration.class) . This will load all the beans in MyConfiguration including the BasicDataSource bean which isn’t required when testing the web tier. Splitting the configuration class into two will enable importing just the security configuration. import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.web.SecurityFilterChain; @Configuration(proxyBeanMethods = false) public class MySecurityConfiguration { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated()); return http.build(); } } import org.apache.commons.dbcp2.BasicDataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.jdbc.DataSourceBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration(proxyBeanMethods = false) public class MyDatasourceConfiguration { @Bean @ConfigurationProperties(""app.datasource.second"") public BasicDataSource secondDataSource() { return DataSourceBuilder.create().type(BasicDataSource.class).build(); } } Having a single configuration class can be inefficient when beans from a certain domain need to be included in slice tests. Instead, structuring the application’s configuration as multiple granular classes with beans for a specific domain can enable importing them only for specific slice tests."
"https://docs.spring.io/spring-boot/how-to/build.html","Build: Spring Boot includes build plugins for Maven and Gradle. This section answers common questions about these plugins. Generate Build Information: Both the Maven plugin and the Gradle plugin allow generating build information containing the coordinates, name, and version of the project. The plugins can also be configured to add additional properties through configuration. When such a file is present, Spring Boot auto-configures a BuildProperties bean. To generate build information with Maven, add an execution for the build-info goal, as shown in the following example: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <version>3.3.4</version> <executions> <execution> <goals> <goal>build-info</goal> </goals> </execution> </executions> </plugin> </plugins> </build> See the Spring Boot Maven Plugin documentation(../maven-plugin/build-info.html) for more details. The following example does the same with Gradle: springBoot { buildInfo() } See the Spring Boot Gradle Plugin documentation(../gradle-plugin/integrating-with-actuator.html) for more details. Generate Git Information: Both Maven and Gradle allow generating a git.properties file containing information about the state of your git source code repository when the project was built. For Maven users, the spring-boot-starter-parent POM includes a pre-configured plugin to generate a git.properties file. To use it, add the following declaration for the Git Commit Id Plugin(https://github.com/git-commit-id/git-commit-id-maven-plugin) to your POM: <build> <plugins> <plugin> <groupId>io.github.git-commit-id</groupId> <artifactId>git-commit-id-maven-plugin</artifactId> </plugin> </plugins> </build> Gradle users can achieve the same result by using the gradle-git-properties(https://plugins.gradle.org/plugin/com.gorylenko.gradle-git-properties) plugin, as shown in the following example: plugins { id ""com.gorylenko.gradle-git-properties"" version ""2.4.1"" } Both the Maven and Gradle plugins allow the properties that are included in git.properties to be configured. The commit time in git.properties is expected to match the following format: yyyy-MM-dd’T’HH:mm:ssZ . This is the default format for both plugins listed above. Using this format lets the time be parsed into a Date and its format, when serialized to JSON, to be controlled by Jackson’s date serialization configuration settings. Customize Dependency Versions: The spring-boot-dependencies POM manages the versions of common dependencies. The Spring Boot plugins for Maven and Gradle allow these managed dependency versions to be customized using build properties. Each Spring Boot release is designed and tested against this specific set of third-party dependencies. Overriding versions may cause compatibility issues. To override dependency versions with Maven, see Using the Plugin(../maven-plugin/using.html) in the Maven plugin’s documentation. To override dependency versions in Gradle, see Customizing Managed Versions(../gradle-plugin/managing-dependencies.html#managing-dependencies.dependency-management-plugin.customizing) in the Gradle plugin’s documentation. Create an Executable JAR with Maven: The spring-boot-maven-plugin can be used to create an executable “fat” JAR. If you use the spring-boot-starter-parent POM, you can declare the plugin and your jars are repackaged as follows: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> If you do not use the parent POM, you can still use the plugin. However, you must additionally add an <executions> section, as follows: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <version>3.3.4</version> <executions> <execution> <goals> <goal>repackage</goal> </goals> </execution> </executions> </plugin> </plugins> </build> See the plugin documentation(../maven-plugin/packaging.html#packaging.repackage-goal) for full usage details. Use a Spring Boot Application as a Dependency: Like a war file, a Spring Boot application is not intended to be used as a dependency. If your application contains classes that you want to share with other projects, the recommended approach is to move that code into a separate module. The separate module can then be depended upon by your application and other projects. If you cannot rearrange your code as recommended above, Spring Boot’s Maven and Gradle plugins must be configured to produce a separate artifact that is suitable for use as a dependency. The executable archive cannot be used as a dependency as the executable jar format(../specification/executable-jar/nested-jars.html#appendix.executable-jar.nested-jars.jar-structure) packages application classes in BOOT-INF/classes . This means that they cannot be found when the executable jar is used as a dependency. To produce the two artifacts, one that can be used as a dependency and one that is executable, a classifier must be specified. This classifier is applied to the name of the executable archive, leaving the default archive for use as a dependency. To configure a classifier of exec in Maven, you can use the following configuration: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <classifier>exec</classifier> </configuration> </plugin> </plugins> </build> Extract Specific Libraries When an Executable Jar Runs: Most nested libraries in an executable jar do not need to be unpacked in order to run. However, certain libraries can have problems. For example, JRuby includes its own nested jar support, which assumes that the jruby-complete.jar is always directly available as a file in its own right. To deal with any problematic libraries, you can flag that specific nested jars should be automatically unpacked when the executable jar first runs. Such nested jars are written beneath the temporary directory identified by the java.io.tmpdir system property. Care should be taken to ensure that your operating system is configured so that it will not delete the jars that have been unpacked to the temporary directory while the application is still running. For example, to indicate that JRuby should be flagged for unpacking by using the Maven Plugin, you would add the following configuration: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <requiresUnpack> <dependency> <groupId>org.jruby</groupId> <artifactId>jruby-complete</artifactId> </dependency> </requiresUnpack> </configuration> </plugin> </plugins> </build> Create a Non-executable JAR with Exclusions: Often, if you have an executable and a non-executable jar as two separate build products, the executable version has additional configuration files that are not needed in a library jar. For example, the application.yaml configuration file might be excluded from the non-executable JAR. In Maven, the executable jar must be the main artifact and you can add a classified jar for the library, as follows: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> <plugin> <artifactId>maven-jar-plugin</artifactId> <executions> <execution> <id>lib</id> <phase>package</phase> <goals> <goal>jar</goal> </goals> <configuration> <classifier>lib</classifier> <excludes> <exclude>application.yaml</exclude> </excludes> </configuration> </execution> </executions> </plugin> </plugins> </build> Remote Debug a Spring Boot Application Started with Maven: To attach a remote debugger to a Spring Boot application that was started with Maven, you can use the jvmArguments property of the maven plugin(../maven-plugin/index.html) . See this example(../maven-plugin/run.html#run.examples.debug) for more details. Build an Executable Archive From Ant without Using spring-boot-antlib: To build with Ant, you need to grab dependencies, compile, and then create a jar or war archive. To make it executable, you can either use the spring-boot-antlib module or you can follow these instructions: If you are building a jar, package the application’s classes and resources in a nested BOOT-INF/classes directory. If you are building a war, package the application’s classes in a nested WEB-INF/classes directory as usual. Add the runtime dependencies in a nested BOOT-INF/lib directory for a jar or WEB-INF/lib for a war. Remember not to compress the entries in the archive. Add the provided (embedded container) dependencies in a nested BOOT-INF/lib directory for a jar or WEB-INF/lib-provided for a war. Remember not to compress the entries in the archive. Add the spring-boot-loader classes at the root of the archive (so that the Main-Class is available). Use the appropriate launcher (such as JarLauncher for a jar file) as a Main-Class attribute in the manifest and specify the other properties it needs as manifest entries — principally, by setting a Start-Class property. The following example shows how to build an executable archive with Ant: <target name=""build"" depends=""compile""> <jar destfile=""target/${ant.project.name}-${spring-boot.version}.jar"" compress=""false""> <mappedresources> <fileset dir=""target/classes"" /> <globmapper from=""*"" to=""BOOT-INF/classes/*""/> </mappedresources> <mappedresources> <fileset dir=""src/main/resources"" erroronmissingdir=""false""/> <globmapper from=""*"" to=""BOOT-INF/classes/*""/> </mappedresources> <mappedresources> <fileset dir=""${lib.dir}/runtime"" /> <globmapper from=""*"" to=""BOOT-INF/lib/*""/> </mappedresources> <zipfileset src=""${lib.dir}/loader/spring-boot-loader-jar-${spring-boot.version}.jar"" /> <manifest> <attribute name=""Main-Class"" value=""org.springframework.boot.loader.launch.JarLauncher"" /> <attribute name=""Start-Class"" value=""${start-class}"" /> </manifest> </jar> </target>"
"https://docs.spring.io/spring-boot/how-to/aot.html","Ahead-of-Time Processing: A number of questions often arise when people use the ahead-of-time processing of Spring Boot applications. This section addresses those questions. Conditions: Ahead-of-time processing optimizes the application and evaluates @Conditional(https://docs.spring.io/spring-framework/docs/6.1.x/javadoc-api/org/springframework/context/annotation/Conditional.html) annotations based on the environment at build time. Profiles(../reference/features/profiles.html) are implemented through conditions and are therefore affected, too. If you want beans that are created based on a condition in an ahead-of-time optimized application, you have to set up the environment when building the application. The beans which are created while ahead-of-time processing at build time are then always created when running the application and can’t be switched off. To do this, you can set the profiles which should be used when building the application. For Maven, this works by setting the profiles configuration of the spring-boot-maven-plugin:process-aot execution: <profile> <id>native</id> <build> <pluginManagement> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>process-aot</id> <configuration> <profiles>profile-a,profile-b</profiles> </configuration> </execution> </executions> </plugin> </plugins> </pluginManagement> </build> </profile> For Gradle, you need to configure the ProcessAot task: tasks.withType(org.springframework.boot.gradle.tasks.aot.ProcessAot).configureEach { args('--spring.profiles.active=profile-a,profile-b') } Profiles which only change configuration properties that don’t influence conditions are supported without limitations when running ahead-of-time optimized applications."
"https://docs.spring.io/spring-boot/how-to/native-image/index.html","GraalVM Native Applications: This section contains details on developing and testing Spring Boot applications as GraalVM native images. For an overview of GraalVM native image concepts, see the Introducing GraalVM Native Images(../../reference/packaging/native-image/introducing-graalvm-native-images.html) section."
"https://docs.spring.io/spring-boot/how-to/native-image/developing-your-first-application.html","Developing Your First GraalVM Native Application: There are two main ways to build a Spring Boot native image application: Using Spring Boot support for Cloud Native Buildpacks(../../reference/packaging/container-images/cloud-native-buildpacks.html) with the Paketo Java Native Image buildpack(https://paketo.io/docs/reference/java-native-image-reference/) to generate a lightweight container containing a native executable. Using GraalVM Native Build Tools to generate a native executable. The easiest way to start a new native Spring Boot project is to go to start.spring.io(https://start.spring.io) , add the GraalVM Native Support dependency and generate the project. The included HELP.md file will provide getting started hints. Sample Application: We need an example application that we can use to create our native image. For our purposes, the simple ""Hello World!"" web application that’s covered in the Developing Your First Spring Boot Application(../../tutorial/first-application/index.html) section will suffice. To recap, our main application code looks like this: import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @SpringBootApplication public class MyApplication { @RequestMapping(""/"") String home() { return ""Hello World!""; } public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } This application uses Spring MVC and embedded Tomcat, both of which have been tested and verified to work with GraalVM native images. Building a Native Image Using Buildpacks: Spring Boot supports building Docker images containing native executables, using Cloud Native Buildpacks (CNB) integration with both Maven and Gradle and the Paketo Java Native Image buildpack(https://paketo.io/docs/reference/java-native-image-reference/) . This means you can just type a single command and quickly get a sensible image into your locally running Docker daemon. The resulting image doesn’t contain a JVM, instead the native image is compiled statically. This leads to smaller images. The CNB builder used for the images is paketobuildpacks/builder-jammy-tiny:latest . It has small footprint and reduced attack surface, but you can also use paketobuildpacks/builder-jammy-base:latest or paketobuildpacks/builder-jammy-full:latest to have more tools available in the image if required. System Requirements: Docker should be installed. See Get Docker(https://docs.docker.com/installation/#installation) for more details. Configure it to allow non-root user(https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user) if you are on Linux. You can run docker run hello-world (without sudo ) to check the Docker daemon is reachable as expected. Check the Maven(../../maven-plugin/build-image.html#build-image.docker-daemon) or Gradle(../../gradle-plugin/packaging-oci-image.html#build-image.docker-daemon) Spring Boot plugin documentation for more details. On macOS, it is recommended to increase the memory allocated to Docker to at least 8GB , and potentially add more CPUs as well. See this Stack Overflow answer(https://stackoverflow.com/questions/44533319/how-to-assign-more-memory-to-docker-container/44533437#44533437) for more details. On Microsoft Windows, make sure to enable the Docker WSL 2 backend(https://docs.docker.com/docker-for-windows/wsl/) for better performance. Using Maven: To build a native image container using Maven you should ensure that your pom.xml file uses the spring-boot-starter-parent and the org.graalvm.buildtools:native-maven-plugin . You should have a <parent> section that looks like this: <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>3.3.4</version> </parent> You additionally should have this in the <build> <plugins> section: <plugin> <groupId>org.graalvm.buildtools</groupId> <artifactId>native-maven-plugin</artifactId> </plugin> The spring-boot-starter-parent declares a native profile that configures the executions that need to run in order to create a native image. You can activate profiles using the -P flag on the command line. If you don’t want to use spring-boot-starter-parent you’ll need to configure executions for the process-aot goal from Spring Boot’s plugin and the add-reachability-metadata goal from the Native Build Tools plugin. To build the image, you can run the spring-boot:build-image goal with the native profile active: $ mvn -Pnative spring-boot:build-image Using Gradle: The Spring Boot Gradle plugin automatically configures AOT tasks when the GraalVM Native Image plugin is applied. You should check that your Gradle build contains a plugins block that includes org.graalvm.buildtools.native . As long as the org.graalvm.buildtools.native plugin is applied, the bootBuildImage task will generate a native image rather than a JVM one. You can run the task using: $ gradle bootBuildImage Running the example: Once you have run the appropriate build command, a Docker image should be available. You can start your application using docker run : $ docker run --rm -p 8080:8080 docker.io/library/myproject:0.0.1-SNAPSHOT You should see output similar to the following: . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v{version-spring-boot}) ....... . . . ....... . . . (log output here) ....... . . . ........ Started MyApplication in 0.08 seconds (process running for 0.095) The startup time differs from machine to machine, but it should be much faster than a Spring Boot application running on a JVM. If you open a web browser to localhost:8080(http://localhost:8080) , you should see the following output: Hello World! To gracefully exit the application, press ctrl-c . Building a Native Image using Native Build Tools: If you want to generate a native executable directly without using Docker, you can use GraalVM Native Build Tools. Native Build Tools are plugins shipped by GraalVM for both Maven and Gradle. You can use them to perform a variety of GraalVM tasks, including generating a native image. Prerequisites: To build a native image using the Native Build Tools, you’ll need a GraalVM distribution on your machine. You can either download it manually on the Liberica Native Image Kit page(https://bell-sw.com/pages/downloads/native-image-kit/#/nik-22-17) , or you can use a download manager like SDKMAN!. Linux and macOS: To install the native image compiler on macOS or Linux, we recommend using SDKMAN!. Get SDKMAN! from sdkman.io(https://sdkman.io) and install the Liberica GraalVM distribution by using the following commands: $ sdk install java 22.3.r17-nik $ sdk use java 22.3.r17-nik Verify that the correct version has been configured by checking the output of java -version : $ java -version openjdk version ""17.0.5"" 2022-10-18 LTS OpenJDK Runtime Environment GraalVM 22.3.0 (build 17.0.5+8-LTS) OpenJDK 64-Bit Server VM GraalVM 22.3.0 (build 17.0.5+8-LTS, mixed mode) Windows: On Windows, follow these instructions(https://medium.com/graalvm/using-graalvm-and-native-image-on-windows-10-9954dc071311) to install either GraalVM(https://www.graalvm.org/downloads/) or Liberica Native Image Kit(https://bell-sw.com/pages/downloads/native-image-kit/#/nik-22-17) in version 22.3, the Visual Studio Build Tools and the Windows SDK. Due to the Windows related command-line maximum length(https://docs.microsoft.com/en-US/troubleshoot/windows-client/shell-experience/command-line-string-limitation) , make sure to use x64 Native Tools Command Prompt instead of the regular Windows command line to run Maven or Gradle plugins. Using Maven: As with the buildpacks support(#howto.native-image.developing-your-first-application.buildpacks.maven) , you need to make sure that you’re using spring-boot-starter-parent in order to inherit the native profile and that the org.graalvm.buildtools:native-maven-plugin plugin is used. With the native profile active, you can invoke the native:compile goal to trigger native-image compilation: $ mvn -Pnative native:compile The native image executable can be found in the target directory. Using Gradle: When the Native Build Tools Gradle plugin is applied to your project, the Spring Boot Gradle plugin will automatically trigger the Spring AOT engine. Task dependencies are automatically configured, so you can just run the standard nativeCompile task to generate a native image: $ gradle nativeCompile The native image executable can be found in the build/native/nativeCompile directory. Running the Example: At this point, your application should work. You can now start the application by running it directly: Maven Gradle $ target/myproject $ build/native/nativeCompile/myproject You should see output similar to the following: . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v3.3.4) ....... . . . ....... . . . (log output here) ....... . . . ........ Started MyApplication in 0.08 seconds (process running for 0.095) The startup time differs from machine to machine, but it should be much faster than a Spring Boot application running on a JVM. If you open a web browser to localhost:8080(http://localhost:8080) , you should see the following output: Hello World! To gracefully exit the application, press ctrl-c ."
"https://docs.spring.io/spring-boot/how-to/native-image/testing-native-applications.html","Testing GraalVM Native Images: When writing native image applications, we recommend that you continue to use the JVM whenever possible to develop the majority of your unit and integration tests. This will help keep developer build times down and allow you to use existing IDE integrations. With broad test coverage on the JVM, you can then focus native image testing on the areas that are likely to be different. For native image testing, you’re generally looking to ensure that the following aspects work: The Spring AOT engine is able to process your application, and it will run in an AOT-processed mode. GraalVM has enough hints to ensure that a valid native image can be produced. Testing Ahead-of-Time Processing With the JVM: When a Spring Boot application runs, it attempts to detect if it is running as a native image. If it is running as a native image, it will initialize the application using the code that was generated during at build-time by the Spring AOT engine. If the application is running on a regular JVM, then any AOT generated code is ignored. Since the native-image compilation phase can take a while to complete, it’s sometimes useful to run your application on the JVM but have it use the AOT generated initialization code. Doing so helps you to quickly validate that there are no errors in the AOT generated code and nothing is missing when your application is eventually converted to a native image. To run a Spring Boot application on the JVM and have it use AOT generated code you can set the spring.aot.enabled system property to true . For example: $ java -Dspring.aot.enabled=true -jar myapplication.jar You need to ensure that the jar you are testing includes AOT generated code. For Maven, this means that you should build with -Pnative to activate the native profile. For Gradle, you need to ensure that your build includes the org.graalvm.buildtools.native plugin. If your application starts with the spring.aot.enabled property set to true , then you have higher confidence that it will work when converted to a native image. You can also consider running integration tests against the running application. For example, you could use the Spring WebClient to call your application REST endpoints. Or you might consider using a project like Selenium to check your application’s HTML responses. Testing With Native Build Tools: GraalVM Native Build Tools includes the ability to run tests inside a native image. This can be helpful when you want to deeply test that the internals of your application work in a GraalVM native image. Generating the native image that contains the tests to run can be a time-consuming operation, so most developers will probably prefer to use the JVM locally. They can, however, be very useful as part of a CI pipeline. For example, you might choose to run native tests once a day. Spring Framework includes ahead-of-time support for running tests. All the usual Spring testing features work with native image tests. For example, you can continue to use the @SpringBootTest annotation. You can also use Spring Boot test slices(../../reference/testing/spring-boot-applications.html#testing.spring-boot-applications.autoconfigured-tests) to test only specific parts of your application. Spring Framework’s native testing support works in the following way: Tests are analyzed in order to discover any ApplicationContext instances that will be required. Ahead-of-time processing is applied to each of these application contexts and assets are generated. A native image is created, with the generated assets being processed by GraalVM. The native image also includes the JUnit TestEngine configured with a list of the discovered tests. The native image is started, triggering the engine which will run each test and report results. Using Maven: To run native tests using Maven, ensure that your pom.xml file uses the spring-boot-starter-parent . You should have a <parent> section that looks like this: <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>3.3.4</version> </parent> The spring-boot-starter-parent declares a nativeTest profile that configures the executions that are needed to run the native tests. You can activate profiles using the -P flag on the command line. If you don’t want to use spring-boot-starter-parent you’ll need to configure executions for the process-test-aot goal from the Spring Boot plugin and the test goal from the Native Build Tools plugin. To build the image and run the tests, use the test goal with the nativeTest profile active: $ mvn -PnativeTest test Using Gradle: The Spring Boot Gradle plugin automatically configures AOT test tasks when the GraalVM Native Image plugin is applied. You should check that your Gradle build contains a plugins block that includes org.graalvm.buildtools.native . To run native tests using Gradle you can use the nativeTest task: $ gradle nativeTest"
"https://docs.spring.io/spring-boot/how-to/class-data-sharing.html","Class Data Sharing: This section includes information about using Class Data Sharing (CDS) with Spring Boot applications. For an overview of Spring Boot support for CDS, see Class Data Sharing(../reference/packaging/class-data-sharing.html) . Packaging an Application Using CDS and Buildpacks: Spring Boot’s support for Cloud Native Buildpacks(../reference/packaging/container-images/cloud-native-buildpacks.html) along with the Paketo Java buildpack(https://paketo.io/docs/reference/java-reference) and its Spring Boot support(https://paketo.io/docs/reference/java-reference/#spring-boot-applications) can be used to generate a Docker image containing a CDS-optimized application. To enable CDS optimization in a generated Docker image, the buildpack environment variable BP_JVM_CDS_ENABLED should be set to true when building the image as described in the Maven plugin(../maven-plugin/build-image.html#build-image.examples.builder-configuration) and Gradle plugin(../gradle-plugin/packaging-oci-image.html#build-image.examples.builder-configuration) documentation. This will cause the buildpack to do a training run of the application, save the CDS archive in the image, and use the CDS archive when launching the application. The Paketo Buildpack for Spring Boot documentation(https://github.com/paketo-buildpacks/spring-boot?tab=readme-ov-file#configuration) has information on other configuration options that can be enabled with builder environment variables, like CDS_TRAINING_JAVA_TOOL_OPTIONS that allows to override the default JAVA_TOOL_OPTIONS , only for the CDS training run. Packaging an Application Using CDS and Dockerfiles: If you don’t want to use Cloud Native Buildpacks, it is also possible to use CDS with a Dockerfile . For more information about that, please see the Dockerfiles reference documentation(../reference/packaging/container-images/dockerfiles.html#packaging.container-images.dockerfiles.cds) . Preventing Remote Services Interaction During the Training Run: When performing the training run, it may be needed to customize the Spring Boot application configuration to prevent connections to remote services that may happen before the Spring lifecycle is started. This can typically happen with early database interactions and can be handled via related configuration that can be applied by default to your application (or specifically to the training run) to prevent such interactions, see related documentation(https://github.com/spring-projects/spring-lifecycle-smoke-tests/blob/main/README.adoc#training-run-configuration) ."
"https://docs.spring.io/spring-boot/how-to/deployment/index.html","Deploying Spring Boot Applications: Spring Boot’s flexible packaging options provide a great deal of choice when it comes to deploying your application. You can deploy Spring Boot applications to a variety of cloud platforms, to virtual/real machines, or make them fully executable for Unix systems. This section covers some of the more common deployment scenarios."
"https://docs.spring.io/spring-boot/how-to/deployment/traditional-deployment.html","Traditional Deployment: Spring Boot supports traditional deployment as well as more modern forms of deployment. This section answers common questions about traditional deployment. Create a Deployable War File: Because Spring WebFlux does not strictly depend on the servlet API and applications are deployed by default on an embedded Reactor Netty server, War deployment is not supported for WebFlux applications. The first step in producing a deployable war file is to provide a SpringBootServletInitializer subclass and override its configure method. Doing so makes use of Spring Framework’s servlet 3.0 support and lets you configure your application when it is launched by the servlet container. Typically, you should update your application’s main class to extend SpringBootServletInitializer , as shown in the following example: Java Kotlin import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.web.servlet.support.SpringBootServletInitializer; @SpringBootApplication public class MyApplication extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { return application.sources(MyApplication.class); } public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.builder.SpringApplicationBuilder import org.springframework.boot.runApplication import org.springframework.boot.web.servlet.support.SpringBootServletInitializer @SpringBootApplication class MyApplication : SpringBootServletInitializer() { override fun configure(application: SpringApplicationBuilder): SpringApplicationBuilder { return application.sources(MyApplication::class.java) } } fun main(args: Array<String>) { runApplication<MyApplication>(*args) } The next step is to update your build configuration such that your project produces a war file rather than a jar file. If you use Maven and spring-boot-starter-parent (which configures Maven’s war plugin for you), all you need to do is to modify pom.xml to change the packaging to war, as follows: <packaging>war</packaging> If you use Gradle, you need to modify build.gradle to apply the war plugin to the project, as follows: apply plugin: 'war' The final step in the process is to ensure that the embedded servlet container does not interfere with the servlet container to which the war file is deployed. To do so, you need to mark the embedded servlet container dependency as being provided. If you use Maven, the following example marks the servlet container (Tomcat, in this case) as being provided: <dependencies> <!-- ... --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-tomcat</artifactId> <scope>provided</scope> </dependency> <!-- ... --> </dependencies> If you use Gradle, the following example marks the servlet container (Tomcat, in this case) as being provided: dependencies { // ... providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat' // ... } providedRuntime is preferred to Gradle’s compileOnly configuration. Among other limitations, compileOnly dependencies are not on the test classpath, so any web-based integration tests fail. If you use the Spring Boot Build Tool Plugins(../../build-tool-plugin/index.html) , marking the embedded servlet container dependency as provided produces an executable war file with the provided dependencies packaged in a lib-provided directory. This means that, in addition to being deployable to a servlet container, you can also run your application by using java -jar on the command line. Convert an Existing Application to Spring Boot: To convert an existing non-web Spring application to a Spring Boot application, replace the code that creates your ApplicationContext and replace it with calls to SpringApplication or SpringApplicationBuilder . Spring MVC web applications are generally amenable to first creating a deployable war application and then migrating it later to an executable war or jar. See the Getting Started Guide on Converting a jar to a war(https://spring.io/guides/gs/convert-jar-to-war/) . To create a deployable war by extending SpringBootServletInitializer (for example, in a class called Application ) and adding the Spring Boot @SpringBootApplication annotation, use code similar to that shown in the following example: Java Kotlin import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.web.servlet.support.SpringBootServletInitializer; @SpringBootApplication public class MyApplication extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { // Customize the application or call application.sources(...) to add sources // Since our example is itself a @Configuration class (through // @SpringBootApplication) // we actually do not need to override this method. return application; } } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.builder.SpringApplicationBuilder import org.springframework.boot.runApplication import org.springframework.boot.web.servlet.support.SpringBootServletInitializer @SpringBootApplication class MyApplication : SpringBootServletInitializer() { override fun configure(application: SpringApplicationBuilder): SpringApplicationBuilder { // Customize the application or call application.sources(...) to add sources // Since our example is itself a @Configuration class (through @SpringBootApplication) // we actually do not need to override this method. return application } } Remember that, whatever you put in the sources is merely a Spring ApplicationContext . Normally, anything that already works should work here. There might be some beans you can remove later and let Spring Boot provide its own defaults for them, but it should be possible to get something working before you need to do that. Static resources can be moved to /public (or /static or /resources or /META-INF/resources ) in the classpath root. The same applies to messages.properties (which Spring Boot automatically detects in the root of the classpath). Vanilla usage of Spring DispatcherServlet and Spring Security should require no further changes. If you have other features in your application (for instance, using other servlets or filters), you may need to add some configuration to your Application context, by replacing those elements from the web.xml , as follows: A @Bean of type Servlet or ServletRegistrationBean installs that bean in the container as if it were a <servlet/> and <servlet-mapping/> in web.xml . A @Bean of type Filter or FilterRegistrationBean behaves similarly (as a <filter/> and <filter-mapping/> ). An ApplicationContext in an XML file can be added through an @ImportResource in your Application . Alternatively, cases where annotation configuration is heavily used already can be recreated in a few lines as @Bean definitions. Once the war file is working, you can make it executable by adding a main method to your Application , as shown in the following example: Java Kotlin public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } fun main(args: Array<String>) { runApplication<MyApplication>(*args) } If you intend to start your application as a war or as an executable application, you need to share the customizations of the builder in a method that is both available to the SpringBootServletInitializer callback and in the main method in a class similar to the following: Java Kotlin import org.springframework.boot.Banner; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.web.servlet.support.SpringBootServletInitializer; @SpringBootApplication public class MyApplication extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return customizerBuilder(builder); } public static void main(String[] args) { customizerBuilder(new SpringApplicationBuilder()).run(args); } private static SpringApplicationBuilder customizerBuilder(SpringApplicationBuilder builder) { return builder.sources(MyApplication.class).bannerMode(Banner.Mode.OFF); } } import org.springframework.boot.Banner import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.builder.SpringApplicationBuilder import org.springframework.boot.web.servlet.support.SpringBootServletInitializer @SpringBootApplication class MyApplication : SpringBootServletInitializer() { override fun configure(builder: SpringApplicationBuilder): SpringApplicationBuilder { return customizerBuilder(builder) } companion object { @JvmStatic fun main(args: Array<String>) { customizerBuilder(SpringApplicationBuilder()).run(*args) } private fun customizerBuilder(builder: SpringApplicationBuilder): SpringApplicationBuilder { return builder.sources(MyApplication::class.java).bannerMode(Banner.Mode.OFF) } } } Applications can fall into more than one category: Servlet 3.0+ applications with no web.xml . Applications with a web.xml . Applications with a context hierarchy. Applications without a context hierarchy. All of these should be amenable to translation, but each might require slightly different techniques. Servlet 3.0+ applications might translate pretty easily if they already use the Spring Servlet 3.0+ initializer support classes. Normally, all the code from an existing WebApplicationInitializer can be moved into a SpringBootServletInitializer . If your existing application has more than one ApplicationContext (for example, if it uses AbstractDispatcherServletInitializer ) then you might be able to combine all your context sources into a single SpringApplication . The main complication you might encounter is if combining does not work and you need to maintain the context hierarchy. See the entry on building a hierarchy(../application.html#howto.application.context-hierarchy) for examples. An existing parent context that contains web-specific features usually needs to be broken up so that all the ServletContextAware components are in the child context. Applications that are not already Spring applications might be convertible to Spring Boot applications, and the previously mentioned guidance may help. However, you may yet encounter problems. In that case, we suggest asking questions on Stack Overflow with a tag of spring-boot(https://stackoverflow.com/questions/tagged/spring-boot) . Deploying a WAR to WebLogic: To deploy a Spring Boot application to WebLogic, you must ensure that your servlet initializer directly implements WebApplicationInitializer (even if you extend from a base class that already implements it). A typical initializer for WebLogic should resemble the following example: Java Kotlin import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.support.SpringBootServletInitializer; import org.springframework.web.WebApplicationInitializer; @SpringBootApplication public class MyApplication extends SpringBootServletInitializer implements WebApplicationInitializer { } import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.web.servlet.support.SpringBootServletInitializer import org.springframework.web.WebApplicationInitializer @SpringBootApplication class MyApplication : SpringBootServletInitializer(), WebApplicationInitializer If you use Logback, you also need to tell WebLogic to prefer the packaged version rather than the version that was pre-installed with the server. You can do so by adding a WEB-INF/weblogic.xml file with the following contents: <?xml version=""1.0"" encoding=""UTF-8""?> <wls:weblogic-web-app xmlns:wls=""http://xmlns.oracle.com/weblogic/weblogic-web-app"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/ejb-jar_3_0.xsd http://xmlns.oracle.com/weblogic/weblogic-web-app https://xmlns.oracle.com/weblogic/weblogic-web-app/1.4/weblogic-web-app.xsd""> <wls:container-descriptor> <wls:prefer-application-packages> <wls:package-name>org.slf4j</wls:package-name> </wls:prefer-application-packages> </wls:container-descriptor> </wls:weblogic-web-app>"
"https://docs.spring.io/spring-boot/how-to/deployment/cloud.html","Deploying to the Cloud: Spring Boot’s executable jars are ready-made for most popular cloud PaaS (Platform-as-a-Service) providers. These providers tend to require that you “bring your own container”. They manage application processes (not Java applications specifically), so they need an intermediary layer that adapts your application to the cloud’s notion of a running process. Two popular cloud providers, Heroku and Cloud Foundry, employ a “buildpack” approach. The buildpack wraps your deployed code in whatever is needed to start your application. It might be a JDK and a call to java , an embedded web server, or a full-fledged application server. A buildpack is pluggable, but ideally you should be able to get by with as few customizations to it as possible. This reduces the footprint of functionality that is not under your control. It minimizes divergence between development and production environments. Ideally, your application, like a Spring Boot executable jar, has everything that it needs to run packaged within it. In this section, we look at what it takes to get the application that we developed(../../tutorial/first-application/index.html) in the “Getting Started” section up and running in the Cloud. Cloud Foundry: Cloud Foundry provides default buildpacks that come into play if no other buildpack is specified. The Cloud Foundry Java buildpack(https://github.com/cloudfoundry/java-buildpack) has excellent support for Spring applications, including Spring Boot. You can deploy stand-alone executable jar applications as well as traditional .war packaged applications. Once you have built your application (by using, for example, mvn clean package ) and have installed the cf command line tool(https://docs.cloudfoundry.org/cf-cli/install-go-cli.html) , deploy your application by using the cf push command, substituting the path to your compiled .jar . Be sure to have logged in with your cf command line client(https://docs.cloudfoundry.org/cf-cli/getting-started.html#login) before pushing an application. The following line shows using the cf push command to deploy an application: $ cf push acloudyspringtime -p target/demo-0.0.1-SNAPSHOT.jar In the preceding example, we substitute acloudyspringtime for whatever value you give cf as the name of your application. See the cf push documentation(https://docs.cloudfoundry.org/cf-cli/getting-started.html#push) for more options. If there is a Cloud Foundry manifest.yml(https://docs.cloudfoundry.org/devguide/deploy-apps/manifest.html) file present in the same directory, it is considered. At this point, cf starts uploading your application, producing output similar to the following example: Uploading acloudyspringtime... OK Preparing to start acloudyspringtime... OK -----> Downloaded app package ( 8.9M ) -----> Java Buildpack Version: v3.12 (offline) | https://github.com/cloudfoundry/java-buildpack.git#6f25b7e -----> Downloading Open Jdk JRE Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.6s) -----> Downloading Open JDK Like Memory Calculator 2.0.2_RELEASE from https://java-buildpack.cloudfoundry.org/memory-calculator/trusty/x86_64/memory-calculator-2.0.2_RELEASE.tar.gz (found in cache) Memory Settings: -Xss349K -Xmx681574K -XX:MaxMetaspaceSize=104857K -Xms681574K -XX:MetaspaceSize=104857K -----> Downloading Container Certificate Trust Store 1.0.0_RELEASE from https://java-buildpack.cloudfoundry.org/container-certificate-trust-store/container-certificate-trust-store-1.0.0_RELEASE.jar (found in cache) Adding certificates to .java-buildpack/container_certificate_trust_store/truststore.jks (0.6s) -----> Downloading Spring Auto Reconfiguration 1.10.0_RELEASE from https://java-buildpack.cloudfoundry.org/auto-reconfiguration/auto-reconfiguration-1.10.0_RELEASE.jar (found in cache) Checking status of app 'acloudyspringtime'... 0 of 1 instances running (1 starting) ... 0 of 1 instances running (1 starting) ... 0 of 1 instances running (1 starting) ... 1 of 1 instances running (1 running) App started Congratulations! The application is now live! Once your application is live, you can verify the status of the deployed application by using the cf apps command, as shown in the following example: $ cf apps Getting applications in ... OK name requested state instances memory disk urls ... acloudyspringtime started 1/1 512M 1G acloudyspringtime.cfapps.io ... Once Cloud Foundry acknowledges that your application has been deployed, you should be able to find the application at the URI given. In the preceding example, you could find it at https://acloudyspringtime.cfapps.io/ . Binding to Services: By default, metadata about the running application as well as service connection information is exposed to the application as environment variables (for example: $VCAP_SERVICES ). This architecture decision is due to Cloud Foundry’s polyglot (any language and platform can be supported as a buildpack) nature. Process-scoped environment variables are language agnostic. Environment variables do not always make for the easiest API, so Spring Boot automatically extracts them and flattens the data into properties that can be accessed through Spring’s Environment abstraction, as shown in the following example: Java Kotlin import org.springframework.context.EnvironmentAware; import org.springframework.core.env.Environment; import org.springframework.stereotype.Component; @Component public class MyBean implements EnvironmentAware { private String instanceId; @Override public void setEnvironment(Environment environment) { this.instanceId = environment.getProperty(""vcap.application.instance_id""); } // ... } import org.springframework.context.EnvironmentAware import org.springframework.core.env.Environment import org.springframework.stereotype.Component @Component class MyBean : EnvironmentAware { private var instanceId: String? = null override fun setEnvironment(environment: Environment) { instanceId = environment.getProperty(""vcap.application.instance_id"") } // ... } All Cloud Foundry properties are prefixed with vcap . You can use vcap properties to access application information (such as the public URL of the application) and service information (such as database credentials). See the CloudFoundryVcapEnvironmentPostProcessor(../../api/java/org/springframework/boot/cloud/CloudFoundryVcapEnvironmentPostProcessor.html) API documentation for complete details. The Java CFEnv(https://github.com/pivotal-cf/java-cfenv/) project is a better fit for tasks such as configuring a DataSource. Kubernetes: Spring Boot auto-detects Kubernetes deployment environments by checking the environment for ""*_SERVICE_HOST"" and ""*_SERVICE_PORT"" variables. You can override this detection with the spring.main.cloud-platform configuration property. Spring Boot helps you to manage the state of your application(../../reference/features/spring-application.html#features.spring-application.application-availability) and export it with HTTP Kubernetes Probes using Actuator(../../reference/actuator/endpoints.html#actuator.endpoints.kubernetes-probes) . Kubernetes Container Lifecycle: When Kubernetes deletes an application instance, the shutdown process involves several subsystems concurrently: shutdown hooks, unregistering the service, removing the instance from the load-balancer…​ Because this shutdown processing happens in parallel (and due to the nature of distributed systems), there is a window during which traffic can be routed to a pod that has also begun its shutdown processing. You can configure a sleep execution in a preStop handler to avoid requests being routed to a pod that has already begun shutting down. This sleep should be long enough for new requests to stop being routed to the pod and its duration will vary from deployment to deployment. The preStop handler can be configured by using the PodSpec in the pod’s configuration file as follows: spec: containers: - name: ""example-container"" image: ""example-image"" lifecycle: preStop: exec: command: [""sh"", ""-c"", ""sleep 10""] Once the pre-stop hook has completed, SIGTERM will be sent to the container and graceful shutdown(../../reference/web/graceful-shutdown.html) will begin, allowing any remaining in-flight requests to complete. When Kubernetes sends a SIGTERM signal to the pod, it waits for a specified time called the termination grace period (the default for which is 30 seconds). If the containers are still running after the grace period, they are sent the SIGKILL signal and forcibly removed. If the pod takes longer than 30 seconds to shut down, which could be because you have increased spring.lifecycle.timeout-per-shutdown-phase , make sure to increase the termination grace period by setting the terminationGracePeriodSeconds option in the Pod YAML. Heroku: Heroku is another popular PaaS platform. To customize Heroku builds, you provide a Procfile , which provides the incantation required to deploy an application. Heroku assigns a port for the Java application to use and then ensures that routing to the external URI works. You must configure your application to listen on the correct port. The following example shows the Procfile for our starter REST application: web: java -Dserver.port=$PORT -jar target/demo-0.0.1-SNAPSHOT.jar Spring Boot makes -D arguments available as properties accessible from a Spring Environment instance. The server.port configuration property is fed to the embedded Tomcat, Jetty, or Undertow instance, which then uses the port when it starts up. The $PORT environment variable is assigned to us by the Heroku PaaS. This should be everything you need. The most common deployment workflow for Heroku deployments is to git push the code to production, as shown in the following example: $ git push heroku main Which will result in the following: Initializing repository, done . Counting objects: 95, done . Delta compression using up to 8 threads. Compressing objects: 100% (78/78), done . Writing objects: 100% (95/95), 8.66 MiB | 606.00 KiB/s, done . Total 95 (delta 31), reused 0 (delta 0) -----> Java app detected -----> Installing OpenJDK... done -----> Installing Maven... done -----> Installing settings.xml... done -----> Executing: mvn -B -DskipTests=true clean install [INFO] Scanning for projects... Downloading: https://repo.spring.io/... Downloaded: https://repo.spring.io/... (818 B at 1.8 KB/sec) .... Downloaded: https://s3pository.heroku.com/jvm/... (152 KB at 595.3 KB/sec) [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/target/... [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/pom.xml ... [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 59.358s [INFO] Finished at: Fri Mar 07 07:28:25 UTC 2014 [INFO] Final Memory: 20M/493M [INFO] ------------------------------------------------------------------------ -----> Discovering process types Procfile declares types -> web -----> Compressing... done , 70.4MB -----> Launching... done , v6 https://agile-sierra-1405.herokuapp.com/ deployed to Heroku To [email protected](/cdn-cgi/l/email-protection) :agile-sierra-1405.git * [new branch] main -> main Your application should now be up and running on Heroku. For more details, see Deploying Spring Boot Applications to Heroku(https://devcenter.heroku.com/articles/deploying-spring-boot-apps-to-heroku) . OpenShift: OpenShift(https://www.openshift.com/) has many resources describing how to deploy Spring Boot applications, including: Using the S2I builder(https://blog.openshift.com/using-openshift-enterprise-grade-spring-boot-deployments/) Architecture guide(https://access.redhat.com/documentation/en-us/reference_architectures/2017/html-single/spring_boot_microservices_on_red_hat_openshift_container_platform_3/) Running as a traditional web application on Wildfly(https://blog.openshift.com/using-spring-boot-on-openshift/) OpenShift Commons Briefing(https://blog.openshift.com/openshift-commons-briefing-96-cloud-native-applications-spring-rhoar/) Amazon Web Services (AWS): Amazon Web Services offers multiple ways to install Spring Boot-based applications, either as traditional web applications (war) or as executable jar files with an embedded web server. The options include: AWS Elastic Beanstalk AWS Code Deploy AWS OPS Works AWS Cloud Formation AWS Container Registry Each has different features and pricing models. In this document, we describe to approach using AWS Elastic Beanstalk. AWS Elastic Beanstalk: As described in the official Elastic Beanstalk Java guide(https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Java.html) , there are two main options to deploy a Java application. You can either use the “Tomcat Platform” or the “Java SE platform”. Using the Tomcat Platform: This option applies to Spring Boot projects that produce a war file. No special configuration is required. You need only follow the official guide. Using the Java SE Platform: This option applies to Spring Boot projects that produce a jar file and run an embedded web container. Elastic Beanstalk environments run an nginx instance on port 80 to proxy the actual application, running on port 5000. To configure it, add the following line to your application.properties file: Properties YAML server.port=5000 server: port: 5000 Upload binaries instead of sources By default, Elastic Beanstalk uploads sources and compiles them in AWS. However, it is best to upload the binaries instead. To do so, add lines similar to the following to your .elasticbeanstalk/config.yml file: deploy: artifact: target/demo-0.0.1-SNAPSHOT.jar Reduce costs by setting the environment type By default an Elastic Beanstalk environment is load balanced. The load balancer has a significant cost. To avoid that cost, set the environment type to “Single instance”, as described in the Amazon documentation(https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity) . You can also create single instance environments by using the CLI and the following command: eb create -s Summary: This is one of the easiest ways to get to AWS, but there are more things to cover, such as how to integrate Elastic Beanstalk into any CI / CD tool, use the Elastic Beanstalk Maven plugin instead of the CLI, and others. There is a blog post(https://exampledriven.wordpress.com/2017/01/09/spring-boot-aws-elastic-beanstalk-example/) covering these topics more in detail. CloudCaptain and Amazon Web Services: CloudCaptain(https://cloudcaptain.sh/) works by turning your Spring Boot executable jar or war into a minimal VM image that can be deployed unchanged either on VirtualBox or on AWS. CloudCaptain comes with deep integration for Spring Boot and uses the information from your Spring Boot configuration file to automatically configure ports and health check URLs. CloudCaptain leverages this information both for the images it produces as well as for all the resources it provisions (instances, security groups, elastic load balancers, and so on). Once you have created a CloudCaptain account(https://console.cloudcaptain.sh) , connected it to your AWS account, installed the latest version of the CloudCaptain Client, and ensured that the application has been built by Maven or Gradle (by using, for example, mvn clean package ), you can deploy your Spring Boot application to AWS with a command similar to the following: $ boxfuse run myapp-1.0.jar -env=prod See the boxfuse run documentation(https://cloudcaptain.sh/docs/commandline/run.html) for more options. If there is a boxfuse.conf(https://cloudcaptain.sh/docs/commandline/#configuration) file present in the current directory, it is considered. By default, CloudCaptain activates a Spring profile named boxfuse on startup. If your executable jar or war contains an application-boxfuse.properties(https://cloudcaptain.sh/docs/payloads/springboot.html#configuration) file, CloudCaptain bases its configuration on the properties it contains. At this point, CloudCaptain creates an image for your application, uploads it, and configures and starts the necessary resources on AWS, resulting in output similar to the following example: Fusing Image for myapp-1.0.jar ... Image fused in 00:06.838s (53937 K) -> axelfontaine/myapp:1.0 Creating axelfontaine/myapp ... Pushing axelfontaine/myapp:1.0 ... Verifying axelfontaine/myapp:1.0 ... Creating Elastic IP ... Mapping myapp-axelfontaine.boxfuse.io to 52.28.233.167 ... Waiting for AWS to create an AMI for axelfontaine/myapp:1.0 in eu-central-1 (this may take up to 50 seconds) ... AMI created in 00:23.557s -> ami-d23f38cf Creating security group boxfuse-sg_axelfontaine/myapp:1.0 ... Launching t2.micro instance of axelfontaine/myapp:1.0 (ami-d23f38cf) in eu-central-1 ... Instance launched in 00:30.306s -> i-92ef9f53 Waiting for AWS to boot Instance i-92ef9f53 and Payload to start at https://52.28.235.61/ ... Payload started in 00:29.266s -> https://52.28.235.61/ Remapping Elastic IP 52.28.233.167 to i-92ef9f53 ... Waiting 15s for AWS to complete Elastic IP Zero Downtime transition ... Deployment completed successfully. axelfontaine/myapp:1.0 is up and running at https://myapp-axelfontaine.boxfuse.io/ Your application should now be up and running on AWS. See the blog post on deploying Spring Boot apps on EC2(https://cloudcaptain.sh/blog/spring-boot-ec2.html) as well as the documentation for the CloudCaptain Spring Boot integration(https://cloudcaptain.sh/docs/payloads/springboot.html) to get started with a Maven build to run the app. Azure: This Getting Started guide(https://spring.io/guides/gs/spring-boot-for-azure/) walks you through deploying your Spring Boot application to either Azure Spring Cloud(https://azure.microsoft.com/en-us/services/spring-cloud/) or Azure App Service(https://docs.microsoft.com/en-us/azure/app-service/overview) . Google Cloud: Google Cloud has several options that can be used to launch Spring Boot applications. The easiest to get started with is probably App Engine, but you could also find ways to run Spring Boot in a container with Container Engine or on a virtual machine with Compute Engine. To deploy your first app to App Engine standard environment, follow this tutorial(https://codelabs.developers.google.com/codelabs/cloud-app-engine-springboot#0) . Alternatively, App Engine Flex requires you to create an app.yaml file to describe the resources your app requires. Normally, you put this file in src/main/appengine , and it should resemble the following file: service: ""default"" runtime: ""java17"" env: ""flex"" handlers: - url: ""/.*"" script: ""this field is required, but ignored"" manual_scaling: instances: 1 health_check: enable_health_check: false env_variables: ENCRYPT_KEY: ""your_encryption_key_here"" You can deploy the app (for example, with a Maven plugin) by adding the project ID to the build configuration, as shown in the following example: <plugin> <groupId>com.google.cloud.tools</groupId> <artifactId>appengine-maven-plugin</artifactId> <version>2.4.4</version> <configuration> <project>myproject</project> </configuration> </plugin> Then deploy with mvn appengine:deploy (you need to authenticate first, otherwise the build fails)."
"https://docs.spring.io/spring-boot/how-to/deployment/installing.html","Installing Spring Boot Applications: In addition to running Spring Boot applications by using java -jar directly, it is also possible to run them as systemd , init.d or Windows services. Installation as a systemd Service: systemd is the successor of the System V init system and is now being used by many modern Linux distributions. Spring Boot applications can be launched by using systemd ‘service’ scripts. Assuming that you have a Spring Boot application packaged as an uber jar in /var/myapp , to install it as a systemd service, create a script named myapp.service and place it in /etc/systemd/system directory. The following script offers an example: [Unit] Description=myapp After=syslog.target network.target [Service] User=myapp Group=myapp Environment=""JAVA_HOME=/path/to/java/home"" ExecStart=${JAVA_HOME}/bin/java -jar /var/myapp/myapp.jar ExecStop=/bin/kill -15 $MAINPID SuccessExitStatus=143 [Install] WantedBy=multi-user.target Remember to change the Description , User , Group , Environment and ExecStart fields for your application. The ExecStart field does not declare the script action command, which means that the run command is used by default. The user that runs the application, the PID file, and the console log file are managed by systemd itself and therefore must be configured by using appropriate fields in the ‘service’ script. Consult the service unit configuration man page(https://www.freedesktop.org/software/systemd/man/systemd.service.html) for more details. To flag the application to start automatically on system boot, use the following command: $ systemctl enable myapp.service Run man systemctl for more details. Installation as an init.d Service (System V): To use your application as init.d service, configure its build to produce a fully executable jar(#) . Fully executable jars work by embedding an extra script at the front of the file. Currently, some tools do not accept this format, so you may not always be able to use this technique. For example, jar -xf may silently fail to extract a jar or war that has been made fully executable. It is recommended that you make your jar or war fully executable only if you intend to execute it directly, rather than running it with java -jar or deploying it to a servlet container. A zip64-format jar file cannot be made fully executable. Attempting to do so will result in a jar file that is reported as corrupt when executed directly or with java -jar . A standard-format jar file that contains one or more zip64-format nested jars can be fully executable. To create a ‘fully executable’ jar with Maven, use the following plugin configuration: <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <executable>true</executable> </configuration> </plugin> The following example shows the equivalent Gradle configuration: tasks.named('bootJar') { launchScript() } It can then be symlinked to init.d to support the standard start , stop , restart , and status commands. The default launch script that is added to a fully executable jar supports most Linux distributions and is tested on CentOS and Ubuntu. Other platforms, such as OS X and FreeBSD, require the use of a custom script. The default scripts supports the following features: Starts the services as the user that owns the jar file Tracks the application’s PID by using /var/run/<appname>/<appname>.pid Writes console logs to /var/log/<appname>.log Assuming that you have a Spring Boot application installed in /var/myapp , to install a Spring Boot application as an init.d service, create a symlink, as follows: $ sudo ln -s /var/myapp/myapp.jar /etc/init.d/myapp Once installed, you can start and stop the service in the usual way. For example, on a Debian-based system, you could start it with the following command: $ service myapp start If your application fails to start, check the log file written to /var/log/<appname>.log for errors. You can also flag the application to start automatically by using your standard operating system tools. For example, on Debian, you could use the following command: $ update-rc.d myapp defaults <priority> Securing an init.d Service: The following is a set of guidelines on how to secure a Spring Boot application that runs as an init.d service. It is not intended to be an exhaustive list of everything that should be done to harden an application and the environment in which it runs. When executed as root, as is the case when root is being used to start an init.d service, the default executable script runs the application as the user specified in the RUN_AS_USER environment variable. When the environment variable is not set, the user who owns the jar file is used instead. You should never run a Spring Boot application as root , so RUN_AS_USER should never be root and your application’s jar file should never be owned by root. Instead, create a specific user to run your application and set the RUN_AS_USER environment variable or use chown to make it the owner of the jar file, as shown in the following example: $ chown bootapp:bootapp your-app.jar In this case, the default executable script runs the application as the bootapp user. To reduce the chances of the application’s user account being compromised, you should consider preventing it from using a login shell. For example, you can set the account’s shell to /usr/sbin/nologin . You should also take steps to prevent the modification of your application’s jar file. Firstly, configure its permissions so that it cannot be written and can only be read or executed by its owner, as shown in the following example: $ chmod 500 your-app.jar Second, you should also take steps to limit the damage if your application or the account that is running it is compromised. If an attacker does gain access, they could make the jar file writable and change its contents. One way to protect against this is to make it immutable by using chattr , as shown in the following example: $ sudo chattr +i your-app.jar This will prevent any user, including root, from modifying the jar. If root is used to control the application’s service and you use a .conf file(#howto.deployment.installing.init-d.script-customization.when-running.conf-file) to customize its startup, the .conf file is read and evaluated by the root user. It should be secured accordingly. Use chmod so that the file can only be read by the owner and use chown to make root the owner, as shown in the following example: $ chmod 400 your-app.conf $ sudo chown root:root your-app.conf Customizing the Startup Script: The default embedded startup script written by the Maven or Gradle plugin can be customized in a number of ways. For most people, using the default script along with a few customizations is usually enough. If you find you cannot customize something that you need to, use the embeddedLaunchScript option to write your own file entirely. Customizing the Start Script When It Is Written: It often makes sense to customize elements of the start script as it is written into the jar file. For example, init.d scripts can provide a “description”. Since you know the description up front (and it need not change), you may as well provide it when the jar is generated. To customize written elements, use the embeddedLaunchScriptProperties option of the Spring Boot Maven plugin or the properties property of the Spring Boot Gradle plugin’s launchScript(../../gradle-plugin/packaging.html#packaging-executable.configuring.launch-script) . The following property substitutions are supported with the default script: Name Description Gradle default Maven default mode The script mode. auto auto initInfoProvides The Provides section of “INIT INFO” ${task.baseName} ${project.artifactId} initInfoRequiredStart Required-Start section of “INIT INFO”. $remote_fs $syslog $network $remote_fs $syslog $network initInfoRequiredStop Required-Stop section of “INIT INFO”. $remote_fs $syslog $network $remote_fs $syslog $network initInfoDefaultStart Default-Start section of “INIT INFO”. 2 3 4 5 2 3 4 5 initInfoDefaultStop Default-Stop section of “INIT INFO”. 0 1 6 0 1 6 initInfoShortDescription Short-Description section of “INIT INFO”. Single-line version of ${project.description} (falling back to ${task.baseName} ) ${project.name} initInfoDescription Description section of “INIT INFO”. ${project.description} (falling back to ${task.baseName} ) ${project.description} (falling back to ${project.name} ) initInfoChkconfig chkconfig section of “INIT INFO” 2345 99 01 2345 99 01 confFolder The default value for CONF_FOLDER Folder containing the jar Folder containing the jar inlinedConfScript Reference to a file script that should be inlined in the default launch script. This can be used to set environmental variables such as JAVA_OPTS before any external config files are loaded logFolder Default value for LOG_FOLDER . Only valid for an init.d service logFilename Default value for LOG_FILENAME . Only valid for an init.d service pidFolder Default value for PID_FOLDER . Only valid for an init.d service pidFilename Default value for the name of the PID file in PID_FOLDER . Only valid for an init.d service useStartStopDaemon Whether the start-stop-daemon command, when it is available, should be used to control the process true true stopWaitTime Default value for STOP_WAIT_TIME in seconds. Only valid for an init.d service 60 60 Customizing a Script When It Runs: For items of the script that need to be customized after the jar has been written, you can use environment variables or a config file(#howto.deployment.installing.init-d.script-customization.when-running.conf-file) . The following environment properties are supported with the default script: Variable Description MODE The “mode” of operation. The default depends on the way the jar was built but is usually auto (meaning it tries to guess if it is an init script by checking if it is a symlink in a directory called init.d ). You can explicitly set it to service so that the stop|start|status|restart commands work or to run if you want to run the script in the foreground. RUN_AS_USER The user that will be used to run the application. When not set, the user that owns the jar file will be used. USE_START_STOP_DAEMON Whether the start-stop-daemon command, when it is available, should be used to control the process. Defaults to true . PID_FOLDER The root name of the pid folder ( /var/run by default). LOG_FOLDER The name of the folder in which to put log files ( /var/log by default). CONF_FOLDER The name of the folder from which to read .conf files (same folder as jar-file by default). LOG_FILENAME The name of the log file in the LOG_FOLDER ( <appname>.log by default). APP_NAME The name of the app. If the jar is run from a symlink, the script guesses the app name. If it is not a symlink or you want to explicitly set the app name, this can be useful. RUN_ARGS The arguments to pass to the program (the Spring Boot app). JAVA_HOME The location of the java executable is discovered by using the PATH by default, but you can set it explicitly if there is an executable file at $JAVA_HOME/bin/java . JAVA_OPTS Options that are passed to the JVM when it is launched. JARFILE The explicit location of the jar file, in case the script is being used to launch a jar that it is not actually embedded. DEBUG If not empty, sets the -x flag on the shell process, allowing you to see the logic in the script. STOP_WAIT_TIME The time in seconds to wait when stopping the application before forcing a shutdown ( 60 by default). The PID_FOLDER , LOG_FOLDER , and LOG_FILENAME variables are only valid for an init.d service. For systemd , the equivalent customizations are made by using the ‘service’ script. See the service unit configuration man page(https://www.freedesktop.org/software/systemd/man/systemd.service.html) for more details. Using a Conf File: With the exception of JARFILE and APP_NAME , the settings listed in the preceding section can be configured by using a .conf file. The file is expected to be next to the jar file and have the same name but suffixed with .conf rather than .jar . For example, a jar named /var/myapp/myapp.jar uses the configuration file named /var/myapp/myapp.conf , as shown in the following example: myapp.conf JAVA_OPTS=-Xmx1024M LOG_FOLDER=/custom/log/folder If you do not like having the config file next to the jar file, you can set a CONF_FOLDER environment variable to customize the location of the config file. To learn about securing this file appropriately, see the guidelines for securing an init.d service(#howto.deployment.installing.init-d.securing) . Microsoft Windows Services: A Spring Boot application can be started as a Windows service by using winsw(https://github.com/kohsuke/winsw) . A ( separately maintained sample(https://github.com/snicoll/spring-boot-daemon) ) describes step-by-step how you can create a Windows service for your Spring Boot application."
"https://docs.spring.io/spring-boot/how-to/docker-compose.html","Docker Compose: This section includes topics relating to the Docker Compose support in Spring Boot. Customizing the JDBC URL: When using JdbcConnectionDetails with Docker Compose, the parameters of the JDBC URL can be customized by applying the org.springframework.boot.jdbc.parameters label to the service. For example: services: postgres: image: 'postgres:15.3' environment: - 'POSTGRES_USER=myuser' - 'POSTGRES_PASSWORD=secret' - 'POSTGRES_DB=mydb' ports: - '5432:5432' labels: org.springframework.boot.jdbc.parameters: 'ssl=true&sslmode=require' With this Docker Compose file in place, the JDBC URL used is jdbc:postgresql://127.0.0.1:5432/mydb?ssl=true&sslmode=require . Sharing Services Between Multiple Applications: If you want to share services between multiple applications, create the compose.yaml file in one of the applications and then use the configuration property spring.docker.compose.file in the other applications to reference the compose.yaml file. You should also set spring.docker.compose.lifecycle-management to start-only , as it defaults to start-and-stop and stopping one application would shut down the shared services for the other still running applications as well. Setting it to start-only won’t stop the shared services on application stop, but a caveat is that if you shut down all applications, the services remain running. You can stop the services manually by running docker compose stop on the command line in the directory which contains the compose.yaml file."
"https://docs.spring.io/spring-boot/build-tool-plugin/index.html","Build Tool Plugins: Spring Boot provides build tool plugins for Maven and Gradle. The plugins offer a variety of features, including the packaging of executable jars. This section provides more details on both plugins as well as some help should you need to extend an unsupported build system. If you are just getting started, you might want to read Build Systems(../reference/using/build-systems.html) from the Developing with Spring Boot(../reference/using/index.html) section first."
"https://docs.spring.io/spring-boot/maven-plugin/index.html","Maven Plugin: The Spring Boot Maven Plugin provides Spring Boot support in Apache Maven(https://maven.org) . It allows you to package executable jar or war archives, run Spring Boot applications, generate build information and start your Spring Boot application prior to running integration tests. To use it, you must use Maven 3.6.3 or later. In addition to this user guide, API documentation(api/java/index.html) is also available."
"https://docs.spring.io/spring-boot/maven-plugin/getting-started.html","Getting Started: To use the Spring Boot Maven Plugin, include the appropriate XML in the plugins section of your pom.xml , as shown in the following example: <project> <modelVersion>4.0.0</modelVersion> <artifactId>getting-started</artifactId> <!-- ... --> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> </project> If you use a milestone or snapshot release, you also need to add the appropriate pluginRepository elements, as shown in the following listing: <pluginRepositories> <pluginRepository> <id>spring-snapshots</id> <url>https://repo.spring.io/snapshot</url> </pluginRepository> <pluginRepository> <id>spring-milestones</id> <url>https://repo.spring.io/milestone</url> </pluginRepository> </pluginRepositories>"
"https://docs.spring.io/spring-boot/maven-plugin/using.html","Using the Plugin: Maven users can inherit from the spring-boot-starter-parent project to obtain sensible defaults. The parent project provides the following features: Java 17 as the default compiler level. UTF-8 source encoding. Compilation with -parameters . A dependency management section, inherited from the spring-boot-dependencies POM, that manages the versions of common dependencies. This dependency management lets you omit <version> tags for those dependencies when used in your own POM. An execution of the repackage goal(packaging.html#packaging.repackage-goal) with a repackage execution id. A native profile that configures the build to be able to generate a Native image. Sensible resource filtering(https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html) . Sensible plugin configuration ( Git commit ID(https://github.com/ktoso/maven-git-commit-id-plugin) , and shade(https://maven.apache.org/plugins/maven-shade-plugin/) ). Sensible resource filtering for application.properties and application.yml including profile-specific files (for example, application-dev.properties and application-dev.yml ) Since the application.properties and application.yml files accept Spring style placeholders ( ${…​} ), the Maven filtering is changed to use @..@ placeholders. (You can override that by setting a Maven property called resource.delimiter .) The spring-boot-starter-parent sets the maven.compiler.release property, which restricts the --add-exports , --add-reads , and --patch-module options if they modify system modules(https://openjdk.org/jeps/247) . In case you need to use those options, unset maven.compiler.release : <maven.compiler.release></maven.compiler.release> and then configure the source and the target options instead: <maven.compiler.source>${java.version}</maven.compiler.source> <maven.compiler.target>${java.version}</maven.compiler.target> Inheriting the Starter Parent POM: To configure your project to inherit from the spring-boot-starter-parent , set the parent as follows: <!-- Inherit defaults from Spring Boot --> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>3.3.4</version> </parent> You should need to specify only the Spring Boot version number on this dependency. If you import additional starters, you can safely omit the version number. With that setup, you can also override individual dependencies by overriding a property in your own project. For instance, to use a different version of the SLF4J library and the Spring Data release train, you would add the following to your pom.xml : <properties> <slf4j.version>1.7.30</slf4j.version> <spring-data-releasetrain.version>Moore-SR6</spring-data-releasetrain.version> </properties> Browse the Dependency Versions Properties(../appendix/dependency-versions/properties.html) section in the Spring Boot reference for a complete list of dependency version properties. Using Spring Boot without the Parent POM: There may be reasons for you not to inherit from the spring-boot-starter-parent POM. You may have your own corporate standard parent that you need to use or you may prefer to explicitly declare all your Maven configuration. If you do not want to use the spring-boot-starter-parent , you can still keep the benefit of the dependency management (but not the plugin management) by using an import scoped dependency, as follows: <dependencyManagement> <dependencies> <dependency> <!-- Import dependency management from Spring Boot --> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-dependencies</artifactId> <version>3.3.4</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> The preceding sample setup does not let you override individual dependencies by using properties, as explained above. To achieve the same result, you need to add entries in the dependencyManagement section of your project before the spring-boot-dependencies entry. For instance, to use a different version of the SLF4J library and the Spring Data release train, you could add the following elements to your pom.xml : <dependencyManagement> <dependencies> <!-- Override SLF4J provided by Spring Boot --> <dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-api</artifactId> <version>1.7.30</version> </dependency> <!-- Override Spring Data release train provided by Spring Boot --> <dependency> <groupId>org.springframework.data</groupId> <artifactId>spring-data-releasetrain</artifactId> <version>2020.0.0-SR1</version> <type>pom</type> <scope>import</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-dependencies</artifactId> <version>3.3.4</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> Overriding Settings on the Command Line: The plugin offers a number of user properties, starting with spring-boot , to let you customize the configuration from the command line. For instance, you could tune the profiles to enable when running the application as follows: $ mvn spring-boot:run -Dspring-boot.run.profiles=dev,local If you want to both have a default while allowing it to be overridden on the command line, you should use a combination of a user-provided project property and MOJO configuration. <project> <properties> <app.profiles>local,dev</app.profiles> </properties> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <profiles>${app.profiles}</profiles> </configuration> </plugin> </plugins> </build> </project> The above makes sure that local and dev are enabled by default. Now a dedicated property has been exposed, this can be overridden on the command line as well: $ mvn spring-boot:run -Dapp.profiles=test"
"https://docs.spring.io/spring-boot/maven-plugin/goals.html","Goals: The Spring Boot Plugin has the following goals: Goal Description spring-boot:build-image(build-image.html#build-image.build-image-goal) Package an application into an OCI image using a buildpack, forking the lifecycle to make sure that package ran. This goal is suitable for command-line invocation. If you need to configure a goal execution in your build, use build-image-no-fork instead. spring-boot:build-image-no-fork(build-image.html#build-image.build-image-no-fork-goal) Package an application into an OCI image using a buildpack, but without forking the lifecycle. This goal should be used when configuring a goal execution in your build. To invoke the goal on the command-line, use build-image instead. spring-boot:build-info(build-info.html#build-info.build-info-goal) Generate a build-info.properties file based on the content of the current MavenProject . spring-boot:help(help.html#help.help-goal) Display help information on spring-boot-maven-plugin. Call mvn spring-boot:help -Ddetail=true -Dgoal=<goal-name> to display parameter details. spring-boot:process-aot(aot.html#aot.process-aot-goal) Invoke the AOT engine on the application. spring-boot:process-test-aot(aot.html#aot.process-test-aot-goal) Invoke the AOT engine on tests. spring-boot:repackage(packaging.html#packaging.repackage-goal) Repackage existing JAR and WAR archives so that they can be executed from the command line using java -jar . With layout=NONE can also be used simply to package a JAR with nested dependencies (and no main class, so not executable). spring-boot:run(run.html#run.run-goal) Run an application in place. spring-boot:start(integration-tests.html#integration-tests.start-goal) Start a spring application. Contrary to the run goal, this does not block and allows other goals to operate on the application. This goal is typically used in integration test scenario where the application is started before a test suite and stopped after. spring-boot:stop(integration-tests.html#integration-tests.stop-goal) Stop an application that has been started by the ""start"" goal. Typically invoked once a test suite has completed. spring-boot:test-run(run.html#run.test-run-goal) Run an application in place using the test runtime classpath. The main class that will be used to launch the application is determined as follows: The configured main class, if any. Then the main class found in the test classes directory, if any. Then the main class found in the classes directory, if any."
"https://docs.spring.io/spring-boot/maven-plugin/packaging.html","Packaging Executable Archives: The plugin can create executable archives (jar files and war files) that contain all of an application’s dependencies and can then be run with java -jar . Packaging an executable archive is performed by the repackage goal, as shown in the following example: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <goals> <goal>repackage</goal> </goals> </execution> </executions> </plugin> </plugins> </build> The repackage goal is not meant to be used alone on the command-line as it operates on the source jar (or war ) produced by the package phase. To use this goal on the command-line, you must include the package phase: mvn package spring-boot:repackage . If you are using spring-boot-starter-parent , such execution is already pre-configured with a repackage execution ID so that only the plugin definition should be added. The example above repackages a jar or war archive that is built during the package phase of the Maven lifecycle, including any provided dependencies that are defined in the project. If some of these dependencies need to be excluded, you can use one of the exclude options; see the dependency exclusion(#packaging.examples.exclude-dependency) for more details. The original (that is non-executable) artifact is renamed to .original by default but it is also possible to keep the original artifact using a custom classifier. The outputFileNameMapping feature of the maven-war-plugin is currently not supported. The spring-boot-devtools and spring-boot-docker-compose modules are automatically excluded by default (you can control this using the excludeDevtools and excludeDockerCompose properties). In order to make that work with war packaging, the spring-boot-devtools and spring-boot-docker-compose dependencies must be set as optional or with the provided scope. The plugin rewrites your manifest, and in particular it manages the Main-Class and Start-Class entries. If the defaults don’t work you have to configure the values in the Spring Boot plugin, not in the jar plugin. The Main-Class in the manifest is controlled by the layout property of the Spring Boot plugin, as shown in the following example: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <mainClass>${start.class}</mainClass> <layout>ZIP</layout> </configuration> <executions> <execution> <goals> <goal>repackage</goal> </goals> </execution> </executions> </plugin> </plugins> </build> The layout property defaults to a value determined by the archive type ( jar or war ). The following layouts are available: JAR : regular executable JAR layout. WAR : executable WAR layout. provided dependencies are placed in WEB-INF/lib-provided to avoid any clash when the war is deployed in a servlet container. ZIP (alias to DIR ): similar to the JAR layout using PropertiesLauncher . NONE : Bundle all dependencies and project resources. Does not bundle a bootstrap loader. Layered Jar or War: A repackaged jar contains the application’s classes and dependencies in BOOT-INF/classes and BOOT-INF/lib respectively. Similarly, an executable war contains the application’s classes in WEB-INF/classes and dependencies in WEB-INF/lib and WEB-INF/lib-provided . For cases where a docker image needs to be built from the contents of a jar or war, it’s useful to be able to separate these directories further so that they can be written into distinct layers. Layered archives use the same layout as a regular repackaged jar or war, but include an additional meta-data file that describes each layer. By default, the following layers are defined: dependencies for any dependency whose version does not contain SNAPSHOT . spring-boot-loader for the loader classes. snapshot-dependencies for any dependency whose version contains SNAPSHOT . application for local module dependencies, application classes, and resources. Module dependencies are identified by looking at all of the modules that are part of the current build. If a module dependency can only be resolved because it has been installed into Maven’s local cache and it is not part of the current build, it will be identified as regular dependency. The layers order is important as it determines how likely previous layers can be cached when part of the application changes. The default order is dependencies , spring-boot-loader , snapshot-dependencies , application . Content that is least likely to change should be added first, followed by layers that are more likely to change. The repackaged archive includes the layers.idx file by default. To disable this feature, you can do so in the following manner: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <layers> <enabled>false</enabled> </layers> </configuration> </plugin> </plugins> </build> </project> Custom Layers Configuration: Depending on your application, you may want to tune how layers are created and add new ones. This can be done using a separate configuration file that should be registered as shown below: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <layers> <enabled>true</enabled> <configuration>${project.basedir}/src/layers.xml</configuration> </layers> </configuration> </plugin> </plugins> </build> </project> The configuration file describes how an archive can be separated into layers, and the order of those layers. The following example shows how the default ordering described above can be defined explicitly: <layers xmlns=""http://www.springframework.org/schema/boot/layers"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.springframework.org/schema/boot/layers layers-xsd: https://www.springframework.org/schema/boot/layers/layers-3.3.xsd""> <application> <into layer=""spring-boot-loader""> <include>org/springframework/boot/loader/**</include> </into> <into layer=""application"" /> </application> <dependencies> <into layer=""application""> <includeModuleDependencies /> </into> <into layer=""snapshot-dependencies""> <include>*:*:*SNAPSHOT</include> </into> <into layer=""dependencies"" /> </dependencies> <layerOrder> <layer>dependencies</layer> <layer>spring-boot-loader</layer> <layer>snapshot-dependencies</layer> <layer>application</layer> </layerOrder> </layers> The layers XML format is defined in three sections: The <application> block defines how the application classes and resources should be layered. The <dependencies> block defines how dependencies should be layered. The <layerOrder> block defines the order that the layers should be written. Nested <into> blocks are used within <application> and <dependencies> sections to claim content for a layer. The blocks are evaluated in the order that they are defined, from top to bottom. Any content not claimed by an earlier block remains available for subsequent blocks to consider. The <into> block claims content using nested <include> and <exclude> elements. The <application> section uses Ant-style path matching for include/exclude expressions. The <dependencies> section uses group:artifact[:version] patterns. It also provides <includeModuleDependencies /> and <excludeModuleDependencies /> elements that can be used to include or exclude local module dependencies. If no <include> is defined, then all content (not claimed by an earlier block) is considered. If no <exclude> is defined, then no exclusions are applied. Looking at the <dependencies> example above, we can see that the first <into> will claim all module dependencies for the application.layer . The next <into> will claim all SNAPSHOT dependencies for the snapshot-dependencies layer. The final <into> will claim anything left (in this case, any dependency that is not a SNAPSHOT) for the dependencies layer. The <application> block has similar rules. First claiming org/springframework/boot/loader/** content for the spring-boot-loader layer. Then claiming any remaining classes and resources for the application layer. The order that <into> blocks are defined is often different from the order that the layers are written. For this reason the <layerOrder> element must always be included and must cover all layers referenced by the <into> blocks. spring-boot:repackage: org.springframework.boot:spring-boot-maven-plugin:3.3.4 Repackage existing JAR and WAR archives so that they can be executed from the command line using java -jar . With layout=NONE can also be used simply to package a JAR with nested dependencies (and no main class, so not executable). Required parameters: Name Type Default outputDirectory(#packaging.repackage-goal.parameter-details.output-directory) File ${project.build.directory} Optional parameters: Name Type Default attach(#packaging.repackage-goal.parameter-details.attach) boolean true classifier(#packaging.repackage-goal.parameter-details.classifier) String embeddedLaunchScript(#packaging.repackage-goal.parameter-details.embedded-launch-script) File embeddedLaunchScriptProperties(#packaging.repackage-goal.parameter-details.embedded-launch-script-properties) Properties excludeDevtools(#packaging.repackage-goal.parameter-details.exclude-devtools) boolean true excludeDockerCompose(#packaging.repackage-goal.parameter-details.exclude-docker-compose) boolean true excludeGroupIds(#packaging.repackage-goal.parameter-details.exclude-group-ids) String excludes(#packaging.repackage-goal.parameter-details.excludes) List executable(#packaging.repackage-goal.parameter-details.executable) boolean false includeSystemScope(#packaging.repackage-goal.parameter-details.include-system-scope) boolean false includeTools(#packaging.repackage-goal.parameter-details.include-tools) boolean true includes(#packaging.repackage-goal.parameter-details.includes) List layers(#packaging.repackage-goal.parameter-details.layers) Layers(api/java/org/springframework/boot/maven/Layers.html) layout(#packaging.repackage-goal.parameter-details.layout) LayoutType(api/java/org/springframework/boot/maven/AbstractPackagerMojo.LayoutType.html) layoutFactory(#packaging.repackage-goal.parameter-details.layout-factory) LayoutFactory(../api/java/org/springframework/boot/loader/tools/LayoutFactory.html) loaderImplementation(#packaging.repackage-goal.parameter-details.loader-implementation) LoaderImplementation(../api/java/org/springframework/boot/loader/tools/LoaderImplementation.html) mainClass(#packaging.repackage-goal.parameter-details.main-class) String outputTimestamp(#packaging.repackage-goal.parameter-details.output-timestamp) String ${project.build.outputTimestamp} requiresUnpack(#packaging.repackage-goal.parameter-details.requires-unpack) List skip(#packaging.repackage-goal.parameter-details.skip) boolean false Parameter details: attach: Attach the repackaged archive to be installed into your local Maven repository or deployed to a remote repository. If no classifier has been configured, it will replace the normal jar. If a classifier has been configured such that the normal jar and the repackaged jar are different, it will be attached alongside the normal jar. When the property is set to false , the repackaged archive will not be installed or deployed. Name attach Type boolean Default value true User property Since 1.4.0 classifier: Classifier to add to the repackaged archive. If not given, the main artifact will be replaced by the repackaged archive. If given, the classifier will also be used to determine the source archive to repackage: if an artifact with that classifier already exists, it will be used as source and replaced. If no such artifact exists, the main artifact will be used as source and the repackaged archive will be attached as a supplemental artifact with that classifier. Attaching the artifact allows to deploy it alongside to the original one, see the Maven documentation for more details(https://maven.apache.org/plugins/maven-deploy-plugin/examples/deploying-with-classifiers.html) . Name classifier Type java.lang.String Default value User property Since 1.0.0 embeddedLaunchScript: The embedded launch script to prepend to the front of the jar if it is fully executable. If not specified the 'Spring Boot' default script will be used. Name embeddedLaunchScript Type java.io.File Default value User property Since 1.3.0 embeddedLaunchScriptProperties: Properties that should be expanded in the embedded launch script. Name embeddedLaunchScriptProperties Type java.util.Properties Default value User property Since 1.3.0 excludeDevtools: Exclude Spring Boot devtools from the repackaged archive. Name excludeDevtools Type boolean Default value true User property spring-boot.repackage.excludeDevtools Since 1.3.0 excludeDockerCompose: Exclude Spring Boot dev services from the repackaged archive. Name excludeDockerCompose Type boolean Default value true User property spring-boot.repackage.excludeDockerCompose Since 3.1.0 excludeGroupIds: Comma separated list of groupId names to exclude (exact match). Name excludeGroupIds Type java.lang.String Default value User property spring-boot.excludeGroupIds Since 1.1.0 excludes: Collection of artifact definitions to exclude. The Exclude element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name excludes Type java.util.List Default value User property spring-boot.excludes Since 1.1.0 executable: Make a fully executable jar for *nix machines by prepending a launch script to the jar. <p> Currently, some tools do not accept this format so you may not always be able to use this technique. For example, jar -xf may silently fail to extract a jar or war that has been made fully-executable. It is recommended that you only enable this option if you intend to execute it directly, rather than running it with java -jar or deploying it to a servlet container. Name executable Type boolean Default value false User property Since 1.3.0 includeSystemScope: Include system scoped dependencies. Name includeSystemScope Type boolean Default value false User property Since 1.4.0 includeTools: Include JAR tools. Name includeTools Type boolean Default value true User property Since 3.3.0 includes: Collection of artifact definitions to include. The Include element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name includes Type java.util.List Default value User property spring-boot.includes Since 1.2.0 layers: Layer configuration with options to disable layer creation, exclude layer tools jar, and provide a custom layers configuration file. Name layers Type org.springframework.boot.maven.Layers(api/java/org/springframework/boot/maven/Layers.html) Default value User property Since 2.3.0 layout: The type of archive (which corresponds to how the dependencies are laid out inside it). Possible values are JAR , WAR , ZIP , DIR , NONE . Defaults to a guess based on the archive type. Name layout Type org.springframework.boot.maven.AbstractPackagerMojo$LayoutType(api/java/org/springframework/boot/maven/AbstractPackagerMojo.LayoutType.html) Default value User property spring-boot.repackage.layout Since 1.0.0 layoutFactory: The layout factory that will be used to create the executable archive if no explicit layout is set. Alternative layouts implementations can be provided by 3rd parties. Name layoutFactory Type org.springframework.boot.loader.tools.LayoutFactory(../api/java/org/springframework/boot/loader/tools/LayoutFactory.html) Default value User property Since 1.5.0 loaderImplementation: The loader implementation that should be used. Name loaderImplementation Type org.springframework.boot.loader.tools.LoaderImplementation(../api/java/org/springframework/boot/loader/tools/LoaderImplementation.html) Default value User property Since 3.2.0 mainClass: The name of the main class. If not specified the first compiled class found that contains a main method will be used. Name mainClass Type java.lang.String Default value User property Since 1.0.0 outputDirectory: Directory containing the generated archive. Name outputDirectory Type java.io.File Default value ${project.build.directory} User property Since 1.0.0 outputTimestamp: Timestamp for reproducible output archive entries, either formatted as ISO 8601 ( yyyy-MM-dd’T’HH:mm:ssXXX ) or an int representing seconds since the epoch. Name outputTimestamp Type java.lang.String Default value ${project.build.outputTimestamp} User property Since 2.3.0 requiresUnpack: A list of the libraries that must be unpacked from uber jars in order to run. Specify each library as a <dependency> with a <groupId> and a <artifactId> and they will be unpacked at runtime. Name requiresUnpack Type java.util.List Default value User property Since 1.1.0 skip: Skip the execution. Name skip Type boolean Default value false User property spring-boot.repackage.skip Since 1.2.0 Examples: Custom Classifier: By default, the repackage goal replaces the original artifact with the repackaged one. That is a sane behavior for modules that represent an application but if your module is used as a dependency of another module, you need to provide a classifier for the repackaged one. The reason for that is that application classes are packaged in BOOT-INF/classes so that the dependent module cannot load a repackaged jar’s classes. If that is the case or if you prefer to keep the original artifact and attach the repackaged one with a different classifier, configure the plugin as shown in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>repackage</id> <goals> <goal>repackage</goal> </goals> <configuration> <classifier>exec</classifier> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> If you are using spring-boot-starter-parent , the repackage goal is executed automatically in an execution with id repackage . In that setup, only the configuration should be specified, as shown in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>repackage</id> <configuration> <classifier>exec</classifier> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> This configuration will generate two artifacts: the original one and the repackaged counter part produced by the repackage goal. Both will be installed/deployed transparently. You can also use the same configuration if you want to repackage a secondary artifact the same way the main artifact is replaced. The following configuration installs/deploys a single task classified artifact with the repackaged application: <project> <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-jar-plugin</artifactId> <executions> <execution> <goals> <goal>jar</goal> </goals> <phase>package</phase> <configuration> <classifier>task</classifier> </configuration> </execution> </executions> </plugin> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>repackage</id> <goals> <goal>repackage</goal> </goals> <configuration> <classifier>task</classifier> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> As both the maven-jar-plugin and the spring-boot-maven-plugin runs at the same phase, it is important that the jar plugin is defined first (so that it runs before the repackage goal). Again, if you are using spring-boot-starter-parent , this can be simplified as follows: <project> <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-jar-plugin</artifactId> <executions> <execution> <id>default-jar</id> <configuration> <classifier>task</classifier> </configuration> </execution> </executions> </plugin> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>repackage</id> <configuration> <classifier>task</classifier> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Custom Name: If you need the repackaged jar to have a different local name than the one defined by the artifactId attribute of the project, use the standard finalName , as shown in the following example: <project> <build> <finalName>my-app</finalName> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>repackage</id> <goals> <goal>repackage</goal> </goals> </execution> </executions> </plugin> </plugins> </build> </project> This configuration will generate the repackaged artifact in target/my-app.jar . Local Repackaged Artifact: By default, the repackage goal replaces the original artifact with the executable one. If you need to only deploy the original jar and yet be able to run your app with the regular file name, configure the plugin as follows: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>repackage</id> <goals> <goal>repackage</goal> </goals> <configuration> <attach>false</attach> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> This configuration generates two artifacts: the original one and the executable counter part produced by the repackage goal. Only the original one will be installed/deployed. Custom Layout: Spring Boot repackages the jar file for this project using a custom layout factory defined in the additional jar file, provided as a dependency to the build plugin: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>repackage</id> <goals> <goal>repackage</goal> </goals> <configuration> <layoutFactory implementation=""com.example.CustomLayoutFactory""> <customProperty>value</customProperty> </layoutFactory> </configuration> </execution> </executions> <dependencies> <dependency> <groupId>com.example</groupId> <artifactId>custom-layout</artifactId> <version>0.0.1.BUILD-SNAPSHOT</version> </dependency> </dependencies> </plugin> </plugins> </build> </project> The layout factory is provided as an implementation of LayoutFactory (from spring-boot-loader-tools ) explicitly specified in the pom. If there is only one custom LayoutFactory on the plugin classpath and it is listed in META-INF/spring.factories then it is unnecessary to explicitly set it in the plugin configuration. Layout factories are always ignored if an explicit layout(#packaging.repackage-goal.parameter-details.layout-factory) is set. Dependency Exclusion: By default, both the repackage and the run goals will include any provided dependencies that are defined in the project. A Spring Boot project should consider provided dependencies as ""container"" dependencies that are required to run the application. Generally speaking, Spring Boot projects are not used as dependencies and are therefore unlikely to have any optional dependencies. When a project does have optional dependencies they too will be included by the repackage and run goals. Some of these dependencies may not be required at all and should be excluded from the executable jar. For consistency, they should not be present either when running the application. There are two ways one can exclude a dependency from being packaged/used at runtime: Exclude a specific artifact identified by groupId and artifactId , optionally with a classifier if needed. Exclude any artifact belonging to a given groupId . The following example excludes com.example:module1 , and only that artifact: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <excludes> <exclude> <groupId>com.example</groupId> <artifactId>module1</artifactId> </exclude> </excludes> </configuration> </plugin> </plugins> </build> </project> This example excludes any artifact belonging to the com.example group: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <excludeGroupIds>com.example</excludeGroupIds> </configuration> </plugin> </plugins> </build> </project> JAR Tools: When a layered jar or war is created, the spring-boot-jarmode-tools jar will be added as a dependency to your archive. With this jar on the classpath, you can launch your application in a special mode which allows the bootstrap code to run something entirely different from your application, for example, something that extracts the layers. If you wish to exclude this dependency, you can do so in the following manner: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <includeTools>false</includeTools> </configuration> </plugin> </plugins> </build> </project> Custom Layers Configuration: The default setup splits dependencies into snapshot and non-snapshot, however, you may have more complex rules. For example, you may want to isolate company-specific dependencies of your project in a dedicated layer. The following layers.xml configuration shown one such setup: <layers xmlns=""http://www.springframework.org/schema/boot/layers"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.springframework.org/schema/boot/layers layers-xsd: https://www.springframework.org/schema/boot/layers/layers-3.3.xsd""> <application> <into layer=""spring-boot-loader""> <include>org/springframework/boot/loader/**</include> </into> <into layer=""application"" /> </application> <dependencies> <into layer=""snapshot-dependencies""> <include>*:*:*SNAPSHOT</include> </into> <into layer=""company-dependencies""> <include>com.acme:*</include> </into> <into layer=""dependencies""/> </dependencies> <layerOrder> <layer>dependencies</layer> <layer>spring-boot-loader</layer> <layer>snapshot-dependencies</layer> <layer>company-dependencies</layer> <layer>application</layer> </layerOrder> </layers> The configuration above creates an additional company-dependencies layer with all libraries with the com.acme groupId."
"https://docs.spring.io/spring-boot/maven-plugin/build-image.html","Packaging OCI Images: The plugin can create an OCI image(https://github.com/opencontainers/image-spec) from a jar or war file using Cloud Native Buildpacks(https://buildpacks.io/) (CNB). Images can be built on the command-line using the build-image goal. This makes sure that the package lifecycle has run before the image is created. For security reasons, images build and run as non-root users. See the CNB specification(https://buildpacks.io/docs/reference/spec/platform-api/#users) for more details. The easiest way to get started is to invoke mvn spring-boot:build-image on a project. It is possible to automate the creation of an image whenever the package phase is invoked, as shown in the following example: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <goals> <goal>build-image-no-fork</goal> </goals> </execution> </executions> </plugin> </plugins> </build> Use build-image-no-fork when binding the goal to the package lifecycle. This goal is similar to build-image but does not fork the lifecycle to make sure package has run. In the rest of this section, build-image is used to refer to either the build-image or build-image-no-fork goals. While the buildpack runs from an executable archive(packaging.html) , it is not necessary to execute the repackage goal first as the executable archive is created automatically if necessary. When the build-image repackages the application, it applies the same settings as the repackage goal would, that is dependencies can be excluded using one of the exclude options. The spring-boot-devtools and spring-boot-docker-compose modules are automatically excluded by default (you can control this using the excludeDevtools and excludeDockerCompose properties). Docker Daemon: The build-image goal requires access to a Docker daemon. The goal will inspect local Docker CLI configuration files(https://docs.docker.com/engine/reference/commandline/cli/#configuration-files) to determine the current context(https://docs.docker.com/engine/context/working-with-contexts/) and use the context connection information to communicate with a Docker daemon. If the current context can not be determined or the context does not have connection information, then the goal will use a default local connection. This works with Docker Engine(https://docs.docker.com/install/) on all supported platforms without configuration. Environment variables can be set to configure the build-image goal to use an alternative local or remote connection. The following table shows the environment variables and their values: Environment variable Description DOCKER_CONFIG Location of Docker CLI configuration files(https://docs.docker.com/engine/reference/commandline/cli/#configuration-files) used to determine the current context (defaults to $HOME/.docker ) DOCKER_CONTEXT Name of a context(https://docs.docker.com/engine/context/working-with-contexts/) that should be used to retrieve host information from Docker CLI configuration files (overrides DOCKER_HOST ) DOCKER_HOST URL containing the host and port for the Docker daemon - for example tcp://192.168.99.100:2376 DOCKER_TLS_VERIFY Enable secure HTTPS protocol when set to 1 (optional) DOCKER_CERT_PATH Path to certificate and key files for HTTPS (required if DOCKER_TLS_VERIFY=1 , ignored otherwise) Docker daemon connection information can also be provided using docker parameters in the plugin configuration. The following table summarizes the available parameters: Parameter Description context Name of a context(https://docs.docker.com/engine/context/working-with-contexts/) that should be used to retrieve host information from Docker CLI configuration files(https://docs.docker.com/engine/reference/commandline/cli/#configuration-files) host URL containing the host and port for the Docker daemon - for example tcp://192.168.99.100:2376 tlsVerify Enable secure HTTPS protocol when set to true (optional) certPath Path to certificate and key files for HTTPS (required if tlsVerify is true , ignored otherwise) bindHostToBuilder When true , the value of the host property will be provided to the container that is created for the CNB builder (optional) For more details, see also examples(#build-image.examples.docker) . Docker Registry: If the Docker images specified by the builder or runImage parameters are stored in a private Docker image registry that requires authentication, the authentication credentials can be provided using docker.builderRegistry parameters. If the generated Docker image is to be published to a Docker image registry, the authentication credentials can be provided using docker.publishRegistry parameters. Parameters are provided for user authentication or identity token authentication. Consult the documentation for the Docker registry being used to store images for further information on supported authentication methods. The following table summarizes the available parameters for docker.builderRegistry and docker.publishRegistry : Parameter Description username Username for the Docker image registry user. Required for user authentication. password Password for the Docker image registry user. Required for user authentication. url Address of the Docker image registry. Optional for user authentication. email E-mail address for the Docker image registry user. Optional for user authentication. token Identity token for the Docker image registry user. Required for token authentication. For more details, see also examples(#build-image.examples.docker) . Image Customizations: The plugin invokes a builder(https://buildpacks.io/docs/concepts/components/builder/) to orchestrate the generation of an image. The builder includes multiple buildpacks(https://buildpacks.io/docs/concepts/components/buildpack) that can inspect the application to influence the generated image. By default, the plugin chooses a builder image. The name of the generated image is deduced from project properties. The image parameter allows configuration of the builder and how it should operate on the project. The following table summarizes the available parameters and their default values: Parameter / (User Property) Description Default value builder ( spring-boot.build-image.builder ) Name of the Builder image to use. paketobuildpacks/builder-jammy-base:latest runImage ( spring-boot.build-image.runImage ) Name of the run image to use. No default value, indicating the run image specified in Builder metadata should be used. name ( spring-boot.build-image.imageName ) Image name(../api/java/org/springframework/boot/buildpack/platform/docker/type/ImageName.html#of-java.lang.String-) for the generated image. docker.io/library/ ${project.artifactId}:${project.version} pullPolicy ( spring-boot.build-image.pullPolicy ) Policy(../api/java/org/springframework/boot/buildpack/platform/build/PullPolicy.html) used to determine when to pull the builder and run images from the registry. Acceptable values are ALWAYS , NEVER , and IF_NOT_PRESENT . ALWAYS env Environment variables that should be passed to the builder. buildpacks Buildpacks that the builder should use when building the image. Only the specified buildpacks will be used, overriding the default buildpacks included in the builder. Buildpack references must be in one of the following forms: Buildpack in the builder - [urn:cnb:builder:]<buildpack ID>[@<version>] Buildpack in a directory on the file system - [file://]<path> Buildpack in a gzipped tar (.tgz) file on the file system - [file://]<path>/<file name> Buildpack in an OCI image - [docker://]<host>/<repo>[:<tag>][@<digest>] None, indicating the builder should use the buildpacks included in it. bindings Volume bind mounts(https://docs.docker.com/storage/bind-mounts/) that should be mounted to the builder container when building the image. The bindings will be passed unparsed and unvalidated to Docker when creating the builder container. Bindings must be in one of the following forms: <host source path>:<container destination path>[:<options>] <host volume name>:<container destination path>[:<options>] Where <options> can contain: ro to mount the volume as read-only in the container rw to mount the volume as readable and writable in the container volume-opt=key=value to specify key-value pairs consisting of an option name and its value network + ( spring-boot.build-image.network ) The network driver(https://docs.docker.com/network/#network-drivers) the builder container will be configured to use. The value supplied will be passed unvalidated to Docker when creating the builder container. cleanCache + ( spring-boot.build-image.cleanCache ) Whether to clean the cache before building. false verboseLogging Enables verbose logging of builder operations. false publish + ( spring-boot.build-image.publish ) Whether to publish the generated image to a Docker registry. false tags One or more additional tags to apply to the generated image. The values provided to the tags option should be full image references. See the tags section(#build-image.customization.tags) for more details. buildWorkspace A temporary workspace that will be used by the builder and buildpacks to store files during image building. The value can be a named volume or a bind mount location. A named volume in the Docker daemon, with a name derived from the image name. buildCache A cache containing layers created by buildpacks and used by the image building process. The value can be a named volume or a bind mount location. A named volume in the Docker daemon, with a name derived from the image name. launchCache A cache containing layers created by buildpacks and used by the image launching process. The value can be a named volume or a bind mount location. A named volume in the Docker daemon, with a name derived from the image name. createdDate ( spring-boot.build-image.createdDate ) A date that will be used to set the Created field in the generated image’s metadata. The value must be a string in the ISO 8601 instant format, or now to use the current date and time. A fixed date that enables build reproducibility(https://buildpacks.io/docs/features/reproducibility/) . applicationDirectory ( spring-boot.build-image.applicationDirectory ) The path to a directory that application contents will be uploaded to in the builder image. Application contents will also be in this location in the generated image. /workspace securityOptions Security options(https://docs.docker.com/engine/reference/run/#security-configuration) that will be applied to the builder container, provided as an array of string values [""label=disable""] on Linux and macOS, [] on Windows The plugin detects the target Java compatibility of the project using the compiler’s plugin configuration or the maven.compiler.target property. When using the default Paketo builder and buildpacks, the plugin instructs the buildpacks to install the same Java version. You can override this behaviour as shown in the builder configuration(#build-image.examples.builder-configuration) examples. For more details, see also examples(#build-image.examples) . Tags Format: The values provided to the tags option should be full image references. The accepted format is [domainHost:port/][path/]name[:tag][@digest] . If the domain is missing, it defaults to docker.io . If the path is missing, it defaults to library . If the tag is missing, it defaults to latest . Some examples: my-image leads to the image reference docker.io/library/my-image:latest my-repository/my-image leads to docker.io/my-repository/my-image:latest example.com/my-repository/my-image:1.0.0 will be used as is spring-boot:build-image: org.springframework.boot:spring-boot-maven-plugin:3.3.4 Package an application into an OCI image using a buildpack, forking the lifecycle to make sure that package ran. This goal is suitable for command-line invocation. If you need to configure a goal execution in your build, use build-image-no-fork instead. Required parameters: Name Type Default sourceDirectory(#build-image.build-image-goal.parameter-details.source-directory) File ${project.build.directory} Optional parameters: Name Type Default classifier(#build-image.build-image-goal.parameter-details.classifier) String docker(#build-image.build-image-goal.parameter-details.docker) Docker(api/java/org/springframework/boot/maven/Docker.html) excludeDevtools(#build-image.build-image-goal.parameter-details.exclude-devtools) boolean true excludeDockerCompose(#build-image.build-image-goal.parameter-details.exclude-docker-compose) boolean true excludeGroupIds(#build-image.build-image-goal.parameter-details.exclude-group-ids) String excludes(#build-image.build-image-goal.parameter-details.excludes) List image(#build-image.build-image-goal.parameter-details.image) Image(api/java/org/springframework/boot/maven/Image.html) includeSystemScope(#build-image.build-image-goal.parameter-details.include-system-scope) boolean false includeTools(#build-image.build-image-goal.parameter-details.include-tools) boolean true includes(#build-image.build-image-goal.parameter-details.includes) List layers(#build-image.build-image-goal.parameter-details.layers) Layers(api/java/org/springframework/boot/maven/Layers.html) layout(#build-image.build-image-goal.parameter-details.layout) LayoutType(api/java/org/springframework/boot/maven/AbstractPackagerMojo.LayoutType.html) layoutFactory(#build-image.build-image-goal.parameter-details.layout-factory) LayoutFactory(../api/java/org/springframework/boot/loader/tools/LayoutFactory.html) loaderImplementation(#build-image.build-image-goal.parameter-details.loader-implementation) LoaderImplementation(../api/java/org/springframework/boot/loader/tools/LoaderImplementation.html) mainClass(#build-image.build-image-goal.parameter-details.main-class) String skip(#build-image.build-image-goal.parameter-details.skip) boolean false Parameter details: classifier: Classifier used when finding the source archive. Name classifier Type java.lang.String Default value User property Since 2.3.0 docker: Docker configuration options. Name docker Type org.springframework.boot.maven.Docker(api/java/org/springframework/boot/maven/Docker.html) Default value User property Since 2.4.0 excludeDevtools: Exclude Spring Boot devtools from the repackaged archive. Name excludeDevtools Type boolean Default value true User property spring-boot.repackage.excludeDevtools Since 1.3.0 excludeDockerCompose: Exclude Spring Boot dev services from the repackaged archive. Name excludeDockerCompose Type boolean Default value true User property spring-boot.repackage.excludeDockerCompose Since 3.1.0 excludeGroupIds: Comma separated list of groupId names to exclude (exact match). Name excludeGroupIds Type java.lang.String Default value User property spring-boot.excludeGroupIds Since 1.1.0 excludes: Collection of artifact definitions to exclude. The Exclude element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name excludes Type java.util.List Default value User property spring-boot.excludes Since 1.1.0 image: Image configuration, with builder , runImage , name , env , cleanCache , verboseLogging , pullPolicy , and publish options. Name image Type org.springframework.boot.maven.Image(api/java/org/springframework/boot/maven/Image.html) Default value User property Since 2.3.0 includeSystemScope: Include system scoped dependencies. Name includeSystemScope Type boolean Default value false User property Since 1.4.0 includeTools: Include JAR tools. Name includeTools Type boolean Default value true User property Since 3.3.0 includes: Collection of artifact definitions to include. The Include element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name includes Type java.util.List Default value User property spring-boot.includes Since 1.2.0 layers: Layer configuration with options to disable layer creation, exclude layer tools jar, and provide a custom layers configuration file. Name layers Type org.springframework.boot.maven.Layers(api/java/org/springframework/boot/maven/Layers.html) Default value User property Since 2.3.0 layout: The type of archive (which corresponds to how the dependencies are laid out inside it). Possible values are JAR , WAR , ZIP , DIR , NONE . Defaults to a guess based on the archive type. Name layout Type org.springframework.boot.maven.AbstractPackagerMojo$LayoutType(api/java/org/springframework/boot/maven/AbstractPackagerMojo.LayoutType.html) Default value User property Since 2.3.11 layoutFactory: The layout factory that will be used to create the executable archive if no explicit layout is set. Alternative layouts implementations can be provided by 3rd parties. Name layoutFactory Type org.springframework.boot.loader.tools.LayoutFactory(../api/java/org/springframework/boot/loader/tools/LayoutFactory.html) Default value User property Since 2.3.11 loaderImplementation: The loader implementation that should be used. Name loaderImplementation Type org.springframework.boot.loader.tools.LoaderImplementation(../api/java/org/springframework/boot/loader/tools/LoaderImplementation.html) Default value User property Since 3.2.0 mainClass: The name of the main class. If not specified the first compiled class found that contains a main method will be used. Name mainClass Type java.lang.String Default value User property Since 1.0.0 skip: Skip the execution. Name skip Type boolean Default value false User property spring-boot.build-image.skip Since 2.3.0 sourceDirectory: Directory containing the source archive. Name sourceDirectory Type java.io.File Default value ${project.build.directory} User property Since 2.3.0 spring-boot:build-image-no-fork: org.springframework.boot:spring-boot-maven-plugin:3.3.4 Package an application into an OCI image using a buildpack, but without forking the lifecycle. This goal should be used when configuring a goal execution in your build. To invoke the goal on the command-line, use build-image instead. Required parameters: Name Type Default sourceDirectory(#build-image.build-image-no-fork-goal.parameter-details.source-directory) File ${project.build.directory} Optional parameters: Name Type Default classifier(#build-image.build-image-no-fork-goal.parameter-details.classifier) String docker(#build-image.build-image-no-fork-goal.parameter-details.docker) Docker(api/java/org/springframework/boot/maven/Docker.html) excludeDevtools(#build-image.build-image-no-fork-goal.parameter-details.exclude-devtools) boolean true excludeDockerCompose(#build-image.build-image-no-fork-goal.parameter-details.exclude-docker-compose) boolean true excludeGroupIds(#build-image.build-image-no-fork-goal.parameter-details.exclude-group-ids) String excludes(#build-image.build-image-no-fork-goal.parameter-details.excludes) List image(#build-image.build-image-no-fork-goal.parameter-details.image) Image(api/java/org/springframework/boot/maven/Image.html) includeSystemScope(#build-image.build-image-no-fork-goal.parameter-details.include-system-scope) boolean false includeTools(#build-image.build-image-no-fork-goal.parameter-details.include-tools) boolean true includes(#build-image.build-image-no-fork-goal.parameter-details.includes) List layers(#build-image.build-image-no-fork-goal.parameter-details.layers) Layers(api/java/org/springframework/boot/maven/Layers.html) layout(#build-image.build-image-no-fork-goal.parameter-details.layout) LayoutType(api/java/org/springframework/boot/maven/AbstractPackagerMojo.LayoutType.html) layoutFactory(#build-image.build-image-no-fork-goal.parameter-details.layout-factory) LayoutFactory(../api/java/org/springframework/boot/loader/tools/LayoutFactory.html) loaderImplementation(#build-image.build-image-no-fork-goal.parameter-details.loader-implementation) LoaderImplementation(../api/java/org/springframework/boot/loader/tools/LoaderImplementation.html) mainClass(#build-image.build-image-no-fork-goal.parameter-details.main-class) String skip(#build-image.build-image-no-fork-goal.parameter-details.skip) boolean false Parameter details: classifier: Classifier used when finding the source archive. Name classifier Type java.lang.String Default value User property Since 2.3.0 docker: Docker configuration options. Name docker Type org.springframework.boot.maven.Docker(api/java/org/springframework/boot/maven/Docker.html) Default value User property Since 2.4.0 excludeDevtools: Exclude Spring Boot devtools from the repackaged archive. Name excludeDevtools Type boolean Default value true User property spring-boot.repackage.excludeDevtools Since 1.3.0 excludeDockerCompose: Exclude Spring Boot dev services from the repackaged archive. Name excludeDockerCompose Type boolean Default value true User property spring-boot.repackage.excludeDockerCompose Since 3.1.0 excludeGroupIds: Comma separated list of groupId names to exclude (exact match). Name excludeGroupIds Type java.lang.String Default value User property spring-boot.excludeGroupIds Since 1.1.0 excludes: Collection of artifact definitions to exclude. The Exclude element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name excludes Type java.util.List Default value User property spring-boot.excludes Since 1.1.0 image: Image configuration, with builder , runImage , name , env , cleanCache , verboseLogging , pullPolicy , and publish options. Name image Type org.springframework.boot.maven.Image(api/java/org/springframework/boot/maven/Image.html) Default value User property Since 2.3.0 includeSystemScope: Include system scoped dependencies. Name includeSystemScope Type boolean Default value false User property Since 1.4.0 includeTools: Include JAR tools. Name includeTools Type boolean Default value true User property Since 3.3.0 includes: Collection of artifact definitions to include. The Include element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name includes Type java.util.List Default value User property spring-boot.includes Since 1.2.0 layers: Layer configuration with options to disable layer creation, exclude layer tools jar, and provide a custom layers configuration file. Name layers Type org.springframework.boot.maven.Layers(api/java/org/springframework/boot/maven/Layers.html) Default value User property Since 2.3.0 layout: The type of archive (which corresponds to how the dependencies are laid out inside it). Possible values are JAR , WAR , ZIP , DIR , NONE . Defaults to a guess based on the archive type. Name layout Type org.springframework.boot.maven.AbstractPackagerMojo$LayoutType(api/java/org/springframework/boot/maven/AbstractPackagerMojo.LayoutType.html) Default value User property Since 2.3.11 layoutFactory: The layout factory that will be used to create the executable archive if no explicit layout is set. Alternative layouts implementations can be provided by 3rd parties. Name layoutFactory Type org.springframework.boot.loader.tools.LayoutFactory(../api/java/org/springframework/boot/loader/tools/LayoutFactory.html) Default value User property Since 2.3.11 loaderImplementation: The loader implementation that should be used. Name loaderImplementation Type org.springframework.boot.loader.tools.LoaderImplementation(../api/java/org/springframework/boot/loader/tools/LoaderImplementation.html) Default value User property Since 3.2.0 mainClass: The name of the main class. If not specified the first compiled class found that contains a main method will be used. Name mainClass Type java.lang.String Default value User property Since 1.0.0 skip: Skip the execution. Name skip Type boolean Default value false User property spring-boot.build-image.skip Since 2.3.0 sourceDirectory: Directory containing the source archive. Name sourceDirectory Type java.io.File Default value ${project.build.directory} User property Since 2.3.0 Examples: Custom Image Builder: If you need to customize the builder used to create the image or the run image used to launch the built image, configure the plugin as shown in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <image> <builder>mine/java-cnb-builder</builder> <runImage>mine/java-cnb-run</runImage> </image> </configuration> </plugin> </plugins> </build> </project> This configuration will use a builder image with the name mine/java-cnb-builder and the tag latest , and the run image named mine/java-cnb-run and the tag latest . The builder and run image can be specified on the command line as well, as shown in this example: $ mvn spring-boot:build-image -Dspring-boot.build-image.builder=mine/java-cnb-builder -Dspring-boot.build-image.runImage=mine/java-cnb-run Builder Configuration: If the builder exposes configuration options using environment variables, those can be set using the env attributes. The following is an example of configuring the JVM version(https://paketo.io/docs/buildpacks/language-family-buildpacks/java/#configuring-the-jvm-version) used by the Paketo Java buildpacks at build time: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <image> <env> <BP_JVM_VERSION>17</BP_JVM_VERSION> </env> </image> </configuration> </plugin> </plugins> </build> </project> If there is a network proxy between the Docker daemon the builder runs in and network locations that buildpacks download artifacts from, you will need to configure the builder to use the proxy. When using the Paketo builder, this can be accomplished by setting the HTTPS_PROXY and/or HTTP_PROXY environment variables as show in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <image> <env> <HTTP_PROXY>http://proxy.example.com</HTTP_PROXY> <HTTPS_PROXY>https://proxy.example.com</HTTPS_PROXY> </env> </image> </configuration> </plugin> </plugins> </build> </project> Runtime JVM Configuration: Paketo Java buildpacks configure the JVM runtime environment(https://paketo.io/docs/buildpacks/language-family-buildpacks/java/#runtime-jvm-configuration) by setting the JAVA_TOOL_OPTIONS environment variable. The buildpack-provided JAVA_TOOL_OPTIONS value can be modified to customize JVM runtime behavior when the application image is launched in a container. Environment variable modifications that should be stored in the image and applied to every deployment can be set as described in the Paketo documentation(https://paketo.io/docs/buildpacks/configuration/#environment-variables) and shown in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <image> <env> <BPE_DELIM_JAVA_TOOL_OPTIONS xml:space=""preserve""> </BPE_DELIM_JAVA_TOOL_OPTIONS> <BPE_APPEND_JAVA_TOOL_OPTIONS>-XX:+HeapDumpOnOutOfMemoryError</BPE_APPEND_JAVA_TOOL_OPTIONS> </env> </image> </configuration> </plugin> </plugins> </build> </project> Custom Image Name: By default, the image name is inferred from the artifactId and the version of the project, something like docker.io/library/${project.artifactId}:${project.version} . You can take control over the name, as shown in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <image> <name>example.com/library/${project.artifactId}</name> </image> </configuration> </plugin> </plugins> </build> </project> This configuration does not provide an explicit tag so latest is used. It is possible to specify a tag as well, either using ${project.version} , any property available in the build or a hardcoded version. The image name can be specified on the command line as well, as shown in this example: $ mvn spring-boot:build-image -Dspring-boot.build-image.imageName=example.com/library/my-app:v1 Buildpacks: By default, the builder will use buildpacks included in the builder image and apply them in a pre-defined order. An alternative set of buildpacks can be provided to apply buildpacks that are not included in the builder, or to change the order of included buildpacks. When one or more buildpacks are provided, only the specified buildpacks will be applied. The following example instructs the builder to use a custom buildpack packaged in a .tgz file, followed by a buildpack included in the builder. <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <image> <buildpacks> <buildpack>file:///path/to/example-buildpack.tgz</buildpack> <buildpack>urn:cnb:builder:paketo-buildpacks/java</buildpack> </buildpacks> </image> </configuration> </plugin> </plugins> </build> </project> Buildpacks can be specified in any of the forms shown below. A buildpack located in a CNB Builder (version may be omitted if there is only one buildpack in the builder matching the buildpack-id ): urn:cnb:builder:buildpack-id urn:cnb:builder: [email protected](/cdn-cgi/l/email-protection) buildpack-id [email protected](/cdn-cgi/l/email-protection) A path to a directory containing buildpack content (not supported on Windows): file:///path/to/buildpack/ /path/to/buildpack/ A path to a gzipped tar file containing buildpack content: file:///path/to/buildpack.tgz /path/to/buildpack.tgz An OCI image containing a packaged buildpack(https://buildpacks.io/docs/buildpack-author-guide/package-a-buildpack/) : docker://example/buildpack docker:///example/buildpack:latest docker:///example/buildpack@sha256:45b23dee08…​ example/buildpack example/buildpack:latest example/buildpack@sha256:45b23dee08…​ Image Publishing: The generated image can be published to a Docker registry by enabling a publish option. If the Docker registry requires authentication, the credentials can be configured using docker.publishRegistry parameters. If the Docker registry does not require authentication, the docker.publishRegistry configuration can be omitted. The registry that the image will be published to is determined by the registry part of the image name ( docker.example.com in these examples). If docker.publishRegistry credentials are configured and include a url parameter, this value is passed to the registry but is not used to determine the publishing registry location. <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <image> <name>docker.example.com/library/${project.artifactId}</name> <publish>true</publish> </image> <docker> <publishRegistry> <username>user</username> <password>secret</password> </publishRegistry> </docker> </configuration> </plugin> </plugins> </build> </project> The publish option can be specified on the command line as well, as shown in this example: $ mvn spring-boot:build-image -Dspring-boot.build-image.imageName=docker.example.com/library/my-app:v1 -Dspring-boot.build-image.publish=true When using the publish option on the command line with authentication, you can provide credentials using properties as in this example: $ mvn spring-boot:build-image \ -Ddocker.publishRegistry.username=user \ -Ddocker.publishRegistry.password=secret \ -Ddocker.publishRegistry.url=docker.example.com \ -Dspring-boot.build-image.publish=true \ -Dspring-boot.build-image.imageName=docker.example.com/library/my-app:v1 and reference the properties in the XML configuration: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <docker> <publishRegistry> <url>${docker.publishRegistry.url}</url> <username>${docker.publishRegistry.username}</username> <password>${docker.publishRegistry.password}</password> </publishRegistry> </docker> </configuration> </plugin> </plugins> </build> </project> Builder Cache and Workspace Configuration: The CNB builder caches layers that are used when building and launching an image. By default, these caches are stored as named volumes in the Docker daemon with names that are derived from the full name of the target image. If the image name changes frequently, for example when the project version is used as a tag in the image name, then the caches can be invalidated frequently. The cache volumes can be configured to use alternative names to give more control over cache lifecycle as shown in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <image> <buildCache> <volume> <name>cache-${project.artifactId}.build</name> </volume> </buildCache> <launchCache> <volume> <name>cache-${project.artifactId}.launch</name> </volume> </launchCache> </image> </configuration> </plugin> </plugins> </build> </project> Builders and buildpacks need a location to store temporary files during image building. By default, this temporary build workspace is stored in a named volume. The caches and the build workspace can be configured to use bind mounts instead of named volumes, as shown in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <image> <buildWorkspace> <bind> <source>/tmp/cache-${project.artifactId}.work</source> </bind> </buildWorkspace> <buildCache> <bind> <source>/tmp/cache-${project.artifactId}.build</source> </bind> </buildCache> <launchCache> <bind> <source>/tmp/cache-${project.artifactId}.launch</source> </bind> </launchCache> </image> </configuration> </plugin> </plugins> </build> </project> Docker Configuration: Docker Configuration for minikube: The plugin can communicate with the Docker daemon provided by minikube(https://minikube.sigs.k8s.io/docs/tasks/docker_daemon/) instead of the default local connection. On Linux and macOS, environment variables can be set using the command eval $(minikube docker-env) after minikube has been started. The plugin can also be configured to use the minikube daemon by providing connection details similar to those shown in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <docker> <host>tcp://192.168.99.100:2376</host> <tlsVerify>true</tlsVerify> <certPath>/home/user/.minikube/certs</certPath> </docker> </configuration> </plugin> </plugins> </build> </project> Docker Configuration for podman: The plugin can communicate with a podman container engine(https://podman.io/) . The plugin can be configured to use podman local connection by providing connection details similar to those shown in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <docker> <host>unix:///run/user/1000/podman/podman.sock</host> <bindHostToBuilder>true</bindHostToBuilder> </docker> </configuration> </plugin> </plugins> </build> </project> With the colima CLI installed, the command podman info --format='{{.Host.RemoteSocket.Path}}' can be used to get the value for the docker.host configuration property shown in this example. Docker Configuration for Colima: The plugin can communicate with the Docker daemon provided by Colima(https://github.com/abiosoft/colima) . The DOCKER_HOST environment variable can be set by using the following command: $ export DOCKER_HOST=$(docker context inspect colima -f '{{.Endpoints.docker.Host}}') The plugin can also be configured to use Colima daemon by providing connection details similar to those shown in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <docker> <host>unix:///${user.home}/.colima/docker.sock</host> </docker> </configuration> </plugin> </plugins> </build> </project> Docker Configuration for Authentication: If the builder or run image are stored in a private Docker registry that supports user authentication, authentication details can be provided using docker.builderRegistry parameters as shown in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <docker> <builderRegistry> <username>user</username> <password>secret</password> <url>https://docker.example.com/v1/</url> <email> [email protected](/cdn-cgi/l/email-protection) </email> </builderRegistry> </docker> </configuration> </plugin> </plugins> </build> </project> If the builder or run image is stored in a private Docker registry that supports token authentication, the token value can be provided using docker.builderRegistry parameters as shown in the following example: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <docker> <builderRegistry> <token>9cbaf023786cd7...</token> </builderRegistry> </docker> </configuration> </plugin> </plugins> </build> </project>"
"https://docs.spring.io/spring-boot/maven-plugin/run.html","Running your Application with Maven: The plugin includes a run goal which can be used to launch your application from the command line, as shown in the following example: $ mvn spring-boot:run Application arguments can be specified using the arguments parameter, see using application arguments(#run.examples.using-application-arguments) for more details. The application is executed in a forked process and setting properties on the command-line will not affect the application. If you need to specify some JVM arguments (that is for debugging purposes), you can use the jvmArguments parameter, see Debug the application(#run.examples.debug) for more details. There is also explicit support for system properties(#run.examples.system-properties) and environment variables(#run.examples.environment-variables) . As enabling a profile is quite common, there is dedicated profiles property that offers a shortcut for -Dspring-boot.run.jvmArguments=""-Dspring.profiles.active=dev"" , see Specify active profiles(#run.examples.specify-active-profiles) . Spring Boot devtools is a module to improve the development-time experience when working on Spring Boot applications. To enable it, just add the following dependency to your project: <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> <optional>true</optional> </dependency> </dependencies> When devtools is running, it detects changes when you recompile your application and automatically refreshes it. This works for not only resources but code as well. It also provides a LiveReload server so that it can automatically trigger a browser refresh whenever things change. Devtools can also be configured to only refresh the browser whenever a static resource has changed (and ignore any change in the code). Just include the following property in your project: spring.devtools.remote.restart.enabled=false Prior to devtools , the plugin supported hot refreshing of resources by default which has now been disabled in favour of the solution described above. You can restore it at any time by configuring your project: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <addResources>true</addResources> </configuration> </plugin> </plugins> </build> When addResources is enabled, any src/main/resources directory will be added to the application classpath when you run the application and any duplicate found in the classes output will be removed. This allows hot refreshing of resources which can be very useful when developing web applications. For example, you can work on HTML, CSS or JavaScript files and see your changes immediately without recompiling your application. It is also a helpful way of allowing your front end developers to work without needing to download and install a Java IDE. A side effect of using this feature is that filtering of resources at build time will not work. In order to be consistent with the repackage goal, the run goal builds the classpath in such a way that any dependency that is excluded in the plugin’s configuration gets excluded from the classpath as well. For more details, see the dedicated example(packaging.html#packaging.examples.exclude-dependency) . Sometimes it is useful to run a test variant of your application. For example, if you want to use Testcontainers at development time(../reference/features/dev-services.html#features.dev-services.testcontainers.at-development-time) or make use of some test stubs. Use the test-run goal with many of the same features and configuration options as run for this purpose. spring-boot:run: org.springframework.boot:spring-boot-maven-plugin:3.3.4 Run an application in place. Required parameters: Name Type Default classesDirectory(#run.run-goal.parameter-details.classes-directory) File ${project.build.outputDirectory} Optional parameters: Name Type Default addResources(#run.run-goal.parameter-details.add-resources) boolean false additionalClasspathElements(#run.run-goal.parameter-details.additional-classpath-elements) String[] agents(#run.run-goal.parameter-details.agents) File[] arguments(#run.run-goal.parameter-details.arguments) String[] commandlineArguments(#run.run-goal.parameter-details.commandline-arguments) String directories(#run.run-goal.parameter-details.directories) String[] environmentVariables(#run.run-goal.parameter-details.environment-variables) Map excludeGroupIds(#run.run-goal.parameter-details.exclude-group-ids) String excludes(#run.run-goal.parameter-details.excludes) List includes(#run.run-goal.parameter-details.includes) List jvmArguments(#run.run-goal.parameter-details.jvm-arguments) String mainClass(#run.run-goal.parameter-details.main-class) String noverify(#run.run-goal.parameter-details.noverify) boolean optimizedLaunch(#run.run-goal.parameter-details.optimized-launch) boolean true profiles(#run.run-goal.parameter-details.profiles) String[] skip(#run.run-goal.parameter-details.skip) boolean false systemPropertyVariables(#run.run-goal.parameter-details.system-property-variables) Map useTestClasspath(#run.run-goal.parameter-details.use-test-classpath) Boolean false workingDirectory(#run.run-goal.parameter-details.working-directory) File Parameter details: addResources: Add maven resources to the classpath directly, this allows live in-place editing of resources. Duplicate resources are removed from target/classes to prevent them from appearing twice if ClassLoader.getResources() is called. Please consider adding spring-boot-devtools to your project instead as it provides this feature and many more. Name addResources Type boolean Default value false User property spring-boot.run.addResources Since 1.0.0 additionalClasspathElements: Additional classpath elements that should be added to the classpath. An element can be a directory with classes and resources or a jar file. Name additionalClasspathElements Type java.lang.String[] Default value User property spring-boot.run.additional-classpath-elements Since 3.2.0 agents: Path to agent jars. Name agents Type java.io.File[] Default value User property spring-boot.run.agents Since 2.2.0 arguments: Arguments that should be passed to the application. Name arguments Type java.lang.String[] Default value User property Since 1.0.0 classesDirectory: Directory containing the classes and resource files that should be used to run the application. Name classesDirectory Type java.io.File Default value ${project.build.outputDirectory} User property Since 1.0.0 commandlineArguments: Arguments from the command line that should be passed to the application. Use spaces to separate multiple arguments and make sure to wrap multiple values between quotes. When specified, takes precedence over #arguments . Name commandlineArguments Type java.lang.String Default value User property spring-boot.run.arguments Since 2.2.3 directories: Additional directories containing classes or resources that should be added to the classpath. Name directories Type java.lang.String[] Default value User property spring-boot.run.directories Since 1.0.0 environmentVariables: List of Environment variables that should be associated with the forked process used to run the application. Name environmentVariables Type java.util.Map Default value User property Since 2.1.0 excludeGroupIds: Comma separated list of groupId names to exclude (exact match). Name excludeGroupIds Type java.lang.String Default value User property spring-boot.excludeGroupIds Since 1.1.0 excludes: Collection of artifact definitions to exclude. The Exclude element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name excludes Type java.util.List Default value User property spring-boot.excludes Since 1.1.0 includes: Collection of artifact definitions to include. The Include element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name includes Type java.util.List Default value User property spring-boot.includes Since 1.2.0 jvmArguments: JVM arguments that should be associated with the forked process used to run the application. On command line, make sure to wrap multiple values between quotes. Name jvmArguments Type java.lang.String Default value User property spring-boot.run.jvmArguments Since 1.1.0 mainClass: The name of the main class. If not specified the first compiled class found that contains a 'main' method will be used. Name mainClass Type java.lang.String Default value User property spring-boot.run.main-class Since 1.0.0 noverify: Flag to say that the agent requires -noverify. Name noverify Type boolean Default value User property spring-boot.run.noverify Since 1.0.0 optimizedLaunch: Whether the JVM’s launch should be optimized. Name optimizedLaunch Type boolean Default value true User property spring-boot.run.optimizedLaunch Since 2.2.0 profiles: The spring profiles to activate. Convenience shortcut of specifying the 'spring.profiles.active' argument. On command line use commas to separate multiple profiles. Name profiles Type java.lang.String[] Default value User property spring-boot.run.profiles Since 1.3.0 skip: Skip the execution. Name skip Type boolean Default value false User property spring-boot.run.skip Since 1.3.2 systemPropertyVariables: List of JVM system properties to pass to the process. Name systemPropertyVariables Type java.util.Map Default value User property Since 2.1.0 useTestClasspath: Flag to include the test classpath when running. Name useTestClasspath Type java.lang.Boolean Default value false User property spring-boot.run.useTestClasspath Since 1.3.0 workingDirectory: Current working directory to use for the application. If not specified, basedir will be used. Name workingDirectory Type java.io.File Default value User property spring-boot.run.workingDirectory Since 1.5.0 spring-boot:test-run: org.springframework.boot:spring-boot-maven-plugin:3.3.4 Run an application in place using the test runtime classpath. The main class that will be used to launch the application is determined as follows: The configured main class, if any. Then the main class found in the test classes directory, if any. Then the main class found in the classes directory, if any. Required parameters: Name Type Default classesDirectory(#run.test-run-goal.parameter-details.classes-directory) File ${project.build.outputDirectory} testClassesDirectory(#run.test-run-goal.parameter-details.test-classes-directory) File ${project.build.testOutputDirectory} Optional parameters: Name Type Default addResources(#run.test-run-goal.parameter-details.add-resources) boolean false additionalClasspathElements(#run.test-run-goal.parameter-details.additional-classpath-elements) String[] agents(#run.test-run-goal.parameter-details.agents) File[] arguments(#run.test-run-goal.parameter-details.arguments) String[] commandlineArguments(#run.test-run-goal.parameter-details.commandline-arguments) String directories(#run.test-run-goal.parameter-details.directories) String[] environmentVariables(#run.test-run-goal.parameter-details.environment-variables) Map excludeGroupIds(#run.test-run-goal.parameter-details.exclude-group-ids) String excludes(#run.test-run-goal.parameter-details.excludes) List includes(#run.test-run-goal.parameter-details.includes) List jvmArguments(#run.test-run-goal.parameter-details.jvm-arguments) String mainClass(#run.test-run-goal.parameter-details.main-class) String noverify(#run.test-run-goal.parameter-details.noverify) boolean optimizedLaunch(#run.test-run-goal.parameter-details.optimized-launch) boolean true profiles(#run.test-run-goal.parameter-details.profiles) String[] skip(#run.test-run-goal.parameter-details.skip) boolean false systemPropertyVariables(#run.test-run-goal.parameter-details.system-property-variables) Map workingDirectory(#run.test-run-goal.parameter-details.working-directory) File Parameter details: addResources: Add maven resources to the classpath directly, this allows live in-place editing of resources. Duplicate resources are removed from target/classes to prevent them from appearing twice if ClassLoader.getResources() is called. Please consider adding spring-boot-devtools to your project instead as it provides this feature and many more. Name addResources Type boolean Default value false User property spring-boot.run.addResources Since 1.0.0 additionalClasspathElements: Additional classpath elements that should be added to the classpath. An element can be a directory with classes and resources or a jar file. Name additionalClasspathElements Type java.lang.String[] Default value User property spring-boot.run.additional-classpath-elements Since 3.2.0 agents: Path to agent jars. Name agents Type java.io.File[] Default value User property spring-boot.run.agents Since 2.2.0 arguments: Arguments that should be passed to the application. Name arguments Type java.lang.String[] Default value User property Since 1.0.0 classesDirectory: Directory containing the classes and resource files that should be used to run the application. Name classesDirectory Type java.io.File Default value ${project.build.outputDirectory} User property Since 1.0.0 commandlineArguments: Arguments from the command line that should be passed to the application. Use spaces to separate multiple arguments and make sure to wrap multiple values between quotes. When specified, takes precedence over #arguments . Name commandlineArguments Type java.lang.String Default value User property spring-boot.run.arguments Since 2.2.3 directories: Additional directories containing classes or resources that should be added to the classpath. Name directories Type java.lang.String[] Default value User property spring-boot.run.directories Since 1.0.0 environmentVariables: List of Environment variables that should be associated with the forked process used to run the application. Name environmentVariables Type java.util.Map Default value User property Since 2.1.0 excludeGroupIds: Comma separated list of groupId names to exclude (exact match). Name excludeGroupIds Type java.lang.String Default value User property spring-boot.excludeGroupIds Since 1.1.0 excludes: Collection of artifact definitions to exclude. The Exclude element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name excludes Type java.util.List Default value User property spring-boot.excludes Since 1.1.0 includes: Collection of artifact definitions to include. The Include element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name includes Type java.util.List Default value User property spring-boot.includes Since 1.2.0 jvmArguments: JVM arguments that should be associated with the forked process used to run the application. On command line, make sure to wrap multiple values between quotes. Name jvmArguments Type java.lang.String Default value User property spring-boot.run.jvmArguments Since 1.1.0 mainClass: The name of the main class. If not specified the first compiled class found that contains a 'main' method will be used. Name mainClass Type java.lang.String Default value User property spring-boot.run.main-class Since 1.0.0 noverify: Flag to say that the agent requires -noverify. Name noverify Type boolean Default value User property spring-boot.run.noverify Since 1.0.0 optimizedLaunch: Whether the JVM’s launch should be optimized. Name optimizedLaunch Type boolean Default value true User property spring-boot.test-run.optimizedLaunch Since profiles: The spring profiles to activate. Convenience shortcut of specifying the 'spring.profiles.active' argument. On command line use commas to separate multiple profiles. Name profiles Type java.lang.String[] Default value User property spring-boot.run.profiles Since 1.3.0 skip: Skip the execution. Name skip Type boolean Default value false User property spring-boot.run.skip Since 1.3.2 systemPropertyVariables: List of JVM system properties to pass to the process. Name systemPropertyVariables Type java.util.Map Default value User property Since 2.1.0 testClassesDirectory: Directory containing the test classes and resource files that should be used to run the application. Name testClassesDirectory Type java.io.File Default value ${project.build.testOutputDirectory} User property Since workingDirectory: Current working directory to use for the application. If not specified, basedir will be used. Name workingDirectory Type java.io.File Default value User property spring-boot.run.workingDirectory Since 1.5.0 Examples: Debug the Application: The run and test-run goals run your application in a forked process. If you need to debug it, you should add the necessary JVM arguments to enable remote debugging. The following configuration suspend the process until a debugger has joined on port 5005: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <jvmArguments> -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005 </jvmArguments> </configuration> </plugin> </plugins> </build> </project> These arguments can be specified on the command line as well: $ mvn spring-boot:run -Dspring-boot.run.jvmArguments=-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005 Using System Properties: System properties can be specified using the systemPropertyVariables attribute. The following example sets property1 to test and property2 to 42: <project> <build> <properties> <my.value>42</my.value> </properties> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <systemPropertyVariables> <property1>test</property1> <property2>${my.value}</property2> </systemPropertyVariables> </configuration> </plugin> </plugins> </build> </project> If the value is empty or not defined (that is <my-property/ >), the system property is set with an empty String as the value. Maven trims values specified in the pom, so it is not possible to specify a System property which needs to start or end with a space through this mechanism: consider using jvmArguments instead. Any String typed Maven variable can be passed as system properties. Any attempt to pass any other Maven variable type (for example a List or a URL variable) will cause the variable expression to be passed literally (unevaluated). The jvmArguments parameter takes precedence over system properties defined with the mechanism above. In the following example, the value for property1 is overridden : $ mvn spring-boot:run -Dspring-boot.run.jvmArguments=""-Dproperty1=overridden"" Using Environment Variables: Environment variables can be specified using the environmentVariables attribute. The following example sets the 'ENV1', 'ENV2', 'ENV3', 'ENV4' env variables: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <environmentVariables> <ENV1>5000</ENV1> <ENV2>Some Text</ENV2> <ENV3/> <ENV4></ENV4> </environmentVariables> </configuration> </plugin> </plugins> </build> </project> If the value is empty or not defined (that is <MY_ENV/ >), the env variable is set with an empty String as the value. Maven trims values specified in the pom so it is not possible to specify an env variable which needs to start or end with a space. Any String typed Maven variable can be passed as system properties. Any attempt to pass any other Maven variable type (for example a List or a URL variable) will cause the variable expression to be passed literally (unevaluated). Environment variables defined this way take precedence over existing values. Using Application Arguments: Application arguments can be specified using the arguments attribute. The following example sets two arguments: property1 and property2=42 : <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <arguments> <argument>property1</argument> <argument>property2=${my.value}</argument> </arguments> </configuration> </plugin> </plugins> </build> </project> On the command-line, arguments are separated by a space the same way jvmArguments are. If an argument contains a space, make sure to quote it. In the following example, two arguments are available: property1 and property2=Hello World : $ mvn spring-boot:run -Dspring-boot.run.arguments=""property1 'property2=Hello World'"" Specify Active Profiles: The active profiles to use for a particular application can be specified using the profiles argument. The following configuration enables the local and dev profiles: <project> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <profiles> <profile>local</profile> <profile>dev</profile> </profiles> </configuration> </plugin> </plugins> </build> </project> The profiles to enable can be specified on the command line as well, make sure to separate them with a comma, as shown in the following example: $ mvn spring-boot:run -Dspring-boot.run.profiles=local,dev"
"https://docs.spring.io/spring-boot/maven-plugin/aot.html","Ahead-of-Time Processing: Spring AOT is a process that analyzes your application at build-time and generate an optimized version of it. It is a mandatory step to run a Spring ApplicationContext in a native image. For an overview of GraalVM Native Images support in Spring Boot, check the reference documentation(../reference/packaging/native-image/index.html) . The Spring Boot Maven plugin offers goals that can be used to perform AOT processing on both application and test code. Processing Applications: To configure your application to use this feature, add an execution for the process-aot goal, as shown in the following example: <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>process-aot</id> <goals> <goal>process-aot</goal> </goals> </execution> </executions> </plugin> As the BeanFactory is fully prepared at build-time, conditions are also evaluated. This has an important difference compared to what a regular Spring Boot application does at runtime. For instance, if you want to opt-in or opt-out for certain features, you need to configure the environment used at build time to do so. The process-aot goal shares a number of properties with the run goal(run.html) for that reason. Using the Native Profile: If you use spring-boot-starter-parent as the parent of your project, a native profile can be used to streamline the steps required to build a native image. The native profile configures the following: Execution of process-aot when the Spring Boot Maven Plugin is applied on a project. Suitable settings so that build-image(build-image.html) generates a native image. Sensible defaults for the Native Build Tools Maven Plugin(https://graalvm.github.io/native-build-tools/0.10.3/maven-plugin.html) , in particular: Making sure the plugin uses the raw classpath, and not the main jar file as it does not understand our repackaged jar format. Validate that a suitable GraalVM version is available. Download third-party reachability metadata. To benefit from the native profile, a module that represents an application should define two plugins, as shown in the following example: <plugin> <groupId>org.graalvm.buildtools</groupId> <artifactId>native-maven-plugin</artifactId> </plugin> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> A single project can trigger the generation of a native image on the command-line using either Cloud Native Buildpacks(../how-to/native-image/developing-your-first-application.html#howto.native-image.developing-your-first-application.buildpacks.maven) or Native Image Build Tools(../how-to/native-image/developing-your-first-application.html#howto.native-image.developing-your-first-application.native-build-tools.maven) . To use the native profile with a multi-modules project, you can create a customization of the native profile so that it invokes your preferred technique. To bind Cloud Native Buildpacks during the package phase, add the following to the root POM of your multi-modules project: <profile> <id>native</id> <build> <pluginManagement> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>build-image</id> <goals> <goal>build-image-no-fork</goal> </goals> </execution> </executions> </plugin> </plugins> </pluginManagement> </build> </profile> The example below does the same for Native Build Tools: <profile> <id>native</id> <build> <pluginManagement> <plugins> <plugin> <groupId>org.graalvm.buildtools</groupId> <artifactId>native-maven-plugin</artifactId> <executions> <execution> <id>build-image</id> <goals> <goal>compile-no-fork</goal> </goals> </execution> </executions> </plugin> </plugins> </pluginManagement> </build> </profile> Once the above is in place, you can build your multi-modules project and generate a native image in the relevant sub-modules, as shown in the following example: $ mvn package -Pnative A ""relevant"" sub-module is a module that represents a Spring Boot application. Such module must define the Native Build Tools and Spring Boot plugins as described above. spring-boot:process-aot: org.springframework.boot:spring-boot-maven-plugin:3.3.4 Invoke the AOT engine on the application. Required parameters: Name Type Default classesDirectory(#aot.process-aot-goal.parameter-details.classes-directory) File ${project.build.outputDirectory} generatedClasses(#aot.process-aot-goal.parameter-details.generated-classes) File ${project.build.directory}/spring-aot/main/classes generatedResources(#aot.process-aot-goal.parameter-details.generated-resources) File ${project.build.directory}/spring-aot/main/resources generatedSources(#aot.process-aot-goal.parameter-details.generated-sources) File ${project.build.directory}/spring-aot/main/sources Optional parameters: Name Type Default arguments(#aot.process-aot-goal.parameter-details.arguments) String[] compilerArguments(#aot.process-aot-goal.parameter-details.compiler-arguments) String excludeGroupIds(#aot.process-aot-goal.parameter-details.exclude-group-ids) String excludes(#aot.process-aot-goal.parameter-details.excludes) List includes(#aot.process-aot-goal.parameter-details.includes) List jvmArguments(#aot.process-aot-goal.parameter-details.jvm-arguments) String mainClass(#aot.process-aot-goal.parameter-details.main-class) String profiles(#aot.process-aot-goal.parameter-details.profiles) String[] skip(#aot.process-aot-goal.parameter-details.skip) boolean false systemPropertyVariables(#aot.process-aot-goal.parameter-details.system-property-variables) Map Parameter details: arguments: Application arguments that should be taken into account for AOT processing. Name arguments Type java.lang.String[] Default value User property Since classesDirectory: Directory containing the classes and resource files that should be packaged into the archive. Name classesDirectory Type java.io.File Default value ${project.build.outputDirectory} User property Since compilerArguments: Arguments that should be provided to the AOT compile process. On command line, make sure to wrap multiple values between quotes. Name compilerArguments Type java.lang.String Default value User property spring-boot.aot.compilerArguments Since excludeGroupIds: Comma separated list of groupId names to exclude (exact match). Name excludeGroupIds Type java.lang.String Default value User property spring-boot.excludeGroupIds Since 1.1.0 excludes: Collection of artifact definitions to exclude. The Exclude element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name excludes Type java.util.List Default value User property spring-boot.excludes Since 1.1.0 generatedClasses: Directory containing the generated classes. Name generatedClasses Type java.io.File Default value ${project.build.directory}/spring-aot/main/classes User property Since generatedResources: Directory containing the generated resources. Name generatedResources Type java.io.File Default value ${project.build.directory}/spring-aot/main/resources User property Since generatedSources: Directory containing the generated sources. Name generatedSources Type java.io.File Default value ${project.build.directory}/spring-aot/main/sources User property Since includes: Collection of artifact definitions to include. The Include element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name includes Type java.util.List Default value User property spring-boot.includes Since 1.2.0 jvmArguments: JVM arguments that should be associated with the AOT process. On command line, make sure to wrap multiple values between quotes. Name jvmArguments Type java.lang.String Default value User property spring-boot.aot.jvmArguments Since mainClass: Name of the main class to use as the source for the AOT process. If not specified the first compiled class found that contains a 'main' method will be used. Name mainClass Type java.lang.String Default value User property spring-boot.aot.main-class Since profiles: Spring profiles to take into account for AOT processing. Name profiles Type java.lang.String[] Default value User property Since skip: Skip the execution. Name skip Type boolean Default value false User property spring-boot.aot.skip Since systemPropertyVariables: List of JVM system properties to pass to the AOT process. Name systemPropertyVariables Type java.util.Map Default value User property Since Processing Tests: The AOT engine can be applied to JUnit 5 tests that use Spring’s Test Context Framework. Suitable tests are processed by the AOT engine in order to generate ApplicationContextInitializer code. To configure your application to use this feature, add an execution for the process-test-aot goal, as shown in the following example: <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>process-test-aot</id> <goals> <goal>process-test-aot</goal> </goals> </execution> </executions> </plugin> If you are using spring-boot-starter-parent , this execution is automatically configured if you enable the nativeTest profile. As with application AOT processing, the BeanFactory is fully prepared at build-time. spring-boot:process-test-aot: org.springframework.boot:spring-boot-maven-plugin:3.3.4 Invoke the AOT engine on tests. Required parameters: Name Type Default classesDirectory(#aot.process-test-aot-goal.parameter-details.classes-directory) File ${project.build.outputDirectory} generatedClasses(#aot.process-test-aot-goal.parameter-details.generated-classes) File ${project.build.directory}/spring-aot/main/classes generatedResources(#aot.process-test-aot-goal.parameter-details.generated-resources) File ${project.build.directory}/spring-aot/test/resources generatedSources(#aot.process-test-aot-goal.parameter-details.generated-sources) File ${project.build.directory}/spring-aot/test/sources generatedTestClasses(#aot.process-test-aot-goal.parameter-details.generated-test-classes) File ${project.build.directory}/spring-aot/test/classes testClassesDirectory(#aot.process-test-aot-goal.parameter-details.test-classes-directory) File ${project.build.testOutputDirectory} Optional parameters: Name Type Default compilerArguments(#aot.process-test-aot-goal.parameter-details.compiler-arguments) String excludeGroupIds(#aot.process-test-aot-goal.parameter-details.exclude-group-ids) String excludes(#aot.process-test-aot-goal.parameter-details.excludes) List includes(#aot.process-test-aot-goal.parameter-details.includes) List jvmArguments(#aot.process-test-aot-goal.parameter-details.jvm-arguments) String skip(#aot.process-test-aot-goal.parameter-details.skip) boolean false systemPropertyVariables(#aot.process-test-aot-goal.parameter-details.system-property-variables) Map Parameter details: classesDirectory: Directory containing the classes and resource files that should be used to run the tests. Name classesDirectory Type java.io.File Default value ${project.build.outputDirectory} User property Since compilerArguments: Arguments that should be provided to the AOT compile process. On command line, make sure to wrap multiple values between quotes. Name compilerArguments Type java.lang.String Default value User property spring-boot.aot.compilerArguments Since excludeGroupIds: Comma separated list of groupId names to exclude (exact match). Name excludeGroupIds Type java.lang.String Default value User property spring-boot.excludeGroupIds Since 1.1.0 excludes: Collection of artifact definitions to exclude. The Exclude element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name excludes Type java.util.List Default value User property spring-boot.excludes Since 1.1.0 generatedClasses: Directory containing the generated test classes. Name generatedClasses Type java.io.File Default value ${project.build.directory}/spring-aot/main/classes User property Since generatedResources: Directory containing the generated test resources. Name generatedResources Type java.io.File Default value ${project.build.directory}/spring-aot/test/resources User property Since generatedSources: Directory containing the generated sources. Name generatedSources Type java.io.File Default value ${project.build.directory}/spring-aot/test/sources User property Since generatedTestClasses: Directory containing the generated test classes. Name generatedTestClasses Type java.io.File Default value ${project.build.directory}/spring-aot/test/classes User property Since includes: Collection of artifact definitions to include. The Include element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name includes Type java.util.List Default value User property spring-boot.includes Since 1.2.0 jvmArguments: JVM arguments that should be associated with the AOT process. On command line, make sure to wrap multiple values between quotes. Name jvmArguments Type java.lang.String Default value User property spring-boot.aot.jvmArguments Since skip: Skip the execution. Name skip Type boolean Default value false User property spring-boot.aot.skip Since systemPropertyVariables: List of JVM system properties to pass to the AOT process. Name systemPropertyVariables Type java.util.Map Default value User property Since testClassesDirectory: Directory containing the classes and resource files that should be packaged into the archive. Name testClassesDirectory Type java.io.File Default value ${project.build.testOutputDirectory} User property Since"
"https://docs.spring.io/spring-boot/maven-plugin/integration-tests.html","Running Integration Tests: While you may start your Spring Boot application very easily from your test (or test suite) itself, it may be desirable to handle that in the build itself. To make sure that the lifecycle of your Spring Boot application is properly managed around your integration tests, you can use the start and stop goals, as shown in the following example: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>pre-integration-test</id> <goals> <goal>start</goal> </goals> </execution> <execution> <id>post-integration-test</id> <goals> <goal>stop</goal> </goals> </execution> </executions> </plugin> </plugins> </build> Such setup can now use the failsafe-plugin(https://maven.apache.org/surefire/maven-failsafe-plugin) to run your integration tests as you would expect. The application is started in a separate process and JMX is used to communicate with the application. By default, the plugin uses port 9001 . If you need to configure the JMX port, see the dedicated example(#integration-tests.examples.jmx-port) . You could also configure a more advanced setup to skip the integration tests when a specific property has been set, see the dedicated example(#integration-tests.examples.skip) . Using Failsafe Without Spring Boot’s Parent POM: Spring Boot’s Parent POM, spring-boot-starter-parent , configures Failsafe’s <classesDirectory> to be ${project.build.outputDirectory} . Without this configuration, which causes Failsafe to use the compiled classes rather than the repackaged jar, Failsafe cannot load your application’s classes. If you are not using the parent POM, you should configure Failsafe in the same way, as shown in the following example: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-failsafe-plugin</artifactId> <configuration> <classesDirectory>${project.build.outputDirectory}</classesDirectory> </configuration> </plugin> spring-boot:start: org.springframework.boot:spring-boot-maven-plugin:3.3.4 Start a spring application. Contrary to the run goal, this does not block and allows other goals to operate on the application. This goal is typically used in integration test scenario where the application is started before a test suite and stopped after. Required parameters: Name Type Default classesDirectory(#integration-tests.start-goal.parameter-details.classes-directory) File ${project.build.outputDirectory} Optional parameters: Name Type Default addResources(#integration-tests.start-goal.parameter-details.add-resources) boolean false additionalClasspathElements(#integration-tests.start-goal.parameter-details.additional-classpath-elements) String[] agents(#integration-tests.start-goal.parameter-details.agents) File[] arguments(#integration-tests.start-goal.parameter-details.arguments) String[] commandlineArguments(#integration-tests.start-goal.parameter-details.commandline-arguments) String directories(#integration-tests.start-goal.parameter-details.directories) String[] environmentVariables(#integration-tests.start-goal.parameter-details.environment-variables) Map excludeGroupIds(#integration-tests.start-goal.parameter-details.exclude-group-ids) String excludes(#integration-tests.start-goal.parameter-details.excludes) List includes(#integration-tests.start-goal.parameter-details.includes) List jmxName(#integration-tests.start-goal.parameter-details.jmx-name) String org.springframework.boot:type=Admin,name=SpringApplication jmxPort(#integration-tests.start-goal.parameter-details.jmx-port) int 9001 jvmArguments(#integration-tests.start-goal.parameter-details.jvm-arguments) String mainClass(#integration-tests.start-goal.parameter-details.main-class) String maxAttempts(#integration-tests.start-goal.parameter-details.max-attempts) int 60 noverify(#integration-tests.start-goal.parameter-details.noverify) boolean profiles(#integration-tests.start-goal.parameter-details.profiles) String[] skip(#integration-tests.start-goal.parameter-details.skip) boolean false systemPropertyVariables(#integration-tests.start-goal.parameter-details.system-property-variables) Map useTestClasspath(#integration-tests.start-goal.parameter-details.use-test-classpath) Boolean false wait(#integration-tests.start-goal.parameter-details.wait) long 500 workingDirectory(#integration-tests.start-goal.parameter-details.working-directory) File Parameter details: addResources: Add maven resources to the classpath directly, this allows live in-place editing of resources. Duplicate resources are removed from target/classes to prevent them from appearing twice if ClassLoader.getResources() is called. Please consider adding spring-boot-devtools to your project instead as it provides this feature and many more. Name addResources Type boolean Default value false User property spring-boot.run.addResources Since 1.0.0 additionalClasspathElements: Additional classpath elements that should be added to the classpath. An element can be a directory with classes and resources or a jar file. Name additionalClasspathElements Type java.lang.String[] Default value User property spring-boot.run.additional-classpath-elements Since 3.2.0 agents: Path to agent jars. Name agents Type java.io.File[] Default value User property spring-boot.run.agents Since 2.2.0 arguments: Arguments that should be passed to the application. Name arguments Type java.lang.String[] Default value User property Since 1.0.0 classesDirectory: Directory containing the classes and resource files that should be used to run the application. Name classesDirectory Type java.io.File Default value ${project.build.outputDirectory} User property Since 1.0.0 commandlineArguments: Arguments from the command line that should be passed to the application. Use spaces to separate multiple arguments and make sure to wrap multiple values between quotes. When specified, takes precedence over #arguments . Name commandlineArguments Type java.lang.String Default value User property spring-boot.run.arguments Since 2.2.3 directories: Additional directories containing classes or resources that should be added to the classpath. Name directories Type java.lang.String[] Default value User property spring-boot.run.directories Since 1.0.0 environmentVariables: List of Environment variables that should be associated with the forked process used to run the application. Name environmentVariables Type java.util.Map Default value User property Since 2.1.0 excludeGroupIds: Comma separated list of groupId names to exclude (exact match). Name excludeGroupIds Type java.lang.String Default value User property spring-boot.excludeGroupIds Since 1.1.0 excludes: Collection of artifact definitions to exclude. The Exclude element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name excludes Type java.util.List Default value User property spring-boot.excludes Since 1.1.0 includes: Collection of artifact definitions to include. The Include element defines mandatory groupId and artifactId components and an optional classifier component. When configured as a property, values should be comma-separated with colon-separated components: groupId:artifactId,groupId:artifactId:classifier Name includes Type java.util.List Default value User property spring-boot.includes Since 1.2.0 jmxName: The JMX name of the automatically deployed MBean managing the lifecycle of the spring application. Name jmxName Type java.lang.String Default value org.springframework.boot:type=Admin,name=SpringApplication User property Since jmxPort: The port to use to expose the platform MBeanServer. Name jmxPort Type int Default value 9001 User property Since jvmArguments: JVM arguments that should be associated with the forked process used to run the application. On command line, make sure to wrap multiple values between quotes. Name jvmArguments Type java.lang.String Default value User property spring-boot.run.jvmArguments Since 1.1.0 mainClass: The name of the main class. If not specified the first compiled class found that contains a 'main' method will be used. Name mainClass Type java.lang.String Default value User property spring-boot.run.main-class Since 1.0.0 maxAttempts: The maximum number of attempts to check if the spring application is ready. Combined with the ""wait"" argument, this gives a global timeout value (30 sec by default) Name maxAttempts Type int Default value 60 User property spring-boot.start.maxAttempts Since noverify: Flag to say that the agent requires -noverify. Name noverify Type boolean Default value User property spring-boot.run.noverify Since 1.0.0 profiles: The spring profiles to activate. Convenience shortcut of specifying the 'spring.profiles.active' argument. On command line use commas to separate multiple profiles. Name profiles Type java.lang.String[] Default value User property spring-boot.run.profiles Since 1.3.0 skip: Skip the execution. Name skip Type boolean Default value false User property spring-boot.run.skip Since 1.3.2 systemPropertyVariables: List of JVM system properties to pass to the process. Name systemPropertyVariables Type java.util.Map Default value User property Since 2.1.0 useTestClasspath: Flag to include the test classpath when running. Name useTestClasspath Type java.lang.Boolean Default value false User property spring-boot.run.useTestClasspath Since wait: The number of milliseconds to wait between each attempt to check if the spring application is ready. Name wait Type long Default value 500 User property spring-boot.start.wait Since workingDirectory: Current working directory to use for the application. If not specified, basedir will be used. Name workingDirectory Type java.io.File Default value User property spring-boot.run.workingDirectory Since 1.5.0 spring-boot:stop: org.springframework.boot:spring-boot-maven-plugin:3.3.4 Stop an application that has been started by the ""start"" goal. Typically invoked once a test suite has completed. Optional parameters: Name Type Default jmxName(#integration-tests.stop-goal.parameter-details.jmx-name) String org.springframework.boot:type=Admin,name=SpringApplication jmxPort(#integration-tests.stop-goal.parameter-details.jmx-port) int 9001 skip(#integration-tests.stop-goal.parameter-details.skip) boolean false Parameter details: jmxName: The JMX name of the automatically deployed MBean managing the lifecycle of the application. Name jmxName Type java.lang.String Default value org.springframework.boot:type=Admin,name=SpringApplication User property Since jmxPort: The port to use to look up the platform MBeanServer. Name jmxPort Type int Default value 9001 User property Since skip: Skip the execution. Name skip Type boolean Default value false User property spring-boot.stop.skip Since 1.3.2 Examples: Random Port for Integration Tests: One nice feature of the Spring Boot test integration is that it can allocate a free port for the web application. When the start goal of the plugin is used, the Spring Boot application is started separately, making it difficult to pass the actual port to the integration test itself. The example below showcases how you could achieve the same feature using the Build Helper Maven Plugin(https://www.mojohaus.org/build-helper-maven-plugin) : <build> <plugins> <plugin> <groupId>org.codehaus.mojo</groupId> <artifactId>build-helper-maven-plugin</artifactId> <executions> <execution> <id>reserve-tomcat-port</id> <goals> <goal>reserve-network-port</goal> </goals> <phase>process-resources</phase> <configuration> <portNames> <portName>tomcat.http.port</portName> </portNames> </configuration> </execution> </executions> </plugin> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>pre-integration-test</id> <goals> <goal>start</goal> </goals> <configuration> <arguments> <argument>--server.port=${tomcat.http.port}</argument> </arguments> </configuration> </execution> <execution> <id>post-integration-test</id> <goals> <goal>stop</goal> </goals> </execution> </executions> </plugin> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-failsafe-plugin</artifactId> <configuration> <systemPropertyVariables> <test.server.port>${tomcat.http.port}</test.server.port> </systemPropertyVariables> </configuration> </plugin> </plugins> </build> You can now retrieve the test.server.port system property in any of your integration test to create a proper URL to the server. Customize JMX Port: The jmxPort property allows to customize the port the plugin uses to communicate with the Spring Boot application. This example shows how you can customize the port in case 9001 is already used: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <jmxPort>9009</jmxPort> </configuration> <executions> <execution> <id>pre-integration-test</id> <goals> <goal>start</goal> </goals> </execution> <execution> <id>post-integration-test</id> <goals> <goal>stop</goal> </goals> </execution> </executions> </plugin> </plugins> </build> If you need to configure the JMX port, make sure to do so in the global configuration as shown above so that it is shared by both goals. Skip Integration Tests: The skip property allows to skip the execution of the Spring Boot maven plugin altogether. This example shows how you can skip integration tests with a command-line property and still make sure that the repackage goal runs: <project> <properties> <skip.it>false</skip.it> </properties> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <id>pre-integration-test</id> <goals> <goal>start</goal> </goals> <configuration> <skip>${skip.it}</skip> </configuration> </execution> <execution> <id>post-integration-test</id> <goals> <goal>stop</goal> </goals> <configuration> <skip>${skip.it}</skip> </configuration> </execution> </executions> </plugin> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-failsafe-plugin</artifactId> <configuration> <skip>${skip.it}</skip> </configuration> </plugin> </plugins> </build> </project> By default, the integration tests will run but this setup allows you to easily disable them on the command-line as follows: $ mvn verify -Dskip.it=true"
"https://docs.spring.io/spring-boot/maven-plugin/build-info.html","Integrating with Actuator: Spring Boot Actuator displays build-related information if a META-INF/build-info.properties file is present. The build-info goal generates such file with the coordinates of the project and the build time. It also allows you to add an arbitrary number of additional properties, as shown in the following example: <project> <modelVersion>4.0.0</modelVersion> <artifactId>build-info</artifactId> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <executions> <execution> <goals> <goal>build-info</goal> </goals> <configuration> <additionalProperties> <encoding.source>UTF-8</encoding.source> <encoding.reporting>UTF-8</encoding.reporting> <java.version>${java.version}</java.version> </additionalProperties> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> This configuration will generate a build-info.properties at the expected location with three additional keys. java.version is expected to be a regular property available in the project. It will be interpolated as you would expect. spring-boot:build-info: org.springframework.boot:spring-boot-maven-plugin:3.3.4 Generate a build-info.properties file based on the content of the current MavenProject . Optional parameters: Name Type Default additionalProperties(#build-info.build-info-goal.parameter-details.additional-properties) Map excludeInfoProperties(#build-info.build-info-goal.parameter-details.exclude-info-properties) List outputFile(#build-info.build-info-goal.parameter-details.output-file) File ${project.build.outputDirectory}/META-INF/build-info.properties skip(#build-info.build-info-goal.parameter-details.skip) boolean false time(#build-info.build-info-goal.parameter-details.time) String ${project.build.outputTimestamp} Parameter details: additionalProperties: Additional properties to store in the build-info.properties file. Each entry is prefixed by build. in the generated build-info.properties . Name additionalProperties Type java.util.Map Default value User property Since excludeInfoProperties: Properties that should be excluded build-info.properties file. Can be used to exclude the standard group , artifact , name , version or time properties as well as items from additionalProperties . Name excludeInfoProperties Type java.util.List Default value User property Since outputFile: The location of the generated build-info.properties file. Name outputFile Type java.io.File Default value ${project.build.outputDirectory}/META-INF/build-info.properties User property Since skip: Skip the execution. Name skip Type boolean Default value false User property spring-boot.build-info.skip Since 3.1.0 time: The value used for the build.time property in a form suitable for Instant#parse(CharSequence) . Defaults to project.build.outputTimestamp or session.request.startTime if the former is not set. To disable the build.time property entirely, use 'off' or add it to excludeInfoProperties . Name time Type java.lang.String Default value ${project.build.outputTimestamp} User property Since 2.2.0"
"https://docs.spring.io/spring-boot/maven-plugin/help.html","Help Information: spring-boot:help: org.springframework.boot:spring-boot-maven-plugin:3.3.4 Display help information on spring-boot-maven-plugin. Call mvn spring-boot:help -Ddetail=true -Dgoal=<goal-name> to display parameter details. Optional parameters: Name Type Default detail(#help.help-goal.parameter-details.detail) boolean false goal(#help.help-goal.parameter-details.goal) String indentSize(#help.help-goal.parameter-details.indent-size) int 2 lineLength(#help.help-goal.parameter-details.line-length) int 80 Parameter details: detail: If true , display all settable properties for each goal. Name detail Type boolean Default value false User property detail Since goal: The name of the goal for which to show help. If unspecified, all goals will be displayed. Name goal Type java.lang.String Default value User property goal Since indentSize: The number of spaces per indentation level, should be positive. Name indentSize Type int Default value 2 User property indentSize Since lineLength: The maximum length of a display line, should be positive. Name lineLength Type int Default value 80 User property lineLength Since"
"https://docs.spring.io/spring-boot/gradle-plugin/index.html","Gradle Plugin: The Spring Boot Gradle Plugin provides Spring Boot support in Gradle(https://gradle.org) . It allows you to package executable jar or war archives, run Spring Boot applications, and use the dependency management provided by spring-boot-dependencies . Spring Boot’s Gradle plugin requires Gradle 7.x (7.5 or later) or 8.x and can be used with Gradle’s configuration cache(https://docs.gradle.org/current/userguide/configuration_cache.html) . In addition to this user guide, API documentation(api/java/index.html) is also available."
"https://docs.spring.io/spring-boot/gradle-plugin/getting-started.html","Getting Started: To get started with the plugin it needs to be applied to your project. The plugin is published to Gradle’s plugin portal(https://plugins.gradle.org/plugin/org.springframework.boot) and can be applied using the plugins block: Groovy Kotlin plugins { id 'org.springframework.boot' version '3.3.4' } plugins { id(""org.springframework.boot"") version ""3.3.4"" } Applied in isolation the plugin makes few changes to a project. Instead, the plugin detects when certain other plugins are applied and reacts accordingly. For example, when the java plugin is applied a task for building an executable jar is automatically configured. A typical Spring Boot project will apply the groovy(https://docs.gradle.org/current/userguide/groovy_plugin.html) , java(https://docs.gradle.org/current/userguide/java_plugin.html) , or org.jetbrains.kotlin.jvm(https://kotlinlang.org/docs/reference/using-gradle.html) plugin as a minimum and also use the io.spring.dependency-management(https://github.com/spring-gradle-plugins/dependency-management-plugin) plugin or Gradle’s native bom support for dependency management. For example: Groovy Kotlin plugins { id 'java' id 'org.springframework.boot' version '3.3.4' } apply plugin: 'io.spring.dependency-management' plugins { java id(""org.springframework.boot"") version ""3.3.4"" } apply(plugin = ""io.spring.dependency-management"") To learn more about how the Spring Boot plugin behaves when other plugins are applied please see the section on reacting to other plugins(reacting.html) ."
"https://docs.spring.io/spring-boot/gradle-plugin/managing-dependencies.html","Managing Dependencies: To manage dependencies in your Spring Boot application, you can either apply the io.spring.dependency-management(https://github.com/spring-gradle-plugins/dependency-management-plugin) plugin or use Gradle’s native bom support. The primary benefit of the former is that it offers property-based customization of managed versions, while using the latter will likely result in faster builds. Managing Dependencies with the Dependency Management Plugin: When you apply the io.spring.dependency-management(https://github.com/spring-gradle-plugins/dependency-management-plugin) plugin, Spring Boot’s plugin will automatically import the spring-boot-dependencies bom(reacting.html#reacting-to-other-plugins.dependency-management) from the version of Spring Boot that you are using. This provides a similar dependency management experience to the one that’s enjoyed by Maven users. For example, it allows you to omit version numbers when declaring dependencies that are managed in the bom. To make use of this functionality, declare dependencies in the usual way but omit the version number: Groovy Kotlin dependencies { implementation('org.springframework.boot:spring-boot-starter-web') implementation('org.springframework.boot:spring-boot-starter-data-jpa') } dependencies { implementation(""org.springframework.boot:spring-boot-starter-web"") implementation(""org.springframework.boot:spring-boot-starter-data-jpa"") } Customizing Managed Versions: The spring-boot-dependencies bom that is automatically imported when the dependency management plugin is applied uses properties to control the versions of the dependencies that it manages. Browse the Dependency Versions Properties(../appendix/dependency-versions/properties.html) section in the Spring Boot reference for a complete list of these properties. To customize a managed version you set its corresponding property. For example, to customize the version of SLF4J which is controlled by the slf4j.version property: Groovy Kotlin ext['slf4j.version'] = '1.7.20' extra[""slf4j.version""] = ""1.7.20"" Each Spring Boot release is designed and tested against a specific set of third-party dependencies. Overriding versions may cause compatibility issues and should be done with care. Using Spring Boot’s Dependency Management in Isolation: Spring Boot’s dependency management can be used in a project without applying Spring Boot’s plugin to that project. The SpringBootPlugin class provides a BOM_COORDINATES constant that can be used to import the bom without having to know its group ID, artifact ID, or version. First, configure the project to depend on the Spring Boot plugin but do not apply it: Groovy Kotlin plugins { id 'org.springframework.boot' version '3.3.4' apply false } plugins { id(""org.springframework.boot"") version ""3.3.4"" apply false } The Spring Boot plugin’s dependency on the dependency management plugin means that you can use the dependency management plugin without having to declare a dependency on it. This also means that you will automatically use the same version of the dependency management plugin as Spring Boot uses. Apply the dependency management plugin and then configure it to import Spring Boot’s bom: Groovy Kotlin apply plugin: 'io.spring.dependency-management' dependencyManagement { imports { mavenBom org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES } } apply(plugin = ""io.spring.dependency-management"") the<DependencyManagementExtension>().apply { imports { mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES) } } The Kotlin code above is a bit awkward. That’s because we’re using the imperative way of applying the dependency management plugin. We can make the code less awkward by applying the plugin from the root parent project, or by using the plugins block as we’re doing for the Spring Boot plugin. A downside of this method is that it forces us to specify the version of the dependency management plugin: plugins { java id(""org.springframework.boot"") version ""3.3.4"" apply false id(""io.spring.dependency-management"") version ""1.1.6"" } dependencyManagement { imports { mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES) } } Learning More: To learn more about the capabilities of the dependency management plugin, please refer to its documentation(https://docs.spring.io/dependency-management-plugin/docs/1.1.6/reference/html/) . Managing Dependencies with Gradle’s Bom Support: Gradle allows a bom to be used to manage a project’s versions by declaring it as a platform or enforcedPlatform dependency. A platform dependency treats the versions in the bom as recommendations and other versions and constraints in the dependency graph may cause a version of a dependency other than that declared in the bom to be used. An enforcedPlatform dependency treats the versions in the bom as requirements and they will override any other version found in the dependency graph. The SpringBootPlugin class provides a BOM_COORDINATES constant that can be used to declare a dependency upon Spring Boot’s bom without having to know its group ID, artifact ID, or version, as shown in the following example: Groovy Kotlin dependencies { implementation platform(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES) } dependencies { implementation(platform(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES)) } A platform or enforced platform will only constrain the versions of the configuration in which it has been declared or that extend from the configuration in which it has been declared. As a result, in may be necessary to declare the same dependency in more than one configuration. Customizing Managed Versions: When using Gradle’s bom support, you cannot use the properties from spring-boot-dependencies to control the versions of the dependencies that it manages. Instead, you must use one of the mechanisms that Gradle provides. One such mechanism is a resolution strategy. SLF4J’s modules are all in the org.slf4j group so their version can be controlled by configuring every dependency in that group to use a particular version, as shown in the following example: Groovy Kotlin configurations.all { resolutionStrategy.eachDependency { DependencyResolveDetails details -> if (details.requested.group == 'org.slf4j') { details.useVersion '1.7.20' } } } configurations.all { resolutionStrategy.eachDependency { if (requested.group == ""org.slf4j"") { useVersion(""1.7.20"") } } } Each Spring Boot release is designed and tested against a specific set of third-party dependencies. Overriding versions may cause compatibility issues and should be done with care."
"https://docs.spring.io/spring-boot/gradle-plugin/packaging.html","Packaging Executable Archives: The plugin can create executable archives (jar files and war files) that contain all of an application’s dependencies and can then be run with java -jar . Packaging Executable Jars: Executable jars can be built using the bootJar task. The task is automatically created when the java plugin is applied and is an instance of BootJar(api/java/org/springframework/boot/gradle/tasks/bundling/BootJar.html) . The assemble task is automatically configured to depend upon the bootJar task so running assemble (or build ) will also run the bootJar task. Packaging Executable Wars: Executable wars can be built using the bootWar task. The task is automatically created when the war plugin is applied and is an instance of BootWar(api/java/org/springframework/boot/gradle/tasks/bundling/BootWar.html) . The assemble task is automatically configured to depend upon the bootWar task so running assemble (or build ) will also run the bootWar task. Packaging Executable and Deployable Wars: A war file can be packaged such that it can be executed using java -jar and deployed to an external container. To do so, the embedded servlet container dependencies should be added to the providedRuntime configuration, for example: Groovy Kotlin dependencies { implementation('org.springframework.boot:spring-boot-starter-web') providedRuntime('org.springframework.boot:spring-boot-starter-tomcat') } dependencies { implementation(""org.springframework.boot:spring-boot-starter-web"") providedRuntime(""org.springframework.boot:spring-boot-starter-tomcat"") } This ensures that they are package in the war file’s WEB-INF/lib-provided directory from where they will not conflict with the external container’s own classes. providedRuntime is preferred to Gradle’s compileOnly configuration as, among other limitations, compileOnly dependencies are not on the test classpath so any web-based integration tests will fail. Packaging Executable and Plain Archives: By default, when the bootJar or bootWar tasks are configured, the jar or war tasks are configured to use plain as the convention for their archive classifier. This ensures that bootJar and jar or bootWar and war have different output locations, allowing both the executable archive and the plain archive to be built at the same time. If you prefer that the executable archive, rather than the plain archive, uses a classifier, configure the classifiers as shown in the following example for the jar and bootJar tasks: Groovy Kotlin tasks.named(""bootJar"") { archiveClassifier = 'boot' } tasks.named(""jar"") { archiveClassifier = '' } tasks.named<BootJar>(""bootJar"") { archiveClassifier.set(""boot"") } tasks.named<Jar>(""jar"") { archiveClassifier.set("""") } Alternatively, if you prefer that the plain archive isn’t built at all, disable its task as shown in the following example for the jar task: Groovy Kotlin tasks.named(""jar"") { enabled = false } tasks.named<Jar>(""jar"") { enabled = false } Do not disable the jar task when creating native images. See #33238(https://github.com/spring-projects/spring-boot/issues/33238) for details. Configuring Executable Archive Packaging: The BootJar(api/java/org/springframework/boot/gradle/tasks/bundling/BootJar.html) and BootWar(api/java/org/springframework/boot/gradle/tasks/bundling/BootWar.html) tasks are subclasses of Gradle’s Jar and War tasks respectively. As a result, all of the standard configuration options that are available when packaging a jar or war are also available when packaging an executable jar or war. A number of configuration options that are specific to executable jars and wars are also provided. Configuring the Main Class: By default, the executable archive’s main class will be configured automatically by looking for a class with a public static void main(String[]) method in the main source set’s output. The main class can also be configured explicitly using the task’s mainClass property: Groovy Kotlin tasks.named(""bootJar"") { mainClass = 'com.example.ExampleApplication' } tasks.named<BootJar>(""bootJar"") { mainClass.set(""com.example.ExampleApplication"") } Alternatively, the main class name can be configured project-wide using the mainClass property of the Spring Boot DSL: Groovy Kotlin springBoot { mainClass = 'com.example.ExampleApplication' } springBoot { mainClass.set(""com.example.ExampleApplication"") } If the application plugin(https://docs.gradle.org/current/userguide/application_plugin.html) has been applied its mainClass property must be configured and can be used for the same purpose: Groovy Kotlin application { mainClass = 'com.example.ExampleApplication' } application { mainClass.set(""com.example.ExampleApplication"") } Lastly, the Start-Class attribute can be configured on the task’s manifest: Groovy Kotlin tasks.named(""bootJar"") { manifest { attributes 'Start-Class': 'com.example.ExampleApplication' } } tasks.named<BootJar>(""bootJar"") { manifest { attributes(""Start-Class"" to ""com.example.ExampleApplication"") } } If the main class is written in Kotlin, the name of the generated Java class should be used. By default, this is the name of the Kotlin class with the Kt suffix added. For example, ExampleApplication becomes ExampleApplicationKt . If another name is defined using @JvmName then that name should be used. Including Development-only Dependencies: By default all dependencies declared in the developmentOnly configuration will be excluded from an executable jar or war. If you want to include dependencies declared in the developmentOnly configuration in your archive, configure the classpath of its task to include the configuration, as shown in the following example for the bootWar task: Groovy Kotlin tasks.named(""bootWar"") { classpath configurations.developmentOnly } tasks.named<BootWar>(""bootWar"") { classpath(configurations[""developmentOnly""]) } Configuring Libraries that Require Unpacking: Most libraries can be used directly when nested in an executable archive, however certain libraries can have problems. For example, JRuby includes its own nested jar support which assumes that jruby-complete.jar is always directly available on the file system. To deal with any problematic libraries, an executable archive can be configured to unpack specific nested jars to a temporary directory when the executable archive is run. Libraries can be identified as requiring unpacking using Ant-style patterns that match against the absolute path of the source jar file: Groovy Kotlin tasks.named(""bootJar"") { requiresUnpack '**/jruby-complete-*.jar' } tasks.named<BootJar>(""bootJar"") { requiresUnpack(""**/jruby-complete-*.jar"") } For more control a closure can also be used. The closure is passed a FileTreeElement and should return a boolean indicating whether or not unpacking is required. Making an Archive Fully Executable: Spring Boot provides support for fully executable archives. An archive is made fully executable by prepending a shell script that knows how to launch the application. On Unix-like platforms, this launch script allows the archive to be run directly like any other executable or to be installed as a service. Currently, some tools do not accept this format so you may not always be able to use this technique. For example, jar -xf may silently fail to extract a jar or war that has been made fully-executable. It is recommended that you only enable this option if you intend to execute it directly, rather than running it with java -jar or deploying it to a servlet container. To use this feature, the inclusion of the launch script must be enabled: Groovy Kotlin tasks.named(""bootJar"") { launchScript() } tasks.named<BootJar>(""bootJar"") { launchScript() } This will add Spring Boot’s default launch script to the archive. The default launch script includes several properties with sensible default values. The values can be customized using the properties property: Groovy Kotlin tasks.named(""bootJar"") { launchScript { properties 'logFilename': 'example-app.log' } } tasks.named<BootJar>(""bootJar"") { launchScript { properties(mapOf(""logFilename"" to ""example-app.log"")) } } If the default launch script does not meet your needs, the script property can be used to provide a custom launch script: Groovy Kotlin tasks.named(""bootJar"") { launchScript { script = file('src/custom.script') } } tasks.named<BootJar>(""bootJar"") { launchScript { script = file(""src/custom.script"") } } Using the PropertiesLauncher: To use the PropertiesLauncher to launch an executable jar or war, configure the task’s manifest to set the Main-Class attribute: Groovy Kotlin tasks.named(""bootWar"") { manifest { attributes 'Main-Class': 'org.springframework.boot.loader.launch.PropertiesLauncher' } } tasks.named<BootWar>(""bootWar"") { manifest { attributes(""Main-Class"" to ""org.springframework.boot.loader.launch.PropertiesLauncher"") } } Packaging Layered Jar or War: By default, the bootJar task builds an archive that contains the application’s classes and dependencies in BOOT-INF/classes and BOOT-INF/lib respectively. Similarly, bootWar builds an archive that contains the application’s classes in WEB-INF/classes and dependencies in WEB-INF/lib and WEB-INF/lib-provided . For cases where a docker image needs to be built from the contents of the jar, it’s useful to be able to separate these directories further so that they can be written into distinct layers. Layered jars use the same layout as regular boot packaged jars, but include an additional meta-data file that describes each layer. By default, the following layers are defined: dependencies for any non-project dependency whose version does not contain SNAPSHOT . spring-boot-loader for the jar loader classes. snapshot-dependencies for any non-project dependency whose version contains SNAPSHOT . application for project dependencies, application classes, and resources. The layers order is important as it determines how likely previous layers can be cached when part of the application changes. The default order is dependencies , spring-boot-loader , snapshot-dependencies , application . Content that is least likely to change should be added first, followed by layers that are more likely to change. To disable this feature, you can do so in the following manner: Groovy Kotlin tasks.named(""bootJar"") { layered { enabled = false } } tasks.named<BootJar>(""bootJar"") { layered { enabled.set(false) } } When a layered jar or war is created, the spring-boot-jarmode-tools jar will be added as a dependency to your archive. With this jar on the classpath, you can launch your application in a special mode which allows the bootstrap code to run something entirely different from your application, for example, something that extracts the layers. If you wish to exclude this dependency, you can do so in the following manner: Groovy Kotlin tasks.named(""bootJar"") { includeTools = false } tasks.named<BootJar>(""bootJar"") { includeTools.set(false) } Custom Layers Configuration: Depending on your application, you may want to tune how layers are created and add new ones. This can be done using configuration that describes how the jar or war can be separated into layers, and the order of those layers. The following example shows how the default ordering described above can be defined explicitly: Groovy Kotlin tasks.named(""bootJar"") { layered { application { intoLayer(""spring-boot-loader"") { include ""org/springframework/boot/loader/**"" } intoLayer(""application"") } dependencies { intoLayer(""application"") { includeProjectDependencies() } intoLayer(""snapshot-dependencies"") { include ""*:*:*SNAPSHOT"" } intoLayer(""dependencies"") } layerOrder = [""dependencies"", ""spring-boot-loader"", ""snapshot-dependencies"", ""application""] } } tasks.named<BootJar>(""bootJar"") { layered { application { intoLayer(""spring-boot-loader"") { include(""org/springframework/boot/loader/**"") } intoLayer(""application"") } dependencies { intoLayer(""application"") { includeProjectDependencies() } intoLayer(""snapshot-dependencies"") { include(""*:*:*SNAPSHOT"") } intoLayer(""dependencies"") } layerOrder.set(listOf(""dependencies"", ""spring-boot-loader"", ""snapshot-dependencies"", ""application"")) } } The layered DSL is defined using three parts: The application closure defines how the application classes and resources should be layered. The dependencies closure defines how dependencies should be layered. The layerOrder method defines the order that the layers should be written. Nested intoLayer closures are used within application and dependencies sections to claim content for a layer. These closures are evaluated in the order that they are defined, from top to bottom. Any content not claimed by an earlier intoLayer closure remains available for subsequent ones to consider. The intoLayer closure claims content using nested include and exclude calls. The application closure uses Ant-style path matching for include/exclude parameters. The dependencies section uses group:artifact[:version] patterns. It also provides includeProjectDependencies() and excludeProjectDependencies() methods that can be used to include or exclude project dependencies. If no include call is made, then all content (not claimed by an earlier closure) is considered. If no exclude call is made, then no exclusions are applied. Looking at the dependencies closure in the example above, we can see that the first intoLayer will claim all project dependencies for the application layer. The next intoLayer will claim all SNAPSHOT dependencies for the snapshot-dependencies layer. The third and final intoLayer will claim anything left (in this case, any dependency that is not a project dependency or a SNAPSHOT) for the dependencies layer. The application closure has similar rules. First claiming org/springframework/boot/loader/** content for the spring-boot-loader layer. Then claiming any remaining classes and resources for the application layer. The order that intoLayer closures are added is often different from the order that the layers are written. For this reason the layerOrder method must always be called and must cover all layers referenced by the intoLayer calls."
"https://docs.spring.io/spring-boot/gradle-plugin/packaging-oci-image.html","Packaging OCI Images: The plugin can create an OCI image(https://github.com/opencontainers/image-spec) from a jar or war file using Cloud Native Buildpacks(https://buildpacks.io) (CNB). Images can be built using the bootBuildImage task. For security reasons, images build and run as non-root users. See the CNB specification(https://buildpacks.io/docs/reference/spec/platform-api/#users) for more details. The task is automatically created when the java or war plugin is applied and is an instance of BootBuildImage(api/java/org/springframework/boot/gradle/tasks/bundling/BootBuildImage.html) . Docker Daemon: The bootBuildImage task requires access to a Docker daemon. The task will inspect local Docker CLI configuration files(https://docs.docker.com/engine/reference/commandline/cli/#configuration-files) to determine the current context(https://docs.docker.com/engine/context/working-with-contexts/) and use the context connection information to communicate with a Docker daemon. If the current context can not be determined or the context does not have connection information, then the task will use a default local connection. This works with Docker Engine(https://docs.docker.com/install/) on all supported platforms without configuration. Environment variables can be set to configure the bootBuildImage task to use an alternative local or remote connection. The following table shows the environment variables and their values: Environment variable Description DOCKER_CONFIG Location of Docker CLI configuration files(https://docs.docker.com/engine/reference/commandline/cli/#configuration-files) used to determine the current context (defaults to $HOME/.docker ) DOCKER_CONTEXT Name of a context(https://docs.docker.com/engine/context/working-with-contexts/) that should be used to retrieve host information from Docker CLI configuration files (overrides DOCKER_HOST ) DOCKER_HOST URL containing the host and port for the Docker daemon - for example tcp://192.168.99.100:2376 DOCKER_TLS_VERIFY Enable secure HTTPS protocol when set to 1 (optional) DOCKER_CERT_PATH Path to certificate and key files for HTTPS (required if DOCKER_TLS_VERIFY=1 , ignored otherwise) Docker daemon connection information can also be provided using docker properties in the plugin configuration. The following table summarizes the available properties: Property Description context Name of a context(https://docs.docker.com/engine/context/working-with-contexts/) that should be used to retrieve host information from Docker CLI configuration files(https://docs.docker.com/engine/reference/commandline/cli/#configuration-files) host URL containing the host and port for the Docker daemon - for example tcp://192.168.99.100:2376 tlsVerify Enable secure HTTPS protocol when set to true (optional) certPath Path to certificate and key files for HTTPS (required if tlsVerify is true , ignored otherwise) bindHostToBuilder When true , the value of the host property will be provided to the container that is created for the CNB builder (optional) For more details, see also examples(#build-image.examples.docker) . Docker Registry: If the Docker images specified by the builder or runImage properties are stored in a private Docker image registry that requires authentication, the authentication credentials can be provided using docker.builderRegistry properties. If the generated Docker image is to be published to a Docker image registry, the authentication credentials can be provided using docker.publishRegistry properties. Properties are provided for user authentication or identity token authentication. Consult the documentation for the Docker registry being used to store images for further information on supported authentication methods. The following table summarizes the available properties for docker.builderRegistry and docker.publishRegistry : Property Description username Username for the Docker image registry user. Required for user authentication. password Password for the Docker image registry user. Required for user authentication. url Address of the Docker image registry. Optional for user authentication. email E-mail address for the Docker image registry user. Optional for user authentication. token Identity token for the Docker image registry user. Required for token authentication. For more details, see also examples(#build-image.examples.docker) . Image Customizations: The plugin invokes a builder(https://buildpacks.io/docs/concepts/components/builder/) to orchestrate the generation of an image. The builder includes multiple buildpacks(https://buildpacks.io/docs/concepts/components/buildpack) that can inspect the application to influence the generated image. By default, the plugin chooses a builder image. The name of the generated image is deduced from project properties. Task properties can be used to configure how the builder should operate on the project. The following table summarizes the available properties and their default values: Property Command-line option Description Default value builder --builder Name of the Builder image to use. paketobuildpacks/builder-jammy-base:latest or paketobuildpacks/builder-jammy-tiny:latest when GraalVM Native Image plugin(https://graalvm.github.io/native-build-tools/0.10.3/gradle-plugin.html) is applied. runImage --runImage Name of the run image to use. No default value, indicating the run image specified in Builder metadata should be used. imageName --imageName Image name(../api/java/org/springframework/boot/buildpack/platform/docker/type/ImageReference.html#of-java.lang.String-) for the generated image. docker.io/library/${project.name}:${project.version} pullPolicy --pullPolicy Policy(../api/java/org/springframework/boot/buildpack/platform/build/PullPolicy.html) used to determine when to pull the builder and run images from the registry. Acceptable values are ALWAYS , NEVER , and IF_NOT_PRESENT . ALWAYS environment Environment variables that should be passed to the builder. Empty or ['BP_NATIVE_IMAGE': 'true'] when GraalVM Native Image plugin(https://graalvm.github.io/native-build-tools/0.10.3/gradle-plugin.html) is applied. buildpacks Buildpacks that the builder should use when building the image. Only the specified buildpacks will be used, overriding the default buildpacks included in the builder. Buildpack references must be in one of the following forms: Buildpack in the builder - [urn:cnb:builder:]<buildpack ID>[@<version>] Buildpack in a directory on the file system - [file://]<path> Buildpack in a gzipped tar (.tgz) file on the file system - [file://]<path>/<file name> Buildpack in an OCI image - [docker://]<host>/<repo>[:<tag>][@<digest>] None, indicating the builder should use the buildpacks included in it. bindings Volume bind mounts(https://docs.docker.com/storage/bind-mounts/) that should be mounted to the builder container when building the image. The bindings will be passed unparsed and unvalidated to Docker when creating the builder container. Bindings must be in one of the following forms: <host source path>:<container destination path>[:<options>] <host volume name>:<container destination path>[:<options>] Where <options> can contain: ro to mount the volume as read-only in the container rw to mount the volume as readable and writable in the container volume-opt=key=value to specify key-value pairs consisting of an option name and its value network --network The network driver(https://docs.docker.com/network/#network-drivers) the builder container will be configured to use. The value supplied will be passed unvalidated to Docker when creating the builder container. cleanCache --cleanCache Whether to clean the cache before building. false verboseLogging Enables verbose logging of builder operations. false publish --publishImage Whether to publish the generated image to a Docker registry. false tags A list of one or more additional tags to apply to the generated image. The values provided to the tags option should be full image references. See the tags section(#build-image.customization.tags) for more details. buildWorkspace A temporary workspace that will be used by the builder and buildpacks to store files during image building. The value can be a named volume or a bind mount location. A named volume in the Docker daemon, with a name derived from the image name. buildCache A cache containing layers created by buildpacks and used by the image building process. The value can be a named volume or a bind mount location. A named volume in the Docker daemon, with a name derived from the image name. launchCache A cache containing layers created by buildpacks and used by the image launching process. The value can be a named volume or a bind mount location. A named volume in the Docker daemon, with a name derived from the image name. createdDate --createdDate A date that will be used to set the Created field in the generated image’s metadata. The value must be a string in the ISO 8601 instant format, or now to use the current date and time. A fixed date that enables build reproducibility(https://buildpacks.io/docs/features/reproducibility/) . applicationDirectory --applicationDirectory The path to a directory that application contents will be uploaded to in the builder image. Application contents will also be in this location in the generated image. /workspace securityOptions --securityOptions Security options(https://docs.docker.com/engine/reference/run/#security-configuration) that will be applied to the builder container, provided as an array of string values [""label=disable""] on Linux and macOS, [] on Windows The plugin detects the target Java compatibility of the project using the JavaPlugin’s targetCompatibility property. When using the default Paketo builder and buildpacks, the plugin instructs the buildpacks to install the same Java version. You can override this behaviour as shown in the builder configuration(#build-image.examples.builder-configuration) examples. Tags Format: The values provided to the tags option should be full image references. The accepted format is [domainHost:port/][path/]name[:tag][@digest] . If the domain is missing, it defaults to docker.io . If the path is missing, it defaults to library . If the tag is missing, it defaults to latest . Some examples: my-image leads to the image reference docker.io/library/my-image:latest my-repository/my-image leads to docker.io/my-repository/my-image:latest example.com/my-repository/my-image:1.0.0 will be used as is Examples: Custom Image Builder and Run Image: If you need to customize the builder used to create the image or the run image used to launch the built image, configure the task as shown in the following example: Groovy Kotlin tasks.named(""bootBuildImage"") { builder = ""mine/java-cnb-builder"" runImage = ""mine/java-cnb-run"" } tasks.named<BootBuildImage>(""bootBuildImage"") { builder.set(""mine/java-cnb-builder"") runImage.set(""mine/java-cnb-run"") } This configuration will use a builder image with the name mine/java-cnb-builder and the tag latest , and the run image named mine/java-cnb-run and the tag latest . The builder and run image can be specified on the command line as well, as shown in this example: $ gradle bootBuildImage --builder=mine/java-cnb-builder --runImage=mine/java-cnb-run Builder Configuration: If the builder exposes configuration options, those can be set using the environment property. The following is an example of configuring the JVM version(https://paketo.io/docs/buildpacks/language-family-buildpacks/java/#configuring-the-jvm-version) used by the Paketo Java buildpacks at build time: Groovy Kotlin tasks.named(""bootBuildImage"") { environment[""BP_JVM_VERSION""] = ""17"" } tasks.named<BootBuildImage>(""bootBuildImage"") { environment.put(""BP_JVM_VERSION"", ""17"") } If there is a network proxy between the Docker daemon the builder runs in and network locations that buildpacks download artifacts from, you will need to configure the builder to use the proxy. When using the Paketo builder, this can be accomplished by setting the HTTPS_PROXY and/or HTTP_PROXY environment variables as show in the following example: Groovy Kotlin tasks.named(""bootBuildImage"") { environment[""HTTP_PROXY""] = ""http://proxy.example.com"" environment[""HTTPS_PROXY""] = ""https://proxy.example.com"" } tasks.named<BootBuildImage>(""bootBuildImage"") { environment.putAll(mapOf(""HTTP_PROXY"" to ""http://proxy.example.com"", ""HTTPS_PROXY"" to ""https://proxy.example.com"")) } Runtime JVM Configuration: Paketo Java buildpacks configure the JVM runtime environment(https://paketo.io/docs/buildpacks/language-family-buildpacks/java/#runtime-jvm-configuration) by setting the JAVA_TOOL_OPTIONS environment variable. The buildpack-provided JAVA_TOOL_OPTIONS value can be modified to customize JVM runtime behavior when the application image is launched in a container. Environment variable modifications that should be stored in the image and applied to every deployment can be set as described in the Paketo documentation(https://paketo.io/docs/buildpacks/configuration/#environment-variables) and shown in the following example: Groovy Kotlin tasks.named(""bootBuildImage"") { environment[""BPE_DELIM_JAVA_TOOL_OPTIONS""] = "" "" environment[""BPE_APPEND_JAVA_TOOL_OPTIONS""] = ""-XX:+HeapDumpOnOutOfMemoryError"" } tasks.named<BootBuildImage>(""bootBuildImage"") { environment.putAll(mapOf( ""BPE_DELIM_JAVA_TOOL_OPTIONS"" to "" "", ""BPE_APPEND_JAVA_TOOL_OPTIONS"" to ""-XX:+HeapDumpOnOutOfMemoryError"" )) } Custom Image Name: By default, the image name is inferred from the name and the version of the project, something like docker.io/library/${project.name}:${project.version} . You can take control over the name by setting task properties, as shown in the following example: Groovy Kotlin tasks.named(""bootBuildImage"") { imageName = ""example.com/library/${project.name}"" } tasks.named<BootBuildImage>(""bootBuildImage"") { imageName.set(""example.com/library/${project.name}"") } Note that this configuration does not provide an explicit tag so latest is used. It is possible to specify a tag as well, either using ${project.version} , any property available in the build or a hardcoded version. The image name can be specified on the command line as well, as shown in this example: $ gradle bootBuildImage --imageName=example.com/library/my-app:v1 Buildpacks: By default, the builder will use buildpacks included in the builder image and apply them in a pre-defined order. An alternative set of buildpacks can be provided to apply buildpacks that are not included in the builder, or to change the order of included buildpacks. When one or more buildpacks are provided, only the specified buildpacks will be applied. The following example instructs the builder to use a custom buildpack packaged in a .tgz file, followed by a buildpack included in the builder. Groovy Kotlin tasks.named(""bootBuildImage"") { buildpacks = [""file:///path/to/example-buildpack.tgz"", ""urn:cnb:builder:paketo-buildpacks/java""] } tasks.named<BootBuildImage>(""bootBuildImage"") { buildpacks.set(listOf(""file:///path/to/example-buildpack.tgz"", ""urn:cnb:builder:paketo-buildpacks/java"")) } Buildpacks can be specified in any of the forms shown below. A buildpack located in a CNB Builder (version may be omitted if there is only one buildpack in the builder matching the buildpack-id ): urn:cnb:builder:buildpack-id urn:cnb:builder: [email protected](/cdn-cgi/l/email-protection) buildpack-id [email protected](/cdn-cgi/l/email-protection) A path to a directory containing buildpack content (not supported on Windows): file:///path/to/buildpack/ /path/to/buildpack/ A path to a gzipped tar file containing buildpack content: file:///path/to/buildpack.tgz /path/to/buildpack.tgz An OCI image containing a packaged buildpack(https://buildpacks.io/docs/buildpack-author-guide/package-a-buildpack/) : docker://example/buildpack docker:///example/buildpack:latest docker:///example/buildpack@sha256:45b23dee08…​ example/buildpack example/buildpack:latest example/buildpack@sha256:45b23dee08…​ Image Publishing: The generated image can be published to a Docker registry by enabling a publish option. If the Docker registry requires authentication, the credentials can be configured using docker.publishRegistry properties. If the Docker registry does not require authentication, the docker.publishRegistry configuration can be omitted. The registry that the image will be published to is determined by the registry part of the image name ( docker.example.com in these examples). If docker.publishRegistry credentials are configured and include a url property, this value is passed to the registry but is not used to determine the publishing registry location. Groovy Kotlin tasks.named(""bootBuildImage"") { imageName.set(""docker.example.com/library/${project.name}"") publish = true docker { publishRegistry { username = ""user"" password = ""secret"" } } } tasks.named<BootBuildImage>(""bootBuildImage"") { imageName.set(""docker.example.com/library/${project.name}"") publish.set(true) docker { publishRegistry { username.set(""user"") password.set(""secret"") } } } The publish option can be specified on the command line as well, as shown in this example: $ gradle bootBuildImage --imageName=docker.example.com/library/my-app:v1 --publishImage Builder Cache and Workspace Configuration: The CNB builder caches layers that are used when building and launching an image. By default, these caches are stored as named volumes in the Docker daemon with names that are derived from the full name of the target image. If the image name changes frequently, for example when the project version is used as a tag in the image name, then the caches can be invalidated frequently. The cache volumes can be configured to use alternative names to give more control over cache lifecycle as shown in the following example: Groovy Kotlin tasks.named(""bootBuildImage"") { buildCache { volume { name = ""cache-${rootProject.name}.build"" } } launchCache { volume { name = ""cache-${rootProject.name}.launch"" } } } tasks.named<BootBuildImage>(""bootBuildImage"") { buildCache { volume { name.set(""cache-${rootProject.name}.build"") } } launchCache { volume { name.set(""cache-${rootProject.name}.launch"") } } } Builders and buildpacks need a location to store temporary files during image building. By default, this temporary build workspace is stored in a named volume. The caches and the build workspace can be configured to use bind mounts instead of named volumes, as shown in the following example: Groovy Kotlin tasks.named(""bootBuildImage"") { buildWorkspace { bind { source = ""/tmp/cache-${rootProject.name}.work"" } } buildCache { bind { source = ""/tmp/cache-${rootProject.name}.build"" } } launchCache { bind { source = ""/tmp/cache-${rootProject.name}.launch"" } } } tasks.named<BootBuildImage>(""bootBuildImage"") { buildWorkspace { bind { source.set(""/tmp/cache-${rootProject.name}.work"") } } buildCache { bind { source.set(""/tmp/cache-${rootProject.name}.build"") } } launchCache { bind { source.set(""/tmp/cache-${rootProject.name}.launch"") } } } Docker Configuration: Docker Configuration for minikube: The plugin can communicate with the Docker daemon provided by minikube(https://minikube.sigs.k8s.io/docs/tasks/docker_daemon/) instead of the default local connection. On Linux and macOS, environment variables can be set using the command eval $(minikube docker-env) after minikube has been started. The plugin can also be configured to use the minikube daemon by providing connection details similar to those shown in the following example: Groovy Kotlin tasks.named(""bootBuildImage"") { docker { host = ""tcp://192.168.99.100:2376"" tlsVerify = true certPath = ""/home/user/.minikube/certs"" } } tasks.named<BootBuildImage>(""bootBuildImage"") { docker { host.set(""tcp://192.168.99.100:2376"") tlsVerify.set(true) certPath.set(""/home/user/.minikube/certs"") } } Docker Configuration for podman: The plugin can communicate with a podman container engine(https://podman.io/) . The plugin can be configured to use podman local connection by providing connection details similar to those shown in the following example: Groovy Kotlin tasks.named(""bootBuildImage"") { docker { host = ""unix:///run/user/1000/podman/podman.sock"" bindHostToBuilder = true } } tasks.named<BootBuildImage>(""bootBuildImage"") { docker { host.set(""unix:///run/user/1000/podman/podman.sock"") bindHostToBuilder.set(true) } } With the podman CLI installed, the command podman info --format='{{.Host.RemoteSocket.Path}}' can be used to get the value for the docker.host configuration property shown in this example. Docker Configuration for Colima: The plugin can communicate with the Docker daemon provided by Colima(https://github.com/abiosoft/colima) . The DOCKER_HOST environment variable can be set by using the following command: $ export DOCKER_HOST=$(docker context inspect colima -f '{{.Endpoints.docker.Host}}') The plugin can also be configured to use Colima daemon by providing connection details similar to those shown in the following example: Groovy Kotlin tasks.named(""bootBuildImage"") { docker { host = ""unix://${System.properties['user.home']}/.colima/docker.sock"" } } tasks.named<BootBuildImage>(""bootBuildImage"") { docker { host.set(""unix://${System.getProperty(""user.home"")}/.colima/docker.sock"") } } Docker Configuration for Authentication: If the builder or run image are stored in a private Docker registry that supports user authentication, authentication details can be provided using docker.builderRegistry properties as shown in the following example: Groovy Kotlin tasks.named(""bootBuildImage"") { docker { builderRegistry { username = ""user"" password = ""secret"" url = ""https://docker.example.com/v1/"" email = "" [email protected](/cdn-cgi/l/email-protection) "" } } } tasks.named<BootBuildImage>(""bootBuildImage"") { docker { builderRegistry { username.set(""user"") password.set(""secret"") url.set(""https://docker.example.com/v1/"") email.set("" [email protected](/cdn-cgi/l/email-protection) "") } } } If the builder or run image is stored in a private Docker registry that supports token authentication, the token value can be provided using docker.builderRegistry as shown in the following example: Groovy Kotlin tasks.named(""bootBuildImage"") { docker { builderRegistry { token = ""9cbaf023786cd7..."" } } } tasks.named<BootBuildImage>(""bootBuildImage"") { docker { builderRegistry { token.set(""9cbaf023786cd7..."") } } }"
"https://docs.spring.io/spring-boot/gradle-plugin/publishing.html","Publishing your Application: Publishing with the Maven-publish Plugin: To publish your Spring Boot jar or war, add it to the publication using the artifact method on MavenPublication . Pass the task that produces that artifact that you wish to publish to the artifact method. For example, to publish the artifact produced by the default bootJar task: Groovy Kotlin publishing { publications { bootJava(MavenPublication) { artifact tasks.named(""bootJar"") } } repositories { maven { url 'https://repo.example.com' } } } publishing { publications { create<MavenPublication>(""bootJava"") { artifact(tasks.named(""bootJar"")) } } repositories { maven { url = uri(""https://repo.example.com"") } } } Distributing with the Application Plugin: When the application plugin(https://docs.gradle.org/current/userguide/application_plugin.html) is applied a distribution named boot is created. This distribution contains the archive produced by the bootJar or bootWar task and scripts to launch it on Unix-like platforms and Windows. Zip and tar distributions can be built by the bootDistZip and bootDistTar tasks respectively. To use the application plugin, its mainClassName property must be configured with the name of your application’s main class."
"https://docs.spring.io/spring-boot/gradle-plugin/running.html","Running your Application with Gradle: To run your application without first building an archive use the bootRun task: $ ./gradlew bootRun The bootRun task is an instance of BootRun(api/java/org/springframework/boot/gradle/tasks/run/BootRun.html) which is a JavaExec subclass. As such, all of the usual configuration options(https://docs.gradle.org/current/dsl/org.gradle.api.tasks.JavaExec.html) for executing a Java process in Gradle are available to you. The task is automatically configured to use the runtime classpath of the main source set. By default, the main class will be configured automatically by looking for a class with a public static void main(String[]) method in the main source set’s output. The main class can also be configured explicitly using the task’s main property: Groovy Kotlin tasks.named(""bootRun"") { mainClass = 'com.example.ExampleApplication' } tasks.named<BootRun>(""bootRun"") { mainClass.set(""com.example.ExampleApplication"") } Alternatively, the main class name can be configured project-wide using the mainClass property of the Spring Boot DSL: Groovy Kotlin springBoot { mainClass = 'com.example.ExampleApplication' } springBoot { mainClass.set(""com.example.ExampleApplication"") } By default, bootRun will configure the JVM to optimize its launch for faster startup during development. This behavior can be disabled by using the optimizedLaunch property, as shown in the following example: Groovy Kotlin tasks.named(""bootRun"") { optimizedLaunch = false } tasks.named<BootRun>(""bootRun"") { optimizedLaunch.set(false) } If the application plugin(https://docs.gradle.org/current/userguide/application_plugin.html) has been applied, its mainClass property must be configured and can be used for the same purpose: Groovy Kotlin application { mainClass = 'com.example.ExampleApplication' } application { mainClass.set(""com.example.ExampleApplication"") } Passing Arguments to Your Application: Like all JavaExec tasks, arguments can be passed into bootRun from the command line using --args='<arguments>' when using Gradle 4.9 or later. For example, to run your application with a profile named dev active the following command can be used: $ ./gradlew bootRun --args='--spring.profiles.active=dev' See the javadoc for JavaExec.setArgsString(https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/JavaExec.html#setArgsString-java.lang.String-) for further details. Passing System Properties to Your application: Since bootRun is a standard JavaExec task, system properties can be passed to the application’s JVM by specifying them in the build script. To make that value of a system property to be configurable set its value using a project property(https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#N14FE1) . To allow a project property to be optional, reference it using findProperty . Doing so also allows a default value to be provided using the ?: Elvis operator, as shown in the following example: Groovy Kotlin tasks.named(""bootRun"") { systemProperty 'com.example.property', findProperty('example') ?: 'default' } tasks.named<BootRun>(""bootRun"") { systemProperty(""com.example.property"", findProperty(""example"") ?: ""default"") } The preceding example sets that com.example.property system property to the value of the example project property. If the example project property has not been set, the value of the system property will be default . Gradle allows project properties to be set in a variety of ways, including on the command line using the -P flag, as shown in the following example: $ ./gradlew bootRun -Pexample=custom The preceding example sets the value of the example project property to custom . bootRun will then use this as the value of the com.example.property system property. Reloading Resources: If devtools has been added to your project it will automatically monitor your application’s classpath for changes. Note that modified files need to be recompiled for the classpath to update in order to trigger reloading with devtools. For more details on using devtools, refer to this section of the reference documentation(../reference/using/devtools.html#using.devtools.restart) . Alternatively, you can configure bootRun such that your application’s static resources are loaded from their source location: Groovy Kotlin tasks.named(""bootRun"") { sourceResources sourceSets.main } tasks.named<BootRun>(""bootRun"") { sourceResources(sourceSets[""main""]) } This makes them reloadable in the live application which can be helpful at development time. Using a Test Main Class: In addition to bootRun a bootTestRun task is also registered. Like bootRun , bootTestRun is an instance of BootRun but it’s configured to use a main class found in the output of the test source set rather than the main source set. It also uses the test source set’s runtime classpath rather than the main source set’s runtime classpath. As bootTestRun is an instance of BootRun , all of the configuration options described above for bootRun can also be used with bootTestRun ."
"https://docs.spring.io/spring-boot/gradle-plugin/aot.html","Ahead-of-Time Processing: Spring AOT is a process that analyzes your code at build-time in order to generate an optimized version of it. It is most often used to help generate GraalVM native images. The Spring Boot Gradle plugin provides tasks that can be used to perform AOT processing on both application and test code. The tasks are configured automatically when the GraalVM Native Image plugin(https://graalvm.github.io/native-build-tools/0.10.3/gradle-plugin.html) is applied: Groovy Kotlin plugins { id 'org.springframework.boot' version '3.3.4' id 'org.graalvm.buildtools.native' version '0.10.3' id 'java' } plugins { id(""org.springframework.boot"") version ""3.3.4"" id(""org.graalvm.buildtools.native"") version ""0.10.3"" java } Processing Applications: Based on your @SpringBootApplication -annotated main class, the processAot task generates a persistent view of the beans that are going to be contributed at runtime in a way that bean instantiation is as straightforward as possible. Additional post-processing of the factory is possible using callbacks. For instance, these are used to generate the necessary reflection configuration that GraalVM needs to initialize the context in a native image. As the BeanFactory is fully prepared at build-time, conditions are also evaluated. This has an important difference compared to what a regular Spring Boot application does at runtime. For instance, if you want to opt-in or opt-out for certain features, you need to configure the environment used at build time to do so. To this end, the processAot task is a JavaExec(https://docs.gradle.org/current/dsl/org.gradle.api.tasks.JavaExec.html) task and can be configured with environment variables, system properties, and arguments as needed. The nativeCompile task of the GraalVM Native Image plugin is automatically configured to use the output of the processAot task. Processing Tests: The AOT engine can be applied to JUnit 5 tests that use Spring’s Test Context Framework. Suitable tests are processed by the processTestAot task to generate ApplicationContextInitializer code. As with application AOT processing, the BeanFactory is fully prepared at build-time. As with processAot , the processTestAot task is JavaExec subclass and can be configured as needed to influence this processing. The nativeTest task of the GraalVM Native Image plugin is automatically configured to use the output of the processAot and processTestAot tasks."
"https://docs.spring.io/spring-boot/gradle-plugin/integrating-with-actuator.html","Integrating with Actuator: Generating Build Information: Spring Boot Actuator’s info endpoint automatically publishes information about your build in the presence of a META-INF/build-info.properties file. A BuildInfo(api/java/org/springframework/boot/gradle/tasks/buildinfo/BuildInfo.html) task is provided to generate this file. The easiest way to use the task is through the plugin’s DSL: Groovy Kotlin springBoot { buildInfo() } springBoot { buildInfo() } This will configure a BuildInfo(api/java/org/springframework/boot/gradle/tasks/buildinfo/BuildInfo.html) task named bootBuildInfo and, if it exists, make the Java plugin’s classes task depend upon it. The task’s destination directory will be META-INF in the output directory of the main source set’s resources (typically build/resources/main ). By default, the generated build information is derived from the project: Property Default value build.artifact The base name of the bootJar or bootWar task build.group The group of the project build.name The name of the project build.version The version of the project build.time The time at which the project is being built The properties can be customized using the DSL: Groovy Kotlin springBoot { buildInfo { properties { artifact = 'example-app' version = '1.2.3' group = 'com.example' name = 'Example application' } } } springBoot { buildInfo { properties { artifact.set(""example-app"") version.set(""1.2.3"") group.set(""com.example"") name.set(""Example application"") } } } To exclude any of the default properties from the generated build information, add its name to the excludes. For example, the time property can be excluded as follows: Groovy Kotlin springBoot { buildInfo { excludes = ['time'] } } springBoot { buildInfo { excludes.set(setOf(""time"")) } } The default value for build.time is the instant at which the project is being built. A side-effect of this is that the task will never be up-to-date. As a result, builds will take longer as more tasks, including the project’s tests, will have to be executed. Another side-effect is that the task’s output will always change and, therefore, the build will not be truly repeatable. If you value build performance or repeatability more highly than the accuracy of the build.time property, exclude the time property as shown in the preceding example. Additional properties can also be added to the build information: Groovy Kotlin springBoot { buildInfo { properties { additional = [ 'a': 'alpha', 'b': 'bravo' ] } } } springBoot { buildInfo { properties { additional.set(mapOf( ""a"" to ""alpha"", ""b"" to ""bravo"" )) } } } An additional property’s value can be computed lazily by using a Provider ."
"https://docs.spring.io/spring-boot/gradle-plugin/reacting.html","Reacting to Other Plugins: When another plugin is applied the Spring Boot plugin reacts by making various changes to the project’s configuration. This section describes those changes. Reacting to the Java Plugin: When Gradle’s java plugin(https://docs.gradle.org/current/userguide/java_plugin.html) is applied to a project, the Spring Boot plugin: Creates a BootJar(api/java/org/springframework/boot/gradle/tasks/bundling/BootJar.html) task named bootJar that will create an executable, uber jar for the project. The jar will contain everything on the runtime classpath of the main source set; classes are packaged in BOOT-INF/classes and jars are packaged in BOOT-INF/lib Configures the assemble task to depend on the bootJar task. Configures the jar task to use plain as the convention for its archive classifier. Creates a BootBuildImage(api/java/org/springframework/boot/gradle/tasks/bundling/BootBuildImage.html) task named bootBuildImage that will create a OCI image using a buildpack(https://buildpacks.io) . Creates a BootRun(api/java/org/springframework/boot/gradle/tasks/run/BootRun.html) task named bootRun that can be used to run your application using the main source set to find its main method and provide its runtime classpath. Creates a 'BootRun`(api/java/org/springframework/boot/gradle/tasks/run/BootRun.html) task named bootTestRun that can be used to run your application using the test source set to find its main method and provide its runtime classpath. Creates a configuration named bootArchives that contains the artifact produced by the bootJar task. Creates a configuration named developmentOnly for dependencies that are only required at development time, such as Spring Boot’s Devtools, and should not be packaged in executable jars and wars. Creates a configuration named testAndDevelopmentOnly for dependencies that are only required at development time and when writing and running tests and that should not be packaged in executable jars and wars. Creates a configuration named productionRuntimeClasspath . It is equivalent to runtimeClasspath minus any dependencies that only appear in the developmentOnly or testDevelopmentOnly configurations. Configures any JavaCompile tasks with no configured encoding to use UTF-8 . Configures any JavaCompile tasks to use the -parameters compiler argument. Reacting to the Kotlin Plugin: When Kotlin’s Gradle plugin(https://kotlinlang.org/docs/reference/using-gradle.html) is applied to a project, the Spring Boot plugin: Aligns the Kotlin version used in Spring Boot’s dependency management with the version of the plugin. This is achieved by setting the kotlin.version property with a value that matches the version of the Kotlin plugin. Configures any KotlinCompile tasks to use the -java-parameters compiler argument. Reacting to the War Plugin: When Gradle’s war plugin(https://docs.gradle.org/current/userguide/war_plugin.html) is applied to a project, the Spring Boot plugin: Creates a BootWar(api/java/org/springframework/boot/gradle/tasks/bundling/BootWar.html) task named bootWar that will create an executable, fat war for the project. In addition to the standard packaging, everything in the providedRuntime configuration will be packaged in WEB-INF/lib-provided . Configures the assemble task to depend on the bootWar task. Configures the war task to use plain as the convention for its archive classifier. Configures the bootArchives configuration to contain the artifact produced by the bootWar task. Reacting to the Dependency Management Plugin: When the io.spring.dependency-management plugin(https://github.com/spring-gradle-plugins/dependency-management-plugin) is applied to a project, the Spring Boot plugin will automatically import the spring-boot-dependencies bom. Reacting to the Application Plugin: When Gradle’s application plugin(https://docs.gradle.org/current/userguide/application_plugin.html) is applied to a project, the Spring Boot plugin: Creates a CreateStartScripts task named bootStartScripts that will create scripts that launch the artifact in the bootArchives configuration using java -jar . The task is configured to use the applicationDefaultJvmArgs property as a convention for its defaultJvmOpts property. Creates a new distribution named boot and configures it to contain the artifact in the bootArchives configuration in its lib directory and the start scripts in its bin directory. Configures the bootRun task to use the mainClassName property as a convention for its main property. Configures the bootRun and bootTestRun tasks to use the applicationDefaultJvmArgs property as a convention for their jvmArgs property. Configures the bootJar task to use the mainClassName property as a convention for the Start-Class entry in its manifest. Configures the bootWar task to use the mainClassName property as a convention for the Start-Class entry in its manifest. Reacting to the GraalVM Native Image Plugin: When the GraalVM Native Image plugin(https://graalvm.github.io/native-build-tools/0.10.3/gradle-plugin.html) is applied to a project, the Spring Boot plugin: Applies the org.springframework.boot.aot plugin that: Registers aot and aotTest source sets. Registers a ProcessAot task named processAot that will generate AOT-optimized source for the application in the aot source set. Configures the Java compilation and process resources tasks for the aot source set to depend upon processAot . Registers a ProcessTestAot task named processTestAot that will generated AOT-optimized source for the application’s tests in the aotTest source set. Configures the Java compilation and process resources tasks for the aotTest source set to depend upon processTestAot . Adds the output of the aot source set to the classpath of the main GraalVM native binary. Adds the output of the aotTest source set to the classpath of the test GraalVM native binary. Configures the GraalVM extension to disable Toolchain detection. Configures each GraalVM native binary to require GraalVM 22.3 or later. Configures the bootJar task to include the reachability metadata produced by the collectReachabilityMetadata task in its jar. Configures the bootBuildImage task to use paketobuildpacks/builder-jammy-tiny:latest as its builder and to set BP_NATIVE_IMAGE to true in its environment."
"https://docs.spring.io/spring-boot/build-tool-plugin/antlib.html","Spring Boot AntLib Module: The Spring Boot AntLib module provides basic Spring Boot support for Apache Ant. You can use the module to create executable jars. To use the module, you need to declare an additional spring-boot namespace in your build.xml , as shown in the following example: <project xmlns:ivy=""antlib:org.apache.ivy.ant"" xmlns:spring-boot=""antlib:org.springframework.boot.ant"" name=""myapp"" default=""build""> ... </project> You need to remember to start Ant using the -lib option, as shown in the following example: $ ant -lib <directory containing spring-boot-antlib-3.3.4.jar> The “Using Spring Boot” section includes a more complete example of using Apache Ant with spring-boot-antlib(../reference/using/build-systems.html#using.build-systems.ant) . Spring Boot Ant Tasks: Once the spring-boot-antlib namespace has been declared, the following additional tasks are available: Using the “exejar” Task(#build-tool-plugins.antlib.tasks.exejar) Using the “findmainclass” Task(#build-tool-plugins.antlib.findmainclass) Using the “exejar” Task: You can use the exejar task to create a Spring Boot executable jar. The following attributes are supported by the task: Attribute Description Required destfile The destination jar file to create Yes classes The root directory of Java class files Yes start-class The main application class to run No (the default is the first class found that declares a main method) The following nested elements can be used with the task: Element Description resources One or more Resource Collections(https://ant.apache.org/manual/Types/resources.html#collection) describing a set of Resources(https://ant.apache.org/manual/Types/resources.html) that should be added to the content of the created jar file. lib One or more Resource Collections(https://ant.apache.org/manual/Types/resources.html#collection) that should be added to the set of jar libraries that make up the runtime dependency classpath of the application. Examples: This section shows two examples of Ant tasks. Specify start-class <spring-boot:exejar destfile=""target/my-application.jar"" classes=""target/classes"" start-class=""com.example.MyApplication""> <resources> <fileset dir=""src/main/resources"" /> </resources> <lib> <fileset dir=""lib"" /> </lib> </spring-boot:exejar> Detect start-class <exejar destfile=""target/my-application.jar"" classes=""target/classes""> <lib> <fileset dir=""lib"" /> </lib> </exejar> Using the “findmainclass” Task: The findmainclass task is used internally by exejar to locate a class declaring a main . If necessary, you can also use this task directly in your build. The following attributes are supported: Attribute Description Required classesroot The root directory of Java class files Yes (unless mainclass is specified) mainclass Can be used to short-circuit the main class search No property The Ant property that should be set with the result No (result will be logged if unspecified) Examples: This section contains three examples of using findmainclass . Find and log <findmainclass classesroot=""target/classes"" /> Find and set <findmainclass classesroot=""target/classes"" property=""main-class"" /> Override and set <findmainclass mainclass=""com.example.MainClass"" property=""main-class"" />"
"https://docs.spring.io/spring-boot/build-tool-plugin/other-build-systems.html","Supporting Other Build Systems: If you want to use a build tool other than Maven, Gradle, or Ant, you likely need to develop your own plugin. Executable jars need to follow a specific format and certain entries need to be written in an uncompressed form (see the executable jar format(../specification/executable-jar/index.html) section in the appendix for details). The Spring Boot Maven and Gradle plugins both make use of spring-boot-loader-tools to actually generate jars. If you need to, you may use this library directly. Repackaging Archives: To repackage an existing archive so that it becomes a self-contained executable archive, use org.springframework.boot.loader.tools.Repackager . The Repackager class takes a single constructor argument that refers to an existing jar or war archive. Use one of the two available repackage() methods to either replace the original file or write to a new destination. Various settings can also be configured on the repackager before it is run. Nested Libraries: When repackaging an archive, you can include references to dependency files by using the org.springframework.boot.loader.tools.Libraries interface. We do not provide any concrete implementations of Libraries here as they are usually build-system-specific. If your archive already includes libraries, you can use Libraries.NONE . Finding a Main Class: If you do not use Repackager.setMainClass() to specify a main class, the repackager uses ASM(https://asm.ow2.io/) to read class files and tries to find a suitable class with a public static void main(String[] args) method. An exception is thrown if more than one candidate is found. Example Repackage Implementation: The following example shows a typical repackage implementation: Java Kotlin import java.io.File; import java.io.IOException; import java.util.List; import org.springframework.boot.loader.tools.Library; import org.springframework.boot.loader.tools.LibraryCallback; import org.springframework.boot.loader.tools.LibraryScope; import org.springframework.boot.loader.tools.Repackager; public class MyBuildTool { public void build() throws IOException { File sourceJarFile = ... Repackager repackager = new Repackager(sourceJarFile); repackager.setBackupSource(false); repackager.repackage(this::getLibraries); } private void getLibraries(LibraryCallback callback) throws IOException { // Build system specific implementation, callback for each dependency for (File nestedJar : getCompileScopeJars()) { callback.library(new Library(nestedJar, LibraryScope.COMPILE)); } // ... } private List<File> getCompileScopeJars() { return ... } } import org.springframework.boot.loader.tools.Library import org.springframework.boot.loader.tools.LibraryCallback import org.springframework.boot.loader.tools.LibraryScope import org.springframework.boot.loader.tools.Repackager import java.io.File import java.io.IOException class MyBuildTool { @Throws(IOException::class) fun build() { val sourceJarFile: File? = ... val repackager = Repackager(sourceJarFile) repackager.setBackupSource(false) repackager.repackage { callback: LibraryCallback -> getLibraries(callback) } } @Throws(IOException::class) private fun getLibraries(callback: LibraryCallback) { // Build system specific implementation, callback for each dependency for (nestedJar in getCompileScopeJars()!!) { callback.library(Library(nestedJar, LibraryScope.COMPILE)) } // ... } private fun getCompileScopeJars(): List<File?>? { return ... } }"
"https://docs.spring.io/spring-boot/cli/index.html","Spring Boot CLI: The Spring Boot CLI is a command line tool that you can use to bootstrap a new project from start.spring.io(https://start.spring.io) or encode a password."
"https://docs.spring.io/spring-boot/cli/installation.html","Installing the CLI: The Spring Boot CLI (Command-Line Interface) can be installed manually by using SDKMAN! (the SDK Manager) or by using Homebrew or MacPorts if you are an OSX user. See Installing the Spring Boot CLI(../installing.html#getting-started.installing.cli) in the “Getting Started” section for comprehensive installation instructions."
"https://docs.spring.io/spring-boot/cli/using-the-cli.html","Using the CLI: Once you have installed the CLI, you can run it by typing spring and pressing Enter at the command line. If you run spring without any arguments, a help screen is displayed, as follows: $ spring usage: spring [--help] [--version] <command> [<args>] Available commands are: init [options] [location] Initialize a new project using Spring Initializr (start.spring.io) encodepassword [options] <password to encode> Encode a password for use with Spring Security shell Start a nested shell Common options: --debug Verbose mode Print additional status information for the command you are running See 'spring help <command>' for more information on a specific command. You can type spring help to get more details about any of the supported commands, as shown in the following example: $ spring help init spring init - Initialize a new project using Spring Initializr (start.spring.io) usage: spring init [options] [location] Option Description ------ ----------- -a, --artifact-id <String> Project coordinates; infer archive name (for example 'test') -b, --boot-version <String> Spring Boot version (for example '1.2.0.RELEASE') --build <String> Build system to use (for example 'maven' or 'gradle') (default: maven) -d, --dependencies <String> Comma-separated list of dependency identifiers to include in the generated project --description <String> Project description -f, --force Force overwrite of existing files --format <String> Format of the generated content (for example 'build' for a build file, 'project' for a project archive) (default: project) -g, --group-id <String> Project coordinates (for example 'org.test') -j, --java-version <String> Language level (for example '1.8') -l, --language <String> Programming language (for example 'java') --list List the capabilities of the service. Use it to discover the dependencies and the types that are available -n, --name <String> Project name; infer application name -p, --packaging <String> Project packaging (for example 'jar') --package-name <String> Package name -t, --type <String> Project type. Not normally needed if you use -- build and/or --format. Check the capabilities of the service (--list) for more details --target <String> URL of the service to use (default: https://start. spring.io) -v, --version <String> Project version (for example '0.0.1-SNAPSHOT') -x, --extract Extract the project archive. Inferred if a location is specified without an extension examples: To list all the capabilities of the service: $ spring init --list To creates a default project: $ spring init To create a web my-app.zip: $ spring init -d=web my-app.zip To create a web/data-jpa gradle project unpacked: $ spring init -d=web,jpa --build=gradle my-dir The version command provides a quick way to check which version of Spring Boot you are using, as follows: $ spring version Spring CLI v3.3.4 Initialize a New Project: The init command lets you create a new project by using start.spring.io(https://start.spring.io) without leaving the shell, as shown in the following example: $ spring init --dependencies=web,data-jpa my-project Using service at https://start.spring.io Project extracted to '/Users/developer/example/my-project' The preceding example creates a my-project directory with a Maven-based project that uses spring-boot-starter-web and spring-boot-starter-data-jpa . You can list the capabilities of the service by using the --list flag, as shown in the following example: $ spring init --list ======================================= Capabilities of https://start.spring.io ======================================= Available dependencies: ----------------------- actuator - Actuator: Production ready features to help you monitor and manage your application ... web - Web: Support for full-stack web development, including Tomcat and spring-webmvc websocket - Websocket: Support for WebSocket development ws - WS: Support for Spring Web Services Available project types: ------------------------ gradle-build - Gradle Config [format:build, build:gradle] gradle-project - Gradle Project [format:project, build:gradle] maven-build - Maven POM [format:build, build:maven] maven-project - Maven Project [format:project, build:maven] (default) ... The init command supports many options. See the help output for more details. For instance, the following command creates a Gradle project that uses Java 17 and war packaging: $ spring init --build=gradle --java-version=17 --dependencies=websocket --packaging=war sample-app.zip Using service at https://start.spring.io Content saved to 'sample-app.zip' Using the Embedded Shell: Spring Boot includes command-line completion scripts for the BASH and zsh shells. If you do not use either of these shells (perhaps you are a Windows user), you can use the shell command to launch an integrated shell, as shown in the following example: $ spring shell Spring Boot (v3.3.4) Hit TAB to complete. Type \'help' and hit RETURN for help, and \'exit' to quit. From inside the embedded shell, you can run other commands directly: $ version Spring CLI v3.3.4 The embedded shell supports ANSI color output as well as tab completion. If you need to run a native command, you can use the ! prefix. To exit the embedded shell, press ctrl-c ."
"https://docs.spring.io/spring-boot/api/rest/actuator/index.html","Actuator REST API: This API documentation describes Spring Boot Actuators web endpoints. Before you proceed, you should read the following topics: URLs(#overview.endpoint-urls) Timestamps(#overview.timestamps) In order to get the correct JSON responses documented below, Jackson must be available. URLs: By default, all web endpoints are available beneath the path /actuator with URLs of the form /actuator/{id} . The /actuator base path can be configured by using the management.endpoints.web.base-path property, as shown in the following example: management.endpoints.web.base-path=/manage The preceding application.properties example changes the form of the endpoint URLs from /actuator/{id} to /manage/{id} . For example, the URL info endpoint would become /manage/info . Timestamps: All timestamps that are consumed by the endpoints, either as query parameters or in the request body, must be formatted as an offset date and time as specified in ISO 8601(https://en.wikipedia.org/wiki/ISO_8601) ."
"https://docs.spring.io/spring-boot/api/rest/actuator/auditevents.html","Audit Events (auditevents): The auditevents endpoint provides information about the application’s audit events. Retrieving Audit Events: To retrieve the audit events, make a GET request to /actuator/auditevents , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/auditevents?principal=alice&after=2024-09-19T09%3A28%3A00.955887613Z&type=logout' -i -X GET The preceding example retrieves logout events for the principal, alice , that occurred after 09:37 on 7 November 2017 in the UTC timezone. The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 127 { ""events"" : [ { ""timestamp"" : ""2024-09-19T09:28:00.956531507Z"", ""principal"" : ""alice"", ""type"" : ""logout"" } ] } Query Parameters: The endpoint uses query parameters to limit the events that it returns. The following table shows the supported query parameters: Parameter Description after Restricts the events to those that occurred after the given time. Optional. principal Restricts the events to those with the given principal. Optional. type Restricts the events to those with the given type. Optional. Response Structure: The response contains details of all of the audit events that matched the query. The following table describes the structure of the response: Path Type Description events Array An array of audit events. events.[].timestamp String The timestamp of when the event occurred. events.[].principal String The principal that triggered the event. events.[].type String The type of the event."
"https://docs.spring.io/spring-boot/api/rest/actuator/beans.html","Beans (beans): The beans endpoint provides information about the application’s beans. Retrieving the Beans: To retrieve the beans, make a GET request to /actuator/beans , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/beans' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 1089 { ""contexts"" : { ""application"" : { ""beans"" : { ""org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration"" : { ""aliases"" : [ ], ""scope"" : ""singleton"", ""type"" : ""org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration"", ""dependencies"" : [ ] }, ""org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration"" : { ""aliases"" : [ ], ""scope"" : ""singleton"", ""type"" : ""org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration"", ""dependencies"" : [ ] }, ""org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration"" : { ""aliases"" : [ ], ""scope"" : ""singleton"", ""type"" : ""org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration"", ""dependencies"" : [ ] } } } } } Response Structure: The response contains details of the application’s beans. The following table describes the structure of the response: Path Type Description contexts Object Application contexts keyed by id. contexts.*.parentId String Id of the parent application context, if any. contexts.*.beans Object Beans in the application context keyed by name. contexts.*.beans.*.aliases Array Names of any aliases. contexts.*.beans.*.scope String Scope of the bean. contexts.*.beans.*.type String Fully qualified type of the bean. contexts.*.beans.*.resource String Resource in which the bean was defined, if any. contexts.*.beans.*.dependencies Array Names of any dependencies."
"https://docs.spring.io/spring-boot/api/rest/actuator/caches.html","Caches (caches): The caches endpoint provides access to the application’s caches. Retrieving All Caches: To retrieve the application’s caches, make a GET request to /actuator/caches , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/caches' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 435 { ""cacheManagers"" : { ""anotherCacheManager"" : { ""caches"" : { ""countries"" : { ""target"" : ""java.util.concurrent.ConcurrentHashMap"" } } }, ""cacheManager"" : { ""caches"" : { ""cities"" : { ""target"" : ""java.util.concurrent.ConcurrentHashMap"" }, ""countries"" : { ""target"" : ""java.util.concurrent.ConcurrentHashMap"" } } } } } Response Structure: The response contains details of the application’s caches. The following table describes the structure of the response: Path Type Description cacheManagers Object Cache managers keyed by id. cacheManagers.*.caches Object Caches in the application context keyed by name. cacheManagers.*.caches.*.target String Fully qualified name of the native cache. Retrieving Caches by Name: To retrieve a cache by name, make a GET request to /actuator/caches/{name} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/caches/cities' -i -X GET The preceding example retrieves information about the cache named cities . The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 113 { ""target"" : ""java.util.concurrent.ConcurrentHashMap"", ""name"" : ""cities"", ""cacheManager"" : ""cacheManager"" } Query Parameters: If the requested name is specific enough to identify a single cache, no extra parameter is required. Otherwise, the cacheManager must be specified. The following table shows the supported query parameters: Parameter Description cacheManager Name of the cacheManager to qualify the cache. May be omitted if the cache name is unique. Response Structure: The response contains details of the requested cache. The following table describes the structure of the response: Path Type Description name String Cache name. cacheManager String Cache manager name. target String Fully qualified name of the native cache. Evict All Caches: To clear all available caches, make a DELETE request to /actuator/caches as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/caches' -i -X DELETE Evict a Cache by Name: To evict a particular cache, make a DELETE request to /actuator/caches/{name} as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/caches/countries?cacheManager=anotherCacheManager' -i -X DELETE \ -H 'Content-Type: application/x-www-form-urlencoded' As there are two caches named countries , the cacheManager has to be provided to specify which Cache should be cleared. Request Structure: If the requested name is specific enough to identify a single cache, no extra parameter is required. Otherwise, the cacheManager must be specified. The following table shows the supported query parameters: Parameter Description cacheManager Name of the cacheManager to qualify the cache. May be omitted if the cache name is unique."
"https://docs.spring.io/spring-boot/api/rest/actuator/conditions.html","Conditions Evaluation Report (conditions): The conditions endpoint provides information about the evaluation of conditions on configuration and auto-configuration classes. Retrieving the Report: To retrieve the report, make a GET request to /actuator/conditions , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/conditions' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 3705 { ""contexts"" : { ""application"" : { ""positiveMatches"" : { ""EndpointAutoConfiguration#endpointOperationParameterMapper"" : [ { ""condition"" : ""OnBeanCondition"", ""message"" : ""@ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.invoke.ParameterValueMapper; SearchStrategy: all) did not find any beans"" } ], ""JacksonEndpointAutoConfiguration#endpointObjectMapper"" : [ { ""condition"" : ""OnClassCondition"", ""message"" : ""@ConditionalOnClass found required classes 'com.fasterxml.jackson.databind.ObjectMapper', 'org.springframework.http.converter.json.Jackson2ObjectMapperBuilder'"" }, { ""condition"" : ""OnPropertyCondition"", ""message"" : ""@ConditionalOnProperty (management.endpoints.jackson.isolated-object-mapper) matched"" } ], ""EndpointAutoConfiguration#endpointCachingOperationInvokerAdvisor"" : [ { ""condition"" : ""OnBeanCondition"", ""message"" : ""@ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.invoker.cache.CachingOperationInvokerAdvisor; SearchStrategy: all) did not find any beans"" } ] }, ""negativeMatches"" : { ""WebFluxEndpointManagementContextConfiguration"" : { ""notMatched"" : [ { ""condition"" : ""OnWebApplicationCondition"", ""message"" : ""not a reactive web application"" } ], ""matched"" : [ { ""condition"" : ""OnClassCondition"", ""message"" : ""@ConditionalOnClass found required classes 'org.springframework.web.reactive.DispatcherHandler', 'org.springframework.http.server.reactive.HttpHandler'"" } ] }, ""GsonHttpMessageConvertersConfiguration.GsonHttpMessageConverterConfiguration"" : { ""notMatched"" : [ { ""condition"" : ""GsonHttpMessageConvertersConfiguration.PreferGsonOrJacksonAndJsonbUnavailableCondition"", ""message"" : ""AnyNestedCondition 0 matched 2 did not; NestedCondition on GsonHttpMessageConvertersConfiguration.PreferGsonOrJacksonAndJsonbUnavailableCondition.JacksonJsonbUnavailable NoneNestedConditions 1 matched 1 did not; NestedCondition on GsonHttpMessageConvertersConfiguration.JacksonAndJsonbUnavailableCondition.JsonbPreferred @ConditionalOnProperty (spring.mvc.converters.preferred-json-mapper=jsonb) did not find property 'spring.mvc.converters.preferred-json-mapper'; NestedCondition on GsonHttpMessageConvertersConfiguration.JacksonAndJsonbUnavailableCondition.JacksonAvailable @ConditionalOnBean (types: org.springframework.http.converter.json.MappingJackson2HttpMessageConverter; SearchStrategy: all) found bean 'mappingJackson2HttpMessageConverter'; NestedCondition on GsonHttpMessageConvertersConfiguration.PreferGsonOrJacksonAndJsonbUnavailableCondition.GsonPreferred @ConditionalOnProperty (spring.mvc.converters.preferred-json-mapper=gson) did not find property 'spring.mvc.converters.preferred-json-mapper'"" } ], ""matched"" : [ ] }, ""WebMvcEndpointManagementContextConfiguration#managementHealthEndpointWebMvcHandlerMapping"" : { ""notMatched"" : [ { ""condition"" : ""OnManagementPortCondition"", ""message"" : ""Management Port actual port type (SAME) did not match required type (DIFFERENT)"" } ], ""matched"" : [ ] } }, ""unconditionalClasses"" : [ ""org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration"", ""org.springframework.boot.actuate.autoconfigure.endpoint.jackson.JacksonEndpointAutoConfiguration"", ""org.springframework.boot.actuate.autoconfigure.endpoint.EndpointAutoConfiguration"" ] } } } Response Structure: The response contains details of the application’s condition evaluation. The following table describes the structure of the response: Path Type Description contexts Object Application contexts keyed by id. contexts.*.positiveMatches Object Classes and methods with conditions that were matched. contexts.*.positiveMatches.*.[].condition String Name of the condition. contexts.*.positiveMatches.*.[].message String Details of why the condition was matched. contexts.*.negativeMatches Object Classes and methods with conditions that were not matched. contexts.*.negativeMatches.*.notMatched Array Conditions that were matched. contexts.*.negativeMatches.*.notMatched.[].condition String Name of the condition. contexts.*.negativeMatches.*.notMatched.[].message String Details of why the condition was not matched. contexts.*.negativeMatches.*.matched Array Conditions that were matched. contexts.*.negativeMatches.*.matched.[].condition String Name of the condition. contexts.*.negativeMatches.*.matched.[].message String Details of why the condition was matched. contexts.*.unconditionalClasses Array Names of unconditional auto-configuration classes if any. contexts.*.parentId String Id of the parent application context, if any."
"https://docs.spring.io/spring-boot/api/rest/actuator/configprops.html","Configuration Properties (configprops): The configprops endpoint provides information about the application’s @ConfigurationProperties beans. Retrieving All @ConfigurationProperties Beans: To retrieve all of the @ConfigurationProperties beans, make a GET request to /actuator/configprops , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/configprops' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 3411 { ""contexts"" : { ""application"" : { ""beans"" : { ""management.endpoints.web.cors-org.springframework.boot.actuate.autoconfigure.endpoint.web.CorsEndpointProperties"" : { ""prefix"" : ""management.endpoints.web.cors"", ""properties"" : { ""allowedOrigins"" : [ ], ""maxAge"" : ""PT30M"", ""exposedHeaders"" : [ ], ""allowedOriginPatterns"" : [ ], ""allowedHeaders"" : [ ], ""allowedMethods"" : [ ] }, ""inputs"" : { ""allowedOrigins"" : [ ], ""maxAge"" : { }, ""exposedHeaders"" : [ ], ""allowedOriginPatterns"" : [ ], ""allowedHeaders"" : [ ], ""allowedMethods"" : [ ] } }, ""management.endpoints.web-org.springframework.boot.actuate.autoconfigure.endpoint.web.WebEndpointProperties"" : { ""prefix"" : ""management.endpoints.web"", ""properties"" : { ""pathMapping"" : { }, ""exposure"" : { ""include"" : [ ""*"" ], ""exclude"" : [ ] }, ""basePath"" : ""/actuator"", ""discovery"" : { ""enabled"" : true } }, ""inputs"" : { ""pathMapping"" : { }, ""exposure"" : { ""include"" : [ { ""value"" : ""*"", ""origin"" : ""\""management.endpoints.web.exposure.include\"" from property source \""Inlined Test Properties\"""" } ], ""exclude"" : [ ] }, ""basePath"" : { }, ""discovery"" : { ""enabled"" : { } } } }, ""spring.web-org.springframework.boot.autoconfigure.web.WebProperties"" : { ""prefix"" : ""spring.web"", ""properties"" : { ""localeResolver"" : ""ACCEPT_HEADER"", ""resources"" : { ""staticLocations"" : [ ""classpath:/META-INF/resources/"", ""classpath:/resources/"", ""classpath:/static/"", ""classpath:/public/"" ], ""addMappings"" : true, ""chain"" : { ""cache"" : true, ""compressed"" : false, ""strategy"" : { ""fixed"" : { ""enabled"" : false, ""paths"" : [ ""/**"" ] }, ""content"" : { ""enabled"" : false, ""paths"" : [ ""/**"" ] } } }, ""cache"" : { ""cachecontrol"" : { }, ""useLastModified"" : true } } }, ""inputs"" : { ""localeResolver"" : { }, ""resources"" : { ""staticLocations"" : [ { }, { }, { }, { } ], ""addMappings"" : { }, ""chain"" : { ""cache"" : { }, ""compressed"" : { }, ""strategy"" : { ""fixed"" : { ""enabled"" : { }, ""paths"" : [ { } ] }, ""content"" : { ""enabled"" : { }, ""paths"" : [ { } ] } } }, ""cache"" : { ""cachecontrol"" : { }, ""useLastModified"" : { } } } } } } } } } Response Structure: The response contains details of the application’s @ConfigurationProperties beans. The following table describes the structure of the response: Path Type Description contexts Object Application contexts keyed by id. contexts.*.beans.* Object @ConfigurationProperties beans keyed by bean name. contexts.*.beans.*.prefix String Prefix applied to the names of the bean’s properties. contexts.*.beans.*.properties Object Properties of the bean as name-value pairs. contexts.*.beans.*.inputs Object Origin and value of the configuration property used when binding to this bean. contexts.*.parentId String Id of the parent application context, if any. Retrieving @ConfigurationProperties Beans By Prefix: To retrieve the @ConfigurationProperties beans mapped under a certain prefix, make a GET request to /actuator/configprops/{prefix} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/configprops/spring.jackson' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Disposition: inline;filename=f.txt Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 878 { ""contexts"" : { ""application"" : { ""beans"" : { ""spring.jackson-org.springframework.boot.autoconfigure.jackson.JacksonProperties"" : { ""prefix"" : ""spring.jackson"", ""properties"" : { ""serialization"" : { }, ""visibility"" : { }, ""parser"" : { }, ""datatype"" : { ""jsonNode"" : { }, ""enum"" : { } }, ""deserialization"" : { }, ""generator"" : { }, ""mapper"" : { } }, ""inputs"" : { ""serialization"" : { }, ""visibility"" : { }, ""parser"" : { }, ""datatype"" : { ""jsonNode"" : { }, ""enum"" : { } }, ""deserialization"" : { }, ""generator"" : { }, ""mapper"" : { } } } } } } } The {prefix} does not need to be exact, a more general prefix will return all beans mapped under that prefix stem. Response Structure: The response contains details of the application’s @ConfigurationProperties beans. The following table describes the structure of the response: Path Type Description contexts Object Application contexts keyed by id. contexts.*.beans.* Object @ConfigurationProperties beans keyed by bean name. contexts.*.beans.*.prefix String Prefix applied to the names of the bean’s properties. contexts.*.beans.*.properties Object Properties of the bean as name-value pairs. contexts.*.beans.*.inputs Object Origin and value of the configuration property used when binding to this bean. contexts.*.parentId String Id of the parent application context, if any."
"https://docs.spring.io/spring-boot/api/rest/actuator/env.html","Environment (env): The env endpoint provides information about the application’s Environment . Retrieving the Entire Environment: To retrieve the entire environment, make a GET request to /actuator/env , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/env' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 78798 { ""activeProfiles"" : [ ], ""defaultProfiles"" : [ ""default"" ], ""propertySources"" : [ { ""name"" : ""servletContextInitParams"", ""properties"" : { } }, { ""name"" : ""systemProperties"", ""properties"" : { ""java.specification.version"" : { ""value"" : ""17"" }, ""java.class.path"" : { ""value"" : ""/home/runner/.gradle/caches/7.6.4/workerMain/gradle-worker.jar:/home/runner/work/spring-boot/spring-boot/spring-boot-project/spring-boot-actuator-autoconfigure/build/classes/java/test:/home/runner/work/spring-boot/spring-boot/spring-boot-project/spring-boot-actuator-autoconfigure/build/resources/test:/home/runner/work/spring-boot/spring-boot/spring-boot-project/spring-boot-actuator-autoconfigure/build/classes/java/main:/home/runner/work/spring-boot/spring-boot/spring-boot-project/spring-boot-actuator-autoconfigure/build/resources/main:/home/runner/work/spring-boot/spring-boot/spring-boot-project/spring-boot-tools/spring-boot-test-support/build/libs/spring-boot-test-support-3.3.4.jar:/home/runner/work/spring-boot/spring-boot/spring-boot-project/spring-boot-actuator/build/libs/spring-boot-actuator-3.3.4.jar:/home/runner/work/spring-boot/spring-boot/spring-boot-project/spring-boot-autoconfigure/build/libs/spring-boot-autoconfigure-3.3.4.jar:/home/runner/work/spring-boot/spring-boot/spring-boot-project/spring-boot-test/build/libs/spring-boot-test-3.3.4.jar:/home/runner/work/spring-boot/spring-boot/spring-boot-project/spring-boot/build/libs/spring-boot-3.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.dataformat/jackson-dataformat-xml/2.17.2/ad58f5bd089e743ac6e5999b2d1e3cf8515cea9a/jackson-dataformat-xml-2.17.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-wavefront/1.13.4/5d424a651af640fcff2400fe44f0aff0192645a8/micrometer-registry-wavefront-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-tracing-reporter-wavefront/1.3.4/1d8742b166c23c4711ecffab27f20f9854b19f8c/micrometer-tracing-reporter-wavefront-1.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.wavefront/wavefront-internal-reporter-java/1.7.16/135f9be9f149a6f0614db155ddf51e216d0d2891/wavefront-internal-reporter-java-1.7.16.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.wavefront/wavefront-sdk-java/3.4.3/48a767aa5aa56b56e09c88e8be87de8707cafe77/wavefront-sdk-java-3.4.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.datatype/jackson-datatype-jsr310/2.17.2/267b85e9ba2892a37be6d80aa9ca1438a0d8c210/jackson-datatype-jsr310-2.17.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-cassandra/4.3.4/e9471274a445fe339e29b6aa0223f030fc71a39b/spring-data-cassandra-4.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.cassandra/java-driver-query-builder/4.18.1/a771500f0d15729c740c43711f684a605157d5f7/java-driver-query-builder-4.18.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.cassandra/java-driver-core/4.18.1/1b80caa76a9b4f88b5adf866799aaa4a80f378f7/java-driver-core-4.18.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-elasticsearch/5.3.4/4236f642bebefdd9f8fe0e2230b21c68ebe997cd/spring-data-elasticsearch-5.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.flywaydb/flyway-core/10.10.0/8761d308b9fc9697a95ae362bcbbb5abe8f6e08f/flyway-core-10.10.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.dataformat/jackson-dataformat-toml/2.17.2/f085b1a94428c4546eef48f00cfa63286f54a8e2/jackson-dataformat-toml-2.17.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.media/jersey-media-json-jackson/3.1.8/8902513d06ff9dd4cd10c3d9b8d8e0f64510f309/jersey-media-json-jackson-3.1.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.module/jackson-module-jakarta-xmlbind-annotations/2.17.2/6c9723133a918f5777bde827ce6a6f1e4db935b2/jackson-module-jakarta-xmlbind-annotations-2.17.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.dataformat/jackson-dataformat-yaml/2.17.2/78d2c73dbec62044d7cf3b544b2e0d24a1a093b0/jackson-dataformat-yaml-2.17.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-rest-webmvc/4.3.4/1906854d16d62866ab6b5c5359bfc2de81d0e373/spring-data-rest-webmvc-4.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-rest-core/4.3.4/460023794deaad1c39e92a3949980ff4aa440b69/spring-data-rest-core-4.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.datatype/jackson-datatype-jdk8/2.17.2/efd3dd0e1d0db8bc72abbe71c15e697bb83b4b45/jackson-datatype-jdk8-2.17.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-core/2.17.2/969a35cb35c86512acbadcdbbbfb044c877db814/jackson-core-2.17.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.kafka/kafka-streams/3.7.1/b66ff777f6daeb44e0badcf9e73169fea569967f/kafka-streams-3.7.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-annotations/2.17.2/147b7b9412ffff24339f8aba080b292448e08698/jackson-annotations-2.17.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-couchbase/5.3.4/d5cf7a6c51593be2e127f35364cdc0bdac6b4855/spring-data-couchbase-5.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.restdocs/spring-restdocs-mockmvc/3.0.1/105b72b6c72416492cd483045e902a8ba30e2b1b/spring-restdocs-mockmvc-3.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.restdocs/spring-restdocs-webtestclient/3.0.1/5faab99b39fb34d865aa7d4800e2d22b47491e01/spring-restdocs-webtestclient-3.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.restdocs/spring-restdocs-core/3.0.1/4fe6b10f656d1fc0f84860f5449866626c4be6b5/spring-restdocs-core-3.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.17.2/e6deb029e5901e027c129341fac39e515066b68c/jackson-databind-2.17.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-classic/1.5.8/229bb1ef6b14dfbf74ff443af9097d836dc5f0dd/logback-classic-1.5.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.activemq/artemis-jakarta-server/2.33.0/b4b9c8fe9069cd12d8ec6fa79964cabbea8836fb/artemis-jakarta-server-2.33.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.activemq/artemis-server/2.33.0/9268e60bca51745cbbae9bcecadc300fc0caccf8/artemis-server-2.33.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.github.ben-manes.caffeine/caffeine/3.1.8/24795585df8afaf70a2cd534786904ea5889c047/caffeine-3.1.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.hazelcast/hazelcast-spring/5.4.0/5e5f37782abc83485e693835aa470a59e0a5b110/hazelcast-spring-5.4.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.hazelcast/hazelcast/5.4.0/91f9e08c36d8a3c3d0c389b974321159874f3b68/hazelcast-5.4.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.zaxxer/HikariCP/5.1.0/8c96e36c14461fc436bb02b264b96ef3ca5dca8c/HikariCP-5.1.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.lettuce/lettuce-core/6.3.2.RELEASE/29b2aac09256c5fc2e9e9ad1df41c65dad5e557a/lettuce-core-6.3.2.RELEASE.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.kafka/spring-kafka/3.2.4/88e6cfe1d3a4368723ca34d61e9f7dc7c57f7f55/spring-kafka-3.2.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-jakarta9/1.13.4/c03aeda6af5e8bae53f87e99c0083df8f4982ae1/micrometer-jakarta9-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-observation-test/1.13.4/485732cc3828119a42bd0c1f3977dec21149b620/micrometer-observation-test-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-tracing-bridge-brave/1.3.4/e860e353235f72748097463f5739bd2c380ac3b1/micrometer-tracing-bridge-brave-1.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-tracing-bridge-otel/1.3.4/182f31982e25832f7fb0cab23e2a53233efebc4/micrometer-tracing-bridge-otel-1.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-tracing/1.3.4/c49505c5459497e69c05843012425ab04db835/micrometer-tracing-1.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.amqp/spring-rabbit/3.1.7/955d7fee7735369ab54f4f66ec1dbe763ffc5f44/spring-rabbit-3.1.7.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.batch/spring-batch-core/5.1.2/461b30be2f5e0daaa7fb96e9fbcb98b2a1c12e24/spring-batch-core-5.1.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.graphql/spring-graphql/1.3.2/1752565a76cdf53a0ae91288e812ae52d4fbe3fa/spring-graphql-1.3.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-jpa/3.3.4/f92296e4b6d18f5f79c5e6074da96bf0de2006d3/spring-data-jpa-3.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-mongodb/4.3.4/922a53f4112a0e8c955ac34e675c8a7086b3e919/spring-data-mongodb-4.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-ldap/3.3.4/543c4ad6fbce2fd2c57e83e75b791a04c69558b5/spring-data-ldap-3.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-webmvc/6.1.13/ca5f025b133c69026bfe01daa6132d0ac2e4a59f/spring-webmvc-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.integration/spring-integration-jmx/6.3.4/f8b68b272a0e5feff0c3bb6d6ea120dcb2f176ef/spring-integration-jmx-6.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.integration/spring-integration-core/6.3.4/c02abcc0b2e14baadbe12ed785c9aa1bc78b8ac1/spring-integration-core-6.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.security/spring-security-config/6.3.3/57b2c01e0a9e12b4418668ebc369e39b648e61bb/spring-security-config-6.3.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.security/spring-security-oauth2-resource-server/6.3.3/369d5c744bfa33559f4c4f6481012ffc5019b573/spring-security-oauth2-resource-server-6.3.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.security/spring-security-saml2-service-provider/6.3.3/cdd3b2cea00f850ba954559bc81b1726b98ad9bd/spring-security-saml2-service-provider-6.3.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.security/spring-security-test/6.3.3/c27081b501b4348602741722534a32a56ddfef34/spring-security-test-6.3.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.security/spring-security-web/6.3.3/54455b90899cd803e92b020124e859a859f63ee0/spring-security-web-6.3.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-redis/3.3.4/f8f239679647f1b68d771990c4865fbd48d4e7d5/spring-data-redis-3.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-context-support/6.1.13/661432476697bf20b9d0c4842edd1cf84891e405/spring-context-support-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-keyvalue/3.3.4/8ba0a0cd306c47e73d0687ea36c942479c1cd308/spring-data-keyvalue-3.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.security/spring-security-oauth2-jose/6.3.3/93910bf54ae6bd0141ade7fb6e05c28f59a0456/spring-security-oauth2-jose-6.3.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.security/spring-security-oauth2-core/6.3.3/d592c08316e3b6c0d361c931ae11d3c7f3ebd21d/spring-security-oauth2-core-6.3.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.security/spring-security-core/6.3.3/2bf159e3db212d61408a2f728d6d7252dfaf4710/spring-security-core-6.3.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.hateoas/spring-hateoas/2.3.3/57998c7e68ac0884ff3c263fb09903b0c211d523/spring-hateoas-2.3.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.plugin/spring-plugin-core/3.0.0/d56aa02dd7272dca30aa598dc8b72e823227046a/spring-plugin-core-3.0.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-context/6.1.13/d5163ddae069c5d78c841cd3a60c4db25bf16401/spring-context-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-jms/6.1.13/c07b1ded85e7b207d91aab566a4922cf5cd3f9df/spring-jms-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.cache2k/cache2k-micrometer/2.6.1.Final/58731da010cc872915e012325027954bdc3122c8/cache2k-micrometer-2.6.1.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.hibernate.orm/hibernate-micrometer/6.5.3.Final/b5e4c04bb647e4d93896c6719ca5387670d16963/hibernate-micrometer-6.5.3.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-stackdriver/1.13.4/9dcc0d02c61cac478ab8a1bccd60c0879e4c8bb1/micrometer-registry-stackdriver-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.ext/jersey-micrometer/3.1.8/2b79ecbafe442ca099cb2279feb2b28c5b0fc714/jersey-micrometer-3.1.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-appoptics/1.13.4/4276ad0837f3a132f024f7621426b3270d7e76ea/micrometer-registry-appoptics-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-atlas/1.13.4/1f38d5e1d07195c780bc8a4db7796cae593bef6a/micrometer-registry-atlas-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-datadog/1.13.4/759d0f66a65819cbd2e359919471a77ac534fe33/micrometer-registry-datadog-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-dynatrace/1.13.4/c1642bad1eaeff60c3c3ebe3acb44b21a9fc6309/micrometer-registry-dynatrace-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-elastic/1.13.4/5572415f79f515cf5d05722ebe39ebab8d989446/micrometer-registry-elastic-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-ganglia/1.13.4/178f7c44143cb43d3469e93a6b1e56421a16c171/micrometer-registry-ganglia-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-graphite/1.13.4/2d6073dbcb8c1f2445fcbd932edcc68958d8ddad/micrometer-registry-graphite-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-humio/1.13.4/1e8f937f442838880453c6182762ecd83502ba2d/micrometer-registry-humio-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-influx/1.13.4/4098b4ee147d0fa9f67814cf65cdcd32ad35cac2/micrometer-registry-influx-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-jmx/1.13.4/b0021d574cda5b143760e1c714162d0c58a89928/micrometer-registry-jmx-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-kairos/1.13.4/5a29b1e2c243fce9b11c0c3fdd936d453e821cd0/micrometer-registry-kairos-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-new-relic/1.13.4/9a0e7d398fd6ee4a4c213a5d8883841614438a22/micrometer-registry-new-relic-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-otlp/1.13.4/e94d3ae981333a5f8f23ca45e7dc738db9a0db52/micrometer-registry-otlp-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-prometheus/1.13.4/8e19d08ff3b493318b50a49e8a3d831a6ccb573d/micrometer-registry-prometheus-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-prometheus-simpleclient/1.13.4/90c786745f0cf2fef9d2702e28372b751c022915/micrometer-registry-prometheus-simpleclient-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-signalfx/1.13.4/671f2fd4b980418241a702033998412a360943c/micrometer-registry-signalfx-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-registry-statsd/1.13.4/dc69cc806f429ab8d4bba35da0cc6fe2fdc14447/micrometer-registry-statsd-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-core/1.13.4/6a333b0ac647afa33616e142797da950ff295b7b/micrometer-core-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-webflux/6.1.13/2f490a97e87da44fba826ade3dc003aa132caca7/spring-webflux-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-web/6.1.13/e4028dbbc4ae1fb4bfd3257c53302956d7687b66/spring-web-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-observation/1.13.4/2673c9b181ab2512002b23b7ad0f1dd02212696c/micrometer-observation-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.prometheus/simpleclient_pushgateway/0.16.0/65935d9855ece6f85c21ad38634703d0917bf88c/simpleclient_pushgateway-0.16.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.zipkin.reporter2/zipkin-reporter-brave/3.4.2/9d972583ad89aeb1c7ce163dfc711366728e4cec/zipkin-reporter-brave-3.4.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.zipkin.reporter2/zipkin-sender-urlconnection/3.4.2/2762b8290baf9518677d2472199bc889a2c7a0f7/zipkin-sender-urlconnection-3.4.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-exporter-zipkin/1.37.0/d4aa3b20f16131fcfc94059692ee46c6edb30444/opentelemetry-exporter-zipkin-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-exporter-otlp/1.37.0/c54e41827e2fbf089aaf6a2f7a4fca7795e8b9c1/opentelemetry-exporter-otlp-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.projectreactor.netty/reactor-netty-http/1.1.22/2faf64b3822b0512f15d72a325e2826eb8564413/reactor-netty-http-1.1.22.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.r2dbc/r2dbc-pool/1.0.1.RELEASE/41ec552a21fc0884dfb85335bd3f4c757a269ab1/r2dbc-pool-1.0.1.RELEASE.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.r2dbc/r2dbc-proxy/1.1.5.RELEASE/ca3de357825915774cf2464deeaf470c368c7cd7/r2dbc-proxy-1.1.5.RELEASE.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.r2dbc/r2dbc-h2/1.0.0.RELEASE/b99b52c87e7f32136f58131ad7b7a3e2eb168f75/r2dbc-h2-1.0.0.RELEASE.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.r2dbc/r2dbc-spi/1.0.0.RELEASE/e3d15b2d27fdb8fdb76a181b21d5c752adf1d165/r2dbc-spi-1.0.0.RELEASE.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.activemq/activemq-client/6.1.3/24a1d36d862c1f903611b847c868bc0941aed3eb/activemq-client-6.1.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.activemq/artemis-jakarta-service-extensions/2.33.0/eaa812948ad099dd94387be5953becf26717b4fe/artemis-jakarta-service-extensions-2.33.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.activemq/artemis-jakarta-client/2.33.0/402d24fdb2e72f323950c970ec222654b9756a51/artemis-jakarta-client-2.33.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.jms/jakarta.jms-api/3.1.0/e194cf91a3f908e4846542849ac11a8e0b3c68ad/jakarta.jms-api-3.1.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.hibernate.orm/hibernate-core/6.5.3.Final/1e23c320a5d10f5eaecbd23095fca5c5c83c1fb5/hibernate-core-6.5.3.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.persistence/jakarta.persistence-api/3.1.0/66901fa1c373c6aff65c13791cc11da72060a8d6/jakarta.persistence-api-3.1.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.undertow/undertow-servlet/2.3.17.Final/5f0c26c02f877be8fa52b4ae944dac4061c9e1ab/undertow-servlet-2.3.17.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.jetty.ee10/jetty-ee10-webapp/12.0.13/d64b34a323801033334cc15bce9102e43f719e70/jetty-ee10-webapp-12.0.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.jetty.ee10/jetty-ee10-servlet/12.0.13/e1cb00629ed0d4091caad7e4ee542878d60978d2/jetty-ee10-servlet-12.0.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.servlet/jakarta.servlet-api/6.0.0/abecc699286e65035ebba9844c03931357a6a963/jakarta.servlet-api-6.0.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/javax.cache/cache-api/1.1.1/c56fb980eb5208bfee29a9a5b9d951aba076bd91/cache-api-1.1.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.activemq/artemis-jdbc-store/2.33.0/4b2e18b3736a9dad998b48107ace88edf865e6f/artemis-jdbc-store-2.33.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-dbcp2/2.12.0/45698ece9fda230d0b1c96282c03ce1ebbd6c3ce/commons-dbcp2-2.12.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.kafka/kafka-clients/3.7.1/75a75c47eb912f3fd06df62a9e4b3b554d5b2bec/kafka-clients-3.7.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.logging.log4j/log4j-to-slf4j/2.23.1/425ad1eb8a39904d2830e907a324e956fb456520/log4j-to-slf4j-2.23.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.logging.log4j/log4j-api/2.23.1/9c15c29c526d9c6783049c0a77722693c66706e1/log4j-api-2.23.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.tomcat.embed/tomcat-embed-core/10.1.30/852ff3547f179175feaff39c443e9b980ec2cc2/tomcat-embed-core-10.1.30.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.tomcat.embed/tomcat-embed-el/10.1.30/432b176aa50de87c3bbda99b0fe85523abfd1382/tomcat-embed-el-10.1.30.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.tomcat/tomcat-jdbc/10.1.30/917c55dd7173340c16631eb6cc6f6bfe12bd1766/tomcat-jdbc-10.1.30.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-aspects/6.1.13/d606215f2876e8a3ed1945db5adfbb76a7e3f0e7/spring-aspects-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaver/1.9.22.1/bca243d0af0db4758fbae45c5f4995cb5dabb612/aspectjweaver-1.9.22.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.cache2k/cache2k-spring/2.6.1.Final/cd312efb1645de91bdd8571b98273cb0acf52d15/cache2k-spring-2.6.1.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.angus/angus-mail/2.0.3/56f811522d693700013768db83b741a65da6c61c/angus-mail-2.0.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.jetty/jetty-ee/12.0.13/153c7fdabe7598e2abce3ec0832df220e19d6325/jetty-ee-12.0.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.jetty/jetty-session/12.0.13/dd79f830f79bd827ba8d7c9e3fd35e03315afbd8/jetty-session-12.0.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.jetty/jetty-security/12.0.13/c71b4755750198d3639cd26b55c32c87be568cce/jetty-security-12.0.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.jetty/jetty-server/12.0.13/f7e2f539dacb3426fef1bcd66ca7a5c13d5f6409/jetty-server-12.0.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/co.elastic.clients/elasticsearch-java/8.13.4/3c8e5b92bef09595d94dd607810a1c2697a743ad/elasticsearch-java-8.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.elasticsearch.client/elasticsearch-rest-client/8.13.4/eb5be3f924f72faaec1df2a6a3890147e00d27ec/elasticsearch-rest-client-8.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.ext/jersey-spring6/3.1.8/c63c40b0b29069890f1fbfe6d5f159fdd5ff3f9f/jersey-spring6-3.1.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.containers/jersey-container-servlet-core/3.1.8/2ea7dc7e94d134df5b6378ceb73c14d54fd5a86c/jersey-container-servlet-core-3.1.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.core/jersey-server/3.1.8/ed02e7d7a04c6bcb0653c0179d8cf56969590e8f/jersey-server-3.1.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.hibernate.validator/hibernate-validator/8.0.1.Final/e49e116b3d3928060599b176b3538bb848718e95/hibernate-validator-8.0.1.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.influxdb/influxdb-java/2.24/638b1ca7c63aa94ce7024fc7bebb1e458a3fb6f6/influxdb-java-2.24.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.liquibase/liquibase-core/4.27.0/759da7263b8b282202d8a157a0c47653b92e473e/liquibase-core-4.27.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.mongodb/mongodb-driver-reactivestreams/5.0.1/26841dc96d29883ccdd1d0f51cdaa003390b893d/mongodb-driver-reactivestreams-5.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.mongodb/mongodb-driver-sync/5.0.1/3723fc6a032986dc4cb1c4929bafa85ce9f93950/mongodb-driver-sync-5.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.neo4j.driver/neo4j-java-driver/5.23.0/a2499107e1e1e1c0b81da86dc62639294abd04f4/neo4j-java-driver-5.23.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.quartz-scheduler/quartz/2.3.2/18a6d6b5a40b77bd060b34cb9f2acadc4bae7c8a/quartz-2.3.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-orm/6.1.13/68093388cd8fca9ad2731e63bfb8de3f2604474/spring-orm-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-jdbc/6.1.13/11811219be3452cfd989c57d3de4529f6927352f/spring-jdbc-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-messaging/6.1.13/97691b76bf2bbacd07e8e2af31cd3d5aee56ce22/spring-messaging-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.session/spring-session-core/3.3.2/e2fad0635b2b7d47761bf32195c278026b98f726/spring-session-core-3.3.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/redis.clients/jedis/5.0.2/47d917ce322cef3fc1fbe7534f351e25d977e52b/jedis-5.0.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.projectreactor/reactor-test/3.6.10/db3509e21cd717517f3c85491609231a40a9288c/reactor-test-3.6.10.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.prometheus/prometheus-metrics-exposition-formats/1.2.1/64190364467197c39bcc296ec80a99f6c979a7dc/prometheus-metrics-exposition-formats-1.2.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.squareup.okhttp3/mockwebserver/4.12.0/3bc54cc5c87cd632031d0881f3c313d3799a1476/mockwebserver-4.12.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.jayway.jsonpath/json-path/2.9.0/37fe2217f577b0b68b18e62c4d17a8858ecf9b69/json-path-2.9.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.undertow/undertow-core/2.3.17.Final/b99fed301cd9840dfa220c74d3333cf34d877e68/undertow-core-2.3.17.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-oxm/6.1.13/d5d7046e9e22f0a2eae688ad1f38ba282cb15e6c/spring-oxm-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.jaxb/jaxb-runtime/4.0.5/ca84c2a7169b5293e232b9d00d1e4e36d4c3914a/jaxb-runtime-4.0.5.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.jaxb/jaxb-core/4.0.5/7b4b11ea5542eea4ad55e1080b23be436795b3/jaxb-core-4.0.5.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.xml.bind/jakarta.xml.bind-api/4.0.2/6cd5a999b834b63238005b7144136379dc36cad2/jakarta.xml.bind-api-4.0.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjrt/1.9.22.1/2b4f27c886fe697fc042f1f67eff7aa6e17e9473/aspectjrt-1.9.22.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-core-test/6.1.13/1e8de39e490b1d124c7bdde682d3d382baeb18cd/spring-core-test-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.25.3/792b270e73aa1cfc28fa135be0b95e69ea451432/assertj-core-3.25.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.awaitility/awaitility/4.2.2/7336242073ebf83fe034e42b46a403c5501b63c9/awaitility-4.2.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.cache2k/cache2k-core/2.6.1.Final/7e333caaafa2bf4e489b58537b5c4218a4e6505/cache2k-core-2.6.1.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.cache2k/cache2k-api/2.6.1.Final/6afd23d7897fff56515f0cefa6a846bdebe10bce/cache2k-api-2.6.1.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-library/2.2/cf530c8a0bc993487c64e940ae639bb4a6104dc6/hamcrest-library-2.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/junit/junit/4.13.2/8ac9e16d933b6fb43bc7f576336b8f4d7eb5ba12/junit-4.13.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/2.2/3f2bd07716a31c395e2837254f37f21f0f0ab24b/hamcrest-core-2.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest/2.2/1820c0968dba3a11a1b30669bb1f01978a91dedc/hamcrest-2.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.hsqldb/hsqldb/2.7.3/85b49338b36f3051d217295596cf92beb92e4bfb/hsqldb-2.7.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.junit.platform/junit-platform-launcher/1.10.3/2e07e6389624f3e93fb2e87aec2fdc30cc84b069/junit-platform-launcher-1.10.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-junit-jupiter/5.11.0/8e658dd339f40305ed4293db25545b5df98b171b/mockito-junit-jupiter-5.11.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.junit.jupiter/junit-jupiter-params/5.10.3/4852f4e4af9074d9214213b199751f99efeab8b9/junit-jupiter-params-5.10.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.junit.jupiter/junit-jupiter-engine/5.10.3/48c14e866bb1a87ca35d24ff068463bb202ada24/junit-jupiter-engine-5.10.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.junit.jupiter/junit-jupiter-api/5.10.3/a22aa91d1d6c69b2020a9aeb6d095ea81132bfa5/junit-jupiter-api-5.10.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.junit.platform/junit-platform-engine/1.10.3/365a320c3cfd47f3346625e541e424e35dc75c42/junit-platform-engine-1.10.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.junit.platform/junit-platform-commons/1.10.3/a353d42a2f13343a7cb80c5228ae66ff64495481/junit-platform-commons-1.10.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.junit.jupiter/junit-jupiter/5.10.3/6686d8fbf251f9bf8ecba413cab57b9e00f9134d/junit-jupiter-5.10.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-core/5.11.0/e4069fa4f4ff2c94322cfec5f2e45341c6c70aff/mockito-core-5.11.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.skyscreamer/jsonassert/1.5.3/aaa43e0823d2a0e106e8754d6a9c4ab24e05e9bc/jsonassert-1.5.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/2.2/3af797a25458550a16bf89acc8e4ab2b7f2bfce0/snakeyaml-2.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.management.j2ee/jakarta.management.j2ee-api/1.1.4/dbbe7575f97efd0b04f3a8455cf82c256c853055/jakarta.management.j2ee-api-1.1.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.transaction/jakarta.transaction-api/2.0.1/51a520e3fae406abb84e2e1148e6746ce3f80a1a/jakarta.transaction-api-2.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opensaml/opensaml-saml-impl/4.0.1/995986fd848ede1443469f3aff1f82b740224262/opensaml-saml-impl-4.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opensaml/opensaml-saml-api/4.0.1/2205aba935f4da468382a3dc5f32c3821ec1564c/opensaml-saml-api-4.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opensaml/opensaml-soap-impl/4.0.1/38bfaf5fc189774e94ead218bd1c754da295c226/opensaml-soap-impl-4.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opensaml/opensaml-profile-api/4.0.1/bece5f6d30d4051e6eeaf2b88dd1e5a13f6b28b7/opensaml-profile-api-4.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opensaml/opensaml-soap-api/4.0.1/d8e11e31cb5164788a530478e1831969e94a38b6/opensaml-soap-api-4.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opensaml/opensaml-xmlsec-impl/4.0.1/efa15ba85127ac3b20c75b8d4f04c7e92325a00a/opensaml-xmlsec-impl-4.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opensaml/opensaml-xmlsec-api/4.0.1/edb4365d3d183933cf0d0b31966ea352b8d20c60/opensaml-xmlsec-api-4.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opensaml/opensaml-security-impl/4.0.1/64568e9aa8bd7bcd76983e462f9eb2c3dcacbdce/opensaml-security-impl-4.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opensaml/opensaml-security-api/4.0.1/f3d33ca18cde2a7c7e3643aeca9f03974be9577d/opensaml-security-api-4.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opensaml/opensaml-messaging-api/4.0.1/eb9c9971f6bd2a6681a2a692a1f29a35874de389/opensaml-messaging-api-4.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opensaml/opensaml-core/4.0.1/ec3d1734137d6ccabba7d6d5e149f571beeaa673/opensaml-core-4.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-test/6.1.13/9f0038d672a513ddc201296922da13b1212dd0f7/spring-test-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.ldap/spring-ldap-core/3.2.6/b4921c4d8be536c576b684e577d54ee9fc6cf478/spring-ldap-core-3.2.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-tx/6.1.13/ed041ecf9a5f480e1b11d0b58a06d8034ff8cfea/spring-tx-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.amqp/spring-amqp/3.1.7/1fc7d6bf5fbb41c0204d29b62451e8bcf35a6d88/spring-amqp-3.1.7.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-aop/6.1.13/ad2c631e1717fdc6d91d56c06d4fd61e0215c19a/spring-aop-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.data/spring-data-commons/3.3.4/f0f6bca5b0cd7d318666e2d3f02726c615334678/spring-data-commons-3.3.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-beans/6.1.13/90bbee6278b46b145e64e5ae29316bdd459c6826/spring-beans-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.batch/spring-batch-infrastructure/5.1.2/bfc8439a45a0681f44771d3b15f5c61fe4751db7/spring-batch-infrastructure-5.1.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-expression/6.1.13/be30254712ca0549cbd539ba05c57064917253f3/spring-expression-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-core/6.1.13/ddbd765408d2665f47017c8f05a7682012f91da3/spring-core-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.vaadin.external.google/android-json/0.0.20131108.vaadin1/fa26d351fe62a6a17f5cda1287c1c6110dec413f/android-json-0.0.20131108.vaadin1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.mchange/c3p0/0.9.5.5/37dfc3021e5589d65ff2ae0becf811510b87ab01/c3p0-0.9.5.5.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven/maven-resolver-provider/3.9.4/d5e38634c1251e000f7718437973a730346bc336/maven-resolver-provider-3.9.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven/maven-model-builder/3.9.4/b12e45736ddfb51f648e1579877a293659e5a96e/maven-model-builder-3.9.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven.resolver/maven-resolver-connector-basic/1.9.14/ffeb368f5587513b29ef9771514ec36d246e65f5/maven-resolver-connector-basic-1.9.14.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven.resolver/maven-resolver-impl/1.9.14/2aa090aca572f7061e5c57f714ef0445bbb4555f/maven-resolver-impl-1.9.14.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven.resolver/maven-resolver-transport-http/1.9.14/1eb4acdce7f21526bd06654b3d7b1edf80370ce8/maven-resolver-transport-http-1.9.14.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven.resolver/maven-resolver-spi/1.9.14/a190c3d49791240c87799f29848505fc9fd8be11/maven-resolver-spi-1.9.14.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven.resolver/maven-resolver-util/1.9.14/ea6fd2997903700191711dee4448746ed30fe4b9/maven-resolver-util-1.9.14.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven.resolver/maven-resolver-api/1.9.14/bd5b7cd9d15c2efcab4d8c8215e769523e8843e4/maven-resolver-api-1.9.14.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/context-propagation/1.1.1/7c62beb1188d7458f5a4b60fcaf4a795cc290508/context-propagation-1.1.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.core/jersey-client/3.1.8/3d5cc934f54ce715ee0aea6073e687721eec6db3/jersey-client-3.1.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.inject/jersey-hk2/3.1.8/4cec532697a56b9c1634222348ba0de5ec25e8b7/jersey-hk2-3.1.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.core/jersey-common/3.1.8/46a5712b60eca0368714ecd22cdf479770b8100b/jersey-common-3.1.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2/3.0.6/12187beb6321e6a7fdc2ef4d196e16c8c58a3a1/hk2-3.0.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2-core/3.0.6/78dfb2117c3148e357a0cec8f514e60bbf689efd/hk2-core-3.0.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2-runlevel/3.0.6/3c347e9bb20f13d98b72ae2b4fc84f14bcbb187e/hk2-runlevel-3.0.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2-locator/3.0.6/92d5c92c9f23bea4b8681c6f8d6ba3d708619f81/hk2-locator-3.0.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2-api/3.0.6/5a5152dea2c43384f5c07985eb27140134074ecb/hk2-api-3.0.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2-utils/3.0.6/b3187d0673c0fd52de197e52c62545c34d4eda29/hk2-utils-3.0.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.inject/jakarta.inject-api/2.0.1/4c28afe1991a941d7702fe1362c365f0a8641d1e/jakarta.inject-api-2.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opensaml/opensaml-storage-api/4.0.1/4e46a7f965ac9f91976b0f298fd4d4e69e9056db/opensaml-storage-api-4.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/net.shibboleth.utilities/java-support/8.0.0/298f946e93922d789b6231599a446cea9dbbe80e/java-support-8.0.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.santuario/xmlsec/2.1.4/cb43326f02e3e77526c24269c8b5d3cc3f7f6653/xmlsec-2.1.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.cloud/google-cloud-monitoring/3.43.0/8423352e76f7e3b8c363cfef3298af4284163c71/google-cloud-monitoring-3.43.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.auth/google-auth-library-oauth2-http/1.23.0/f9ebd75a55b8e2cfa62e1f66d04a62b46a2f3b70/google-auth-library-oauth2-http-1.23.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.http-client/google-http-client-gson/1.44.1/f3b8967c6f7078da6380687859d0873105f84d39/google-http-client-gson-1.44.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.http-client/google-http-client/1.44.1/d8956bacb8a4011365fa15a690482c49a70c78c5/google-http-client-1.44.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.httpcomponents/httpclient/4.5.14/1194890e6f56ec29177673f2f12d0b8e627dec98/httpclient-4.5.14.jar:/home/runner/.gradle/caches/modules-2/files-2.1/commons-codec/commons-codec/1.16.1/47bd4d333fba53406f6c6c51884ddbca435c8862/commons-codec-1.16.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opencensus/opencensus-contrib-http-util/0.31.1/3c13fc5715231fadb16a9b74a44d9d59c460cfa8/opencensus-contrib-http-util-0.31.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/33.1.0-jre/9b7ed39143d59e8eabcc6f91ffe4d23db2efe558/guava-33.1.0-jre.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.api.grpc/proto-google-cloud-monitoring-v3/3.43.0/191267f5c2995f7cbb8863f0f0e8f2ea55c99739/proto-google-cloud-monitoring-v3-3.43.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.code.findbugs/jsr305/3.0.2/25ea2e8b0c338a877313bd4672d3fe056ea78f0d/jsr305-3.0.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.dropwizard.metrics/metrics-graphite/4.2.27/fe71b40878454ea54a091fefca42df04de8a1b75/metrics-graphite-4.2.27.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.dropwizard.metrics/metrics-jmx/4.2.27/10f1376905dee23aefd18bb83fa90654acc62742/metrics-jmx-4.2.27.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.dropwizard.metrics/metrics-core/4.2.27/55d29cfeb32ade650d9e73b94a81e4c85a5cafac/metrics-core-4.2.27.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.velocity/velocity-engine-core/2.2/68d899cb70cd27d495562fa808feb2da4926d38f/velocity-engine-core-2.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven.resolver/maven-resolver-named-locks/1.9.14/71cf74d91b4f6de1bff8fc1fafb401d9ac42b1b8/maven-resolver-named-locks-1.9.14.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.zaxxer/HikariCP-java7/2.4.13/3e441eddedb374d4de8e3abbb0c90997f51cc97b/HikariCP-java7-2.4.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.activemq/artemis-core-client/2.33.0/31188ee6cf5b28736d7d22759cee89f269b1762f/artemis-core-client-2.33.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.activemq/artemis-selector/2.33.0/b2a96664e487de682f5349b53a8c3b3e37e619a4/artemis-selector-2.33.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.activemq/artemis-journal/2.33.0/71f43d0dad511aabedcaa8fc75ce0f4384fa7f98/artemis-journal-2.33.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.activemq/artemis-commons/2.33.0/d210a181d855171857c93c364dd7eb3113cf094c/artemis-commons-2.33.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.jetty/jetty-xml/12.0.13/3caacf30834177539fb020b27b4d0154ca544e54/jetty-xml-12.0.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.jetty/jetty-http/12.0.13/4cc207e1006a747796cb99072087d58182193ad8/jetty-http-12.0.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.jetty/jetty-io/12.0.13/a8377234b4a3967ee9ecc65ee25ef93dcffeb0f8/jetty-io-12.0.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.netflix.spectator/spectator-reg-atlas/1.7.19/813185300cfdfdac2a03199daa13c3abb3e3c158/spectator-reg-atlas-1.7.19.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.rabbitmq/amqp-client/5.21.0/70797e8a66e800391940edcf21f31423b9768f1/amqp-client-5.21.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.graphql-java/graphql-java/22.1/567a967b71fa367308847d747c571413d12ef48c/graphql-java-22.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.graphql-java/java-dataloader/3.3.0/1786c5efbf871395a32cbce1a2114d6788ac4f53/java-dataloader-3.3.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.jetty/jetty-util/12.0.13/ad63179e37e1037b901feaa9d7423c27f70fcdfe/jetty-util-12.0.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.netflix.spectator/spectator-ext-ipc/1.7.19/c82d228d53c70179bd3eb58224a9e50b7bbb78ff/spectator-ext-ipc-1.7.19.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.netflix.spectator/spectator-api/1.7.19/73c6a38aef42f2a8435c188e82fc3912f5c1cf39/spectator-api-1.7.19.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.couchbase.client/java-client/3.6.3/6227da2931947e962d94804a9021b4557a7aa585/java-client-3.6.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.couchbase.client/core-io/2.6.3/da342aa9906a2d6c3a1ed6ac07e8900d05108f6d/core-io-2.6.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.slf4j/slf4j-api/2.0.16/172931663a09a1fa515567af5fbef00897d3c04/slf4j-api-2.0.16.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.httpcomponents/httpcore/4.4.16/51cf043c87253c9f58b539c9f7e44c8894223850/httpcore-4.4.16.jar:/home/runner/.gradle/caches/modules-2/files-2.1/net.bytebuddy/byte-buddy/1.14.19/4c0c637b8f47dc08f89240e6f59900011752c97b/byte-buddy-1.14.19.jar:/home/runner/.gradle/caches/modules-2/files-2.1/net.bytebuddy/byte-buddy-agent/1.14.19/154da3a65b4f4a909d3e5bdec55d1b2b4cbb6ce1/byte-buddy-agent-1.14.19.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.fasterxml/classmate/1.7.0/e98374da1f2143ac8e6e0a95036994bb19137a3/classmate-1.7.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.opencsv/opencsv/5.9/284ea0b60a24b71a530100783185e7d547ab5339/opencsv-5.9.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-configuration2/2.9.0/adc3ee6b84fc62a6e75e901d080adacb72aac61e/commons-configuration2-2.9.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-text/1.11.0/2bb044b7717ec2eccaf9ea7769c1509054b50e9a/commons-text-1.11.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven/maven-artifact/3.9.4/9738999a0459221e758ebe728449c43567d7fecc/maven-artifact-3.9.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-lang3/3.14.0/1ed471194b02f2c6cb734a0cd6f6f107c673afae/commons-lang3-3.14.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.12.0/458563f69fbdaebf7daadfe10dc3a22e42a7de50/commons-pool2-2.12.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.code.gson/gson/2.10.1/b3add478d4382b78ea20b1671390a858002feb6c/gson-2.10.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.h2database/h2/2.2.224/7bdade27d8cd197d9b5ce9dc251f41d2edc5f7ad/h2-2.2.224.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.httpcomponents/httpasyncclient/4.1.5/cd18227f1eb8e9a263286c1d7362ceb24f6f9b32/httpasyncclient-4.1.5.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.httpcomponents/httpcore-nio/4.4.16/cd21c80a9956be48c4c1cfd2f594ba02857d0927/httpcore-nio-4.4.16.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.angus/angus-activation/2.0.2/41f1e0ddd157c856926ed149ab837d110955a9fc/angus-activation-2.0.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.mail/jakarta.mail-api/2.1.3/a327aa5f514ba86e80d54584417d7376ed2bde0e/jakarta.mail-api-2.1.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.activation/jakarta.activation-api/2.1.3/fa165bd70cda600368eee31555222776a46b881f/jakarta.activation-api-2.1.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.annotation/jakarta.annotation-api/2.1.1/48b9bda22b091b1f48b13af03fe36db3be6e1ae3/jakarta.annotation-api-2.1.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.parsson/parsson/1.0.5/f68020271ff70f79412f70ca45973703b6e907c/parsson-1.0.5.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.json/jakarta.json-api/2.1.3/4febd83e1d9d1561d078af460ecd19532383735c/jakarta.json-api-2.1.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.validation/jakarta.validation-api/3.0.2/92b6631659ba35ca09e44874d3eb936edfeee532/jakarta.validation-api-3.0.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.ext/jersey-entity-filtering/3.1.8/d253b6f7a0abbc937f2546e93b45c9c75a769d34/jersey-entity-filtering-3.1.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/jakarta.ws.rs/jakarta.ws.rs-api/3.1.0/15ce10d249a38865b58fc39521f10f29ab0e3363/jakarta.ws.rs-api-3.1.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.jboss.xnio/xnio-nio/3.8.16.Final/9aab17706a371a212fd051b09c7959d29d051379/xnio-nio-3.8.16.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.jboss.xnio/xnio-api/3.8.16.Final/7c98c649a4583523c23cc0a7e62ddace1f486b54/xnio-api-3.8.16.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.wildfly.client/wildfly-client-config/1.0.1.Final/2a803b23c40a0de0f03a90d1fd3755747bc05f4b/wildfly-client-config-1.0.1.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.jboss.threads/jboss-threads/3.5.0.Final/dd23d4788b3eafe9597ef3fe028e46ceb293ba8d/jboss-threads-3.5.0.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.jboss.logging/jboss-logging/3.5.3.Final/c88fc1d8a96d4c3491f55d4317458ccad53ca663/jboss-logging-3.5.3.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/net.minidev/json-smart/2.5.1/4c11d2808d009132dfbbf947ebf37de6bf266c8e/json-smart-2.5.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-core/1.5.8/3fce599197de3b6f387cc9bee412ead2b4994a46/logback-core-1.5.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.mongodb/mongodb-driver-core/5.0.1/f9a18eb8015b9e05f0312c9e5752dcdc01dbd784/mongodb-driver-core-5.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.mongodb/bson-record-codec/5.0.1/7d856a5b4250b22ec011661b4fca260663b452d5/bson-record-codec-5.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.mongodb/bson/5.0.1/757035ed1e9c94fa95ee13b1f9a0af93269ff20/bson-5.0.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.projectreactor.addons/reactor-pool/1.0.8/96648560a264afca6e33128404e99cb12d06cd76/reactor-pool-1.0.8.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.projectreactor.netty/reactor-netty-core/1.1.22/8356b59b29f86e7142c9daca0434653a64ae64b/reactor-netty-core-1.1.22.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.projectreactor/reactor-core/3.6.10/6860a576ae0bd1957c5d4c87e861025248818c01/reactor-core-3.6.10.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.reactivestreams/reactive-streams/1.0.4/3864a1320d97d7b045f729a326e1e077661f31b7/reactive-streams-1.0.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.retry/spring-retry/2.0.9/fc605474a6002a501a6d0ea67c04df1db14d22af/spring-retry-2.0.9.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.tomcat/tomcat-annotations-api/10.1.30/9f549bd377f6d83eeab43239e6cb1bd0ca69fb75/tomcat-annotations-api-10.1.30.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven/maven-model/3.9.4/5b79d873cf6d13b3fc4020eac04e2a62ebbfa0aa/maven-model-3.9.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven/maven-repository-metadata/3.9.4/ef368d45a2caa54634de221540994ca2d810c4c9/maven-repository-metadata-3.9.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.codehaus.plexus/plexus-utils/3.5.1/c6bfb17c97ecc8863e88778ea301be742c62b06d/plexus-utils-3.5.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.guava/failureaccess/1.0.2/c4a06a64e650562f30b7bf9aaec1bfed43aca12b/failureaccess-1.0.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/b421526c5f297295adef1c886e5246c39d4ac629/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.checkerframework/checker-qual/3.42.0/638ec33f363a94d41a4f03c3e7d3dcfba64e402d/checker-qual-3.42.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.errorprone/error_prone_annotations/2.26.1/c1fde57694bdc14e8618899aaa6e857d9465d7de/error_prone_annotations-2.26.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.j2objc/j2objc-annotations/3.0.0/7399e65dd7e9ff3404f4535b2f017093bdb134c7/j2objc-annotations-3.0.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.cryptacular/cryptacular/1.2.4/4994c015d87886212683245d13e87f6fb903a760/cryptacular-1.2.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.bouncycastle/bcpkix-jdk15on/1.64/3dac163e20110817d850d17e0444852a6d7d0bd7/bcpkix-jdk15on-1.64.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.bouncycastle/bcprov-jdk15on/1.64/1467dac1b787b5ad2a18201c0c281df69882259e/bcprov-jdk15on-1.64.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.fasterxml.woodstox/woodstox-core/6.7.0/ebbbdee43bb8c49f673f35b5697ae6d8515a4711/woodstox-core-6.7.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.activemq/artemis-lockmanager-api/2.33.0/7d3c17131b976abf5936be628cf92855b9ce491b/artemis-lockmanager-api-2.33.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.zipkin.reporter2/zipkin-sender-okhttp3/3.4.2/f447dcc8709713f63404f711781f697cd7ae21f8/zipkin-sender-okhttp3-3.4.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.zipkin.reporter2/zipkin-reporter/3.4.2/8be3231724bc6f24a6bf5e0466b5c7b563c29cd9/zipkin-reporter-3.4.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.zipkin.zipkin2/zipkin/2.27.1/74b5227ae2fe515217107fd228707e4d960ec3ec/zipkin-2.27.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.zipkin.aws/brave-propagation-aws/1.2.5/828490df0b6be58b6de4d3dd3b3a395fb8243f45/brave-propagation-aws-1.2.5.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.zipkin.brave/brave-context-slf4j/6.0.3/a863730f5af570514b4fa4b920c8455c9556d9cd/brave-context-slf4j-6.0.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.zipkin.brave/brave-instrumentation-http/6.0.3/bc58655bd14d2f8e8975c5951fecab202e1a1e5/brave-instrumentation-http-6.0.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.zipkin.brave/brave/6.0.3/2d626aaf5162463edefcc88291799d5ea9204630/brave-6.0.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.datastax.oss/native-protocol/1.5.1/97e812373a5fe7667384e7ad67819d2c71878bf8/native-protocol-1.5.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.datastax.oss/java-driver-shaded-guava/25.1-jre-graal-sub-1/522771d14d6b7dba67056a39db33f205ffbed6a4/java-driver-shaded-guava-25.1-jre-graal-sub-1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.jaxb/txw2/4.0.5/f36a4ef12120a9bb06d766d6a0e54b144fd7ed98/txw2-4.0.5.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.sun.istack/istack-commons-runtime/4.1.2/18ec117c85f3ba0ac65409136afa8e42bc74e739/istack-commons-runtime-4.1.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.squareup.okhttp3/logging-interceptor/4.12.0/e922c1f14d365c0f2bed140cc0825e18462c2778/logging-interceptor-4.12.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-exporter-sender-okhttp/1.37.0/821912a6b2641ce1b07220067d874c8bcfe4c45b/opentelemetry-exporter-sender-okhttp-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.squareup.retrofit2/converter-moshi/2.9.0/db0979801926e6d39bc2478736145f9761c3e034/converter-moshi-2.9.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.squareup.retrofit2/retrofit/2.9.0/d8fdfbd5da952141a665a403348b74538efc05ff/retrofit-2.9.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.squareup.okhttp3/okhttp/4.12.0/2f4525d4a200e97e1b87449c2cd9bd2e25b7e8cd/okhttp-4.12.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.squareup.okio/okio-jvm/3.6.0/5600569133b7bdefe1daf9ec7f4abeb6d13e1786/okio-jvm-3.6.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-jdk8/1.9.25/20d44e880a284f7b5cd99dd69450b403073f49b2/kotlin-stdlib-jdk8-1.9.25.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-jdk7/1.9.25/1c166692314a2639e5edfed0d23ed7eee4a5c7a5/kotlin-stdlib-jdk7-1.9.25.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.9.25/f700a2f2b8f0d6d0fde48f56d894dc722fb029d7/kotlin-stdlib-1.9.25.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.micrometer/micrometer-commons/1.13.4/edcf69518a4c382c48e19c7fb7d4aedfb115c0c3/micrometer-commons-1.13.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-codec-http2/4.1.113.Final/e7e86e501158596e13ca3c2acebd832137228455/netty-codec-http2-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-handler-proxy/4.1.113.Final/68d6c8a37a874b8094f3856b0070b9fc3cb862e/netty-handler-proxy-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-codec-http/4.1.113.Final/4851935f2cf98b34499c46725a51c45e6804c67/netty-codec-http-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-resolver-dns-native-macos/4.1.113.Final/3c7ad5582227667c01fb46480bda9e4ea5734494/netty-resolver-dns-native-macos-4.1.113.Final-osx-x86_64.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-resolver-dns-classes-macos/4.1.113.Final/ff3ba7ed178595704d653c83a8315ae61e2a63e2/netty-resolver-dns-classes-macos-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-resolver-dns/4.1.113.Final/41285e5dcaf43ffaa8809cc3f9104778595a77e8/netty-resolver-dns-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-handler/4.1.113.Final/df48be9ca640df01c66c1ee88fc2cd91987c31ab/netty-handler-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-transport-native-epoll/4.1.113.Final/a26dddb61a54c5d939c2e35197232f618322c1b1/netty-transport-native-epoll-4.1.113.Final-linux-x86_64.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-transport-classes-epoll/4.1.113.Final/314f680c386eddbb944cad1c63a116b9b3b75e42/netty-transport-classes-epoll-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-transport-native-kqueue/4.1.113.Final/673f7bdb8083d833d72074026107365264bd4bab/netty-transport-native-kqueue-4.1.113.Final-osx-x86_64.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-transport-classes-kqueue/4.1.113.Final/33dda3359bff69d60a531ee68ebaa06a5775f1b7/netty-transport-classes-kqueue-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-transport-native-unix-common/4.1.113.Final/e8d1d4ba444e203fd8af42a9d22e1032d89daa32/netty-transport-native-unix-common-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-codec-socks/4.1.113.Final/39efd7a056ae0ede07e73081db9572c86f252195/netty-codec-socks-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-codec-dns/4.1.113.Final/af2d096266a680455a6432157b3ce0bc8c5b3257/netty-codec-dns-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-codec/4.1.113.Final/370ab9b7c1b31b32423498331c1f723cda3332cb/netty-codec-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-transport/4.1.113.Final/8ba0a07b6ca61aefd607ca2a91ebd1cce28f5e3d/netty-transport-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-buffer/4.1.113.Final/69462f1f5528fb95477fa3b15a1e755ada0df66/netty-buffer-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-resolver/4.1.113.Final/ffe3172485dd1e433271a60195d4a26fd9398be7/netty-resolver-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-common/4.1.113.Final/1a7fe68aa349746008e5cff490aa6077728aac5a/netty-common-4.1.113.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.netty/netty-tcnative-classes/2.0.66.Final/9588bd2f891157538a78d86c945aa34bf9308dda/netty-tcnative-classes-2.0.66.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-exporter-otlp-common/1.37.0/444d869b5773695c6fb0192d77b1304361e6a765/opentelemetry-exporter-otlp-common-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-exporter-common/1.37.0/6359022f97208fbec5f458749611e37fa3fc9404/opentelemetry-exporter-common-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-sdk-extension-autoconfigure-spi/1.37.0/bb9097589c4e4569e77e634477baabc76a755bc4/opentelemetry-sdk-extension-autoconfigure-spi-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-sdk/1.37.0/e71abf2eaa1b7f91b9689d86d919b7d1c00faa3c/opentelemetry-sdk-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-sdk-trace/1.37.0/9875634a47d8e1e150df963ceba8a707547ab00a/opentelemetry-sdk-trace-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-sdk-metrics/1.37.0/49eb5a745be2bce3663a1a4f2ebc963e8a78620/opentelemetry-sdk-metrics-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-sdk-logs/1.37.0/d1b3fe627a0343c35a1b803f68ad596a1b231a25/opentelemetry-sdk-logs-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-sdk-common/1.37.0/7e1421111afbffca43f6aa65d2a60a606bc1da5b/opentelemetry-sdk-common-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-extension-trace-propagators/1.37.0/72e9f95ec089cbf711ac9d5cf37a131e34d709a/opentelemetry-extension-trace-propagators-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry.instrumentation/opentelemetry-instrumentation-api-semconv/1.33.3-alpha/9b26012e6c08d39441e2f44af181311bbd9bbb09/opentelemetry-instrumentation-api-semconv-1.33.3-alpha.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry.instrumentation/opentelemetry-instrumentation-api/1.33.3/133644185f680998c454ed738afcb459b211f6db/opentelemetry-instrumentation-api-1.33.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-api-incubator/1.38.0-alpha/27a5bf8657cf41181c3fd6768f1e86468a73ed9c/opentelemetry-api-incubator-1.38.0-alpha.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-api/1.37.0/9b4bdeb434885fdf417967ddea37afe4d21fab4e/opentelemetry-api-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry/opentelemetry-context/1.37.0/f180a3855a9dd8c1cf4fddabcfbd4d0a55c4996b/opentelemetry-context-1.37.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.prometheus/prometheus-metrics-core/1.2.1/362330b5934a128e91e331f1497cd275fec1a81c/prometheus-metrics-core-1.2.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.prometheus/prometheus-metrics-config/1.2.1/bcccb14176161671c4cb858b0ca50d680237fdbe/prometheus-metrics-config-1.2.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.prometheus/prometheus-metrics-model/1.2.1/99caac1a3f974de6bc9882fbf6a09ea055733c7b/prometheus-metrics-model-1.2.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.prometheus/prometheus-metrics-tracer-common/1.2.1/74cc4ac3226a3937d6e5c74c06454258e7901cec/prometheus-metrics-tracer-common-1.2.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.prometheus/prometheus-metrics-shaded-protobuf/1.2.1/2b8ace486645dbaba1f3a694bd3a081f4d7a3aa5/prometheus-metrics-shaded-protobuf-1.2.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.prometheus/simpleclient_common/0.16.0/a09a8c790a20309b942a9fdbfe77da22407096e6/simpleclient_common-0.16.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.prometheus/simpleclient/0.16.0/28b0eaf7c500c506976da8d0fc9cad6c278e8d87/simpleclient-0.16.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.prometheus/simpleclient_tracer_otel/0.16.0/cc3d2b7b7cb6f077e3b1ee1d3e99eb54fddfa151/simpleclient_tracer_otel-0.16.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.prometheus/simpleclient_tracer_otel_agent/0.16.0/9d724771e339ff7ec6cd7c0cc170d3470904c5/simpleclient_tracer_otel_agent-0.16.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.prometheus/simpleclient_tracer_common/0.16.0/dec00ef7c6155c4ca1109ec8248f7ff58d8f6cd3/simpleclient_tracer_common-0.16.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.querydsl/querydsl-apt/5.1.0/3b1cbe05851840b5dc926833908747a193c097cc/querydsl-apt-5.1.0-jakarta.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.querydsl/querydsl-codegen/5.1.0/a8504ea51fbc2258543cedab6a37fe6039b2d20a/querydsl-codegen-5.1.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.querydsl/querydsl-core/5.1.0/be322c3fe98de8e7c204afb8860bfabd81a3bafd/querydsl-core-5.1.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.querydsl/codegen-utils/5.1.0/ba401554d613760617992eafb6cdba175c811e6f/codegen-utils-5.1.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework/spring-jcl/6.1.13/37291ff008a66a9dbf2c98e11bd468cfadaa7ebc/spring-jcl-6.1.13.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.springframework.security/spring-security-crypto/6.3.3/a44e901cd1cfa1d6c20d30b69b83499e12e607a1/spring-security-crypto-6.3.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.typesafe/config/1.4.1/19058a07624a87f90d129af7cd9c68bee94535a9/config-1.4.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.github.jnr/jnr-posix/3.1.15/f7d6737adcbd5925d625b8f99166de2cbf13caac/jnr-posix-3.1.15.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.hdrhistogram/HdrHistogram/2.2.2/7959933ebcc0f05b2eaa5af0a0c8689fa257b15c/HdrHistogram-2.2.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.hibernate.common/hibernate-commons-annotations/6.0.6.Final/77a5f94b56d49508e0ee334751db5b78e5ccd50c/hibernate-commons-annotations-6.0.6.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.smallrye/jandex/3.1.2/a6c1c89925c7df06242b03dddb353116ceb9584c/jandex-3.1.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.antlr/antlr4-runtime/4.13.0/5a02e48521624faaf5ff4d99afc88b01686af655/antlr4-runtime-4.13.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.msgpack/msgpack-core/0.9.6/d829f746a66769787e5d7ecab47ba0e4477050e2/msgpack-core-0.9.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.json/json/20231013/e22e0c040fe16f04ffdb85d851d77b07fc05ea52/json-20231013.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.github.luben/zstd-jni/1.5.6-3/823b794106e4bcb80110f49408d1641231f25927/zstd-jni-1.5.6-3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.lz4/lz4-java/1.8.0/4b986a99445e49ea5fbf5d149c4b63f6ed6c6780/lz4-java-1.8.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.xerial.snappy/snappy-java/1.1.10.5/ac605269f3598506196e469f1fb0d7ed5c55059e/snappy-java-1.1.10.5.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.rocksdb/rocksdbjni/7.9.2/6409b667493149191b09fe1fce94bada6096a3e9/rocksdbjni-7.9.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-collections4/4.4/62ebe7544cb7164d87e0637a2a6a2bdc981395e8/commons-collections4-4.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.mchange/mchange-commons-java/0.2.19/7a4bee38ea02bd7dee776869b19fb3f6861d6acf/mchange-commons-java-0.2.19.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.tomcat/tomcat-juli/10.1.30/ad32aa18c9bcc664a718e2e653034e2fe08a6b6b/tomcat-juli-10.1.30.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.codehaus.plexus/plexus-interpolation/1.26/25b919c664b79795ccde0ede5cee0fd68b544197/plexus-interpolation-1.26.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.maven/maven-builder-support/3.9.4/671110e56110d5c89eda904f198719a2b5fa4a21/maven-builder-support-3.9.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.sisu/org.eclipse.sisu.inject/0.3.5/d4265dd4f0f1d7a06d80df5a5f475d5ff9c17140/org.eclipse.sisu.inject-0.3.5.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.codehaus.woodstox/stax2-api/4.2.2/b0d746cadea928e5264f2ea294ea9a1bf815bbde/stax2-api-4.2.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.fusesource.hawtbuf/hawtbuf/1.11/8f0e50ad8bea37b84b698ec40cce09e47714a63e/hawtbuf-1.11.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/spring-bridge/3.0.6/e7047f31108550310f1ed9c2814caea58d875ccc/spring-bridge-3.0.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.dynatrace.metric.util/dynatrace-metric-utils-java/2.2.1/a25d8db688874b00aef7539d3bcefda603024c60/dynatrace-metric-utils-java-2.2.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/info.ganglia.gmetric4j/gmetric4j/1.0.10/3d62003123b586adb86cb028cc0f8a8c3a701d81/gmetric4j-1.0.10.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry.proto/opentelemetry-proto/1.2.0-alpha/aab7c61780ea1313bd0382b62080d076671dfe37/opentelemetry-proto-1.2.0-alpha.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.signalfx.public/signalfx-java/1.0.45/5939ab646bae54cd6c831e541045bf35f50919f8/signalfx-java-1.0.45.jar:/home/runner/.gradle/caches/modules-2/files-2.1/aopalliance/aopalliance/1.0/235ba8b489512805ac13a8f9ea77a1ca5ebe3e8/aopalliance-1.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.zipkin.contrib.brave-propagation-w3c/brave-propagation-tracecontext/0.2.0/bdc26787eb3bf99e7172b53df4e170e9a067b44/brave-propagation-tracecontext-0.2.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opentelemetry.semconv/opentelemetry-semconv/1.23.1-alpha/218e361772670212a46be5940010222d68e66f2a/opentelemetry-semconv-1.23.1-alpha.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.objenesis/objenesis/3.3/1049c09f1de4331e8193e579448d0916d75b7631/objenesis-3.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.thoughtworks.qdox/qdox/2.1.0/64dd4d16364d1eaecba9f6c4c0d6dbcef8e8160/qdox-2.1.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.nimbusds/nimbus-jose-jwt/9.37.3/700f71ffefd60c16bd8ce711a956967ea9071cec/nimbus-jose-jwt-9.37.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.latencyutils/LatencyUtils/2.0.3/769c0b82cb2421c8256300e907298a9410a2a3d3/LatencyUtils-2.0.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.github.jnr/jnr-ffi/2.2.11/bcf004ce358c87fc4cd2853b658d336348d0370f/jnr-ffi-2.2.11.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.github.jnr/jnr-constants/0.10.3/af19ec7359dd72cbc7869c00bf7cdfa4c308e985/jnr-constants-0.10.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.squareup.moshi/moshi/1.8.0/752e7b187599d3ccb174d00ba7235e29add736be/moshi-1.8.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opencensus/opencensus-api/0.31.1/66a60c7201c2b8b20ce495f0295b32bb0ccbbc57/opencensus-api-0.31.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-context/1.62.2/69e86c35140b3b1718d65635bb54ccecc4c12f14/grpc-context-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-api/1.62.2/a93b6ee3761d48edd9a9279f20a58be1a245ad01/grpc-api-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-stub/1.62.2/fc1e85697502d96d6c912e8dd2a56f46f1aba050/grpc-stub-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-protobuf/1.62.2/15aaf31c8d16c3c1c695223d3bd22b75c6405a83/grpc-protobuf-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-protobuf-lite/1.62.2/9d807d2a0e34bd7284a5336186f57cf241090920/grpc-protobuf-lite-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.api/api-common/2.30.0/c0621415b79825a4745d57b9f0610be202ef4255/api-common-2.30.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.auto.value/auto-value-annotations/1.10.4/9679de8286eb0a151db6538ba297a8951c4a1224/auto-value-annotations-1.10.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java/3.25.3/d3200261955f3298e0d85c9892201e70492ce8eb/protobuf-java-3.25.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.api.grpc/proto-google-common-protos/2.38.0/53f7972acb7a89ae6a9bd6f4f7d2743107940e87/proto-google-common-protos-2.38.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.api/gax/2.47.0/7aae7101d5b7b6cc3858ba5d23deff61749f9d9a/gax-2.47.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.auth/google-auth-library-credentials/1.23.0/a50ee3611922a0eea9d421c6ddb1db031972a7dc/google-auth-library-credentials-1.23.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.api/gax-grpc/2.47.0/7b34f26bd4f79f81eaebd364d2fd19c3537175d3/gax-grpc-2.47.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-inprocess/1.62.2/eff7a21027f8205334c22629cd8c2d38619b95cf/grpc-inprocess-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-core/1.62.2/5808049a5e33eba6f248a68d58e75399a68f2784/grpc-core-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.android/annotations/4.1.1.4/a1678ba907bf92691d879fef34e1a187038f9259/annotations-4.1.1.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.codehaus.mojo/animal-sniffer-annotations/1.23/3c0daebd5f0e1ce72cc50c818321ac957aeb5d70/animal-sniffer-annotations-1.23.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-alts/1.62.2/539c66c5fc83ed2fd356c4a94b41d8b1a2373ad6/grpc-alts-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-grpclb/1.62.2/6007272964ba7afd0ee926f8de8d3badc7ab9f4e/grpc-grpclb-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.protobuf/protobuf-java-util/3.25.3/c2284abc8c484d64ee5cb79bf61d5b7a819f6d50/protobuf-java-util-3.25.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.conscrypt/conscrypt-openjdk-uber/2.5.2/d858f142ea189c62771c505a6548d8606ac098fe/conscrypt-openjdk-uber-2.5.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-auth/1.62.2/5bc444f4e23ed7a8bafdf5eca700d0fd28a44c8f/grpc-auth-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-netty-shaded/1.62.2/a714ecbed7be23639d861015125b6b921481bc97/grpc-netty-shaded-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-util/1.62.2/98c4138f09fb57c3ad6cbeffb31ed73e302038f7/grpc-util-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.perfmark/perfmark-api/0.27.0/f86f575a41b091786a4b027cd9c0c1d2e3fc1c01/perfmark-api-0.27.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-googleapis/1.62.2/b70a7127144ca2a38dacc18b96c9ad2cdc047676/grpc-googleapis-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-xds/1.62.2/40d7036c6ae1aa694d754fde3560a5b29eda9574/grpc-xds-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.opencensus/opencensus-proto/0.2.0/c05b6b32b69d5d9144087ea0ebc6fab183fb9151/opencensus-proto-0.2.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.grpc/grpc-services/1.62.2/9c323306c41d52641114987aff2ef2adcb889080/grpc-services-1.62.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.google.re2j/re2j/1.7/2949632c1b4acce0d7784f28e3152e9cf3c2ec7a/re2j-1.7.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.threeten/threetenbp/1.6.9/39c822e33f202e7c25b54172d8235d484b4966fc/threetenbp-1.6.9.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.wildfly.common/wildfly-common/1.5.4.Final/735ceee5616d5143bac1bc740e444697073c002f/wildfly-common-1.5.4.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/net.minidev/accessors-smart/2.5.1/19b820261eb2e7de7d5bde11d1c06e4501dd7e5f/accessors-smart-2.5.1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.jgroups/jgroups/5.3.2.Final/4155114e89e8c33523df336c91aff70e5d361446/jgroups-5.3.2.Final.jar:/home/runner/.gradle/caches/modules-2/files-2.1/de.dentrassi.crypto/pem-keystore/2.3.0/945587a5930d1fa7b655c46ce4055a5fb8348121/pem-keystore-2.3.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.bouncycastle/bcpkix-jdk18on/1.77/ed953791ba0229747dd0fd9911e3d76a462acfd3/bcpkix-jdk18on-1.77.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.bouncycastle/bcutil-jdk18on/1.77/de3eaef351545fe8562cf29ddff4a403a45b49b7/bcutil-jdk18on-1.77.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.bouncycastle/bcprov-jdk18on/1.77/2cc971b6c20949c1ff98d1a4bc741ee848a09523/bcprov-jdk18on-1.77.jar:/home/runner/.gradle/caches/modules-2/files-2.1/commons-beanutils/commons-beanutils/1.9.4/d52b9abcd97f38c81342bb7e7ae1eee9b73cba51/commons-beanutils-1.9.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.jctools/jctools-core/4.0.2/e8c05d02ac3af90186ba74463be581dac0c110e6/jctools-core-4.0.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/commons-collections/commons-collections/3.2.2/8ad72fe39fa8c91eaaf12aadb21e0c3661fe26d5/commons-collections-3.2.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.apache.activemq/activemq-artemis-native/2.0.0/a1bdd3cea7822f3b90063456b0c9928702076bd1/activemq-artemis-native-2.0.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/osgi-resource-locator/1.0.3/de3b21279df7e755e38275137539be5e2c80dd58/osgi-resource-locator-1.0.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/class-model/3.0.6/cdb59ed7b763f2fbee0a5595b2d1bad91d22f27f/class-model-3.0.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.javassist/javassist/3.30.2-GA/284580b5e42dfa1b8267058566435d9e93fae7f7/javassist-3.30.2-GA.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.opentest4j/opentest4j/1.3.0/152ea56b3a72f655d4fd677fc0ef2596c3dd5e6e/opentest4j-1.3.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.acplt.remotetea/remotetea-oncrpc/1.1.2/705c490ad22ff4627389853439f9decf5ee69be/remotetea-oncrpc-1.1.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.tdunning/t-digest/3.2/2ab94758b0276a8a26102adf8d528cf6d0567b9a/t-digest-3.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.atteo/evo-inflector/1.3/4cf8b5f363c60e63f8b7688ac053590460f2768e/evo-inflector-1.3.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.github.stephenc.jcip/jcip-annotations/1.0-1/ef31541dd28ae2cefdd17c7ebf352d93e9058c63/jcip-annotations-1.0-1.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.github.jnr/jffi/1.3.9/b776ea131fa693af2c943368b52acf94131cbd7/jffi-1.3.9.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.github.jnr/jffi/1.3.9/163d683f80c06911f3e770c723d6e399e4c59448/jffi-1.3.9-native.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm-util/9.2/fbc178fc5ba3dab50fd7e8a5317b8b647c8e8946/asm-util-9.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm-commons/9.6/f1a9e5508eff490744144565c47326c8648be309/asm-commons-9.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm-analysis/9.2/7487dd756daf96cab9986e44b9d7bcb796a61c10/asm-analysis-9.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm-tree/9.6/c0cdda9d211e965d2a4448aa3fd86110f2f8c2de/asm-tree-9.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm/9.6/aa205cf0a06dbd8e04ece91c0b37c3f5d567546a/asm-9.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.github.jnr/jnr-a64asm/1.0.0/a1cb8dbe71b5a6a0288043c3ba3ca64545be165/jnr-a64asm-1.0.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.github.jnr/jnr-x86asm/1.0.2/6936bbd6c5b235665d87bd450f5e13b52d4b48/jnr-x86asm-1.0.2.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2.external/aopalliance-repackaged/3.0.6/e3c3f17b649c97155640616026bd32b1043b3c1d/aopalliance-repackaged-3.0.6.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.jetbrains/annotations/13.0/919f0dfe192fb4e063e7dacadee7f8bb9a2672a9/annotations-13.0.jar:/home/runner/.gradle/caches/modules-2/files-2.1/io.github.classgraph/classgraph/4.8.146/360448a09bfa5689d89cfa97fea53b3fdefa9c23/classgraph-4.8.146.jar:/home/runner/.gradle/caches/modules-2/files-2.1/com.mysema.commons/mysema-commons-lang/0.2.4/d09c8489d54251a6c22fbce804bdd4a070557317/mysema-commons-lang-0.2.4.jar:/home/runner/.gradle/caches/modules-2/files-2.1/org.eclipse.jdt/ecj/3.26.0/4837be609a3368a0f7e7cf0dc1bdbc7fe94993de/ecj-3.26.0.jar"" }, ""java.vm.vendor"" : { ""value"" : ""BellSoft"" } } }, { ""name"" : ""systemEnvironment"", ""properties"" : { ""JAVA_HOME"" : { ""value"" : ""/opt/hostedtoolcache/Java_Liberica_jdk/17.0.12-10/x64"", ""origin"" : ""System Environment Property \""JAVA_HOME\"""" } } }, { ""name"" : ""Config resource 'class path resource [application.properties]' via location 'classpath:/'"", ""properties"" : { ""com.example.cache.max-size"" : { ""value"" : ""1000"", ""origin"" : ""class path resource [application.properties] - 1:29"" } } }, { ""name"" : ""logCorrelation"", ""properties"" : { } } ] } Sanitization of sensitive values has been switched off for this example. Response Structure: The response contains details of the application’s Environment . The following table describes the structure of the response: Path Type Description activeProfiles Array Names of the active profiles, if any. defaultProfiles Array Names of the default profiles, if any. propertySources Array Property sources in order of precedence. propertySources.[].name String Name of the property source. propertySources.[].properties Object Properties in the property source keyed by property name. propertySources.[].properties.*.value String Value of the property. propertySources.[].properties.*.origin String Origin of the property, if any. Retrieving a Single Property: To retrieve a single property, make a GET request to /actuator/env/{property.name} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/env/com.example.cache.max-size' -i -X GET The preceding example retrieves information about the property named com.example.cache.max-size . The resulting response is similar to the following: HTTP/1.1 200 OK Content-Disposition: inline;filename=f.txt Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 511 {""property"":{""source"":""Config resource 'class path resource [application.properties]' via location 'classpath:/'"",""value"":""1000""},""activeProfiles"":[],""defaultProfiles"":[""default""],""propertySources"":[{""name"":""servletContextInitParams""},{""name"":""systemProperties""},{""name"":""systemEnvironment""},{""name"":""Config resource 'class path resource [application.properties]' via location 'classpath:/'"",""property"":{""value"":""1000"",""origin"":""class path resource [application.properties] - 1:29""}},{""name"":""logCorrelation""}]} Sanitization of sensitive values has been switched off for this example. Response Structure: The response contains details of the requested property. The following table describes the structure of the response: Path Type Description property Object Property from the environment, if found. property.source String Name of the source of the property. property.value String Value of the property. activeProfiles Array Names of the active profiles, if any. defaultProfiles Array Names of the default profiles, if any. propertySources Array Property sources in order of precedence. propertySources.[].name String Name of the property source. propertySources.[].property Object Property in the property source, if any. propertySources.[].property.value Varies Value of the property. propertySources.[].property.origin String Origin of the property, if any."
"https://docs.spring.io/spring-boot/api/rest/actuator/flyway.html","Flyway (flyway): The flyway endpoint provides information about database migrations performed by Flyway. Retrieving the Migrations: To retrieve the migrations, make a GET request to /actuator/flyway , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/flyway' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 515 { ""contexts"" : { ""application"" : { ""flywayBeans"" : { ""flyway"" : { ""migrations"" : [ { ""type"" : ""SQL"", ""checksum"" : -156244537, ""version"" : ""1"", ""description"" : ""init"", ""script"" : ""V1__init.sql"", ""state"" : ""SUCCESS"", ""installedBy"" : ""SA"", ""installedOn"" : ""2024-09-19T09:28:10.386Z"", ""installedRank"" : 1, ""executionTime"" : 8 } ] } } } } } Response Structure: The response contains details of the application’s Flyway migrations. The following table describes the structure of the response: Path Type Description contexts Object Application contexts keyed by id contexts.*.flywayBeans.*.migrations Array Migrations performed by the Flyway instance, keyed by Flyway bean name. contexts.*.flywayBeans.*.migrations.[].checksum Number Checksum of the migration, if any. contexts.*.flywayBeans.*.migrations.[].description String Description of the migration, if any. contexts.*.flywayBeans.*.migrations.[].executionTime Number Execution time in milliseconds of an applied migration. contexts.*.flywayBeans.*.migrations.[].installedBy String User that installed the applied migration, if any. contexts.*.flywayBeans.*.migrations.[].installedOn String Timestamp of when the applied migration was installed, if any. contexts.*.flywayBeans.*.migrations.[].installedRank Number Rank of the applied migration, if any. Later migrations have higher ranks. contexts.*.flywayBeans.*.migrations.[].script String Name of the script used to execute the migration, if any. contexts.*.flywayBeans.*.migrations.[].state String State of the migration. ( PENDING , ABOVE_TARGET , BELOW_BASELINE , BASELINE_IGNORED , BASELINE , IGNORED , MISSING_SUCCESS , MISSING_FAILED , SUCCESS , UNDONE , AVAILABLE , FAILED , OUT_OF_ORDER , FUTURE_SUCCESS , FUTURE_FAILED , OUTDATED , SUPERSEDED , DELETED ) contexts.*.flywayBeans.*.migrations.[].type String Type of the migration. contexts.*.flywayBeans.*.migrations.[].version String Version of the database after applying the migration, if any. contexts.*.parentId String Id of the parent application context, if any."
"https://docs.spring.io/spring-boot/api/rest/actuator/health.html","Health (health): The health endpoint provides detailed information about the health of the application. Retrieving the Health of the Application: To retrieve the health of the application, make a GET request to /actuator/health , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/health' -i -X GET \ -H 'Accept: application/json' The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/json Content-Length: 821 { ""status"" : ""UP"", ""components"" : { ""broker"" : { ""status"" : ""UP"", ""components"" : { ""us1"" : { ""status"" : ""UP"", ""details"" : { ""version"" : ""1.0.2"" } }, ""us2"" : { ""status"" : ""UP"", ""details"" : { ""version"" : ""1.0.4"" } } } }, ""db"" : { ""status"" : ""UP"", ""details"" : { ""database"" : ""H2"", ""validationQuery"" : ""isValid()"" } }, ""diskSpace"" : { ""status"" : ""UP"", ""details"" : { ""total"" : 77851254784, ""free"" : 37568974848, ""threshold"" : 10485760, ""path"" : ""/home/runner/work/spring-boot/spring-boot/spring-boot-project/spring-boot-actuator-autoconfigure/."", ""exists"" : true } } } } Response Structure: The response contains details of the health of the application. The following table describes the structure of the response: Path Type Description status String Overall status of the application. components Object The components that make up the health. components.*.status String Status of a specific part of the application. components.*.components Object The nested components that make up the health. components.*.details Object Details of the health of a specific part of the application. Presence is controlled by management.endpoint.health.show-details . The response fields above are for the V3 API. If you need to return V2 JSON you should use an accept header or application/vnd.spring-boot.actuator.v2+json Retrieving the Health of a Component: To retrieve the health of a particular component of the application’s health, make a GET request to /actuator/health/{component} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/health/db' -i -X GET \ -H 'Accept: application/json' The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/json Content-Length: 101 { ""status"" : ""UP"", ""details"" : { ""database"" : ""H2"", ""validationQuery"" : ""isValid()"" } } Response Structure: The response contains details of the health of a particular component of the application’s health. The following table describes the structure of the response: Path Type Description status String Status of a specific part of the application details Object Details of the health of a specific part of the application. Retrieving the Health of a Nested Component: If a particular component contains other nested components (as the broker indicator in the example above), the health of such a nested component can be retrieved by issuing a GET request to /actuator/health/{component}/{subcomponent} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/health/broker/us1' -i -X GET \ -H 'Accept: application/json' The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/json Content-Length: 66 { ""status"" : ""UP"", ""details"" : { ""version"" : ""1.0.2"" } } Components of an application’s health may be nested arbitrarily deep depending on the application’s health indicators and how they have been grouped. The health endpoint supports any number of /{component} identifiers in the URL to allow the health of a component at any depth to be retrieved. Response Structure: The response contains details of the health of an instance of a particular component of the application. The following table describes the structure of the response: Path Type Description status String Status of a specific part of the application details Object Details of the health of a specific part of the application."
"https://docs.spring.io/spring-boot/api/rest/actuator/heapdump.html","Heap Dump (heapdump): The heapdump endpoint provides a heap dump from the application’s JVM. Retrieving the Heap Dump: To retrieve the heap dump, make a GET request to /actuator/heapdump . The response is binary data and can be large. Its format depends upon the JVM on which the application is running. When running on a HotSpot JVM the format is HPROF(https://docs.oracle.com/javase/8/docs/technotes/samples/hprof.html) and on OpenJ9 it is PHD(https://www.eclipse.org/openj9/docs/dump_heapdump/#portable-heap-dump-phd-format) . Typically, you should save the response to disk for subsequent analysis. When using curl, this can be achieved by using the -O option, as shown in the following example: $ curl 'http://localhost:8080/actuator/heapdump' -O The preceding example results in a file named heapdump being written to the current working directory."
"https://docs.spring.io/spring-boot/api/rest/actuator/httpexchanges.html","HTTP Exchanges (httpexchanges): The httpexchanges endpoint provides information about HTTP request-response exchanges. Retrieving the HTTP Exchanges: To retrieve the HTTP exchanges, make a GET request to /actuator/httpexchanges , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/httpexchanges' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 511 { ""exchanges"" : [ { ""timestamp"" : ""2022-12-22T13:43:41Z"", ""request"" : { ""uri"" : ""https://api.example.com"", ""method"" : ""GET"", ""headers"" : { ""Accept"" : [ ""application/json"" ] } }, ""response"" : { ""status"" : 200, ""headers"" : { ""Content-Type"" : [ ""application/json"" ] } }, ""principal"" : { ""name"" : ""alice"" }, ""session"" : { ""id"" : ""94839a54-f308-4f43-a979-cbeb4906e2af"" }, ""timeTaken"" : ""PT0.023S"" } ] } Response Structure: The response contains details of the traced HTTP request-response exchanges. The following table describes the structure of the response: Path Type Description exchanges Array An array of HTTP request-response exchanges. exchanges.[].timestamp String Timestamp of when the exchange occurred. exchanges.[].principal Object Principal of the exchange, if any. exchanges.[].principal.name String Name of the principal. exchanges.[].request.method String HTTP method of the request. exchanges.[].request.remoteAddress String Remote address from which the request was received, if known. exchanges.[].request.uri String URI of the request. exchanges.[].request.headers Object Headers of the request, keyed by header name. exchanges.[].request.headers.*.[] Array Values of the header exchanges.[].response.status Number Status of the response exchanges.[].response.headers Object Headers of the response, keyed by header name. exchanges.[].response.headers.*.[] Array Values of the header exchanges.[].session Object Session associated with the exchange, if any. exchanges.[].session.id String ID of the session. exchanges.[].timeTaken String Time taken to handle the exchange."
"https://docs.spring.io/spring-boot/api/rest/actuator/info.html","Info (info): The info endpoint provides general information about the application. Retrieving the Info: To retrieve the information about the application, make a GET request to /actuator/info , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/info' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 231 { ""git"" : { ""branch"" : ""main"", ""commit"" : { ""id"" : ""df027cf"", ""time"" : ""2024-09-19T09:28:14Z"" } }, ""build"" : { ""artifact"" : ""application"", ""version"" : ""1.0.3"", ""group"" : ""com.example"" } } Response Structure: The response contains general information about the application. Each section of the response is contributed by an InfoContributor . Spring Boot provides several contributors that are described below. Build Response Structure: The following table describe the structure of the build section of the response: Path Type Description artifact String Artifact ID of the application, if any. group String Group ID of the application, if any. name String Name of the application, if any. version String Version of the application, if any. time Varies Timestamp of when the application was built, if any. Git Response Structure: The following table describes the structure of the git section of the response: Path Type Description branch String Name of the Git branch, if any. commit Object Details of the Git commit, if any. commit.time Varies Timestamp of the commit, if any. commit.id String ID of the commit, if any. This is the ""simple"" output. The contributor can also be configured to output all available data."
"https://docs.spring.io/spring-boot/api/rest/actuator/integrationgraph.html","Spring Integration Graph (integrationgraph): The integrationgraph endpoint exposes a graph containing all Spring Integration components. Retrieving the Spring Integration Graph: To retrieve the information about the application, make a GET request to /actuator/integrationgraph , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/integrationgraph' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 1033 { ""contentDescriptor"" : { ""providerVersion"" : ""6.3.4"", ""providerFormatVersion"" : 1.2, ""provider"" : ""spring-integration"" }, ""nodes"" : [ { ""nodeId"" : 1, ""componentType"" : ""null-channel"", ""integrationPatternType"" : ""null_channel"", ""integrationPatternCategory"" : ""messaging_channel"", ""properties"" : { }, ""name"" : ""nullChannel"", ""observed"" : false }, { ""nodeId"" : 2, ""componentType"" : ""publish-subscribe-channel"", ""integrationPatternType"" : ""publish_subscribe_channel"", ""integrationPatternCategory"" : ""messaging_channel"", ""properties"" : { }, ""name"" : ""errorChannel"", ""observed"" : false }, { ""nodeId"" : 3, ""componentType"" : ""logging-channel-adapter"", ""integrationPatternType"" : ""outbound_channel_adapter"", ""integrationPatternCategory"" : ""messaging_endpoint"", ""properties"" : { }, ""input"" : ""errorChannel"", ""name"" : ""errorLogger"", ""observed"" : false } ], ""links"" : [ { ""from"" : 2, ""to"" : 3, ""type"" : ""input"" } ] } Response Structure: The response contains all Spring Integration components used within the application, as well as the links between them. More information about the structure can be found in the reference documentation(https://docs.spring.io/spring-integration/reference/6.3/graph.html) . Rebuilding the Spring Integration Graph: To rebuild the exposed graph, make a POST request to /actuator/integrationgraph , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/integrationgraph' -i -X POST This will result in a 204 - No Content response: HTTP/1.1 204 No Content"
"https://docs.spring.io/spring-boot/api/rest/actuator/liquibase.html","Liquibase (liquibase): The liquibase endpoint provides information about database change sets applied by Liquibase. Retrieving the Changes: To retrieve the changes, make a GET request to /actuator/liquibase , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/liquibase' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 677 { ""contexts"" : { ""application"" : { ""liquibaseBeans"" : { ""liquibase"" : { ""changeSets"" : [ { ""author"" : ""marceloverdijk"", ""changeLog"" : ""db/changelog/db.changelog-master.yaml"", ""comments"" : """", ""contexts"" : [ ], ""dateExecuted"" : ""2024-09-19T09:28:18.855Z"", ""deploymentId"" : ""6738098719"", ""description"" : ""createTable tableName=customer"", ""execType"" : ""EXECUTED"", ""id"" : ""1"", ""labels"" : [ ], ""checksum"" : ""9:d3589feb2baad02e15540750499ba311"", ""orderExecuted"" : 1 } ] } } } } } Response Structure: The response contains details of the application’s Liquibase change sets. The following table describes the structure of the response: Path Type Description contexts Object Application contexts keyed by id contexts.*.liquibaseBeans.*.changeSets Array Change sets made by the Liquibase beans, keyed by bean name. contexts.*.liquibaseBeans.*.changeSets[].author String Author of the change set. contexts.*.liquibaseBeans.*.changeSets[].changeLog String Change log that contains the change set. contexts.*.liquibaseBeans.*.changeSets[].comments String Comments on the change set. contexts.*.liquibaseBeans.*.changeSets[].contexts Array Contexts of the change set. contexts.*.liquibaseBeans.*.changeSets[].dateExecuted String Timestamp of when the change set was executed. contexts.*.liquibaseBeans.*.changeSets[].deploymentId String ID of the deployment that ran the change set. contexts.*.liquibaseBeans.*.changeSets[].description String Description of the change set. contexts.*.liquibaseBeans.*.changeSets[].execType String Execution type of the change set ( EXECUTED , FAILED , SKIPPED , RERAN , MARK_RAN ). contexts.*.liquibaseBeans.*.changeSets[].id String ID of the change set. contexts.*.liquibaseBeans.*.changeSets[].labels Array Labels associated with the change set. contexts.*.liquibaseBeans.*.changeSets[].checksum String Checksum of the change set. contexts.*.liquibaseBeans.*.changeSets[].orderExecuted Number Order of the execution of the change set. contexts.*.liquibaseBeans.*.changeSets[].tag String Tag associated with the change set, if any. contexts.*.parentId String Id of the parent application context, if any."
"https://docs.spring.io/spring-boot/api/rest/actuator/logfile.html","Log File (logfile): The logfile endpoint provides access to the contents of the application’s log file. Retrieving the Log File: To retrieve the log file, make a GET request to /actuator/logfile , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/logfile' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Accept-Ranges: bytes Content-Type: text/plain;charset=UTF-8 Content-Length: 4707 . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: 2017-08-08 17:12:30.910 INFO 19866 --- [ main] s.f.SampleWebFreeMarkerApplication : Starting SampleWebFreeMarkerApplication with PID 19866 2017-08-08 17:12:30.913 INFO 19866 --- [ main] s.f.SampleWebFreeMarkerApplication : No active profile set, falling back to default profiles: default 2017-08-08 17:12:30.952 INFO 19866 --- [ main] ConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@76b10754: startup date [Tue Aug 08 17:12:30 BST 2017]; root of context hierarchy 2017-08-08 17:12:31.878 INFO 19866 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port 8080 (http) 2017-08-08 17:12:31.889 INFO 19866 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2017-08-08 17:12:31.890 INFO 19866 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.16 2017-08-08 17:12:31.978 INFO 19866 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2017-08-08 17:12:31.978 INFO 19866 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1028 ms 2017-08-08 17:12:32.080 INFO 19866 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: 'dispatcherServlet' to [/] 2017-08-08 17:12:32.084 INFO 19866 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'characterEncodingFilter' to: [/*] 2017-08-08 17:12:32.084 INFO 19866 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'hiddenHttpMethodFilter' to: [/*] 2017-08-08 17:12:32.084 INFO 19866 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'httpPutFormContentFilter' to: [/*] 2017-08-08 17:12:32.084 INFO 19866 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'requestContextFilter' to: [/*] 2017-08-08 17:12:32.349 INFO 19866 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@76b10754: startup date [Tue Aug 08 17:12:30 BST 2017]; root of context hierarchy 2017-08-08 17:12:32.420 INFO 19866 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped ""{[/error]}"" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.error(jakarta.servlet.http.HttpServletRequest) 2017-08-08 17:12:32.421 INFO 19866 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped ""{[/error],produces=[text/html]}"" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse) 2017-08-08 17:12:32.444 INFO 19866 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2017-08-08 17:12:32.444 INFO 19866 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2017-08-08 17:12:32.471 INFO 19866 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2017-08-08 17:12:32.600 INFO 19866 --- [ main] o.s.w.s.v.f.FreeMarkerConfigurer : ClassTemplateLoader for Spring macros added to FreeMarker configuration 2017-08-08 17:12:32.681 INFO 19866 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup 2017-08-08 17:12:32.744 INFO 19866 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port 8080 (http) 2017-08-08 17:12:32.750 INFO 19866 --- [ main] s.f.SampleWebFreeMarkerApplication : Started SampleWebFreeMarkerApplication in 2.172 seconds (JVM running for 2.479) Retrieving Part of the Log File: Retrieving part of the log file is not supported when using Jersey. To retrieve part of the log file, make a GET request to /actuator/logfile by using the Range header, as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/logfile' -i -X GET \ -H 'Range: bytes=0-1023' The preceding example retrieves the first 1024 bytes of the log file. The resulting response is similar to the following: HTTP/1.1 206 Partial Content Accept-Ranges: bytes Content-Type: text/plain;charset=UTF-8 Content-Range: bytes 0-1023/4707 Content-Length: 1024 . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: 2017-08-08 17:12:30.910 INFO 19866 --- [ main] s.f.SampleWebFreeMarkerApplication : Starting SampleWebFreeMarkerApplication with PID 19866 2017-08-08 17:12:30.913 INFO 19866 --- [ main] s.f.SampleWebFreeMarkerApplication : No active profile set, falling back to default profiles: default 2017-08-08 17:12:30.952 INFO 19866 --- [ main] ConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@76b10754: startup date [Tue Aug 08 17:12:30 BST 2017]; root of context hierarchy 2017-08-08 17:12:31.878 INFO 19866 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port 8080 (http) 20"
"https://docs.spring.io/spring-boot/api/rest/actuator/loggers.html","Loggers (loggers): The loggers endpoint provides access to the application’s loggers and the configuration of their levels. Retrieving All Loggers: To retrieve the application’s loggers, make a GET request to /actuator/loggers , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/loggers' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 791 { ""levels"" : [ ""OFF"", ""FATAL"", ""ERROR"", ""WARN"", ""INFO"", ""DEBUG"", ""TRACE"" ], ""loggers"" : { ""ROOT"" : { ""configuredLevel"" : ""INFO"", ""effectiveLevel"" : ""INFO"" }, ""com.example"" : { ""configuredLevel"" : ""DEBUG"", ""effectiveLevel"" : ""DEBUG"" } }, ""groups"" : { ""test"" : { ""configuredLevel"" : ""INFO"", ""members"" : [ ""test.member1"", ""test.member2"" ] }, ""web"" : { ""members"" : [ ""org.springframework.core.codec"", ""org.springframework.http"", ""org.springframework.web"", ""org.springframework.boot.actuate.endpoint.web"", ""org.springframework.boot.web.servlet.ServletContextInitializerBeans"" ] }, ""sql"" : { ""members"" : [ ""org.springframework.jdbc.core"", ""org.hibernate.SQL"", ""org.jooq.tools.LoggerListener"" ] } } } Response Structure: The response contains details of the application’s loggers. The following table describes the structure of the response: Path Type Description levels Array Levels support by the logging system. loggers Object Loggers keyed by name. groups Object Logger groups keyed by name loggers.*.configuredLevel String Configured level of the logger, if any. loggers.*.effectiveLevel String Effective level of the logger. groups.*.configuredLevel String Configured level of the logger group, if any. groups.*.members Array Loggers that are part of this group Retrieving a Single Logger: To retrieve a single logger, make a GET request to /actuator/loggers/{logger.name} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/loggers/com.example' -i -X GET The preceding example retrieves information about the logger named com.example . The resulting response is similar to the following: HTTP/1.1 200 OK Content-Disposition: inline;filename=f.txt Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 61 { ""configuredLevel"" : ""INFO"", ""effectiveLevel"" : ""INFO"" } Response Structure: The response contains details of the requested logger. The following table describes the structure of the response: Path Type Description configuredLevel String Configured level of the logger, if any. effectiveLevel String Effective level of the logger. Retrieving a Single Group: To retrieve a single group, make a GET request to /actuator/loggers/{group.name} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/loggers/test' -i -X GET The preceding example retrieves information about the logger group named test . The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 82 { ""configuredLevel"" : ""INFO"", ""members"" : [ ""test.member1"", ""test.member2"" ] } Response Structure: The response contains details of the requested group. The following table describes the structure of the response: Path Type Description configuredLevel String Configured level of the logger group, if any. members Array Loggers that are part of this group Setting a Log Level: To set the level of a logger, make a POST request to /actuator/loggers/{logger.name} with a JSON body that specifies the configured level for the logger, as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/loggers/com.example' -i -X POST \ -H 'Content-Type: application/json' \ -d '{""configuredLevel"":""debug""}' The preceding example sets the configuredLevel of the com.example logger to DEBUG . Request Structure: The request specifies the desired level of the logger. The following table describes the structure of the request: Path Type Description configuredLevel String Level for the logger. May be omitted to clear the level. Setting a Log Level for a Group: To set the level of a logger, make a POST request to /actuator/loggers/{group.name} with a JSON body that specifies the configured level for the logger group, as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/loggers/test' -i -X POST \ -H 'Content-Type: application/json' \ -d '{""configuredLevel"":""debug""}' The preceding example sets the configuredLevel of the test logger group to DEBUG . Request Structure: The request specifies the desired level of the logger group. The following table describes the structure of the request: Path Type Description configuredLevel String Level for the logger. May be omitted to clear the level. Clearing a Log Level: To clear the level of a logger, make a POST request to /actuator/loggers/{logger.name} with a JSON body containing an empty object, as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/loggers/com.example' -i -X POST \ -H 'Content-Type: application/json' \ -d '{}' The preceding example clears the configured level of the com.example logger."
"https://docs.spring.io/spring-boot/api/rest/actuator/mappings.html","Mappings (mappings): The mappings endpoint provides information about the application’s request mappings. Retrieving the Mappings: To retrieve the mappings, make a GET request to /actuator/mappings , as shown in the following curl-based example: $ curl 'http://localhost:33775/actuator/mappings' -i -X GET \ -H 'accept-encoding: gzip' \ -H 'user-agent: ReactorNetty/1.1.22' \ -H 'accept: */*' The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Transfer-Encoding: chunked Date: Thu, 19 Sep 2024 09:28:30 GMT Content-Length: 5342 { ""contexts"" : { ""application"" : { ""mappings"" : { ""dispatcherServlets"" : { ""dispatcherServlet"" : [ { ""handler"" : ""Actuator web endpoint 'mappings'"", ""predicate"" : ""{GET [/actuator/mappings], produces [application/vnd.spring-boot.actuator.v3+json || application/vnd.spring-boot.actuator.v2+json || application/json]}"", ""details"" : { ""handlerMethod"" : { ""className"" : ""org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping.OperationHandler"", ""name"" : ""handle"", ""descriptor"" : ""(Ljakarta/servlet/http/HttpServletRequest;Ljava/util/Map;)Ljava/lang/Object;"" }, ""requestMappingConditions"" : { ""consumes"" : [ ], ""headers"" : [ ], ""methods"" : [ ""GET"" ], ""params"" : [ ], ""patterns"" : [ ""/actuator/mappings"" ], ""produces"" : [ { ""mediaType"" : ""application/vnd.spring-boot.actuator.v3+json"", ""negated"" : false }, { ""mediaType"" : ""application/vnd.spring-boot.actuator.v2+json"", ""negated"" : false }, { ""mediaType"" : ""application/json"", ""negated"" : false } ] } } }, { ""handler"" : ""Actuator root web endpoint"", ""predicate"" : ""{GET [/actuator], produces [application/vnd.spring-boot.actuator.v3+json || application/vnd.spring-boot.actuator.v2+json || application/json]}"", ""details"" : { ""handlerMethod"" : { ""className"" : ""org.springframework.boot.actuate.endpoint.web.servlet.WebMvcEndpointHandlerMapping.WebMvcLinksHandler"", ""name"" : ""links"", ""descriptor"" : ""(Ljakarta/servlet/http/HttpServletRequest;Ljakarta/servlet/http/HttpServletResponse;)Ljava/util/Map;"" }, ""requestMappingConditions"" : { ""consumes"" : [ ], ""headers"" : [ ], ""methods"" : [ ""GET"" ], ""params"" : [ ], ""patterns"" : [ ""/actuator"" ], ""produces"" : [ { ""mediaType"" : ""application/vnd.spring-boot.actuator.v3+json"", ""negated"" : false }, { ""mediaType"" : ""application/vnd.spring-boot.actuator.v2+json"", ""negated"" : false }, { ""mediaType"" : ""application/json"", ""negated"" : false } ] } } }, { ""handler"" : ""org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation.MappingsEndpointServletDocumentationTests$ExampleController#example()"", ""predicate"" : ""{POST [/], params [a!=alpha], headers [X-Custom=Foo], consumes [application/json || !application/xml], produces [text/plain]}"", ""details"" : { ""handlerMethod"" : { ""className"" : ""org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation.MappingsEndpointServletDocumentationTests.ExampleController"", ""name"" : ""example"", ""descriptor"" : ""()Ljava/lang/String;"" }, ""requestMappingConditions"" : { ""consumes"" : [ { ""mediaType"" : ""application/json"", ""negated"" : false }, { ""mediaType"" : ""application/xml"", ""negated"" : true } ], ""headers"" : [ { ""name"" : ""X-Custom"", ""value"" : ""Foo"", ""negated"" : false } ], ""methods"" : [ ""POST"" ], ""params"" : [ { ""name"" : ""a"", ""value"" : ""alpha"", ""negated"" : true } ], ""patterns"" : [ ""/"" ], ""produces"" : [ { ""mediaType"" : ""text/plain"", ""negated"" : false } ] } } }, { ""handler"" : ""ResourceHttpRequestHandler [classpath [META-INF/resources/webjars/]]"", ""predicate"" : ""/webjars/**"" }, { ""handler"" : ""ResourceHttpRequestHandler [classpath [META-INF/resources/], classpath [resources/], classpath [static/], classpath [public/], ServletContext [/]]"", ""predicate"" : ""/**"" } ] }, ""servletFilters"" : [ { ""servletNameMappings"" : [ ], ""urlPatternMappings"" : [ ""/*"" ], ""name"" : ""requestContextFilter"", ""className"" : ""org.springframework.boot.web.servlet.filter.OrderedRequestContextFilter"" }, { ""servletNameMappings"" : [ ], ""urlPatternMappings"" : [ ""/*"" ], ""name"" : ""formContentFilter"", ""className"" : ""org.springframework.boot.web.servlet.filter.OrderedFormContentFilter"" } ], ""servlets"" : [ { ""mappings"" : [ ""/"" ], ""name"" : ""dispatcherServlet"", ""className"" : ""org.springframework.web.servlet.DispatcherServlet"" } ] } } } } Response Structure: The response contains details of the application’s mappings. The items found in the response depend on the type of web application (reactive or Servlet-based). The following table describes the structure of the common elements of the response: Path Type Description contexts Object Application contexts keyed by id. contexts.*.mappings Object Mappings in the context, keyed by mapping type. contexts.*.mappings.dispatcherServlets Object Dispatcher servlet mappings, if any. contexts.*.mappings.servletFilters Array Servlet filter mappings, if any. contexts.*.mappings.servlets Array Servlet mappings, if any. contexts.*.mappings.dispatcherHandlers Object Dispatcher handler mappings, if any. contexts.*.parentId String Id of the parent application context, if any. The entries that may be found in contexts.*.mappings are described in the following sections. Dispatcher Servlets Response Structure: When using Spring MVC, the response contains details of any DispatcherServlet request mappings beneath contexts.*.mappings.dispatcherServlets . The following table describes the structure of this section of the response: Path Type Description * Array Dispatcher servlet mappings, if any, keyed by dispatcher servlet bean name. *.[].details Object Additional implementation-specific details about the mapping. Optional. *.[].handler String Handler for the mapping. *.[].predicate String Predicate for the mapping. *.[].details.handlerMethod Object Details of the method, if any, that will handle requests to this mapping. *.[].details.handlerMethod.className Varies Fully qualified name of the class of the method. *.[].details.handlerMethod.name Varies Name of the method. *.[].details.handlerMethod.descriptor Varies Descriptor of the method as specified in the Java Language Specification. *.[].details.requestMappingConditions Object Details of the request mapping conditions. *.[].details.requestMappingConditions.consumes Varies Details of the consumes condition *.[].details.requestMappingConditions.consumes.[].mediaType Varies Consumed media type. *.[].details.requestMappingConditions.consumes.[].negated Varies Whether the media type is negated. *.[].details.requestMappingConditions.headers Varies Details of the headers condition. *.[].details.requestMappingConditions.headers.[].name Varies Name of the header. *.[].details.requestMappingConditions.headers.[].value Varies Required value of the header, if any. *.[].details.requestMappingConditions.headers.[].negated Varies Whether the value is negated. *.[].details.requestMappingConditions.methods Varies HTTP methods that are handled. *.[].details.requestMappingConditions.params Varies Details of the params condition. *.[].details.requestMappingConditions.params.[].name Varies Name of the parameter. *.[].details.requestMappingConditions.params.[].value Varies Required value of the parameter, if any. *.[].details.requestMappingConditions.params.[].negated Varies Whether the value is negated. *.[].details.requestMappingConditions.patterns Varies Patterns identifying the paths handled by the mapping. *.[].details.requestMappingConditions.produces Varies Details of the produces condition. *.[].details.requestMappingConditions.produces.[].mediaType Varies Produced media type. *.[].details.requestMappingConditions.produces.[].negated Varies Whether the media type is negated. Servlets Response Structure: When using the Servlet stack, the response contains details of any Servlet mappings beneath contexts.*.mappings.servlets . The following table describes the structure of this section of the response: Path Type Description [].mappings Array Mappings of the servlet. [].name String Name of the servlet. [].className String Class name of the servlet Servlet Filters Response Structure: When using the Servlet stack, the response contains details of any Filter mappings beneath contexts.*.mappings.servletFilters . The following table describes the structure of this section of the response: Path Type Description [].servletNameMappings Array Names of the servlets to which the filter is mapped. [].urlPatternMappings Array URL pattern to which the filter is mapped. [].name String Name of the filter. [].className String Class name of the filter Dispatcher Handlers Response Structure: When using Spring WebFlux, the response contains details of any DispatcherHandler request mappings beneath contexts.*.mappings.dispatcherHandlers . The following table describes the structure of this section of the response: Path Type Description * Array Dispatcher handler mappings, if any, keyed by dispatcher handler bean name. *.[].details Object Additional implementation-specific details about the mapping. Optional. *.[].handler String Handler for the mapping. *.[].predicate String Predicate for the mapping. *.[].details.requestMappingConditions Object Details of the request mapping conditions. *.[].details.requestMappingConditions.consumes Varies Details of the consumes condition *.[].details.requestMappingConditions.consumes.[].mediaType Varies Consumed media type. *.[].details.requestMappingConditions.consumes.[].negated Varies Whether the media type is negated. *.[].details.requestMappingConditions.headers Varies Details of the headers condition. *.[].details.requestMappingConditions.headers.[].name Varies Name of the header. *.[].details.requestMappingConditions.headers.[].value Varies Required value of the header, if any. *.[].details.requestMappingConditions.headers.[].negated Varies Whether the value is negated. *.[].details.requestMappingConditions.methods Varies HTTP methods that are handled. *.[].details.requestMappingConditions.params Varies Details of the params condition. *.[].details.requestMappingConditions.params.[].name Varies Name of the parameter. *.[].details.requestMappingConditions.params.[].value Varies Required value of the parameter, if any. *.[].details.requestMappingConditions.params.[].negated Varies Whether the value is negated. *.[].details.requestMappingConditions.patterns Varies Patterns identifying the paths handled by the mapping. *.[].details.requestMappingConditions.produces Varies Details of the produces condition. *.[].details.requestMappingConditions.produces.[].mediaType Varies Produced media type. *.[].details.requestMappingConditions.produces.[].negated Varies Whether the media type is negated. *.[].details.handlerMethod Object Details of the method, if any, that will handle requests to this mapping. *.[].details.handlerMethod.className String Fully qualified name of the class of the method. *.[].details.handlerMethod.name String Name of the method. *.[].details.handlerMethod.descriptor String Descriptor of the method as specified in the Java Language Specification. *.[].details.handlerFunction Object Details of the function, if any, that will handle requests to this mapping. *.[].details.handlerFunction.className String Fully qualified name of the class of the function."
"https://docs.spring.io/spring-boot/api/rest/actuator/metrics.html","Metrics (metrics): The metrics endpoint provides access to application metrics. Retrieving Metric Names: To retrieve the names of the available metrics, make a GET request to /actuator/metrics , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/metrics' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 154 { ""names"" : [ ""jvm.buffer.count"", ""jvm.buffer.memory.used"", ""jvm.buffer.total.capacity"", ""jvm.memory.committed"", ""jvm.memory.max"", ""jvm.memory.used"" ] } Response Structure: The response contains details of the metric names. The following table describes the structure of the response: Path Type Description names Array Names of the known metrics. Retrieving a Metric: To retrieve a metric, make a GET request to /actuator/metrics/{metric.name} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/metrics/jvm.memory.max' -i -X GET The preceding example retrieves information about the metric named jvm.memory.max . The resulting response is similar to the following: HTTP/1.1 200 OK Content-Disposition: inline;filename=f.txt Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 555 { ""name"" : ""jvm.memory.max"", ""description"" : ""The maximum amount of memory in bytes that can be used for memory management"", ""baseUnit"" : ""bytes"", ""measurements"" : [ { ""statistic"" : ""VALUE"", ""value"" : 2.399141885E9 } ], ""availableTags"" : [ { ""tag"" : ""area"", ""values"" : [ ""heap"", ""nonheap"" ] }, { ""tag"" : ""id"", ""values"" : [ ""CodeHeap 'profiled nmethods'"", ""G1 Old Gen"", ""CodeHeap 'non-profiled nmethods'"", ""G1 Survivor Space"", ""Compressed Class Space"", ""Metaspace"", ""G1 Eden Space"", ""CodeHeap 'non-nmethods'"" ] } ] } Query Parameters: The endpoint uses query parameters to drill down(#metrics.drilling-down) into a metric by using its tags. The following table shows the single supported query parameter: Parameter Description tag A tag to use for drill-down in the form name:value . Response Structure: The response contains details of the metric. The following table describes the structure of the response: Path Type Description name String Name of the metric description String Description of the metric baseUnit String Base unit of the metric measurements Array Measurements of the metric measurements[].statistic String Statistic of the measurement. ( TOTAL , TOTAL_TIME , COUNT , MAX , VALUE , UNKNOWN , ACTIVE_TASKS , DURATION ). measurements[].value Number Value of the measurement. availableTags Array Tags that are available for drill-down. availableTags[].tag String Name of the tag. availableTags[].values Array Possible values of the tag. Drilling Down: To drill down into a metric, make a GET request to /actuator/metrics/{metric.name} using the tag query parameter, as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/metrics/jvm.memory.max?tag=area%3Anonheap&tag=id%3ACompressed+Class+Space' -i -X GET The preceding example retrieves the jvm.memory.max metric, where the area tag has a value of nonheap and the id attribute has a value of Compressed Class Space . The resulting response is similar to the following: HTTP/1.1 200 OK Content-Disposition: inline;filename=f.txt Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 263 { ""name"" : ""jvm.memory.max"", ""description"" : ""The maximum amount of memory in bytes that can be used for memory management"", ""baseUnit"" : ""bytes"", ""measurements"" : [ { ""statistic"" : ""VALUE"", ""value"" : 1.073741824E9 } ], ""availableTags"" : [ ] }"
"https://docs.spring.io/spring-boot/api/rest/actuator/prometheus.html","Prometheus (prometheus): The prometheus endpoint provides Spring Boot application’s metrics in the format required for scraping by a Prometheus server. Retrieving All Metrics: To retrieve all metrics, make a GET request to /actuator/prometheus , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/prometheus' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: text/plain;version=0.0.4;charset=utf-8 Content-Length: 3096 # HELP jvm_buffer_count_buffers An estimate of the number of buffers in the pool # TYPE jvm_buffer_count_buffers gauge jvm_buffer_count_buffers{id=""direct""} 16.0 jvm_buffer_count_buffers{id=""mapped""} 0.0 jvm_buffer_count_buffers{id=""mapped - 'non-volatile memory'""} 0.0 # HELP jvm_buffer_memory_used_bytes An estimate of the memory that the Java virtual machine is using for this buffer pool # TYPE jvm_buffer_memory_used_bytes gauge jvm_buffer_memory_used_bytes{id=""direct""} 1.7043464E7 jvm_buffer_memory_used_bytes{id=""mapped""} 0.0 jvm_buffer_memory_used_bytes{id=""mapped - 'non-volatile memory'""} 0.0 # HELP jvm_buffer_total_capacity_bytes An estimate of the total capacity of the buffers in this pool # TYPE jvm_buffer_total_capacity_bytes gauge jvm_buffer_total_capacity_bytes{id=""direct""} 1.7043463E7 jvm_buffer_total_capacity_bytes{id=""mapped""} 0.0 jvm_buffer_total_capacity_bytes{id=""mapped - 'non-volatile memory'""} 0.0 # HELP jvm_memory_committed_bytes The amount of memory in bytes that is committed for the Java virtual machine to use # TYPE jvm_memory_committed_bytes gauge jvm_memory_committed_bytes{area=""heap"",id=""G1 Eden Space""} 1.56237824E8 jvm_memory_committed_bytes{area=""heap"",id=""G1 Old Gen""} 1.42606336E8 jvm_memory_committed_bytes{area=""heap"",id=""G1 Survivor Space""} 2097152.0 jvm_memory_committed_bytes{area=""nonheap"",id=""CodeHeap 'non-nmethods'""} 2555904.0 jvm_memory_committed_bytes{area=""nonheap"",id=""CodeHeap 'non-profiled nmethods'""} 4259840.0 jvm_memory_committed_bytes{area=""nonheap"",id=""CodeHeap 'profiled nmethods'""} 1.9726336E7 jvm_memory_committed_bytes{area=""nonheap"",id=""Compressed Class Space""} 1.212416E7 jvm_memory_committed_bytes{area=""nonheap"",id=""Metaspace""} 8.8342528E7 # HELP jvm_memory_max_bytes The maximum amount of memory in bytes that can be used for memory management # TYPE jvm_memory_max_bytes gauge jvm_memory_max_bytes{area=""heap"",id=""G1 Eden Space""} -1.0 jvm_memory_max_bytes{area=""heap"",id=""G1 Old Gen""} 1.073741824E9 jvm_memory_max_bytes{area=""heap"",id=""G1 Survivor Space""} -1.0 jvm_memory_max_bytes{area=""nonheap"",id=""CodeHeap 'non-nmethods'""} 5836800.0 jvm_memory_max_bytes{area=""nonheap"",id=""CodeHeap 'non-profiled nmethods'""} 1.22912768E8 jvm_memory_max_bytes{area=""nonheap"",id=""CodeHeap 'profiled nmethods'""} 1.22908672E8 jvm_memory_max_bytes{area=""nonheap"",id=""Compressed Class Space""} 1.073741824E9 jvm_memory_max_bytes{area=""nonheap"",id=""Metaspace""} -1.0 # HELP jvm_memory_used_bytes The amount of used memory # TYPE jvm_memory_used_bytes gauge jvm_memory_used_bytes{area=""heap"",id=""G1 Eden Space""} 8388608.0 jvm_memory_used_bytes{area=""heap"",id=""G1 Old Gen""} 8.8518144E7 jvm_memory_used_bytes{area=""heap"",id=""G1 Survivor Space""} 1531536.0 jvm_memory_used_bytes{area=""nonheap"",id=""CodeHeap 'non-nmethods'""} 1443456.0 jvm_memory_used_bytes{area=""nonheap"",id=""CodeHeap 'non-profiled nmethods'""} 4226816.0 jvm_memory_used_bytes{area=""nonheap"",id=""CodeHeap 'profiled nmethods'""} 1.966976E7 jvm_memory_used_bytes{area=""nonheap"",id=""Compressed Class Space""} 1.1769496E7 jvm_memory_used_bytes{area=""nonheap"",id=""Metaspace""} 8.7564792E7 The default response content type is text/plain;version=0.0.4 . The endpoint can also produce application/openmetrics-text;version=1.0.0 when called with an appropriate Accept header, as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/prometheus' -i -X GET \ -H 'Accept: application/openmetrics-text; version=1.0.0; charset=utf-8' The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/openmetrics-text;version=1.0.0;charset=utf-8 Content-Length: 3101 # TYPE jvm_buffer_count_buffers gauge # HELP jvm_buffer_count_buffers An estimate of the number of buffers in the pool jvm_buffer_count_buffers{id=""direct""} 16.0 jvm_buffer_count_buffers{id=""mapped""} 0.0 jvm_buffer_count_buffers{id=""mapped - 'non-volatile memory'""} 0.0 # TYPE jvm_buffer_memory_used_bytes gauge # HELP jvm_buffer_memory_used_bytes An estimate of the memory that the Java virtual machine is using for this buffer pool jvm_buffer_memory_used_bytes{id=""direct""} 1.7043464E7 jvm_buffer_memory_used_bytes{id=""mapped""} 0.0 jvm_buffer_memory_used_bytes{id=""mapped - 'non-volatile memory'""} 0.0 # TYPE jvm_buffer_total_capacity_bytes gauge # HELP jvm_buffer_total_capacity_bytes An estimate of the total capacity of the buffers in this pool jvm_buffer_total_capacity_bytes{id=""direct""} 1.7043463E7 jvm_buffer_total_capacity_bytes{id=""mapped""} 0.0 jvm_buffer_total_capacity_bytes{id=""mapped - 'non-volatile memory'""} 0.0 # TYPE jvm_memory_committed_bytes gauge # HELP jvm_memory_committed_bytes The amount of memory in bytes that is committed for the Java virtual machine to use jvm_memory_committed_bytes{area=""heap"",id=""G1 Eden Space""} 1.56237824E8 jvm_memory_committed_bytes{area=""heap"",id=""G1 Old Gen""} 1.42606336E8 jvm_memory_committed_bytes{area=""heap"",id=""G1 Survivor Space""} 2097152.0 jvm_memory_committed_bytes{area=""nonheap"",id=""CodeHeap 'non-nmethods'""} 2555904.0 jvm_memory_committed_bytes{area=""nonheap"",id=""CodeHeap 'non-profiled nmethods'""} 4259840.0 jvm_memory_committed_bytes{area=""nonheap"",id=""CodeHeap 'profiled nmethods'""} 1.96608E7 jvm_memory_committed_bytes{area=""nonheap"",id=""Compressed Class Space""} 1.212416E7 jvm_memory_committed_bytes{area=""nonheap"",id=""Metaspace""} 8.8342528E7 # TYPE jvm_memory_max_bytes gauge # HELP jvm_memory_max_bytes The maximum amount of memory in bytes that can be used for memory management jvm_memory_max_bytes{area=""heap"",id=""G1 Eden Space""} -1.0 jvm_memory_max_bytes{area=""heap"",id=""G1 Old Gen""} 1.073741824E9 jvm_memory_max_bytes{area=""heap"",id=""G1 Survivor Space""} -1.0 jvm_memory_max_bytes{area=""nonheap"",id=""CodeHeap 'non-nmethods'""} 5836800.0 jvm_memory_max_bytes{area=""nonheap"",id=""CodeHeap 'non-profiled nmethods'""} 1.22912768E8 jvm_memory_max_bytes{area=""nonheap"",id=""CodeHeap 'profiled nmethods'""} 1.22908672E8 jvm_memory_max_bytes{area=""nonheap"",id=""Compressed Class Space""} 1.073741824E9 jvm_memory_max_bytes{area=""nonheap"",id=""Metaspace""} -1.0 # TYPE jvm_memory_used_bytes gauge # HELP jvm_memory_used_bytes The amount of used memory jvm_memory_used_bytes{area=""heap"",id=""G1 Eden Space""} 7340032.0 jvm_memory_used_bytes{area=""heap"",id=""G1 Old Gen""} 8.8518144E7 jvm_memory_used_bytes{area=""heap"",id=""G1 Survivor Space""} 1531536.0 jvm_memory_used_bytes{area=""nonheap"",id=""CodeHeap 'non-nmethods'""} 1443456.0 jvm_memory_used_bytes{area=""nonheap"",id=""CodeHeap 'non-profiled nmethods'""} 4216448.0 jvm_memory_used_bytes{area=""nonheap"",id=""CodeHeap 'profiled nmethods'""} 1.9626368E7 jvm_memory_used_bytes{area=""nonheap"",id=""Compressed Class Space""} 1.1765576E7 jvm_memory_used_bytes{area=""nonheap"",id=""Metaspace""} 8.7528184E7 # EOF Query Parameters: The endpoint uses query parameters to limit the samples that it returns. The following table shows the supported query parameters: Parameter Description includedNames Restricts the samples to those that match the names. Optional. Retrieving Filtered Metrics: To retrieve metrics matching specific names, make a GET request to /actuator/prometheus with the includedNames query parameter, as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/prometheus?includedNames=jvm_memory_used_bytes%2Cjvm_memory_committed_bytes' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: text/plain;version=0.0.4;charset=utf-8 Content-Length: 1459 # HELP jvm_memory_committed_bytes The amount of memory in bytes that is committed for the Java virtual machine to use # TYPE jvm_memory_committed_bytes gauge jvm_memory_committed_bytes{area=""heap"",id=""G1 Eden Space""} 1.56237824E8 jvm_memory_committed_bytes{area=""heap"",id=""G1 Old Gen""} 1.42606336E8 jvm_memory_committed_bytes{area=""heap"",id=""G1 Survivor Space""} 2097152.0 jvm_memory_committed_bytes{area=""nonheap"",id=""CodeHeap 'non-nmethods'""} 2555904.0 jvm_memory_committed_bytes{area=""nonheap"",id=""CodeHeap 'non-profiled nmethods'""} 4259840.0 jvm_memory_committed_bytes{area=""nonheap"",id=""CodeHeap 'profiled nmethods'""} 1.9726336E7 jvm_memory_committed_bytes{area=""nonheap"",id=""Compressed Class Space""} 1.212416E7 jvm_memory_committed_bytes{area=""nonheap"",id=""Metaspace""} 8.8342528E7 # HELP jvm_memory_used_bytes The amount of used memory # TYPE jvm_memory_used_bytes gauge jvm_memory_used_bytes{area=""heap"",id=""G1 Eden Space""} 9437184.0 jvm_memory_used_bytes{area=""heap"",id=""G1 Old Gen""} 8.8518144E7 jvm_memory_used_bytes{area=""heap"",id=""G1 Survivor Space""} 1531536.0 jvm_memory_used_bytes{area=""nonheap"",id=""CodeHeap 'non-nmethods'""} 1443456.0 jvm_memory_used_bytes{area=""nonheap"",id=""CodeHeap 'non-profiled nmethods'""} 4230656.0 jvm_memory_used_bytes{area=""nonheap"",id=""CodeHeap 'profiled nmethods'""} 1.9694336E7 jvm_memory_used_bytes{area=""nonheap"",id=""Compressed Class Space""} 1.1770096E7 jvm_memory_used_bytes{area=""nonheap"",id=""Metaspace""} 8.75714E7"
"https://docs.spring.io/spring-boot/api/rest/actuator/quartz.html","Quartz (quartz): The quartz endpoint provides information about jobs and triggers that are managed by the Quartz Scheduler. Retrieving Registered Groups: Jobs and triggers are managed in groups. To retrieve the list of registered job and trigger groups, make a GET request to /actuator/quartz , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/quartz' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 120 { ""jobs"" : { ""groups"" : [ ""samples"", ""tests"" ] }, ""triggers"" : { ""groups"" : [ ""samples"", ""DEFAULT"" ] } } Response Structure: The response contains the groups names for registered jobs and triggers. The following table describes the structure of the response: Path Type Description jobs.groups Array An array of job group names. triggers.groups Array An array of trigger group names. Retrieving Registered Job Names: To retrieve the list of registered job names, make a GET request to /actuator/quartz/jobs , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/quartz/jobs' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 137 { ""groups"" : { ""samples"" : { ""jobs"" : [ ""jobOne"", ""jobTwo"" ] }, ""tests"" : { ""jobs"" : [ ""jobThree"" ] } } } Response Structure: The response contains the registered job names for each group. The following table describes the structure of the response: Path Type Description groups Object Job groups keyed by name. groups.*.jobs Array An array of job names. Retrieving Registered Trigger Names: To retrieve the list of registered trigger names, make a GET request to /actuator/quartz/triggers , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/quartz/triggers' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 229 { ""groups"" : { ""samples"" : { ""paused"" : false, ""triggers"" : [ ""3am-weekdays"", ""every-day"", ""once-a-week"" ] }, ""DEFAULT"" : { ""paused"" : false, ""triggers"" : [ ""every-hour-tue-thu"" ] } } } Response Structure: The response contains the registered trigger names for each group. The following table describes the structure of the response: Path Type Description groups Object Trigger groups keyed by name. groups.*.paused Boolean Whether this trigger group is paused. groups.*.triggers Array An array of trigger names. Retrieving Overview of a Job Group: To retrieve an overview of the jobs in a particular group, make a GET request to /actuator/quartz/jobs/{groupName} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/quartz/jobs/samples' -i -X GET The preceding example retrieves the summary for jobs in the samples group. The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 201 { ""group"" : ""samples"", ""jobs"" : { ""jobOne"" : { ""className"" : ""org.springframework.scheduling.quartz.DelegatingJob"" }, ""jobTwo"" : { ""className"" : ""org.quartz.Job"" } } } Response Structure: The response contains an overview of jobs in a particular group. The following table describes the structure of the response: Path Type Description group String Name of the group. jobs Object Job details keyed by name. jobs.*.className String Fully qualified name of the job implementation. Retrieving Overview of a Trigger Group: To retrieve an overview of the triggers in a particular group, make a GET request to /actuator/quartz/triggers/{groupName} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/quartz/triggers/tests' -i -X GET The preceding example retrieves the summary for triggers in the tests group. The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 1268 { ""group"" : ""tests"", ""paused"" : false, ""triggers"" : { ""cron"" : { ""3am-week"" : { ""previousFireTime"" : ""2020-12-04T03:00:00.000+00:00"", ""nextFireTime"" : ""2020-12-07T03:00:00.000+00:00"", ""priority"" : 3, ""expression"" : ""0 0 3 ? * 1,2,3,4,5"", ""timeZone"" : ""Europe/Paris"" } }, ""simple"" : { ""every-day"" : { ""nextFireTime"" : ""2020-12-04T12:00:00.000+00:00"", ""priority"" : 7, ""interval"" : 86400000 } }, ""dailyTimeInterval"" : { ""tue-thu"" : { ""priority"" : 5, ""interval"" : 3600000, ""daysOfWeek"" : [ 3, 5 ], ""startTimeOfDay"" : ""09:00:00"", ""endTimeOfDay"" : ""18:00:00"" } }, ""calendarInterval"" : { ""once-a-week"" : { ""previousFireTime"" : ""2020-12-02T14:00:00.000+00:00"", ""nextFireTime"" : ""2020-12-08T14:00:00.000+00:00"", ""priority"" : 5, ""interval"" : 604800000, ""timeZone"" : ""Etc/UTC"" } }, ""custom"" : { ""once-a-year-custom"" : { ""previousFireTime"" : ""2020-07-14T16:00:00.000+00:00"", ""nextFireTime"" : ""2021-07-14T16:00:00.000+00:00"", ""priority"" : 10, ""trigger"" : ""com.example.CustomTrigger@fdsfsd"" } } } } Response Structure: The response contains an overview of triggers in a particular group. Trigger implementation specific details are available. The following table describes the structure of the response: Path Type Description group String Name of the group. paused Boolean Whether the group is paused. triggers.cron Object Cron triggers keyed by name, if any. triggers.simple Object Simple triggers keyed by name, if any. triggers.dailyTimeInterval Object Daily time interval triggers keyed by name, if any. triggers.calendarInterval Object Calendar interval triggers keyed by name, if any. triggers.custom Object Any other triggers keyed by name, if any. triggers.cron.*.previousFireTime String Last time the trigger fired, if any. triggers.cron.*.nextFireTime String Next time at which the Trigger is scheduled to fire, if any. triggers.cron.*.priority Number Priority to use if two triggers have the same scheduled fire time. triggers.cron.*.expression String Cron expression to use. triggers.cron.*.timeZone String Time zone for which the expression will be resolved, if any. triggers.simple.*.previousFireTime String Last time the trigger fired, if any. triggers.simple.*.nextFireTime String Next time at which the Trigger is scheduled to fire, if any. triggers.simple.*.priority Number Priority to use if two triggers have the same scheduled fire time. triggers.simple.*.interval Number Interval, in milliseconds, between two executions. triggers.dailyTimeInterval.*.previousFireTime String Last time the trigger fired, if any. triggers.dailyTimeInterval.*.nextFireTime String Next time at which the Trigger is scheduled to fire, if any. triggers.dailyTimeInterval.*.priority Number Priority to use if two triggers have the same scheduled fire time. triggers.dailyTimeInterval.*.interval Number Interval, in milliseconds, added to the fire time in order to calculate the time of the next trigger repeat. triggers.dailyTimeInterval.*.daysOfWeek Array An array of days of the week upon which to fire. triggers.dailyTimeInterval.*.startTimeOfDay String Time of day to start firing at the given interval, if any. triggers.dailyTimeInterval.*.endTimeOfDay String Time of day to complete firing at the given interval, if any. triggers.calendarInterval.*.previousFireTime String Last time the trigger fired, if any. triggers.calendarInterval.*.nextFireTime String Next time at which the Trigger is scheduled to fire, if any. triggers.calendarInterval.*.priority Number Priority to use if two triggers have the same scheduled fire time. triggers.calendarInterval.*.interval Number Interval, in milliseconds, added to the fire time in order to calculate the time of the next trigger repeat. triggers.calendarInterval.*.timeZone String Time zone within which time calculations will be performed, if any. triggers.custom.*.previousFireTime String Last time the trigger fired, if any. triggers.custom.*.nextFireTime String Next time at which the Trigger is scheduled to fire, if any. triggers.custom.*.priority Number Priority to use if two triggers have the same scheduled fire time. triggers.custom.*.trigger String A toString representation of the custom trigger instance. Retrieving Details of a Job: To retrieve the details about a particular job, make a GET request to /actuator/quartz/jobs/{groupName}/{jobName} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/quartz/jobs/samples/jobOne' -i -X GET The preceding example retrieves the details of the job identified by the samples group and jobOne name. The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 609 { ""group"" : ""samples"", ""name"" : ""jobOne"", ""description"" : ""A sample job"", ""className"" : ""org.springframework.scheduling.quartz.DelegatingJob"", ""durable"" : false, ""requestRecovery"" : false, ""data"" : { ""password"" : ""secret"", ""user"" : ""admin"" }, ""triggers"" : [ { ""group"" : ""samples"", ""name"" : ""every-day"", ""previousFireTime"" : ""2020-12-04T03:00:00.000+00:00"", ""nextFireTime"" : ""2020-12-04T12:00:00.000+00:00"", ""priority"" : 7 }, { ""group"" : ""samples"", ""name"" : ""3am-weekdays"", ""nextFireTime"" : ""2020-12-07T03:00:00.000+00:00"", ""priority"" : 3 } ] } If a key in the data map is identified as sensitive, its value is sanitized. Response Structure: The response contains the full details of a job including a summary of the triggers associated with it, if any. The triggers are sorted by next fire time and priority. The following table describes the structure of the response: Path Type Description group String Name of the group. name String Name of the job. description String Description of the job, if any. className String Fully qualified name of the job implementation. durable Boolean Whether the job should remain stored after it is orphaned. requestRecovery Boolean Whether the job should be re-executed if a 'recovery' or 'fail-over' situation is encountered. data.* String Job data map as key/value pairs, if any. triggers Array An array of triggers associated to the job, if any. triggers.[].group String Name of the trigger group. triggers.[].name String Name of the trigger. triggers.[].previousFireTime String Last time the trigger fired, if any. triggers.[].nextFireTime String Next time at which the Trigger is scheduled to fire, if any. triggers.[].priority Number Priority to use if two triggers have the same scheduled fire time. Retrieving Details of a Trigger: To retrieve the details about a particular trigger, make a GET request to /actuator/quartz/triggers/{groupName}/{triggerName} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/quartz/triggers/samples/example' -i -X GET The preceding example retrieves the details of trigger identified by the samples group and example name. Common Response Structure: The response has a common structure and an additional object that is specific to the trigger’s type. There are five supported types: cron for CronTrigger simple for SimpleTrigger dailyTimeInterval for DailyTimeIntervalTrigger calendarInterval for CalendarIntervalTrigger custom for any other trigger implementations The following table describes the structure of the common elements of the response: Path Type Description group String Name of the group. name String Name of the trigger. description String Description of the trigger, if any. state String State of the trigger ( NONE , NORMAL , PAUSED , COMPLETE , ERROR , BLOCKED ). type String Type of the trigger ( calendarInterval , cron , custom , dailyTimeInterval , simple ). Determines the key of the object containing type-specific details. calendarName String Name of the Calendar associated with this Trigger, if any. startTime String Time at which the Trigger should take effect, if any. endTime String Time at which the Trigger should quit repeating, regardless of any remaining repeats, if any. previousFireTime String Last time the trigger fired, if any. nextFireTime String Next time at which the Trigger is scheduled to fire, if any. priority Number Priority to use if two triggers have the same scheduled fire time. finalFireTime String Last time at which the Trigger will fire, if any. data Object Job data map keyed by name, if any. calendarInterval Object Calendar time interval trigger details, if any. Present when type is calendarInterval . custom Object Custom trigger details, if any. Present when type is custom . cron Object Cron trigger details, if any. Present when type is cron . dailyTimeInterval Object Daily time interval trigger details, if any. Present when type is dailyTimeInterval . simple Object Simple trigger details, if any. Present when type is simple . Cron Trigger Response Structure: A cron trigger defines the cron expression that is used to determine when it has to fire. The resulting response for such a trigger implementation is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 490 { ""group"" : ""samples"", ""name"" : ""example"", ""description"" : ""Example trigger"", ""state"" : ""NORMAL"", ""type"" : ""cron"", ""calendarName"" : ""bankHolidays"", ""startTime"" : ""2020-11-30T17:00:00.000+00:00"", ""endTime"" : ""2020-12-30T03:00:00.000+00:00"", ""previousFireTime"" : ""2020-12-04T03:00:00.000+00:00"", ""nextFireTime"" : ""2020-12-07T03:00:00.000+00:00"", ""priority"" : 3, ""data"" : { }, ""cron"" : { ""expression"" : ""0 0 3 ? * 1,2,3,4,5"", ""timeZone"" : ""Europe/Paris"" } } Much of the response is common to all trigger types. The structure of the common elements of the response was described previously(#quartz.trigger.common-response-structure) . The following table describes the structure of the parts of the response that are specific to cron triggers: Path Type Description cron Object Cron trigger specific details. cron.expression String Cron expression to use. cron.timeZone String Time zone for which the expression will be resolved, if any. Simple Trigger Response Structure: A simple trigger is used to fire a Job at a given moment in time, and optionally repeated at a specified interval. The resulting response for such a trigger implementation is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 549 { ""group"" : ""samples"", ""name"" : ""example"", ""description"" : ""Example trigger"", ""state"" : ""NORMAL"", ""type"" : ""simple"", ""calendarName"" : ""bankHolidays"", ""startTime"" : ""2020-11-30T17:00:00.000+00:00"", ""endTime"" : ""2020-12-30T03:00:00.000+00:00"", ""previousFireTime"" : ""2020-12-04T03:00:00.000+00:00"", ""nextFireTime"" : ""2020-12-07T03:00:00.000+00:00"", ""priority"" : 7, ""finalFireTime"" : ""2020-12-29T17:00:00.000+00:00"", ""data"" : { }, ""simple"" : { ""interval"" : 86400000, ""repeatCount"" : -1, ""timesTriggered"" : 0 } } Much of the response is common to all trigger types. The structure of the common elements of the response was described previously(#quartz.trigger.common-response-structure) . The following table describes the structure of the parts of the response that are specific to simple triggers: Path Type Description simple Object Simple trigger specific details. simple.interval Number Interval, in milliseconds, between two executions. simple.repeatCount Number Number of times the trigger should repeat, or -1 to repeat indefinitely. simple.timesTriggered Number Number of times the trigger has already fired. Daily Time Interval Trigger Response Structure: A daily time interval trigger is used to fire a Job based upon daily repeating time intervals. The resulting response for such a trigger implementation is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 667 { ""group"" : ""samples"", ""name"" : ""example"", ""description"" : ""Example trigger"", ""state"" : ""PAUSED"", ""type"" : ""dailyTimeInterval"", ""calendarName"" : ""bankHolidays"", ""startTime"" : ""2020-11-30T17:00:00.000+00:00"", ""endTime"" : ""2020-12-30T03:00:00.000+00:00"", ""previousFireTime"" : ""2020-12-04T03:00:00.000+00:00"", ""nextFireTime"" : ""2020-12-07T03:00:00.000+00:00"", ""priority"" : 5, ""finalFireTime"" : ""2020-12-30T18:00:00.000+00:00"", ""data"" : { }, ""dailyTimeInterval"" : { ""interval"" : 3600000, ""daysOfWeek"" : [ 3, 5 ], ""startTimeOfDay"" : ""09:00:00"", ""endTimeOfDay"" : ""18:00:00"", ""repeatCount"" : -1, ""timesTriggered"" : 0 } } Much of the response is common to all trigger types. The structure of the common elements of the response was described previously(#quartz.trigger.common-response-structure) . The following table describes the structure of the parts of the response that are specific to daily time interval triggers: Path Type Description dailyTimeInterval Object Daily time interval trigger specific details. dailyTimeInterval.interval Number Interval, in milliseconds, added to the fire time in order to calculate the time of the next trigger repeat. dailyTimeInterval.daysOfWeek Array An array of days of the week upon which to fire. dailyTimeInterval.startTimeOfDay String Time of day to start firing at the given interval, if any. dailyTimeInterval.endTimeOfDay String Time of day to complete firing at the given interval, if any. dailyTimeInterval.repeatCount Number Number of times the trigger should repeat, or -1 to repeat indefinitely. dailyTimeInterval.timesTriggered Number Number of times the trigger has already fired. Calendar Interval Trigger Response Structure: A calendar interval trigger is used to fire a Job based upon repeating calendar time intervals. The resulting response for such a trigger implementation is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 669 { ""group"" : ""samples"", ""name"" : ""example"", ""description"" : ""Example trigger"", ""state"" : ""NORMAL"", ""type"" : ""calendarInterval"", ""calendarName"" : ""bankHolidays"", ""startTime"" : ""2020-11-30T17:00:00.000+00:00"", ""endTime"" : ""2020-12-30T03:00:00.000+00:00"", ""previousFireTime"" : ""2020-12-04T03:00:00.000+00:00"", ""nextFireTime"" : ""2020-12-07T03:00:00.000+00:00"", ""priority"" : 5, ""finalFireTime"" : ""2020-12-28T17:00:00.000+00:00"", ""data"" : { }, ""calendarInterval"" : { ""interval"" : 604800000, ""timeZone"" : ""Etc/UTC"", ""timesTriggered"" : 0, ""preserveHourOfDayAcrossDaylightSavings"" : false, ""skipDayIfHourDoesNotExist"" : false } } Much of the response is common to all trigger types. The structure of the common elements of the response was described previously(#quartz.trigger.common-response-structure) . The following table describes the structure of the parts of the response that are specific to calendar interval triggers: Path Type Description calendarInterval Object Calendar interval trigger specific details. calendarInterval.interval Number Interval, in milliseconds, added to the fire time in order to calculate the time of the next trigger repeat. calendarInterval.timeZone String Time zone within which time calculations will be performed, if any. calendarInterval.timesTriggered Number Number of times the trigger has already fired. calendarInterval.preserveHourOfDayAcrossDaylightSavings Boolean Whether to fire the trigger at the same time of day, regardless of daylight saving time transitions. calendarInterval.skipDayIfHourDoesNotExist Boolean Whether to skip if the hour of the day does not exist on a given day. Custom Trigger Response Structure: A custom trigger is any other implementation. The resulting response for such a trigger implementation is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 457 { ""group"" : ""samples"", ""name"" : ""example"", ""description"" : ""Example trigger."", ""state"" : ""NORMAL"", ""type"" : ""custom"", ""calendarName"" : ""bankHolidays"", ""startTime"" : ""2020-11-30T17:00:00.000+00:00"", ""endTime"" : ""2020-12-30T03:00:00.000+00:00"", ""previousFireTime"" : ""2020-12-04T03:00:00.000+00:00"", ""nextFireTime"" : ""2020-12-07T03:00:00.000+00:00"", ""priority"" : 10, ""custom"" : { ""trigger"" : ""com.example.CustomTrigger@fdsfsd"" } } Much of the response is common to all trigger types. The structure of the common elements of the response was described previously(#quartz.trigger.common-response-structure) . The following table describes the structure of the parts of the response that are specific to custom triggers: Path Type Description custom Object Custom trigger specific details. custom.trigger String A toString representation of the custom trigger instance."
"https://docs.spring.io/spring-boot/api/rest/actuator/sbom.html","Software Bill of Materials (sbom): The sbom endpoint provides information about the software bill of materials (SBOM). Retrieving the Available SBOMs: To retrieve the available SBOMs, make a GET request to /actuator/sbom , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/sbom' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 31 { ""ids"" : [ ""application"" ] } Response Structure: The response contains the available SBOMs. The following table describes the structure of the response: Path Type Description ids Array An array of available SBOM ids. Retrieving a Single SBOM: To retrieve the available SBOMs, make a GET request to /actuator/sbom/{id} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/sbom/application' -i -X GET The preceding example retrieves the SBOM named application. The resulting response depends on the format of the SBOM. This example uses the CycloneDX format. HTTP/1.1 200 OK Content-Type: application/vnd.cyclonedx+json Accept-Ranges: bytes Content-Length: 160316 { ""bomFormat"" : ""CycloneDX"", ""specVersion"" : ""1.5"", ""serialNumber"" : ""urn:uuid:13862013-3360-43e5-8055-3645aa43c548"", ""version"" : 1, // ... } Response Structure: The response depends on the format of the SBOM: CycloneDX(https://cyclonedx.org/specification/overview/)"
"https://docs.spring.io/spring-boot/api/rest/actuator/scheduledtasks.html","Scheduled Tasks (scheduledtasks): The scheduledtasks endpoint provides information about the application’s scheduled tasks. Retrieving the Scheduled Tasks: To retrieve the scheduled tasks, make a GET request to /actuator/scheduledtasks , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/scheduledtasks' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 629 { ""cron"" : [ { ""runnable"" : { ""target"" : ""com.example.Processor.processOrders"" }, ""expression"" : ""0 0 0/3 1/1 * ?"" } ], ""fixedDelay"" : [ { ""runnable"" : { ""target"" : ""com.example.Processor.purge"" }, ""initialDelay"" : 5000, ""interval"" : 5000 } ], ""fixedRate"" : [ { ""runnable"" : { ""target"" : ""com.example.Processor.retrieveIssues"" }, ""initialDelay"" : 10000, ""interval"" : 3000 } ], ""custom"" : [ { ""runnable"" : { ""target"" : ""com.example.Processor$CustomTriggeredRunnable"" }, ""trigger"" : ""com.example.Processor$CustomTrigger@1d6ddb48"" } ] } Response Structure: The response contains details of the application’s scheduled tasks. The following table describes the structure of the response: Path Type Description cron Array Cron tasks, if any. cron.[].runnable.target String Target that will be executed. cron.[].expression String Cron expression. fixedDelay Array Fixed delay tasks, if any. fixedDelay.[].runnable.target String Target that will be executed. fixedDelay.[].initialDelay Number Delay, in milliseconds, before first execution. fixedDelay.[].interval Number Interval, in milliseconds, between the end of the last execution and the start of the next. fixedRate Array Fixed rate tasks, if any. fixedRate.[].runnable.target String Target that will be executed. fixedRate.[].interval Number Interval, in milliseconds, between the start of each execution. fixedRate.[].initialDelay Number Delay, in milliseconds, before first execution. custom Array Tasks with custom triggers, if any. custom.[].runnable.target String Target that will be executed. custom.[].trigger String Trigger for the task."
"https://docs.spring.io/spring-boot/api/rest/actuator/sessions.html","Sessions (sessions): The sessions endpoint provides information about the application’s HTTP sessions that are managed by Spring Session. Retrieving Sessions: To retrieve the sessions, make a GET request to /actuator/sessions , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/sessions?username=alice' -i -X GET The preceding examples retrieves all of the sessions for the user whose username is alice . The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 789 { ""sessions"" : [ { ""id"" : ""dcb8205c-bf12-4a67-8276-3465388cf3f1"", ""attributeNames"" : [ ], ""creationTime"" : ""2024-09-19T07:28:37.000609935Z"", ""lastAccessedTime"" : ""2024-09-19T09:28:25.000610867Z"", ""maxInactiveInterval"" : 1800, ""expired"" : false }, { ""id"" : ""4db5efcc-99cb-4d05-a52c-b49acfbb7ea9"", ""attributeNames"" : [ ], ""creationTime"" : ""2024-09-19T04:28:37.000603813Z"", ""lastAccessedTime"" : ""2024-09-19T09:28:00.000606348Z"", ""maxInactiveInterval"" : 1800, ""expired"" : false }, { ""id"" : ""e9cea084-1112-4c42-8f21-3c4dae14b6f0"", ""attributeNames"" : [ ], ""creationTime"" : ""2024-09-18T21:28:36.996894519Z"", ""lastAccessedTime"" : ""2024-09-19T09:27:51.996900210Z"", ""maxInactiveInterval"" : 1800, ""expired"" : false } ] } Query Parameters: The endpoint uses query parameters to limit the sessions that it returns. The following table shows the single required query parameter: Parameter Description username Name of the user. Response Structure: The response contains details of the matching sessions. The following table describes the structure of the response: Path Type Description sessions Array Sessions for the given username. sessions.[].id String ID of the session. sessions.[].attributeNames Array Names of the attributes stored in the session. sessions.[].creationTime String Timestamp of when the session was created. sessions.[].lastAccessedTime String Timestamp of when the session was last accessed. sessions.[].maxInactiveInterval Number Maximum permitted period of inactivity, in seconds, before the session will expire. sessions.[].expired Boolean Whether the session has expired. Retrieving a Single Session: To retrieve a single session, make a GET request to /actuator/sessions/{id} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/sessions/4db5efcc-99cb-4d05-a52c-b49acfbb7ea9' -i -X GET The preceding example retrieves the session with the id of 4db5efcc-99cb-4d05-a52c-b49acfbb7ea9 . The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 208 {""id"":""4db5efcc-99cb-4d05-a52c-b49acfbb7ea9"",""attributeNames"":[],""creationTime"":""2024-09-19T04:28:37.000603813Z"",""lastAccessedTime"":""2024-09-19T09:28:00.000606348Z"",""maxInactiveInterval"":1800,""expired"":false} Response Structure: The response contains details of the requested session. The following table describes the structure of the response: Path Type Description id String ID of the session. attributeNames Array Names of the attributes stored in the session. creationTime String Timestamp of when the session was created. lastAccessedTime String Timestamp of when the session was last accessed. maxInactiveInterval Number Maximum permitted period of inactivity, in seconds, before the session will expire. expired Boolean Whether the session has expired. Deleting a Session: To delete a session, make a DELETE request to /actuator/sessions/{id} , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/sessions/4db5efcc-99cb-4d05-a52c-b49acfbb7ea9' -i -X DELETE The preceding example deletes the session with the id of 4db5efcc-99cb-4d05-a52c-b49acfbb7ea9 ."
"https://docs.spring.io/spring-boot/api/rest/actuator/shutdown.html","Shutdown (shutdown): The shutdown endpoint is used to shut down the application. Shutting Down the Application: To shut down the application, make a POST request to /actuator/shutdown , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/shutdown' -i -X POST A response similar to the following is produced: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 41 { ""message"" : ""Shutting down, bye..."" } Response Structure: The response contains details of the result of the shutdown request. The following table describes the structure of the response: Path Type Description message String Message describing the result of the request."
"https://docs.spring.io/spring-boot/api/rest/actuator/startup.html","Application Startup (startup): The startup endpoint provides information about the application’s startup sequence. Retrieving the Application Startup Steps: The application startup steps can either be retrieved as a snapshot ( GET ) or drained from the buffer ( POST ). Retrieving a snapshot of the Application Startup Steps: To retrieve the steps recorded so far during the application startup phase, make a GET request to /actuator/startup , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/startup' -i -X GET The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 889 { ""springBootVersion"" : ""3.3.4"", ""timeline"" : { ""startTime"" : ""2024-09-19T09:28:38.943281778Z"", ""events"" : [ { ""endTime"" : ""2024-09-19T09:28:39.424524423Z"", ""duration"" : ""PT0.000005931S"", ""startTime"" : ""2024-09-19T09:28:39.424518492Z"", ""startupStep"" : { ""name"" : ""spring.beans.instantiate"", ""id"" : 3, ""tags"" : [ { ""key"" : ""beanName"", ""value"" : ""homeController"" } ], ""parentId"" : 2 } }, { ""endTime"" : ""2024-09-19T09:28:39.424530835Z"", ""duration"" : ""PT0.000019486S"", ""startTime"" : ""2024-09-19T09:28:39.424511349Z"", ""startupStep"" : { ""name"" : ""spring.boot.application.starting"", ""id"" : 2, ""tags"" : [ { ""key"" : ""mainApplicationClass"", ""value"" : ""com.example.startup.StartupApplication"" } ] } } ] } } Draining the Application Startup Steps: To drain and return the steps recorded so far during the application startup phase, make a POST request to /actuator/startup , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/startup' -i -X POST The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/vnd.spring-boot.actuator.v3+json Content-Length: 889 { ""springBootVersion"" : ""3.3.4"", ""timeline"" : { ""startTime"" : ""2024-09-19T09:28:38.943281778Z"", ""events"" : [ { ""endTime"" : ""2024-09-19T09:28:39.350665755Z"", ""duration"" : ""PT0.009626917S"", ""startTime"" : ""2024-09-19T09:28:39.341038838Z"", ""startupStep"" : { ""name"" : ""spring.beans.instantiate"", ""id"" : 1, ""tags"" : [ { ""key"" : ""beanName"", ""value"" : ""homeController"" } ], ""parentId"" : 0 } }, { ""endTime"" : ""2024-09-19T09:28:39.350709006Z"", ""duration"" : ""PT0.010630523S"", ""startTime"" : ""2024-09-19T09:28:39.340078483Z"", ""startupStep"" : { ""name"" : ""spring.boot.application.starting"", ""id"" : 0, ""tags"" : [ { ""key"" : ""mainApplicationClass"", ""value"" : ""com.example.startup.StartupApplication"" } ] } } ] } } Response Structure: The response contains details of the application startup steps. The following table describes the structure of the response: Path Type Description springBootVersion String Spring Boot version for this application. timeline.startTime String Start time of the application. timeline.events Array An array of steps collected during application startup so far. timeline.events.[].startTime String The timestamp of the start of this event. timeline.events.[].endTime String The timestamp of the end of this event. timeline.events.[].duration String The precise duration of this event. timeline.events.[].startupStep.name String The name of the StartupStep. timeline.events.[].startupStep.id Number The id of this StartupStep. timeline.events.[].startupStep.parentId Number The parent id for this StartupStep. timeline.events.[].startupStep.tags Array An array of key/value pairs with additional step info. timeline.events.[].startupStep.tags[].key String The key of the StartupStep Tag. timeline.events.[].startupStep.tags[].value String The value of the StartupStep Tag."
"https://docs.spring.io/spring-boot/api/rest/actuator/threaddump.html","Thread Dump (threaddump): The threaddump endpoint provides a thread dump from the application’s JVM. Retrieving the Thread Dump as JSON: To retrieve the thread dump as JSON, make a GET request to /actuator/threaddump with an appropriate Accept header, as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/threaddump' -i -X GET \ -H 'Accept: application/json' The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: application/json Content-Length: 38917 { ""threads"" : [ { ""threadName"" : ""Test worker"", ""threadId"" : 1, ""blockedTime"" : -1, ""blockedCount"" : 46, ""waitedTime"" : -1, ""waitedCount"" : 40, ""lockOwnerId"" : -1, ""daemon"" : false, ""inNative"" : false, ""suspended"" : false, ""threadState"" : ""RUNNABLE"", ""priority"" : 5, ""stackTrace"" : [ { ""moduleName"" : ""java.management"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""dumpThreads0"", ""fileName"" : ""ThreadImpl.java"", ""lineNumber"" : -2, ""nativeMethod"" : true, ""className"" : ""sun.management.ThreadImpl"" }, { ""moduleName"" : ""java.management"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""dumpAllThreads"", ""fileName"" : ""ThreadImpl.java"", ""lineNumber"" : 528, ""nativeMethod"" : false, ""className"" : ""sun.management.ThreadImpl"" }, { ""moduleName"" : ""java.management"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""dumpAllThreads"", ""fileName"" : ""ThreadImpl.java"", ""lineNumber"" : 516, ""nativeMethod"" : false, ""className"" : ""sun.management.ThreadImpl"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""getFormattedThreadDump"", ""fileName"" : ""ThreadDumpEndpoint.java"", ""lineNumber"" : 52, ""nativeMethod"" : false, ""className"" : ""org.springframework.boot.actuate.management.ThreadDumpEndpoint"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""threadDump"", ""fileName"" : ""ThreadDumpEndpoint.java"", ""lineNumber"" : 43, ""nativeMethod"" : false, ""className"" : ""org.springframework.boot.actuate.management.ThreadDumpEndpoint"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke0"", ""fileName"" : ""NativeMethodAccessorImpl.java"", ""lineNumber"" : -2, ""nativeMethod"" : true, ""className"" : ""jdk.internal.reflect.NativeMethodAccessorImpl"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke"", ""fileName"" : ""NativeMethodAccessorImpl.java"", ""lineNumber"" : 77, ""nativeMethod"" : false, ""className"" : ""jdk.internal.reflect.NativeMethodAccessorImpl"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke"", ""fileName"" : ""DelegatingMethodAccessorImpl.java"", ""lineNumber"" : 43, ""nativeMethod"" : false, ""className"" : ""jdk.internal.reflect.DelegatingMethodAccessorImpl"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke"", ""fileName"" : ""Method.java"", ""lineNumber"" : 569, ""nativeMethod"" : false, ""className"" : ""java.lang.reflect.Method"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invokeMethod"", ""fileName"" : ""ReflectionUtils.java"", ""lineNumber"" : 281, ""nativeMethod"" : false, ""className"" : ""org.springframework.util.ReflectionUtils"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invoke"", ""fileName"" : ""ReflectiveOperationInvoker.java"", ""lineNumber"" : 74, ""nativeMethod"" : false, ""className"" : ""org.springframework.boot.actuate.endpoint.invoke.reflect.ReflectiveOperationInvoker"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invoke"", ""fileName"" : ""AbstractDiscoveredOperation.java"", ""lineNumber"" : 60, ""nativeMethod"" : false, ""className"" : ""org.springframework.boot.actuate.endpoint.annotation.AbstractDiscoveredOperation"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""handle"", ""fileName"" : ""AbstractWebMvcEndpointHandlerMapping.java"", ""lineNumber"" : 327, ""nativeMethod"" : false, ""className"" : ""org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping$ServletWebOperationAdapter"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""handle"", ""fileName"" : ""AbstractWebMvcEndpointHandlerMapping.java"", ""lineNumber"" : 434, ""nativeMethod"" : false, ""className"" : ""org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping$OperationHandler"" }, { ""methodName"" : ""invoke"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""jdk.internal.reflect.GeneratedMethodAccessor64"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke"", ""fileName"" : ""DelegatingMethodAccessorImpl.java"", ""lineNumber"" : 43, ""nativeMethod"" : false, ""className"" : ""jdk.internal.reflect.DelegatingMethodAccessorImpl"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke"", ""fileName"" : ""Method.java"", ""lineNumber"" : 569, ""nativeMethod"" : false, ""className"" : ""java.lang.reflect.Method"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""doInvoke"", ""fileName"" : ""InvocableHandlerMethod.java"", ""lineNumber"" : 255, ""nativeMethod"" : false, ""className"" : ""org.springframework.web.method.support.InvocableHandlerMethod"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invokeForRequest"", ""fileName"" : ""InvocableHandlerMethod.java"", ""lineNumber"" : 188, ""nativeMethod"" : false, ""className"" : ""org.springframework.web.method.support.InvocableHandlerMethod"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invokeAndHandle"", ""fileName"" : ""ServletInvocableHandlerMethod.java"", ""lineNumber"" : 118, ""nativeMethod"" : false, ""className"" : ""org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invokeHandlerMethod"", ""fileName"" : ""RequestMappingHandlerAdapter.java"", ""lineNumber"" : 926, ""nativeMethod"" : false, ""className"" : ""org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""handleInternal"", ""fileName"" : ""RequestMappingHandlerAdapter.java"", ""lineNumber"" : 831, ""nativeMethod"" : false, ""className"" : ""org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""handle"", ""fileName"" : ""AbstractHandlerMethodAdapter.java"", ""lineNumber"" : 87, ""nativeMethod"" : false, ""className"" : ""org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""doDispatch"", ""fileName"" : ""DispatcherServlet.java"", ""lineNumber"" : 1089, ""nativeMethod"" : false, ""className"" : ""org.springframework.web.servlet.DispatcherServlet"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""doService"", ""fileName"" : ""DispatcherServlet.java"", ""lineNumber"" : 979, ""nativeMethod"" : false, ""className"" : ""org.springframework.web.servlet.DispatcherServlet"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""processRequest"", ""fileName"" : ""FrameworkServlet.java"", ""lineNumber"" : 1014, ""nativeMethod"" : false, ""className"" : ""org.springframework.web.servlet.FrameworkServlet"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""doGet"", ""fileName"" : ""FrameworkServlet.java"", ""lineNumber"" : 903, ""nativeMethod"" : false, ""className"" : ""org.springframework.web.servlet.FrameworkServlet"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""service"", ""fileName"" : ""HttpServlet.java"", ""lineNumber"" : 527, ""nativeMethod"" : false, ""className"" : ""jakarta.servlet.http.HttpServlet"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""service"", ""fileName"" : ""FrameworkServlet.java"", ""lineNumber"" : 885, ""nativeMethod"" : false, ""className"" : ""org.springframework.web.servlet.FrameworkServlet"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""service"", ""fileName"" : ""TestDispatcherServlet.java"", ""lineNumber"" : 72, ""nativeMethod"" : false, ""className"" : ""org.springframework.test.web.servlet.TestDispatcherServlet"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""service"", ""fileName"" : ""HttpServlet.java"", ""lineNumber"" : 614, ""nativeMethod"" : false, ""className"" : ""jakarta.servlet.http.HttpServlet"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""doFilter"", ""fileName"" : ""MockFilterChain.java"", ""lineNumber"" : 165, ""nativeMethod"" : false, ""className"" : ""org.springframework.mock.web.MockFilterChain$ServletFilterProxy"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""doFilter"", ""fileName"" : ""MockFilterChain.java"", ""lineNumber"" : 132, ""nativeMethod"" : false, ""className"" : ""org.springframework.mock.web.MockFilterChain"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""perform"", ""fileName"" : ""MockMvc.java"", ""lineNumber"" : 201, ""nativeMethod"" : false, ""className"" : ""org.springframework.test.web.servlet.MockMvc"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""jsonThreadDump"", ""fileName"" : ""ThreadDumpEndpointDocumentationTests.java"", ""lineNumber"" : 66, ""nativeMethod"" : false, ""className"" : ""org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation.ThreadDumpEndpointDocumentationTests"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke0"", ""fileName"" : ""NativeMethodAccessorImpl.java"", ""lineNumber"" : -2, ""nativeMethod"" : true, ""className"" : ""jdk.internal.reflect.NativeMethodAccessorImpl"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke"", ""fileName"" : ""NativeMethodAccessorImpl.java"", ""lineNumber"" : 77, ""nativeMethod"" : false, ""className"" : ""jdk.internal.reflect.NativeMethodAccessorImpl"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke"", ""fileName"" : ""DelegatingMethodAccessorImpl.java"", ""lineNumber"" : 43, ""nativeMethod"" : false, ""className"" : ""jdk.internal.reflect.DelegatingMethodAccessorImpl"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke"", ""fileName"" : ""Method.java"", ""lineNumber"" : 569, ""nativeMethod"" : false, ""className"" : ""java.lang.reflect.Method"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invokeMethod"", ""fileName"" : ""ReflectionUtils.java"", ""lineNumber"" : 728, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.commons.util.ReflectionUtils"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""proceed"", ""fileName"" : ""MethodInvocation.java"", ""lineNumber"" : 60, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.execution.MethodInvocation"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""proceed"", ""fileName"" : ""InvocationInterceptorChain.java"", ""lineNumber"" : 131, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""intercept"", ""fileName"" : ""TimeoutExtension.java"", ""lineNumber"" : 156, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.extension.TimeoutExtension"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""interceptTestableMethod"", ""fileName"" : ""TimeoutExtension.java"", ""lineNumber"" : 147, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.extension.TimeoutExtension"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""interceptTestMethod"", ""fileName"" : ""TimeoutExtension.java"", ""lineNumber"" : 86, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.extension.TimeoutExtension"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""apply"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor$$Lambda$204/0x00007f79a8136068"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$ofVoidMethod$0"", ""fileName"" : ""InterceptingExecutableInvoker.java"", ""lineNumber"" : 103, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""apply"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall$$Lambda$205/0x00007f79a8136488"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$invoke$0"", ""fileName"" : ""InterceptingExecutableInvoker.java"", ""lineNumber"" : 93, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.execution.InterceptingExecutableInvoker"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""apply"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$$Lambda$489/0x00007f79a81e6200"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""proceed"", ""fileName"" : ""InvocationInterceptorChain.java"", ""lineNumber"" : 106, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""proceed"", ""fileName"" : ""InvocationInterceptorChain.java"", ""lineNumber"" : 64, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.execution.InvocationInterceptorChain"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""chainAndInvoke"", ""fileName"" : ""InvocationInterceptorChain.java"", ""lineNumber"" : 45, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.execution.InvocationInterceptorChain"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invoke"", ""fileName"" : ""InvocationInterceptorChain.java"", ""lineNumber"" : 37, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.execution.InvocationInterceptorChain"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invoke"", ""fileName"" : ""InterceptingExecutableInvoker.java"", ""lineNumber"" : 92, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.execution.InterceptingExecutableInvoker"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invoke"", ""fileName"" : ""InterceptingExecutableInvoker.java"", ""lineNumber"" : 86, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.execution.InterceptingExecutableInvoker"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$invokeTestMethod$7"", ""fileName"" : ""TestMethodTestDescriptor.java"", ""lineNumber"" : 218, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor$$Lambda$1033/0x00007f79a85ee8d8"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""ThrowableCollector.java"", ""lineNumber"" : 73, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.ThrowableCollector"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invokeTestMethod"", ""fileName"" : ""TestMethodTestDescriptor.java"", ""lineNumber"" : 214, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""TestMethodTestDescriptor.java"", ""lineNumber"" : 139, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""TestMethodTestDescriptor.java"", ""lineNumber"" : 69, ""nativeMethod"" : false, ""className"" : ""org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$executeRecursively$6"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 151, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$306/0x00007f79a8156428"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""ThrowableCollector.java"", ""lineNumber"" : 73, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.ThrowableCollector"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$executeRecursively$8"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 141, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invoke"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$305/0x00007f79a8156200"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""around"", ""fileName"" : ""Node.java"", ""lineNumber"" : 137, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.Node"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$executeRecursively$9"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 139, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$304/0x00007f79a8153c98"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""ThrowableCollector.java"", ""lineNumber"" : 73, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.ThrowableCollector"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""executeRecursively"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 138, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 95, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""accept"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService$$Lambda$310/0x00007f79a8156f40"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""forEach"", ""fileName"" : ""ArrayList.java"", ""lineNumber"" : 1511, ""nativeMethod"" : false, ""className"" : ""java.util.ArrayList"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invokeAll"", ""fileName"" : ""SameThreadHierarchicalTestExecutorService.java"", ""lineNumber"" : 41, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$executeRecursively$6"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 155, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$306/0x00007f79a8156428"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""ThrowableCollector.java"", ""lineNumber"" : 73, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.ThrowableCollector"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$executeRecursively$8"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 141, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invoke"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$305/0x00007f79a8156200"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""around"", ""fileName"" : ""Node.java"", ""lineNumber"" : 137, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.Node"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$executeRecursively$9"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 139, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$304/0x00007f79a8153c98"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""ThrowableCollector.java"", ""lineNumber"" : 73, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.ThrowableCollector"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""executeRecursively"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 138, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 95, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""accept"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService$$Lambda$310/0x00007f79a8156f40"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""forEach"", ""fileName"" : ""ArrayList.java"", ""lineNumber"" : 1511, ""nativeMethod"" : false, ""className"" : ""java.util.ArrayList"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invokeAll"", ""fileName"" : ""SameThreadHierarchicalTestExecutorService.java"", ""lineNumber"" : 41, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$executeRecursively$6"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 155, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$306/0x00007f79a8156428"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""ThrowableCollector.java"", ""lineNumber"" : 73, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.ThrowableCollector"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$executeRecursively$8"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 141, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""invoke"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$305/0x00007f79a8156200"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""around"", ""fileName"" : ""Node.java"", ""lineNumber"" : 137, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.Node"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$executeRecursively$9"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 139, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$304/0x00007f79a8153c98"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""ThrowableCollector.java"", ""lineNumber"" : 73, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.ThrowableCollector"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""executeRecursively"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 138, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""NodeTestTask.java"", ""lineNumber"" : 95, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.NodeTestTask"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""submit"", ""fileName"" : ""SameThreadHierarchicalTestExecutorService.java"", ""lineNumber"" : 35, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""HierarchicalTestExecutor.java"", ""lineNumber"" : 57, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""HierarchicalTestEngine.java"", ""lineNumber"" : 54, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""EngineExecutionOrchestrator.java"", ""lineNumber"" : 198, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.launcher.core.EngineExecutionOrchestrator"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""EngineExecutionOrchestrator.java"", ""lineNumber"" : 169, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.launcher.core.EngineExecutionOrchestrator"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""EngineExecutionOrchestrator.java"", ""lineNumber"" : 93, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.launcher.core.EngineExecutionOrchestrator"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""lambda$execute$0"", ""fileName"" : ""EngineExecutionOrchestrator.java"", ""lineNumber"" : 58, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.launcher.core.EngineExecutionOrchestrator"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""accept"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.launcher.core.EngineExecutionOrchestrator$$Lambda$259/0x00007f79a8141180"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""withInterceptedStreams"", ""fileName"" : ""EngineExecutionOrchestrator.java"", ""lineNumber"" : 141, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.launcher.core.EngineExecutionOrchestrator"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""EngineExecutionOrchestrator.java"", ""lineNumber"" : 57, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.launcher.core.EngineExecutionOrchestrator"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""DefaultLauncher.java"", ""lineNumber"" : 103, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.launcher.core.DefaultLauncher"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""DefaultLauncher.java"", ""lineNumber"" : 85, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.launcher.core.DefaultLauncher"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""DelegatingLauncher.java"", ""lineNumber"" : 47, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.launcher.core.DelegatingLauncher"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""execute"", ""fileName"" : ""SessionPerRequestLauncher.java"", ""lineNumber"" : 63, ""nativeMethod"" : false, ""className"" : ""org.junit.platform.launcher.core.SessionPerRequestLauncher"" }, { ""methodName"" : ""processAllTestClasses"", ""fileName"" : ""JUnitPlatformTestClassProcessor.java"", ""lineNumber"" : 99, ""nativeMethod"" : false, ""className"" : ""org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor"" }, { ""methodName"" : ""access$000"", ""fileName"" : ""JUnitPlatformTestClassProcessor.java"", ""lineNumber"" : 79, ""nativeMethod"" : false, ""className"" : ""org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor"" }, { ""methodName"" : ""stop"", ""fileName"" : ""JUnitPlatformTestClassProcessor.java"", ""lineNumber"" : 75, ""nativeMethod"" : false, ""className"" : ""org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor"" }, { ""methodName"" : ""stop"", ""fileName"" : ""SuiteTestClassProcessor.java"", ""lineNumber"" : 62, ""nativeMethod"" : false, ""className"" : ""org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke0"", ""fileName"" : ""NativeMethodAccessorImpl.java"", ""lineNumber"" : -2, ""nativeMethod"" : true, ""className"" : ""jdk.internal.reflect.NativeMethodAccessorImpl"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke"", ""fileName"" : ""NativeMethodAccessorImpl.java"", ""lineNumber"" : 77, ""nativeMethod"" : false, ""className"" : ""jdk.internal.reflect.NativeMethodAccessorImpl"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke"", ""fileName"" : ""DelegatingMethodAccessorImpl.java"", ""lineNumber"" : 43, ""nativeMethod"" : false, ""className"" : ""jdk.internal.reflect.DelegatingMethodAccessorImpl"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""invoke"", ""fileName"" : ""Method.java"", ""lineNumber"" : 569, ""nativeMethod"" : false, ""className"" : ""java.lang.reflect.Method"" }, { ""methodName"" : ""dispatch"", ""fileName"" : ""ReflectionDispatch.java"", ""lineNumber"" : 36, ""nativeMethod"" : false, ""className"" : ""org.gradle.internal.dispatch.ReflectionDispatch"" }, { ""methodName"" : ""dispatch"", ""fileName"" : ""ReflectionDispatch.java"", ""lineNumber"" : 24, ""nativeMethod"" : false, ""className"" : ""org.gradle.internal.dispatch.ReflectionDispatch"" }, { ""methodName"" : ""dispatch"", ""fileName"" : ""ContextClassLoaderDispatch.java"", ""lineNumber"" : 33, ""nativeMethod"" : false, ""className"" : ""org.gradle.internal.dispatch.ContextClassLoaderDispatch"" }, { ""methodName"" : ""invoke"", ""fileName"" : ""ProxyDispatchAdapter.java"", ""lineNumber"" : 94, ""nativeMethod"" : false, ""className"" : ""org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler"" }, { ""moduleName"" : ""jdk.proxy1"", ""methodName"" : ""stop"", ""lineNumber"" : -1, ""nativeMethod"" : false, ""className"" : ""jdk.proxy1.$Proxy2"" }, { ""methodName"" : ""run"", ""fileName"" : ""TestWorker.java"", ""lineNumber"" : 193, ""nativeMethod"" : false, ""className"" : ""org.gradle.api.internal.tasks.testing.worker.TestWorker$3"" }, { ""methodName"" : ""executeAndMaintainThreadName"", ""fileName"" : ""TestWorker.java"", ""lineNumber"" : 129, ""nativeMethod"" : false, ""className"" : ""org.gradle.api.internal.tasks.testing.worker.TestWorker"" }, { ""methodName"" : ""execute"", ""fileName"" : ""TestWorker.java"", ""lineNumber"" : 100, ""nativeMethod"" : false, ""className"" : ""org.gradle.api.internal.tasks.testing.worker.TestWorker"" }, { ""methodName"" : ""execute"", ""fileName"" : ""TestWorker.java"", ""lineNumber"" : 60, ""nativeMethod"" : false, ""className"" : ""org.gradle.api.internal.tasks.testing.worker.TestWorker"" }, { ""methodName"" : ""execute"", ""fileName"" : ""ActionExecutionWorker.java"", ""lineNumber"" : 56, ""nativeMethod"" : false, ""className"" : ""org.gradle.process.internal.worker.child.ActionExecutionWorker"" }, { ""methodName"" : ""call"", ""fileName"" : ""SystemApplicationClassLoaderWorker.java"", ""lineNumber"" : 113, ""nativeMethod"" : false, ""className"" : ""org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker"" }, { ""methodName"" : ""call"", ""fileName"" : ""SystemApplicationClassLoaderWorker.java"", ""lineNumber"" : 65, ""nativeMethod"" : false, ""className"" : ""org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""run"", ""fileName"" : ""GradleWorkerMain.java"", ""lineNumber"" : 69, ""nativeMethod"" : false, ""className"" : ""worker.org.gradle.process.internal.worker.GradleWorkerMain"" }, { ""classLoaderName"" : ""app"", ""methodName"" : ""main"", ""fileName"" : ""GradleWorkerMain.java"", ""lineNumber"" : 74, ""nativeMethod"" : false, ""className"" : ""worker.org.gradle.process.internal.worker.GradleWorkerMain"" } ], ""lockedMonitors"" : [ ], ""lockedSynchronizers"" : [ ] }, { ""threadName"" : ""Reference Handler"", ""threadId"" : 2, ""blockedTime"" : -1, ""blockedCount"" : 0, ""waitedTime"" : -1, ""waitedCount"" : 0, ""lockOwnerId"" : -1, ""daemon"" : true, ""inNative"" : false, ""suspended"" : false, ""threadState"" : ""RUNNABLE"", ""priority"" : 10, ""stackTrace"" : [ { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""waitForReferencePendingList"", ""fileName"" : ""Reference.java"", ""lineNumber"" : -2, ""nativeMethod"" : true, ""className"" : ""java.lang.ref.Reference"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""processPendingReferences"", ""fileName"" : ""Reference.java"", ""lineNumber"" : 253, ""nativeMethod"" : false, ""className"" : ""java.lang.ref.Reference"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""run"", ""fileName"" : ""Reference.java"", ""lineNumber"" : 215, ""nativeMethod"" : false, ""className"" : ""java.lang.ref.Reference$ReferenceHandler"" } ], ""lockedMonitors"" : [ ], ""lockedSynchronizers"" : [ ] }, { ""threadName"" : ""Finalizer"", ""threadId"" : 3, ""blockedTime"" : -1, ""blockedCount"" : 1, ""waitedTime"" : -1, ""waitedCount"" : 2, ""lockName"" : ""java.lang.ref.ReferenceQueue$Lock@62b17f08"", ""lockOwnerId"" : -1, ""daemon"" : true, ""inNative"" : false, ""suspended"" : false, ""threadState"" : ""WAITING"", ""priority"" : 8, ""stackTrace"" : [ { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""wait"", ""lineNumber"" : -2, ""nativeMethod"" : true, ""className"" : ""java.lang.Object"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""remove"", ""fileName"" : ""ReferenceQueue.java"", ""lineNumber"" : 155, ""nativeMethod"" : false, ""className"" : ""java.lang.ref.ReferenceQueue"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""remove"", ""fileName"" : ""ReferenceQueue.java"", ""lineNumber"" : 176, ""nativeMethod"" : false, ""className"" : ""java.lang.ref.ReferenceQueue"" }, { ""moduleName"" : ""java.base"", ""moduleVersion"" : ""17.0.12"", ""methodName"" : ""run"", ""fileName"" : ""Finalizer.java"", ""lineNumber"" : 172, ""nativeMethod"" : false, ""className"" : ""java.lang.ref.Finalizer$FinalizerThread"" } ], ""lockedMonitors"" : [ ], ""lockedSynchronizers"" : [ ], ""lockInfo"" : { ""className"" : ""java.lang.ref.ReferenceQueue$Lock"", ""identityHashCode"" : 1655799560 } } ] } Response Structure: The response contains details of the JVM’s threads. The following table describes the structure of the response: Path Type Description threads Array JVM’s threads. threads.[].blockedCount Number Total number of times that the thread has been blocked. threads.[].blockedTime Number Time in milliseconds that the thread has spent blocked. -1 if thread contention monitoring is disabled. threads.[].daemon Boolean Whether the thread is a daemon thread. Only available on Java 9 or later. threads.[].inNative Boolean Whether the thread is executing native code. threads.[].lockName String Description of the object on which the thread is blocked, if any. threads.[].lockInfo Object Object for which the thread is blocked waiting. threads.[].lockInfo.className String Fully qualified class name of the lock object. threads.[].lockInfo.identityHashCode Number Identity hash code of the lock object. threads.[].lockedMonitors Array Monitors locked by this thread, if any threads.[].lockedMonitors.[].className String Class name of the lock object. threads.[].lockedMonitors.[].identityHashCode Number Identity hash code of the lock object. threads.[].lockedMonitors.[].lockedStackDepth Number Stack depth where the monitor was locked. threads.[].lockedMonitors.[].lockedStackFrame Object Stack frame that locked the monitor. threads.[].lockedSynchronizers Array Synchronizers locked by this thread. threads.[].lockedSynchronizers.[].className String Class name of the locked synchronizer. threads.[].lockedSynchronizers.[].identityHashCode Number Identity hash code of the locked synchronizer. threads.[].lockOwnerId Number ID of the thread that owns the object on which the thread is blocked. -1 if the thread is not blocked. threads.[].lockOwnerName String Name of the thread that owns the object on which the thread is blocked, if any. threads.[].priority Number Priority of the thread. Only available on Java 9 or later. threads.[].stackTrace Array Stack trace of the thread. threads.[].stackTrace.[].classLoaderName String Name of the class loader of the class that contains the execution point identified by this entry, if any. Only available on Java 9 or later. threads.[].stackTrace.[].className String Name of the class that contains the execution point identified by this entry. threads.[].stackTrace.[].fileName String Name of the source file that contains the execution point identified by this entry, if any. threads.[].stackTrace.[].lineNumber Number Line number of the execution point identified by this entry. Negative if unknown. threads.[].stackTrace.[].methodName String Name of the method. threads.[].stackTrace.[].moduleName String Name of the module that contains the execution point identified by this entry, if any. Only available on Java 9 or later. threads.[].stackTrace.[].moduleVersion String Version of the module that contains the execution point identified by this entry, if any. Only available on Java 9 or later. threads.[].stackTrace.[].nativeMethod Boolean Whether the execution point is a native method. threads.[].suspended Boolean Whether the thread is suspended. threads.[].threadId Number ID of the thread. threads.[].threadName String Name of the thread. threads.[].threadState String State of the thread ( NEW , RUNNABLE , BLOCKED , WAITING , TIMED_WAITING , TERMINATED ). threads.[].waitedCount Number Total number of times that the thread has waited for notification. threads.[].waitedTime Number Time in milliseconds that the thread has spent waiting. -1 if thread contention monitoring is disabled Retrieving the Thread Dump as Text: To retrieve the thread dump as text, make a GET request to /actuator/threaddump that accepts text/plain , as shown in the following curl-based example: $ curl 'http://localhost:8080/actuator/threaddump' -i -X GET \ -H 'Accept: text/plain' The resulting response is similar to the following: HTTP/1.1 200 OK Content-Type: text/plain;charset=UTF-8 Content-Length: 52644 2024-09-19 09:28:40 Full thread dump OpenJDK 64-Bit Server VM (17.0.12+10-LTS mixed mode, sharing): ""Test worker"" - Thread t@1 java.lang.Thread.State: RUNNABLE at [email protected](/cdn-cgi/l/email-protection) /sun.management.ThreadImpl.dumpThreads0(Native Method) at [email protected](/cdn-cgi/l/email-protection) /sun.management.ThreadImpl.dumpAllThreads(ThreadImpl.java:528) at [email protected](/cdn-cgi/l/email-protection) /sun.management.ThreadImpl.dumpAllThreads(ThreadImpl.java:516) at app//org.springframework.boot.actuate.management.ThreadDumpEndpoint.getFormattedThreadDump(ThreadDumpEndpoint.java:52) at app//org.springframework.boot.actuate.management.ThreadDumpEndpoint.textThreadDump(ThreadDumpEndpoint.java:48) at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at [email protected](/cdn-cgi/l/email-protection) /java.lang.reflect.Method.invoke(Method.java:569) at app//org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:281) at app//org.springframework.boot.actuate.endpoint.invoke.reflect.ReflectiveOperationInvoker.invoke(ReflectiveOperationInvoker.java:74) at app//org.springframework.boot.actuate.endpoint.annotation.AbstractDiscoveredOperation.invoke(AbstractDiscoveredOperation.java:60) at app//org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping$ServletWebOperationAdapter.handle(AbstractWebMvcEndpointHandlerMapping.java:327) at app//org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping$OperationHandler.handle(AbstractWebMvcEndpointHandlerMapping.java:434) at jdk.internal.reflect.GeneratedMethodAccessor64.invoke(Unknown Source) at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at [email protected](/cdn-cgi/l/email-protection) /java.lang.reflect.Method.invoke(Method.java:569) at app//org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:255) at app//org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:188) at app//org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118) at app//org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:926) at app//org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:831) at app//org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at app//org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089) at app//org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979) at app//org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) at app//org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903) at app//jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527) at app//org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885) at app//org.springframework.test.web.servlet.TestDispatcherServlet.service(TestDispatcherServlet.java:72) at app//jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614) at app//org.springframework.mock.web.MockFilterChain$ServletFilterProxy.doFilter(MockFilterChain.java:165) at app//org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:132) at app//org.springframework.test.web.servlet.MockMvc.perform(MockMvc.java:201) at app//org.springframework.boot.actuate.autoconfigure.endpoint.web.documentation.ThreadDumpEndpointDocumentationTests.textThreadDump(ThreadDumpEndpointDocumentationTests.java:182) at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at [email protected](/cdn-cgi/l/email-protection) /java.lang.reflect.Method.invoke(Method.java:569) at app//org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:728) at app//org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) at app//org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) at app//org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:156) at app//org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:147) at app//org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:86) at app//org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor$$Lambda$204/0x00007f79a8136068.apply(Unknown Source) at app//org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(InterceptingExecutableInvoker.java:103) at app//org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall$$Lambda$205/0x00007f79a8136488.apply(Unknown Source) at app//org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.lambda$invoke$0(InterceptingExecutableInvoker.java:93) at app//org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$$Lambda$489/0x00007f79a81e6200.apply(Unknown Source) at app//org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) at app//org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) at app//org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) at app//org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) at app//org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:92) at app//org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:86) at app//org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:218) at app//org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor$$Lambda$1033/0x00007f79a85ee8d8.execute(Unknown Source) at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at app//org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:214) at app//org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:139) at app//org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:69) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$306/0x00007f79a8156428.execute(Unknown Source) at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$305/0x00007f79a8156200.invoke(Unknown Source) at app//org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$304/0x00007f79a8153c98.execute(Unknown Source) at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) at app//org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService$$Lambda$310/0x00007f79a8156f40.accept(Unknown Source) at [email protected](/cdn-cgi/l/email-protection) /java.util.ArrayList.forEach(ArrayList.java:1511) at app//org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$306/0x00007f79a8156428.execute(Unknown Source) at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$305/0x00007f79a8156200.invoke(Unknown Source) at app//org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$304/0x00007f79a8153c98.execute(Unknown Source) at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) at app//org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService$$Lambda$310/0x00007f79a8156f40.accept(Unknown Source) at [email protected](/cdn-cgi/l/email-protection) /java.util.ArrayList.forEach(ArrayList.java:1511) at app//org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$306/0x00007f79a8156428.execute(Unknown Source) at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$305/0x00007f79a8156200.invoke(Unknown Source) at app//org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$304/0x00007f79a8153c98.execute(Unknown Source) at app//org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) at app//org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35) at app//org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) at app//org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54) at app//org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:198) at app//org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:169) at app//org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:93) at app//org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:58) at app//org.junit.platform.launcher.core.EngineExecutionOrchestrator$$Lambda$259/0x00007f79a8141180.accept(Unknown Source) at app//org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:141) at app//org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:57) at app//org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:103) at app//org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:85) at app//org.junit.platform.launcher.core.DelegatingLauncher.execute(DelegatingLauncher.java:47) at app//org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:63) at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99) at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79) at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75) at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:62) at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at [email protected](/cdn-cgi/l/email-protection) /java.lang.reflect.Method.invoke(Method.java:569) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) at jdk.proxy1/jdk.proxy1.$Proxy2.stop(Unknown Source) at org.gradle.api.internal.tasks.testing.worker.TestWorker$3.run(TestWorker.java:193) at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129) at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100) at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60) at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56) at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:113) at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:65) at app//worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69) at app//worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74) Locked ownable synchronizers: - None ""Reference Handler"" - Thread t@2 java.lang.Thread.State: RUNNABLE at [email protected](/cdn-cgi/l/email-protection) /java.lang.ref.Reference.waitForReferencePendingList(Native Method) at [email protected](/cdn-cgi/l/email-protection) /java.lang.ref.Reference.processPendingReferences(Reference.java:253) at [email protected](/cdn-cgi/l/email-protection) /java.lang.ref.Reference$ReferenceHandler.run(Reference.java:215) Locked ownable synchronizers: - None ""Finalizer"" - Thread t@3 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /java.lang.Object.wait(Native Method) - waiting on <62b17f08> (a java.lang.ref.ReferenceQueue$Lock) at [email protected](/cdn-cgi/l/email-protection) /java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:155) at [email protected](/cdn-cgi/l/email-protection) /java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:176) at [email protected](/cdn-cgi/l/email-protection) /java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:172) Locked ownable synchronizers: - None ""Signal Dispatcher"" - Thread t@4 java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None ""Common-Cleaner"" - Thread t@11 java.lang.Thread.State: TIMED_WAITING at [email protected](/cdn-cgi/l/email-protection) /java.lang.Object.wait(Native Method) - waiting on <3c0ff70b> (a java.lang.ref.ReferenceQueue$Lock) at [email protected](/cdn-cgi/l/email-protection) /java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:155) at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.ref.CleanerImpl.run(CleanerImpl.java:140) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.InnocuousThread.run(InnocuousThread.java:162) Locked ownable synchronizers: - None ""Notification Thread"" - Thread t@12 java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None ""/127.0.0.1:40644 to /127.0.0.1:38869 workers"" - Thread t@14 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <2c5ff4a5> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at org.gradle.internal.remote.internal.hub.queue.EndPointQueue.take(EndPointQueue.java:49) at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:403) at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:49) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - Locked <2525ff7e> (a java.util.concurrent.ThreadPoolExecutor$Worker) ""/127.0.0.1:40644 to /127.0.0.1:38869 workers Thread 2"" - Thread t@15 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <2f5f543> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at org.gradle.internal.remote.internal.hub.queue.EndPointQueue.take(EndPointQueue.java:49) at org.gradle.internal.remote.internal.hub.MessageHub$ConnectionDispatch.run(MessageHub.java:322) at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:49) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - Locked <223aa2f7> (a java.util.concurrent.ThreadPoolExecutor$Worker) ""/127.0.0.1:40644 to /127.0.0.1:38869 workers Thread 3"" - Thread t@16 java.lang.Thread.State: RUNNABLE at [email protected](/cdn-cgi/l/email-protection) /sun.nio.ch.EPoll.wait(Native Method) at [email protected](/cdn-cgi/l/email-protection) /sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:118) at [email protected](/cdn-cgi/l/email-protection) /sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:129) - locked <6b55832a> (a sun.nio.ch.Util$2) - locked <7b08b589> (a sun.nio.ch.EPollSelectorImpl) at [email protected](/cdn-cgi/l/email-protection) /sun.nio.ch.SelectorImpl.select(SelectorImpl.java:146) at org.gradle.internal.remote.internal.inet.SocketConnection$SocketInputStream.read(SocketConnection.java:185) at com.esotericsoftware.kryo.io.Input.fill(Input.java:146) at com.esotericsoftware.kryo.io.Input.require(Input.java:178) at com.esotericsoftware.kryo.io.Input.readByte(Input.java:295) at org.gradle.internal.serialize.kryo.KryoBackedDecoder.readByte(KryoBackedDecoder.java:88) at org.gradle.internal.remote.internal.hub.InterHubMessageSerializer$MessageReader.read(InterHubMessageSerializer.java:64) at org.gradle.internal.remote.internal.hub.InterHubMessageSerializer$MessageReader.read(InterHubMessageSerializer.java:52) at org.gradle.internal.remote.internal.inet.SocketConnection.receive(SocketConnection.java:81) at org.gradle.internal.remote.internal.hub.MessageHub$ConnectionReceive.run(MessageHub.java:270) at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:49) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - Locked <57af006c> (a java.util.concurrent.ThreadPoolExecutor$Worker) ""process reaper"" - Thread t@20 java.lang.Thread.State: TIMED_WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <56fa1846> (a java.util.concurrent.SynchronousQueue$TransferStack) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:252) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:401) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:903) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1061) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1122) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""Attach Listener"" - Thread t@21 java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None ""HikariPool-1 housekeeper"" - Thread t@29 java.lang.Thread.State: TIMED_WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <11f18d60> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:252) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:1674) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1182) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:899) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1062) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1122) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""boundedElastic-evictor-1"" - Thread t@40 java.lang.Thread.State: TIMED_WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <35c3bf1c> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:252) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:1674) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1182) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:899) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1062) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1122) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""reactor-http-epoll-1"" - Thread t@41 java.lang.Thread.State: RUNNABLE at app//io.netty.channel.epoll.Native.epollWait(Native Method) at app//io.netty.channel.epoll.Native.epollWait(Native.java:220) at app//io.netty.channel.epoll.Native.epollWait(Native.java:213) at app//io.netty.channel.epoll.EpollEventLoop.epollWaitNoTimerChange(EpollEventLoop.java:308) at app//io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:365) at app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) at app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""server"" - Thread t@42 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <bd9f0d0> (a java.util.concurrent.CountDownLatch$Sync) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:211) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:715) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1047) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.CountDownLatch.await(CountDownLatch.java:230) at app//reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:91) at app//reactor.core.publisher.Mono.block(Mono.java:1779) at app//org.springframework.boot.web.embedded.netty.NettyWebServer$1.run(NettyWebServer.java:229) Locked ownable synchronizers: - None ""reactor-http-epoll-2"" - Thread t@43 java.lang.Thread.State: RUNNABLE at app//io.netty.channel.epoll.Native.epollWait(Native Method) at app//io.netty.channel.epoll.Native.epollWait(Native.java:220) at app//io.netty.channel.epoll.Native.epollWait(Native.java:213) at app//io.netty.channel.epoll.EpollEventLoop.epollWaitNoTimerChange(EpollEventLoop.java:308) at app//io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:365) at app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) at app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""reactor-http-epoll-3"" - Thread t@44 java.lang.Thread.State: RUNNABLE at app//io.netty.channel.epoll.Native.epollWait(Native Method) at app//io.netty.channel.epoll.Native.epollWait(Native.java:220) at app//io.netty.channel.epoll.Native.epollWait(Native.java:213) at app//io.netty.channel.epoll.EpollEventLoop.epollWaitNoTimerChange(EpollEventLoop.java:308) at app//io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:365) at app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) at app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""reactor-http-epoll-4"" - Thread t@45 java.lang.Thread.State: RUNNABLE at app//io.netty.channel.epoll.Native.epollWait(Native Method) at app//io.netty.channel.epoll.Native.epollWait(Native.java:220) at app//io.netty.channel.epoll.Native.epollWait(Native.java:213) at app//io.netty.channel.epoll.EpollEventLoop.epollWaitNoTimerChange(EpollEventLoop.java:308) at app//io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:365) at app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) at app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""boundedElastic-1"" - Thread t@46 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <d67e1c5> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1170) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:899) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1062) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1122) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""Catalina-utility-1"" - Thread t@48 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <1060e784> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1177) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:899) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1062) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1122) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) at app//org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""Catalina-utility-2"" - Thread t@49 java.lang.Thread.State: TIMED_WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <1060e784> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:252) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:1674) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1182) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:899) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1062) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1122) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) at app//org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""container-0"" - Thread t@50 java.lang.Thread.State: TIMED_WAITING at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.sleep(Native Method) at app//org.apache.catalina.core.StandardServer.await(StandardServer.java:520) at app//org.springframework.boot.web.embedded.tomcat.TomcatWebServer$1.run(TomcatWebServer.java:219) Locked ownable synchronizers: - None ""http-nio-auto-1-exec-1"" - Thread t@51 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <38f381cb> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:117) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:33) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1114) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1175) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) at app//org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""http-nio-auto-1-exec-2"" - Thread t@52 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <38f381cb> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:117) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:33) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1114) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1175) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) at app//org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""http-nio-auto-1-exec-3"" - Thread t@53 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <38f381cb> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:117) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:33) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1114) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1175) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) at app//org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""http-nio-auto-1-exec-4"" - Thread t@54 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <38f381cb> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:117) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:33) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1114) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1175) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) at app//org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""http-nio-auto-1-exec-5"" - Thread t@55 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <38f381cb> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:117) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:33) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1114) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1175) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) at app//org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""http-nio-auto-1-exec-6"" - Thread t@56 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <38f381cb> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:117) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:33) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1114) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1175) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) at app//org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""http-nio-auto-1-exec-7"" - Thread t@57 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <38f381cb> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:117) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:33) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1114) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1175) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) at app//org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""http-nio-auto-1-exec-8"" - Thread t@58 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <38f381cb> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:117) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:33) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1114) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1175) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) at app//org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""http-nio-auto-1-exec-9"" - Thread t@59 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <38f381cb> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:117) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:33) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1114) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1175) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) at app//org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""http-nio-auto-1-exec-10"" - Thread t@60 java.lang.Thread.State: WAITING at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.park(Native Method) - parking to wait for <38f381cb> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.LockSupport.park(LockSupport.java:341) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:506) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3465) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3436) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1625) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:435) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:117) at app//org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:33) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1114) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1175) at app//org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) at app//org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""http-nio-auto-1-Poller"" - Thread t@61 java.lang.Thread.State: RUNNABLE at [email protected](/cdn-cgi/l/email-protection) /sun.nio.ch.EPoll.wait(Native Method) at [email protected](/cdn-cgi/l/email-protection) /sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:118) at [email protected](/cdn-cgi/l/email-protection) /sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:129) - locked <7c68b975> (a sun.nio.ch.Util$2) - locked <4eb316f4> (a sun.nio.ch.EPollSelectorImpl) at [email protected](/cdn-cgi/l/email-protection) /sun.nio.ch.SelectorImpl.select(SelectorImpl.java:141) at app//org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:755) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None ""http-nio-auto-1-Acceptor"" - Thread t@62 java.lang.Thread.State: RUNNABLE at [email protected](/cdn-cgi/l/email-protection) /sun.nio.ch.Net.accept(Native Method) at [email protected](/cdn-cgi/l/email-protection) /sun.nio.ch.ServerSocketChannelImpl.implAccept(ServerSocketChannelImpl.java:425) at [email protected](/cdn-cgi/l/email-protection) /sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:391) at app//org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:518) at app//org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:71) at app//org.apache.tomcat.util.net.Acceptor.run(Acceptor.java:128) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - Locked <59f89461> (a java.util.concurrent.locks.ReentrantLock$NonfairSync) ""pool-4-thread-1"" - Thread t@69 java.lang.Thread.State: RUNNABLE at [email protected](/cdn-cgi/l/email-protection) /jdk.internal.misc.Unsafe.compareAndSetInt(Native Method) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(AbstractQueuedSynchronizer.java:556) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.ReentrantLock$NonfairSync.initialTryLock(ReentrantLock.java:225) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(ReentrantLock.java:160) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:372) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1165) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:899) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1062) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1122) at [email protected](/cdn-cgi/l/email-protection) /java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) at [email protected](/cdn-cgi/l/email-protection) /java.lang.Thread.run(Thread.java:840) Locked ownable synchronizers: - None"
"https://docs.spring.io/spring-boot/api/kotlin/index.html",""
"https://docs.spring.io/spring-boot/specification/configuration-metadata/index.html","Configuration Metadata: Spring Boot jars include metadata files that provide details of all supported configuration properties. The files are designed to let IDE developers offer contextual help and “code completion” as users are working with application.properties or application.yaml files. The majority of the metadata file is generated automatically at compile time by processing all items annotated with @ConfigurationProperties . However, it is possible to write part of the metadata manually(annotation-processor.html#appendix.configuration-metadata.annotation-processor.adding-additional-metadata) for corner cases or more advanced use cases."
"https://docs.spring.io/spring-boot/specification/configuration-metadata/format.html","Metadata Format: Configuration metadata files are located inside jars under META-INF/spring-configuration-metadata.json . They use a JSON format with items categorized under either “groups” or “properties” and additional values hints categorized under ""hints"", as shown in the following example: {""groups"": [ { ""name"": ""server"", ""type"": ""org.springframework.boot.autoconfigure.web.ServerProperties"", ""sourceType"": ""org.springframework.boot.autoconfigure.web.ServerProperties"" }, { ""name"": ""spring.jpa.hibernate"", ""type"": ""org.springframework.boot.autoconfigure.orm.jpa.JpaProperties$Hibernate"", ""sourceType"": ""org.springframework.boot.autoconfigure.orm.jpa.JpaProperties"", ""sourceMethod"": ""getHibernate()"" } ... ],""properties"": [ { ""name"": ""server.port"", ""type"": ""java.lang.Integer"", ""sourceType"": ""org.springframework.boot.autoconfigure.web.ServerProperties"" }, { ""name"": ""server.address"", ""type"": ""java.net.InetAddress"", ""sourceType"": ""org.springframework.boot.autoconfigure.web.ServerProperties"" }, { ""name"": ""spring.jpa.hibernate.ddl-auto"", ""type"": ""java.lang.String"", ""description"": ""DDL mode. This is actually a shortcut for the \""hibernate.hbm2ddl.auto\"" property."", ""sourceType"": ""org.springframework.boot.autoconfigure.orm.jpa.JpaProperties$Hibernate"" } ... ],""hints"": [ { ""name"": ""spring.jpa.hibernate.ddl-auto"", ""values"": [ { ""value"": ""none"", ""description"": ""Disable DDL handling."" }, { ""value"": ""validate"", ""description"": ""Validate the schema, make no changes to the database."" }, { ""value"": ""update"", ""description"": ""Update the schema if necessary."" }, { ""value"": ""create"", ""description"": ""Create the schema and destroy previous data."" }, { ""value"": ""create-drop"", ""description"": ""Create and then destroy the schema at the end of the session."" } ] } ]} Each “property” is a configuration item that the user specifies with a given value. For example, server.port and server.address might be specified in your application.properties / application.yaml , as follows: Properties YAML server.port=9090 server.address=127.0.0.1 server: port: 9090 address: 127.0.0.1 The “groups” are higher level items that do not themselves specify a value but instead provide a contextual grouping for properties. For example, the server.port and server.address properties are part of the server group. It is not required that every “property” has a “group”. Some properties might exist in their own right. Finally, “hints” are additional information used to assist the user in configuring a given property. For example, when a developer is configuring the spring.jpa.hibernate.ddl-auto property, a tool can use the hints to offer some auto-completion help for the none , validate , update , create , and create-drop values. Group Attributes: The JSON object contained in the groups array can contain the attributes shown in the following table: Name Type Purpose name String The full name of the group. This attribute is mandatory. type String The class name of the data type of the group. For example, if the group were based on a class annotated with @ConfigurationProperties , the attribute would contain the fully qualified name of that class. If it were based on a @Bean method, it would be the return type of that method. If the type is not known, the attribute may be omitted. description String A short description of the group that can be displayed to users. If no description is available, it may be omitted. It is recommended that descriptions be short paragraphs, with the first line providing a concise summary. The last line in the description should end with a period ( . ). sourceType String The class name of the source that contributed this group. For example, if the group were based on a @Bean method annotated with @ConfigurationProperties , this attribute would contain the fully qualified name of the @Configuration class that contains the method. If the source type is not known, the attribute may be omitted. sourceMethod String The full name of the method (include parenthesis and argument types) that contributed this group (for example, the name of a @ConfigurationProperties annotated @Bean method). If the source method is not known, it may be omitted. Property Attributes: The JSON object contained in the properties array can contain the attributes described in the following table: Name Type Purpose name String The full name of the property. Names are in lower-case period-separated form (for example, server.address ). This attribute is mandatory. type String The full signature of the data type of the property (for example, java.lang.String ) but also a full generic type (such as java.util.Map<java.lang.String,com.example.MyEnum> ). You can use this attribute to guide the user as to the types of values that they can enter. For consistency, the type of a primitive is specified by using its wrapper counterpart (for example, boolean becomes java.lang.Boolean ). Note that this class may be a complex type that gets converted from a String as values are bound. If the type is not known, it may be omitted. description String A short description of the property that can be displayed to users. If no description is available, it may be omitted. It is recommended that descriptions be short paragraphs, with the first line providing a concise summary. The last line in the description should end with a period ( . ). sourceType String The class name of the source that contributed this property. For example, if the property were from a class annotated with @ConfigurationProperties , this attribute would contain the fully qualified name of that class. If the source type is unknown, it may be omitted. defaultValue Object The default value, which is used if the property is not specified. If the type of the property is an array, it can be an array of value(s). If the default value is unknown, it may be omitted. deprecation Deprecation Specify whether the property is deprecated. If the field is not deprecated or if that information is not known, it may be omitted. The next table offers more detail about the deprecation attribute. The JSON object contained in the deprecation attribute of each properties element can contain the following attributes: Name Type Purpose level String The level of deprecation, which can be either warning (the default) or error . When a property has a warning deprecation level, it should still be bound in the environment. However, when it has an error deprecation level, the property is no longer managed and is not bound. reason String A short description of the reason why the property was deprecated. If no reason is available, it may be omitted. It is recommended that descriptions be short paragraphs, with the first line providing a concise summary. The last line in the description should end with a period ( . ). replacement String The full name of the property that replaces this deprecated property. If there is no replacement for this property, it may be omitted. since String The version in which the property became deprecated. Can be omitted. Prior to Spring Boot 1.3, a single deprecated boolean attribute can be used instead of the deprecation element. This is still supported in a deprecated fashion and should no longer be used. If no reason and replacement are available, an empty deprecation object should be set. Deprecation can also be specified declaratively in code by adding the @DeprecatedConfigurationProperty annotation to the getter exposing the deprecated property. For instance, assume that the my.app.target property was confusing and was renamed to my.app.name . The following example shows how to handle that situation: import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.context.properties.DeprecatedConfigurationProperty; @ConfigurationProperties(""my.app"") public class MyProperties { private String name; public String getName() { return this.name; } public void setName(String name) { this.name = name; } @Deprecated @DeprecatedConfigurationProperty(replacement = ""my.app.name"") public String getTarget() { return this.name; } @Deprecated public void setTarget(String target) { this.name = target; } } There is no way to set a level . warning is always assumed, since code is still handling the property. The preceding code makes sure that the deprecated property still works (delegating to the name property behind the scenes). Once the getTarget and setTarget methods can be removed from your public API, the automatic deprecation hint in the metadata goes away as well. If you want to keep a hint, adding manual metadata with an error deprecation level ensures that users are still informed about that property. Doing so is particularly useful when a replacement is provided. Hint Attributes: The JSON object contained in the hints array can contain the attributes shown in the following table: Name Type Purpose name String The full name of the property to which this hint refers. Names are in lower-case period-separated form (such as spring.mvc.servlet.path ). If the property refers to a map (such as system.contexts ), the hint either applies to the keys of the map ( system.contexts.keys ) or the values ( system.contexts.values ) of the map. This attribute is mandatory. values ValueHint[] A list of valid values as defined by the ValueHint object (described in the next table). Each entry defines the value and may have a description. providers ValueProvider[] A list of providers as defined by the ValueProvider object (described later in this document). Each entry defines the name of the provider and its parameters, if any. The JSON object contained in the values attribute of each hint element can contain the attributes described in the following table: Name Type Purpose value Object A valid value for the element to which the hint refers. If the type of the property is an array, it can also be an array of value(s). This attribute is mandatory. description String A short description of the value that can be displayed to users. If no description is available, it may be omitted. It is recommended that descriptions be short paragraphs, with the first line providing a concise summary. The last line in the description should end with a period ( . ). The JSON object contained in the providers attribute of each hint element can contain the attributes described in the following table: Name Type Purpose name String The name of the provider to use to offer additional content assistance for the element to which the hint refers. parameters JSON object Any additional parameter that the provider supports (check the documentation of the provider for more details). Repeated Metadata Items: Objects with the same “property” and “group” name can appear multiple times within a metadata file. For example, you could bind two separate classes to the same prefix, with each having potentially overlapping property names. While the same names appearing in the metadata multiple times should not be common, consumers of metadata should take care to ensure that they support it."
"https://docs.spring.io/spring-boot/specification/configuration-metadata/manual-hints.html","Providing Manual Hints: To improve the user experience and further assist the user in configuring a given property, you can provide additional metadata that: Describes the list of potential values for a property. Associates a provider, to attach a well defined semantic to a property, so that a tool can discover the list of potential values based on the project’s context. Value Hint: The name attribute of each hint refers to the name of a property. In the initial example shown earlier(format.html) , we provide five values for the spring.jpa.hibernate.ddl-auto property: none , validate , update , create , and create-drop . Each value may have a description as well. If your property is of type Map , you can provide hints for both the keys and the values (but not for the map itself). The special .keys and .values suffixes must refer to the keys and the values, respectively. Assume a my.contexts maps magic String values to an integer, as shown in the following example: import java.util.Map; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(""my"") public class MyProperties { private Map<String, Integer> contexts; // getters/setters ... public Map<String, Integer> getContexts() { return this.contexts; } public void setContexts(Map<String, Integer> contexts) { this.contexts = contexts; } } The magic values are (in this example) are sample1 and sample2 . In order to offer additional content assistance for the keys, you could add the following JSON to the manual metadata of the module(annotation-processor.html#appendix.configuration-metadata.annotation-processor.adding-additional-metadata) : {""hints"": [ { ""name"": ""my.contexts.keys"", ""values"": [ { ""value"": ""sample1"" }, { ""value"": ""sample2"" } ] } ]} We recommend that you use an Enum for those two values instead. If your IDE supports it, this is by far the most effective approach to auto-completion. Value Providers: Providers are a powerful way to attach semantics to a property. In this section, we define the official providers that you can use for your own hints. However, your favorite IDE may implement some of these or none of them. Also, it could eventually provide its own. As this is a new feature, IDE vendors must catch up with how it works. Adoption times naturally vary. The following table summarizes the list of supported providers: Name Description any Permits any additional value to be provided. class-reference Auto-completes the classes available in the project. Usually constrained by a base class that is specified by the target parameter. handle-as Handles the property as if it were defined by the type defined by the mandatory target parameter. logger-name Auto-completes valid logger names and logger groups(../../reference/features/logging.html#features.logging.log-groups) . Typically, package and class names available in the current project can be auto-completed as well as defined groups. spring-bean-reference Auto-completes the available bean names in the current project. Usually constrained by a base class that is specified by the target parameter. spring-profile-name Auto-completes the available Spring profile names in the project. Only one provider can be active for a given property, but you can specify several providers if they can all manage the property in some way . Make sure to place the most powerful provider first, as the IDE must use the first one in the JSON section that it can handle. If no provider for a given property is supported, no special content assistance is provided, either. Any: The special any provider value permits any additional values to be provided. Regular value validation based on the property type should be applied if this is supported. This provider is typically used if you have a list of values and any extra values should still be considered as valid. The following example offers on and off as auto-completion values for system.state : {""hints"": [ { ""name"": ""system.state"", ""values"": [ { ""value"": ""on"" }, { ""value"": ""off"" } ], ""providers"": [ { ""name"": ""any"" } ] } ]} Note that, in the preceding example, any other value is also allowed. Class Reference: The class-reference provider auto-completes classes available in the project. This provider supports the following parameters: Parameter Type Default value Description target String ( Class ) none The fully qualified name of the class that should be assignable to the chosen value. Typically used to filter out-non candidate classes. Note that this information can be provided by the type itself by exposing a class with the appropriate upper bound. concrete boolean true Specify whether only concrete classes are to be considered as valid candidates. The following metadata snippet corresponds to the standard server.servlet.jsp.class-name property that defines the JspServlet class name to use: {""hints"": [ { ""name"": ""server.servlet.jsp.class-name"", ""providers"": [ { ""name"": ""class-reference"", ""parameters"": { ""target"": ""jakarta.servlet.http.HttpServlet"" } } ] } ]} Handle As: The handle-as provider lets you substitute the type of the property to a more high-level type. This typically happens when the property has a java.lang.String type, because you do not want your configuration classes to rely on classes that may not be on the classpath. This provider supports the following parameters: Parameter Type Default value Description target String ( Class ) none The fully qualified name of the type to consider for the property. This parameter is mandatory. The following types can be used: Any java.lang.Enum : Lists the possible values for the property. (We recommend defining the property with the Enum type, as no further hint should be required for the IDE to auto-complete the values) java.nio.charset.Charset : Supports auto-completion of charset/encoding values (such as UTF-8 ) java.util.Locale : auto-completion of locales (such as en_US ) org.springframework.util.MimeType : Supports auto-completion of content type values (such as text/plain ) org.springframework.core.io.Resource : Supports auto-completion of Spring’s Resource abstraction to refer to a file on the filesystem or on the classpath (such as classpath:/sample.properties ) If multiple values can be provided, use a Collection or Array type to teach the IDE about it. The following metadata snippet corresponds to the standard spring.liquibase.change-log property that defines the path to the changelog to use. It is actually used internally as a org.springframework.core.io.Resource but cannot be exposed as such, because we need to keep the original String value to pass it to the Liquibase API. {""hints"": [ { ""name"": ""spring.liquibase.change-log"", ""providers"": [ { ""name"": ""handle-as"", ""parameters"": { ""target"": ""org.springframework.core.io.Resource"" } } ] } ]} Logger Name: The logger-name provider auto-completes valid logger names and logger groups(../../reference/features/logging.html#features.logging.log-groups) . Typically, package and class names available in the current project can be auto-completed. If groups are enabled (default) and if a custom logger group is identified in the configuration, auto-completion for it should be provided. Specific frameworks may have extra magic logger names that can be supported as well. This provider supports the following parameters: Parameter Type Default value Description group boolean true Specify whether known groups should be considered. Since a logger name can be any arbitrary name, this provider should allow any value but could highlight valid package and class names that are not available in the project’s classpath. The following metadata snippet corresponds to the standard logging.level property. Keys are logger names , and values correspond to the standard log levels or any custom level. As Spring Boot defines a few logger groups out-of-the-box, dedicated value hints have been added for those. {""hints"": [ { ""name"": ""logging.level.keys"", ""values"": [ { ""value"": ""root"", ""description"": ""Root logger used to assign the default logging level."" }, { ""value"": ""sql"", ""description"": ""SQL logging group including Hibernate SQL logger."" }, { ""value"": ""web"", ""description"": ""Web logging group including codecs."" } ], ""providers"": [ { ""name"": ""logger-name"" } ] }, { ""name"": ""logging.level.values"", ""values"": [ { ""value"": ""trace"" }, { ""value"": ""debug"" }, { ""value"": ""info"" }, { ""value"": ""warn"" }, { ""value"": ""error"" }, { ""value"": ""fatal"" }, { ""value"": ""off"" } ], ""providers"": [ { ""name"": ""any"" } ] } ]} Spring Bean Reference: The spring-bean-reference provider auto-completes the beans that are defined in the configuration of the current project. This provider supports the following parameters: Parameter Type Default value Description target String ( Class ) none The fully qualified name of the bean class that should be assignable to the candidate. Typically used to filter out non-candidate beans. The following metadata snippet corresponds to the standard spring.jmx.server property that defines the name of the MBeanServer bean to use: {""hints"": [ { ""name"": ""spring.jmx.server"", ""providers"": [ { ""name"": ""spring-bean-reference"", ""parameters"": { ""target"": ""javax.management.MBeanServer"" } } ] } ]} The binder is not aware of the metadata. If you provide that hint, you still need to transform the bean name into an actual Bean reference using by the ApplicationContext . Spring Profile Name: The spring-profile-name provider auto-completes the Spring profiles that are defined in the configuration of the current project. The following metadata snippet corresponds to the standard spring.profiles.active property that defines the name of the Spring profile(s) to enable: {""hints"": [ { ""name"": ""spring.profiles.active"", ""providers"": [ { ""name"": ""spring-profile-name"" } ] } ]}"
"https://docs.spring.io/spring-boot/specification/configuration-metadata/annotation-processor.html","Generating Your Own Metadata by Using the Annotation Processor: You can easily generate your own configuration metadata file from items annotated with @ConfigurationProperties by using the spring-boot-configuration-processor jar. The jar includes a Java annotation processor which is invoked as your project is compiled. Configuring the Annotation Processor: To use the processor, include a dependency on spring-boot-configuration-processor . With Maven the dependency should be declared as optional, as shown in the following example: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-configuration-processor</artifactId> <optional>true</optional> </dependency> With Gradle, the dependency should be declared in the annotationProcessor configuration, as shown in the following example: dependencies { annotationProcessor ""org.springframework.boot:spring-boot-configuration-processor"" } If you are using an additional-spring-configuration-metadata.json file, the compileJava task should be configured to depend on the processResources task, as shown in the following example: tasks.named('compileJava') { inputs.files(tasks.named('processResources')) } This dependency ensures that the additional metadata is available when the annotation processor runs during compilation. If you are using AspectJ in your project, you need to make sure that the annotation processor runs only once. There are several ways to do this. With Maven, you can configure the maven-apt-plugin explicitly and add the dependency to the annotation processor only there. You could also let the AspectJ plugin run all the processing and disable annotation processing in the maven-compiler-plugin configuration, as follows: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <configuration> <proc>none</proc> </configuration> </plugin> If you are using Lombok in your project, you need to make sure that its annotation processor runs before spring-boot-configuration-processor . To do so with Maven, you can list the annotation processors in the right order using the annotationProcessors attribute of the Maven compiler plugin. If you are not using this attribute, and annotation processors are picked up by the dependencies available on the classpath, make sure that the lombok dependency is defined before the spring-boot-configuration-processor dependency. Automatic Metadata Generation: The processor picks up both classes and methods that are annotated with @ConfigurationProperties . Custom annotations that are meta-annotated with @ConfigurationProperties are not supported. If the class has a single parameterized constructor, one property is created per constructor parameter, unless the constructor is annotated with @Autowired . If the class has a constructor explicitly annotated with @ConstructorBinding , one property is created per constructor parameter for that constructor. Otherwise, properties are discovered through the presence of standard getters and setters with special handling for collection and map types (that is detected even if only a getter is present). The annotation processor also supports the use of the @Data , @Value , @Getter , and @Setter lombok annotations. Consider the following example: import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = ""my.server"") public class MyServerProperties { /** * Name of the server. */ private String name; /** * IP address to listen to. */ private String ip = ""127.0.0.1""; /** * Port to listener to. */ private int port = 9797; // getters/setters ... public String getName() { return this.name; } public void setName(String name) { this.name = name; } public String getIp() { return this.ip; } public void setIp(String ip) { this.ip = ip; } public int getPort() { return this.port; } public void setPort(int port) { this.port = port; } // fold:off } This exposes three properties where my.server.name has no default and my.server.ip and my.server.port defaults to ""127.0.0.1"" and 9797 respectively. The Javadoc on fields is used to populate the description attribute. For instance, the description of my.server.ip is ""IP address to listen to."". You should only use plain text with @ConfigurationProperties field Javadoc, since they are not processed before being added to the JSON. If you use @ConfigurationProperties with record class then record components' descriptions should be provided via class-level Javadoc tag @param (there are no explicit instance fields in record classes to put regular field-level Javadocs on). The annotation processor applies a number of heuristics to extract the default value from the source model. Default values have to be provided statically. In particular, do not refer to a constant defined in another class. Also, the annotation processor cannot auto-detect default values for Enum s and Collections s. For cases where the default value could not be detected, manual metadata(#appendix.configuration-metadata.annotation-processor.adding-additional-metadata) should be provided. Consider the following example: import java.util.ArrayList; import java.util.Arrays; import java.util.List; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = ""my.messaging"") public class MyMessagingProperties { private List<String> addresses = new ArrayList<>(Arrays.asList(""a"", ""b"")); private ContainerType containerType = ContainerType.SIMPLE; // getters/setters ... public List<String> getAddresses() { return this.addresses; } public void setAddresses(List<String> addresses) { this.addresses = addresses; } public ContainerType getContainerType() { return this.containerType; } public void setContainerType(ContainerType containerType) { this.containerType = containerType; } public enum ContainerType { SIMPLE, DIRECT } } In order to document default values for properties in the class above, you could add the following content to the manual metadata of the module(#appendix.configuration-metadata.annotation-processor.adding-additional-metadata) : {""properties"": [ { ""name"": ""my.messaging.addresses"", ""defaultValue"": [""a"", ""b""] }, { ""name"": ""my.messaging.container-type"", ""defaultValue"": ""simple"" } ]} Only the name of the property is required to document additional metadata for existing properties. Nested Properties: The annotation processor automatically considers inner classes as nested properties. Rather than documenting the ip and port at the root of the namespace, we could create a sub-namespace for it. Consider the updated example: import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = ""my.server"") public class MyServerProperties { private String name; private Host host; // getters/setters ... public String getName() { return this.name; } public void setName(String name) { this.name = name; } public Host getHost() { return this.host; } public void setHost(Host host) { this.host = host; } public static class Host { private String ip; private int port; // getters/setters ... public String getIp() { return this.ip; } public void setIp(String ip) { this.ip = ip; } public int getPort() { return this.port; } public void setPort(int port) { this.port = port; } // @fold:off // getters/setters ... } } The preceding example produces metadata information for my.server.name , my.server.host.ip , and my.server.host.port properties. You can use the @NestedConfigurationProperty annotation on a field to indicate that a regular (non-inner) class should be treated as if it were nested. This has no effect on collections and maps, as those types are automatically identified, and a single metadata property is generated for each of them. Adding Additional Metadata: Spring Boot’s configuration file handling is quite flexible, and it is often the case that properties may exist that are not bound to a @ConfigurationProperties bean. You may also need to tune some attributes of an existing key. To support such cases and let you provide custom ""hints"", the annotation processor automatically merges items from META-INF/additional-spring-configuration-metadata.json into the main metadata file. If you refer to a property that has been detected automatically, the description, default value, and deprecation information are overridden, if specified. If the manual property declaration is not identified in the current module, it is added as a new property. The format of the additional-spring-configuration-metadata.json file is exactly the same as the regular spring-configuration-metadata.json . The additional properties file is optional. If you do not have any additional properties, do not add the file."
"https://docs.spring.io/spring-boot/specification/executable-jar/index.html","The Executable Jar Format: The spring-boot-loader modules lets Spring Boot support executable jar and war files. If you use the Maven plugin or the Gradle plugin, executable jars are automatically generated, and you generally do not need to know the details of how they work. If you need to create executable jars from a different build system or if you are just curious about the underlying technology, this appendix provides some background."
"https://docs.spring.io/spring-boot/specification/executable-jar/nested-jars.html","Nested JARs: Java does not provide any standard way to load nested jar files (that is, jar files that are themselves contained within a jar). This can be problematic if you need to distribute a self-contained application that can be run from the command line without unpacking. To solve this problem, many developers use “shaded” jars. A shaded jar packages all classes, from all jars, into a single “uber jar”. The problem with shaded jars is that it becomes hard to see which libraries are actually in your application. It can also be problematic if the same filename is used (but with different content) in multiple jars. Spring Boot takes a different approach and lets you actually nest jars directly. The Executable Jar File Structure: Spring Boot Loader-compatible jar files should be structured in the following way: example.jar | +-META-INF | +-MANIFEST.MF +-org | +-springframework | +-boot | +-loader | +-<spring boot loader classes> +-BOOT-INF +-classes | +-mycompany | +-project | +-YourClasses.class +-lib +-dependency1.jar +-dependency2.jar Application classes should be placed in a nested BOOT-INF/classes directory. Dependencies should be placed in a nested BOOT-INF/lib directory. The Executable War File Structure: Spring Boot Loader-compatible war files should be structured in the following way: example.war | +-META-INF | +-MANIFEST.MF +-org | +-springframework | +-boot | +-loader | +-<spring boot loader classes> +-WEB-INF +-classes | +-com | +-mycompany | +-project | +-YourClasses.class +-lib | +-dependency1.jar | +-dependency2.jar +-lib-provided +-servlet-api.jar +-dependency3.jar Dependencies should be placed in a nested WEB-INF/lib directory. Any dependencies that are required when running embedded but are not required when deploying to a traditional web container should be placed in WEB-INF/lib-provided . Index Files: Spring Boot Loader-compatible jar and war archives can include additional index files under the BOOT-INF/ directory. A classpath.idx file can be provided for both jars and wars, and it provides the ordering that jars should be added to the classpath. The layers.idx file can be used only for jars, and it allows a jar to be split into logical layers for Docker/OCI image creation. Index files follow a YAML compatible syntax so that they can be easily parsed by third-party tools. These files, however, are not parsed internally as YAML and they must be written in exactly the formats described below in order to be used. Classpath Index: The classpath index file can be provided in BOOT-INF/classpath.idx . Typically, it is generated automatically by Spring Boot’s Maven and Gradle build plugins. It provides a list of jar names (including the directory) in the order that they should be added to the classpath. When generated by the build plugins, this classpath ordering matches that used by the build system for running and testing the application. Each line must start with dash space ( ""-·"" ) and names must be in double quotes. For example, given the following jar: example.jar | +-META-INF | +-... +-BOOT-INF +-classes | +... +-lib +-dependency1.jar +-dependency2.jar The index file would look like this: - ""BOOT-INF/lib/dependency2.jar"" - ""BOOT-INF/lib/dependency1.jar"" Layer Index: The layers index file can be provided in BOOT-INF/layers.idx . It provides a list of layers and the parts of the jar that should be contained within them. Layers are written in the order that they should be added to the Docker/OCI image. Layers names are written as quoted strings prefixed with dash space ( ""-·"" ) and with a colon ( "":"" ) suffix. Layer content is either a file or directory name written as a quoted string prefixed by space space dash space ( ""··-·"" ). A directory name ends with / , a file name does not. When a directory name is used it means that all files inside that directory are in the same layer. A typical example of a layers index would be: - ""dependencies"": - ""BOOT-INF/lib/dependency1.jar"" - ""BOOT-INF/lib/dependency2.jar"" - ""application"": - ""BOOT-INF/classes/"" - ""META-INF/"""
"https://docs.spring.io/spring-boot/specification/executable-jar/jarfile-class.html","Spring Boot’s “NestedJarFile” Class: The core class used to support loading nested jars is org.springframework.boot.loader.jar.NestedJarFile . It lets you load jar content from nested child jar data. When first loaded, the location of each JarEntry is mapped to a physical file offset of the outer jar, as shown in the following example: myapp.jar +-------------------+-------------------------+ | /BOOT-INF/classes | /BOOT-INF/lib/mylib.jar | |+-----------------+||+-----------+----------+| || A.class ||| B.class | C.class || |+-----------------+||+-----------+----------+| +-------------------+-------------------------+ ^ ^ ^ 0063 3452 3980 The preceding example shows how A.class can be found in /BOOT-INF/classes in myapp.jar at position 0063 . B.class from the nested jar can actually be found in myapp.jar at position 3452 , and C.class is at position 3980 . Armed with this information, we can load specific nested entries by seeking to the appropriate part of the outer jar. We do not need to unpack the archive, and we do not need to read all entry data into memory. Compatibility With the Standard Java “JarFile”: Spring Boot Loader strives to remain compatible with existing code and libraries. org.springframework.boot.loader.jar.NestedJarFile extends from java.util.jar.JarFile and should work as a drop-in replacement. Nested JAR URLs of the form jar:nested:/path/myjar.jar/!BOOT-INF/lib/mylib.jar!/B.class are supported and open a connection compatible with java.net.JarURLConnection . These can be used with Java’s URLClassLoader ."
"https://docs.spring.io/spring-boot/specification/executable-jar/launching.html","Launching Executable Jars: The org.springframework.boot.loader.launch.Launcher class is a special bootstrap class that is used as an executable jar’s main entry point. It is the actual Main-Class in your jar file, and it is used to setup an appropriate ClassLoader and ultimately call your main() method. There are three launcher subclasses ( JarLauncher , WarLauncher , and PropertiesLauncher ). Their purpose is to load resources ( .class files and so on) from nested jar files or war files in directories (as opposed to those explicitly on the classpath). In the case of JarLauncher and WarLauncher , the nested paths are fixed. JarLauncher looks in BOOT-INF/lib/ , and WarLauncher looks in WEB-INF/lib/ and WEB-INF/lib-provided/ . You can add extra jars in those locations if you want more. The PropertiesLauncher looks in BOOT-INF/lib/ in your application archive by default. You can add additional locations by setting an environment variable called LOADER_PATH or loader.path in loader.properties (which is a comma-separated list of directories, archives, or directories within archives). Launcher Manifest: You need to specify an appropriate Launcher as the Main-Class attribute of META-INF/MANIFEST.MF . The actual class that you want to launch (that is, the class that contains a main method) should be specified in the Start-Class attribute. The following example shows a typical MANIFEST.MF for an executable jar file: Main-Class: org.springframework.boot.loader.launch.JarLauncher Start-Class: com.mycompany.project.MyApplication For a war file, it would be as follows: Main-Class: org.springframework.boot.loader.launch.WarLauncher Start-Class: com.mycompany.project.MyApplication You need not specify Class-Path entries in your manifest file. The classpath is deduced from the nested jars."
"https://docs.spring.io/spring-boot/specification/executable-jar/property-launcher.html","PropertiesLauncher Features: PropertiesLauncher has a few special features that can be enabled with external properties (System properties, environment variables, manifest entries, or loader.properties ). The following table describes these properties: Key Purpose loader.path Comma-separated Classpath, such as lib,${HOME}/app/lib . Earlier entries take precedence, like a regular -classpath on the javac command line. loader.home Used to resolve relative paths in loader.path . For example, given loader.path=lib , then ${loader.home}/lib is a classpath location (along with all jar files in that directory). This property is also used to locate a loader.properties file, as in the following example /opt/app(file:///opt/app) It defaults to ${user.dir} . loader.args Default arguments for the main method (space separated). loader.main Name of main class to launch (for example, com.app.Application ). loader.config.name Name of properties file (for example, launcher ). It defaults to loader . loader.config.location Path to properties file (for example, classpath:loader.properties ). It defaults to loader.properties . loader.system Boolean flag to indicate that all properties should be added to System properties. It defaults to false . When specified as environment variables or manifest entries, the following names should be used: Key Manifest entry Environment variable loader.path Loader-Path LOADER_PATH loader.home Loader-Home LOADER_HOME loader.args Loader-Args LOADER_ARGS loader.main Start-Class LOADER_MAIN loader.config.location Loader-Config-Location LOADER_CONFIG_LOCATION loader.system Loader-System LOADER_SYSTEM Build plugins automatically move the Main-Class attribute to Start-Class when the uber jar is built. If you use that, specify the name of the class to launch by using the Main-Class attribute and leaving out Start-Class . The following rules apply to working with PropertiesLauncher : loader.properties is searched for in loader.home , then in the root of the classpath, and then in classpath:/BOOT-INF/classes . The first location where a file with that name exists is used. loader.home is the directory location of an additional properties file (overriding the default) only when loader.config.location is not specified. loader.path can contain directories (which are scanned recursively for jar and zip files), archive paths, a directory within an archive that is scanned for jar files (for example, dependencies.jar!/lib ), or wildcard patterns (for the default JVM behavior). Archive paths can be relative to loader.home or anywhere in the file system with a jar:file: prefix. loader.path (if empty) defaults to BOOT-INF/lib (meaning a local directory or a nested one if running from an archive). Because of this, PropertiesLauncher behaves the same as JarLauncher when no additional configuration is provided. loader.path can not be used to configure the location of loader.properties (the classpath used to search for the latter is the JVM classpath when PropertiesLauncher is launched). Placeholder replacement is done from System and environment variables plus the properties file itself on all values before use. The search order for properties (where it makes sense to look in more than one place) is environment variables, system properties, loader.properties , the exploded archive manifest, and the archive manifest."
"https://docs.spring.io/spring-boot/specification/executable-jar/restrictions.html","Executable Jar Restrictions: You need to consider the following restrictions when working with a Spring Boot Loader packaged application: Zip entry compression: The ZipEntry for a nested jar must be saved by using the ZipEntry.STORED method. This is required so that we can seek directly to individual content within the nested jar. The content of the nested jar file itself can still be compressed, as can any other entry in the outer jar. System classLoader: Launched applications should use Thread.getContextClassLoader() when loading classes (most libraries and frameworks do so by default). Trying to load nested jar classes with ClassLoader.getSystemClassLoader() fails. java.util.Logging always uses the system classloader. For this reason, you should consider a different logging implementation."
"https://docs.spring.io/spring-boot/specification/executable-jar/alternatives.html","Alternative Single Jar Solutions: If the preceding restrictions mean that you cannot use Spring Boot Loader, consider the following alternatives: Maven Shade Plugin(https://maven.apache.org/plugins/maven-shade-plugin/) JarClassLoader(http://www.jdotsoft.com/JarClassLoader.php) OneJar(https://sourceforge.net/projects/one-jar/) Gradle Shadow Plugin(https://imperceptiblethoughts.com/shadow/)"
"https://docs.spring.io/spring-boot/appendix/application-properties/index.html","Common Application Properties: Various properties can be specified inside your application.properties file, inside your application.yaml file, or as command line switches. This appendix provides a list of common Spring Boot properties and references to the underlying classes that consume them. Spring Boot provides various conversion mechanisms with advanced value formatting. Make sure to review the properties conversion section(../../reference/features/external-config.html#features.external-config.typesafe-configuration-properties.conversion) . Property contributions can come from additional jar files on your classpath, so you should not consider this an exhaustive list. Also, you can define your own properties. Core Properties: Name Description Default Value () debug(#application-properties.core.debug) Enable debug logs. false () info.*(#application-properties.core.info) Arbitrary properties to add to the info endpoint. () logging.charset.console(#application-properties.core.logging.charset.console) Charset to use for console output. () logging.charset.file(#application-properties.core.logging.charset.file) Charset to use for file output. () logging.config(#application-properties.core.logging.config) Location of the logging configuration file. For instance, `classpath:logback.xml` for Logback. () logging.exception-conversion-word(#application-properties.core.logging.exception-conversion-word) Conversion word used when logging exceptions. %wEx () logging.file.name(#application-properties.core.logging.file.name) Log file name (for instance, `myapp.log`). Names can be an exact location or relative to the current directory. () logging.file.path(#application-properties.core.logging.file.path) Location of the log file. For instance, `/var/log`. () logging.group.*(#application-properties.core.logging.group) Log groups to quickly change multiple loggers at the same time. For instance, `logging.group.db=org.hibernate,org.springframework.jdbc`. () logging.include-application-name(#application-properties.core.logging.include-application-name) Whether to include the application name in the logs. true () logging.level.*(#application-properties.core.logging.level) Log levels severity mapping. For instance, `logging.level.org.springframework=DEBUG`. () logging.log4j2.config.override(#application-properties.core.logging.log4j2.config.override) Overriding configuration files used to create a composite configuration. () logging.logback.rollingpolicy.clean-history-on-start(#application-properties.core.logging.logback.rollingpolicy.clean-history-on-start) Whether to clean the archive log files on startup. false () logging.logback.rollingpolicy.file-name-pattern(#application-properties.core.logging.logback.rollingpolicy.file-name-pattern) Pattern for rolled-over log file names. ${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz () logging.logback.rollingpolicy.max-file-size(#application-properties.core.logging.logback.rollingpolicy.max-file-size) Maximum log file size. 10MB () logging.logback.rollingpolicy.max-history(#application-properties.core.logging.logback.rollingpolicy.max-history) Maximum number of archive log files to keep. 7 () logging.logback.rollingpolicy.total-size-cap(#application-properties.core.logging.logback.rollingpolicy.total-size-cap) Total size of log backups to be kept. 0B () logging.pattern.console(#application-properties.core.logging.pattern.console) Appender pattern for output to the console. Varies according to the logging system () logging.pattern.correlation(#application-properties.core.logging.pattern.correlation) Appender pattern for log correlation. Varies according to the logging system () logging.pattern.dateformat(#application-properties.core.logging.pattern.dateformat) Appender pattern for log date format. yyyy-MM-dd'T'HH:mm:ss.SSSXXX () logging.pattern.file(#application-properties.core.logging.pattern.file) Appender pattern for output to a file. Varies according to the logging system () logging.pattern.level(#application-properties.core.logging.pattern.level) Appender pattern for log level. %5p () logging.register-shutdown-hook(#application-properties.core.logging.register-shutdown-hook) Register a shutdown hook for the logging system when it is initialized. Disabled automatically when deployed as a war file. true () logging.threshold.console(#application-properties.core.logging.threshold.console) Log level threshold for console output. TRACE () logging.threshold.file(#application-properties.core.logging.threshold.file) Log level threshold for file output. TRACE () spring.aop.auto(#application-properties.core.spring.aop.auto) Add @EnableAspectJAutoProxy. true () spring.aop.proxy-target-class(#application-properties.core.spring.aop.proxy-target-class) Whether subclass-based (CGLIB) proxies are to be created (true), as opposed to standard Java interface-based proxies (false). true () spring.application.admin.enabled(#application-properties.core.spring.application.admin.enabled) Whether to enable admin features for the application. false () spring.application.admin.jmx-name(#application-properties.core.spring.application.admin.jmx-name) JMX name of the application admin MBean. org.springframework.boot:type=Admin,name=SpringApplication () spring.application.name(#application-properties.core.spring.application.name) Application name. () spring.autoconfigure.exclude(#application-properties.core.spring.autoconfigure.exclude) Auto-configuration classes to exclude. () spring.banner.charset(#application-properties.core.spring.banner.charset) Banner file encoding. UTF-8 () spring.banner.location(#application-properties.core.spring.banner.location) Banner text resource location. classpath:banner.txt () spring.beaninfo.ignore(#application-properties.core.spring.beaninfo.ignore) Whether to skip search of BeanInfo classes. true () spring.codec.log-request-details(#application-properties.core.spring.codec.log-request-details) Whether to log form data at DEBUG level, and headers at TRACE level. false () spring.codec.max-in-memory-size(#application-properties.core.spring.codec.max-in-memory-size) Limit on the number of bytes that can be buffered whenever the input stream needs to be aggregated. This applies only to the auto-configured WebFlux server and WebClient instances. By default this is not set, in which case individual codec defaults apply. Most codecs are limited to 256K by default. () spring.config.activate.on-cloud-platform(#application-properties.core.spring.config.activate.on-cloud-platform) Required cloud platform for the document to be included. () spring.config.activate.on-profile(#application-properties.core.spring.config.activate.on-profile) Profile expressions that should match for the document to be included. () spring.config.additional-location(#application-properties.core.spring.config.additional-location) Config file locations used in addition to the defaults. () spring.config.import(#application-properties.core.spring.config.import) Import additional config data. () spring.config.location(#application-properties.core.spring.config.location) Config file locations that replace the defaults. () spring.config.name(#application-properties.core.spring.config.name) Config file name. application () spring.info.build.encoding(#application-properties.core.spring.info.build.encoding) File encoding. UTF-8 () spring.info.build.location(#application-properties.core.spring.info.build.location) Location of the generated build-info.properties file. classpath:META-INF/build-info.properties () spring.info.git.encoding(#application-properties.core.spring.info.git.encoding) File encoding. UTF-8 () spring.info.git.location(#application-properties.core.spring.info.git.location) Location of the generated git.properties file. classpath:git.properties () spring.jmx.default-domain(#application-properties.core.spring.jmx.default-domain) JMX domain name. () spring.jmx.enabled(#application-properties.core.spring.jmx.enabled) Expose Spring's management beans to the JMX domain. false () spring.jmx.registration-policy(#application-properties.core.spring.jmx.registration-policy) JMX Registration policy. fail-on-existing () spring.jmx.server(#application-properties.core.spring.jmx.server) MBeanServer bean name. mbeanServer () spring.jmx.unique-names(#application-properties.core.spring.jmx.unique-names) Whether unique runtime object names should be ensured. false () spring.lifecycle.timeout-per-shutdown-phase(#application-properties.core.spring.lifecycle.timeout-per-shutdown-phase) Timeout for the shutdown of any phase (group of SmartLifecycle beans with the same 'phase' value). 30s () spring.main.allow-bean-definition-overriding(#application-properties.core.spring.main.allow-bean-definition-overriding) Whether bean definition overriding, by registering a definition with the same name as an existing definition, is allowed. false () spring.main.allow-circular-references(#application-properties.core.spring.main.allow-circular-references) Whether to allow circular references between beans and automatically try to resolve them. false () spring.main.banner-mode(#application-properties.core.spring.main.banner-mode) Mode used to display the banner when the application runs. console () spring.main.cloud-platform(#application-properties.core.spring.main.cloud-platform) Override the Cloud Platform auto-detection. () spring.main.keep-alive(#application-properties.core.spring.main.keep-alive) Whether to keep the application alive even if there are no more non-daemon threads. false () spring.main.lazy-initialization(#application-properties.core.spring.main.lazy-initialization) Whether initialization should be performed lazily. false () spring.main.log-startup-info(#application-properties.core.spring.main.log-startup-info) Whether to log information about the application when it starts. true () spring.main.register-shutdown-hook(#application-properties.core.spring.main.register-shutdown-hook) Whether the application should have a shutdown hook registered. true () spring.main.sources(#application-properties.core.spring.main.sources) Sources (class names, package names, or XML resource locations) to include in the ApplicationContext. () spring.main.web-application-type(#application-properties.core.spring.main.web-application-type) Flag to explicitly request a specific type of web application. If not set, auto-detected based on the classpath. () spring.mandatory-file-encoding(#application-properties.core.spring.mandatory-file-encoding) Expected character encoding the application must use. () spring.messages.always-use-message-format(#application-properties.core.spring.messages.always-use-message-format) Whether to always apply the MessageFormat rules, parsing even messages without arguments. false () spring.messages.basename(#application-properties.core.spring.messages.basename) Comma-separated list of basenames (essentially a fully-qualified classpath location), each following the ResourceBundle convention with relaxed support for slash based locations. If it doesn't contain a package qualifier (such as ""org.mypackage""), it will be resolved from the classpath root. messages () spring.messages.cache-duration(#application-properties.core.spring.messages.cache-duration) Loaded resource bundle files cache duration. When not set, bundles are cached forever. If a duration suffix is not specified, seconds will be used. () spring.messages.encoding(#application-properties.core.spring.messages.encoding) Message bundles encoding. UTF-8 () spring.messages.fallback-to-system-locale(#application-properties.core.spring.messages.fallback-to-system-locale) Whether to fall back to the system Locale if no files for a specific Locale have been found. if this is turned off, the only fallback will be the default file (e.g. ""messages.properties"" for basename ""messages""). true () spring.messages.use-code-as-default-message(#application-properties.core.spring.messages.use-code-as-default-message) Whether to use the message code as the default message instead of throwing a ""NoSuchMessageException"". Recommended during development only. false () spring.output.ansi.enabled(#application-properties.core.spring.output.ansi.enabled) Configures the ANSI output. detect () spring.pid.fail-on-write-error(#application-properties.core.spring.pid.fail-on-write-error) Fails if ApplicationPidFileWriter is used but it cannot write the PID file. () spring.pid.file(#application-properties.core.spring.pid.file) Location of the PID file to write (if ApplicationPidFileWriter is used). () spring.profiles.active(#application-properties.core.spring.profiles.active) Comma-separated list of active profiles. Can be overridden by a command line switch. () spring.profiles.default(#application-properties.core.spring.profiles.default) Name of the profile to enable if no profile is active. default () spring.profiles.group.*(#application-properties.core.spring.profiles.group) Profile groups to define a logical name for a related group of profiles. () spring.profiles.include(#application-properties.core.spring.profiles.include) Unconditionally activate the specified comma-separated list of profiles (or list of profiles if using YAML). () spring.quartz.auto-startup(#application-properties.core.spring.quartz.auto-startup) Whether to automatically start the scheduler after initialization. true () spring.quartz.jdbc.comment-prefix(#application-properties.core.spring.quartz.jdbc.comment-prefix) Prefixes for single-line comments in SQL initialization scripts. [#, --] () spring.quartz.jdbc.initialize-schema(#application-properties.core.spring.quartz.jdbc.initialize-schema) Database schema initialization mode. embedded () spring.quartz.jdbc.platform(#application-properties.core.spring.quartz.jdbc.platform) Platform to use in initialization scripts if the @@platform@@ placeholder is used. Auto-detected by default. () spring.quartz.jdbc.schema(#application-properties.core.spring.quartz.jdbc.schema) Path to the SQL file to use to initialize the database schema. classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql () spring.quartz.job-store-type(#application-properties.core.spring.quartz.job-store-type) Quartz job store type. memory () spring.quartz.overwrite-existing-jobs(#application-properties.core.spring.quartz.overwrite-existing-jobs) Whether configured jobs should overwrite existing job definitions. false () spring.quartz.properties.*(#application-properties.core.spring.quartz.properties) Additional Quartz Scheduler properties. () spring.quartz.scheduler-name(#application-properties.core.spring.quartz.scheduler-name) Name of the scheduler. quartzScheduler () spring.quartz.startup-delay(#application-properties.core.spring.quartz.startup-delay) Delay after which the scheduler is started once initialization completes. Setting this property makes sense if no jobs should be run before the entire application has started up. 0s () spring.quartz.wait-for-jobs-to-complete-on-shutdown(#application-properties.core.spring.quartz.wait-for-jobs-to-complete-on-shutdown) Whether to wait for running jobs to complete on shutdown. false () spring.reactor.context-propagation(#application-properties.core.spring.reactor.context-propagation) Context Propagation support mode for Reactor operators. limited () spring.reactor.debug-agent.enabled(#application-properties.core.spring.reactor.debug-agent.enabled) Whether the Reactor Debug Agent should be enabled when reactor-tools is present. true () spring.reactor.netty.shutdown-quiet-period(#application-properties.core.spring.reactor.netty.shutdown-quiet-period) Amount of time to wait before shutting down resources. () spring.ssl.bundle.jks.*(#application-properties.core.spring.ssl.bundle.jks) Java keystore SSL trust material. () spring.ssl.bundle.pem.*(#application-properties.core.spring.ssl.bundle.pem) PEM-encoded SSL trust material. () spring.ssl.bundle.watch.file.quiet-period(#application-properties.core.spring.ssl.bundle.watch.file.quiet-period) Quiet period, after which changes are detected. 10s () spring.task.execution.pool.allow-core-thread-timeout(#application-properties.core.spring.task.execution.pool.allow-core-thread-timeout) Whether core threads are allowed to time out. This enables dynamic growing and shrinking of the pool. Doesn't have an effect if virtual threads are enabled. true () spring.task.execution.pool.core-size(#application-properties.core.spring.task.execution.pool.core-size) Core number of threads. Doesn't have an effect if virtual threads are enabled. 8 () spring.task.execution.pool.keep-alive(#application-properties.core.spring.task.execution.pool.keep-alive) Time limit for which threads may remain idle before being terminated. Doesn't have an effect if virtual threads are enabled. 60s () spring.task.execution.pool.max-size(#application-properties.core.spring.task.execution.pool.max-size) Maximum allowed number of threads. If tasks are filling up the queue, the pool can expand up to that size to accommodate the load. Ignored if the queue is unbounded. Doesn't have an effect if virtual threads are enabled. () spring.task.execution.pool.queue-capacity(#application-properties.core.spring.task.execution.pool.queue-capacity) Queue capacity. An unbounded capacity does not increase the pool and therefore ignores the ""max-size"" property. Doesn't have an effect if virtual threads are enabled. () spring.task.execution.pool.shutdown.accept-tasks-after-context-close(#application-properties.core.spring.task.execution.pool.shutdown.accept-tasks-after-context-close) Whether to accept further tasks after the application context close phase has begun. false () spring.task.execution.shutdown.await-termination(#application-properties.core.spring.task.execution.shutdown.await-termination) Whether the executor should wait for scheduled tasks to complete on shutdown. false () spring.task.execution.shutdown.await-termination-period(#application-properties.core.spring.task.execution.shutdown.await-termination-period) Maximum time the executor should wait for remaining tasks to complete. () spring.task.execution.simple.concurrency-limit(#application-properties.core.spring.task.execution.simple.concurrency-limit) Set the maximum number of parallel accesses allowed. -1 indicates no concurrency limit at all. () spring.task.execution.thread-name-prefix(#application-properties.core.spring.task.execution.thread-name-prefix) Prefix to use for the names of newly created threads. task- () spring.task.scheduling.pool.size(#application-properties.core.spring.task.scheduling.pool.size) Maximum allowed number of threads. Doesn't have an effect if virtual threads are enabled. 1 () spring.task.scheduling.shutdown.await-termination(#application-properties.core.spring.task.scheduling.shutdown.await-termination) Whether the executor should wait for scheduled tasks to complete on shutdown. false () spring.task.scheduling.shutdown.await-termination-period(#application-properties.core.spring.task.scheduling.shutdown.await-termination-period) Maximum time the executor should wait for remaining tasks to complete. () spring.task.scheduling.simple.concurrency-limit(#application-properties.core.spring.task.scheduling.simple.concurrency-limit) Set the maximum number of parallel accesses allowed. -1 indicates no concurrency limit at all. () spring.task.scheduling.thread-name-prefix(#application-properties.core.spring.task.scheduling.thread-name-prefix) Prefix to use for the names of newly created threads. scheduling- () spring.threads.virtual.enabled(#application-properties.core.spring.threads.virtual.enabled) Whether to use virtual threads. false () trace(#application-properties.core.trace) Enable trace logs. false Cache Properties: Name Description Default Value () spring.cache.cache-names(#application-properties.cache.spring.cache.cache-names) Comma-separated list of cache names to create if supported by the underlying cache manager. Usually, this disables the ability to create additional caches on-the-fly. () spring.cache.caffeine.spec(#application-properties.cache.spring.cache.caffeine.spec) The spec to use to create caches. See CaffeineSpec for more details on the spec format. () spring.cache.couchbase.expiration(#application-properties.cache.spring.cache.couchbase.expiration) Entry expiration. By default the entries never expire. Note that this value is ultimately converted to seconds. () spring.cache.infinispan.config(#application-properties.cache.spring.cache.infinispan.config) The location of the configuration file to use to initialize Infinispan. () spring.cache.jcache.config(#application-properties.cache.spring.cache.jcache.config) The location of the configuration file to use to initialize the cache manager. The configuration file is dependent of the underlying cache implementation. () spring.cache.jcache.provider(#application-properties.cache.spring.cache.jcache.provider) Fully qualified name of the CachingProvider implementation to use to retrieve the JSR-107 compliant cache manager. Needed only if more than one JSR-107 implementation is available on the classpath. () spring.cache.redis.cache-null-values(#application-properties.cache.spring.cache.redis.cache-null-values) Allow caching null values. true () spring.cache.redis.enable-statistics(#application-properties.cache.spring.cache.redis.enable-statistics) Whether to enable cache statistics. false () spring.cache.redis.key-prefix(#application-properties.cache.spring.cache.redis.key-prefix) Key prefix. () spring.cache.redis.time-to-live(#application-properties.cache.spring.cache.redis.time-to-live) Entry expiration. By default the entries never expire. () spring.cache.redis.use-key-prefix(#application-properties.cache.spring.cache.redis.use-key-prefix) Whether to use the key prefix when writing to Redis. true () spring.cache.type(#application-properties.cache.spring.cache.type) Cache type. By default, auto-detected according to the environment. Mail Properties: Name Description Default Value () spring.mail.default-encoding(#application-properties.mail.spring.mail.default-encoding) Default MimeMessage encoding. UTF-8 () spring.mail.host(#application-properties.mail.spring.mail.host) SMTP server host. For instance, 'smtp.example.com'. () spring.mail.jndi-name(#application-properties.mail.spring.mail.jndi-name) Session JNDI name. When set, takes precedence over other Session settings. () spring.mail.password(#application-properties.mail.spring.mail.password) Login password of the SMTP server. () spring.mail.port(#application-properties.mail.spring.mail.port) SMTP server port. () spring.mail.properties.*(#application-properties.mail.spring.mail.properties) Additional JavaMail Session properties. () spring.mail.protocol(#application-properties.mail.spring.mail.protocol) Protocol used by the SMTP server. smtp () spring.mail.test-connection(#application-properties.mail.spring.mail.test-connection) Whether to test that the mail server is available on startup. false () spring.mail.username(#application-properties.mail.spring.mail.username) Login user of the SMTP server. () spring.sendgrid.api-key(#application-properties.mail.spring.sendgrid.api-key) SendGrid API key. () spring.sendgrid.proxy.host(#application-properties.mail.spring.sendgrid.proxy.host) SendGrid proxy host. () spring.sendgrid.proxy.port(#application-properties.mail.spring.sendgrid.proxy.port) SendGrid proxy port. JSON Properties: Name Description Default Value () spring.gson.date-format(#application-properties.json.spring.gson.date-format) Format to use when serializing Date objects. () spring.gson.disable-html-escaping(#application-properties.json.spring.gson.disable-html-escaping) Whether to disable the escaping of HTML characters such as '<', '>', etc. () spring.gson.disable-inner-class-serialization(#application-properties.json.spring.gson.disable-inner-class-serialization) Whether to exclude inner classes during serialization. () spring.gson.enable-complex-map-key-serialization(#application-properties.json.spring.gson.enable-complex-map-key-serialization) Whether to enable serialization of complex map keys (i.e. non-primitives). () spring.gson.exclude-fields-without-expose-annotation(#application-properties.json.spring.gson.exclude-fields-without-expose-annotation) Whether to exclude all fields from consideration for serialization or deserialization that do not have the ""Expose"" annotation. () spring.gson.field-naming-policy(#application-properties.json.spring.gson.field-naming-policy) Naming policy that should be applied to an object's field during serialization and deserialization. () spring.gson.generate-non-executable-json(#application-properties.json.spring.gson.generate-non-executable-json) Whether to generate non-executable JSON by prefixing the output with some special text. () spring.gson.lenient(#application-properties.json.spring.gson.lenient) Whether to be lenient about parsing JSON that doesn't conform to RFC 4627. () spring.gson.long-serialization-policy(#application-properties.json.spring.gson.long-serialization-policy) Serialization policy for Long and long types. () spring.gson.pretty-printing(#application-properties.json.spring.gson.pretty-printing) Whether to output serialized JSON that fits in a page for pretty printing. () spring.gson.serialize-nulls(#application-properties.json.spring.gson.serialize-nulls) Whether to serialize null fields. () spring.jackson.constructor-detector(#application-properties.json.spring.jackson.constructor-detector) Strategy to use to auto-detect constructor, and in particular behavior with single-argument constructors. default () spring.jackson.datatype.enum.*(#application-properties.json.spring.jackson.datatype.enum) Jackson on/off features for enums. () spring.jackson.datatype.json-node.*(#application-properties.json.spring.jackson.datatype.json-node) Jackson on/off features for JsonNodes. () spring.jackson.date-format(#application-properties.json.spring.jackson.date-format) Date format string or a fully-qualified date format class name. For instance, 'yyyy-MM-dd HH:mm:ss'. () spring.jackson.default-leniency(#application-properties.json.spring.jackson.default-leniency) Global default setting (if any) for leniency. () spring.jackson.default-property-inclusion(#application-properties.json.spring.jackson.default-property-inclusion) Controls the inclusion of properties during serialization. Configured with one of the values in Jackson's JsonInclude.Include enumeration. () spring.jackson.deserialization.*(#application-properties.json.spring.jackson.deserialization) Jackson on/off features that affect the way Java objects are deserialized. () spring.jackson.generator.*(#application-properties.json.spring.jackson.generator) Jackson on/off features for generators. () spring.jackson.locale(#application-properties.json.spring.jackson.locale) Locale used for formatting. () spring.jackson.mapper.*(#application-properties.json.spring.jackson.mapper) Jackson general purpose on/off features. () spring.jackson.parser.*(#application-properties.json.spring.jackson.parser) Jackson on/off features for parsers. () spring.jackson.property-naming-strategy(#application-properties.json.spring.jackson.property-naming-strategy) One of the constants on Jackson's PropertyNamingStrategies. Can also be a fully-qualified class name of a PropertyNamingStrategy implementation. () spring.jackson.serialization.*(#application-properties.json.spring.jackson.serialization) Jackson on/off features that affect the way Java objects are serialized. () spring.jackson.time-zone(#application-properties.json.spring.jackson.time-zone) Time zone used when formatting dates. For instance, ""America/Los_Angeles"" or ""GMT+10"". () spring.jackson.visibility.*(#application-properties.json.spring.jackson.visibility) Jackson visibility thresholds that can be used to limit which methods (and fields) are auto-detected. Data Properties: Name Description Default Value () spring.cassandra.compression(#application-properties.data.spring.cassandra.compression) Compression supported by the Cassandra binary protocol. none () spring.cassandra.config(#application-properties.data.spring.cassandra.config) Location of the configuration file to use. () spring.cassandra.connection.connect-timeout(#application-properties.data.spring.cassandra.connection.connect-timeout) Timeout to use when establishing driver connections. 5s () spring.cassandra.connection.init-query-timeout(#application-properties.data.spring.cassandra.connection.init-query-timeout) Timeout to use for internal queries that run as part of the initialization process, just after a connection is opened. 5s () spring.cassandra.contact-points(#application-properties.data.spring.cassandra.contact-points) Cluster node addresses in the form 'host:port', or a simple 'host' to use the configured port. [127.0.0.1:9042] () spring.cassandra.controlconnection.timeout(#application-properties.data.spring.cassandra.controlconnection.timeout) Timeout to use for control queries. 5s () spring.cassandra.keyspace-name(#application-properties.data.spring.cassandra.keyspace-name) Keyspace name to use. () spring.cassandra.local-datacenter(#application-properties.data.spring.cassandra.local-datacenter) Datacenter that is considered ""local"". Contact points should be from this datacenter. () spring.cassandra.password(#application-properties.data.spring.cassandra.password) Login password of the server. () spring.cassandra.pool.heartbeat-interval(#application-properties.data.spring.cassandra.pool.heartbeat-interval) Heartbeat interval after which a message is sent on an idle connection to make sure it's still alive. 30s () spring.cassandra.pool.idle-timeout(#application-properties.data.spring.cassandra.pool.idle-timeout) Idle timeout before an idle connection is removed. 5s () spring.cassandra.port(#application-properties.data.spring.cassandra.port) Port to use if a contact point does not specify one. 9042 () spring.cassandra.request.consistency(#application-properties.data.spring.cassandra.request.consistency) Queries consistency level. () spring.cassandra.request.page-size(#application-properties.data.spring.cassandra.request.page-size) How many rows will be retrieved simultaneously in a single network round-trip. 5000 () spring.cassandra.request.serial-consistency(#application-properties.data.spring.cassandra.request.serial-consistency) Queries serial consistency level. () spring.cassandra.request.throttler.drain-interval(#application-properties.data.spring.cassandra.request.throttler.drain-interval) How often the throttler attempts to dequeue requests. Set this high enough that each attempt will process multiple entries in the queue, but not delay requests too much. () spring.cassandra.request.throttler.max-concurrent-requests(#application-properties.data.spring.cassandra.request.throttler.max-concurrent-requests) Maximum number of requests that are allowed to execute in parallel. () spring.cassandra.request.throttler.max-queue-size(#application-properties.data.spring.cassandra.request.throttler.max-queue-size) Maximum number of requests that can be enqueued when the throttling threshold is exceeded. () spring.cassandra.request.throttler.max-requests-per-second(#application-properties.data.spring.cassandra.request.throttler.max-requests-per-second) Maximum allowed request rate. () spring.cassandra.request.throttler.type(#application-properties.data.spring.cassandra.request.throttler.type) Request throttling type. none () spring.cassandra.request.timeout(#application-properties.data.spring.cassandra.request.timeout) How long the driver waits for a request to complete. 2s () spring.cassandra.schema-action(#application-properties.data.spring.cassandra.schema-action) Schema action to take at startup. none () spring.cassandra.session-name(#application-properties.data.spring.cassandra.session-name) Name of the Cassandra session. () spring.cassandra.ssl.bundle(#application-properties.data.spring.cassandra.ssl.bundle) SSL bundle name. () spring.cassandra.ssl.enabled(#application-properties.data.spring.cassandra.ssl.enabled) Whether to enable SSL support. () spring.cassandra.username(#application-properties.data.spring.cassandra.username) Login user of the server. () spring.couchbase.connection-string(#application-properties.data.spring.couchbase.connection-string) Connection string used to locate the Couchbase cluster. () spring.couchbase.env.io.idle-http-connection-timeout(#application-properties.data.spring.couchbase.env.io.idle-http-connection-timeout) Length of time an HTTP connection may remain idle before it is closed and removed from the pool. 1s () spring.couchbase.env.io.max-endpoints(#application-properties.data.spring.couchbase.env.io.max-endpoints) Maximum number of sockets per node. 12 () spring.couchbase.env.io.min-endpoints(#application-properties.data.spring.couchbase.env.io.min-endpoints) Minimum number of sockets per node. 1 () spring.couchbase.env.ssl.bundle(#application-properties.data.spring.couchbase.env.ssl.bundle) SSL bundle name. () spring.couchbase.env.ssl.enabled(#application-properties.data.spring.couchbase.env.ssl.enabled) Whether to enable SSL support. Enabled automatically if a ""bundle"" is provided unless specified otherwise. () spring.couchbase.env.timeouts.analytics(#application-properties.data.spring.couchbase.env.timeouts.analytics) Timeout for the analytics service. 75s () spring.couchbase.env.timeouts.connect(#application-properties.data.spring.couchbase.env.timeouts.connect) Bucket connect timeout. 10s () spring.couchbase.env.timeouts.disconnect(#application-properties.data.spring.couchbase.env.timeouts.disconnect) Bucket disconnect timeout. 10s () spring.couchbase.env.timeouts.key-value(#application-properties.data.spring.couchbase.env.timeouts.key-value) Timeout for operations on a specific key-value. 2500ms () spring.couchbase.env.timeouts.key-value-durable(#application-properties.data.spring.couchbase.env.timeouts.key-value-durable) Timeout for operations on a specific key-value with a durability level. 10s () spring.couchbase.env.timeouts.management(#application-properties.data.spring.couchbase.env.timeouts.management) Timeout for the management operations. 75s () spring.couchbase.env.timeouts.query(#application-properties.data.spring.couchbase.env.timeouts.query) N1QL query operations timeout. 75s () spring.couchbase.env.timeouts.search(#application-properties.data.spring.couchbase.env.timeouts.search) Timeout for the search service. 75s () spring.couchbase.env.timeouts.view(#application-properties.data.spring.couchbase.env.timeouts.view) Regular and geospatial view operations timeout. 75s () spring.couchbase.password(#application-properties.data.spring.couchbase.password) Cluster password. () spring.couchbase.username(#application-properties.data.spring.couchbase.username) Cluster username. () spring.dao.exceptiontranslation.enabled(#application-properties.data.spring.dao.exceptiontranslation.enabled) Whether to enable the PersistenceExceptionTranslationPostProcessor. true () spring.data.cassandra.repositories.type(#application-properties.data.spring.data.cassandra.repositories.type) Type of Cassandra repositories to enable. auto () spring.data.couchbase.auto-index(#application-properties.data.spring.data.couchbase.auto-index) Automatically create views and indexes. Use the meta-data provided by ""@ViewIndexed"", ""@N1qlPrimaryIndexed"" and ""@N1qlSecondaryIndexed"". false () spring.data.couchbase.bucket-name(#application-properties.data.spring.data.couchbase.bucket-name) Name of the bucket to connect to. () spring.data.couchbase.field-naming-strategy(#application-properties.data.spring.data.couchbase.field-naming-strategy) Fully qualified name of the FieldNamingStrategy to use. () spring.data.couchbase.repositories.type(#application-properties.data.spring.data.couchbase.repositories.type) Type of Couchbase repositories to enable. auto () spring.data.couchbase.scope-name(#application-properties.data.spring.data.couchbase.scope-name) Name of the scope used for all collection access. () spring.data.couchbase.type-key(#application-properties.data.spring.data.couchbase.type-key) Name of the field that stores the type information for complex types when using ""MappingCouchbaseConverter"". _class () spring.data.elasticsearch.repositories.enabled(#application-properties.data.spring.data.elasticsearch.repositories.enabled) Whether to enable Elasticsearch repositories. true () spring.data.jdbc.dialect(#application-properties.data.spring.data.jdbc.dialect) Dialect to use. By default, the dialect is determined by inspecting the database connection. () spring.data.jdbc.repositories.enabled(#application-properties.data.spring.data.jdbc.repositories.enabled) Whether to enable JDBC repositories. true () spring.data.jpa.repositories.bootstrap-mode(#application-properties.data.spring.data.jpa.repositories.bootstrap-mode) Bootstrap mode for JPA repositories. default () spring.data.jpa.repositories.enabled(#application-properties.data.spring.data.jpa.repositories.enabled) Whether to enable JPA repositories. true () spring.data.ldap.repositories.enabled(#application-properties.data.spring.data.ldap.repositories.enabled) Whether to enable LDAP repositories. true () spring.data.mongodb.additional-hosts(#application-properties.data.spring.data.mongodb.additional-hosts) Additional server hosts. Cannot be set with URI or if 'host' is not specified. Additional hosts will use the default mongo port of 27017. If you want to use a different port you can use the ""host:port"" syntax. () spring.data.mongodb.authentication-database(#application-properties.data.spring.data.mongodb.authentication-database) Authentication database name. () spring.data.mongodb.auto-index-creation(#application-properties.data.spring.data.mongodb.auto-index-creation) Whether to enable auto-index creation. () spring.data.mongodb.database(#application-properties.data.spring.data.mongodb.database) Database name. Overrides database in URI. () spring.data.mongodb.field-naming-strategy(#application-properties.data.spring.data.mongodb.field-naming-strategy) Fully qualified name of the FieldNamingStrategy to use. () spring.data.mongodb.gridfs.bucket(#application-properties.data.spring.data.mongodb.gridfs.bucket) GridFS bucket name. () spring.data.mongodb.gridfs.database(#application-properties.data.spring.data.mongodb.gridfs.database) GridFS database name. () spring.data.mongodb.host(#application-properties.data.spring.data.mongodb.host) Mongo server host. Cannot be set with URI. () spring.data.mongodb.password(#application-properties.data.spring.data.mongodb.password) Login password of the mongo server. Cannot be set with URI. () spring.data.mongodb.port(#application-properties.data.spring.data.mongodb.port) Mongo server port. Cannot be set with URI. () spring.data.mongodb.replica-set-name(#application-properties.data.spring.data.mongodb.replica-set-name) Required replica set name for the cluster. Cannot be set with URI. () spring.data.mongodb.repositories.type(#application-properties.data.spring.data.mongodb.repositories.type) Type of Mongo repositories to enable. auto () spring.data.mongodb.ssl.bundle(#application-properties.data.spring.data.mongodb.ssl.bundle) SSL bundle name. () spring.data.mongodb.ssl.enabled(#application-properties.data.spring.data.mongodb.ssl.enabled) Whether to enable SSL support. Enabled automatically if ""bundle"" is provided unless specified otherwise. () spring.data.mongodb.uri(#application-properties.data.spring.data.mongodb.uri) Mongo database URI. Overrides host, port, username, and password. mongodb://localhost/test () spring.data.mongodb.username(#application-properties.data.spring.data.mongodb.username) Login user of the mongo server. Cannot be set with URI. () spring.data.mongodb.uuid-representation(#application-properties.data.spring.data.mongodb.uuid-representation) Representation to use when converting a UUID to a BSON binary value. java-legacy () spring.data.neo4j.database(#application-properties.data.spring.data.neo4j.database) Database name to use. By default, the server decides the default database to use. () spring.data.neo4j.repositories.type(#application-properties.data.spring.data.neo4j.repositories.type) Type of Neo4j repositories to enable. auto () spring.data.r2dbc.repositories.enabled(#application-properties.data.spring.data.r2dbc.repositories.enabled) Whether to enable R2DBC repositories. true () spring.data.redis.client-name(#application-properties.data.spring.data.redis.client-name) Client name to be set on connections with CLIENT SETNAME. () spring.data.redis.client-type(#application-properties.data.spring.data.redis.client-type) Type of client to use. By default, auto-detected according to the classpath. () spring.data.redis.cluster.max-redirects(#application-properties.data.spring.data.redis.cluster.max-redirects) Maximum number of redirects to follow when executing commands across the cluster. () spring.data.redis.cluster.nodes(#application-properties.data.spring.data.redis.cluster.nodes) Comma-separated list of ""host:port"" pairs to bootstrap from. This represents an ""initial"" list of cluster nodes and is required to have at least one entry. () spring.data.redis.connect-timeout(#application-properties.data.spring.data.redis.connect-timeout) Connection timeout. () spring.data.redis.database(#application-properties.data.spring.data.redis.database) Database index used by the connection factory. 0 () spring.data.redis.host(#application-properties.data.spring.data.redis.host) Redis server host. localhost () spring.data.redis.jedis.pool.enabled(#application-properties.data.spring.data.redis.jedis.pool.enabled) Whether to enable the pool. Enabled automatically if ""commons-pool2"" is available. With Jedis, pooling is implicitly enabled in sentinel mode and this setting only applies to single node setup. () spring.data.redis.jedis.pool.max-active(#application-properties.data.spring.data.redis.jedis.pool.max-active) Maximum number of connections that can be allocated by the pool at a given time. Use a negative value for no limit. 8 () spring.data.redis.jedis.pool.max-idle(#application-properties.data.spring.data.redis.jedis.pool.max-idle) Maximum number of ""idle"" connections in the pool. Use a negative value to indicate an unlimited number of idle connections. 8 () spring.data.redis.jedis.pool.max-wait(#application-properties.data.spring.data.redis.jedis.pool.max-wait) Maximum amount of time a connection allocation should block before throwing an exception when the pool is exhausted. Use a negative value to block indefinitely. -1ms () spring.data.redis.jedis.pool.min-idle(#application-properties.data.spring.data.redis.jedis.pool.min-idle) Target for the minimum number of idle connections to maintain in the pool. This setting only has an effect if both it and time between eviction runs are positive. 0 () spring.data.redis.jedis.pool.time-between-eviction-runs(#application-properties.data.spring.data.redis.jedis.pool.time-between-eviction-runs) Time between runs of the idle object evictor thread. When positive, the idle object evictor thread starts, otherwise no idle object eviction is performed. () spring.data.redis.lettuce.cluster.refresh.adaptive(#application-properties.data.spring.data.redis.lettuce.cluster.refresh.adaptive) Whether adaptive topology refreshing using all available refresh triggers should be used. false () spring.data.redis.lettuce.cluster.refresh.dynamic-refresh-sources(#application-properties.data.spring.data.redis.lettuce.cluster.refresh.dynamic-refresh-sources) Whether to discover and query all cluster nodes for obtaining the cluster topology. When set to false, only the initial seed nodes are used as sources for topology discovery. true () spring.data.redis.lettuce.cluster.refresh.period(#application-properties.data.spring.data.redis.lettuce.cluster.refresh.period) Cluster topology refresh period. () spring.data.redis.lettuce.pool.enabled(#application-properties.data.spring.data.redis.lettuce.pool.enabled) Whether to enable the pool. Enabled automatically if ""commons-pool2"" is available. With Jedis, pooling is implicitly enabled in sentinel mode and this setting only applies to single node setup. () spring.data.redis.lettuce.pool.max-active(#application-properties.data.spring.data.redis.lettuce.pool.max-active) Maximum number of connections that can be allocated by the pool at a given time. Use a negative value for no limit. 8 () spring.data.redis.lettuce.pool.max-idle(#application-properties.data.spring.data.redis.lettuce.pool.max-idle) Maximum number of ""idle"" connections in the pool. Use a negative value to indicate an unlimited number of idle connections. 8 () spring.data.redis.lettuce.pool.max-wait(#application-properties.data.spring.data.redis.lettuce.pool.max-wait) Maximum amount of time a connection allocation should block before throwing an exception when the pool is exhausted. Use a negative value to block indefinitely. -1ms () spring.data.redis.lettuce.pool.min-idle(#application-properties.data.spring.data.redis.lettuce.pool.min-idle) Target for the minimum number of idle connections to maintain in the pool. This setting only has an effect if both it and time between eviction runs are positive. 0 () spring.data.redis.lettuce.pool.time-between-eviction-runs(#application-properties.data.spring.data.redis.lettuce.pool.time-between-eviction-runs) Time between runs of the idle object evictor thread. When positive, the idle object evictor thread starts, otherwise no idle object eviction is performed. () spring.data.redis.lettuce.shutdown-timeout(#application-properties.data.spring.data.redis.lettuce.shutdown-timeout) Shutdown timeout. 100ms () spring.data.redis.password(#application-properties.data.spring.data.redis.password) Login password of the redis server. () spring.data.redis.port(#application-properties.data.spring.data.redis.port) Redis server port. 6379 () spring.data.redis.repositories.enabled(#application-properties.data.spring.data.redis.repositories.enabled) Whether to enable Redis repositories. true () spring.data.redis.sentinel.master(#application-properties.data.spring.data.redis.sentinel.master) Name of the Redis server. () spring.data.redis.sentinel.nodes(#application-properties.data.spring.data.redis.sentinel.nodes) Comma-separated list of ""host:port"" pairs. () spring.data.redis.sentinel.password(#application-properties.data.spring.data.redis.sentinel.password) Password for authenticating with sentinel(s). () spring.data.redis.sentinel.username(#application-properties.data.spring.data.redis.sentinel.username) Login username for authenticating with sentinel(s). () spring.data.redis.ssl.bundle(#application-properties.data.spring.data.redis.ssl.bundle) SSL bundle name. () spring.data.redis.ssl.enabled(#application-properties.data.spring.data.redis.ssl.enabled) Whether to enable SSL support. Enabled automatically if ""bundle"" is provided unless specified otherwise. () spring.data.redis.timeout(#application-properties.data.spring.data.redis.timeout) Read timeout. () spring.data.redis.url(#application-properties.data.spring.data.redis.url) Connection URL. Overrides host, port, username, and password. Example: redis://user: [email protected](/cdn-cgi/l/email-protection) :6379 () spring.data.redis.username(#application-properties.data.spring.data.redis.username) Login username of the redis server. () spring.data.rest.base-path(#application-properties.data.spring.data.rest.base-path) Base path to be used by Spring Data REST to expose repository resources. () spring.data.rest.default-media-type(#application-properties.data.spring.data.rest.default-media-type) Content type to use as a default when none is specified. () spring.data.rest.default-page-size(#application-properties.data.spring.data.rest.default-page-size) Default size of pages. () spring.data.rest.detection-strategy(#application-properties.data.spring.data.rest.detection-strategy) Strategy to use to determine which repositories get exposed. default () spring.data.rest.enable-enum-translation(#application-properties.data.spring.data.rest.enable-enum-translation) Whether to enable enum value translation through the Spring Data REST default resource bundle. () spring.data.rest.limit-param-name(#application-properties.data.spring.data.rest.limit-param-name) Name of the URL query string parameter that indicates how many results to return at once. () spring.data.rest.max-page-size(#application-properties.data.spring.data.rest.max-page-size) Maximum size of pages. () spring.data.rest.page-param-name(#application-properties.data.spring.data.rest.page-param-name) Name of the URL query string parameter that indicates what page to return. () spring.data.rest.return-body-on-create(#application-properties.data.spring.data.rest.return-body-on-create) Whether to return a response body after creating an entity. () spring.data.rest.return-body-on-update(#application-properties.data.spring.data.rest.return-body-on-update) Whether to return a response body after updating an entity. () spring.data.rest.sort-param-name(#application-properties.data.spring.data.rest.sort-param-name) Name of the URL query string parameter that indicates what direction to sort results. () spring.data.web.pageable.default-page-size(#application-properties.data.spring.data.web.pageable.default-page-size) Default page size. 20 () spring.data.web.pageable.max-page-size(#application-properties.data.spring.data.web.pageable.max-page-size) Maximum page size to be accepted. 2000 () spring.data.web.pageable.one-indexed-parameters(#application-properties.data.spring.data.web.pageable.one-indexed-parameters) Whether to expose and assume 1-based page number indexes. Defaults to ""false"", meaning a page number of 0 in the request equals the first page. false () spring.data.web.pageable.page-parameter(#application-properties.data.spring.data.web.pageable.page-parameter) Page index parameter name. page () spring.data.web.pageable.prefix(#application-properties.data.spring.data.web.pageable.prefix) General prefix to be prepended to the page number and page size parameters. () spring.data.web.pageable.qualifier-delimiter(#application-properties.data.spring.data.web.pageable.qualifier-delimiter) Delimiter to be used between the qualifier and the actual page number and size properties. _ () spring.data.web.pageable.size-parameter(#application-properties.data.spring.data.web.pageable.size-parameter) Page size parameter name. size () spring.data.web.sort.sort-parameter(#application-properties.data.spring.data.web.sort.sort-parameter) Sort parameter name. sort () spring.datasource.dbcp2.abandoned-usage-tracking spring.datasource.dbcp2.access-to-underlying-connection-allowed spring.datasource.dbcp2.auto-commit-on-return spring.datasource.dbcp2.cache-state spring.datasource.dbcp2.clear-statement-pool-on-return spring.datasource.dbcp2.connection-factory-class-name spring.datasource.dbcp2.connection-init-sqls spring.datasource.dbcp2.default-auto-commit spring.datasource.dbcp2.default-catalog spring.datasource.dbcp2.default-read-only spring.datasource.dbcp2.default-schema spring.datasource.dbcp2.default-transaction-isolation spring.datasource.dbcp2.disconnection-sql-codes spring.datasource.dbcp2.driver spring.datasource.dbcp2.driver-class-name spring.datasource.dbcp2.duration-between-eviction-runs spring.datasource.dbcp2.eviction-policy-class-name spring.datasource.dbcp2.fast-fail-validation spring.datasource.dbcp2.initial-size spring.datasource.dbcp2.jmx-name spring.datasource.dbcp2.lifo spring.datasource.dbcp2.log-abandoned spring.datasource.dbcp2.log-expired-connections spring.datasource.dbcp2.login-timeout spring.datasource.dbcp2.max-idle spring.datasource.dbcp2.max-open-prepared-statements spring.datasource.dbcp2.max-total spring.datasource.dbcp2.min-idle spring.datasource.dbcp2.num-tests-per-eviction-run spring.datasource.dbcp2.password spring.datasource.dbcp2.pool-prepared-statements spring.datasource.dbcp2.remove-abandoned-on-borrow spring.datasource.dbcp2.remove-abandoned-on-maintenance spring.datasource.dbcp2.rollback-on-return spring.datasource.dbcp2.test-on-borrow spring.datasource.dbcp2.test-on-create spring.datasource.dbcp2.test-on-return spring.datasource.dbcp2.test-while-idle spring.datasource.dbcp2.url spring.datasource.dbcp2.username spring.datasource.dbcp2.validation-query(#application-properties.data.spring.datasource.dbcp2) Commons DBCP2 specific settings bound to an instance of DBCP2's BasicDataSource () spring.datasource.driver-class-name(#application-properties.data.spring.datasource.driver-class-name) Fully qualified name of the JDBC driver. Auto-detected based on the URL by default. () spring.datasource.embedded-database-connection(#application-properties.data.spring.datasource.embedded-database-connection) Connection details for an embedded database. Defaults to the most suitable embedded database that is available on the classpath. () spring.datasource.generate-unique-name(#application-properties.data.spring.datasource.generate-unique-name) Whether to generate a random datasource name. true () spring.datasource.hikari.allow-pool-suspension spring.datasource.hikari.auto-commit spring.datasource.hikari.catalog spring.datasource.hikari.connection-init-sql spring.datasource.hikari.connection-test-query spring.datasource.hikari.connection-timeout spring.datasource.hikari.data-source-class-name spring.datasource.hikari.data-source-j-n-d-i spring.datasource.hikari.data-source-properties spring.datasource.hikari.driver-class-name spring.datasource.hikari.exception-override-class-name spring.datasource.hikari.health-check-properties spring.datasource.hikari.idle-timeout spring.datasource.hikari.initialization-fail-timeout spring.datasource.hikari.isolate-internal-queries spring.datasource.hikari.jdbc-url spring.datasource.hikari.keepalive-time spring.datasource.hikari.leak-detection-threshold spring.datasource.hikari.login-timeout spring.datasource.hikari.max-lifetime spring.datasource.hikari.maximum-pool-size spring.datasource.hikari.metrics-tracker-factory spring.datasource.hikari.minimum-idle spring.datasource.hikari.password spring.datasource.hikari.pool-name spring.datasource.hikari.read-only spring.datasource.hikari.register-mbeans spring.datasource.hikari.scheduled-executor spring.datasource.hikari.schema spring.datasource.hikari.transaction-isolation spring.datasource.hikari.username spring.datasource.hikari.validation-timeout(#application-properties.data.spring.datasource.hikari) Hikari specific settings bound to an instance of Hikari's HikariDataSource () spring.datasource.jndi-name(#application-properties.data.spring.datasource.jndi-name) JNDI location of the datasource. Class, url, username and password are ignored when set. () spring.datasource.name(#application-properties.data.spring.datasource.name) Datasource name to use if ""generate-unique-name"" is false. Defaults to ""testdb"" when using an embedded database, otherwise null. () spring.datasource.oracleucp.abandoned-connection-timeout spring.datasource.oracleucp.connection-factory-class-name spring.datasource.oracleucp.connection-factory-properties spring.datasource.oracleucp.connection-harvest-max-count spring.datasource.oracleucp.connection-harvest-trigger-count spring.datasource.oracleucp.connection-labeling-high-cost spring.datasource.oracleucp.connection-pool-name spring.datasource.oracleucp.connection-properties spring.datasource.oracleucp.connection-repurpose-threshold spring.datasource.oracleucp.connection-validation-timeout spring.datasource.oracleucp.connection-wait-timeout spring.datasource.oracleucp.data-source-name spring.datasource.oracleucp.database-name spring.datasource.oracleucp.description spring.datasource.oracleucp.fast-connection-failover-enabled spring.datasource.oracleucp.high-cost-connection-reuse-threshold spring.datasource.oracleucp.inactive-connection-timeout spring.datasource.oracleucp.initial-pool-size spring.datasource.oracleucp.login-timeout spring.datasource.oracleucp.max-connection-reuse-count spring.datasource.oracleucp.max-connection-reuse-time spring.datasource.oracleucp.max-connections-per-shard spring.datasource.oracleucp.max-idle-time spring.datasource.oracleucp.max-pool-size spring.datasource.oracleucp.max-statements spring.datasource.oracleucp.min-pool-size spring.datasource.oracleucp.network-protocol spring.datasource.oracleucp.o-n-s-configuration spring.datasource.oracleucp.pdb-roles spring.datasource.oracleucp.port-number spring.datasource.oracleucp.property-cycle spring.datasource.oracleucp.query-timeout spring.datasource.oracleucp.read-only-instance-allowed spring.datasource.oracleucp.role-name spring.datasource.oracleucp.s-q-l-for-validate-connection spring.datasource.oracleucp.seconds-to-trust-idle-connection spring.datasource.oracleucp.server-name spring.datasource.oracleucp.sharding-mode spring.datasource.oracleucp.time-to-live-connection-timeout spring.datasource.oracleucp.timeout-check-interval spring.datasource.oracleucp.u-r-l spring.datasource.oracleucp.user spring.datasource.oracleucp.validate-connection-on-borrow(#application-properties.data.spring.datasource.oracleucp) Oracle UCP specific settings bound to an instance of Oracle UCP's PoolDataSource () spring.datasource.password(#application-properties.data.spring.datasource.password) Login password of the database. () spring.datasource.tomcat.abandon-when-percentage-full spring.datasource.tomcat.access-to-underlying-connection-allowed spring.datasource.tomcat.alternate-username-allowed spring.datasource.tomcat.commit-on-return spring.datasource.tomcat.connection-properties spring.datasource.tomcat.data-source-j-n-d-i spring.datasource.tomcat.db-properties spring.datasource.tomcat.default-auto-commit spring.datasource.tomcat.default-catalog spring.datasource.tomcat.default-read-only spring.datasource.tomcat.default-transaction-isolation spring.datasource.tomcat.driver-class-name spring.datasource.tomcat.fair-queue spring.datasource.tomcat.ignore-exception-on-pre-load spring.datasource.tomcat.init-s-q-l spring.datasource.tomcat.initial-size spring.datasource.tomcat.jdbc-interceptors spring.datasource.tomcat.jmx-enabled spring.datasource.tomcat.log-abandoned spring.datasource.tomcat.log-validation-errors spring.datasource.tomcat.login-timeout spring.datasource.tomcat.max-active spring.datasource.tomcat.max-age spring.datasource.tomcat.max-idle spring.datasource.tomcat.max-wait spring.datasource.tomcat.min-evictable-idle-time-millis spring.datasource.tomcat.min-idle spring.datasource.tomcat.name spring.datasource.tomcat.num-tests-per-eviction-run spring.datasource.tomcat.password spring.datasource.tomcat.propagate-interrupt-state spring.datasource.tomcat.remove-abandoned spring.datasource.tomcat.remove-abandoned-timeout spring.datasource.tomcat.rollback-on-return spring.datasource.tomcat.suspect-timeout spring.datasource.tomcat.test-on-borrow spring.datasource.tomcat.test-on-connect spring.datasource.tomcat.test-on-return spring.datasource.tomcat.test-while-idle spring.datasource.tomcat.time-between-eviction-runs-millis spring.datasource.tomcat.url spring.datasource.tomcat.use-disposable-connection-facade spring.datasource.tomcat.use-equals spring.datasource.tomcat.use-lock spring.datasource.tomcat.use-statement-facade spring.datasource.tomcat.username spring.datasource.tomcat.validation-interval spring.datasource.tomcat.validation-query spring.datasource.tomcat.validation-query-timeout spring.datasource.tomcat.validator-class-name(#application-properties.data.spring.datasource.tomcat) Tomcat datasource specific settings bound to an instance of Tomcat JDBC's DataSource () spring.datasource.type(#application-properties.data.spring.datasource.type) Fully qualified name of the connection pool implementation to use. By default, it is auto-detected from the classpath. () spring.datasource.url(#application-properties.data.spring.datasource.url) JDBC URL of the database. () spring.datasource.username(#application-properties.data.spring.datasource.username) Login username of the database. () spring.datasource.xa.data-source-class-name(#application-properties.data.spring.datasource.xa.data-source-class-name) XA datasource fully qualified name. () spring.datasource.xa.properties.*(#application-properties.data.spring.datasource.xa.properties) Properties to pass to the XA data source. () spring.elasticsearch.connection-timeout(#application-properties.data.spring.elasticsearch.connection-timeout) Connection timeout used when communicating with Elasticsearch. 1s () spring.elasticsearch.password(#application-properties.data.spring.elasticsearch.password) Password for authentication with Elasticsearch. () spring.elasticsearch.path-prefix(#application-properties.data.spring.elasticsearch.path-prefix) Prefix added to the path of every request sent to Elasticsearch. () spring.elasticsearch.restclient.sniffer.delay-after-failure(#application-properties.data.spring.elasticsearch.restclient.sniffer.delay-after-failure) Delay of a sniff execution scheduled after a failure. 1m () spring.elasticsearch.restclient.sniffer.interval(#application-properties.data.spring.elasticsearch.restclient.sniffer.interval) Interval between consecutive ordinary sniff executions. 5m () spring.elasticsearch.restclient.ssl.bundle(#application-properties.data.spring.elasticsearch.restclient.ssl.bundle) SSL bundle name. () spring.elasticsearch.socket-keep-alive(#application-properties.data.spring.elasticsearch.socket-keep-alive) Whether to enable socket keep alive between client and Elasticsearch. false () spring.elasticsearch.socket-timeout(#application-properties.data.spring.elasticsearch.socket-timeout) Socket timeout used when communicating with Elasticsearch. 30s () spring.elasticsearch.uris(#application-properties.data.spring.elasticsearch.uris) Comma-separated list of the Elasticsearch instances to use. [http://localhost:9200] () spring.elasticsearch.username(#application-properties.data.spring.elasticsearch.username) Username for authentication with Elasticsearch. () spring.h2.console.enabled(#application-properties.data.spring.h2.console.enabled) Whether to enable the console. false () spring.h2.console.path(#application-properties.data.spring.h2.console.path) Path at which the console is available. /h2-console () spring.h2.console.settings.trace(#application-properties.data.spring.h2.console.settings.trace) Whether to enable trace output. false () spring.h2.console.settings.web-admin-password(#application-properties.data.spring.h2.console.settings.web-admin-password) Password to access preferences and tools of H2 Console. () spring.h2.console.settings.web-allow-others(#application-properties.data.spring.h2.console.settings.web-allow-others) Whether to enable remote access. false () spring.jdbc.template.fetch-size(#application-properties.data.spring.jdbc.template.fetch-size) Number of rows that should be fetched from the database when more rows are needed. Use -1 to use the JDBC driver's default configuration. -1 () spring.jdbc.template.max-rows(#application-properties.data.spring.jdbc.template.max-rows) Maximum number of rows. Use -1 to use the JDBC driver's default configuration. -1 () spring.jdbc.template.query-timeout(#application-properties.data.spring.jdbc.template.query-timeout) Query timeout. Default is to use the JDBC driver's default configuration. If a duration suffix is not specified, seconds will be used. () spring.jooq.sql-dialect(#application-properties.data.spring.jooq.sql-dialect) SQL dialect to use. Auto-detected by default. () spring.jpa.database(#application-properties.data.spring.jpa.database) Target database to operate on, auto-detected by default. Can be alternatively set using the ""databasePlatform"" property. () spring.jpa.database-platform(#application-properties.data.spring.jpa.database-platform) Name of the target database to operate on, auto-detected by default. Can be alternatively set using the ""Database"" enum. () spring.jpa.defer-datasource-initialization(#application-properties.data.spring.jpa.defer-datasource-initialization) Whether to defer DataSource initialization until after any EntityManagerFactory beans have been created and initialized. false () spring.jpa.generate-ddl(#application-properties.data.spring.jpa.generate-ddl) Whether to initialize the schema on startup. false () spring.jpa.hibernate.ddl-auto(#application-properties.data.spring.jpa.hibernate.ddl-auto) DDL mode. This is actually a shortcut for the ""hibernate.hbm2ddl.auto"" property. Defaults to ""create-drop"" when using an embedded database and no schema manager was detected. Otherwise, defaults to ""none"". () spring.jpa.hibernate.naming.implicit-strategy(#application-properties.data.spring.jpa.hibernate.naming.implicit-strategy) Fully qualified name of the implicit naming strategy. () spring.jpa.hibernate.naming.physical-strategy(#application-properties.data.spring.jpa.hibernate.naming.physical-strategy) Fully qualified name of the physical naming strategy. () spring.jpa.mapping-resources(#application-properties.data.spring.jpa.mapping-resources) Mapping resources (equivalent to ""mapping-file"" entries in persistence.xml). () spring.jpa.open-in-view(#application-properties.data.spring.jpa.open-in-view) Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request. true () spring.jpa.properties.*(#application-properties.data.spring.jpa.properties) Additional native properties to set on the JPA provider. () spring.jpa.show-sql(#application-properties.data.spring.jpa.show-sql) Whether to enable logging of SQL statements. false () spring.ldap.anonymous-read-only(#application-properties.data.spring.ldap.anonymous-read-only) Whether read-only operations should use an anonymous environment. Disabled by default unless a username is set. () spring.ldap.base(#application-properties.data.spring.ldap.base) Base suffix from which all operations should originate. () spring.ldap.base-environment.*(#application-properties.data.spring.ldap.base-environment) LDAP specification settings. () spring.ldap.embedded.base-dn(#application-properties.data.spring.ldap.embedded.base-dn) List of base DNs. () spring.ldap.embedded.credential.password(#application-properties.data.spring.ldap.embedded.credential.password) Embedded LDAP password. () spring.ldap.embedded.credential.username(#application-properties.data.spring.ldap.embedded.credential.username) Embedded LDAP username. () spring.ldap.embedded.ldif(#application-properties.data.spring.ldap.embedded.ldif) Schema (LDIF) script resource reference. classpath:schema.ldif () spring.ldap.embedded.port(#application-properties.data.spring.ldap.embedded.port) Embedded LDAP port. 0 () spring.ldap.embedded.validation.enabled(#application-properties.data.spring.ldap.embedded.validation.enabled) Whether to enable LDAP schema validation. true () spring.ldap.embedded.validation.schema(#application-properties.data.spring.ldap.embedded.validation.schema) Path to the custom schema. () spring.ldap.password(#application-properties.data.spring.ldap.password) Login password of the server. () spring.ldap.template.ignore-name-not-found-exception(#application-properties.data.spring.ldap.template.ignore-name-not-found-exception) Whether NameNotFoundException should be ignored in searches through the LdapTemplate. false () spring.ldap.template.ignore-partial-result-exception(#application-properties.data.spring.ldap.template.ignore-partial-result-exception) Whether PartialResultException should be ignored in searches through the LdapTemplate. false () spring.ldap.template.ignore-size-limit-exceeded-exception(#application-properties.data.spring.ldap.template.ignore-size-limit-exceeded-exception) Whether SizeLimitExceededException should be ignored in searches through the LdapTemplate. true () spring.ldap.urls(#application-properties.data.spring.ldap.urls) LDAP URLs of the server. () spring.ldap.username(#application-properties.data.spring.ldap.username) Login username of the server. () spring.neo4j.authentication.kerberos-ticket(#application-properties.data.spring.neo4j.authentication.kerberos-ticket) Kerberos ticket for connecting to the database. Mutual exclusive with a given username. () spring.neo4j.authentication.password(#application-properties.data.spring.neo4j.authentication.password) Login password of the server. () spring.neo4j.authentication.realm(#application-properties.data.spring.neo4j.authentication.realm) Realm to connect to. () spring.neo4j.authentication.username(#application-properties.data.spring.neo4j.authentication.username) Login user of the server. () spring.neo4j.connection-timeout(#application-properties.data.spring.neo4j.connection-timeout) Timeout for borrowing connections from the pool. 30s () spring.neo4j.max-transaction-retry-time(#application-properties.data.spring.neo4j.max-transaction-retry-time) Maximum time transactions are allowed to retry. 30s () spring.neo4j.pool.connection-acquisition-timeout(#application-properties.data.spring.neo4j.pool.connection-acquisition-timeout) Acquisition of new connections will be attempted for at most configured timeout. 60s () spring.neo4j.pool.idle-time-before-connection-test(#application-properties.data.spring.neo4j.pool.idle-time-before-connection-test) Pooled connections that have been idle in the pool for longer than this threshold will be tested before they are used again. () spring.neo4j.pool.log-leaked-sessions(#application-properties.data.spring.neo4j.pool.log-leaked-sessions) Whether to log leaked sessions. false () spring.neo4j.pool.max-connection-lifetime(#application-properties.data.spring.neo4j.pool.max-connection-lifetime) Pooled connections older than this threshold will be closed and removed from the pool. 1h () spring.neo4j.pool.max-connection-pool-size(#application-properties.data.spring.neo4j.pool.max-connection-pool-size) Maximum amount of connections in the connection pool towards a single database. 100 () spring.neo4j.pool.metrics-enabled(#application-properties.data.spring.neo4j.pool.metrics-enabled) Whether to enable metrics. false () spring.neo4j.security.cert-file(#application-properties.data.spring.neo4j.security.cert-file) Path to the file that holds the trusted certificates. () spring.neo4j.security.encrypted(#application-properties.data.spring.neo4j.security.encrypted) Whether the driver should use encrypted traffic. false () spring.neo4j.security.hostname-verification-enabled(#application-properties.data.spring.neo4j.security.hostname-verification-enabled) Whether hostname verification is required. true () spring.neo4j.security.trust-strategy(#application-properties.data.spring.neo4j.security.trust-strategy) Trust strategy to use. trust-system-ca-signed-certificates () spring.neo4j.uri(#application-properties.data.spring.neo4j.uri) URI used by the driver. bolt://localhost:7687 () spring.r2dbc.generate-unique-name(#application-properties.data.spring.r2dbc.generate-unique-name) Whether to generate a random database name. Ignore any configured name when enabled. false () spring.r2dbc.name(#application-properties.data.spring.r2dbc.name) Database name. Set if no name is specified in the url. Default to ""testdb"" when using an embedded database. () spring.r2dbc.password(#application-properties.data.spring.r2dbc.password) Login password of the database. Set if no password is specified in the url. () spring.r2dbc.pool.enabled(#application-properties.data.spring.r2dbc.pool.enabled) Whether pooling is enabled. Requires r2dbc-pool. true () spring.r2dbc.pool.initial-size(#application-properties.data.spring.r2dbc.pool.initial-size) Initial connection pool size. 10 () spring.r2dbc.pool.max-acquire-time(#application-properties.data.spring.r2dbc.pool.max-acquire-time) Maximum time to acquire a connection from the pool. By default, wait indefinitely. () spring.r2dbc.pool.max-create-connection-time(#application-properties.data.spring.r2dbc.pool.max-create-connection-time) Maximum time to wait to create a new connection. By default, wait indefinitely. () spring.r2dbc.pool.max-idle-time(#application-properties.data.spring.r2dbc.pool.max-idle-time) Maximum amount of time that a connection is allowed to sit idle in the pool. 30m () spring.r2dbc.pool.max-life-time(#application-properties.data.spring.r2dbc.pool.max-life-time) Maximum lifetime of a connection in the pool. By default, connections have an infinite lifetime. () spring.r2dbc.pool.max-size(#application-properties.data.spring.r2dbc.pool.max-size) Maximal connection pool size. 10 () spring.r2dbc.pool.max-validation-time(#application-properties.data.spring.r2dbc.pool.max-validation-time) Maximum time to validate a connection from the pool. By default, wait indefinitely. () spring.r2dbc.pool.min-idle(#application-properties.data.spring.r2dbc.pool.min-idle) Minimal number of idle connections. 0 () spring.r2dbc.pool.validation-depth(#application-properties.data.spring.r2dbc.pool.validation-depth) Validation depth. local () spring.r2dbc.pool.validation-query(#application-properties.data.spring.r2dbc.pool.validation-query) Validation query. () spring.r2dbc.properties.*(#application-properties.data.spring.r2dbc.properties) Additional R2DBC options. () spring.r2dbc.url(#application-properties.data.spring.r2dbc.url) R2DBC URL of the database. database name, username, password and pooling options specified in the url take precedence over individual options. () spring.r2dbc.username(#application-properties.data.spring.r2dbc.username) Login username of the database. Set if no username is specified in the url. Transaction Properties: Name Description Default Value () spring.jta.enabled(#application-properties.transaction.spring.jta.enabled) Whether to enable JTA support. true () spring.transaction.default-timeout(#application-properties.transaction.spring.transaction.default-timeout) Default transaction timeout. If a duration suffix is not specified, seconds will be used. () spring.transaction.rollback-on-commit-failure(#application-properties.transaction.spring.transaction.rollback-on-commit-failure) Whether to roll back on commit failures. Data Migration Properties: Name Description Default Value () spring.flyway.baseline-description(#application-properties.data-migration.spring.flyway.baseline-description) Description to tag an existing schema with when applying a baseline. << Flyway Baseline >> () spring.flyway.baseline-on-migrate(#application-properties.data-migration.spring.flyway.baseline-on-migrate) Whether to automatically call baseline when migrating a non-empty schema. false () spring.flyway.baseline-version(#application-properties.data-migration.spring.flyway.baseline-version) Version to tag an existing schema with when executing baseline. 1 () spring.flyway.batch(#application-properties.data-migration.spring.flyway.batch) Whether to batch SQL statements when executing them. Requires Flyway Teams. () spring.flyway.clean-disabled(#application-properties.data-migration.spring.flyway.clean-disabled) Whether to disable cleaning of the database. true () spring.flyway.clean-on-validation-error(#application-properties.data-migration.spring.flyway.clean-on-validation-error) Whether to automatically call clean when a validation error occurs. false () spring.flyway.connect-retries(#application-properties.data-migration.spring.flyway.connect-retries) Maximum number of retries when attempting to connect to the database. 0 () spring.flyway.connect-retries-interval(#application-properties.data-migration.spring.flyway.connect-retries-interval) Maximum time between retries when attempting to connect to the database. If a duration suffix is not specified, seconds will be used. 120s () spring.flyway.create-schemas(#application-properties.data-migration.spring.flyway.create-schemas) Whether Flyway should attempt to create the schemas specified in the schemas property. true () spring.flyway.default-schema(#application-properties.data-migration.spring.flyway.default-schema) Default schema name managed by Flyway (case-sensitive). () spring.flyway.detect-encoding(#application-properties.data-migration.spring.flyway.detect-encoding) Whether to attempt to automatically detect SQL migration file encoding. Requires Flyway Teams. () spring.flyway.driver-class-name(#application-properties.data-migration.spring.flyway.driver-class-name) Fully qualified name of the JDBC driver. Auto-detected based on the URL by default. () spring.flyway.enabled(#application-properties.data-migration.spring.flyway.enabled) Whether to enable flyway. true () spring.flyway.encoding(#application-properties.data-migration.spring.flyway.encoding) Encoding of SQL migrations. UTF-8 () spring.flyway.error-overrides(#application-properties.data-migration.spring.flyway.error-overrides) Rules for the built-in error handling to override specific SQL states and error codes. Requires Flyway Teams. () spring.flyway.execute-in-transaction(#application-properties.data-migration.spring.flyway.execute-in-transaction) Whether Flyway should execute SQL within a transaction. true () spring.flyway.fail-on-missing-locations(#application-properties.data-migration.spring.flyway.fail-on-missing-locations) Whether to fail if a location of migration scripts doesn't exist. false () spring.flyway.group(#application-properties.data-migration.spring.flyway.group) Whether to group all pending migrations together in the same transaction when applying them. false () spring.flyway.ignore-migration-patterns(#application-properties.data-migration.spring.flyway.ignore-migration-patterns) Ignore migrations that match this comma-separated list of patterns when validating migrations. Requires Flyway Teams. () spring.flyway.init-sqls(#application-properties.data-migration.spring.flyway.init-sqls) SQL statements to execute to initialize a connection immediately after obtaining it. () spring.flyway.installed-by(#application-properties.data-migration.spring.flyway.installed-by) Username recorded in the schema history table as having applied the migration. () spring.flyway.jdbc-properties.*(#application-properties.data-migration.spring.flyway.jdbc-properties) Properties to pass to the JDBC driver. Requires Flyway Teams. () spring.flyway.kerberos-config-file(#application-properties.data-migration.spring.flyway.kerberos-config-file) Path of the Kerberos config file. Requires Flyway Teams. () spring.flyway.locations(#application-properties.data-migration.spring.flyway.locations) Locations of migrations scripts. Can contain the special ""{vendor}"" placeholder to use vendor-specific locations. [classpath:db/migration] () spring.flyway.lock-retry-count(#application-properties.data-migration.spring.flyway.lock-retry-count) Maximum number of retries when trying to obtain a lock. 50 () spring.flyway.loggers(#application-properties.data-migration.spring.flyway.loggers) Loggers Flyway should use. [slf4j] () spring.flyway.mixed(#application-properties.data-migration.spring.flyway.mixed) Whether to allow mixing transactional and non-transactional statements within the same migration. false () spring.flyway.oracle.kerberos-cache-file(#application-properties.data-migration.spring.flyway.oracle.kerberos-cache-file) Path of the Oracle Kerberos cache file. Requires Flyway Teams. () spring.flyway.oracle.sqlplus(#application-properties.data-migration.spring.flyway.oracle.sqlplus) Whether to enable support for Oracle SQL*Plus commands. Requires Flyway Teams. () spring.flyway.oracle.sqlplus-warn(#application-properties.data-migration.spring.flyway.oracle.sqlplus-warn) Whether to issue a warning rather than an error when a not-yet-supported Oracle SQL*Plus statement is encountered. Requires Flyway Teams. () spring.flyway.oracle.wallet-location(#application-properties.data-migration.spring.flyway.oracle.wallet-location) Location of the Oracle Wallet, used to sign in to the database automatically. Requires Flyway Teams. () spring.flyway.out-of-order(#application-properties.data-migration.spring.flyway.out-of-order) Whether to allow migrations to be run out of order. false () spring.flyway.output-query-results(#application-properties.data-migration.spring.flyway.output-query-results) Whether Flyway should output a table with the results of queries when executing migrations. Requires Flyway Teams. () spring.flyway.password(#application-properties.data-migration.spring.flyway.password) Login password of the database to migrate. () spring.flyway.placeholder-prefix(#application-properties.data-migration.spring.flyway.placeholder-prefix) Prefix of placeholders in migration scripts. ${ () spring.flyway.placeholder-replacement(#application-properties.data-migration.spring.flyway.placeholder-replacement) Perform placeholder replacement in migration scripts. true () spring.flyway.placeholder-separator(#application-properties.data-migration.spring.flyway.placeholder-separator) Separator of default placeholders. : () spring.flyway.placeholder-suffix(#application-properties.data-migration.spring.flyway.placeholder-suffix) Suffix of placeholders in migration scripts. } () spring.flyway.placeholders.*(#application-properties.data-migration.spring.flyway.placeholders) Placeholders and their replacements to apply to sql migration scripts. () spring.flyway.postgresql.transactional-lock(#application-properties.data-migration.spring.flyway.postgresql.transactional-lock) Whether transactional advisory locks should be used. If set to false, session-level locks are used instead. () spring.flyway.repeatable-sql-migration-prefix(#application-properties.data-migration.spring.flyway.repeatable-sql-migration-prefix) File name prefix for repeatable SQL migrations. R () spring.flyway.schemas(#application-properties.data-migration.spring.flyway.schemas) Scheme names managed by Flyway (case-sensitive). () spring.flyway.script-placeholder-prefix(#application-properties.data-migration.spring.flyway.script-placeholder-prefix) Prefix of placeholders in migration scripts. FP__ () spring.flyway.script-placeholder-suffix(#application-properties.data-migration.spring.flyway.script-placeholder-suffix) Suffix of placeholders in migration scripts. __ () spring.flyway.skip-default-callbacks(#application-properties.data-migration.spring.flyway.skip-default-callbacks) Whether to skip default callbacks. If true, only custom callbacks are used. false () spring.flyway.skip-default-resolvers(#application-properties.data-migration.spring.flyway.skip-default-resolvers) Whether to skip default resolvers. If true, only custom resolvers are used. false () spring.flyway.skip-executing-migrations(#application-properties.data-migration.spring.flyway.skip-executing-migrations) Whether Flyway should skip executing the contents of the migrations and only update the schema history table. Requires Flyway teams. () spring.flyway.sql-migration-prefix(#application-properties.data-migration.spring.flyway.sql-migration-prefix) File name prefix for SQL migrations. V () spring.flyway.sql-migration-separator(#application-properties.data-migration.spring.flyway.sql-migration-separator) File name separator for SQL migrations. __ () spring.flyway.sql-migration-suffixes(#application-properties.data-migration.spring.flyway.sql-migration-suffixes) File name suffix for SQL migrations. [.sql] () spring.flyway.sqlserver.kerberos-login-file(#application-properties.data-migration.spring.flyway.sqlserver.kerberos-login-file) Path to the SQL Server Kerberos login file. Requires Flyway Teams. () spring.flyway.stream(#application-properties.data-migration.spring.flyway.stream) Whether to stream SQL migrations when executing them. Requires Flyway Teams. () spring.flyway.table(#application-properties.data-migration.spring.flyway.table) Name of the schema history table that will be used by Flyway. flyway_schema_history () spring.flyway.tablespace(#application-properties.data-migration.spring.flyway.tablespace) Tablespace in which the schema history table is created. Ignored when using a database that does not support tablespaces. Defaults to the default tablespace of the connection used by Flyway. () spring.flyway.target(#application-properties.data-migration.spring.flyway.target) Target version up to which migrations should be considered. latest () spring.flyway.url(#application-properties.data-migration.spring.flyway.url) JDBC url of the database to migrate. If not set, the primary configured data source is used. () spring.flyway.user(#application-properties.data-migration.spring.flyway.user) Login user of the database to migrate. () spring.flyway.validate-migration-naming(#application-properties.data-migration.spring.flyway.validate-migration-naming) Whether to validate migrations and callbacks whose scripts do not obey the correct naming convention. false () spring.flyway.validate-on-migrate(#application-properties.data-migration.spring.flyway.validate-on-migrate) Whether to automatically call validate when performing a migration. true () spring.liquibase.change-log(#application-properties.data-migration.spring.liquibase.change-log) Change log configuration path. classpath:/db/changelog/db.changelog-master.yaml () spring.liquibase.clear-checksums(#application-properties.data-migration.spring.liquibase.clear-checksums) Whether to clear all checksums in the current changelog, so they will be recalculated upon the next update. false () spring.liquibase.contexts(#application-properties.data-migration.spring.liquibase.contexts) Comma-separated list of runtime contexts to use. () spring.liquibase.database-change-log-lock-table(#application-properties.data-migration.spring.liquibase.database-change-log-lock-table) Name of table to use for tracking concurrent Liquibase usage. DATABASECHANGELOGLOCK () spring.liquibase.database-change-log-table(#application-properties.data-migration.spring.liquibase.database-change-log-table) Name of table to use for tracking change history. DATABASECHANGELOG () spring.liquibase.default-schema(#application-properties.data-migration.spring.liquibase.default-schema) Default database schema. () spring.liquibase.driver-class-name(#application-properties.data-migration.spring.liquibase.driver-class-name) Fully qualified name of the JDBC driver. Auto-detected based on the URL by default. () spring.liquibase.drop-first(#application-properties.data-migration.spring.liquibase.drop-first) Whether to first drop the database schema. false () spring.liquibase.enabled(#application-properties.data-migration.spring.liquibase.enabled) Whether to enable Liquibase support. true () spring.liquibase.label-filter(#application-properties.data-migration.spring.liquibase.label-filter) Comma-separated list of runtime labels to use. () spring.liquibase.liquibase-schema(#application-properties.data-migration.spring.liquibase.liquibase-schema) Schema to use for Liquibase objects. () spring.liquibase.liquibase-tablespace(#application-properties.data-migration.spring.liquibase.liquibase-tablespace) Tablespace to use for Liquibase objects. () spring.liquibase.parameters.*(#application-properties.data-migration.spring.liquibase.parameters) Change log parameters. () spring.liquibase.password(#application-properties.data-migration.spring.liquibase.password) Login password of the database to migrate. () spring.liquibase.rollback-file(#application-properties.data-migration.spring.liquibase.rollback-file) File to which rollback SQL is written when an update is performed. () spring.liquibase.show-summary(#application-properties.data-migration.spring.liquibase.show-summary) Whether to print a summary of the update operation. summary () spring.liquibase.show-summary-output(#application-properties.data-migration.spring.liquibase.show-summary-output) Where to print a summary of the update operation. log () spring.liquibase.tag(#application-properties.data-migration.spring.liquibase.tag) Tag name to use when applying database changes. Can also be used with ""rollbackFile"" to generate a rollback script for all existing changes associated with that tag. () spring.liquibase.test-rollback-on-update(#application-properties.data-migration.spring.liquibase.test-rollback-on-update) Whether rollback should be tested before update is performed. false () spring.liquibase.ui-service(#application-properties.data-migration.spring.liquibase.ui-service) Which UIService to use. logger () spring.liquibase.url(#application-properties.data-migration.spring.liquibase.url) JDBC URL of the database to migrate. If not set, the primary configured data source is used. () spring.liquibase.user(#application-properties.data-migration.spring.liquibase.user) Login user of the database to migrate. () spring.sql.init.continue-on-error(#application-properties.data-migration.spring.sql.init.continue-on-error) Whether initialization should continue when an error occurs. false () spring.sql.init.data-locations(#application-properties.data-migration.spring.sql.init.data-locations) Locations of the data (DML) scripts to apply to the database. () spring.sql.init.encoding(#application-properties.data-migration.spring.sql.init.encoding) Encoding of the schema and data scripts. () spring.sql.init.mode(#application-properties.data-migration.spring.sql.init.mode) Mode to apply when determining whether initialization should be performed. embedded () spring.sql.init.password(#application-properties.data-migration.spring.sql.init.password) Password of the database to use when applying initialization scripts (if different). () spring.sql.init.platform(#application-properties.data-migration.spring.sql.init.platform) Platform to use in the default schema or data script locations, schema-${platform}.sql and data-${platform}.sql. all () spring.sql.init.schema-locations(#application-properties.data-migration.spring.sql.init.schema-locations) Locations of the schema (DDL) scripts to apply to the database. () spring.sql.init.separator(#application-properties.data-migration.spring.sql.init.separator) Statement separator in the schema and data scripts. ; () spring.sql.init.username(#application-properties.data-migration.spring.sql.init.username) Username of the database to use when applying initialization scripts (if different). Integration Properties: Name Description Default Value () spring.activemq.broker-url(#application-properties.integration.spring.activemq.broker-url) URL of the ActiveMQ broker. Auto-generated by default. () spring.activemq.close-timeout(#application-properties.integration.spring.activemq.close-timeout) Time to wait before considering a close complete. 15s () spring.activemq.non-blocking-redelivery(#application-properties.integration.spring.activemq.non-blocking-redelivery) Whether to stop message delivery before re-delivering messages from a rolled back transaction. This implies that message order is not preserved when this is enabled. false () spring.activemq.packages.trust-all(#application-properties.integration.spring.activemq.packages.trust-all) Whether to trust all packages. () spring.activemq.packages.trusted(#application-properties.integration.spring.activemq.packages.trusted) Comma-separated list of specific packages to trust (when not trusting all packages). () spring.activemq.password(#application-properties.integration.spring.activemq.password) Login password of the broker. () spring.activemq.pool.block-if-full(#application-properties.integration.spring.activemq.pool.block-if-full) Whether to block when a connection is requested and the pool is full. Set it to false to throw a ""JMSException"" instead. true () spring.activemq.pool.block-if-full-timeout(#application-properties.integration.spring.activemq.pool.block-if-full-timeout) Blocking period before throwing an exception if the pool is still full. -1ms () spring.activemq.pool.enabled(#application-properties.integration.spring.activemq.pool.enabled) Whether a JmsPoolConnectionFactory should be created, instead of a regular ConnectionFactory. false () spring.activemq.pool.idle-timeout(#application-properties.integration.spring.activemq.pool.idle-timeout) Connection idle timeout. 30s () spring.activemq.pool.max-connections(#application-properties.integration.spring.activemq.pool.max-connections) Maximum number of pooled connections. 1 () spring.activemq.pool.max-sessions-per-connection(#application-properties.integration.spring.activemq.pool.max-sessions-per-connection) Maximum number of pooled sessions per connection in the pool. 500 () spring.activemq.pool.time-between-expiration-check(#application-properties.integration.spring.activemq.pool.time-between-expiration-check) Time to sleep between runs of the idle connection eviction thread. When negative, no idle connection eviction thread runs. -1ms () spring.activemq.pool.use-anonymous-producers(#application-properties.integration.spring.activemq.pool.use-anonymous-producers) Whether to use only one anonymous ""MessageProducer"" instance. Set it to false to create one ""MessageProducer"" every time one is required. true () spring.activemq.send-timeout(#application-properties.integration.spring.activemq.send-timeout) Time to wait on message sends for a response. Set it to 0 to wait forever. 0ms () spring.activemq.user(#application-properties.integration.spring.activemq.user) Login user of the broker. () spring.artemis.broker-url(#application-properties.integration.spring.artemis.broker-url) Artemis broker url. tcp://localhost:61616 () spring.artemis.embedded.cluster-password(#application-properties.integration.spring.artemis.embedded.cluster-password) Cluster password. Randomly generated on startup by default. () spring.artemis.embedded.data-directory(#application-properties.integration.spring.artemis.embedded.data-directory) Journal file directory. Not necessary if persistence is turned off. () spring.artemis.embedded.enabled(#application-properties.integration.spring.artemis.embedded.enabled) Whether to enable embedded mode if the Artemis server APIs are available. true () spring.artemis.embedded.persistent(#application-properties.integration.spring.artemis.embedded.persistent) Whether to enable persistent store. false () spring.artemis.embedded.queues(#application-properties.integration.spring.artemis.embedded.queues) Comma-separated list of queues to create on startup. [] () spring.artemis.embedded.server-id(#application-properties.integration.spring.artemis.embedded.server-id) Server ID. By default, an auto-incremented counter is used. 0 () spring.artemis.embedded.topics(#application-properties.integration.spring.artemis.embedded.topics) Comma-separated list of topics to create on startup. [] () spring.artemis.mode(#application-properties.integration.spring.artemis.mode) Artemis deployment mode, auto-detected by default. () spring.artemis.password(#application-properties.integration.spring.artemis.password) Login password of the broker. () spring.artemis.pool.block-if-full(#application-properties.integration.spring.artemis.pool.block-if-full) Whether to block when a connection is requested and the pool is full. Set it to false to throw a ""JMSException"" instead. true () spring.artemis.pool.block-if-full-timeout(#application-properties.integration.spring.artemis.pool.block-if-full-timeout) Blocking period before throwing an exception if the pool is still full. -1ms () spring.artemis.pool.enabled(#application-properties.integration.spring.artemis.pool.enabled) Whether a JmsPoolConnectionFactory should be created, instead of a regular ConnectionFactory. false () spring.artemis.pool.idle-timeout(#application-properties.integration.spring.artemis.pool.idle-timeout) Connection idle timeout. 30s () spring.artemis.pool.max-connections(#application-properties.integration.spring.artemis.pool.max-connections) Maximum number of pooled connections. 1 () spring.artemis.pool.max-sessions-per-connection(#application-properties.integration.spring.artemis.pool.max-sessions-per-connection) Maximum number of pooled sessions per connection in the pool. 500 () spring.artemis.pool.time-between-expiration-check(#application-properties.integration.spring.artemis.pool.time-between-expiration-check) Time to sleep between runs of the idle connection eviction thread. When negative, no idle connection eviction thread runs. -1ms () spring.artemis.pool.use-anonymous-producers(#application-properties.integration.spring.artemis.pool.use-anonymous-producers) Whether to use only one anonymous ""MessageProducer"" instance. Set it to false to create one ""MessageProducer"" every time one is required. true () spring.artemis.user(#application-properties.integration.spring.artemis.user) Login user of the broker. () spring.batch.jdbc.initialize-schema(#application-properties.integration.spring.batch.jdbc.initialize-schema) Database schema initialization mode. embedded () spring.batch.jdbc.isolation-level-for-create(#application-properties.integration.spring.batch.jdbc.isolation-level-for-create) Transaction isolation level to use when creating job meta-data for new jobs. () spring.batch.jdbc.platform(#application-properties.integration.spring.batch.jdbc.platform) Platform to use in initialization scripts if the @@platform@@ placeholder is used. Auto-detected by default. () spring.batch.jdbc.schema(#application-properties.integration.spring.batch.jdbc.schema) Path to the SQL file to use to initialize the database schema. classpath:org/springframework/batch/core/schema-@@platform@@.sql () spring.batch.jdbc.table-prefix(#application-properties.integration.spring.batch.jdbc.table-prefix) Table prefix for all the batch meta-data tables. () spring.batch.job.enabled(#application-properties.integration.spring.batch.job.enabled) Execute all Spring Batch jobs in the context on startup. true () spring.batch.job.name(#application-properties.integration.spring.batch.job.name) Job name to execute on startup. Must be specified if multiple Jobs are found in the context. () spring.hazelcast.config(#application-properties.integration.spring.hazelcast.config) The location of the configuration file to use to initialize Hazelcast. () spring.integration.channel.auto-create(#application-properties.integration.spring.integration.channel.auto-create) Whether to create input channels if necessary. true () spring.integration.channel.max-broadcast-subscribers(#application-properties.integration.spring.integration.channel.max-broadcast-subscribers) Default number of subscribers allowed on, for example, a 'PublishSubscribeChannel'. () spring.integration.channel.max-unicast-subscribers(#application-properties.integration.spring.integration.channel.max-unicast-subscribers) Default number of subscribers allowed on, for example, a 'DirectChannel'. () spring.integration.endpoint.default-timeout(#application-properties.integration.spring.integration.endpoint.default-timeout) Default timeout for blocking operations such as sending or receiving messages. 30s () spring.integration.endpoint.no-auto-startup(#application-properties.integration.spring.integration.endpoint.no-auto-startup) A comma-separated list of endpoint bean names patterns that should not be started automatically during application startup. () spring.integration.endpoint.read-only-headers(#application-properties.integration.spring.integration.endpoint.read-only-headers) A comma-separated list of message header names that should not be populated into Message instances during a header copying operation. () spring.integration.endpoint.throw-exception-on-late-reply(#application-properties.integration.spring.integration.endpoint.throw-exception-on-late-reply) Whether to throw an exception when a reply is not expected anymore by a gateway. false () spring.integration.error.ignore-failures(#application-properties.integration.spring.integration.error.ignore-failures) Whether to ignore failures for one or more of the handlers of the global 'errorChannel'. true () spring.integration.error.require-subscribers(#application-properties.integration.spring.integration.error.require-subscribers) Whether to not silently ignore messages on the global 'errorChannel' when there are no subscribers. true () spring.integration.jdbc.initialize-schema(#application-properties.integration.spring.integration.jdbc.initialize-schema) Database schema initialization mode. embedded () spring.integration.jdbc.platform(#application-properties.integration.spring.integration.jdbc.platform) Platform to use in initialization scripts if the @@platform@@ placeholder is used. Auto-detected by default. () spring.integration.jdbc.schema(#application-properties.integration.spring.integration.jdbc.schema) Path to the SQL file to use to initialize the database schema. classpath:org/springframework/integration/jdbc/schema-@@platform@@.sql () spring.integration.management.default-logging-enabled(#application-properties.integration.spring.integration.management.default-logging-enabled) Whether Spring Integration components should perform logging in the main message flow. When disabled, such logging will be skipped without checking the logging level. When enabled, such logging is controlled as normal by the logging system's log level configuration. true () spring.integration.management.observation-patterns(#application-properties.integration.spring.integration.management.observation-patterns) Comma-separated list of simple patterns to match against the names of Spring Integration components. When matched, observation instrumentation will be performed for the component. Please refer to the javadoc of the smartMatch method of Spring Integration's PatternMatchUtils for details of the pattern syntax. () spring.integration.poller.cron(#application-properties.integration.spring.integration.poller.cron) Cron expression for polling. Mutually exclusive with 'fixedDelay' and 'fixedRate'. () spring.integration.poller.fixed-delay(#application-properties.integration.spring.integration.poller.fixed-delay) Polling delay period. Mutually exclusive with 'cron' and 'fixedRate'. () spring.integration.poller.fixed-rate(#application-properties.integration.spring.integration.poller.fixed-rate) Polling rate period. Mutually exclusive with 'fixedDelay' and 'cron'. () spring.integration.poller.initial-delay(#application-properties.integration.spring.integration.poller.initial-delay) Polling initial delay. Applied for 'fixedDelay' and 'fixedRate'; ignored for 'cron'. () spring.integration.poller.max-messages-per-poll(#application-properties.integration.spring.integration.poller.max-messages-per-poll) Maximum number of messages to poll per polling cycle. () spring.integration.poller.receive-timeout(#application-properties.integration.spring.integration.poller.receive-timeout) How long to wait for messages on poll. 1s () spring.integration.rsocket.client.host(#application-properties.integration.spring.integration.rsocket.client.host) TCP RSocket server host to connect to. () spring.integration.rsocket.client.port(#application-properties.integration.spring.integration.rsocket.client.port) TCP RSocket server port to connect to. () spring.integration.rsocket.client.uri(#application-properties.integration.spring.integration.rsocket.client.uri) WebSocket RSocket server uri to connect to. () spring.integration.rsocket.server.message-mapping-enabled(#application-properties.integration.spring.integration.rsocket.server.message-mapping-enabled) Whether to handle message mapping for RSocket through Spring Integration. false () spring.jms.cache.consumers(#application-properties.integration.spring.jms.cache.consumers) Whether to cache message consumers. false () spring.jms.cache.enabled(#application-properties.integration.spring.jms.cache.enabled) Whether to cache sessions. true () spring.jms.cache.producers(#application-properties.integration.spring.jms.cache.producers) Whether to cache message producers. true () spring.jms.cache.session-cache-size(#application-properties.integration.spring.jms.cache.session-cache-size) Size of the session cache (per JMS Session type). 1 () spring.jms.client-id(#application-properties.integration.spring.jms.client-id) Client id of the connection. () spring.jms.jndi-name(#application-properties.integration.spring.jms.jndi-name) Connection factory JNDI name. When set, takes precedence to others connection factory auto-configurations. () spring.jms.listener.auto-startup(#application-properties.integration.spring.jms.listener.auto-startup) Start the container automatically on startup. true () spring.jms.listener.max-concurrency(#application-properties.integration.spring.jms.listener.max-concurrency) Maximum number of concurrent consumers. () spring.jms.listener.min-concurrency(#application-properties.integration.spring.jms.listener.min-concurrency) Minimum number of concurrent consumers. When max-concurrency is not specified the minimum will also be used as the maximum. () spring.jms.listener.receive-timeout(#application-properties.integration.spring.jms.listener.receive-timeout) Timeout to use for receive calls. Use -1 for a no-wait receive or 0 for no timeout at all. The latter is only feasible if not running within a transaction manager and is generally discouraged since it prevents clean shutdown. 1s () spring.jms.listener.session.acknowledge-mode(#application-properties.integration.spring.jms.listener.session.acknowledge-mode) Acknowledge mode of the listener container. auto () spring.jms.listener.session.transacted(#application-properties.integration.spring.jms.listener.session.transacted) Whether the listener container should use transacted JMS sessions. Defaults to false in the presence of a JtaTransactionManager and true otherwise. () spring.jms.pub-sub-domain(#application-properties.integration.spring.jms.pub-sub-domain) Whether the default destination type is topic. false () spring.jms.subscription-durable(#application-properties.integration.spring.jms.subscription-durable) Whether the subscription is durable. false () spring.jms.template.default-destination(#application-properties.integration.spring.jms.template.default-destination) Default destination to use on send and receive operations that do not have a destination parameter. () spring.jms.template.delivery-delay(#application-properties.integration.spring.jms.template.delivery-delay) Delivery delay to use for send calls. () spring.jms.template.delivery-mode(#application-properties.integration.spring.jms.template.delivery-mode) Delivery mode. Enables QoS (Quality of Service) when set. () spring.jms.template.priority(#application-properties.integration.spring.jms.template.priority) Priority of a message when sending. Enables QoS (Quality of Service) when set. () spring.jms.template.qos-enabled(#application-properties.integration.spring.jms.template.qos-enabled) Whether to enable explicit QoS (Quality of Service) when sending a message. When enabled, the delivery mode, priority and time-to-live properties will be used when sending a message. QoS is automatically enabled when at least one of those settings is customized. () spring.jms.template.receive-timeout(#application-properties.integration.spring.jms.template.receive-timeout) Timeout to use for receive calls. () spring.jms.template.session.acknowledge-mode(#application-properties.integration.spring.jms.template.session.acknowledge-mode) Acknowledge mode used when creating sessions. auto () spring.jms.template.session.transacted(#application-properties.integration.spring.jms.template.session.transacted) Whether to use transacted sessions. false () spring.jms.template.time-to-live(#application-properties.integration.spring.jms.template.time-to-live) Time-to-live of a message when sending. Enables QoS (Quality of Service) when set. () spring.kafka.admin.auto-create(#application-properties.integration.spring.kafka.admin.auto-create) Whether to automatically create topics during context initialization. When set to false, disables automatic topic creation during context initialization. true () spring.kafka.admin.client-id(#application-properties.integration.spring.kafka.admin.client-id) ID to pass to the server when making requests. Used for server-side logging. () spring.kafka.admin.close-timeout(#application-properties.integration.spring.kafka.admin.close-timeout) Close timeout. () spring.kafka.admin.fail-fast(#application-properties.integration.spring.kafka.admin.fail-fast) Whether to fail fast if the broker is not available on startup. false () spring.kafka.admin.modify-topic-configs(#application-properties.integration.spring.kafka.admin.modify-topic-configs) Whether to enable modification of existing topic configuration. false () spring.kafka.admin.operation-timeout(#application-properties.integration.spring.kafka.admin.operation-timeout) Operation timeout. () spring.kafka.admin.properties.*(#application-properties.integration.spring.kafka.admin.properties) Additional admin-specific properties used to configure the client. () spring.kafka.admin.security.protocol(#application-properties.integration.spring.kafka.admin.security.protocol) Security protocol used to communicate with brokers. () spring.kafka.admin.ssl.bundle(#application-properties.integration.spring.kafka.admin.ssl.bundle) Name of the SSL bundle to use. () spring.kafka.admin.ssl.key-password(#application-properties.integration.spring.kafka.admin.ssl.key-password) Password of the private key in either key store key or key store file. () spring.kafka.admin.ssl.key-store-certificate-chain(#application-properties.integration.spring.kafka.admin.ssl.key-store-certificate-chain) Certificate chain in PEM format with a list of X.509 certificates. () spring.kafka.admin.ssl.key-store-key(#application-properties.integration.spring.kafka.admin.ssl.key-store-key) Private key in PEM format with PKCS#8 keys. () spring.kafka.admin.ssl.key-store-location(#application-properties.integration.spring.kafka.admin.ssl.key-store-location) Location of the key store file. () spring.kafka.admin.ssl.key-store-password(#application-properties.integration.spring.kafka.admin.ssl.key-store-password) Store password for the key store file. () spring.kafka.admin.ssl.key-store-type(#application-properties.integration.spring.kafka.admin.ssl.key-store-type) Type of the key store. () spring.kafka.admin.ssl.protocol(#application-properties.integration.spring.kafka.admin.ssl.protocol) SSL protocol to use. () spring.kafka.admin.ssl.trust-store-certificates(#application-properties.integration.spring.kafka.admin.ssl.trust-store-certificates) Trusted certificates in PEM format with X.509 certificates. () spring.kafka.admin.ssl.trust-store-location(#application-properties.integration.spring.kafka.admin.ssl.trust-store-location) Location of the trust store file. () spring.kafka.admin.ssl.trust-store-password(#application-properties.integration.spring.kafka.admin.ssl.trust-store-password) Store password for the trust store file. () spring.kafka.admin.ssl.trust-store-type(#application-properties.integration.spring.kafka.admin.ssl.trust-store-type) Type of the trust store. () spring.kafka.bootstrap-servers(#application-properties.integration.spring.kafka.bootstrap-servers) Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Applies to all components unless overridden. () spring.kafka.client-id(#application-properties.integration.spring.kafka.client-id) ID to pass to the server when making requests. Used for server-side logging. () spring.kafka.consumer.auto-commit-interval(#application-properties.integration.spring.kafka.consumer.auto-commit-interval) Frequency with which the consumer offsets are auto-committed to Kafka if 'enable.auto.commit' is set to true. () spring.kafka.consumer.auto-offset-reset(#application-properties.integration.spring.kafka.consumer.auto-offset-reset) What to do when there is no initial offset in Kafka or if the current offset no longer exists on the server. () spring.kafka.consumer.bootstrap-servers(#application-properties.integration.spring.kafka.consumer.bootstrap-servers) Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for consumers. () spring.kafka.consumer.client-id(#application-properties.integration.spring.kafka.consumer.client-id) ID to pass to the server when making requests. Used for server-side logging. () spring.kafka.consumer.enable-auto-commit(#application-properties.integration.spring.kafka.consumer.enable-auto-commit) Whether the consumer's offset is periodically committed in the background. () spring.kafka.consumer.fetch-max-wait(#application-properties.integration.spring.kafka.consumer.fetch-max-wait) Maximum amount of time the server blocks before answering the fetch request if there isn't sufficient data to immediately satisfy the requirement given by ""fetch-min-size"". () spring.kafka.consumer.fetch-min-size(#application-properties.integration.spring.kafka.consumer.fetch-min-size) Minimum amount of data the server should return for a fetch request. () spring.kafka.consumer.group-id(#application-properties.integration.spring.kafka.consumer.group-id) Unique string that identifies the consumer group to which this consumer belongs. () spring.kafka.consumer.heartbeat-interval(#application-properties.integration.spring.kafka.consumer.heartbeat-interval) Expected time between heartbeats to the consumer coordinator. () spring.kafka.consumer.isolation-level(#application-properties.integration.spring.kafka.consumer.isolation-level) Isolation level for reading messages that have been written transactionally. read-uncommitted () spring.kafka.consumer.key-deserializer(#application-properties.integration.spring.kafka.consumer.key-deserializer) Deserializer class for keys. () spring.kafka.consumer.max-poll-records(#application-properties.integration.spring.kafka.consumer.max-poll-records) Maximum number of records returned in a single call to poll(). () spring.kafka.consumer.properties.*(#application-properties.integration.spring.kafka.consumer.properties) Additional consumer-specific properties used to configure the client. () spring.kafka.consumer.security.protocol(#application-properties.integration.spring.kafka.consumer.security.protocol) Security protocol used to communicate with brokers. () spring.kafka.consumer.ssl.bundle(#application-properties.integration.spring.kafka.consumer.ssl.bundle) Name of the SSL bundle to use. () spring.kafka.consumer.ssl.key-password(#application-properties.integration.spring.kafka.consumer.ssl.key-password) Password of the private key in either key store key or key store file. () spring.kafka.consumer.ssl.key-store-certificate-chain(#application-properties.integration.spring.kafka.consumer.ssl.key-store-certificate-chain) Certificate chain in PEM format with a list of X.509 certificates. () spring.kafka.consumer.ssl.key-store-key(#application-properties.integration.spring.kafka.consumer.ssl.key-store-key) Private key in PEM format with PKCS#8 keys. () spring.kafka.consumer.ssl.key-store-location(#application-properties.integration.spring.kafka.consumer.ssl.key-store-location) Location of the key store file. () spring.kafka.consumer.ssl.key-store-password(#application-properties.integration.spring.kafka.consumer.ssl.key-store-password) Store password for the key store file. () spring.kafka.consumer.ssl.key-store-type(#application-properties.integration.spring.kafka.consumer.ssl.key-store-type) Type of the key store. () spring.kafka.consumer.ssl.protocol(#application-properties.integration.spring.kafka.consumer.ssl.protocol) SSL protocol to use. () spring.kafka.consumer.ssl.trust-store-certificates(#application-properties.integration.spring.kafka.consumer.ssl.trust-store-certificates) Trusted certificates in PEM format with X.509 certificates. () spring.kafka.consumer.ssl.trust-store-location(#application-properties.integration.spring.kafka.consumer.ssl.trust-store-location) Location of the trust store file. () spring.kafka.consumer.ssl.trust-store-password(#application-properties.integration.spring.kafka.consumer.ssl.trust-store-password) Store password for the trust store file. () spring.kafka.consumer.ssl.trust-store-type(#application-properties.integration.spring.kafka.consumer.ssl.trust-store-type) Type of the trust store. () spring.kafka.consumer.value-deserializer(#application-properties.integration.spring.kafka.consumer.value-deserializer) Deserializer class for values. () spring.kafka.jaas.control-flag(#application-properties.integration.spring.kafka.jaas.control-flag) Control flag for login configuration. required () spring.kafka.jaas.enabled(#application-properties.integration.spring.kafka.jaas.enabled) Whether to enable JAAS configuration. false () spring.kafka.jaas.login-module(#application-properties.integration.spring.kafka.jaas.login-module) Login module. com.sun.security.auth.module.Krb5LoginModule () spring.kafka.jaas.options.*(#application-properties.integration.spring.kafka.jaas.options) Additional JAAS options. () spring.kafka.listener.ack-count(#application-properties.integration.spring.kafka.listener.ack-count) Number of records between offset commits when ackMode is ""COUNT"" or ""COUNT_TIME"". () spring.kafka.listener.ack-mode(#application-properties.integration.spring.kafka.listener.ack-mode) Listener AckMode. See the spring-kafka documentation. () spring.kafka.listener.ack-time(#application-properties.integration.spring.kafka.listener.ack-time) Time between offset commits when ackMode is ""TIME"" or ""COUNT_TIME"". () spring.kafka.listener.async-acks(#application-properties.integration.spring.kafka.listener.async-acks) Support for asynchronous record acknowledgements. Only applies when spring.kafka.listener.ack-mode is manual or manual-immediate. () spring.kafka.listener.auto-startup(#application-properties.integration.spring.kafka.listener.auto-startup) Whether to auto start the container. true () spring.kafka.listener.change-consumer-thread-name(#application-properties.integration.spring.kafka.listener.change-consumer-thread-name) Whether to instruct the container to change the consumer thread name during initialization. () spring.kafka.listener.client-id(#application-properties.integration.spring.kafka.listener.client-id) Prefix for the listener's consumer client.id property. () spring.kafka.listener.concurrency(#application-properties.integration.spring.kafka.listener.concurrency) Number of threads to run in the listener containers. () spring.kafka.listener.idle-between-polls(#application-properties.integration.spring.kafka.listener.idle-between-polls) Sleep interval between Consumer.poll(Duration) calls. 0 () spring.kafka.listener.idle-event-interval(#application-properties.integration.spring.kafka.listener.idle-event-interval) Time between publishing idle consumer events (no data received). () spring.kafka.listener.idle-partition-event-interval(#application-properties.integration.spring.kafka.listener.idle-partition-event-interval) Time between publishing idle partition consumer events (no data received for partition). () spring.kafka.listener.immediate-stop(#application-properties.integration.spring.kafka.listener.immediate-stop) Whether the container stops after the current record is processed or after all the records from the previous poll are processed. false () spring.kafka.listener.log-container-config(#application-properties.integration.spring.kafka.listener.log-container-config) Whether to log the container configuration during initialization (INFO level). () spring.kafka.listener.missing-topics-fatal(#application-properties.integration.spring.kafka.listener.missing-topics-fatal) Whether the container should fail to start if at least one of the configured topics are not present on the broker. false () spring.kafka.listener.monitor-interval(#application-properties.integration.spring.kafka.listener.monitor-interval) Time between checks for non-responsive consumers. If a duration suffix is not specified, seconds will be used. () spring.kafka.listener.no-poll-threshold(#application-properties.integration.spring.kafka.listener.no-poll-threshold) Multiplier applied to ""pollTimeout"" to determine if a consumer is non-responsive. () spring.kafka.listener.observation-enabled(#application-properties.integration.spring.kafka.listener.observation-enabled) Whether to enable observation. false () spring.kafka.listener.poll-timeout(#application-properties.integration.spring.kafka.listener.poll-timeout) Timeout to use when polling the consumer. () spring.kafka.listener.type(#application-properties.integration.spring.kafka.listener.type) Listener type. single () spring.kafka.producer.acks(#application-properties.integration.spring.kafka.producer.acks) Number of acknowledgments the producer requires the leader to have received before considering a request complete. () spring.kafka.producer.batch-size(#application-properties.integration.spring.kafka.producer.batch-size) Default batch size. A small batch size will make batching less common and may reduce throughput (a batch size of zero disables batching entirely). () spring.kafka.producer.bootstrap-servers(#application-properties.integration.spring.kafka.producer.bootstrap-servers) Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for producers. () spring.kafka.producer.buffer-memory(#application-properties.integration.spring.kafka.producer.buffer-memory) Total memory size the producer can use to buffer records waiting to be sent to the server. () spring.kafka.producer.client-id(#application-properties.integration.spring.kafka.producer.client-id) ID to pass to the server when making requests. Used for server-side logging. () spring.kafka.producer.compression-type(#application-properties.integration.spring.kafka.producer.compression-type) Compression type for all data generated by the producer. () spring.kafka.producer.key-serializer(#application-properties.integration.spring.kafka.producer.key-serializer) Serializer class for keys. () spring.kafka.producer.properties.*(#application-properties.integration.spring.kafka.producer.properties) Additional producer-specific properties used to configure the client. () spring.kafka.producer.retries(#application-properties.integration.spring.kafka.producer.retries) When greater than zero, enables retrying of failed sends. () spring.kafka.producer.security.protocol(#application-properties.integration.spring.kafka.producer.security.protocol) Security protocol used to communicate with brokers. () spring.kafka.producer.ssl.bundle(#application-properties.integration.spring.kafka.producer.ssl.bundle) Name of the SSL bundle to use. () spring.kafka.producer.ssl.key-password(#application-properties.integration.spring.kafka.producer.ssl.key-password) Password of the private key in either key store key or key store file. () spring.kafka.producer.ssl.key-store-certificate-chain(#application-properties.integration.spring.kafka.producer.ssl.key-store-certificate-chain) Certificate chain in PEM format with a list of X.509 certificates. () spring.kafka.producer.ssl.key-store-key(#application-properties.integration.spring.kafka.producer.ssl.key-store-key) Private key in PEM format with PKCS#8 keys. () spring.kafka.producer.ssl.key-store-location(#application-properties.integration.spring.kafka.producer.ssl.key-store-location) Location of the key store file. () spring.kafka.producer.ssl.key-store-password(#application-properties.integration.spring.kafka.producer.ssl.key-store-password) Store password for the key store file. () spring.kafka.producer.ssl.key-store-type(#application-properties.integration.spring.kafka.producer.ssl.key-store-type) Type of the key store. () spring.kafka.producer.ssl.protocol(#application-properties.integration.spring.kafka.producer.ssl.protocol) SSL protocol to use. () spring.kafka.producer.ssl.trust-store-certificates(#application-properties.integration.spring.kafka.producer.ssl.trust-store-certificates) Trusted certificates in PEM format with X.509 certificates. () spring.kafka.producer.ssl.trust-store-location(#application-properties.integration.spring.kafka.producer.ssl.trust-store-location) Location of the trust store file. () spring.kafka.producer.ssl.trust-store-password(#application-properties.integration.spring.kafka.producer.ssl.trust-store-password) Store password for the trust store file. () spring.kafka.producer.ssl.trust-store-type(#application-properties.integration.spring.kafka.producer.ssl.trust-store-type) Type of the trust store. () spring.kafka.producer.transaction-id-prefix(#application-properties.integration.spring.kafka.producer.transaction-id-prefix) When non empty, enables transaction support for producer. () spring.kafka.producer.value-serializer(#application-properties.integration.spring.kafka.producer.value-serializer) Serializer class for values. () spring.kafka.properties.*(#application-properties.integration.spring.kafka.properties) Additional properties, common to producers and consumers, used to configure the client. () spring.kafka.retry.topic.attempts(#application-properties.integration.spring.kafka.retry.topic.attempts) Total number of processing attempts made before sending the message to the DLT. 3 () spring.kafka.retry.topic.delay(#application-properties.integration.spring.kafka.retry.topic.delay) Canonical backoff period. Used as an initial value in the exponential case, and as a minimum value in the uniform case. 1s () spring.kafka.retry.topic.enabled(#application-properties.integration.spring.kafka.retry.topic.enabled) Whether to enable topic-based non-blocking retries. false () spring.kafka.retry.topic.max-delay(#application-properties.integration.spring.kafka.retry.topic.max-delay) Maximum wait between retries. If less than the delay then the default of 30 seconds is applied. 0 () spring.kafka.retry.topic.multiplier(#application-properties.integration.spring.kafka.retry.topic.multiplier) Multiplier to use for generating the next backoff delay. 0 () spring.kafka.retry.topic.random-back-off(#application-properties.integration.spring.kafka.retry.topic.random-back-off) Whether to have the backoff delays. false () spring.kafka.security.protocol(#application-properties.integration.spring.kafka.security.protocol) Security protocol used to communicate with brokers. () spring.kafka.ssl.bundle(#application-properties.integration.spring.kafka.ssl.bundle) Name of the SSL bundle to use. () spring.kafka.ssl.key-password(#application-properties.integration.spring.kafka.ssl.key-password) Password of the private key in either key store key or key store file. () spring.kafka.ssl.key-store-certificate-chain(#application-properties.integration.spring.kafka.ssl.key-store-certificate-chain) Certificate chain in PEM format with a list of X.509 certificates. () spring.kafka.ssl.key-store-key(#application-properties.integration.spring.kafka.ssl.key-store-key) Private key in PEM format with PKCS#8 keys. () spring.kafka.ssl.key-store-location(#application-properties.integration.spring.kafka.ssl.key-store-location) Location of the key store file. () spring.kafka.ssl.key-store-password(#application-properties.integration.spring.kafka.ssl.key-store-password) Store password for the key store file. () spring.kafka.ssl.key-store-type(#application-properties.integration.spring.kafka.ssl.key-store-type) Type of the key store. () spring.kafka.ssl.protocol(#application-properties.integration.spring.kafka.ssl.protocol) SSL protocol to use. () spring.kafka.ssl.trust-store-certificates(#application-properties.integration.spring.kafka.ssl.trust-store-certificates) Trusted certificates in PEM format with X.509 certificates. () spring.kafka.ssl.trust-store-location(#application-properties.integration.spring.kafka.ssl.trust-store-location) Location of the trust store file. () spring.kafka.ssl.trust-store-password(#application-properties.integration.spring.kafka.ssl.trust-store-password) Store password for the trust store file. () spring.kafka.ssl.trust-store-type(#application-properties.integration.spring.kafka.ssl.trust-store-type) Type of the trust store. () spring.kafka.streams.application-id(#application-properties.integration.spring.kafka.streams.application-id) Kafka streams application.id property; default spring.application.name. () spring.kafka.streams.auto-startup(#application-properties.integration.spring.kafka.streams.auto-startup) Whether to auto-start the streams factory bean. true () spring.kafka.streams.bootstrap-servers(#application-properties.integration.spring.kafka.streams.bootstrap-servers) Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for streams. () spring.kafka.streams.cleanup.on-shutdown(#application-properties.integration.spring.kafka.streams.cleanup.on-shutdown) Cleanup the application’s local state directory on shutdown. false () spring.kafka.streams.cleanup.on-startup(#application-properties.integration.spring.kafka.streams.cleanup.on-startup) Cleanup the application’s local state directory on startup. false () spring.kafka.streams.client-id(#application-properties.integration.spring.kafka.streams.client-id) ID to pass to the server when making requests. Used for server-side logging. () spring.kafka.streams.properties.*(#application-properties.integration.spring.kafka.streams.properties) Additional Kafka properties used to configure the streams. () spring.kafka.streams.replication-factor(#application-properties.integration.spring.kafka.streams.replication-factor) The replication factor for change log topics and repartition topics created by the stream processing application. () spring.kafka.streams.security.protocol(#application-properties.integration.spring.kafka.streams.security.protocol) Security protocol used to communicate with brokers. () spring.kafka.streams.ssl.bundle(#application-properties.integration.spring.kafka.streams.ssl.bundle) Name of the SSL bundle to use. () spring.kafka.streams.ssl.key-password(#application-properties.integration.spring.kafka.streams.ssl.key-password) Password of the private key in either key store key or key store file. () spring.kafka.streams.ssl.key-store-certificate-chain(#application-properties.integration.spring.kafka.streams.ssl.key-store-certificate-chain) Certificate chain in PEM format with a list of X.509 certificates. () spring.kafka.streams.ssl.key-store-key(#application-properties.integration.spring.kafka.streams.ssl.key-store-key) Private key in PEM format with PKCS#8 keys. () spring.kafka.streams.ssl.key-store-location(#application-properties.integration.spring.kafka.streams.ssl.key-store-location) Location of the key store file. () spring.kafka.streams.ssl.key-store-password(#application-properties.integration.spring.kafka.streams.ssl.key-store-password) Store password for the key store file. () spring.kafka.streams.ssl.key-store-type(#application-properties.integration.spring.kafka.streams.ssl.key-store-type) Type of the key store. () spring.kafka.streams.ssl.protocol(#application-properties.integration.spring.kafka.streams.ssl.protocol) SSL protocol to use. () spring.kafka.streams.ssl.trust-store-certificates(#application-properties.integration.spring.kafka.streams.ssl.trust-store-certificates) Trusted certificates in PEM format with X.509 certificates. () spring.kafka.streams.ssl.trust-store-location(#application-properties.integration.spring.kafka.streams.ssl.trust-store-location) Location of the trust store file. () spring.kafka.streams.ssl.trust-store-password(#application-properties.integration.spring.kafka.streams.ssl.trust-store-password) Store password for the trust store file. () spring.kafka.streams.ssl.trust-store-type(#application-properties.integration.spring.kafka.streams.ssl.trust-store-type) Type of the trust store. () spring.kafka.streams.state-dir(#application-properties.integration.spring.kafka.streams.state-dir) Directory location for the state store. () spring.kafka.streams.state-store-cache-max-size(#application-properties.integration.spring.kafka.streams.state-store-cache-max-size) Maximum size of the in-memory state store cache across all threads. () spring.kafka.template.default-topic(#application-properties.integration.spring.kafka.template.default-topic) Default topic to which messages are sent. () spring.kafka.template.observation-enabled(#application-properties.integration.spring.kafka.template.observation-enabled) Whether to enable observation. false () spring.kafka.template.transaction-id-prefix(#application-properties.integration.spring.kafka.template.transaction-id-prefix) Transaction id prefix, override the transaction id prefix in the producer factory. () spring.pulsar.admin.authentication.param.*(#application-properties.integration.spring.pulsar.admin.authentication.param) Authentication parameter(s) as a map of parameter names to parameter values. () spring.pulsar.admin.authentication.plugin-class-name(#application-properties.integration.spring.pulsar.admin.authentication.plugin-class-name) Fully qualified class name of the authentication plugin. () spring.pulsar.admin.connection-timeout(#application-properties.integration.spring.pulsar.admin.connection-timeout) Duration to wait for a connection to server to be established. 1m () spring.pulsar.admin.read-timeout(#application-properties.integration.spring.pulsar.admin.read-timeout) Server response read time out for any request. 1m () spring.pulsar.admin.request-timeout(#application-properties.integration.spring.pulsar.admin.request-timeout) Server request time out for any request. 5m () spring.pulsar.admin.service-url(#application-properties.integration.spring.pulsar.admin.service-url) Pulsar web URL for the admin endpoint in the format '(http|https)://host:port'. http://localhost:8080 () spring.pulsar.client.authentication.param.*(#application-properties.integration.spring.pulsar.client.authentication.param) Authentication parameter(s) as a map of parameter names to parameter values. () spring.pulsar.client.authentication.plugin-class-name(#application-properties.integration.spring.pulsar.client.authentication.plugin-class-name) Fully qualified class name of the authentication plugin. () spring.pulsar.client.connection-timeout(#application-properties.integration.spring.pulsar.client.connection-timeout) Duration to wait for a connection to a broker to be established. 10s () spring.pulsar.client.failover.backup-clusters(#application-properties.integration.spring.pulsar.client.failover.backup-clusters) List of backup clusters. The backup cluster is chosen in the sequence of the given list. If all backup clusters are available, the Pulsar client chooses the first backup cluster. () spring.pulsar.client.failover.check-interval(#application-properties.integration.spring.pulsar.client.failover.check-interval) Frequency of performing a probe task. () spring.pulsar.client.failover.delay(#application-properties.integration.spring.pulsar.client.failover.delay) Delay before the Pulsar client switches from the primary cluster to the backup cluster. () spring.pulsar.client.failover.policy(#application-properties.integration.spring.pulsar.client.failover.policy) Cluster failover policy. order () spring.pulsar.client.failover.switch-back-delay(#application-properties.integration.spring.pulsar.client.failover.switch-back-delay) Delay before the Pulsar client switches from the backup cluster to the primary cluster. () spring.pulsar.client.lookup-timeout(#application-properties.integration.spring.pulsar.client.lookup-timeout) Client lookup timeout. () spring.pulsar.client.operation-timeout(#application-properties.integration.spring.pulsar.client.operation-timeout) Client operation timeout. 30s () spring.pulsar.client.service-url(#application-properties.integration.spring.pulsar.client.service-url) Pulsar service URL in the format '(pulsar|pulsar+ssl)://host:port'. pulsar://localhost:6650 () spring.pulsar.consumer.dead-letter-policy.dead-letter-topic(#application-properties.integration.spring.pulsar.consumer.dead-letter-policy.dead-letter-topic) Name of the dead topic where the failing messages will be sent. () spring.pulsar.consumer.dead-letter-policy.initial-subscription-name(#application-properties.integration.spring.pulsar.consumer.dead-letter-policy.initial-subscription-name) Name of the initial subscription of the dead letter topic. When not set, the initial subscription will not be created. However, when the property is set then the broker's 'allowAutoSubscriptionCreation' must be enabled or the DLQ producer will fail. () spring.pulsar.consumer.dead-letter-policy.max-redeliver-count(#application-properties.integration.spring.pulsar.consumer.dead-letter-policy.max-redeliver-count) Maximum number of times that a message will be redelivered before being sent to the dead letter queue. 0 () spring.pulsar.consumer.dead-letter-policy.retry-letter-topic(#application-properties.integration.spring.pulsar.consumer.dead-letter-policy.retry-letter-topic) Name of the retry topic where the failing messages will be sent. () spring.pulsar.consumer.name(#application-properties.integration.spring.pulsar.consumer.name) Consumer name to identify a particular consumer from the topic stats. () spring.pulsar.consumer.priority-level(#application-properties.integration.spring.pulsar.consumer.priority-level) Priority level for shared subscription consumers. 0 () spring.pulsar.consumer.read-compacted(#application-properties.integration.spring.pulsar.consumer.read-compacted) Whether to read messages from the compacted topic rather than the full message backlog. false () spring.pulsar.consumer.retry-enable(#application-properties.integration.spring.pulsar.consumer.retry-enable) Whether to auto retry messages. false () spring.pulsar.consumer.subscription.initial-position(#application-properties.integration.spring.pulsar.consumer.subscription.initial-position) Position where to initialize a newly created subscription. latest () spring.pulsar.consumer.subscription.mode(#application-properties.integration.spring.pulsar.consumer.subscription.mode) Subscription mode to be used when subscribing to the topic. durable () spring.pulsar.consumer.subscription.name(#application-properties.integration.spring.pulsar.consumer.subscription.name) Subscription name for the consumer. () spring.pulsar.consumer.subscription.topics-mode(#application-properties.integration.spring.pulsar.consumer.subscription.topics-mode) Determines which type of topics (persistent, non-persistent, or all) the consumer should be subscribed to when using pattern subscriptions. persistentonly () spring.pulsar.consumer.subscription.type(#application-properties.integration.spring.pulsar.consumer.subscription.type) Subscription type to be used when subscribing to a topic. exclusive () spring.pulsar.consumer.topics(#application-properties.integration.spring.pulsar.consumer.topics) Topics the consumer subscribes to. () spring.pulsar.consumer.topics-pattern(#application-properties.integration.spring.pulsar.consumer.topics-pattern) Pattern for topics the consumer subscribes to. () spring.pulsar.defaults.type-mappings(#application-properties.integration.spring.pulsar.defaults.type-mappings) List of mappings from message type to topic name and schema info to use as a defaults when a topic name and/or schema is not explicitly specified when producing or consuming messages of the mapped type. () spring.pulsar.function.enabled(#application-properties.integration.spring.pulsar.function.enabled) Whether to enable function support. true () spring.pulsar.function.fail-fast(#application-properties.integration.spring.pulsar.function.fail-fast) Whether to stop processing further function creates/updates when a failure occurs. true () spring.pulsar.function.propagate-failures(#application-properties.integration.spring.pulsar.function.propagate-failures) Whether to throw an exception if any failure is encountered during server startup while creating/updating functions. true () spring.pulsar.function.propagate-stop-failures(#application-properties.integration.spring.pulsar.function.propagate-stop-failures) Whether to throw an exception if any failure is encountered during server shutdown while enforcing stop policy on functions. false () spring.pulsar.listener.observation-enabled(#application-properties.integration.spring.pulsar.listener.observation-enabled) Whether to record observations for when the Observations API is available and the client supports it. false () spring.pulsar.listener.schema-type(#application-properties.integration.spring.pulsar.listener.schema-type) SchemaType of the consumed messages. () spring.pulsar.producer.access-mode(#application-properties.integration.spring.pulsar.producer.access-mode) Type of access to the topic the producer requires. shared () spring.pulsar.producer.batching-enabled(#application-properties.integration.spring.pulsar.producer.batching-enabled) Whether to automatically batch messages. true () spring.pulsar.producer.cache.enabled(#application-properties.integration.spring.pulsar.producer.cache.enabled) Whether to enable caching in the PulsarProducerFactory. true () spring.pulsar.producer.cache.expire-after-access(#application-properties.integration.spring.pulsar.producer.cache.expire-after-access) Time period to expire unused entries in the cache. 1m () spring.pulsar.producer.cache.initial-capacity(#application-properties.integration.spring.pulsar.producer.cache.initial-capacity) Initial size of cache. 50 () spring.pulsar.producer.cache.maximum-size(#application-properties.integration.spring.pulsar.producer.cache.maximum-size) Maximum size of cache (entries). 1000 () spring.pulsar.producer.chunking-enabled(#application-properties.integration.spring.pulsar.producer.chunking-enabled) Whether to split large-size messages into multiple chunks. false () spring.pulsar.producer.compression-type(#application-properties.integration.spring.pulsar.producer.compression-type) Message compression type. () spring.pulsar.producer.hashing-scheme(#application-properties.integration.spring.pulsar.producer.hashing-scheme) Message hashing scheme to choose the partition to which the message is published. javastringhash () spring.pulsar.producer.message-routing-mode(#application-properties.integration.spring.pulsar.producer.message-routing-mode) Message routing mode for a partitioned producer. roundrobinpartition () spring.pulsar.producer.name(#application-properties.integration.spring.pulsar.producer.name) Name for the producer. If not assigned, a unique name is generated. () spring.pulsar.producer.send-timeout(#application-properties.integration.spring.pulsar.producer.send-timeout) Time before a message has to be acknowledged by the broker. 30s () spring.pulsar.producer.topic-name(#application-properties.integration.spring.pulsar.producer.topic-name) Topic the producer will publish to. () spring.pulsar.reader.name(#application-properties.integration.spring.pulsar.reader.name) Reader name. () spring.pulsar.reader.read-compacted(#application-properties.integration.spring.pulsar.reader.read-compacted) Whether to read messages from a compacted topic rather than a full message backlog of a topic. false () spring.pulsar.reader.subscription-name(#application-properties.integration.spring.pulsar.reader.subscription-name) Subscription name. () spring.pulsar.reader.subscription-role-prefix(#application-properties.integration.spring.pulsar.reader.subscription-role-prefix) Prefix of subscription role. () spring.pulsar.reader.topics(#application-properties.integration.spring.pulsar.reader.topics) Topics the reader subscribes to. () spring.pulsar.template.observations-enabled(#application-properties.integration.spring.pulsar.template.observations-enabled) Whether to record observations for when the Observations API is available. false () spring.pulsar.transaction.enabled(#application-properties.integration.spring.pulsar.transaction.enabled) Whether transaction support is enabled. false () spring.rabbitmq.address-shuffle-mode(#application-properties.integration.spring.rabbitmq.address-shuffle-mode) Mode used to shuffle configured addresses. none () spring.rabbitmq.addresses(#application-properties.integration.spring.rabbitmq.addresses) Comma-separated list of addresses to which the client should connect. When set, the host and port are ignored. () spring.rabbitmq.cache.channel.checkout-timeout(#application-properties.integration.spring.rabbitmq.cache.channel.checkout-timeout) Duration to wait to obtain a channel if the cache size has been reached. If 0, always create a new channel. () spring.rabbitmq.cache.channel.size(#application-properties.integration.spring.rabbitmq.cache.channel.size) Number of channels to retain in the cache. When ""check-timeout"" > 0, max channels per connection. () spring.rabbitmq.cache.connection.mode(#application-properties.integration.spring.rabbitmq.cache.connection.mode) Connection factory cache mode. channel () spring.rabbitmq.cache.connection.size(#application-properties.integration.spring.rabbitmq.cache.connection.size) Number of connections to cache. Only applies when mode is CONNECTION. () spring.rabbitmq.channel-rpc-timeout(#application-properties.integration.spring.rabbitmq.channel-rpc-timeout) Continuation timeout for RPC calls in channels. Set it to zero to wait forever. 10m () spring.rabbitmq.connection-timeout(#application-properties.integration.spring.rabbitmq.connection-timeout) Connection timeout. Set it to zero to wait forever. () spring.rabbitmq.dynamic(#application-properties.integration.spring.rabbitmq.dynamic) Whether to create an AmqpAdmin bean. true () spring.rabbitmq.host(#application-properties.integration.spring.rabbitmq.host) RabbitMQ host. Ignored if an address is set. localhost () spring.rabbitmq.listener.direct.acknowledge-mode(#application-properties.integration.spring.rabbitmq.listener.direct.acknowledge-mode) Acknowledge mode of container. () spring.rabbitmq.listener.direct.auto-startup(#application-properties.integration.spring.rabbitmq.listener.direct.auto-startup) Whether to start the container automatically on startup. true () spring.rabbitmq.listener.direct.consumers-per-queue(#application-properties.integration.spring.rabbitmq.listener.direct.consumers-per-queue) Number of consumers per queue. () spring.rabbitmq.listener.direct.de-batching-enabled(#application-properties.integration.spring.rabbitmq.listener.direct.de-batching-enabled) Whether the container should present batched messages as discrete messages or call the listener with the batch. true () spring.rabbitmq.listener.direct.default-requeue-rejected(#application-properties.integration.spring.rabbitmq.listener.direct.default-requeue-rejected) Whether rejected deliveries are re-queued by default. () spring.rabbitmq.listener.direct.force-stop(#application-properties.integration.spring.rabbitmq.listener.direct.force-stop) Whether the container (when stopped) should stop immediately after processing the current message or stop after processing all pre-fetched messages. false () spring.rabbitmq.listener.direct.idle-event-interval(#application-properties.integration.spring.rabbitmq.listener.direct.idle-event-interval) How often idle container events should be published. () spring.rabbitmq.listener.direct.missing-queues-fatal(#application-properties.integration.spring.rabbitmq.listener.direct.missing-queues-fatal) Whether to fail if the queues declared by the container are not available on the broker. false () spring.rabbitmq.listener.direct.observation-enabled(#application-properties.integration.spring.rabbitmq.listener.direct.observation-enabled) Whether to enable observation. false () spring.rabbitmq.listener.direct.prefetch(#application-properties.integration.spring.rabbitmq.listener.direct.prefetch) Maximum number of unacknowledged messages that can be outstanding at each consumer. () spring.rabbitmq.listener.direct.retry.enabled(#application-properties.integration.spring.rabbitmq.listener.direct.retry.enabled) Whether publishing retries are enabled. false () spring.rabbitmq.listener.direct.retry.initial-interval(#application-properties.integration.spring.rabbitmq.listener.direct.retry.initial-interval) Duration between the first and second attempt to deliver a message. 1000ms () spring.rabbitmq.listener.direct.retry.max-attempts(#application-properties.integration.spring.rabbitmq.listener.direct.retry.max-attempts) Maximum number of attempts to deliver a message. 3 () spring.rabbitmq.listener.direct.retry.max-interval(#application-properties.integration.spring.rabbitmq.listener.direct.retry.max-interval) Maximum duration between attempts. 10000ms () spring.rabbitmq.listener.direct.retry.multiplier(#application-properties.integration.spring.rabbitmq.listener.direct.retry.multiplier) Multiplier to apply to the previous retry interval. 1 () spring.rabbitmq.listener.direct.retry.stateless(#application-properties.integration.spring.rabbitmq.listener.direct.retry.stateless) Whether retries are stateless or stateful. true () spring.rabbitmq.listener.simple.acknowledge-mode(#application-properties.integration.spring.rabbitmq.listener.simple.acknowledge-mode) Acknowledge mode of container. () spring.rabbitmq.listener.simple.auto-startup(#application-properties.integration.spring.rabbitmq.listener.simple.auto-startup) Whether to start the container automatically on startup. true () spring.rabbitmq.listener.simple.batch-size(#application-properties.integration.spring.rabbitmq.listener.simple.batch-size) Batch size, expressed as the number of physical messages, to be used by the container. () spring.rabbitmq.listener.simple.concurrency(#application-properties.integration.spring.rabbitmq.listener.simple.concurrency) Minimum number of listener invoker threads. () spring.rabbitmq.listener.simple.consumer-batch-enabled(#application-properties.integration.spring.rabbitmq.listener.simple.consumer-batch-enabled) Whether the container creates a batch of messages based on the 'receive-timeout' and 'batch-size'. Coerces 'de-batching-enabled' to true to include the contents of a producer created batch in the batch as discrete records. false () spring.rabbitmq.listener.simple.de-batching-enabled(#application-properties.integration.spring.rabbitmq.listener.simple.de-batching-enabled) Whether the container should present batched messages as discrete messages or call the listener with the batch. true () spring.rabbitmq.listener.simple.default-requeue-rejected(#application-properties.integration.spring.rabbitmq.listener.simple.default-requeue-rejected) Whether rejected deliveries are re-queued by default. () spring.rabbitmq.listener.simple.force-stop(#application-properties.integration.spring.rabbitmq.listener.simple.force-stop) Whether the container (when stopped) should stop immediately after processing the current message or stop after processing all pre-fetched messages. false () spring.rabbitmq.listener.simple.idle-event-interval(#application-properties.integration.spring.rabbitmq.listener.simple.idle-event-interval) How often idle container events should be published. () spring.rabbitmq.listener.simple.max-concurrency(#application-properties.integration.spring.rabbitmq.listener.simple.max-concurrency) Maximum number of listener invoker threads. () spring.rabbitmq.listener.simple.missing-queues-fatal(#application-properties.integration.spring.rabbitmq.listener.simple.missing-queues-fatal) Whether to fail if the queues declared by the container are not available on the broker and/or whether to stop the container if one or more queues are deleted at runtime. true () spring.rabbitmq.listener.simple.observation-enabled(#application-properties.integration.spring.rabbitmq.listener.simple.observation-enabled) Whether to enable observation. false () spring.rabbitmq.listener.simple.prefetch(#application-properties.integration.spring.rabbitmq.listener.simple.prefetch) Maximum number of unacknowledged messages that can be outstanding at each consumer. () spring.rabbitmq.listener.simple.retry.enabled(#application-properties.integration.spring.rabbitmq.listener.simple.retry.enabled) Whether publishing retries are enabled. false () spring.rabbitmq.listener.simple.retry.initial-interval(#application-properties.integration.spring.rabbitmq.listener.simple.retry.initial-interval) Duration between the first and second attempt to deliver a message. 1000ms () spring.rabbitmq.listener.simple.retry.max-attempts(#application-properties.integration.spring.rabbitmq.listener.simple.retry.max-attempts) Maximum number of attempts to deliver a message. 3 () spring.rabbitmq.listener.simple.retry.max-interval(#application-properties.integration.spring.rabbitmq.listener.simple.retry.max-interval) Maximum duration between attempts. 10000ms () spring.rabbitmq.listener.simple.retry.multiplier(#application-properties.integration.spring.rabbitmq.listener.simple.retry.multiplier) Multiplier to apply to the previous retry interval. 1 () spring.rabbitmq.listener.simple.retry.stateless(#application-properties.integration.spring.rabbitmq.listener.simple.retry.stateless) Whether retries are stateless or stateful. true () spring.rabbitmq.listener.stream.native-listener(#application-properties.integration.spring.rabbitmq.listener.stream.native-listener) Whether the container will support listeners that consume native stream messages instead of Spring AMQP messages. false () spring.rabbitmq.listener.stream.observation-enabled(#application-properties.integration.spring.rabbitmq.listener.stream.observation-enabled) Whether to enable observation. false () spring.rabbitmq.listener.type(#application-properties.integration.spring.rabbitmq.listener.type) Listener container type. simple () spring.rabbitmq.max-inbound-message-body-size(#application-properties.integration.spring.rabbitmq.max-inbound-message-body-size) Maximum size of the body of inbound (received) messages. 64MB () spring.rabbitmq.password(#application-properties.integration.spring.rabbitmq.password) Login to authenticate against the broker. guest () spring.rabbitmq.port(#application-properties.integration.spring.rabbitmq.port) RabbitMQ port. Ignored if an address is set. Default to 5672, or 5671 if SSL is enabled. () spring.rabbitmq.publisher-confirm-type(#application-properties.integration.spring.rabbitmq.publisher-confirm-type) Type of publisher confirms to use. () spring.rabbitmq.publisher-returns(#application-properties.integration.spring.rabbitmq.publisher-returns) Whether to enable publisher returns. false () spring.rabbitmq.requested-channel-max(#application-properties.integration.spring.rabbitmq.requested-channel-max) Number of channels per connection requested by the client. Use 0 for unlimited. 2047 () spring.rabbitmq.requested-heartbeat(#application-properties.integration.spring.rabbitmq.requested-heartbeat) Requested heartbeat timeout; zero for none. If a duration suffix is not specified, seconds will be used. () spring.rabbitmq.ssl.algorithm(#application-properties.integration.spring.rabbitmq.ssl.algorithm) SSL algorithm to use. By default, configured by the Rabbit client library. () spring.rabbitmq.ssl.bundle(#application-properties.integration.spring.rabbitmq.ssl.bundle) SSL bundle name. () spring.rabbitmq.ssl.enabled(#application-properties.integration.spring.rabbitmq.ssl.enabled) Whether to enable SSL support. Determined automatically if an address is provided with the protocol (amqp:// vs. amqps://). () spring.rabbitmq.ssl.key-store(#application-properties.integration.spring.rabbitmq.ssl.key-store) Path to the key store that holds the SSL certificate. () spring.rabbitmq.ssl.key-store-algorithm(#application-properties.integration.spring.rabbitmq.ssl.key-store-algorithm) Key store algorithm. SunX509 () spring.rabbitmq.ssl.key-store-password(#application-properties.integration.spring.rabbitmq.ssl.key-store-password) Password used to access the key store. () spring.rabbitmq.ssl.key-store-type(#application-properties.integration.spring.rabbitmq.ssl.key-store-type) Key store type. PKCS12 () spring.rabbitmq.ssl.trust-store(#application-properties.integration.spring.rabbitmq.ssl.trust-store) Trust store that holds SSL certificates. () spring.rabbitmq.ssl.trust-store-algorithm(#application-properties.integration.spring.rabbitmq.ssl.trust-store-algorithm) Trust store algorithm. SunX509 () spring.rabbitmq.ssl.trust-store-password(#application-properties.integration.spring.rabbitmq.ssl.trust-store-password) Password used to access the trust store. () spring.rabbitmq.ssl.trust-store-type(#application-properties.integration.spring.rabbitmq.ssl.trust-store-type) Trust store type. JKS () spring.rabbitmq.ssl.validate-server-certificate(#application-properties.integration.spring.rabbitmq.ssl.validate-server-certificate) Whether to enable server side certificate validation. true () spring.rabbitmq.ssl.verify-hostname(#application-properties.integration.spring.rabbitmq.ssl.verify-hostname) Whether to enable hostname verification. true () spring.rabbitmq.stream.host(#application-properties.integration.spring.rabbitmq.stream.host) Host of a RabbitMQ instance with the Stream plugin enabled. localhost () spring.rabbitmq.stream.name(#application-properties.integration.spring.rabbitmq.stream.name) Name of the stream. () spring.rabbitmq.stream.password(#application-properties.integration.spring.rabbitmq.stream.password) Login password to authenticate to the broker. When not set spring.rabbitmq.password is used. () spring.rabbitmq.stream.port(#application-properties.integration.spring.rabbitmq.stream.port) Stream port of a RabbitMQ instance with the Stream plugin enabled. () spring.rabbitmq.stream.username(#application-properties.integration.spring.rabbitmq.stream.username) Login user to authenticate to the broker. When not set, spring.rabbitmq.username is used. () spring.rabbitmq.stream.virtual-host(#application-properties.integration.spring.rabbitmq.stream.virtual-host) Virtual host of a RabbitMQ instance with the Stream plugin enabled. When not set, spring.rabbitmq.virtual-host is used. () spring.rabbitmq.template.allowed-list-patterns(#application-properties.integration.spring.rabbitmq.template.allowed-list-patterns) Simple patterns for allowable packages/classes for deserialization. () spring.rabbitmq.template.default-receive-queue(#application-properties.integration.spring.rabbitmq.template.default-receive-queue) Name of the default queue to receive messages from when none is specified explicitly. () spring.rabbitmq.template.exchange(#application-properties.integration.spring.rabbitmq.template.exchange) Name of the default exchange to use for send operations. () spring.rabbitmq.template.mandatory(#application-properties.integration.spring.rabbitmq.template.mandatory) Whether to enable mandatory messages. () spring.rabbitmq.template.observation-enabled(#application-properties.integration.spring.rabbitmq.template.observation-enabled) Whether to enable observation. false () spring.rabbitmq.template.receive-timeout(#application-properties.integration.spring.rabbitmq.template.receive-timeout) Timeout for receive() operations. () spring.rabbitmq.template.reply-timeout(#application-properties.integration.spring.rabbitmq.template.reply-timeout) Timeout for sendAndReceive() operations. () spring.rabbitmq.template.retry.enabled(#application-properties.integration.spring.rabbitmq.template.retry.enabled) Whether publishing retries are enabled. false () spring.rabbitmq.template.retry.initial-interval(#application-properties.integration.spring.rabbitmq.template.retry.initial-interval) Duration between the first and second attempt to deliver a message. 1000ms () spring.rabbitmq.template.retry.max-attempts(#application-properties.integration.spring.rabbitmq.template.retry.max-attempts) Maximum number of attempts to deliver a message. 3 () spring.rabbitmq.template.retry.max-interval(#application-properties.integration.spring.rabbitmq.template.retry.max-interval) Maximum duration between attempts. 10000ms () spring.rabbitmq.template.retry.multiplier(#application-properties.integration.spring.rabbitmq.template.retry.multiplier) Multiplier to apply to the previous retry interval. 1 () spring.rabbitmq.template.routing-key(#application-properties.integration.spring.rabbitmq.template.routing-key) Value of a default routing key to use for send operations. () spring.rabbitmq.username(#application-properties.integration.spring.rabbitmq.username) Login user to authenticate to the broker. guest () spring.rabbitmq.virtual-host(#application-properties.integration.spring.rabbitmq.virtual-host) Virtual host to use when connecting to the broker. () spring.webservices.path(#application-properties.integration.spring.webservices.path) Path that serves as the base URI for the services. /services () spring.webservices.servlet.init.*(#application-properties.integration.spring.webservices.servlet.init) Servlet init parameters to pass to Spring Web Services. () spring.webservices.servlet.load-on-startup(#application-properties.integration.spring.webservices.servlet.load-on-startup) Load on startup priority of the Spring Web Services servlet. -1 () spring.webservices.wsdl-locations(#application-properties.integration.spring.webservices.wsdl-locations) Comma-separated list of locations of WSDLs and accompanying XSDs to be exposed as beans. Web Properties: Name Description Default Value () spring.graphql.cors.allow-credentials(#application-properties.web.spring.graphql.cors.allow-credentials) Whether credentials are supported. When not set, credentials are not supported. () spring.graphql.cors.allowed-headers(#application-properties.web.spring.graphql.cors.allowed-headers) Comma-separated list of HTTP headers to allow in a request. '*' allows all headers. () spring.graphql.cors.allowed-methods(#application-properties.web.spring.graphql.cors.allowed-methods) Comma-separated list of HTTP methods to allow. '*' allows all methods. When not set, defaults to GET. () spring.graphql.cors.allowed-origin-patterns(#application-properties.web.spring.graphql.cors.allowed-origin-patterns) Comma-separated list of origin patterns to allow. Unlike allowed origins which only support '*', origin patterns are more flexible, e.g. 'https://*.example.com', and can be used with allow-credentials. When neither allowed origins nor allowed origin patterns are set, cross-origin requests are effectively disabled. () spring.graphql.cors.allowed-origins(#application-properties.web.spring.graphql.cors.allowed-origins) Comma-separated list of origins to allow with '*' allowing all origins. When allow-credentials is enabled, '*' cannot be used, and setting origin patterns should be considered instead. When neither allowed origins nor allowed origin patterns are set, cross-origin requests are effectively disabled. () spring.graphql.cors.exposed-headers(#application-properties.web.spring.graphql.cors.exposed-headers) Comma-separated list of headers to include in a response. () spring.graphql.cors.max-age(#application-properties.web.spring.graphql.cors.max-age) How long the response from a pre-flight request can be cached by clients. If a duration suffix is not specified, seconds will be used. 1800s () spring.graphql.graphiql.enabled(#application-properties.web.spring.graphql.graphiql.enabled) Whether the default GraphiQL UI is enabled. false () spring.graphql.graphiql.path(#application-properties.web.spring.graphql.graphiql.path) Path to the GraphiQL UI endpoint. /graphiql () spring.graphql.path(#application-properties.web.spring.graphql.path) Path at which to expose a GraphQL request HTTP endpoint. /graphql () spring.graphql.rsocket.mapping(#application-properties.web.spring.graphql.rsocket.mapping) Mapping of the RSocket message handler. () spring.graphql.schema.file-extensions(#application-properties.web.spring.graphql.schema.file-extensions) File extensions for GraphQL schema files. .graphqls,.gqls () spring.graphql.schema.inspection.enabled(#application-properties.web.spring.graphql.schema.inspection.enabled) Whether schema should be compared to the application to detect missing mappings. true () spring.graphql.schema.introspection.enabled(#application-properties.web.spring.graphql.schema.introspection.enabled) Whether field introspection should be enabled at the schema level. true () spring.graphql.schema.locations(#application-properties.web.spring.graphql.schema.locations) Locations of GraphQL schema files. classpath:graphql/**/ () spring.graphql.schema.printer.enabled(#application-properties.web.spring.graphql.schema.printer.enabled) Whether the endpoint that prints the schema is enabled. Schema is available under spring.graphql.path + ""/schema"". false () spring.graphql.websocket.connection-init-timeout(#application-properties.web.spring.graphql.websocket.connection-init-timeout) Time within which the initial {@code CONNECTION_INIT} type message must be received. 60s () spring.graphql.websocket.keep-alive(#application-properties.web.spring.graphql.websocket.keep-alive) Maximum idle period before a server keep-alive ping is sent to client. () spring.graphql.websocket.path(#application-properties.web.spring.graphql.websocket.path) Path of the GraphQL WebSocket subscription endpoint. () spring.hateoas.use-hal-as-default-json-media-type(#application-properties.web.spring.hateoas.use-hal-as-default-json-media-type) Whether application/hal+json responses should be sent to requests that accept application/json. true () spring.jersey.application-path(#application-properties.web.spring.jersey.application-path) Path that serves as the base URI for the application. If specified, overrides the value of ""@ApplicationPath"". () spring.jersey.filter.order(#application-properties.web.spring.jersey.filter.order) Jersey filter chain order. 0 () spring.jersey.init.*(#application-properties.web.spring.jersey.init) Init parameters to pass to Jersey through the servlet or filter. () spring.jersey.servlet.load-on-startup(#application-properties.web.spring.jersey.servlet.load-on-startup) Load on startup priority of the Jersey servlet. -1 () spring.jersey.type(#application-properties.web.spring.jersey.type) Jersey integration type. servlet () spring.mvc.async.request-timeout(#application-properties.web.spring.mvc.async.request-timeout) Amount of time before asynchronous request handling times out. If this value is not set, the default timeout of the underlying implementation is used. () spring.mvc.contentnegotiation.favor-parameter(#application-properties.web.spring.mvc.contentnegotiation.favor-parameter) Whether a request parameter (""format"" by default) should be used to determine the requested media type. false () spring.mvc.contentnegotiation.media-types.*(#application-properties.web.spring.mvc.contentnegotiation.media-types) Map file extensions to media types for content negotiation. For instance, yml to text/yaml. () spring.mvc.contentnegotiation.parameter-name(#application-properties.web.spring.mvc.contentnegotiation.parameter-name) Query parameter name to use when ""favor-parameter"" is enabled. () spring.mvc.converters.preferred-json-mapper(#application-properties.web.spring.mvc.converters.preferred-json-mapper) Preferred JSON mapper to use for HTTP message conversion. By default, auto-detected according to the environment. Supported values are 'jackson', 'gson', and 'jsonb'. When other json mapping libraries (such as kotlinx.serialization) are present, use a custom HttpMessageConverters bean to control the preferred mapper. jackson () spring.mvc.dispatch-options-request(#application-properties.web.spring.mvc.dispatch-options-request) Whether to dispatch OPTIONS requests to the FrameworkServlet doService method. true () spring.mvc.dispatch-trace-request(#application-properties.web.spring.mvc.dispatch-trace-request) Whether to dispatch TRACE requests to the FrameworkServlet doService method. false () spring.mvc.format.date(#application-properties.web.spring.mvc.format.date) Date format to use, for example 'dd/MM/yyyy'. Used for formatting of java.util.Date and java.time.LocalDate. () spring.mvc.format.date-time(#application-properties.web.spring.mvc.format.date-time) Date-time format to use, for example 'yyyy-MM-dd HH:mm:ss'. Used for formatting of java.time's LocalDateTime, OffsetDateTime, and ZonedDateTime. () spring.mvc.format.time(#application-properties.web.spring.mvc.format.time) Time format to use, for example 'HH:mm:ss'. Used for formatting of java.time's LocalTime and OffsetTime. () spring.mvc.formcontent.filter.enabled(#application-properties.web.spring.mvc.formcontent.filter.enabled) Whether to enable Spring's FormContentFilter. true () spring.mvc.hiddenmethod.filter.enabled(#application-properties.web.spring.mvc.hiddenmethod.filter.enabled) Whether to enable Spring's HiddenHttpMethodFilter. false () spring.mvc.log-request-details(#application-properties.web.spring.mvc.log-request-details) Whether logging of (potentially sensitive) request details at DEBUG and TRACE level is allowed. false () spring.mvc.log-resolved-exception(#application-properties.web.spring.mvc.log-resolved-exception) Whether to enable warn logging of exceptions resolved by a ""HandlerExceptionResolver"", except for ""DefaultHandlerExceptionResolver"". false () spring.mvc.message-codes-resolver-format(#application-properties.web.spring.mvc.message-codes-resolver-format) Formatting strategy for message codes. For instance, 'PREFIX_ERROR_CODE'. () spring.mvc.pathmatch.matching-strategy(#application-properties.web.spring.mvc.pathmatch.matching-strategy) Choice of strategy for matching request paths against registered mappings. path-pattern-parser () spring.mvc.problemdetails.enabled(#application-properties.web.spring.mvc.problemdetails.enabled) Whether RFC 9457 Problem Details support should be enabled. false () spring.mvc.publish-request-handled-events(#application-properties.web.spring.mvc.publish-request-handled-events) Whether to publish a ServletRequestHandledEvent at the end of each request. true () spring.mvc.servlet.load-on-startup(#application-properties.web.spring.mvc.servlet.load-on-startup) Load on startup priority of the dispatcher servlet. -1 () spring.mvc.servlet.path(#application-properties.web.spring.mvc.servlet.path) Path of the dispatcher servlet. Setting a custom value for this property is not compatible with the PathPatternParser matching strategy. / () spring.mvc.static-path-pattern(#application-properties.web.spring.mvc.static-path-pattern) Path pattern used for static resources. /** () spring.mvc.view.prefix(#application-properties.web.spring.mvc.view.prefix) Spring MVC view prefix. () spring.mvc.view.suffix(#application-properties.web.spring.mvc.view.suffix) Spring MVC view suffix. () spring.mvc.webjars-path-pattern(#application-properties.web.spring.mvc.webjars-path-pattern) Path pattern used for WebJar assets. /webjars/** () spring.netty.leak-detection(#application-properties.web.spring.netty.leak-detection) Level of leak detection for reference-counted buffers. If not configured via 'ResourceLeakDetector.setLevel' or the 'io.netty.leakDetection.level' system property, default to 'simple'. () spring.servlet.multipart.enabled(#application-properties.web.spring.servlet.multipart.enabled) Whether to enable support of multipart uploads. true () spring.servlet.multipart.file-size-threshold(#application-properties.web.spring.servlet.multipart.file-size-threshold) Threshold after which files are written to disk. 0B () spring.servlet.multipart.location(#application-properties.web.spring.servlet.multipart.location) Intermediate location of uploaded files. () spring.servlet.multipart.max-file-size(#application-properties.web.spring.servlet.multipart.max-file-size) Max file size. 1MB () spring.servlet.multipart.max-request-size(#application-properties.web.spring.servlet.multipart.max-request-size) Max request size. 10MB () spring.servlet.multipart.resolve-lazily(#application-properties.web.spring.servlet.multipart.resolve-lazily) Whether to resolve the multipart request lazily at the time of file or parameter access. false () spring.servlet.multipart.strict-servlet-compliance(#application-properties.web.spring.servlet.multipart.strict-servlet-compliance) Whether to resolve the multipart request strictly complying with the Servlet specification, only to be used for ""multipart/form-data"" requests. false () spring.session.hazelcast.flush-mode(#application-properties.web.spring.session.hazelcast.flush-mode) Sessions flush mode. Determines when session changes are written to the session store. on-save () spring.session.hazelcast.map-name(#application-properties.web.spring.session.hazelcast.map-name) Name of the map used to store sessions. spring:session:sessions () spring.session.hazelcast.save-mode(#application-properties.web.spring.session.hazelcast.save-mode) Sessions save mode. Determines how session changes are tracked and saved to the session store. on-set-attribute () spring.session.jdbc.cleanup-cron(#application-properties.web.spring.session.jdbc.cleanup-cron) Cron expression for expired session cleanup job. 0 * * * * * () spring.session.jdbc.flush-mode(#application-properties.web.spring.session.jdbc.flush-mode) Sessions flush mode. Determines when session changes are written to the session store. on-save () spring.session.jdbc.initialize-schema(#application-properties.web.spring.session.jdbc.initialize-schema) Database schema initialization mode. embedded () spring.session.jdbc.platform(#application-properties.web.spring.session.jdbc.platform) Platform to use in initialization scripts if the @@platform@@ placeholder is used. Auto-detected by default. () spring.session.jdbc.save-mode(#application-properties.web.spring.session.jdbc.save-mode) Sessions save mode. Determines how session changes are tracked and saved to the session store. on-set-attribute () spring.session.jdbc.schema(#application-properties.web.spring.session.jdbc.schema) Path to the SQL file to use to initialize the database schema. classpath:org/springframework/session/jdbc/schema-@@platform@@.sql () spring.session.jdbc.table-name(#application-properties.web.spring.session.jdbc.table-name) Name of the database table used to store sessions. SPRING_SESSION () spring.session.mongodb.collection-name(#application-properties.web.spring.session.mongodb.collection-name) Collection name used to store sessions. sessions () spring.session.redis.cleanup-cron(#application-properties.web.spring.session.redis.cleanup-cron) Cron expression for expired session cleanup job. Only supported when repository-type is set to indexed. 0 * * * * * () spring.session.redis.configure-action(#application-properties.web.spring.session.redis.configure-action) The configure action to apply when no user defined ConfigureRedisAction bean is present. notify-keyspace-events () spring.session.redis.flush-mode(#application-properties.web.spring.session.redis.flush-mode) Sessions flush mode. Determines when session changes are written to the session store. on-save () spring.session.redis.namespace(#application-properties.web.spring.session.redis.namespace) Namespace for keys used to store sessions. spring:session () spring.session.redis.repository-type(#application-properties.web.spring.session.redis.repository-type) Type of Redis session repository to configure. default () spring.session.redis.save-mode(#application-properties.web.spring.session.redis.save-mode) Sessions save mode. Determines how session changes are tracked and saved to the session store. on-set-attribute () spring.session.servlet.filter-dispatcher-types(#application-properties.web.spring.session.servlet.filter-dispatcher-types) Session repository filter dispatcher types. [async, error, request] () spring.session.servlet.filter-order(#application-properties.web.spring.session.servlet.filter-order) Session repository filter order. () spring.session.timeout(#application-properties.web.spring.session.timeout) Session timeout. If a duration suffix is not specified, seconds will be used. () spring.web.locale(#application-properties.web.spring.web.locale) Locale to use. By default, this locale is overridden by the ""Accept-Language"" header. () spring.web.locale-resolver(#application-properties.web.spring.web.locale-resolver) Define how the locale should be resolved. accept-header () spring.web.resources.add-mappings(#application-properties.web.spring.web.resources.add-mappings) Whether to enable default resource handling. true () spring.web.resources.cache.cachecontrol.cache-private(#application-properties.web.spring.web.resources.cache.cachecontrol.cache-private) Indicate that the response message is intended for a single user and must not be stored by a shared cache. () spring.web.resources.cache.cachecontrol.cache-public(#application-properties.web.spring.web.resources.cache.cachecontrol.cache-public) Indicate that any cache may store the response. () spring.web.resources.cache.cachecontrol.max-age(#application-properties.web.spring.web.resources.cache.cachecontrol.max-age) Maximum time the response should be cached, in seconds if no duration suffix is not specified. () spring.web.resources.cache.cachecontrol.must-revalidate(#application-properties.web.spring.web.resources.cache.cachecontrol.must-revalidate) Indicate that once it has become stale, a cache must not use the response without re-validating it with the server. () spring.web.resources.cache.cachecontrol.no-cache(#application-properties.web.spring.web.resources.cache.cachecontrol.no-cache) Indicate that the cached response can be reused only if re-validated with the server. () spring.web.resources.cache.cachecontrol.no-store(#application-properties.web.spring.web.resources.cache.cachecontrol.no-store) Indicate to not cache the response in any case. () spring.web.resources.cache.cachecontrol.no-transform(#application-properties.web.spring.web.resources.cache.cachecontrol.no-transform) Indicate intermediaries (caches and others) that they should not transform the response content. () spring.web.resources.cache.cachecontrol.proxy-revalidate(#application-properties.web.spring.web.resources.cache.cachecontrol.proxy-revalidate) Same meaning as the ""must-revalidate"" directive, except that it does not apply to private caches. () spring.web.resources.cache.cachecontrol.s-max-age(#application-properties.web.spring.web.resources.cache.cachecontrol.s-max-age) Maximum time the response should be cached by shared caches, in seconds if no duration suffix is not specified. () spring.web.resources.cache.cachecontrol.stale-if-error(#application-properties.web.spring.web.resources.cache.cachecontrol.stale-if-error) Maximum time the response may be used when errors are encountered, in seconds if no duration suffix is not specified. () spring.web.resources.cache.cachecontrol.stale-while-revalidate(#application-properties.web.spring.web.resources.cache.cachecontrol.stale-while-revalidate) Maximum time the response can be served after it becomes stale, in seconds if no duration suffix is not specified. () spring.web.resources.cache.period(#application-properties.web.spring.web.resources.cache.period) Cache period for the resources served by the resource handler. If a duration suffix is not specified, seconds will be used. Can be overridden by the 'spring.web.resources.cache.cachecontrol' properties. () spring.web.resources.cache.use-last-modified(#application-properties.web.spring.web.resources.cache.use-last-modified) Whether we should use the ""lastModified"" metadata of the files in HTTP caching headers. true () spring.web.resources.chain.cache(#application-properties.web.spring.web.resources.chain.cache) Whether to enable caching in the Resource chain. true () spring.web.resources.chain.compressed(#application-properties.web.spring.web.resources.chain.compressed) Whether to enable resolution of already compressed resources (gzip, brotli). Checks for a resource name with the '.gz' or '.br' file extensions. false () spring.web.resources.chain.enabled(#application-properties.web.spring.web.resources.chain.enabled) Whether to enable the Spring Resource Handling chain. By default, disabled unless at least one strategy has been enabled. () spring.web.resources.chain.strategy.content.enabled(#application-properties.web.spring.web.resources.chain.strategy.content.enabled) Whether to enable the content Version Strategy. false () spring.web.resources.chain.strategy.content.paths(#application-properties.web.spring.web.resources.chain.strategy.content.paths) Comma-separated list of patterns to apply to the content Version Strategy. [/**] () spring.web.resources.chain.strategy.fixed.enabled(#application-properties.web.spring.web.resources.chain.strategy.fixed.enabled) Whether to enable the fixed Version Strategy. false () spring.web.resources.chain.strategy.fixed.paths(#application-properties.web.spring.web.resources.chain.strategy.fixed.paths) Comma-separated list of patterns to apply to the fixed Version Strategy. [/**] () spring.web.resources.chain.strategy.fixed.version(#application-properties.web.spring.web.resources.chain.strategy.fixed.version) Version string to use for the fixed Version Strategy. () spring.web.resources.static-locations(#application-properties.web.spring.web.resources.static-locations) Locations of static resources. Defaults to classpath:[/META-INF/resources/, /resources/, /static/, /public/]. [classpath:/META-INF/resources/, classpath:/resources/, classpath:/static/, classpath:/public/] () spring.webflux.base-path(#application-properties.web.spring.webflux.base-path) Base path for all web handlers. () spring.webflux.format.date(#application-properties.web.spring.webflux.format.date) Date format to use, for example 'dd/MM/yyyy'. Used for formatting of java.util.Date and java.time.LocalDate. () spring.webflux.format.date-time(#application-properties.web.spring.webflux.format.date-time) Date-time format to use, for example 'yyyy-MM-dd HH:mm:ss'. Used for formatting of java.time's LocalDateTime, OffsetDateTime, and ZonedDateTime. () spring.webflux.format.time(#application-properties.web.spring.webflux.format.time) Time format to use, for example 'HH:mm:ss'. Used for formatting of java.time's LocalTime and OffsetTime. () spring.webflux.hiddenmethod.filter.enabled(#application-properties.web.spring.webflux.hiddenmethod.filter.enabled) Whether to enable Spring's HiddenHttpMethodFilter. false () spring.webflux.multipart.file-storage-directory(#application-properties.web.spring.webflux.multipart.file-storage-directory) Directory used to store file parts larger than 'maxInMemorySize'. Default is a directory named 'spring-multipart' created under the system temporary directory. Ignored when using the PartEvent streaming support. () spring.webflux.multipart.headers-charset(#application-properties.web.spring.webflux.multipart.headers-charset) Character set used to decode headers. UTF-8 () spring.webflux.multipart.max-disk-usage-per-part(#application-properties.web.spring.webflux.multipart.max-disk-usage-per-part) Maximum amount of disk space allowed per part. Default is -1 which enforces no limits. -1B () spring.webflux.multipart.max-headers-size(#application-properties.web.spring.webflux.multipart.max-headers-size) Maximum amount of memory allowed per headers section of each part. Set to -1 to enforce no limits. 10KB () spring.webflux.multipart.max-in-memory-size(#application-properties.web.spring.webflux.multipart.max-in-memory-size) Maximum amount of memory allowed per part before it's written to disk. Set to -1 to store all contents in memory. 256KB () spring.webflux.multipart.max-parts(#application-properties.web.spring.webflux.multipart.max-parts) Maximum number of parts allowed in a given multipart request. Default is -1 which enforces no limits. -1 () spring.webflux.problemdetails.enabled(#application-properties.web.spring.webflux.problemdetails.enabled) Whether RFC 9457 Problem Details support should be enabled. false () spring.webflux.static-path-pattern(#application-properties.web.spring.webflux.static-path-pattern) Path pattern used for static resources. /** () spring.webflux.webjars-path-pattern(#application-properties.web.spring.webflux.webjars-path-pattern) Path pattern used for WebJar assets. /webjars/** Templating Properties: Name Description Default Value () spring.freemarker.allow-request-override(#application-properties.templating.spring.freemarker.allow-request-override) Whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name. false () spring.freemarker.allow-session-override(#application-properties.templating.spring.freemarker.allow-session-override) Whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name. false () spring.freemarker.cache(#application-properties.templating.spring.freemarker.cache) Whether to enable template caching. false () spring.freemarker.charset(#application-properties.templating.spring.freemarker.charset) Template encoding. UTF-8 () spring.freemarker.check-template-location(#application-properties.templating.spring.freemarker.check-template-location) Whether to check that the templates location exists. true () spring.freemarker.content-type(#application-properties.templating.spring.freemarker.content-type) Content-Type value. text/html () spring.freemarker.enabled(#application-properties.templating.spring.freemarker.enabled) Whether to enable MVC view resolution for this technology. true () spring.freemarker.expose-request-attributes(#application-properties.templating.spring.freemarker.expose-request-attributes) Whether all request attributes should be added to the model prior to merging with the template. false () spring.freemarker.expose-session-attributes(#application-properties.templating.spring.freemarker.expose-session-attributes) Whether all HttpSession attributes should be added to the model prior to merging with the template. false () spring.freemarker.expose-spring-macro-helpers(#application-properties.templating.spring.freemarker.expose-spring-macro-helpers) Whether to expose a RequestContext for use by Spring's macro library, under the name ""springMacroRequestContext"". true () spring.freemarker.prefer-file-system-access(#application-properties.templating.spring.freemarker.prefer-file-system-access) Whether to prefer file system access for template loading to enable hot detection of template changes. When a template path is detected as a directory, templates are loaded from the directory only and other matching classpath locations will not be considered. false () spring.freemarker.prefix(#application-properties.templating.spring.freemarker.prefix) Prefix that gets prepended to view names when building a URL. () spring.freemarker.request-context-attribute(#application-properties.templating.spring.freemarker.request-context-attribute) Name of the RequestContext attribute for all views. () spring.freemarker.settings.*(#application-properties.templating.spring.freemarker.settings) Well-known FreeMarker keys which are passed to FreeMarker's Configuration. () spring.freemarker.suffix(#application-properties.templating.spring.freemarker.suffix) Suffix that gets appended to view names when building a URL. .ftlh () spring.freemarker.template-loader-path(#application-properties.templating.spring.freemarker.template-loader-path) Comma-separated list of template paths. [classpath:/templates/] () spring.freemarker.view-names(#application-properties.templating.spring.freemarker.view-names) View names that can be resolved. () spring.groovy.template.allow-request-override(#application-properties.templating.spring.groovy.template.allow-request-override) Whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name. false () spring.groovy.template.allow-session-override(#application-properties.templating.spring.groovy.template.allow-session-override) Whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name. false () spring.groovy.template.cache(#application-properties.templating.spring.groovy.template.cache) Whether to enable template caching. false () spring.groovy.template.charset(#application-properties.templating.spring.groovy.template.charset) Template encoding. UTF-8 () spring.groovy.template.check-template-location(#application-properties.templating.spring.groovy.template.check-template-location) Whether to check that the templates location exists. true () spring.groovy.template.configuration.auto-escape spring.groovy.template.configuration.auto-indent spring.groovy.template.configuration.auto-indent-string spring.groovy.template.configuration.auto-new-line spring.groovy.template.configuration.base-template-class spring.groovy.template.configuration.cache-templates spring.groovy.template.configuration.declaration-encoding spring.groovy.template.configuration.expand-empty-elements spring.groovy.template.configuration.locale spring.groovy.template.configuration.new-line-string spring.groovy.template.configuration.resource-loader-path spring.groovy.template.configuration.use-double-quotes(#application-properties.templating.spring.groovy.template.configuration) See GroovyMarkupConfigurer () spring.groovy.template.content-type(#application-properties.templating.spring.groovy.template.content-type) Content-Type value. text/html () spring.groovy.template.enabled(#application-properties.templating.spring.groovy.template.enabled) Whether to enable MVC view resolution for this technology. true () spring.groovy.template.expose-request-attributes(#application-properties.templating.spring.groovy.template.expose-request-attributes) Whether all request attributes should be added to the model prior to merging with the template. false () spring.groovy.template.expose-session-attributes(#application-properties.templating.spring.groovy.template.expose-session-attributes) Whether all HttpSession attributes should be added to the model prior to merging with the template. false () spring.groovy.template.expose-spring-macro-helpers(#application-properties.templating.spring.groovy.template.expose-spring-macro-helpers) Whether to expose a RequestContext for use by Spring's macro library, under the name ""springMacroRequestContext"". true () spring.groovy.template.prefix(#application-properties.templating.spring.groovy.template.prefix) Prefix that gets prepended to view names when building a URL. () spring.groovy.template.request-context-attribute(#application-properties.templating.spring.groovy.template.request-context-attribute) Name of the RequestContext attribute for all views. () spring.groovy.template.resource-loader-path(#application-properties.templating.spring.groovy.template.resource-loader-path) Template path. classpath:/templates/ () spring.groovy.template.suffix(#application-properties.templating.spring.groovy.template.suffix) Suffix that gets appended to view names when building a URL. .tpl () spring.groovy.template.view-names(#application-properties.templating.spring.groovy.template.view-names) View names that can be resolved. () spring.mustache.charset(#application-properties.templating.spring.mustache.charset) Template encoding. UTF-8 () spring.mustache.check-template-location(#application-properties.templating.spring.mustache.check-template-location) Whether to check that the templates location exists. true () spring.mustache.enabled(#application-properties.templating.spring.mustache.enabled) Whether to enable MVC view resolution for Mustache. true () spring.mustache.prefix(#application-properties.templating.spring.mustache.prefix) Prefix to apply to template names. classpath:/templates/ () spring.mustache.reactive.media-types(#application-properties.templating.spring.mustache.reactive.media-types) Media types supported by Mustache views. text/html;charset=UTF-8 () spring.mustache.request-context-attribute(#application-properties.templating.spring.mustache.request-context-attribute) Name of the RequestContext attribute for all views. () spring.mustache.servlet.allow-request-override(#application-properties.templating.spring.mustache.servlet.allow-request-override) Whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name. false () spring.mustache.servlet.allow-session-override(#application-properties.templating.spring.mustache.servlet.allow-session-override) Whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name. false () spring.mustache.servlet.cache(#application-properties.templating.spring.mustache.servlet.cache) Whether to enable template caching. false () spring.mustache.servlet.content-type(#application-properties.templating.spring.mustache.servlet.content-type) Content-Type value. () spring.mustache.servlet.expose-request-attributes(#application-properties.templating.spring.mustache.servlet.expose-request-attributes) Whether all request attributes should be added to the model prior to merging with the template. false () spring.mustache.servlet.expose-session-attributes(#application-properties.templating.spring.mustache.servlet.expose-session-attributes) Whether all HttpSession attributes should be added to the model prior to merging with the template. false () spring.mustache.servlet.expose-spring-macro-helpers(#application-properties.templating.spring.mustache.servlet.expose-spring-macro-helpers) Whether to expose a RequestContext for use by Spring's macro library, under the name ""springMacroRequestContext"". true () spring.mustache.suffix(#application-properties.templating.spring.mustache.suffix) Suffix to apply to template names. .mustache () spring.mustache.view-names(#application-properties.templating.spring.mustache.view-names) View names that can be resolved. () spring.thymeleaf.cache(#application-properties.templating.spring.thymeleaf.cache) Whether to enable template caching. true () spring.thymeleaf.check-template(#application-properties.templating.spring.thymeleaf.check-template) Whether to check that the template exists before rendering it. true () spring.thymeleaf.check-template-location(#application-properties.templating.spring.thymeleaf.check-template-location) Whether to check that the templates location exists. true () spring.thymeleaf.enable-spring-el-compiler(#application-properties.templating.spring.thymeleaf.enable-spring-el-compiler) Enable the SpringEL compiler in SpringEL expressions. false () spring.thymeleaf.enabled(#application-properties.templating.spring.thymeleaf.enabled) Whether to enable Thymeleaf view resolution for Web frameworks. true () spring.thymeleaf.encoding(#application-properties.templating.spring.thymeleaf.encoding) Template files encoding. UTF-8 () spring.thymeleaf.excluded-view-names(#application-properties.templating.spring.thymeleaf.excluded-view-names) Comma-separated list of view names (patterns allowed) that should be excluded from resolution. () spring.thymeleaf.mode(#application-properties.templating.spring.thymeleaf.mode) Template mode to be applied to templates. See also Thymeleaf's TemplateMode enum. HTML () spring.thymeleaf.prefix(#application-properties.templating.spring.thymeleaf.prefix) Prefix that gets prepended to view names when building a URL. classpath:/templates/ () spring.thymeleaf.reactive.chunked-mode-view-names(#application-properties.templating.spring.thymeleaf.reactive.chunked-mode-view-names) Comma-separated list of view names (patterns allowed) that should be the only ones executed in CHUNKED mode when a max chunk size is set. () spring.thymeleaf.reactive.full-mode-view-names(#application-properties.templating.spring.thymeleaf.reactive.full-mode-view-names) Comma-separated list of view names (patterns allowed) that should be executed in FULL mode even if a max chunk size is set. () spring.thymeleaf.reactive.max-chunk-size(#application-properties.templating.spring.thymeleaf.reactive.max-chunk-size) Maximum size of data buffers used for writing to the response. Templates will execute in CHUNKED mode by default if this is set. 0B () spring.thymeleaf.reactive.media-types(#application-properties.templating.spring.thymeleaf.reactive.media-types) Media types supported by the view technology. [text/html, application/xhtml+xml, application/xml, text/xml, application/rss+xml, application/atom+xml, application/javascript, application/ecmascript, text/javascript, text/ecmascript, application/json, text/css, text/plain, text/event-stream] () spring.thymeleaf.render-hidden-markers-before-checkboxes(#application-properties.templating.spring.thymeleaf.render-hidden-markers-before-checkboxes) Whether hidden form inputs acting as markers for checkboxes should be rendered before the checkbox element itself. false () spring.thymeleaf.servlet.content-type(#application-properties.templating.spring.thymeleaf.servlet.content-type) Content-Type value written to HTTP responses. text/html () spring.thymeleaf.servlet.produce-partial-output-while-processing(#application-properties.templating.spring.thymeleaf.servlet.produce-partial-output-while-processing) Whether Thymeleaf should start writing partial output as soon as possible or buffer until template processing is finished. true () spring.thymeleaf.suffix(#application-properties.templating.spring.thymeleaf.suffix) Suffix that gets appended to view names when building a URL. .html () spring.thymeleaf.template-resolver-order(#application-properties.templating.spring.thymeleaf.template-resolver-order) Order of the template resolver in the chain. By default, the template resolver is first in the chain. Order start at 1 and should only be set if you have defined additional ""TemplateResolver"" beans. () spring.thymeleaf.view-names(#application-properties.templating.spring.thymeleaf.view-names) Comma-separated list of view names (patterns allowed) that can be resolved. Server Properties: Name Description Default Value () server.address(#application-properties.server.server.address) Network address to which the server should bind. () server.compression.enabled(#application-properties.server.server.compression.enabled) Whether response compression is enabled. false () server.compression.excluded-user-agents(#application-properties.server.server.compression.excluded-user-agents) Comma-separated list of user agents for which responses should not be compressed. () server.compression.mime-types(#application-properties.server.server.compression.mime-types) Comma-separated list of MIME types that should be compressed. [text/html, text/xml, text/plain, text/css, text/javascript, application/javascript, application/json, application/xml] () server.compression.min-response-size(#application-properties.server.server.compression.min-response-size) Minimum ""Content-Length"" value that is required for compression to be performed. 2KB () server.error.include-binding-errors(#application-properties.server.server.error.include-binding-errors) When to include ""errors"" attribute. never () server.error.include-exception(#application-properties.server.server.error.include-exception) Include the ""exception"" attribute. false () server.error.include-message(#application-properties.server.server.error.include-message) When to include ""message"" attribute. never () server.error.include-path(#application-properties.server.server.error.include-path) When to include ""path"" attribute. always () server.error.include-stacktrace(#application-properties.server.server.error.include-stacktrace) When to include the ""trace"" attribute. never () server.error.path(#application-properties.server.server.error.path) Path of the error controller. /error () server.error.whitelabel.enabled(#application-properties.server.server.error.whitelabel.enabled) Whether to enable the default error page displayed in browsers in case of a server error. true () server.forward-headers-strategy(#application-properties.server.server.forward-headers-strategy) Strategy for handling X-Forwarded-* headers. () server.http2.enabled(#application-properties.server.server.http2.enabled) Whether to enable HTTP/2 support, if the current environment supports it. false () server.jetty.accesslog.append(#application-properties.server.server.jetty.accesslog.append) Append to log. false () server.jetty.accesslog.custom-format(#application-properties.server.server.jetty.accesslog.custom-format) Custom log format, see org.eclipse.jetty.server.CustomRequestLog. If defined, overrides the ""format"" configuration key. () server.jetty.accesslog.enabled(#application-properties.server.server.jetty.accesslog.enabled) Enable access log. false () server.jetty.accesslog.file-date-format(#application-properties.server.server.jetty.accesslog.file-date-format) Date format to place in log file name. () server.jetty.accesslog.filename(#application-properties.server.server.jetty.accesslog.filename) Log filename. If not specified, logs redirect to ""System.err"". () server.jetty.accesslog.format(#application-properties.server.server.jetty.accesslog.format) Log format. ncsa () server.jetty.accesslog.ignore-paths(#application-properties.server.server.jetty.accesslog.ignore-paths) Request paths that should not be logged. () server.jetty.accesslog.retention-period(#application-properties.server.server.jetty.accesslog.retention-period) Number of days before rotated log files are deleted. 31 () server.jetty.connection-idle-timeout(#application-properties.server.server.jetty.connection-idle-timeout) Time that the connection can be idle before it is closed. () server.jetty.max-connections(#application-properties.server.server.jetty.max-connections) Maximum number of connections that the server accepts and processes at any given time. -1 () server.jetty.max-http-form-post-size(#application-properties.server.server.jetty.max-http-form-post-size) Maximum size of the form content in any HTTP post request. 200000B () server.jetty.max-http-response-header-size(#application-properties.server.server.jetty.max-http-response-header-size) Maximum size of the HTTP response header. 8KB () server.jetty.threads.acceptors(#application-properties.server.server.jetty.threads.acceptors) Number of acceptor threads to use. When the value is -1, the default, the number of acceptors is derived from the operating environment. -1 () server.jetty.threads.idle-timeout(#application-properties.server.server.jetty.threads.idle-timeout) Maximum thread idle time. 60000ms () server.jetty.threads.max(#application-properties.server.server.jetty.threads.max) Maximum number of threads. Doesn't have an effect if virtual threads are enabled. 200 () server.jetty.threads.max-queue-capacity(#application-properties.server.server.jetty.threads.max-queue-capacity) Maximum capacity of the thread pool's backing queue. A default is computed based on the threading configuration. () server.jetty.threads.min(#application-properties.server.server.jetty.threads.min) Minimum number of threads. Doesn't have an effect if virtual threads are enabled. 8 () server.jetty.threads.selectors(#application-properties.server.server.jetty.threads.selectors) Number of selector threads to use. When the value is -1, the default, the number of selectors is derived from the operating environment. -1 () server.max-http-request-header-size(#application-properties.server.server.max-http-request-header-size) Maximum size of the HTTP request header. 8KB () server.netty.connection-timeout(#application-properties.server.server.netty.connection-timeout) Connection timeout of the Netty channel. () server.netty.h2c-max-content-length(#application-properties.server.server.netty.h2c-max-content-length) Maximum content length of an H2C upgrade request. 0B () server.netty.idle-timeout(#application-properties.server.server.netty.idle-timeout) Idle timeout of the Netty channel. When not specified, an infinite timeout is used. () server.netty.initial-buffer-size(#application-properties.server.server.netty.initial-buffer-size) Initial buffer size for HTTP request decoding. 128B () server.netty.max-initial-line-length(#application-properties.server.server.netty.max-initial-line-length) Maximum length that can be decoded for an HTTP request's initial line. 4KB () server.netty.max-keep-alive-requests(#application-properties.server.server.netty.max-keep-alive-requests) Maximum number of requests that can be made per connection. By default, a connection serves unlimited number of requests. () server.netty.validate-headers(#application-properties.server.server.netty.validate-headers) Whether to validate headers when decoding requests. true () server.port(#application-properties.server.server.port) Server HTTP port. 8080 () server.reactive.session.cookie.domain(#application-properties.server.server.reactive.session.cookie.domain) Domain for the cookie. () server.reactive.session.cookie.http-only(#application-properties.server.server.reactive.session.cookie.http-only) Whether to use ""HttpOnly"" cookies for the cookie. () server.reactive.session.cookie.max-age(#application-properties.server.server.reactive.session.cookie.max-age) Maximum age of the cookie. If a duration suffix is not specified, seconds will be used. A positive value indicates when the cookie expires relative to the current time. A value of 0 means the cookie should expire immediately. A negative value means no ""Max-Age"". () server.reactive.session.cookie.name(#application-properties.server.server.reactive.session.cookie.name) Name for the cookie. () server.reactive.session.cookie.path(#application-properties.server.server.reactive.session.cookie.path) Path of the cookie. () server.reactive.session.cookie.same-site(#application-properties.server.server.reactive.session.cookie.same-site) SameSite setting for the cookie. () server.reactive.session.cookie.secure(#application-properties.server.server.reactive.session.cookie.secure) Whether to always mark the cookie as secure. () server.reactive.session.max-sessions(#application-properties.server.server.reactive.session.max-sessions) Maximum number of sessions that can be stored. 10000 () server.reactive.session.timeout(#application-properties.server.server.reactive.session.timeout) Session timeout. If a duration suffix is not specified, seconds will be used. 30m () server.server-header(#application-properties.server.server.server-header) Value to use for the Server response header (if empty, no header is sent). () server.servlet.application-display-name(#application-properties.server.server.servlet.application-display-name) Display name of the application. application () server.servlet.context-parameters.*(#application-properties.server.server.servlet.context-parameters) Servlet context init parameters. () server.servlet.context-path(#application-properties.server.server.servlet.context-path) Context path of the application. () server.servlet.encoding.charset(#application-properties.server.server.servlet.encoding.charset) Charset of HTTP requests and responses. Added to the ""Content-Type"" header if not set explicitly. UTF-8 () server.servlet.encoding.enabled(#application-properties.server.server.servlet.encoding.enabled) Whether to enable http encoding support. true () server.servlet.encoding.force(#application-properties.server.server.servlet.encoding.force) Whether to force the encoding to the configured charset on HTTP requests and responses. () server.servlet.encoding.force-request(#application-properties.server.server.servlet.encoding.force-request) Whether to force the encoding to the configured charset on HTTP requests. Defaults to true when ""force"" has not been specified. () server.servlet.encoding.force-response(#application-properties.server.server.servlet.encoding.force-response) Whether to force the encoding to the configured charset on HTTP responses. () server.servlet.encoding.mapping.*(#application-properties.server.server.servlet.encoding.mapping) Mapping of locale to charset for response encoding. () server.servlet.jsp.class-name(#application-properties.server.server.servlet.jsp.class-name) Class name of the servlet to use for JSPs. If registered is true and this class * is on the classpath then it will be registered. org.apache.jasper.servlet.JspServlet () server.servlet.jsp.init-parameters.*(#application-properties.server.server.servlet.jsp.init-parameters) Init parameters used to configure the JSP servlet. () server.servlet.jsp.registered(#application-properties.server.server.servlet.jsp.registered) Whether the JSP servlet is registered. true () server.servlet.register-default-servlet(#application-properties.server.server.servlet.register-default-servlet) Whether to register the default Servlet with the container. false () server.servlet.session.cookie.domain(#application-properties.server.server.servlet.session.cookie.domain) Domain for the cookie. () server.servlet.session.cookie.http-only(#application-properties.server.server.servlet.session.cookie.http-only) Whether to use ""HttpOnly"" cookies for the cookie. () server.servlet.session.cookie.max-age(#application-properties.server.server.servlet.session.cookie.max-age) Maximum age of the cookie. If a duration suffix is not specified, seconds will be used. A positive value indicates when the cookie expires relative to the current time. A value of 0 means the cookie should expire immediately. A negative value means no ""Max-Age"". () server.servlet.session.cookie.name(#application-properties.server.server.servlet.session.cookie.name) Name of the cookie. () server.servlet.session.cookie.path(#application-properties.server.server.servlet.session.cookie.path) Path of the cookie. () server.servlet.session.cookie.same-site(#application-properties.server.server.servlet.session.cookie.same-site) SameSite setting for the cookie. () server.servlet.session.cookie.secure(#application-properties.server.server.servlet.session.cookie.secure) Whether to always mark the cookie as secure. () server.servlet.session.persistent(#application-properties.server.server.servlet.session.persistent) Whether to persist session data between restarts. false () server.servlet.session.store-dir(#application-properties.server.server.servlet.session.store-dir) Directory used to store session data. () server.servlet.session.timeout(#application-properties.server.server.servlet.session.timeout) Session timeout. If a duration suffix is not specified, seconds will be used. 30m () server.servlet.session.tracking-modes(#application-properties.server.server.servlet.session.tracking-modes) Session tracking modes. () server.shutdown(#application-properties.server.server.shutdown) Type of shutdown that the server will support. immediate () server.ssl.bundle(#application-properties.server.server.ssl.bundle) The name of a configured SSL bundle. () server.ssl.certificate(#application-properties.server.server.ssl.certificate) Path to a PEM-encoded SSL certificate file. () server.ssl.certificate-private-key(#application-properties.server.server.ssl.certificate-private-key) Path to a PEM-encoded private key file for the SSL certificate. () server.ssl.ciphers(#application-properties.server.server.ssl.ciphers) Supported SSL ciphers. () server.ssl.client-auth(#application-properties.server.server.ssl.client-auth) Client authentication mode. Requires a trust store. () server.ssl.enabled(#application-properties.server.server.ssl.enabled) Whether to enable SSL support. true () server.ssl.enabled-protocols(#application-properties.server.server.ssl.enabled-protocols) Enabled SSL protocols. () server.ssl.key-alias(#application-properties.server.server.ssl.key-alias) Alias that identifies the key in the key store. () server.ssl.key-password(#application-properties.server.server.ssl.key-password) Password used to access the key in the key store. () server.ssl.key-store(#application-properties.server.server.ssl.key-store) Path to the key store that holds the SSL certificate (typically a jks file). () server.ssl.key-store-password(#application-properties.server.server.ssl.key-store-password) Password used to access the key store. () server.ssl.key-store-provider(#application-properties.server.server.ssl.key-store-provider) Provider for the key store. () server.ssl.key-store-type(#application-properties.server.server.ssl.key-store-type) Type of the key store. () server.ssl.protocol(#application-properties.server.server.ssl.protocol) SSL protocol to use. TLS () server.ssl.server-name-bundles(#application-properties.server.server.ssl.server-name-bundles) Mapping of host names to SSL bundles for SNI configuration. () server.ssl.trust-certificate(#application-properties.server.server.ssl.trust-certificate) Path to a PEM-encoded SSL certificate authority file. () server.ssl.trust-certificate-private-key(#application-properties.server.server.ssl.trust-certificate-private-key) Path to a PEM-encoded private key file for the SSL certificate authority. () server.ssl.trust-store(#application-properties.server.server.ssl.trust-store) Trust store that holds SSL certificates. () server.ssl.trust-store-password(#application-properties.server.server.ssl.trust-store-password) Password used to access the trust store. () server.ssl.trust-store-provider(#application-properties.server.server.ssl.trust-store-provider) Provider for the trust store. () server.ssl.trust-store-type(#application-properties.server.server.ssl.trust-store-type) Type of the trust store. () server.tomcat.accept-count(#application-properties.server.server.tomcat.accept-count) Maximum queue length for incoming connection requests when all possible request processing threads are in use. 100 () server.tomcat.accesslog.buffered(#application-properties.server.server.tomcat.accesslog.buffered) Whether to buffer output such that it is flushed only periodically. true () server.tomcat.accesslog.check-exists(#application-properties.server.server.tomcat.accesslog.check-exists) Whether to check for log file existence so it can be recreated if an external process has renamed it. false () server.tomcat.accesslog.condition-if(#application-properties.server.server.tomcat.accesslog.condition-if) Whether logging of the request will only be enabled if ""ServletRequest.getAttribute(conditionIf)"" does not yield null. () server.tomcat.accesslog.condition-unless(#application-properties.server.server.tomcat.accesslog.condition-unless) Whether logging of the request will only be enabled if ""ServletRequest.getAttribute(conditionUnless)"" yield null. () server.tomcat.accesslog.directory(#application-properties.server.server.tomcat.accesslog.directory) Directory in which log files are created. Can be absolute or relative to the Tomcat base dir. logs () server.tomcat.accesslog.enabled(#application-properties.server.server.tomcat.accesslog.enabled) Enable access log. false () server.tomcat.accesslog.encoding(#application-properties.server.server.tomcat.accesslog.encoding) Character set used by the log file. Default to the system default character set. () server.tomcat.accesslog.file-date-format(#application-properties.server.server.tomcat.accesslog.file-date-format) Date format to place in the log file name. .yyyy-MM-dd () server.tomcat.accesslog.ipv6-canonical(#application-properties.server.server.tomcat.accesslog.ipv6-canonical) Whether to use IPv6 canonical representation format as defined by RFC 5952. false () server.tomcat.accesslog.locale(#application-properties.server.server.tomcat.accesslog.locale) Locale used to format timestamps in log entries and in log file name suffix. Default to the default locale of the Java process. () server.tomcat.accesslog.max-days(#application-properties.server.server.tomcat.accesslog.max-days) Number of days to retain the access log files before they are removed. -1 () server.tomcat.accesslog.pattern(#application-properties.server.server.tomcat.accesslog.pattern) Format pattern for access logs. common () server.tomcat.accesslog.prefix(#application-properties.server.server.tomcat.accesslog.prefix) Log file name prefix. access_log () server.tomcat.accesslog.rename-on-rotate(#application-properties.server.server.tomcat.accesslog.rename-on-rotate) Whether to defer inclusion of the date stamp in the file name until rotate time. false () server.tomcat.accesslog.request-attributes-enabled(#application-properties.server.server.tomcat.accesslog.request-attributes-enabled) Set request attributes for the IP address, Hostname, protocol, and port used for the request. false () server.tomcat.accesslog.rotate(#application-properties.server.server.tomcat.accesslog.rotate) Whether to enable access log rotation. true () server.tomcat.accesslog.suffix(#application-properties.server.server.tomcat.accesslog.suffix) Log file name suffix. .log () server.tomcat.additional-tld-skip-patterns(#application-properties.server.server.tomcat.additional-tld-skip-patterns) Comma-separated list of additional patterns that match jars to ignore for TLD scanning. The special '?' and '*' characters can be used in the pattern to match one and only one character and zero or more characters respectively. () server.tomcat.background-processor-delay(#application-properties.server.server.tomcat.background-processor-delay) Delay between the invocation of backgroundProcess methods. If a duration suffix is not specified, seconds will be used. 10s () server.tomcat.basedir(#application-properties.server.server.tomcat.basedir) Tomcat base directory. If not specified, a temporary directory is used. () server.tomcat.connection-timeout(#application-properties.server.server.tomcat.connection-timeout) Amount of time the connector will wait, after accepting a connection, for the request URI line to be presented. () server.tomcat.keep-alive-timeout(#application-properties.server.server.tomcat.keep-alive-timeout) Time to wait for another HTTP request before the connection is closed. When not set the connectionTimeout is used. When set to -1 there will be no timeout. () server.tomcat.max-connections(#application-properties.server.server.tomcat.max-connections) Maximum number of connections that the server accepts and processes at any given time. Once the limit has been reached, the operating system may still accept connections based on the ""acceptCount"" property. 8192 () server.tomcat.max-http-form-post-size(#application-properties.server.server.tomcat.max-http-form-post-size) Maximum size of the form content in any HTTP post request. 2MB () server.tomcat.max-http-response-header-size(#application-properties.server.server.tomcat.max-http-response-header-size) Maximum size of the HTTP response header. 8KB () server.tomcat.max-keep-alive-requests(#application-properties.server.server.tomcat.max-keep-alive-requests) Maximum number of HTTP requests that can be pipelined before the connection is closed. When set to 0 or 1, keep-alive and pipelining are disabled. When set to -1, an unlimited number of pipelined or keep-alive requests are allowed. 100 () server.tomcat.max-swallow-size(#application-properties.server.server.tomcat.max-swallow-size) Maximum amount of request body to swallow. 2MB () server.tomcat.mbeanregistry.enabled(#application-properties.server.server.tomcat.mbeanregistry.enabled) Whether Tomcat's MBean Registry should be enabled. false () server.tomcat.processor-cache(#application-properties.server.server.tomcat.processor-cache) Maximum number of idle processors that will be retained in the cache and reused with a subsequent request. When set to -1 the cache will be unlimited with a theoretical maximum size equal to the maximum number of connections. 200 () server.tomcat.redirect-context-root(#application-properties.server.server.tomcat.redirect-context-root) Whether requests to the context root should be redirected by appending a / to the path. When using SSL terminated at a proxy, this property should be set to false. true () server.tomcat.relaxed-path-chars(#application-properties.server.server.tomcat.relaxed-path-chars) Comma-separated list of additional unencoded characters that should be allowed in URI paths. Only ""< > [ \ ] ^ ` { | }"" are allowed. () server.tomcat.relaxed-query-chars(#application-properties.server.server.tomcat.relaxed-query-chars) Comma-separated list of additional unencoded characters that should be allowed in URI query strings. Only ""< > [ \ ] ^ ` { | }"" are allowed. () server.tomcat.remoteip.host-header(#application-properties.server.server.tomcat.remoteip.host-header) Name of the HTTP header from which the remote host is extracted. X-Forwarded-Host () server.tomcat.remoteip.internal-proxies(#application-properties.server.server.tomcat.remoteip.internal-proxies) Regular expression that matches proxies that are to be trusted. 10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|192\\.168\\.\\d{1,3}\\.\\d{1,3}|169\\.254\\.\\d{1,3}\\.\\d{1,3}|127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|100\\.6[4-9]{1}\\.\\d{1,3}\\.\\d{1,3}|100\\.[7-9]{1}\\d{1}\\.\\d{1,3}\\.\\d{1,3}|100\\.1[0-1]{1}\\d{1}\\.\\d{1,3}\\.\\d{1,3}|100\\.12[0-7]{1}\\.\\d{1,3}\\.\\d{1,3}|172\\.1[6-9]{1}\\.\\d{1,3}\\.\\d{1,3}|172\\.2[0-9]{1}\\.\\d{1,3}\\.\\d{1,3}|172\\.3[0-1]{1}\\.\\d{1,3}\\.\\d{1,3}|0:0:0:0:0:0:0:1|::1 () server.tomcat.remoteip.port-header(#application-properties.server.server.tomcat.remoteip.port-header) Name of the HTTP header used to override the original port value. X-Forwarded-Port () server.tomcat.remoteip.protocol-header(#application-properties.server.server.tomcat.remoteip.protocol-header) Header that holds the incoming protocol, usually named ""X-Forwarded-Proto"". () server.tomcat.remoteip.protocol-header-https-value(#application-properties.server.server.tomcat.remoteip.protocol-header-https-value) Value of the protocol header indicating whether the incoming request uses SSL. https () server.tomcat.remoteip.remote-ip-header(#application-properties.server.server.tomcat.remoteip.remote-ip-header) Name of the HTTP header from which the remote IP is extracted. For instance, 'X-FORWARDED-FOR'. () server.tomcat.remoteip.trusted-proxies(#application-properties.server.server.tomcat.remoteip.trusted-proxies) Regular expression defining proxies that are trusted when they appear in the ""remote-ip-header"" header. () server.tomcat.resource.allow-caching(#application-properties.server.server.tomcat.resource.allow-caching) Whether static resource caching is permitted for this web application. true () server.tomcat.resource.cache-ttl(#application-properties.server.server.tomcat.resource.cache-ttl) Time-to-live of the static resource cache. () server.tomcat.threads.max(#application-properties.server.server.tomcat.threads.max) Maximum amount of worker threads. Doesn't have an effect if virtual threads are enabled. 200 () server.tomcat.threads.max-queue-capacity(#application-properties.server.server.tomcat.threads.max-queue-capacity) Maximum capacity of the thread pool's backing queue. 2147483647 () server.tomcat.threads.min-spare(#application-properties.server.server.tomcat.threads.min-spare) Minimum amount of worker threads. Doesn't have an effect if virtual threads are enabled. 10 () server.tomcat.uri-encoding(#application-properties.server.server.tomcat.uri-encoding) Character encoding to use to decode the URI. UTF-8 () server.tomcat.use-relative-redirects(#application-properties.server.server.tomcat.use-relative-redirects) Whether HTTP 1.1 and later location headers generated by a call to sendRedirect will use relative or absolute redirects. false () server.undertow.accesslog.dir(#application-properties.server.server.undertow.accesslog.dir) Undertow access log directory. () server.undertow.accesslog.enabled(#application-properties.server.server.undertow.accesslog.enabled) Whether to enable the access log. false () server.undertow.accesslog.pattern(#application-properties.server.server.undertow.accesslog.pattern) Format pattern for access logs. common () server.undertow.accesslog.prefix(#application-properties.server.server.undertow.accesslog.prefix) Log file name prefix. access_log. () server.undertow.accesslog.rotate(#application-properties.server.server.undertow.accesslog.rotate) Whether to enable access log rotation. true () server.undertow.accesslog.suffix(#application-properties.server.server.undertow.accesslog.suffix) Log file name suffix. log () server.undertow.always-set-keep-alive(#application-properties.server.server.undertow.always-set-keep-alive) Whether the 'Connection: keep-alive' header should be added to all responses, even if not required by the HTTP specification. true () server.undertow.buffer-size(#application-properties.server.server.undertow.buffer-size) Size of each buffer. The default is derived from the maximum amount of memory that is available to the JVM. () server.undertow.decode-slash(#application-properties.server.server.undertow.decode-slash) Whether encoded slash characters (%2F) should be decoded. Decoding can cause security problems if a front-end proxy does not perform the same decoding. Only enable this if you have a legacy application that requires it. When set, server.undertow.allow-encoded-slash has no effect. () server.undertow.decode-url(#application-properties.server.server.undertow.decode-url) Whether the URL should be decoded. When disabled, percent-encoded characters in the URL will be left as-is. true () server.undertow.direct-buffers(#application-properties.server.server.undertow.direct-buffers) Whether to allocate buffers outside the Java heap. The default is derived from the maximum amount of memory that is available to the JVM. () server.undertow.eager-filter-init(#application-properties.server.server.undertow.eager-filter-init) Whether servlet filters should be initialized on startup. true () server.undertow.max-cookies(#application-properties.server.server.undertow.max-cookies) Maximum number of cookies that are allowed. This limit exists to prevent hash collision based DOS attacks. 200 () server.undertow.max-headers(#application-properties.server.server.undertow.max-headers) Maximum number of headers that are allowed. This limit exists to prevent hash collision based DOS attacks. () server.undertow.max-http-post-size(#application-properties.server.server.undertow.max-http-post-size) Maximum size of the HTTP post content. When the value is -1, the default, the size is unlimited. -1B () server.undertow.max-parameters(#application-properties.server.server.undertow.max-parameters) Maximum number of query or path parameters that are allowed. This limit exists to prevent hash collision based DOS attacks. () server.undertow.no-request-timeout(#application-properties.server.server.undertow.no-request-timeout) Amount of time a connection can sit idle without processing a request, before it is closed by the server. () server.undertow.options.server.*(#application-properties.server.server.undertow.options.server) Server options as defined in io.undertow.UndertowOptions. () server.undertow.options.socket.*(#application-properties.server.server.undertow.options.socket) Socket options as defined in org.xnio.Options. () server.undertow.preserve-path-on-forward(#application-properties.server.server.undertow.preserve-path-on-forward) Whether to preserve the path of a request when it is forwarded. false () server.undertow.threads.io(#application-properties.server.server.undertow.threads.io) Number of I/O threads to create for the worker. The default is derived from the number of available processors. () server.undertow.threads.worker(#application-properties.server.server.undertow.threads.worker) Number of worker threads. The default is 8 times the number of I/O threads. () server.undertow.url-charset(#application-properties.server.server.undertow.url-charset) Charset used to decode URLs. UTF-8 Security Properties: Name Description Default Value () spring.security.filter.dispatcher-types(#application-properties.security.spring.security.filter.dispatcher-types) Security filter chain dispatcher types for Servlet-based web applications. [async, error, forward, include, request] () spring.security.filter.order(#application-properties.security.spring.security.filter.order) Security filter chain order for Servlet-based web applications. -100 () spring.security.oauth2.authorizationserver.client.*(#application-properties.security.spring.security.oauth2.authorizationserver.client) Registered clients of the Authorization Server. () spring.security.oauth2.authorizationserver.endpoint.authorization-uri(#application-properties.security.spring.security.oauth2.authorizationserver.endpoint.authorization-uri) Authorization Server's OAuth 2.0 Authorization Endpoint. /oauth2/authorize () spring.security.oauth2.authorizationserver.endpoint.device-authorization-uri(#application-properties.security.spring.security.oauth2.authorizationserver.endpoint.device-authorization-uri) Authorization Server's OAuth 2.0 Device Authorization Endpoint. /oauth2/device_authorization () spring.security.oauth2.authorizationserver.endpoint.device-verification-uri(#application-properties.security.spring.security.oauth2.authorizationserver.endpoint.device-verification-uri) Authorization Server's OAuth 2.0 Device Verification Endpoint. /oauth2/device_verification () spring.security.oauth2.authorizationserver.endpoint.jwk-set-uri(#application-properties.security.spring.security.oauth2.authorizationserver.endpoint.jwk-set-uri) Authorization Server's JWK Set Endpoint. /oauth2/jwks () spring.security.oauth2.authorizationserver.endpoint.oidc.client-registration-uri(#application-properties.security.spring.security.oauth2.authorizationserver.endpoint.oidc.client-registration-uri) Authorization Server's OpenID Connect 1.0 Client Registration Endpoint. /connect/register () spring.security.oauth2.authorizationserver.endpoint.oidc.logout-uri(#application-properties.security.spring.security.oauth2.authorizationserver.endpoint.oidc.logout-uri) Authorization Server's OpenID Connect 1.0 Logout Endpoint. /connect/logout () spring.security.oauth2.authorizationserver.endpoint.oidc.user-info-uri(#application-properties.security.spring.security.oauth2.authorizationserver.endpoint.oidc.user-info-uri) Authorization Server's OpenID Connect 1.0 UserInfo Endpoint. /userinfo () spring.security.oauth2.authorizationserver.endpoint.token-introspection-uri(#application-properties.security.spring.security.oauth2.authorizationserver.endpoint.token-introspection-uri) Authorization Server's OAuth 2.0 Token Introspection Endpoint. /oauth2/introspect () spring.security.oauth2.authorizationserver.endpoint.token-revocation-uri(#application-properties.security.spring.security.oauth2.authorizationserver.endpoint.token-revocation-uri) Authorization Server's OAuth 2.0 Token Revocation Endpoint. /oauth2/revoke () spring.security.oauth2.authorizationserver.endpoint.token-uri(#application-properties.security.spring.security.oauth2.authorizationserver.endpoint.token-uri) Authorization Server's OAuth 2.0 Token Endpoint. /oauth2/token () spring.security.oauth2.authorizationserver.issuer(#application-properties.security.spring.security.oauth2.authorizationserver.issuer) URL of the Authorization Server's Issuer Identifier. () spring.security.oauth2.authorizationserver.multiple-issuers-allowed(#application-properties.security.spring.security.oauth2.authorizationserver.multiple-issuers-allowed) Whether multiple issuers are allowed per host. Using path components in the URL of the issuer identifier enables supporting multiple issuers per host in a multi-tenant hosting configuration. false () spring.security.oauth2.client.provider.*(#application-properties.security.spring.security.oauth2.client.provider) OAuth provider details. () spring.security.oauth2.client.registration.*(#application-properties.security.spring.security.oauth2.client.registration) OAuth client registrations. () spring.security.oauth2.resourceserver.jwt.audiences(#application-properties.security.spring.security.oauth2.resourceserver.jwt.audiences) Identifies the recipients that the JWT is intended for. () spring.security.oauth2.resourceserver.jwt.authorities-claim-delimiter(#application-properties.security.spring.security.oauth2.resourceserver.jwt.authorities-claim-delimiter) Regex to use for splitting the value of the authorities claim into authorities. () spring.security.oauth2.resourceserver.jwt.authorities-claim-name(#application-properties.security.spring.security.oauth2.resourceserver.jwt.authorities-claim-name) Name of token claim to use for mapping authorities from JWT. () spring.security.oauth2.resourceserver.jwt.authority-prefix(#application-properties.security.spring.security.oauth2.resourceserver.jwt.authority-prefix) Prefix to use for authorities mapped from JWT. () spring.security.oauth2.resourceserver.jwt.issuer-uri(#application-properties.security.spring.security.oauth2.resourceserver.jwt.issuer-uri) URI that can either be an OpenID Connect discovery endpoint or an OAuth 2.0 Authorization Server Metadata endpoint defined by RFC 8414. () spring.security.oauth2.resourceserver.jwt.jwk-set-uri(#application-properties.security.spring.security.oauth2.resourceserver.jwt.jwk-set-uri) JSON Web Key URI to use to verify the JWT token. () spring.security.oauth2.resourceserver.jwt.jws-algorithms(#application-properties.security.spring.security.oauth2.resourceserver.jwt.jws-algorithms) JSON Web Algorithms used for verifying the digital signatures. RS256 () spring.security.oauth2.resourceserver.jwt.principal-claim-name(#application-properties.security.spring.security.oauth2.resourceserver.jwt.principal-claim-name) JWT principal claim name. () spring.security.oauth2.resourceserver.jwt.public-key-location(#application-properties.security.spring.security.oauth2.resourceserver.jwt.public-key-location) Location of the file containing the public key used to verify a JWT. () spring.security.oauth2.resourceserver.opaquetoken.client-id(#application-properties.security.spring.security.oauth2.resourceserver.opaquetoken.client-id) Client id used to authenticate with the token introspection endpoint. () spring.security.oauth2.resourceserver.opaquetoken.client-secret(#application-properties.security.spring.security.oauth2.resourceserver.opaquetoken.client-secret) Client secret used to authenticate with the token introspection endpoint. () spring.security.oauth2.resourceserver.opaquetoken.introspection-uri(#application-properties.security.spring.security.oauth2.resourceserver.opaquetoken.introspection-uri) OAuth 2.0 endpoint through which token introspection is accomplished. () spring.security.saml2.relyingparty.registration.*(#application-properties.security.spring.security.saml2.relyingparty.registration) SAML2 relying party registrations. () spring.security.user.name(#application-properties.security.spring.security.user.name) Default user name. user () spring.security.user.password(#application-properties.security.spring.security.user.password) Password for the default user name. () spring.security.user.roles(#application-properties.security.spring.security.user.roles) Granted roles for the default user name. RSocket Properties: Name Description Default Value () spring.rsocket.server.address(#application-properties.rsocket.spring.rsocket.server.address) Network address to which the server should bind. () spring.rsocket.server.fragment-size(#application-properties.rsocket.spring.rsocket.server.fragment-size) Maximum transmission unit. Frames larger than the specified value are fragmented. () spring.rsocket.server.mapping-path(#application-properties.rsocket.spring.rsocket.server.mapping-path) Path under which RSocket handles requests (only works with websocket transport). () spring.rsocket.server.port(#application-properties.rsocket.spring.rsocket.server.port) Server port. () spring.rsocket.server.spec.compress(#application-properties.rsocket.spring.rsocket.server.spec.compress) Whether the websocket compression extension is enabled. false () spring.rsocket.server.spec.handle-ping(#application-properties.rsocket.spring.rsocket.server.spec.handle-ping) Whether to proxy websocket ping frames or respond to them. false () spring.rsocket.server.spec.max-frame-payload-length(#application-properties.rsocket.spring.rsocket.server.spec.max-frame-payload-length) Maximum allowable frame payload length. 65536B () spring.rsocket.server.spec.protocols(#application-properties.rsocket.spring.rsocket.server.spec.protocols) Sub-protocols to use in websocket handshake signature. () spring.rsocket.server.ssl.bundle(#application-properties.rsocket.spring.rsocket.server.ssl.bundle) The name of a configured SSL bundle. () spring.rsocket.server.ssl.certificate(#application-properties.rsocket.spring.rsocket.server.ssl.certificate) Path to a PEM-encoded SSL certificate file. () spring.rsocket.server.ssl.certificate-private-key(#application-properties.rsocket.spring.rsocket.server.ssl.certificate-private-key) Path to a PEM-encoded private key file for the SSL certificate. () spring.rsocket.server.ssl.ciphers(#application-properties.rsocket.spring.rsocket.server.ssl.ciphers) Supported SSL ciphers. () spring.rsocket.server.ssl.client-auth(#application-properties.rsocket.spring.rsocket.server.ssl.client-auth) Client authentication mode. Requires a trust store. () spring.rsocket.server.ssl.enabled(#application-properties.rsocket.spring.rsocket.server.ssl.enabled) Whether to enable SSL support. true () spring.rsocket.server.ssl.enabled-protocols(#application-properties.rsocket.spring.rsocket.server.ssl.enabled-protocols) Enabled SSL protocols. () spring.rsocket.server.ssl.key-alias(#application-properties.rsocket.spring.rsocket.server.ssl.key-alias) Alias that identifies the key in the key store. () spring.rsocket.server.ssl.key-password(#application-properties.rsocket.spring.rsocket.server.ssl.key-password) Password used to access the key in the key store. () spring.rsocket.server.ssl.key-store(#application-properties.rsocket.spring.rsocket.server.ssl.key-store) Path to the key store that holds the SSL certificate (typically a jks file). () spring.rsocket.server.ssl.key-store-password(#application-properties.rsocket.spring.rsocket.server.ssl.key-store-password) Password used to access the key store. () spring.rsocket.server.ssl.key-store-provider(#application-properties.rsocket.spring.rsocket.server.ssl.key-store-provider) Provider for the key store. () spring.rsocket.server.ssl.key-store-type(#application-properties.rsocket.spring.rsocket.server.ssl.key-store-type) Type of the key store. () spring.rsocket.server.ssl.protocol(#application-properties.rsocket.spring.rsocket.server.ssl.protocol) SSL protocol to use. TLS () spring.rsocket.server.ssl.server-name-bundles(#application-properties.rsocket.spring.rsocket.server.ssl.server-name-bundles) Mapping of host names to SSL bundles for SNI configuration. () spring.rsocket.server.ssl.trust-certificate(#application-properties.rsocket.spring.rsocket.server.ssl.trust-certificate) Path to a PEM-encoded SSL certificate authority file. () spring.rsocket.server.ssl.trust-certificate-private-key(#application-properties.rsocket.spring.rsocket.server.ssl.trust-certificate-private-key) Path to a PEM-encoded private key file for the SSL certificate authority. () spring.rsocket.server.ssl.trust-store(#application-properties.rsocket.spring.rsocket.server.ssl.trust-store) Trust store that holds SSL certificates. () spring.rsocket.server.ssl.trust-store-password(#application-properties.rsocket.spring.rsocket.server.ssl.trust-store-password) Password used to access the trust store. () spring.rsocket.server.ssl.trust-store-provider(#application-properties.rsocket.spring.rsocket.server.ssl.trust-store-provider) Provider for the trust store. () spring.rsocket.server.ssl.trust-store-type(#application-properties.rsocket.spring.rsocket.server.ssl.trust-store-type) Type of the trust store. () spring.rsocket.server.transport(#application-properties.rsocket.spring.rsocket.server.transport) RSocket transport protocol. tcp Actuator Properties: Name Description Default Value () management.appoptics.metrics.export.api-token(#application-properties.actuator.management.appoptics.metrics.export.api-token) AppOptics API token. () management.appoptics.metrics.export.batch-size(#application-properties.actuator.management.appoptics.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 500 () management.appoptics.metrics.export.connect-timeout(#application-properties.actuator.management.appoptics.metrics.export.connect-timeout) Connection timeout for requests to this backend. 5s () management.appoptics.metrics.export.enabled(#application-properties.actuator.management.appoptics.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.appoptics.metrics.export.floor-times(#application-properties.actuator.management.appoptics.metrics.export.floor-times) Whether to ship a floored time, useful when sending measurements from multiple hosts to align them on a given time boundary. false () management.appoptics.metrics.export.host-tag(#application-properties.actuator.management.appoptics.metrics.export.host-tag) Tag that will be mapped to ""@host"" when shipping metrics to AppOptics. instance () management.appoptics.metrics.export.read-timeout(#application-properties.actuator.management.appoptics.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.appoptics.metrics.export.step(#application-properties.actuator.management.appoptics.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.appoptics.metrics.export.uri(#application-properties.actuator.management.appoptics.metrics.export.uri) URI to ship metrics to. https://api.appoptics.com/v1/measurements () management.atlas.metrics.export.batch-size(#application-properties.actuator.management.atlas.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 10000 () management.atlas.metrics.export.config-refresh-frequency(#application-properties.actuator.management.atlas.metrics.export.config-refresh-frequency) Frequency for refreshing config settings from the LWC service. 10s () management.atlas.metrics.export.config-time-to-live(#application-properties.actuator.management.atlas.metrics.export.config-time-to-live) Time to live for subscriptions from the LWC service. 150s () management.atlas.metrics.export.config-uri(#application-properties.actuator.management.atlas.metrics.export.config-uri) URI for the Atlas LWC endpoint to retrieve current subscriptions. http://localhost:7101/lwc/api/v1/expressions/local-dev () management.atlas.metrics.export.connect-timeout(#application-properties.actuator.management.atlas.metrics.export.connect-timeout) Connection timeout for requests to this backend. 1s () management.atlas.metrics.export.enabled(#application-properties.actuator.management.atlas.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.atlas.metrics.export.eval-uri(#application-properties.actuator.management.atlas.metrics.export.eval-uri) URI for the Atlas LWC endpoint to evaluate the data for a subscription. http://localhost:7101/lwc/api/v1/evaluate () management.atlas.metrics.export.lwc-enabled(#application-properties.actuator.management.atlas.metrics.export.lwc-enabled) Whether to enable streaming to Atlas LWC. false () management.atlas.metrics.export.lwc-ignore-publish-step(#application-properties.actuator.management.atlas.metrics.export.lwc-ignore-publish-step) Whether expressions with the same step size as Atlas publishing should be ignored for streaming. Used for cases where data being published to Atlas is also sent into streaming from the backend. true () management.atlas.metrics.export.lwc-step(#application-properties.actuator.management.atlas.metrics.export.lwc-step) Step size (reporting frequency) to use for streaming to Atlas LWC. This is the highest supported resolution for getting an on-demand stream of the data. It must be less than or equal to management.metrics.export.atlas.step and management.metrics.export.atlas.step should be an even multiple of this value. 5s () management.atlas.metrics.export.meter-time-to-live(#application-properties.actuator.management.atlas.metrics.export.meter-time-to-live) Time to live for meters that do not have any activity. After this period the meter will be considered expired and will not get reported. 15m () management.atlas.metrics.export.num-threads(#application-properties.actuator.management.atlas.metrics.export.num-threads) Number of threads to use with the metrics publishing scheduler. 4 () management.atlas.metrics.export.read-timeout(#application-properties.actuator.management.atlas.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.atlas.metrics.export.step(#application-properties.actuator.management.atlas.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.atlas.metrics.export.uri(#application-properties.actuator.management.atlas.metrics.export.uri) URI of the Atlas server. http://localhost:7101/api/v1/publish () management.auditevents.enabled(#application-properties.actuator.management.auditevents.enabled) Whether to enable storage of audit events. true () management.cloudfoundry.enabled(#application-properties.actuator.management.cloudfoundry.enabled) Whether to enable extended Cloud Foundry actuator endpoints. true () management.cloudfoundry.skip-ssl-validation(#application-properties.actuator.management.cloudfoundry.skip-ssl-validation) Whether to skip SSL verification for Cloud Foundry actuator endpoint security calls. false () management.datadog.metrics.export.api-key(#application-properties.actuator.management.datadog.metrics.export.api-key) Datadog API key. () management.datadog.metrics.export.application-key(#application-properties.actuator.management.datadog.metrics.export.application-key) Datadog application key. Not strictly required, but improves the Datadog experience by sending meter descriptions, types, and base units to Datadog. () management.datadog.metrics.export.batch-size(#application-properties.actuator.management.datadog.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 10000 () management.datadog.metrics.export.connect-timeout(#application-properties.actuator.management.datadog.metrics.export.connect-timeout) Connection timeout for requests to this backend. 1s () management.datadog.metrics.export.descriptions(#application-properties.actuator.management.datadog.metrics.export.descriptions) Whether to publish descriptions metadata to Datadog. Turn this off to minimize the amount of metadata sent. true () management.datadog.metrics.export.enabled(#application-properties.actuator.management.datadog.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.datadog.metrics.export.host-tag(#application-properties.actuator.management.datadog.metrics.export.host-tag) Tag that will be mapped to ""host"" when shipping metrics to Datadog. instance () management.datadog.metrics.export.read-timeout(#application-properties.actuator.management.datadog.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.datadog.metrics.export.step(#application-properties.actuator.management.datadog.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.datadog.metrics.export.uri(#application-properties.actuator.management.datadog.metrics.export.uri) URI to ship metrics to. Set this if you need to publish metrics to a Datadog site other than US, or to an internal proxy en-route to Datadog. https://api.datadoghq.com () management.defaults.metrics.export.enabled(#application-properties.actuator.management.defaults.metrics.export.enabled) Whether to enable default metrics exporters. true () management.dynatrace.metrics.export.api-token(#application-properties.actuator.management.dynatrace.metrics.export.api-token) Dynatrace authentication token. () management.dynatrace.metrics.export.batch-size(#application-properties.actuator.management.dynatrace.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 10000 () management.dynatrace.metrics.export.connect-timeout(#application-properties.actuator.management.dynatrace.metrics.export.connect-timeout) Connection timeout for requests to this backend. 1s () management.dynatrace.metrics.export.enabled(#application-properties.actuator.management.dynatrace.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.dynatrace.metrics.export.read-timeout(#application-properties.actuator.management.dynatrace.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.dynatrace.metrics.export.step(#application-properties.actuator.management.dynatrace.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.dynatrace.metrics.export.uri(#application-properties.actuator.management.dynatrace.metrics.export.uri) URI to ship metrics to. Should be used for SaaS, self-managed instances or to en-route through an internal proxy. () management.dynatrace.metrics.export.v1.device-id(#application-properties.actuator.management.dynatrace.metrics.export.v1.device-id) ID of the custom device that is exporting metrics to Dynatrace. () management.dynatrace.metrics.export.v1.group(#application-properties.actuator.management.dynatrace.metrics.export.v1.group) Group for exported metrics. Used to specify custom device group name in the Dynatrace UI. () management.dynatrace.metrics.export.v1.technology-type(#application-properties.actuator.management.dynatrace.metrics.export.v1.technology-type) Technology type for exported metrics. Used to group metrics under a logical technology name in the Dynatrace UI. java () management.dynatrace.metrics.export.v2.default-dimensions.*(#application-properties.actuator.management.dynatrace.metrics.export.v2.default-dimensions) Default dimensions that are added to all metrics in the form of key-value pairs. These are overwritten by Micrometer tags if they use the same key. () management.dynatrace.metrics.export.v2.enrich-with-dynatrace-metadata(#application-properties.actuator.management.dynatrace.metrics.export.v2.enrich-with-dynatrace-metadata) Whether to enable Dynatrace metadata export. true () management.dynatrace.metrics.export.v2.export-meter-metadata(#application-properties.actuator.management.dynatrace.metrics.export.v2.export-meter-metadata) Whether to export meter metadata (unit and description) to the Dynatrace backend. true () management.dynatrace.metrics.export.v2.metric-key-prefix(#application-properties.actuator.management.dynatrace.metrics.export.v2.metric-key-prefix) Prefix string that is added to all exported metrics. () management.dynatrace.metrics.export.v2.use-dynatrace-summary-instruments(#application-properties.actuator.management.dynatrace.metrics.export.v2.use-dynatrace-summary-instruments) Whether to fall back to the built-in micrometer instruments for Timer and DistributionSummary. true () management.elastic.metrics.export.api-key-credentials(#application-properties.actuator.management.elastic.metrics.export.api-key-credentials) Base64-encoded credentials string. Mutually exclusive with user-name and password. () management.elastic.metrics.export.auto-create-index(#application-properties.actuator.management.elastic.metrics.export.auto-create-index) Whether to create the index automatically if it does not exist. true () management.elastic.metrics.export.batch-size(#application-properties.actuator.management.elastic.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 10000 () management.elastic.metrics.export.connect-timeout(#application-properties.actuator.management.elastic.metrics.export.connect-timeout) Connection timeout for requests to this backend. 1s () management.elastic.metrics.export.enabled(#application-properties.actuator.management.elastic.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.elastic.metrics.export.host(#application-properties.actuator.management.elastic.metrics.export.host) Host to export metrics to. http://localhost:9200 () management.elastic.metrics.export.index(#application-properties.actuator.management.elastic.metrics.export.index) Index to export metrics to. micrometer-metrics () management.elastic.metrics.export.index-date-format(#application-properties.actuator.management.elastic.metrics.export.index-date-format) Index date format used for rolling indices. Appended to the index name. yyyy-MM () management.elastic.metrics.export.index-date-separator(#application-properties.actuator.management.elastic.metrics.export.index-date-separator) Prefix to separate the index name from the date format used for rolling indices. - () management.elastic.metrics.export.password(#application-properties.actuator.management.elastic.metrics.export.password) Login password of the Elastic server. Mutually exclusive with api-key-credentials. () management.elastic.metrics.export.pipeline(#application-properties.actuator.management.elastic.metrics.export.pipeline) Ingest pipeline name. By default, events are not pre-processed. () management.elastic.metrics.export.read-timeout(#application-properties.actuator.management.elastic.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.elastic.metrics.export.step(#application-properties.actuator.management.elastic.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.elastic.metrics.export.timestamp-field-name(#application-properties.actuator.management.elastic.metrics.export.timestamp-field-name) Name of the timestamp field. @timestamp () management.elastic.metrics.export.user-name(#application-properties.actuator.management.elastic.metrics.export.user-name) Login user of the Elastic server. Mutually exclusive with api-key-credentials. () management.endpoint.auditevents.cache.time-to-live(#application-properties.actuator.management.endpoint.auditevents.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.auditevents.enabled(#application-properties.actuator.management.endpoint.auditevents.enabled) Whether to enable the auditevents endpoint. true () management.endpoint.beans.cache.time-to-live(#application-properties.actuator.management.endpoint.beans.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.beans.enabled(#application-properties.actuator.management.endpoint.beans.enabled) Whether to enable the beans endpoint. true () management.endpoint.caches.cache.time-to-live(#application-properties.actuator.management.endpoint.caches.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.caches.enabled(#application-properties.actuator.management.endpoint.caches.enabled) Whether to enable the caches endpoint. true () management.endpoint.conditions.cache.time-to-live(#application-properties.actuator.management.endpoint.conditions.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.conditions.enabled(#application-properties.actuator.management.endpoint.conditions.enabled) Whether to enable the conditions endpoint. true () management.endpoint.configprops.cache.time-to-live(#application-properties.actuator.management.endpoint.configprops.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.configprops.enabled(#application-properties.actuator.management.endpoint.configprops.enabled) Whether to enable the configprops endpoint. true () management.endpoint.configprops.roles(#application-properties.actuator.management.endpoint.configprops.roles) Roles used to determine whether a user is authorized to be shown unsanitized values. When empty, all authenticated users are authorized. () management.endpoint.configprops.show-values(#application-properties.actuator.management.endpoint.configprops.show-values) When to show unsanitized values. never () management.endpoint.env.cache.time-to-live(#application-properties.actuator.management.endpoint.env.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.env.enabled(#application-properties.actuator.management.endpoint.env.enabled) Whether to enable the env endpoint. true () management.endpoint.env.roles(#application-properties.actuator.management.endpoint.env.roles) Roles used to determine whether a user is authorized to be shown unsanitized values. When empty, all authenticated users are authorized. () management.endpoint.env.show-values(#application-properties.actuator.management.endpoint.env.show-values) When to show unsanitized values. never () management.endpoint.flyway.cache.time-to-live(#application-properties.actuator.management.endpoint.flyway.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.flyway.enabled(#application-properties.actuator.management.endpoint.flyway.enabled) Whether to enable the flyway endpoint. true () management.endpoint.health.cache.time-to-live(#application-properties.actuator.management.endpoint.health.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.health.enabled(#application-properties.actuator.management.endpoint.health.enabled) Whether to enable the health endpoint. true () management.endpoint.health.group.*(#application-properties.actuator.management.endpoint.health.group) Health endpoint groups. () management.endpoint.health.logging.slow-indicator-threshold(#application-properties.actuator.management.endpoint.health.logging.slow-indicator-threshold) Threshold after which a warning will be logged for slow health indicators. 10s () management.endpoint.health.probes.add-additional-paths(#application-properties.actuator.management.endpoint.health.probes.add-additional-paths) Whether to make the liveness and readiness health groups available on the main server port. false () management.endpoint.health.probes.enabled(#application-properties.actuator.management.endpoint.health.probes.enabled) Whether to enable liveness and readiness probes. false () management.endpoint.health.roles(#application-properties.actuator.management.endpoint.health.roles) Roles used to determine whether a user is authorized to be shown details. When empty, all authenticated users are authorized. () management.endpoint.health.show-components(#application-properties.actuator.management.endpoint.health.show-components) When to show components. If not specified the 'show-details' setting will be used. () management.endpoint.health.show-details(#application-properties.actuator.management.endpoint.health.show-details) When to show full health details. never () management.endpoint.health.status.http-mapping.*(#application-properties.actuator.management.endpoint.health.status.http-mapping) Mapping of health statuses to HTTP status codes. By default, registered health statuses map to sensible defaults (for example, UP maps to 200). () management.endpoint.health.status.order(#application-properties.actuator.management.endpoint.health.status.order) Comma-separated list of health statuses in order of severity. [DOWN, OUT_OF_SERVICE, UP, UNKNOWN] () management.endpoint.health.validate-group-membership(#application-properties.actuator.management.endpoint.health.validate-group-membership) Whether to validate health group membership on startup. Validation fails if a group includes or excludes a health contributor that does not exist. true () management.endpoint.heapdump.cache.time-to-live(#application-properties.actuator.management.endpoint.heapdump.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.heapdump.enabled(#application-properties.actuator.management.endpoint.heapdump.enabled) Whether to enable the heapdump endpoint. true () management.endpoint.httpexchanges.cache.time-to-live(#application-properties.actuator.management.endpoint.httpexchanges.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.httpexchanges.enabled(#application-properties.actuator.management.endpoint.httpexchanges.enabled) Whether to enable the httpexchanges endpoint. true () management.endpoint.info.cache.time-to-live(#application-properties.actuator.management.endpoint.info.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.info.enabled(#application-properties.actuator.management.endpoint.info.enabled) Whether to enable the info endpoint. true () management.endpoint.integrationgraph.cache.time-to-live(#application-properties.actuator.management.endpoint.integrationgraph.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.integrationgraph.enabled(#application-properties.actuator.management.endpoint.integrationgraph.enabled) Whether to enable the integrationgraph endpoint. true () management.endpoint.liquibase.cache.time-to-live(#application-properties.actuator.management.endpoint.liquibase.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.liquibase.enabled(#application-properties.actuator.management.endpoint.liquibase.enabled) Whether to enable the liquibase endpoint. true () management.endpoint.logfile.cache.time-to-live(#application-properties.actuator.management.endpoint.logfile.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.logfile.enabled(#application-properties.actuator.management.endpoint.logfile.enabled) Whether to enable the logfile endpoint. true () management.endpoint.logfile.external-file(#application-properties.actuator.management.endpoint.logfile.external-file) External Logfile to be accessed. Can be used if the logfile is written by output redirect and not by the logging system itself. () management.endpoint.loggers.cache.time-to-live(#application-properties.actuator.management.endpoint.loggers.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.loggers.enabled(#application-properties.actuator.management.endpoint.loggers.enabled) Whether to enable the loggers endpoint. true () management.endpoint.mappings.cache.time-to-live(#application-properties.actuator.management.endpoint.mappings.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.mappings.enabled(#application-properties.actuator.management.endpoint.mappings.enabled) Whether to enable the mappings endpoint. true () management.endpoint.metrics.cache.time-to-live(#application-properties.actuator.management.endpoint.metrics.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.metrics.enabled(#application-properties.actuator.management.endpoint.metrics.enabled) Whether to enable the metrics endpoint. true () management.endpoint.prometheus.enabled(#application-properties.actuator.management.endpoint.prometheus.enabled) Whether to enable the prometheus endpoint. true () management.endpoint.quartz.cache.time-to-live(#application-properties.actuator.management.endpoint.quartz.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.quartz.enabled(#application-properties.actuator.management.endpoint.quartz.enabled) Whether to enable the quartz endpoint. true () management.endpoint.quartz.roles(#application-properties.actuator.management.endpoint.quartz.roles) Roles used to determine whether a user is authorized to be shown unsanitized job or trigger values. When empty, all authenticated users are authorized. () management.endpoint.quartz.show-values(#application-properties.actuator.management.endpoint.quartz.show-values) When to show unsanitized job or trigger values. never () management.endpoint.sbom.additional.*(#application-properties.actuator.management.endpoint.sbom.additional) Additional SBOMs. () management.endpoint.sbom.application.location(#application-properties.actuator.management.endpoint.sbom.application.location) Location to the SBOM. If null, the location will be auto-detected. () management.endpoint.sbom.application.media-type(#application-properties.actuator.management.endpoint.sbom.application.media-type) Media type of the SBOM. If null, the media type will be auto-detected. () management.endpoint.sbom.cache.time-to-live(#application-properties.actuator.management.endpoint.sbom.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.sbom.enabled(#application-properties.actuator.management.endpoint.sbom.enabled) Whether to enable the sbom endpoint. true () management.endpoint.scheduledtasks.cache.time-to-live(#application-properties.actuator.management.endpoint.scheduledtasks.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.scheduledtasks.enabled(#application-properties.actuator.management.endpoint.scheduledtasks.enabled) Whether to enable the scheduledtasks endpoint. true () management.endpoint.sessions.enabled(#application-properties.actuator.management.endpoint.sessions.enabled) Whether to enable the sessions endpoint. true () management.endpoint.shutdown.enabled(#application-properties.actuator.management.endpoint.shutdown.enabled) Whether to enable the shutdown endpoint. false () management.endpoint.startup.cache.time-to-live(#application-properties.actuator.management.endpoint.startup.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.startup.enabled(#application-properties.actuator.management.endpoint.startup.enabled) Whether to enable the startup endpoint. true () management.endpoint.threaddump.cache.time-to-live(#application-properties.actuator.management.endpoint.threaddump.cache.time-to-live) Maximum time that a response can be cached. 0ms () management.endpoint.threaddump.enabled(#application-properties.actuator.management.endpoint.threaddump.enabled) Whether to enable the threaddump endpoint. true () management.endpoints.enabled-by-default(#application-properties.actuator.management.endpoints.enabled-by-default) Whether to enable or disable all endpoints by default. () management.endpoints.jackson.isolated-object-mapper(#application-properties.actuator.management.endpoints.jackson.isolated-object-mapper) Whether to use an isolated object mapper to serialize endpoint JSON. true () management.endpoints.jmx.domain(#application-properties.actuator.management.endpoints.jmx.domain) Endpoints JMX domain name. Fallback to 'spring.jmx.default-domain' if set. org.springframework.boot () management.endpoints.jmx.exposure.exclude(#application-properties.actuator.management.endpoints.jmx.exposure.exclude) Endpoint IDs that should be excluded or '*' for all. () management.endpoints.jmx.exposure.include(#application-properties.actuator.management.endpoints.jmx.exposure.include) Endpoint IDs that should be included or '*' for all. health () management.endpoints.jmx.static-names(#application-properties.actuator.management.endpoints.jmx.static-names) Additional static properties to append to all ObjectNames of MBeans representing Endpoints. () management.endpoints.migrate-legacy-ids(#application-properties.actuator.management.endpoints.migrate-legacy-ids) Whether to transparently migrate legacy endpoint IDs. false () management.endpoints.web.base-path(#application-properties.actuator.management.endpoints.web.base-path) Base path for Web endpoints. Relative to the servlet context path (server.servlet.context-path) or WebFlux base path (spring.webflux.base-path) when the management server is sharing the main server port. Relative to the management server base path (management.server.base-path) when a separate management server port (management.server.port) is configured. /actuator () management.endpoints.web.cors.allow-credentials(#application-properties.actuator.management.endpoints.web.cors.allow-credentials) Whether credentials are supported. When not set, credentials are not supported. () management.endpoints.web.cors.allowed-headers(#application-properties.actuator.management.endpoints.web.cors.allowed-headers) Comma-separated list of headers to allow in a request. '*' allows all headers. () management.endpoints.web.cors.allowed-methods(#application-properties.actuator.management.endpoints.web.cors.allowed-methods) Comma-separated list of methods to allow. '*' allows all methods. When not set, defaults to GET. () management.endpoints.web.cors.allowed-origin-patterns(#application-properties.actuator.management.endpoints.web.cors.allowed-origin-patterns) Comma-separated list of origin patterns to allow. Unlike allowed origins which only supports '*', origin patterns are more flexible (for example 'https://*.example.com') and can be used when credentials are allowed. When no allowed origin patterns or allowed origins are set, CORS support is disabled. () management.endpoints.web.cors.allowed-origins(#application-properties.actuator.management.endpoints.web.cors.allowed-origins) Comma-separated list of origins to allow. '*' allows all origins. When credentials are allowed, '*' cannot be used and origin patterns should be configured instead. When no allowed origins or allowed origin patterns are set, CORS support is disabled. () management.endpoints.web.cors.exposed-headers(#application-properties.actuator.management.endpoints.web.cors.exposed-headers) Comma-separated list of headers to include in a response. () management.endpoints.web.cors.max-age(#application-properties.actuator.management.endpoints.web.cors.max-age) How long the response from a pre-flight request can be cached by clients. If a duration suffix is not specified, seconds will be used. 1800s () management.endpoints.web.discovery.enabled(#application-properties.actuator.management.endpoints.web.discovery.enabled) Whether the discovery page is enabled. true () management.endpoints.web.exposure.exclude(#application-properties.actuator.management.endpoints.web.exposure.exclude) Endpoint IDs that should be excluded or '*' for all. () management.endpoints.web.exposure.include(#application-properties.actuator.management.endpoints.web.exposure.include) Endpoint IDs that should be included or '*' for all. [health] () management.endpoints.web.path-mapping.*(#application-properties.actuator.management.endpoints.web.path-mapping) Mapping between endpoint IDs and the path that should expose them. () management.ganglia.metrics.export.addressing-mode(#application-properties.actuator.management.ganglia.metrics.export.addressing-mode) UDP addressing mode, either unicast or multicast. multicast () management.ganglia.metrics.export.duration-units(#application-properties.actuator.management.ganglia.metrics.export.duration-units) Base time unit used to report durations. milliseconds () management.ganglia.metrics.export.enabled(#application-properties.actuator.management.ganglia.metrics.export.enabled) Whether exporting of metrics to Ganglia is enabled. true () management.ganglia.metrics.export.host(#application-properties.actuator.management.ganglia.metrics.export.host) Host of the Ganglia server to receive exported metrics. localhost () management.ganglia.metrics.export.port(#application-properties.actuator.management.ganglia.metrics.export.port) Port of the Ganglia server to receive exported metrics. 8649 () management.ganglia.metrics.export.step(#application-properties.actuator.management.ganglia.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.ganglia.metrics.export.time-to-live(#application-properties.actuator.management.ganglia.metrics.export.time-to-live) Time to live for metrics on Ganglia. Set the multicast Time-To-Live to be one greater than the number of hops (routers) between the hosts. 1 () management.graphite.metrics.export.duration-units(#application-properties.actuator.management.graphite.metrics.export.duration-units) Base time unit used to report durations. milliseconds () management.graphite.metrics.export.enabled(#application-properties.actuator.management.graphite.metrics.export.enabled) Whether exporting of metrics to Graphite is enabled. true () management.graphite.metrics.export.graphite-tags-enabled(#application-properties.actuator.management.graphite.metrics.export.graphite-tags-enabled) Whether Graphite tags should be used, as opposed to a hierarchical naming convention. Enabled by default unless ""tagsAsPrefix"" is set. () management.graphite.metrics.export.host(#application-properties.actuator.management.graphite.metrics.export.host) Host of the Graphite server to receive exported metrics. localhost () management.graphite.metrics.export.port(#application-properties.actuator.management.graphite.metrics.export.port) Port of the Graphite server to receive exported metrics. 2004 () management.graphite.metrics.export.protocol(#application-properties.actuator.management.graphite.metrics.export.protocol) Protocol to use while shipping data to Graphite. pickled () management.graphite.metrics.export.rate-units(#application-properties.actuator.management.graphite.metrics.export.rate-units) Base time unit used to report rates. seconds () management.graphite.metrics.export.step(#application-properties.actuator.management.graphite.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.graphite.metrics.export.tags-as-prefix(#application-properties.actuator.management.graphite.metrics.export.tags-as-prefix) For the hierarchical naming convention, turn the specified tag keys into part of the metric prefix. Ignored if ""graphiteTagsEnabled"" is true. [] () management.health.cassandra.enabled(#application-properties.actuator.management.health.cassandra.enabled) Whether to enable Cassandra health check. true () management.health.couchbase.enabled(#application-properties.actuator.management.health.couchbase.enabled) Whether to enable Couchbase health check. true () management.health.db.enabled(#application-properties.actuator.management.health.db.enabled) Whether to enable database health check. true () management.health.db.ignore-routing-data-sources(#application-properties.actuator.management.health.db.ignore-routing-data-sources) Whether to ignore AbstractRoutingDataSources when creating database health indicators. false () management.health.defaults.enabled(#application-properties.actuator.management.health.defaults.enabled) Whether to enable default health indicators. true () management.health.diskspace.enabled(#application-properties.actuator.management.health.diskspace.enabled) Whether to enable disk space health check. true () management.health.diskspace.path(#application-properties.actuator.management.health.diskspace.path) Path used to compute the available disk space. () management.health.diskspace.threshold(#application-properties.actuator.management.health.diskspace.threshold) Minimum disk space that should be available. 10MB () management.health.elasticsearch.enabled(#application-properties.actuator.management.health.elasticsearch.enabled) Whether to enable Elasticsearch health check. true () management.health.influxdb.enabled(#application-properties.actuator.management.health.influxdb.enabled) Whether to enable InfluxDB health check. true () management.health.jms.enabled(#application-properties.actuator.management.health.jms.enabled) Whether to enable JMS health check. true () management.health.ldap.enabled(#application-properties.actuator.management.health.ldap.enabled) Whether to enable LDAP health check. true () management.health.livenessstate.enabled(#application-properties.actuator.management.health.livenessstate.enabled) Whether to enable liveness state health check. false () management.health.mail.enabled(#application-properties.actuator.management.health.mail.enabled) Whether to enable Mail health check. true () management.health.mongo.enabled(#application-properties.actuator.management.health.mongo.enabled) Whether to enable MongoDB health check. true () management.health.neo4j.enabled(#application-properties.actuator.management.health.neo4j.enabled) Whether to enable Neo4j health check. true () management.health.ping.enabled(#application-properties.actuator.management.health.ping.enabled) Whether to enable ping health check. true () management.health.rabbit.enabled(#application-properties.actuator.management.health.rabbit.enabled) Whether to enable RabbitMQ health check. true () management.health.readinessstate.enabled(#application-properties.actuator.management.health.readinessstate.enabled) Whether to enable readiness state health check. false () management.health.redis.enabled(#application-properties.actuator.management.health.redis.enabled) Whether to enable Redis health check. true () management.httpexchanges.recording.enabled(#application-properties.actuator.management.httpexchanges.recording.enabled) Whether to enable HTTP request-response exchange recording. true () management.httpexchanges.recording.include(#application-properties.actuator.management.httpexchanges.recording.include) Items to be included in the exchange recording. Defaults to request headers (excluding Authorization and Cookie), response headers (excluding Set-Cookie), and time taken. [request-headers, response-headers, errors] () management.humio.metrics.export.api-token(#application-properties.actuator.management.humio.metrics.export.api-token) Humio API token. () management.humio.metrics.export.batch-size(#application-properties.actuator.management.humio.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 10000 () management.humio.metrics.export.connect-timeout(#application-properties.actuator.management.humio.metrics.export.connect-timeout) Connection timeout for requests to this backend. 5s () management.humio.metrics.export.enabled(#application-properties.actuator.management.humio.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.humio.metrics.export.read-timeout(#application-properties.actuator.management.humio.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.humio.metrics.export.step(#application-properties.actuator.management.humio.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.humio.metrics.export.tags.*(#application-properties.actuator.management.humio.metrics.export.tags) Humio tags describing the data source in which metrics will be stored. Humio tags are a distinct concept from Micrometer's tags. Micrometer's tags are used to divide metrics along dimensional boundaries. () management.humio.metrics.export.uri(#application-properties.actuator.management.humio.metrics.export.uri) URI to ship metrics to. If you need to publish metrics to an internal proxy en-route to Humio, you can define the location of the proxy with this. https://cloud.humio.com () management.influx.metrics.export.api-version(#application-properties.actuator.management.influx.metrics.export.api-version) API version of InfluxDB to use. Defaults to 'v1' unless an org is configured. If an org is configured, defaults to 'v2'. () management.influx.metrics.export.auto-create-db(#application-properties.actuator.management.influx.metrics.export.auto-create-db) Whether to create the Influx database if it does not exist before attempting to publish metrics to it. InfluxDB v1 only. true () management.influx.metrics.export.batch-size(#application-properties.actuator.management.influx.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 10000 () management.influx.metrics.export.bucket(#application-properties.actuator.management.influx.metrics.export.bucket) Bucket for metrics. Use either the bucket name or ID. Defaults to the value of the db property if not set. InfluxDB v2 only. () management.influx.metrics.export.compressed(#application-properties.actuator.management.influx.metrics.export.compressed) Whether to enable GZIP compression of metrics batches published to Influx. true () management.influx.metrics.export.connect-timeout(#application-properties.actuator.management.influx.metrics.export.connect-timeout) Connection timeout for requests to this backend. 1s () management.influx.metrics.export.consistency(#application-properties.actuator.management.influx.metrics.export.consistency) Write consistency for each point. one () management.influx.metrics.export.db(#application-properties.actuator.management.influx.metrics.export.db) Database to send metrics to. InfluxDB v1 only. mydb () management.influx.metrics.export.enabled(#application-properties.actuator.management.influx.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.influx.metrics.export.org(#application-properties.actuator.management.influx.metrics.export.org) Org to write metrics to. InfluxDB v2 only. () management.influx.metrics.export.password(#application-properties.actuator.management.influx.metrics.export.password) Login password of the Influx server. InfluxDB v1 only. () management.influx.metrics.export.read-timeout(#application-properties.actuator.management.influx.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.influx.metrics.export.retention-duration(#application-properties.actuator.management.influx.metrics.export.retention-duration) Time period for which Influx should retain data in the current database. For instance 7d, check the influx documentation for more details on the duration format. InfluxDB v1 only. () management.influx.metrics.export.retention-policy(#application-properties.actuator.management.influx.metrics.export.retention-policy) Retention policy to use (Influx writes to the DEFAULT retention policy if one is not specified). InfluxDB v1 only. () management.influx.metrics.export.retention-replication-factor(#application-properties.actuator.management.influx.metrics.export.retention-replication-factor) How many copies of the data are stored in the cluster. Must be 1 for a single node instance. InfluxDB v1 only. () management.influx.metrics.export.retention-shard-duration(#application-properties.actuator.management.influx.metrics.export.retention-shard-duration) Time range covered by a shard group. For instance 2w, check the influx documentation for more details on the duration format. InfluxDB v1 only. () management.influx.metrics.export.step(#application-properties.actuator.management.influx.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.influx.metrics.export.token(#application-properties.actuator.management.influx.metrics.export.token) Authentication token to use with calls to the InfluxDB backend. For InfluxDB v1, the Bearer scheme is used. For v2, the Token scheme is used. () management.influx.metrics.export.uri(#application-properties.actuator.management.influx.metrics.export.uri) URI of the Influx server. http://localhost:8086 () management.influx.metrics.export.user-name(#application-properties.actuator.management.influx.metrics.export.user-name) Login user of the Influx server. InfluxDB v1 only. () management.info.build.enabled(#application-properties.actuator.management.info.build.enabled) Whether to enable build info. true () management.info.defaults.enabled(#application-properties.actuator.management.info.defaults.enabled) Whether to enable default info contributors. true () management.info.env.enabled(#application-properties.actuator.management.info.env.enabled) Whether to enable environment info. false () management.info.git.enabled(#application-properties.actuator.management.info.git.enabled) Whether to enable git info. true () management.info.git.mode(#application-properties.actuator.management.info.git.mode) Mode to use to expose git information. simple () management.info.java.enabled(#application-properties.actuator.management.info.java.enabled) Whether to enable Java info. false () management.info.os.enabled(#application-properties.actuator.management.info.os.enabled) Whether to enable Operating System info. false () management.info.process.enabled(#application-properties.actuator.management.info.process.enabled) Whether to enable process info. false () management.jmx.metrics.export.domain(#application-properties.actuator.management.jmx.metrics.export.domain) Metrics JMX domain name. metrics () management.jmx.metrics.export.enabled(#application-properties.actuator.management.jmx.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.jmx.metrics.export.step(#application-properties.actuator.management.jmx.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.kairos.metrics.export.batch-size(#application-properties.actuator.management.kairos.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 10000 () management.kairos.metrics.export.connect-timeout(#application-properties.actuator.management.kairos.metrics.export.connect-timeout) Connection timeout for requests to this backend. 1s () management.kairos.metrics.export.enabled(#application-properties.actuator.management.kairos.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.kairos.metrics.export.password(#application-properties.actuator.management.kairos.metrics.export.password) Login password of the KairosDB server. () management.kairos.metrics.export.read-timeout(#application-properties.actuator.management.kairos.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.kairos.metrics.export.step(#application-properties.actuator.management.kairos.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.kairos.metrics.export.uri(#application-properties.actuator.management.kairos.metrics.export.uri) URI of the KairosDB server. http://localhost:8080/api/v1/datapoints () management.kairos.metrics.export.user-name(#application-properties.actuator.management.kairos.metrics.export.user-name) Login user of the KairosDB server. () management.metrics.data.repository.autotime.enabled(#application-properties.actuator.management.metrics.data.repository.autotime.enabled) Whether to enable auto-timing. true () management.metrics.data.repository.autotime.percentiles(#application-properties.actuator.management.metrics.data.repository.autotime.percentiles) Percentiles for which additional time series should be published. () management.metrics.data.repository.autotime.percentiles-histogram(#application-properties.actuator.management.metrics.data.repository.autotime.percentiles-histogram) Whether to publish percentile histograms. false () management.metrics.data.repository.metric-name(#application-properties.actuator.management.metrics.data.repository.metric-name) Name of the metric for sent requests. spring.data.repository.invocations () management.metrics.distribution.buffer-length.*(#application-properties.actuator.management.metrics.distribution.buffer-length) Number of histograms for meter IDs starting with the specified name to keep in the ring buffer. The longest match wins, the key `all` can also be used to configure all meters. () management.metrics.distribution.expiry.*(#application-properties.actuator.management.metrics.distribution.expiry) Maximum amount of time that samples for meter IDs starting with the specified name are accumulated to decaying distribution statistics before they are reset and rotated. The longest match wins, the key `all` can also be used to configure all meters. () management.metrics.distribution.maximum-expected-value.*(#application-properties.actuator.management.metrics.distribution.maximum-expected-value) Maximum value that meter IDs starting with the specified name are expected to observe. The longest match wins. Values can be specified as a double or as a Duration value (for timer meters, defaulting to ms if no unit specified). () management.metrics.distribution.minimum-expected-value.*(#application-properties.actuator.management.metrics.distribution.minimum-expected-value) Minimum value that meter IDs starting with the specified name are expected to observe. The longest match wins. Values can be specified as a double or as a Duration value (for timer meters, defaulting to ms if no unit specified). () management.metrics.distribution.percentiles.*(#application-properties.actuator.management.metrics.distribution.percentiles) Specific computed non-aggregable percentiles to ship to the backend for meter IDs starting-with the specified name. The longest match wins, the key 'all' can also be used to configure all meters. () management.metrics.distribution.percentiles-histogram.*(#application-properties.actuator.management.metrics.distribution.percentiles-histogram) Whether meter IDs starting with the specified name should publish percentile histograms. For monitoring systems that support aggregable percentile calculation based on a histogram, this can be set to true. For other systems, this has no effect. The longest match wins, the key 'all' can also be used to configure all meters. () management.metrics.distribution.slo.*(#application-properties.actuator.management.metrics.distribution.slo) Specific service-level objective boundaries for meter IDs starting with the specified name. The longest match wins. Counters will be published for each specified boundary. Values can be specified as a double or as a Duration value (for timer meters, defaulting to ms if no unit specified). () management.metrics.enable.*(#application-properties.actuator.management.metrics.enable) Whether meter IDs starting with the specified name should be enabled. The longest match wins, the key 'all' can also be used to configure all meters. () management.metrics.mongo.command.enabled(#application-properties.actuator.management.metrics.mongo.command.enabled) Whether to enable Mongo client command metrics. true () management.metrics.mongo.connectionpool.enabled(#application-properties.actuator.management.metrics.mongo.connectionpool.enabled) Whether to enable Mongo connection pool metrics. true () management.metrics.system.diskspace.paths(#application-properties.actuator.management.metrics.system.diskspace.paths) Comma-separated list of paths to report disk metrics for. [.] () management.metrics.tags.*(#application-properties.actuator.management.metrics.tags) Common tags that are applied to every meter. () management.metrics.use-global-registry(#application-properties.actuator.management.metrics.use-global-registry) Whether auto-configured MeterRegistry implementations should be bound to the global static registry on Metrics. For testing, set this to 'false' to maximize test independence. true () management.metrics.web.client.max-uri-tags(#application-properties.actuator.management.metrics.web.client.max-uri-tags) Maximum number of unique URI tag values allowed. After the max number of tag values is reached, metrics with additional tag values are denied by filter. 100 () management.metrics.web.server.max-uri-tags(#application-properties.actuator.management.metrics.web.server.max-uri-tags) Maximum number of unique URI tag values allowed. After the max number of tag values is reached, metrics with additional tag values are denied by filter. 100 () management.newrelic.metrics.export.account-id(#application-properties.actuator.management.newrelic.metrics.export.account-id) New Relic account ID. () management.newrelic.metrics.export.api-key(#application-properties.actuator.management.newrelic.metrics.export.api-key) New Relic API key. () management.newrelic.metrics.export.batch-size(#application-properties.actuator.management.newrelic.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 10000 () management.newrelic.metrics.export.client-provider-type(#application-properties.actuator.management.newrelic.metrics.export.client-provider-type) Client provider type to use. insights-api () management.newrelic.metrics.export.connect-timeout(#application-properties.actuator.management.newrelic.metrics.export.connect-timeout) Connection timeout for requests to this backend. 1s () management.newrelic.metrics.export.enabled(#application-properties.actuator.management.newrelic.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.newrelic.metrics.export.event-type(#application-properties.actuator.management.newrelic.metrics.export.event-type) The event type that should be published. This property will be ignored if 'meter-name-event-type-enabled' is set to 'true'. SpringBootSample () management.newrelic.metrics.export.meter-name-event-type-enabled(#application-properties.actuator.management.newrelic.metrics.export.meter-name-event-type-enabled) Whether to send the meter name as the event type instead of using the 'event-type' configuration property value. Can be set to 'true' if New Relic guidelines are not being followed or event types consistent with previous Spring Boot releases are required. false () management.newrelic.metrics.export.read-timeout(#application-properties.actuator.management.newrelic.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.newrelic.metrics.export.step(#application-properties.actuator.management.newrelic.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.newrelic.metrics.export.uri(#application-properties.actuator.management.newrelic.metrics.export.uri) URI to ship metrics to. https://insights-collector.newrelic.com () management.observations.annotations.enabled(#application-properties.actuator.management.observations.annotations.enabled) Whether auto-configuration of Micrometer annotations is enabled. false () management.observations.enable.*(#application-properties.actuator.management.observations.enable) Whether observations starting with the specified name should be enabled. The longest match wins, the key 'all' can also be used to configure all observations. () management.observations.http.client.requests.name(#application-properties.actuator.management.observations.http.client.requests.name) Name of the observation for client requests. http.client.requests () management.observations.http.server.requests.name(#application-properties.actuator.management.observations.http.server.requests.name) Name of the observation for server requests. http.server.requests () management.observations.key-values.*(#application-properties.actuator.management.observations.key-values) Common key-values that are applied to every observation. () management.observations.long-task-timer.enabled(#application-properties.actuator.management.observations.long-task-timer.enabled) Whether to create a LongTaskTimer for every observation. true () management.observations.r2dbc.include-parameter-values(#application-properties.actuator.management.observations.r2dbc.include-parameter-values) Whether to tag actual query parameter values. false () management.opentelemetry.resource-attributes.*(#application-properties.actuator.management.opentelemetry.resource-attributes) Resource attributes. () management.otlp.metrics.export.aggregation-temporality(#application-properties.actuator.management.otlp.metrics.export.aggregation-temporality) Aggregation temporality of sums. It defines the way additive values are expressed. This setting depends on the backend you use, some only support one temporality. cumulative () management.otlp.metrics.export.base-time-unit(#application-properties.actuator.management.otlp.metrics.export.base-time-unit) Time unit for exported metrics. milliseconds () management.otlp.metrics.export.batch-size(#application-properties.actuator.management.otlp.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 10000 () management.otlp.metrics.export.connect-timeout(#application-properties.actuator.management.otlp.metrics.export.connect-timeout) Connection timeout for requests to this backend. 1s () management.otlp.metrics.export.enabled(#application-properties.actuator.management.otlp.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.otlp.metrics.export.headers.*(#application-properties.actuator.management.otlp.metrics.export.headers) Headers for the exported metrics. () management.otlp.metrics.export.read-timeout(#application-properties.actuator.management.otlp.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.otlp.metrics.export.step(#application-properties.actuator.management.otlp.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.otlp.metrics.export.url(#application-properties.actuator.management.otlp.metrics.export.url) URI of the OLTP server. http://localhost:4318/v1/metrics () management.otlp.tracing.compression(#application-properties.actuator.management.otlp.tracing.compression) Method used to compress the payload. none () management.otlp.tracing.endpoint(#application-properties.actuator.management.otlp.tracing.endpoint) URL to the OTel collector's HTTP API. () management.otlp.tracing.headers.*(#application-properties.actuator.management.otlp.tracing.headers) Custom HTTP headers you want to pass to the collector, for example auth headers. () management.otlp.tracing.timeout(#application-properties.actuator.management.otlp.tracing.timeout) Call timeout for the OTel Collector to process an exported batch of data. This timeout spans the entire call: resolving DNS, connecting, writing the request body, server processing, and reading the response body. If the call requires redirects or retries all must complete within one timeout period. 10s () management.prometheus.metrics.export.descriptions(#application-properties.actuator.management.prometheus.metrics.export.descriptions) Whether to enable publishing descriptions as part of the scrape payload to Prometheus. Turn this off to minimize the amount of data sent on each scrape. true () management.prometheus.metrics.export.enabled(#application-properties.actuator.management.prometheus.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.prometheus.metrics.export.properties.*(#application-properties.actuator.management.prometheus.metrics.export.properties) Additional properties to pass to the Prometheus client. () management.prometheus.metrics.export.pushgateway.base-url(#application-properties.actuator.management.prometheus.metrics.export.pushgateway.base-url) Base URL for the Pushgateway. http://localhost:9091 () management.prometheus.metrics.export.pushgateway.enabled(#application-properties.actuator.management.prometheus.metrics.export.pushgateway.enabled) Enable publishing over a Prometheus Pushgateway. false () management.prometheus.metrics.export.pushgateway.grouping-key.*(#application-properties.actuator.management.prometheus.metrics.export.pushgateway.grouping-key) Grouping key for the pushed metrics. () management.prometheus.metrics.export.pushgateway.job(#application-properties.actuator.management.prometheus.metrics.export.pushgateway.job) Job identifier for this application instance. () management.prometheus.metrics.export.pushgateway.password(#application-properties.actuator.management.prometheus.metrics.export.pushgateway.password) Login password of the Prometheus Pushgateway. () management.prometheus.metrics.export.pushgateway.push-rate(#application-properties.actuator.management.prometheus.metrics.export.pushgateway.push-rate) Frequency with which to push metrics. 1m () management.prometheus.metrics.export.pushgateway.shutdown-operation(#application-properties.actuator.management.prometheus.metrics.export.pushgateway.shutdown-operation) Operation that should be performed on shutdown. none () management.prometheus.metrics.export.pushgateway.username(#application-properties.actuator.management.prometheus.metrics.export.pushgateway.username) Login user of the Prometheus Pushgateway. () management.prometheus.metrics.export.step(#application-properties.actuator.management.prometheus.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.server.add-application-context-header(#application-properties.actuator.management.server.add-application-context-header) Add the ""X-Application-Context"" HTTP header in each response. false () management.server.address(#application-properties.actuator.management.server.address) Network address to which the management endpoints should bind. Requires a custom management.server.port. () management.server.base-path(#application-properties.actuator.management.server.base-path) Management endpoint base path (for instance, '/management'). Requires a custom management.server.port. () management.server.port(#application-properties.actuator.management.server.port) Management endpoint HTTP port (uses the same port as the application by default). Configure a different port to use management-specific SSL. () management.server.ssl.bundle(#application-properties.actuator.management.server.ssl.bundle) The name of a configured SSL bundle. () management.server.ssl.certificate(#application-properties.actuator.management.server.ssl.certificate) Path to a PEM-encoded SSL certificate file. () management.server.ssl.certificate-private-key(#application-properties.actuator.management.server.ssl.certificate-private-key) Path to a PEM-encoded private key file for the SSL certificate. () management.server.ssl.ciphers(#application-properties.actuator.management.server.ssl.ciphers) Supported SSL ciphers. () management.server.ssl.client-auth(#application-properties.actuator.management.server.ssl.client-auth) Client authentication mode. Requires a trust store. () management.server.ssl.enabled(#application-properties.actuator.management.server.ssl.enabled) Whether to enable SSL support. true () management.server.ssl.enabled-protocols(#application-properties.actuator.management.server.ssl.enabled-protocols) Enabled SSL protocols. () management.server.ssl.key-alias(#application-properties.actuator.management.server.ssl.key-alias) Alias that identifies the key in the key store. () management.server.ssl.key-password(#application-properties.actuator.management.server.ssl.key-password) Password used to access the key in the key store. () management.server.ssl.key-store(#application-properties.actuator.management.server.ssl.key-store) Path to the key store that holds the SSL certificate (typically a jks file). () management.server.ssl.key-store-password(#application-properties.actuator.management.server.ssl.key-store-password) Password used to access the key store. () management.server.ssl.key-store-provider(#application-properties.actuator.management.server.ssl.key-store-provider) Provider for the key store. () management.server.ssl.key-store-type(#application-properties.actuator.management.server.ssl.key-store-type) Type of the key store. () management.server.ssl.protocol(#application-properties.actuator.management.server.ssl.protocol) SSL protocol to use. TLS () management.server.ssl.server-name-bundles(#application-properties.actuator.management.server.ssl.server-name-bundles) Mapping of host names to SSL bundles for SNI configuration. () management.server.ssl.trust-certificate(#application-properties.actuator.management.server.ssl.trust-certificate) Path to a PEM-encoded SSL certificate authority file. () management.server.ssl.trust-certificate-private-key(#application-properties.actuator.management.server.ssl.trust-certificate-private-key) Path to a PEM-encoded private key file for the SSL certificate authority. () management.server.ssl.trust-store(#application-properties.actuator.management.server.ssl.trust-store) Trust store that holds SSL certificates. () management.server.ssl.trust-store-password(#application-properties.actuator.management.server.ssl.trust-store-password) Password used to access the trust store. () management.server.ssl.trust-store-provider(#application-properties.actuator.management.server.ssl.trust-store-provider) Provider for the trust store. () management.server.ssl.trust-store-type(#application-properties.actuator.management.server.ssl.trust-store-type) Type of the trust store. () management.signalfx.metrics.export.access-token(#application-properties.actuator.management.signalfx.metrics.export.access-token) SignalFX access token. () management.signalfx.metrics.export.batch-size(#application-properties.actuator.management.signalfx.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 10000 () management.signalfx.metrics.export.connect-timeout(#application-properties.actuator.management.signalfx.metrics.export.connect-timeout) Connection timeout for requests to this backend. 1s () management.signalfx.metrics.export.enabled(#application-properties.actuator.management.signalfx.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.signalfx.metrics.export.published-histogram-type(#application-properties.actuator.management.signalfx.metrics.export.published-histogram-type) Type of histogram to publish. default () management.signalfx.metrics.export.read-timeout(#application-properties.actuator.management.signalfx.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.signalfx.metrics.export.source(#application-properties.actuator.management.signalfx.metrics.export.source) Uniquely identifies the app instance that is publishing metrics to SignalFx. Defaults to the local host name. () management.signalfx.metrics.export.step(#application-properties.actuator.management.signalfx.metrics.export.step) Step size (i.e. reporting frequency) to use. 10s () management.signalfx.metrics.export.uri(#application-properties.actuator.management.signalfx.metrics.export.uri) URI to ship metrics to. https://ingest.signalfx.com () management.simple.metrics.export.enabled(#application-properties.actuator.management.simple.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.simple.metrics.export.mode(#application-properties.actuator.management.simple.metrics.export.mode) Counting mode. cumulative () management.simple.metrics.export.step(#application-properties.actuator.management.simple.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.stackdriver.metrics.export.batch-size(#application-properties.actuator.management.stackdriver.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 10000 () management.stackdriver.metrics.export.connect-timeout(#application-properties.actuator.management.stackdriver.metrics.export.connect-timeout) Connection timeout for requests to this backend. 1s () management.stackdriver.metrics.export.enabled(#application-properties.actuator.management.stackdriver.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.stackdriver.metrics.export.metric-type-prefix(#application-properties.actuator.management.stackdriver.metrics.export.metric-type-prefix) Prefix for metric type. Valid prefixes are described in the Google Cloud documentation (https://cloud.google.com/monitoring/custom-metrics#identifier). custom.googleapis.com/ () management.stackdriver.metrics.export.project-id(#application-properties.actuator.management.stackdriver.metrics.export.project-id) Identifier of the Google Cloud project to monitor. () management.stackdriver.metrics.export.read-timeout(#application-properties.actuator.management.stackdriver.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.stackdriver.metrics.export.resource-labels.*(#application-properties.actuator.management.stackdriver.metrics.export.resource-labels) Monitored resource's labels. () management.stackdriver.metrics.export.resource-type(#application-properties.actuator.management.stackdriver.metrics.export.resource-type) Monitored resource type. global () management.stackdriver.metrics.export.step(#application-properties.actuator.management.stackdriver.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.stackdriver.metrics.export.use-semantic-metric-types(#application-properties.actuator.management.stackdriver.metrics.export.use-semantic-metric-types) Whether to use semantically correct metric types. When false, counter metrics are published as the GAUGE MetricKind. When true, counter metrics are published as the CUMULATIVE MetricKind. false () management.statsd.metrics.export.buffered(#application-properties.actuator.management.statsd.metrics.export.buffered) Whether measurements should be buffered before sending to the StatsD server. true () management.statsd.metrics.export.enabled(#application-properties.actuator.management.statsd.metrics.export.enabled) Whether exporting of metrics to StatsD is enabled. true () management.statsd.metrics.export.flavor(#application-properties.actuator.management.statsd.metrics.export.flavor) StatsD line protocol to use. datadog () management.statsd.metrics.export.host(#application-properties.actuator.management.statsd.metrics.export.host) Host of the StatsD server to receive exported metrics. localhost () management.statsd.metrics.export.max-packet-length(#application-properties.actuator.management.statsd.metrics.export.max-packet-length) Total length of a single payload should be kept within your network's MTU. 1400 () management.statsd.metrics.export.polling-frequency(#application-properties.actuator.management.statsd.metrics.export.polling-frequency) How often gauges will be polled. When a gauge is polled, its value is recalculated and if the value has changed (or publishUnchangedMeters is true), it is sent to the StatsD server. 10s () management.statsd.metrics.export.port(#application-properties.actuator.management.statsd.metrics.export.port) Port of the StatsD server to receive exported metrics. 8125 () management.statsd.metrics.export.protocol(#application-properties.actuator.management.statsd.metrics.export.protocol) Protocol of the StatsD server to receive exported metrics. udp () management.statsd.metrics.export.publish-unchanged-meters(#application-properties.actuator.management.statsd.metrics.export.publish-unchanged-meters) Whether to send unchanged meters to the StatsD server. true () management.statsd.metrics.export.step(#application-properties.actuator.management.statsd.metrics.export.step) Step size to use in computing windowed statistics like max. To get the most out of these statistics, align the step interval to be close to your scrape interval. 1m () management.tracing.baggage.correlation.enabled(#application-properties.actuator.management.tracing.baggage.correlation.enabled) Whether to enable correlation of the baggage context with logging contexts. true () management.tracing.baggage.correlation.fields(#application-properties.actuator.management.tracing.baggage.correlation.fields) List of fields that should be correlated with the logging context. That means that these fields would end up as key-value pairs in e.g. MDC. () management.tracing.baggage.enabled(#application-properties.actuator.management.tracing.baggage.enabled) Whether to enable Micrometer Tracing baggage propagation. true () management.tracing.baggage.local-fields(#application-properties.actuator.management.tracing.baggage.local-fields) List of fields that should be accessible within the JVM process but not propagated over the wire. Local fields are not supported with OpenTelemetry. () management.tracing.baggage.remote-fields(#application-properties.actuator.management.tracing.baggage.remote-fields) List of fields that are referenced the same in-process as it is on the wire. For example, the field ""x-vcap-request-id"" would be set as-is including the prefix. () management.tracing.baggage.tag-fields(#application-properties.actuator.management.tracing.baggage.tag-fields) List of fields that should automatically become tags. () management.tracing.brave.span-joining-supported(#application-properties.actuator.management.tracing.brave.span-joining-supported) Whether the propagation type and tracing backend support sharing the span ID between client and server spans. Requires B3 propagation and a compatible backend. false () management.tracing.enabled(#application-properties.actuator.management.tracing.enabled) Whether auto-configuration of tracing is enabled to export and propagate traces. true () management.tracing.propagation.consume(#application-properties.actuator.management.tracing.propagation.consume) Tracing context propagation types consumed by the application. [W3C, B3, B3_MULTI] () management.tracing.propagation.produce(#application-properties.actuator.management.tracing.propagation.produce) Tracing context propagation types produced by the application. [W3C] () management.tracing.propagation.type(#application-properties.actuator.management.tracing.propagation.type) Tracing context propagation types produced and consumed by the application. Setting this property overrides the more fine-grained propagation type properties. () management.tracing.sampling.probability(#application-properties.actuator.management.tracing.sampling.probability) Probability in the range from 0.0 to 1.0 that a trace will be sampled. 0.1 () management.wavefront.api-token(#application-properties.actuator.management.wavefront.api-token) API token used when publishing metrics and traces directly to the Wavefront API host. () management.wavefront.api-token-type(#application-properties.actuator.management.wavefront.api-token-type) Type of the API token. () management.wavefront.application.cluster-name(#application-properties.actuator.management.wavefront.application.cluster-name) Wavefront Cluster name used in ApplicationTags. () management.wavefront.application.custom-tags.*(#application-properties.actuator.management.wavefront.application.custom-tags) Wavefront custom tags used in ApplicationTags. () management.wavefront.application.name(#application-properties.actuator.management.wavefront.application.name) Wavefront 'Application' name used in ApplicationTags. unnamed_application () management.wavefront.application.service-name(#application-properties.actuator.management.wavefront.application.service-name) Wavefront 'Service' name used in ApplicationTags, falling back to 'spring.application.name'. If both are unset it defaults to 'unnamed_service'. () management.wavefront.application.shard-name(#application-properties.actuator.management.wavefront.application.shard-name) Wavefront Shard name used in ApplicationTags. () management.wavefront.metrics.export.batch-size(#application-properties.actuator.management.wavefront.metrics.export.batch-size) Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made. 10000 () management.wavefront.metrics.export.connect-timeout(#application-properties.actuator.management.wavefront.metrics.export.connect-timeout) Connection timeout for requests to this backend. 1s () management.wavefront.metrics.export.enabled(#application-properties.actuator.management.wavefront.metrics.export.enabled) Whether exporting of metrics to this backend is enabled. true () management.wavefront.metrics.export.global-prefix(#application-properties.actuator.management.wavefront.metrics.export.global-prefix) Global prefix to separate metrics originating from this app's instrumentation from those originating from other Wavefront integrations when viewed in the Wavefront UI. () management.wavefront.metrics.export.read-timeout(#application-properties.actuator.management.wavefront.metrics.export.read-timeout) Read timeout for requests to this backend. 10s () management.wavefront.metrics.export.report-day-distribution(#application-properties.actuator.management.wavefront.metrics.export.report-day-distribution) Whether to report histogram distributions aggregated into day intervals. false () management.wavefront.metrics.export.report-hour-distribution(#application-properties.actuator.management.wavefront.metrics.export.report-hour-distribution) Whether to report histogram distributions aggregated into hour intervals. false () management.wavefront.metrics.export.report-minute-distribution(#application-properties.actuator.management.wavefront.metrics.export.report-minute-distribution) Whether to report histogram distributions aggregated into minute intervals. true () management.wavefront.metrics.export.step(#application-properties.actuator.management.wavefront.metrics.export.step) Step size (i.e. reporting frequency) to use. 1m () management.wavefront.sender.batch-size(#application-properties.actuator.management.wavefront.sender.batch-size) Number of measurements per request to use for Wavefront. If more measurements are found, then multiple requests will be made. 10000 () management.wavefront.sender.flush-interval(#application-properties.actuator.management.wavefront.sender.flush-interval) Flush interval to send queued messages. 1s () management.wavefront.sender.max-queue-size(#application-properties.actuator.management.wavefront.sender.max-queue-size) Maximum size of queued messages. 50000 () management.wavefront.sender.message-size(#application-properties.actuator.management.wavefront.sender.message-size) Maximum size of a message. () management.wavefront.source(#application-properties.actuator.management.wavefront.source) Unique identifier for the app instance that is the source of metrics and traces being published to Wavefront. Defaults to the local host name. () management.wavefront.trace-derived-custom-tag-keys(#application-properties.actuator.management.wavefront.trace-derived-custom-tag-keys) Customized span tags for RED metrics. () management.wavefront.uri(#application-properties.actuator.management.wavefront.uri) URI to ship metrics and traces to. https://longboard.wavefront.com () management.zipkin.tracing.connect-timeout(#application-properties.actuator.management.zipkin.tracing.connect-timeout) Connection timeout for requests to Zipkin. 1s () management.zipkin.tracing.encoding(#application-properties.actuator.management.zipkin.tracing.encoding) How to encode the POST body to the Zipkin API. [JSON] () management.zipkin.tracing.endpoint(#application-properties.actuator.management.zipkin.tracing.endpoint) URL to the Zipkin API. http://localhost:9411/api/v2/spans () management.zipkin.tracing.read-timeout(#application-properties.actuator.management.zipkin.tracing.read-timeout) Read timeout for requests to Zipkin. 10s Devtools Properties: Name Description Default Value () spring.devtools.add-properties(#application-properties.devtools.spring.devtools.add-properties) Whether to enable development property defaults. true () spring.devtools.livereload.enabled(#application-properties.devtools.spring.devtools.livereload.enabled) Whether to enable a livereload.com-compatible server. true () spring.devtools.livereload.port(#application-properties.devtools.spring.devtools.livereload.port) Server port. 35729 () spring.devtools.remote.context-path(#application-properties.devtools.spring.devtools.remote.context-path) Context path used to handle the remote connection. /.~~spring-boot!~ () spring.devtools.remote.proxy.host(#application-properties.devtools.spring.devtools.remote.proxy.host) The host of the proxy to use to connect to the remote application. () spring.devtools.remote.proxy.port(#application-properties.devtools.spring.devtools.remote.proxy.port) The port of the proxy to use to connect to the remote application. () spring.devtools.remote.restart.enabled(#application-properties.devtools.spring.devtools.remote.restart.enabled) Whether to enable remote restart. true () spring.devtools.remote.secret(#application-properties.devtools.spring.devtools.remote.secret) A shared secret required to establish a connection (required to enable remote support). () spring.devtools.remote.secret-header-name(#application-properties.devtools.spring.devtools.remote.secret-header-name) HTTP header used to transfer the shared secret. X-AUTH-TOKEN () spring.devtools.restart.additional-exclude(#application-properties.devtools.spring.devtools.restart.additional-exclude) Additional patterns that should be excluded from triggering a full restart. () spring.devtools.restart.additional-paths(#application-properties.devtools.spring.devtools.restart.additional-paths) Additional paths to watch for changes. () spring.devtools.restart.enabled(#application-properties.devtools.spring.devtools.restart.enabled) Whether to enable automatic restart. true () spring.devtools.restart.exclude(#application-properties.devtools.spring.devtools.restart.exclude) Patterns that should be excluded from triggering a full restart. META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties () spring.devtools.restart.log-condition-evaluation-delta(#application-properties.devtools.spring.devtools.restart.log-condition-evaluation-delta) Whether to log the condition evaluation delta upon restart. true () spring.devtools.restart.poll-interval(#application-properties.devtools.spring.devtools.restart.poll-interval) Amount of time to wait between polling for classpath changes. 1s () spring.devtools.restart.quiet-period(#application-properties.devtools.spring.devtools.restart.quiet-period) Amount of quiet time required without any classpath changes before a restart is triggered. 400ms () spring.devtools.restart.trigger-file(#application-properties.devtools.spring.devtools.restart.trigger-file) Name of a specific file that, when changed, triggers the restart check. Must be a simple name (without any path) of a file that appears on your classpath. If not specified, any classpath file change triggers the restart. Docker Compose Properties: Name Description Default Value () spring.docker.compose.enabled(#application-properties.docker-compose.spring.docker.compose.enabled) Whether docker compose support is enabled. true () spring.docker.compose.file(#application-properties.docker-compose.spring.docker.compose.file) Path to a specific docker compose configuration file. () spring.docker.compose.host(#application-properties.docker-compose.spring.docker.compose.host) Hostname or IP of the machine where the docker containers are started. () spring.docker.compose.lifecycle-management(#application-properties.docker-compose.spring.docker.compose.lifecycle-management) Docker compose lifecycle management. start-and-stop () spring.docker.compose.profiles.active(#application-properties.docker-compose.spring.docker.compose.profiles.active) Docker compose profiles that should be active. () spring.docker.compose.readiness.tcp.connect-timeout(#application-properties.docker-compose.spring.docker.compose.readiness.tcp.connect-timeout) Timeout for connections. 200ms () spring.docker.compose.readiness.tcp.read-timeout(#application-properties.docker-compose.spring.docker.compose.readiness.tcp.read-timeout) Timeout for reads. 200ms () spring.docker.compose.readiness.timeout(#application-properties.docker-compose.spring.docker.compose.readiness.timeout) Timeout of the readiness checks. 2m () spring.docker.compose.readiness.wait(#application-properties.docker-compose.spring.docker.compose.readiness.wait) Wait strategy to use. always () spring.docker.compose.skip.in-tests(#application-properties.docker-compose.spring.docker.compose.skip.in-tests) Whether to skip in tests. true () spring.docker.compose.start.command(#application-properties.docker-compose.spring.docker.compose.start.command) Command used to start docker compose. up () spring.docker.compose.start.log-level(#application-properties.docker-compose.spring.docker.compose.start.log-level) Log level for output. info () spring.docker.compose.start.skip(#application-properties.docker-compose.spring.docker.compose.start.skip) Whether to skip executing the start command. if-running () spring.docker.compose.stop.command(#application-properties.docker-compose.spring.docker.compose.stop.command) Command used to stop docker compose. stop () spring.docker.compose.stop.timeout(#application-properties.docker-compose.spring.docker.compose.stop.timeout) Timeout for stopping Docker Compose. Use '0' for forced stop. 10s Testcontainers Properties: Name Description Default Value () spring.testcontainers.beans.startup(#application-properties.testcontainers.spring.testcontainers.beans.startup) Testcontainers startup modes. sequential Testing Properties: Name Description Default Value () spring.test.database.replace(#application-properties.testing.spring.test.database.replace) Type of existing DataSource to replace. any () spring.test.mockmvc.print(#application-properties.testing.spring.test.mockmvc.print) MVC Print option. default () spring.test.observability.auto-configure(#application-properties.testing.spring.test.observability.auto-configure) Whether observability should be auto-configured in tests. false"
"https://docs.spring.io/spring-boot/appendix/auto-configuration-classes/index.html","Auto-configuration Classes: This appendix contains details of all of the auto-configuration classes provided by Spring Boot, with links to documentation and source code. Remember to also look at the conditions report in your application for more details of which features are switched on. (To do so, start the app with --debug or -Ddebug or, in an Actuator application, use the conditions endpoint)."
"https://docs.spring.io/spring-boot/appendix/auto-configuration-classes/core.html","spring-boot-autoconfigure: The following auto-configuration classes are from the spring-boot-autoconfigure module: Configuration Class Links ActiveMQAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQAutoConfiguration.html) AopAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/aop/AopAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/aop/AopAutoConfiguration.html) ApplicationAvailabilityAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/availability/ApplicationAvailabilityAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/availability/ApplicationAvailabilityAutoConfiguration.html) ArtemisAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisAutoConfiguration.html) BatchAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.html) CacheAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/cache/CacheAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/cache/CacheAutoConfiguration.html) CassandraAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/cassandra/CassandraAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/cassandra/CassandraAutoConfiguration.html) CassandraDataAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/cassandra/CassandraDataAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/cassandra/CassandraDataAutoConfiguration.html) CassandraReactiveDataAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/cassandra/CassandraReactiveDataAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/cassandra/CassandraReactiveDataAutoConfiguration.html) CassandraReactiveRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/cassandra/CassandraReactiveRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/cassandra/CassandraReactiveRepositoriesAutoConfiguration.html) CassandraRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/cassandra/CassandraRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/cassandra/CassandraRepositoriesAutoConfiguration.html) ClientHttpConnectorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/reactive/function/client/ClientHttpConnectorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/reactive/function/client/ClientHttpConnectorAutoConfiguration.html) CodecsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/http/codec/CodecsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/http/codec/CodecsAutoConfiguration.html) ConfigurationPropertiesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/ConfigurationPropertiesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/context/ConfigurationPropertiesAutoConfiguration.html) CouchbaseAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/couchbase/CouchbaseAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/couchbase/CouchbaseAutoConfiguration.html) CouchbaseDataAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/couchbase/CouchbaseDataAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/couchbase/CouchbaseDataAutoConfiguration.html) CouchbaseReactiveDataAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/couchbase/CouchbaseReactiveDataAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/couchbase/CouchbaseReactiveDataAutoConfiguration.html) CouchbaseReactiveRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/couchbase/CouchbaseReactiveRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/couchbase/CouchbaseReactiveRepositoriesAutoConfiguration.html) CouchbaseRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/couchbase/CouchbaseRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/couchbase/CouchbaseRepositoriesAutoConfiguration.html) DataSourceAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.html) DataSourceTransactionManagerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceTransactionManagerAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jdbc/DataSourceTransactionManagerAutoConfiguration.html) DispatcherServletAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/DispatcherServletAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/servlet/DispatcherServletAutoConfiguration.html) ElasticsearchClientAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/elasticsearch/ElasticsearchClientAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/elasticsearch/ElasticsearchClientAutoConfiguration.html) ElasticsearchDataAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/elasticsearch/ElasticsearchDataAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/elasticsearch/ElasticsearchDataAutoConfiguration.html) ElasticsearchRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/elasticsearch/ElasticsearchRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/elasticsearch/ElasticsearchRepositoriesAutoConfiguration.html) ElasticsearchRestClientAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/elasticsearch/ElasticsearchRestClientAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/elasticsearch/ElasticsearchRestClientAutoConfiguration.html) EmbeddedLdapAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/ldap/embedded/EmbeddedLdapAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/ldap/embedded/EmbeddedLdapAutoConfiguration.html) EmbeddedWebServerFactoryCustomizerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/embedded/EmbeddedWebServerFactoryCustomizerAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/embedded/EmbeddedWebServerFactoryCustomizerAutoConfiguration.html) ErrorMvcAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration.html) ErrorWebFluxAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/reactive/error/ErrorWebFluxAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/reactive/error/ErrorWebFluxAutoConfiguration.html) FlywayAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration.html) FreeMarkerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/freemarker/FreeMarkerAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/freemarker/FreeMarkerAutoConfiguration.html) GraphQlAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/graphql/GraphQlAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/graphql/GraphQlAutoConfiguration.html) GraphQlQueryByExampleAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/graphql/data/GraphQlQueryByExampleAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/graphql/data/GraphQlQueryByExampleAutoConfiguration.html) GraphQlQuerydslAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/graphql/data/GraphQlQuerydslAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/graphql/data/GraphQlQuerydslAutoConfiguration.html) GraphQlRSocketAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/graphql/rsocket/GraphQlRSocketAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/graphql/rsocket/GraphQlRSocketAutoConfiguration.html) GraphQlReactiveQueryByExampleAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/graphql/data/GraphQlReactiveQueryByExampleAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/graphql/data/GraphQlReactiveQueryByExampleAutoConfiguration.html) GraphQlReactiveQuerydslAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/graphql/data/GraphQlReactiveQuerydslAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/graphql/data/GraphQlReactiveQuerydslAutoConfiguration.html) GraphQlWebFluxAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/graphql/reactive/GraphQlWebFluxAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/graphql/reactive/GraphQlWebFluxAutoConfiguration.html) GraphQlWebFluxSecurityAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/graphql/security/GraphQlWebFluxSecurityAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/graphql/security/GraphQlWebFluxSecurityAutoConfiguration.html) GraphQlWebMvcAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/graphql/servlet/GraphQlWebMvcAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/graphql/servlet/GraphQlWebMvcAutoConfiguration.html) GraphQlWebMvcSecurityAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/graphql/security/GraphQlWebMvcSecurityAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/graphql/security/GraphQlWebMvcSecurityAutoConfiguration.html) GroovyTemplateAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/groovy/template/GroovyTemplateAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/groovy/template/GroovyTemplateAutoConfiguration.html) GsonAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/gson/GsonAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/gson/GsonAutoConfiguration.html) H2ConsoleAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/h2/H2ConsoleAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/h2/H2ConsoleAutoConfiguration.html) HazelcastAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/hazelcast/HazelcastAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/hazelcast/HazelcastAutoConfiguration.html) HazelcastJpaDependencyAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/hazelcast/HazelcastJpaDependencyAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/hazelcast/HazelcastJpaDependencyAutoConfiguration.html) HibernateJpaAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.html) HttpEncodingAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/HttpEncodingAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/servlet/HttpEncodingAutoConfiguration.html) HttpHandlerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/reactive/HttpHandlerAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/reactive/HttpHandlerAutoConfiguration.html) HttpMessageConvertersAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/http/HttpMessageConvertersAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/http/HttpMessageConvertersAutoConfiguration.html) HypermediaAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/hateoas/HypermediaAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/hateoas/HypermediaAutoConfiguration.html) InfluxDbAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/influx/InfluxDbAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/influx/InfluxDbAutoConfiguration.html) IntegrationAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.html) JacksonAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.html) JdbcClientAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/JdbcClientAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jdbc/JdbcClientAutoConfiguration.html) JdbcRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/jdbc/JdbcRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/jdbc/JdbcRepositoriesAutoConfiguration.html) JdbcTemplateAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/JdbcTemplateAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jdbc/JdbcTemplateAutoConfiguration.html) JerseyAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jersey/JerseyAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jersey/JerseyAutoConfiguration.html) JmsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/JmsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jms/JmsAutoConfiguration.html) JmxAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.html) JndiConnectionFactoryAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/JndiConnectionFactoryAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jms/JndiConnectionFactoryAutoConfiguration.html) JndiDataSourceAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/JndiDataSourceAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jdbc/JndiDataSourceAutoConfiguration.html) JooqAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jooq/JooqAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jooq/JooqAutoConfiguration.html) JpaRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/jpa/JpaRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/jpa/JpaRepositoriesAutoConfiguration.html) JsonbAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jsonb/JsonbAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jsonb/JsonbAutoConfiguration.html) JtaAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/transaction/jta/JtaAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/transaction/jta/JtaAutoConfiguration.html) KafkaAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/kafka/KafkaAutoConfiguration.html) LdapAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/ldap/LdapAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/ldap/LdapAutoConfiguration.html) LdapRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/ldap/LdapRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/ldap/LdapRepositoriesAutoConfiguration.html) LifecycleAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/LifecycleAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/context/LifecycleAutoConfiguration.html) LiquibaseAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/liquibase/LiquibaseAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/liquibase/LiquibaseAutoConfiguration.html) MailSenderAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailSenderAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/mail/MailSenderAutoConfiguration.html) MailSenderValidatorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailSenderValidatorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/mail/MailSenderValidatorAutoConfiguration.html) MessageSourceAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/MessageSourceAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/context/MessageSourceAutoConfiguration.html) MongoAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mongo/MongoAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/mongo/MongoAutoConfiguration.html) MongoDataAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/mongo/MongoDataAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/mongo/MongoDataAutoConfiguration.html) MongoReactiveAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mongo/MongoReactiveAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/mongo/MongoReactiveAutoConfiguration.html) MongoReactiveDataAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/mongo/MongoReactiveDataAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/mongo/MongoReactiveDataAutoConfiguration.html) MongoReactiveRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/mongo/MongoReactiveRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/mongo/MongoReactiveRepositoriesAutoConfiguration.html) MongoRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/mongo/MongoRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/mongo/MongoRepositoriesAutoConfiguration.html) MultipartAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/MultipartAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/servlet/MultipartAutoConfiguration.html) MustacheAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mustache/MustacheAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/mustache/MustacheAutoConfiguration.html) Neo4jAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/neo4j/Neo4jAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/neo4j/Neo4jAutoConfiguration.html) Neo4jDataAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/neo4j/Neo4jDataAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/neo4j/Neo4jDataAutoConfiguration.html) Neo4jReactiveDataAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/neo4j/Neo4jReactiveDataAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/neo4j/Neo4jReactiveDataAutoConfiguration.html) Neo4jReactiveRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/neo4j/Neo4jReactiveRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/neo4j/Neo4jReactiveRepositoriesAutoConfiguration.html) Neo4jRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/neo4j/Neo4jRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/neo4j/Neo4jRepositoriesAutoConfiguration.html) NettyAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/netty/NettyAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/netty/NettyAutoConfiguration.html) OAuth2AuthorizationServerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/oauth2/server/servlet/OAuth2AuthorizationServerAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/oauth2/server/servlet/OAuth2AuthorizationServerAutoConfiguration.html) OAuth2AuthorizationServerJwtAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/oauth2/server/servlet/OAuth2AuthorizationServerJwtAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/oauth2/server/servlet/OAuth2AuthorizationServerJwtAutoConfiguration.html) OAuth2ClientAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/oauth2/client/servlet/OAuth2ClientAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/oauth2/client/servlet/OAuth2ClientAutoConfiguration.html) OAuth2ResourceServerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/oauth2/resource/servlet/OAuth2ResourceServerAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/oauth2/resource/servlet/OAuth2ResourceServerAutoConfiguration.html) PersistenceExceptionTranslationAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/dao/PersistenceExceptionTranslationAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/dao/PersistenceExceptionTranslationAutoConfiguration.html) ProjectInfoAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/info/ProjectInfoAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/info/ProjectInfoAutoConfiguration.html) PropertyPlaceholderAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/PropertyPlaceholderAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/context/PropertyPlaceholderAutoConfiguration.html) PulsarAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/pulsar/PulsarAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/pulsar/PulsarAutoConfiguration.html) PulsarReactiveAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/pulsar/PulsarReactiveAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/pulsar/PulsarReactiveAutoConfiguration.html) QuartzAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/quartz/QuartzAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/quartz/QuartzAutoConfiguration.html) R2dbcAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/r2dbc/R2dbcAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/r2dbc/R2dbcAutoConfiguration.html) R2dbcDataAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/r2dbc/R2dbcDataAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/r2dbc/R2dbcDataAutoConfiguration.html) R2dbcRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/r2dbc/R2dbcRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/r2dbc/R2dbcRepositoriesAutoConfiguration.html) R2dbcTransactionManagerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/r2dbc/R2dbcTransactionManagerAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/r2dbc/R2dbcTransactionManagerAutoConfiguration.html) RSocketGraphQlClientAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/graphql/rsocket/RSocketGraphQlClientAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/graphql/rsocket/RSocketGraphQlClientAutoConfiguration.html) RSocketMessagingAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/rsocket/RSocketMessagingAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/rsocket/RSocketMessagingAutoConfiguration.html) RSocketRequesterAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/rsocket/RSocketRequesterAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/rsocket/RSocketRequesterAutoConfiguration.html) RSocketSecurityAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/rsocket/RSocketSecurityAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/rsocket/RSocketSecurityAutoConfiguration.html) RSocketServerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/rsocket/RSocketServerAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/rsocket/RSocketServerAutoConfiguration.html) RSocketStrategiesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/rsocket/RSocketStrategiesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/rsocket/RSocketStrategiesAutoConfiguration.html) RabbitAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/amqp/RabbitAutoConfiguration.html) ReactiveElasticsearchClientAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/elasticsearch/ReactiveElasticsearchClientAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/elasticsearch/ReactiveElasticsearchClientAutoConfiguration.html) ReactiveElasticsearchRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/elasticsearch/ReactiveElasticsearchRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/elasticsearch/ReactiveElasticsearchRepositoriesAutoConfiguration.html) ReactiveMultipartAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/reactive/ReactiveMultipartAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/reactive/ReactiveMultipartAutoConfiguration.html) ReactiveOAuth2ClientAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/oauth2/client/reactive/ReactiveOAuth2ClientAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/oauth2/client/reactive/ReactiveOAuth2ClientAutoConfiguration.html) ReactiveOAuth2ResourceServerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/oauth2/resource/reactive/ReactiveOAuth2ResourceServerAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/oauth2/resource/reactive/ReactiveOAuth2ResourceServerAutoConfiguration.html) ReactiveSecurityAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/reactive/ReactiveSecurityAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/reactive/ReactiveSecurityAutoConfiguration.html) ReactiveUserDetailsServiceAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/reactive/ReactiveUserDetailsServiceAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/reactive/ReactiveUserDetailsServiceAutoConfiguration.html) ReactiveWebServerFactoryAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/reactive/ReactiveWebServerFactoryAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/reactive/ReactiveWebServerFactoryAutoConfiguration.html) ReactorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/reactor/ReactorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/reactor/ReactorAutoConfiguration.html) RedisAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/redis/RedisAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/redis/RedisAutoConfiguration.html) RedisReactiveAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/redis/RedisReactiveAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/redis/RedisReactiveAutoConfiguration.html) RedisRepositoriesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/redis/RedisRepositoriesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/redis/RedisRepositoriesAutoConfiguration.html) RepositoryRestMvcAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/rest/RepositoryRestMvcAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/rest/RepositoryRestMvcAutoConfiguration.html) RestClientAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/client/RestClientAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/client/RestClientAutoConfiguration.html) RestTemplateAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/client/RestTemplateAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/client/RestTemplateAutoConfiguration.html) Saml2RelyingPartyAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/saml2/Saml2RelyingPartyAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/saml2/Saml2RelyingPartyAutoConfiguration.html) SecurityAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/servlet/SecurityAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/servlet/SecurityAutoConfiguration.html) SecurityFilterAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/servlet/SecurityFilterAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/servlet/SecurityFilterAutoConfiguration.html) SendGridAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/sendgrid/SendGridAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/sendgrid/SendGridAutoConfiguration.html) ServletWebServerFactoryAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/ServletWebServerFactoryAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/servlet/ServletWebServerFactoryAutoConfiguration.html) SessionAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/session/SessionAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/session/SessionAutoConfiguration.html) SpringApplicationAdminJmxAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/admin/SpringApplicationAdminJmxAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/admin/SpringApplicationAdminJmxAutoConfiguration.html) SpringDataWebAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/web/SpringDataWebAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/data/web/SpringDataWebAutoConfiguration.html) SqlInitializationAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/sql/init/SqlInitializationAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/sql/init/SqlInitializationAutoConfiguration.html) SslAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/ssl/SslAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/ssl/SslAutoConfiguration.html) TaskExecutionAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/task/TaskExecutionAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/task/TaskExecutionAutoConfiguration.html) TaskSchedulingAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/task/TaskSchedulingAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/task/TaskSchedulingAutoConfiguration.html) ThymeleafAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/thymeleaf/ThymeleafAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/thymeleaf/ThymeleafAutoConfiguration.html) TransactionAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/transaction/TransactionAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/transaction/TransactionAutoConfiguration.html) TransactionManagerCustomizationAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/transaction/TransactionManagerCustomizationAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/transaction/TransactionManagerCustomizationAutoConfiguration.html) UserDetailsServiceAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/servlet/UserDetailsServiceAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/security/servlet/UserDetailsServiceAutoConfiguration.html) ValidationAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/validation/ValidationAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/validation/ValidationAutoConfiguration.html) WebClientAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/reactive/function/client/WebClientAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/reactive/function/client/WebClientAutoConfiguration.html) WebFluxAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/reactive/WebFluxAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/reactive/WebFluxAutoConfiguration.html) WebMvcAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.html) WebServiceTemplateAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/webservices/client/WebServiceTemplateAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/webservices/client/WebServiceTemplateAutoConfiguration.html) WebServicesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/webservices/WebServicesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/webservices/WebServicesAutoConfiguration.html) WebSessionIdResolverAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/reactive/WebSessionIdResolverAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/web/reactive/WebSessionIdResolverAutoConfiguration.html) WebSocketMessagingAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/websocket/servlet/WebSocketMessagingAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/websocket/servlet/WebSocketMessagingAutoConfiguration.html) WebSocketReactiveAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/websocket/reactive/WebSocketReactiveAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/websocket/reactive/WebSocketReactiveAutoConfiguration.html) WebSocketServletAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/websocket/servlet/WebSocketServletAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/websocket/servlet/WebSocketServletAutoConfiguration.html) XADataSourceAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/XADataSourceAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/autoconfigure/jdbc/XADataSourceAutoConfiguration.html)"
"https://docs.spring.io/spring-boot/appendix/auto-configuration-classes/actuator.html","spring-boot-actuator-autoconfigure: The following auto-configuration classes are from the spring-boot-actuator-autoconfigure module: Configuration Class Links AppOpticsMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/appoptics/AppOpticsMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/appoptics/AppOpticsMetricsExportAutoConfiguration.html) AtlasMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/atlas/AtlasMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/atlas/AtlasMetricsExportAutoConfiguration.html) AuditAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/audit/AuditAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/audit/AuditAutoConfiguration.html) AuditEventsEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/audit/AuditEventsEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/audit/AuditEventsEndpointAutoConfiguration.html) AvailabilityHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/availability/AvailabilityHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/availability/AvailabilityHealthContributorAutoConfiguration.html) AvailabilityProbesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/availability/AvailabilityProbesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/availability/AvailabilityProbesAutoConfiguration.html) BatchObservationAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/observation/batch/BatchObservationAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/observation/batch/BatchObservationAutoConfiguration.html) BeansEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/beans/BeansEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/beans/BeansEndpointAutoConfiguration.html) BraveAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/tracing/BraveAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/tracing/BraveAutoConfiguration.html) CacheMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/cache/CacheMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/cache/CacheMetricsAutoConfiguration.html) CachesEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cache/CachesEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/cache/CachesEndpointAutoConfiguration.html) CassandraHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cassandra/CassandraHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/cassandra/CassandraHealthContributorAutoConfiguration.html) CassandraReactiveHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cassandra/CassandraReactiveHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/cassandra/CassandraReactiveHealthContributorAutoConfiguration.html) CloudFoundryActuatorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cloudfoundry/servlet/CloudFoundryActuatorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/cloudfoundry/servlet/CloudFoundryActuatorAutoConfiguration.html) CompositeMeterRegistryAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/CompositeMeterRegistryAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/CompositeMeterRegistryAutoConfiguration.html) ConditionsReportEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/condition/ConditionsReportEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/condition/ConditionsReportEndpointAutoConfiguration.html) ConfigurationPropertiesReportEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/context/properties/ConfigurationPropertiesReportEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/context/properties/ConfigurationPropertiesReportEndpointAutoConfiguration.html) ConnectionFactoryHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/r2dbc/ConnectionFactoryHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/r2dbc/ConnectionFactoryHealthContributorAutoConfiguration.html) ConnectionPoolMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/r2dbc/ConnectionPoolMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/r2dbc/ConnectionPoolMetricsAutoConfiguration.html) CouchbaseHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/couchbase/CouchbaseHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/couchbase/CouchbaseHealthContributorAutoConfiguration.html) CouchbaseReactiveHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/couchbase/CouchbaseReactiveHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/couchbase/CouchbaseReactiveHealthContributorAutoConfiguration.html) DataSourceHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/jdbc/DataSourceHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/jdbc/DataSourceHealthContributorAutoConfiguration.html) DataSourcePoolMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/jdbc/DataSourcePoolMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/jdbc/DataSourcePoolMetricsAutoConfiguration.html) DatadogMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/datadog/DatadogMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/datadog/DatadogMetricsExportAutoConfiguration.html) DiskSpaceHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/system/DiskSpaceHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/system/DiskSpaceHealthContributorAutoConfiguration.html) DynatraceMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/dynatrace/DynatraceMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/dynatrace/DynatraceMetricsExportAutoConfiguration.html) ElasticMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/elastic/ElasticMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/elastic/ElasticMetricsExportAutoConfiguration.html) ElasticsearchReactiveHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/data/elasticsearch/ElasticsearchReactiveHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/data/elasticsearch/ElasticsearchReactiveHealthContributorAutoConfiguration.html) ElasticsearchRestHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/elasticsearch/ElasticsearchRestHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/elasticsearch/ElasticsearchRestHealthContributorAutoConfiguration.html) EndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/EndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/endpoint/EndpointAutoConfiguration.html) EnvironmentEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/env/EnvironmentEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/env/EnvironmentEndpointAutoConfiguration.html) FlywayEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/flyway/FlywayEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/flyway/FlywayEndpointAutoConfiguration.html) GangliaMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/ganglia/GangliaMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/ganglia/GangliaMetricsExportAutoConfiguration.html) GraphQlObservationAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/observation/graphql/GraphQlObservationAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/observation/graphql/GraphQlObservationAutoConfiguration.html) GraphiteMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/graphite/GraphiteMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/graphite/GraphiteMetricsExportAutoConfiguration.html) HazelcastHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/hazelcast/HazelcastHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/hazelcast/HazelcastHealthContributorAutoConfiguration.html) HealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/health/HealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/health/HealthContributorAutoConfiguration.html) HealthEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/health/HealthEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/health/HealthEndpointAutoConfiguration.html) HeapDumpWebEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/management/HeapDumpWebEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/management/HeapDumpWebEndpointAutoConfiguration.html) HibernateMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/orm/jpa/HibernateMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/orm/jpa/HibernateMetricsAutoConfiguration.html) HttpClientObservationsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/observation/web/client/HttpClientObservationsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/observation/web/client/HttpClientObservationsAutoConfiguration.html) HttpExchangesAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/web/exchanges/HttpExchangesAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/web/exchanges/HttpExchangesAutoConfiguration.html) HttpExchangesEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/web/exchanges/HttpExchangesEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/web/exchanges/HttpExchangesEndpointAutoConfiguration.html) HumioMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/humio/HumioMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/humio/HumioMetricsExportAutoConfiguration.html) InfluxDbHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/influx/InfluxDbHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/influx/InfluxDbHealthContributorAutoConfiguration.html) InfluxMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/influx/InfluxMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/influx/InfluxMetricsExportAutoConfiguration.html) InfoContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/info/InfoContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/info/InfoContributorAutoConfiguration.html) InfoEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/info/InfoEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/info/InfoEndpointAutoConfiguration.html) IntegrationGraphEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/integration/IntegrationGraphEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/integration/IntegrationGraphEndpointAutoConfiguration.html) JacksonEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/jackson/JacksonEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/endpoint/jackson/JacksonEndpointAutoConfiguration.html) JerseyServerMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/jersey/JerseyServerMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/jersey/JerseyServerMetricsAutoConfiguration.html) JettyMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/web/jetty/JettyMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/web/jetty/JettyMetricsAutoConfiguration.html) JmsHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/jms/JmsHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/jms/JmsHealthContributorAutoConfiguration.html) JmxEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/jmx/JmxEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/endpoint/jmx/JmxEndpointAutoConfiguration.html) JmxMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/jmx/JmxMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/jmx/JmxMetricsExportAutoConfiguration.html) JvmMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/JvmMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/JvmMetricsAutoConfiguration.html) KafkaMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/KafkaMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/KafkaMetricsAutoConfiguration.html) KairosMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/kairos/KairosMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/kairos/KairosMetricsExportAutoConfiguration.html) LdapHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/ldap/LdapHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/ldap/LdapHealthContributorAutoConfiguration.html) LettuceMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/redis/LettuceMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/redis/LettuceMetricsAutoConfiguration.html) LiquibaseEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/liquibase/LiquibaseEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/liquibase/LiquibaseEndpointAutoConfiguration.html) Log4J2MetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/Log4J2MetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/Log4J2MetricsAutoConfiguration.html) LogFileWebEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/logging/LogFileWebEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/logging/LogFileWebEndpointAutoConfiguration.html) LogbackMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/LogbackMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/LogbackMetricsAutoConfiguration.html) LoggersEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/logging/LoggersEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/logging/LoggersEndpointAutoConfiguration.html) MailHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/mail/MailHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/mail/MailHealthContributorAutoConfiguration.html) ManagementContextAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/web/server/ManagementContextAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/web/server/ManagementContextAutoConfiguration.html) ManagementWebSecurityAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/security/servlet/ManagementWebSecurityAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/security/servlet/ManagementWebSecurityAutoConfiguration.html) MappingsEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/web/mappings/MappingsEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/web/mappings/MappingsEndpointAutoConfiguration.html) MetricsAspectsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/MetricsAspectsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/MetricsAspectsAutoConfiguration.html) MetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/MetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/MetricsAutoConfiguration.html) MetricsEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/MetricsEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/MetricsEndpointAutoConfiguration.html) MicrometerTracingAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/tracing/MicrometerTracingAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/tracing/MicrometerTracingAutoConfiguration.html) MongoHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/data/mongo/MongoHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/data/mongo/MongoHealthContributorAutoConfiguration.html) MongoMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/mongo/MongoMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/mongo/MongoMetricsAutoConfiguration.html) MongoReactiveHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/data/mongo/MongoReactiveHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/data/mongo/MongoReactiveHealthContributorAutoConfiguration.html) Neo4jHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/neo4j/Neo4jHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/neo4j/Neo4jHealthContributorAutoConfiguration.html) NewRelicMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/newrelic/NewRelicMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/newrelic/NewRelicMetricsExportAutoConfiguration.html) NoopTracerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/tracing/NoopTracerAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/tracing/NoopTracerAutoConfiguration.html) ObservationAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/observation/ObservationAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/observation/ObservationAutoConfiguration.html) OpenTelemetryAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/opentelemetry/OpenTelemetryAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/opentelemetry/OpenTelemetryAutoConfiguration.html) OtlpAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/tracing/otlp/OtlpAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/tracing/otlp/OtlpAutoConfiguration.html) OtlpMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/otlp/OtlpMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/otlp/OtlpMetricsExportAutoConfiguration.html) PrometheusExemplarsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/tracing/prometheus/PrometheusExemplarsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/tracing/prometheus/PrometheusExemplarsAutoConfiguration.html) PrometheusMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/prometheus/PrometheusMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/prometheus/PrometheusMetricsExportAutoConfiguration.html) PrometheusSimpleclientExemplarsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/tracing/prometheus/PrometheusSimpleclientExemplarsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/tracing/prometheus/PrometheusSimpleclientExemplarsAutoConfiguration.html) PrometheusSimpleclientMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/prometheus/PrometheusSimpleclientMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/prometheus/PrometheusSimpleclientMetricsExportAutoConfiguration.html) QuartzEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/quartz/QuartzEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/quartz/QuartzEndpointAutoConfiguration.html) R2dbcObservationAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/r2dbc/R2dbcObservationAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/r2dbc/R2dbcObservationAutoConfiguration.html) RabbitHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/amqp/RabbitHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/amqp/RabbitHealthContributorAutoConfiguration.html) RabbitMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/amqp/RabbitMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/amqp/RabbitMetricsAutoConfiguration.html) ReactiveCloudFoundryActuatorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/cloudfoundry/reactive/ReactiveCloudFoundryActuatorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/cloudfoundry/reactive/ReactiveCloudFoundryActuatorAutoConfiguration.html) ReactiveManagementContextAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/web/reactive/ReactiveManagementContextAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/web/reactive/ReactiveManagementContextAutoConfiguration.html) ReactiveManagementWebSecurityAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/security/reactive/ReactiveManagementWebSecurityAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/security/reactive/ReactiveManagementWebSecurityAutoConfiguration.html) RedisHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/data/redis/RedisHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/data/redis/RedisHealthContributorAutoConfiguration.html) RedisReactiveHealthContributorAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/data/redis/RedisReactiveHealthContributorAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/data/redis/RedisReactiveHealthContributorAutoConfiguration.html) RepositoryMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/data/RepositoryMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/data/RepositoryMetricsAutoConfiguration.html) SbomEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/sbom/SbomEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/sbom/SbomEndpointAutoConfiguration.html) ScheduledTasksEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/scheduling/ScheduledTasksEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/scheduling/ScheduledTasksEndpointAutoConfiguration.html) ScheduledTasksObservabilityAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/scheduling/ScheduledTasksObservabilityAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/scheduling/ScheduledTasksObservabilityAutoConfiguration.html) ServletManagementContextAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/web/servlet/ServletManagementContextAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/web/servlet/ServletManagementContextAutoConfiguration.html) SessionsEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/session/SessionsEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/session/SessionsEndpointAutoConfiguration.html) ShutdownEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/context/ShutdownEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/context/ShutdownEndpointAutoConfiguration.html) SignalFxMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/signalfx/SignalFxMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/signalfx/SignalFxMetricsExportAutoConfiguration.html) SimpleMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/simple/SimpleMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/simple/SimpleMetricsExportAutoConfiguration.html) StackdriverMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/stackdriver/StackdriverMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/stackdriver/StackdriverMetricsExportAutoConfiguration.html) StartupEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/startup/StartupEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/startup/StartupEndpointAutoConfiguration.html) StartupTimeMetricsListenerAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/startup/StartupTimeMetricsListenerAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/startup/StartupTimeMetricsListenerAutoConfiguration.html) StatsdMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/statsd/StatsdMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/statsd/StatsdMetricsExportAutoConfiguration.html) SystemMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/SystemMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/SystemMetricsAutoConfiguration.html) TaskExecutorMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/task/TaskExecutorMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/task/TaskExecutorMetricsAutoConfiguration.html) ThreadDumpEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/management/ThreadDumpEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/management/ThreadDumpEndpointAutoConfiguration.html) TomcatMetricsAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/web/tomcat/TomcatMetricsAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/web/tomcat/TomcatMetricsAutoConfiguration.html) WavefrontAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/wavefront/WavefrontAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/wavefront/WavefrontAutoConfiguration.html) WavefrontMetricsExportAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/metrics/export/wavefront/WavefrontMetricsExportAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/metrics/export/wavefront/WavefrontMetricsExportAutoConfiguration.html) WavefrontTracingAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/tracing/wavefront/WavefrontTracingAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/tracing/wavefront/WavefrontTracingAutoConfiguration.html) WebEndpointAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/WebEndpointAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/WebEndpointAutoConfiguration.html) WebFluxObservationAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/observation/web/reactive/WebFluxObservationAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/observation/web/reactive/WebFluxObservationAutoConfiguration.html) WebMvcObservationAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/observation/web/servlet/WebMvcObservationAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/observation/web/servlet/WebMvcObservationAutoConfiguration.html) ZipkinAutoConfiguration(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/tracing/zipkin/ZipkinAutoConfiguration.java) javadoc(../../api/java/org/springframework/boot/actuate/autoconfigure/tracing/zipkin/ZipkinAutoConfiguration.html)"
"https://docs.spring.io/spring-boot/appendix/test-auto-configuration/index.html","Test Auto-configuration Annotations: This appendix describes the @…​Test auto-configuration annotations that Spring Boot provides to test slices of your application."
"https://docs.spring.io/spring-boot/appendix/test-auto-configuration/slices.html","Test Slices: The following table lists the various @…​Test annotations that can be used to test slices of your application and the auto-configuration that they import by default: Test slice Imported auto-configuration @DataCassandraTest optional:org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.ssl.SslAutoConfiguration @DataCouchbaseTest optional:org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.ssl.SslAutoConfiguration @DataElasticsearchTest optional:org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchClientAutoConfiguration org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration org.springframework.boot.autoconfigure.elasticsearch.ReactiveElasticsearchClientAutoConfiguration org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration org.springframework.boot.autoconfigure.ssl.SslAutoConfiguration @DataJdbcTest optional:org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration org.springframework.boot.autoconfigure.jdbc.JdbcClientAutoConfiguration org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration @DataJpaTest optional:org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration org.springframework.boot.autoconfigure.jdbc.JdbcClientAutoConfiguration org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManagerAutoConfiguration @DataLdapTest optional:org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration @DataMongoTest optional:org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration org.springframework.boot.autoconfigure.ssl.SslAutoConfiguration org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration @DataNeo4jTest optional:org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveDataAutoConfiguration org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.neo4j.Neo4jAutoConfiguration org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration @DataR2dbcTest optional:org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration org.springframework.boot.autoconfigure.r2dbc.R2dbcTransactionManagerAutoConfiguration org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration @DataRedisTest optional:org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration org.springframework.boot.autoconfigure.ssl.SslAutoConfiguration @GraphQlTest org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.graphql.GraphQlAutoConfiguration org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration org.springframework.boot.test.autoconfigure.graphql.tester.GraphQlTesterAutoConfiguration @JdbcTest optional:org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration org.springframework.boot.autoconfigure.jdbc.JdbcClientAutoConfiguration org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration @JooqTest optional:org.springframework.boot.testcontainers.service.connection.ServiceConnectionAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration @JsonTest org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.test.autoconfigure.json.JsonTestersAutoConfiguration @RestClientTest org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration org.springframework.boot.autoconfigure.web.client.RestClientAutoConfiguration org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration org.springframework.boot.test.autoconfigure.web.client.MockRestServiceServerAutoConfiguration org.springframework.boot.test.autoconfigure.web.client.WebClientRestTemplateAutoConfiguration @WebFluxTest org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration @WebMvcTest org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration @WebServiceClientTest org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration org.springframework.boot.test.autoconfigure.webservices.client.MockWebServiceServerAutoConfiguration org.springframework.boot.test.autoconfigure.webservices.client.WebServiceClientTemplateAutoConfiguration @WebServiceServerTest org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration org.springframework.boot.test.autoconfigure.webservices.server.MockWebServiceClientAutoConfiguration"
"https://docs.spring.io/spring-boot/appendix/dependency-versions/index.html","Dependency Versions: This appendix provides details of the dependencies that are managed by Spring Boot."
"https://docs.spring.io/spring-boot/appendix/dependency-versions/coordinates.html","Managed Dependency Coordinates: The following table provides details of all of the dependency versions that are provided by Spring Boot in its CLI (Command Line Interface), Maven dependency management, and Gradle plugin. When you declare a dependency on one of these artifacts without declaring a version, the version listed in the table is used. Group ID Artifact ID Version biz.aQute.bnd biz.aQute.bnd.annotation 7.0.0 ch.qos.logback logback-classic 1.5.8 ch.qos.logback logback-core 1.5.8 co.elastic.clients elasticsearch-java 8.13.4 com.couchbase.client java-client 3.6.3 com.datastax.oss java-driver-shaded-guava 25.1-jre-graal-sub-1 com.datastax.oss native-protocol 1.5.1 com.fasterxml classmate 1.7.0 com.fasterxml.jackson.core jackson-annotations 2.17.2 com.fasterxml.jackson.core jackson-core 2.17.2 com.fasterxml.jackson.core jackson-databind 2.17.2 com.fasterxml.jackson.dataformat jackson-dataformat-avro 2.17.2 com.fasterxml.jackson.dataformat jackson-dataformat-cbor 2.17.2 com.fasterxml.jackson.dataformat jackson-dataformat-csv 2.17.2 com.fasterxml.jackson.dataformat jackson-dataformat-ion 2.17.2 com.fasterxml.jackson.dataformat jackson-dataformat-properties 2.17.2 com.fasterxml.jackson.dataformat jackson-dataformat-protobuf 2.17.2 com.fasterxml.jackson.dataformat jackson-dataformat-smile 2.17.2 com.fasterxml.jackson.dataformat jackson-dataformat-toml 2.17.2 com.fasterxml.jackson.dataformat jackson-dataformat-xml 2.17.2 com.fasterxml.jackson.dataformat jackson-dataformat-yaml 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-eclipse-collections 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-guava 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-hibernate4 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-hibernate5 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-hibernate5-jakarta 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-hibernate6 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-hppc 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-jakarta-jsonp 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-jaxrs 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-jdk8 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-joda 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-joda-money 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-json-org 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-jsr310 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-jsr353 2.17.2 com.fasterxml.jackson.datatype jackson-datatype-pcollections 2.17.2 com.fasterxml.jackson.jakarta.rs jackson-jakarta-rs-base 2.17.2 com.fasterxml.jackson.jakarta.rs jackson-jakarta-rs-cbor-provider 2.17.2 com.fasterxml.jackson.jakarta.rs jackson-jakarta-rs-json-provider 2.17.2 com.fasterxml.jackson.jakarta.rs jackson-jakarta-rs-smile-provider 2.17.2 com.fasterxml.jackson.jakarta.rs jackson-jakarta-rs-xml-provider 2.17.2 com.fasterxml.jackson.jakarta.rs jackson-jakarta-rs-yaml-provider 2.17.2 com.fasterxml.jackson.jaxrs jackson-jaxrs-base 2.17.2 com.fasterxml.jackson.jaxrs jackson-jaxrs-cbor-provider 2.17.2 com.fasterxml.jackson.jaxrs jackson-jaxrs-json-provider 2.17.2 com.fasterxml.jackson.jaxrs jackson-jaxrs-smile-provider 2.17.2 com.fasterxml.jackson.jaxrs jackson-jaxrs-xml-provider 2.17.2 com.fasterxml.jackson.jaxrs jackson-jaxrs-yaml-provider 2.17.2 com.fasterxml.jackson.jr jackson-jr-all 2.17.2 com.fasterxml.jackson.jr jackson-jr-annotation-support 2.17.2 com.fasterxml.jackson.jr jackson-jr-extension-javatime 2.17.2 com.fasterxml.jackson.jr jackson-jr-objects 2.17.2 com.fasterxml.jackson.jr jackson-jr-retrofit2 2.17.2 com.fasterxml.jackson.jr jackson-jr-stree 2.17.2 com.fasterxml.jackson.module jackson-module-afterburner 2.17.2 com.fasterxml.jackson.module jackson-module-android-record 2.17.2 com.fasterxml.jackson.module jackson-module-blackbird 2.17.2 com.fasterxml.jackson.module jackson-module-guice 2.17.2 com.fasterxml.jackson.module jackson-module-guice7 2.17.2 com.fasterxml.jackson.module jackson-module-jakarta-xmlbind-annotations 2.17.2 com.fasterxml.jackson.module jackson-module-jaxb-annotations 2.17.2 com.fasterxml.jackson.module jackson-module-jsonSchema 2.17.2 com.fasterxml.jackson.module jackson-module-jsonSchema-jakarta 2.17.2 com.fasterxml.jackson.module jackson-module-kotlin 2.17.2 com.fasterxml.jackson.module jackson-module-mrbean 2.17.2 com.fasterxml.jackson.module jackson-module-no-ctor-deser 2.17.2 com.fasterxml.jackson.module jackson-module-osgi 2.17.2 com.fasterxml.jackson.module jackson-module-parameter-names 2.17.2 com.fasterxml.jackson.module jackson-module-paranamer 2.17.2 com.fasterxml.jackson.module jackson-module-scala_2.11 2.17.2 com.fasterxml.jackson.module jackson-module-scala_2.12 2.17.2 com.fasterxml.jackson.module jackson-module-scala_2.13 2.17.2 com.fasterxml.jackson.module jackson-module-scala_3 2.17.2 com.github.ben-manes.caffeine caffeine 3.1.8 com.github.ben-manes.caffeine guava 3.1.8 com.github.ben-manes.caffeine jcache 3.1.8 com.github.ben-manes.caffeine simulator 3.1.8 com.github.mxab.thymeleaf.extras thymeleaf-extras-data-attribute 2.0.1 com.github.spotbugs spotbugs-annotations 4.8.3 com.google.code.gson gson 2.10.1 com.graphql-java graphql-java 22.1 com.h2database h2 2.2.224 com.hazelcast hazelcast 5.4.0 com.hazelcast hazelcast-spring 5.4.0 com.ibm.db2 jcc 11.5.9.0 com.jayway.jsonpath json-path 2.9.0 com.jayway.jsonpath json-path-assert 2.9.0 com.microsoft.sqlserver mssql-jdbc 12.6.4.jre11 com.mysql mysql-connector-j 8.3.0 com.oracle.database.ha ons 21.9.0.0 com.oracle.database.ha simplefan 21.9.0.0 com.oracle.database.jdbc ojdbc11 21.9.0.0 com.oracle.database.jdbc ojdbc11-production 21.9.0.0 com.oracle.database.jdbc ojdbc8 21.9.0.0 com.oracle.database.jdbc ojdbc8-production 21.9.0.0 com.oracle.database.jdbc rsi 21.9.0.0 com.oracle.database.jdbc ucp 21.9.0.0 com.oracle.database.jdbc ucp11 21.9.0.0 com.oracle.database.jdbc.debug ojdbc11-debug 21.9.0.0 com.oracle.database.jdbc.debug ojdbc11-observability-debug 21.9.0.0 com.oracle.database.jdbc.debug ojdbc11_g 21.9.0.0 com.oracle.database.jdbc.debug ojdbc11dms_g 21.9.0.0 com.oracle.database.jdbc.debug ojdbc8-debug 21.9.0.0 com.oracle.database.jdbc.debug ojdbc8-observability-debug 21.9.0.0 com.oracle.database.jdbc.debug ojdbc8_g 21.9.0.0 com.oracle.database.jdbc.debug ojdbc8dms_g 21.9.0.0 com.oracle.database.nls orai18n 21.9.0.0 com.oracle.database.observability dms 21.9.0.0 com.oracle.database.observability ojdbc11-observability 21.9.0.0 com.oracle.database.observability ojdbc11dms 21.9.0.0 com.oracle.database.observability ojdbc8-observability 21.9.0.0 com.oracle.database.observability ojdbc8dms 21.9.0.0 com.oracle.database.r2dbc oracle-r2dbc 1.2.0 com.oracle.database.security oraclepki 21.9.0.0 com.oracle.database.security osdt_cert 21.9.0.0 com.oracle.database.security osdt_core 21.9.0.0 com.oracle.database.xml xdb 21.9.0.0 com.oracle.database.xml xmlparserv2 21.9.0.0 com.querydsl codegen-utils 5.1.0 com.querydsl querydsl-apt 5.1.0 com.querydsl querydsl-codegen 5.1.0 com.querydsl querydsl-collections 5.1.0 com.querydsl querydsl-core 5.1.0 com.querydsl querydsl-guava 5.1.0 com.querydsl querydsl-hibernate-search 5.1.0 com.querydsl querydsl-jdo 5.1.0 com.querydsl querydsl-jpa 5.1.0 com.querydsl querydsl-jpa-codegen 5.1.0 com.querydsl querydsl-kotlin 5.1.0 com.querydsl querydsl-kotlin-codegen 5.1.0 com.querydsl querydsl-lucene3 5.1.0 com.querydsl querydsl-lucene4 5.1.0 com.querydsl querydsl-lucene5 5.1.0 com.querydsl querydsl-mongodb 5.1.0 com.querydsl querydsl-scala 5.1.0 com.querydsl querydsl-spatial 5.1.0 com.querydsl querydsl-sql 5.1.0 com.querydsl querydsl-sql-codegen 5.1.0 com.querydsl querydsl-sql-spatial 5.1.0 com.querydsl querydsl-sql-spring 5.1.0 com.rabbitmq amqp-client 5.21.0 com.rabbitmq stream-client 0.15.0 com.samskivert jmustache 1.16 com.sendgrid sendgrid-java 4.10.3 com.squareup.okhttp3 logging-interceptor 4.12.0 com.squareup.okhttp3 mockwebserver 4.12.0 com.squareup.okhttp3 okcurl 4.12.0 com.squareup.okhttp3 okhttp 4.12.0 com.squareup.okhttp3 okhttp-brotli 4.12.0 com.squareup.okhttp3 okhttp-dnsoverhttps 4.12.0 com.squareup.okhttp3 okhttp-sse 4.12.0 com.squareup.okhttp3 okhttp-tls 4.12.0 com.squareup.okhttp3 okhttp-urlconnection 4.12.0 com.sun.istack istack-commons-runtime 4.1.2 com.sun.xml.bind jaxb-core 4.0.5 com.sun.xml.bind jaxb-impl 4.0.5 com.sun.xml.bind jaxb-jxc 4.0.5 com.sun.xml.bind jaxb-osgi 4.0.5 com.sun.xml.bind jaxb-xjc 4.0.5 com.sun.xml.fastinfoset FastInfoset 2.1.1 com.sun.xml.messaging.saaj saaj-impl 3.0.4 com.unboundid unboundid-ldapsdk 6.0.11 com.zaxxer HikariCP 5.1.0 commons-codec commons-codec 1.16.1 commons-pool commons-pool 1.6 io.asyncer r2dbc-mysql 1.1.3 io.lettuce lettuce-core 6.3.2.RELEASE io.micrometer context-propagation 1.1.1 io.micrometer docs 1.3.4 io.micrometer micrometer-commons 1.13.4 io.micrometer micrometer-core 1.13.4 io.micrometer micrometer-jakarta9 1.13.4 io.micrometer micrometer-java11 1.13.4 io.micrometer micrometer-jetty11 1.13.4 io.micrometer micrometer-jetty12 1.13.4 io.micrometer micrometer-observation 1.13.4 io.micrometer micrometer-observation-test 1.13.4 io.micrometer micrometer-registry-appoptics 1.13.4 io.micrometer micrometer-registry-atlas 1.13.4 io.micrometer micrometer-registry-azure-monitor 1.13.4 io.micrometer micrometer-registry-cloudwatch2 1.13.4 io.micrometer micrometer-registry-datadog 1.13.4 io.micrometer micrometer-registry-dynatrace 1.13.4 io.micrometer micrometer-registry-elastic 1.13.4 io.micrometer micrometer-registry-ganglia 1.13.4 io.micrometer micrometer-registry-graphite 1.13.4 io.micrometer micrometer-registry-health 1.13.4 io.micrometer micrometer-registry-humio 1.13.4 io.micrometer micrometer-registry-influx 1.13.4 io.micrometer micrometer-registry-jmx 1.13.4 io.micrometer micrometer-registry-kairos 1.13.4 io.micrometer micrometer-registry-new-relic 1.13.4 io.micrometer micrometer-registry-opentsdb 1.13.4 io.micrometer micrometer-registry-otlp 1.13.4 io.micrometer micrometer-registry-prometheus 1.13.4 io.micrometer micrometer-registry-prometheus-simpleclient 1.13.4 io.micrometer micrometer-registry-signalfx 1.13.4 io.micrometer micrometer-registry-stackdriver 1.13.4 io.micrometer micrometer-registry-statsd 1.13.4 io.micrometer micrometer-registry-wavefront 1.13.4 io.micrometer micrometer-test 1.13.4 io.micrometer micrometer-tracing 1.3.4 io.micrometer micrometer-tracing-bridge-brave 1.3.4 io.micrometer micrometer-tracing-bridge-otel 1.3.4 io.micrometer micrometer-tracing-integration-test 1.3.4 io.micrometer micrometer-tracing-reporter-wavefront 1.3.4 io.micrometer micrometer-tracing-test 1.3.4 io.netty netty-all 4.1.113.Final io.netty netty-buffer 4.1.113.Final io.netty netty-codec 4.1.113.Final io.netty netty-codec-dns 4.1.113.Final io.netty netty-codec-haproxy 4.1.113.Final io.netty netty-codec-http 4.1.113.Final io.netty netty-codec-http2 4.1.113.Final io.netty netty-codec-memcache 4.1.113.Final io.netty netty-codec-mqtt 4.1.113.Final io.netty netty-codec-redis 4.1.113.Final io.netty netty-codec-smtp 4.1.113.Final io.netty netty-codec-socks 4.1.113.Final io.netty netty-codec-stomp 4.1.113.Final io.netty netty-codec-xml 4.1.113.Final io.netty netty-common 4.1.113.Final io.netty netty-dev-tools 4.1.113.Final io.netty netty-example 4.1.113.Final io.netty netty-handler 4.1.113.Final io.netty netty-handler-proxy 4.1.113.Final io.netty netty-handler-ssl-ocsp 4.1.113.Final io.netty netty-resolver 4.1.113.Final io.netty netty-resolver-dns 4.1.113.Final io.netty netty-resolver-dns-classes-macos 4.1.113.Final io.netty netty-resolver-dns-native-macos 4.1.113.Final io.netty netty-tcnative 2.0.66.Final io.netty netty-tcnative-boringssl-static 2.0.66.Final io.netty netty-tcnative-classes 2.0.66.Final io.netty netty-transport 4.1.113.Final io.netty netty-transport-classes-epoll 4.1.113.Final io.netty netty-transport-classes-kqueue 4.1.113.Final io.netty netty-transport-native-epoll 4.1.113.Final io.netty netty-transport-native-kqueue 4.1.113.Final io.netty netty-transport-native-unix-common 4.1.113.Final io.netty netty-transport-rxtx 4.1.113.Final io.netty netty-transport-sctp 4.1.113.Final io.netty netty-transport-udt 4.1.113.Final io.opentelemetry opentelemetry-api 1.37.0 io.opentelemetry opentelemetry-context 1.37.0 io.opentelemetry opentelemetry-exporter-common 1.37.0 io.opentelemetry opentelemetry-exporter-logging 1.37.0 io.opentelemetry opentelemetry-exporter-logging-otlp 1.37.0 io.opentelemetry opentelemetry-exporter-otlp 1.37.0 io.opentelemetry opentelemetry-exporter-otlp-common 1.37.0 io.opentelemetry opentelemetry-exporter-sender-grpc-managed-channel 1.37.0 io.opentelemetry opentelemetry-exporter-sender-okhttp 1.37.0 io.opentelemetry opentelemetry-exporter-zipkin 1.37.0 io.opentelemetry opentelemetry-extension-kotlin 1.37.0 io.opentelemetry opentelemetry-extension-trace-propagators 1.37.0 io.opentelemetry opentelemetry-opentracing-shim 1.37.0 io.opentelemetry opentelemetry-sdk 1.37.0 io.opentelemetry opentelemetry-sdk-common 1.37.0 io.opentelemetry opentelemetry-sdk-extension-autoconfigure 1.37.0 io.opentelemetry opentelemetry-sdk-extension-autoconfigure-spi 1.37.0 io.opentelemetry opentelemetry-sdk-extension-jaeger-remote-sampler 1.37.0 io.opentelemetry opentelemetry-sdk-logs 1.37.0 io.opentelemetry opentelemetry-sdk-metrics 1.37.0 io.opentelemetry opentelemetry-sdk-testing 1.37.0 io.opentelemetry opentelemetry-sdk-trace 1.37.0 io.projectreactor reactor-core 3.6.10 io.projectreactor reactor-core-micrometer 1.1.10 io.projectreactor reactor-test 3.6.10 io.projectreactor reactor-tools 3.6.10 io.projectreactor.addons reactor-adapter 3.5.2 io.projectreactor.addons reactor-extra 3.5.2 io.projectreactor.addons reactor-pool 1.0.8 io.projectreactor.addons reactor-pool-micrometer 0.1.8 io.projectreactor.kafka reactor-kafka 1.3.23 io.projectreactor.kotlin reactor-kotlin-extensions 1.2.3 io.projectreactor.netty reactor-netty 1.1.22 io.projectreactor.netty reactor-netty-core 1.1.22 io.projectreactor.netty reactor-netty-http 1.1.22 io.projectreactor.netty reactor-netty-http-brave 1.1.22 io.prometheus prometheus-metrics-config 1.2.1 io.prometheus prometheus-metrics-core 1.2.1 io.prometheus prometheus-metrics-exporter-common 1.2.1 io.prometheus prometheus-metrics-exporter-httpserver 1.2.1 io.prometheus prometheus-metrics-exporter-opentelemetry 1.2.1 io.prometheus prometheus-metrics-exporter-servlet-jakarta 1.2.1 io.prometheus prometheus-metrics-exporter-servlet-javax 1.2.1 io.prometheus prometheus-metrics-exposition-formats 1.2.1 io.prometheus prometheus-metrics-instrumentation-dropwizard5 1.2.1 io.prometheus prometheus-metrics-instrumentation-jvm 1.2.1 io.prometheus prometheus-metrics-model 1.2.1 io.prometheus prometheus-metrics-shaded-dependencies 1.2.1 io.prometheus prometheus-metrics-shaded-opentelemetry 1.2.1 io.prometheus prometheus-metrics-shaded-protobuf 1.2.1 io.prometheus prometheus-metrics-simpleclient-bridge 1.2.1 io.prometheus prometheus-metrics-tracer 1.2.1 io.prometheus prometheus-metrics-tracer-common 1.2.1 io.prometheus prometheus-metrics-tracer-initializer 1.2.1 io.prometheus prometheus-metrics-tracer-otel 1.2.1 io.prometheus prometheus-metrics-tracer-otel-agent 1.2.1 io.prometheus simpleclient 0.16.0 io.prometheus simpleclient_caffeine 0.16.0 io.prometheus simpleclient_common 0.16.0 io.prometheus simpleclient_dropwizard 0.16.0 io.prometheus simpleclient_graphite_bridge 0.16.0 io.prometheus simpleclient_guava 0.16.0 io.prometheus simpleclient_hibernate 0.16.0 io.prometheus simpleclient_hotspot 0.16.0 io.prometheus simpleclient_httpserver 0.16.0 io.prometheus simpleclient_jetty 0.16.0 io.prometheus simpleclient_jetty_jdk8 0.16.0 io.prometheus simpleclient_log4j 0.16.0 io.prometheus simpleclient_log4j2 0.16.0 io.prometheus simpleclient_logback 0.16.0 io.prometheus simpleclient_pushgateway 0.16.0 io.prometheus simpleclient_servlet 0.16.0 io.prometheus simpleclient_servlet_jakarta 0.16.0 io.prometheus simpleclient_spring_boot 0.16.0 io.prometheus simpleclient_spring_web 0.16.0 io.prometheus simpleclient_tracer_common 0.16.0 io.prometheus simpleclient_tracer_otel 0.16.0 io.prometheus simpleclient_tracer_otel_agent 0.16.0 io.prometheus simpleclient_vertx 0.16.0 io.r2dbc r2dbc-h2 1.0.0.RELEASE io.r2dbc r2dbc-mssql 1.0.2.RELEASE io.r2dbc r2dbc-pool 1.0.1.RELEASE io.r2dbc r2dbc-proxy 1.1.5.RELEASE io.r2dbc r2dbc-spi 1.0.0.RELEASE io.reactivex.rxjava3 rxjava 3.1.9 io.rest-assured json-path 5.4.0 io.rest-assured json-schema-validator 5.4.0 io.rest-assured kotlin-extensions 5.4.0 io.rest-assured rest-assured 5.4.0 io.rest-assured rest-assured-all 5.4.0 io.rest-assured rest-assured-common 5.4.0 io.rest-assured scala-support 5.4.0 io.rest-assured spring-commons 5.4.0 io.rest-assured spring-mock-mvc 5.4.0 io.rest-assured spring-mock-mvc-kotlin-extensions 5.4.0 io.rest-assured spring-web-test-client 5.4.0 io.rest-assured spring-web-test-client-kotlin-extensions 5.4.0 io.rest-assured xml-path 5.4.0 io.rsocket rsocket-core 1.1.3 io.rsocket rsocket-load-balancer 1.1.3 io.rsocket rsocket-micrometer 1.1.3 io.rsocket rsocket-test 1.1.3 io.rsocket rsocket-transport-local 1.1.3 io.rsocket rsocket-transport-netty 1.1.3 io.spring.gradle dependency-management-plugin 1.1.6 io.undertow undertow-core 2.3.17.Final io.undertow undertow-servlet 2.3.17.Final io.undertow undertow-websockets-jsr 2.3.17.Final io.zipkin.brave brave 6.0.3 io.zipkin.brave brave-context-jfr 6.0.3 io.zipkin.brave brave-context-log4j12 6.0.3 io.zipkin.brave brave-context-log4j2 6.0.3 io.zipkin.brave brave-context-slf4j 6.0.3 io.zipkin.brave brave-instrumentation-benchmarks 6.0.3 io.zipkin.brave brave-instrumentation-dubbo 6.0.3 io.zipkin.brave brave-instrumentation-grpc 6.0.3 io.zipkin.brave brave-instrumentation-http 6.0.3 io.zipkin.brave brave-instrumentation-http-tests 6.0.3 io.zipkin.brave brave-instrumentation-http-tests-jakarta 6.0.3 io.zipkin.brave brave-instrumentation-httpasyncclient 6.0.3 io.zipkin.brave brave-instrumentation-httpclient 6.0.3 io.zipkin.brave brave-instrumentation-httpclient5 6.0.3 io.zipkin.brave brave-instrumentation-jakarta-jms 6.0.3 io.zipkin.brave brave-instrumentation-jaxrs2 6.0.3 io.zipkin.brave brave-instrumentation-jersey-server 6.0.3 io.zipkin.brave brave-instrumentation-jms 6.0.3 io.zipkin.brave brave-instrumentation-jms-jakarta 6.0.3 io.zipkin.brave brave-instrumentation-kafka-clients 6.0.3 io.zipkin.brave brave-instrumentation-kafka-streams 6.0.3 io.zipkin.brave brave-instrumentation-messaging 6.0.3 io.zipkin.brave brave-instrumentation-mongodb 6.0.3 io.zipkin.brave brave-instrumentation-mysql 6.0.3 io.zipkin.brave brave-instrumentation-mysql6 6.0.3 io.zipkin.brave brave-instrumentation-mysql8 6.0.3 io.zipkin.brave brave-instrumentation-netty-codec-http 6.0.3 io.zipkin.brave brave-instrumentation-okhttp3 6.0.3 io.zipkin.brave brave-instrumentation-rpc 6.0.3 io.zipkin.brave brave-instrumentation-servlet 6.0.3 io.zipkin.brave brave-instrumentation-servlet-jakarta 6.0.3 io.zipkin.brave brave-instrumentation-spring-rabbit 6.0.3 io.zipkin.brave brave-instrumentation-spring-web 6.0.3 io.zipkin.brave brave-instrumentation-spring-webmvc 6.0.3 io.zipkin.brave brave-instrumentation-vertx-web 6.0.3 io.zipkin.brave brave-spring-beans 6.0.3 io.zipkin.brave brave-tests 6.0.3 io.zipkin.reporter2 zipkin-reporter 3.4.2 io.zipkin.reporter2 zipkin-reporter-brave 3.4.2 io.zipkin.reporter2 zipkin-reporter-metrics-micrometer 3.4.2 io.zipkin.reporter2 zipkin-reporter-spring-beans 3.4.2 io.zipkin.reporter2 zipkin-sender-activemq-client 3.4.2 io.zipkin.reporter2 zipkin-sender-amqp-client 3.4.2 io.zipkin.reporter2 zipkin-sender-kafka 3.4.2 io.zipkin.reporter2 zipkin-sender-libthrift 3.4.2 io.zipkin.reporter2 zipkin-sender-okhttp3 3.4.2 io.zipkin.reporter2 zipkin-sender-urlconnection 3.4.2 io.zipkin.zipkin2 zipkin 2.27.1 jakarta.activation jakarta.activation-api 2.1.3 jakarta.annotation jakarta.annotation-api 2.1.1 jakarta.inject jakarta.inject-api 2.0.1 jakarta.jms jakarta.jms-api 3.1.0 jakarta.json jakarta.json-api 2.1.3 jakarta.json.bind jakarta.json.bind-api 3.0.1 jakarta.mail jakarta.mail-api 2.1.3 jakarta.management.j2ee jakarta.management.j2ee-api 1.1.4 jakarta.persistence jakarta.persistence-api 3.1.0 jakarta.servlet jakarta.servlet-api 6.0.0 jakarta.servlet.jsp.jstl jakarta.servlet.jsp.jstl-api 3.0.2 jakarta.transaction jakarta.transaction-api 2.0.1 jakarta.validation jakarta.validation-api 3.0.2 jakarta.websocket jakarta.websocket-api 2.1.1 jakarta.websocket jakarta.websocket-client-api 2.1.1 jakarta.ws.rs jakarta.ws.rs-api 3.1.0 jakarta.xml.bind jakarta.xml.bind-api 4.0.2 jakarta.xml.soap jakarta.xml.soap-api 3.0.2 jakarta.xml.ws jakarta.xml.ws-api 4.0.2 javax.cache cache-api 1.1.1 javax.money money-api 1.1 jaxen jaxen 2.0.0 junit junit 4.13.2 net.bytebuddy byte-buddy 1.14.19 net.bytebuddy byte-buddy-agent 1.14.19 net.minidev json-smart 2.5.1 net.sourceforge.htmlunit htmlunit 2.70.0 net.sourceforge.jtds jtds 1.3.1 net.sourceforge.nekohtml nekohtml 1.9.22 nz.net.ultraq.thymeleaf thymeleaf-layout-dialect 3.3.0 org.apache.activemq activemq-all 6.1.3 org.apache.activemq activemq-amqp 6.1.3 org.apache.activemq activemq-blueprint 6.1.3 org.apache.activemq activemq-branding 2.33.0 org.apache.activemq activemq-broker 6.1.3 org.apache.activemq activemq-client 6.1.3 org.apache.activemq activemq-console 6.1.3 org.apache.activemq activemq-http 6.1.3 org.apache.activemq activemq-jaas 6.1.3 org.apache.activemq activemq-jdbc-store 6.1.3 org.apache.activemq activemq-jms-pool 6.1.3 org.apache.activemq activemq-kahadb-store 6.1.3 org.apache.activemq activemq-karaf 6.1.3 org.apache.activemq activemq-log4j-appender 6.1.3 org.apache.activemq activemq-mqtt 6.1.3 org.apache.activemq activemq-openwire-generator 6.1.3 org.apache.activemq activemq-openwire-legacy 6.1.3 org.apache.activemq activemq-osgi 6.1.3 org.apache.activemq activemq-pool 6.1.3 org.apache.activemq activemq-ra 6.1.3 org.apache.activemq activemq-rar 6.1.3 org.apache.activemq activemq-run 6.1.3 org.apache.activemq activemq-runtime-config 6.1.3 org.apache.activemq activemq-shiro 6.1.3 org.apache.activemq activemq-spring 6.1.3 org.apache.activemq activemq-stomp 6.1.3 org.apache.activemq activemq-web 6.1.3 org.apache.activemq activemq-web-console 6.1.3 org.apache.activemq activemq-web-demo 6.1.3 org.apache.activemq artemis-amqp-protocol 2.33.0 org.apache.activemq artemis-boot 2.33.0 org.apache.activemq artemis-cdi-client 2.33.0 org.apache.activemq artemis-cli 2.33.0 org.apache.activemq artemis-commons 2.33.0 org.apache.activemq artemis-console 2.33.0 org.apache.activemq artemis-core-client 2.33.0 org.apache.activemq artemis-core-client-all 2.33.0 org.apache.activemq artemis-core-client-osgi 2.33.0 org.apache.activemq artemis-dto 2.33.0 org.apache.activemq artemis-features 2.33.0 org.apache.activemq artemis-hornetq-protocol 2.33.0 org.apache.activemq artemis-hqclient-protocol 2.33.0 org.apache.activemq artemis-jakarta-client 2.33.0 org.apache.activemq artemis-jakarta-client-all 2.33.0 org.apache.activemq artemis-jakarta-openwire-protocol 2.33.0 org.apache.activemq artemis-jakarta-ra 2.33.0 org.apache.activemq artemis-jakarta-server 2.33.0 org.apache.activemq artemis-jakarta-service-extensions 2.33.0 org.apache.activemq artemis-jdbc-store 2.33.0 org.apache.activemq artemis-jms-client 2.33.0 org.apache.activemq artemis-jms-client-all 2.33.0 org.apache.activemq artemis-jms-client-osgi 2.33.0 org.apache.activemq artemis-jms-server 2.33.0 org.apache.activemq artemis-journal 2.33.0 org.apache.activemq artemis-lockmanager-api 2.33.0 org.apache.activemq artemis-lockmanager-ri 2.33.0 org.apache.activemq artemis-mqtt-protocol 2.33.0 org.apache.activemq artemis-openwire-protocol 2.33.0 org.apache.activemq artemis-plugin 2.33.0 org.apache.activemq artemis-ra 2.33.0 org.apache.activemq artemis-selector 2.33.0 org.apache.activemq artemis-server 2.33.0 org.apache.activemq artemis-server-osgi 2.33.0 org.apache.activemq artemis-service-extensions 2.33.0 org.apache.activemq artemis-stomp-protocol 2.33.0 org.apache.activemq artemis-web 2.33.0 org.apache.activemq artemis-website 2.33.0 org.apache.cassandra java-driver-core 4.18.1 org.apache.cassandra java-driver-core-shaded 4.18.1 org.apache.cassandra java-driver-mapper-processor 4.18.1 org.apache.cassandra java-driver-mapper-runtime 4.18.1 org.apache.cassandra java-driver-metrics-micrometer 4.18.1 org.apache.cassandra java-driver-metrics-microprofile 4.18.1 org.apache.cassandra java-driver-query-builder 4.18.1 org.apache.cassandra java-driver-test-infra 4.18.1 org.apache.commons commons-dbcp2 2.12.0 org.apache.commons commons-lang3 3.14.0 org.apache.commons commons-pool2 2.12.0 org.apache.derby derby 10.16.1.1 org.apache.derby derbyclient 10.16.1.1 org.apache.derby derbynet 10.16.1.1 org.apache.derby derbyoptionaltools 10.16.1.1 org.apache.derby derbyshared 10.16.1.1 org.apache.derby derbytools 10.16.1.1 org.apache.groovy groovy 4.0.23 org.apache.groovy groovy-ant 4.0.23 org.apache.groovy groovy-astbuilder 4.0.23 org.apache.groovy groovy-cli-commons 4.0.23 org.apache.groovy groovy-cli-picocli 4.0.23 org.apache.groovy groovy-console 4.0.23 org.apache.groovy groovy-contracts 4.0.23 org.apache.groovy groovy-datetime 4.0.23 org.apache.groovy groovy-dateutil 4.0.23 org.apache.groovy groovy-docgenerator 4.0.23 org.apache.groovy groovy-ginq 4.0.23 org.apache.groovy groovy-groovydoc 4.0.23 org.apache.groovy groovy-groovysh 4.0.23 org.apache.groovy groovy-jmx 4.0.23 org.apache.groovy groovy-json 4.0.23 org.apache.groovy groovy-jsr223 4.0.23 org.apache.groovy groovy-macro 4.0.23 org.apache.groovy groovy-macro-library 4.0.23 org.apache.groovy groovy-nio 4.0.23 org.apache.groovy groovy-servlet 4.0.23 org.apache.groovy groovy-sql 4.0.23 org.apache.groovy groovy-swing 4.0.23 org.apache.groovy groovy-templates 4.0.23 org.apache.groovy groovy-test 4.0.23 org.apache.groovy groovy-test-junit5 4.0.23 org.apache.groovy groovy-testng 4.0.23 org.apache.groovy groovy-toml 4.0.23 org.apache.groovy groovy-typecheckers 4.0.23 org.apache.groovy groovy-xml 4.0.23 org.apache.groovy groovy-yaml 4.0.23 org.apache.httpcomponents httpasyncclient 4.1.5 org.apache.httpcomponents httpcore 4.4.16 org.apache.httpcomponents httpcore-nio 4.4.16 org.apache.httpcomponents.client5 httpclient5 5.3.1 org.apache.httpcomponents.client5 httpclient5-cache 5.3.1 org.apache.httpcomponents.client5 httpclient5-fluent 5.3.1 org.apache.httpcomponents.core5 httpcore5 5.2.5 org.apache.httpcomponents.core5 httpcore5-h2 5.2.5 org.apache.httpcomponents.core5 httpcore5-reactive 5.2.5 org.apache.kafka connect 3.7.1 org.apache.kafka connect-api 3.7.1 org.apache.kafka connect-basic-auth-extension 3.7.1 org.apache.kafka connect-file 3.7.1 org.apache.kafka connect-json 3.7.1 org.apache.kafka connect-mirror 3.7.1 org.apache.kafka connect-mirror-client 3.7.1 org.apache.kafka connect-runtime 3.7.1 org.apache.kafka connect-transforms 3.7.1 org.apache.kafka generator 3.7.1 org.apache.kafka kafka-clients 3.7.1 org.apache.kafka kafka-log4j-appender 3.7.1 org.apache.kafka kafka-metadata 3.7.1 org.apache.kafka kafka-raft 3.7.1 org.apache.kafka kafka-server-common 3.7.1 org.apache.kafka kafka-shell 3.7.1 org.apache.kafka kafka-storage 3.7.1 org.apache.kafka kafka-storage-api 3.7.1 org.apache.kafka kafka-streams 3.7.1 org.apache.kafka kafka-streams-scala_2.12 3.7.1 org.apache.kafka kafka-streams-scala_2.13 3.7.1 org.apache.kafka kafka-streams-test-utils 3.7.1 org.apache.kafka kafka-tools 3.7.1 org.apache.kafka kafka_2.12 3.7.1 org.apache.kafka kafka_2.13 3.7.1 org.apache.kafka trogdor 3.7.1 org.apache.logging.log4j log4j-1.2-api 2.23.1 org.apache.logging.log4j log4j-api 2.23.1 org.apache.logging.log4j log4j-api-test 2.23.1 org.apache.logging.log4j log4j-appserver 2.23.1 org.apache.logging.log4j log4j-cassandra 2.23.1 org.apache.logging.log4j log4j-core 2.23.1 org.apache.logging.log4j log4j-core-test 2.23.1 org.apache.logging.log4j log4j-couchdb 2.23.1 org.apache.logging.log4j log4j-docker 2.23.1 org.apache.logging.log4j log4j-flume-ng 2.23.1 org.apache.logging.log4j log4j-iostreams 2.23.1 org.apache.logging.log4j log4j-jakarta-smtp 2.23.1 org.apache.logging.log4j log4j-jakarta-web 2.23.1 org.apache.logging.log4j log4j-jcl 2.23.1 org.apache.logging.log4j log4j-jpa 2.23.1 org.apache.logging.log4j log4j-jpl 2.23.1 org.apache.logging.log4j log4j-jul 2.23.1 org.apache.logging.log4j log4j-kubernetes 2.23.1 org.apache.logging.log4j log4j-layout-template-json 2.23.1 org.apache.logging.log4j log4j-mongodb3 2.23.1 org.apache.logging.log4j log4j-mongodb4 2.23.1 org.apache.logging.log4j log4j-slf4j-impl 2.23.1 org.apache.logging.log4j log4j-slf4j2-impl 2.23.1 org.apache.logging.log4j log4j-spring-boot 2.23.1 org.apache.logging.log4j log4j-spring-cloud-config-client 2.23.1 org.apache.logging.log4j log4j-taglib 2.23.1 org.apache.logging.log4j log4j-to-jul 2.23.1 org.apache.logging.log4j log4j-to-slf4j 2.23.1 org.apache.logging.log4j log4j-web 2.23.1 org.apache.maven.plugin-tools maven-plugin-annotations 3.11.0 org.apache.pulsar bouncy-castle-bc 3.2.4 org.apache.pulsar bouncy-castle-bcfips 3.2.4 org.apache.pulsar bouncy-castle-parent 3.2.4 org.apache.pulsar buildtools 3.2.4 org.apache.pulsar distribution 3.2.4 org.apache.pulsar docker-images 3.2.4 org.apache.pulsar jclouds-shaded 3.2.4 org.apache.pulsar managed-ledger 3.2.4 org.apache.pulsar pulsar 3.2.4 org.apache.pulsar pulsar-all-docker-image 3.2.4 org.apache.pulsar pulsar-broker 3.2.4 org.apache.pulsar pulsar-broker-auth-athenz 3.2.4 org.apache.pulsar pulsar-broker-auth-oidc 3.2.4 org.apache.pulsar pulsar-broker-auth-sasl 3.2.4 org.apache.pulsar pulsar-broker-common 3.2.4 org.apache.pulsar pulsar-cli-utils 3.2.4 org.apache.pulsar pulsar-client 3.2.4 org.apache.pulsar pulsar-client-1x 3.2.4 org.apache.pulsar pulsar-client-1x-base 3.2.4 org.apache.pulsar pulsar-client-2x-shaded 3.2.4 org.apache.pulsar pulsar-client-admin 3.2.4 org.apache.pulsar pulsar-client-admin-api 3.2.4 org.apache.pulsar pulsar-client-admin-original 3.2.4 org.apache.pulsar pulsar-client-all 3.2.4 org.apache.pulsar pulsar-client-api 3.2.4 org.apache.pulsar pulsar-client-auth-athenz 3.2.4 org.apache.pulsar pulsar-client-auth-sasl 3.2.4 org.apache.pulsar pulsar-client-messagecrypto-bc 3.2.4 org.apache.pulsar pulsar-client-original 3.2.4 org.apache.pulsar pulsar-client-reactive-adapter 0.5.7 org.apache.pulsar pulsar-client-reactive-api 0.5.7 org.apache.pulsar pulsar-client-reactive-jackson 0.5.7 org.apache.pulsar pulsar-client-reactive-producer-cache-caffeine 0.5.7 org.apache.pulsar pulsar-client-reactive-producer-cache-caffeine-shaded 0.5.7 org.apache.pulsar pulsar-client-tools 3.2.4 org.apache.pulsar pulsar-client-tools-api 3.2.4 org.apache.pulsar pulsar-common 3.2.4 org.apache.pulsar pulsar-config-validation 3.2.4 org.apache.pulsar pulsar-docker-image 3.2.4 org.apache.pulsar pulsar-docs-tools 3.2.4 org.apache.pulsar pulsar-functions 3.2.4 org.apache.pulsar pulsar-functions-api 3.2.4 org.apache.pulsar pulsar-functions-api-examples 3.2.4 org.apache.pulsar pulsar-functions-api-examples-builtin 3.2.4 org.apache.pulsar pulsar-functions-instance 3.2.4 org.apache.pulsar pulsar-functions-local-runner 3.2.4 org.apache.pulsar pulsar-functions-local-runner-original 3.2.4 org.apache.pulsar pulsar-functions-proto 3.2.4 org.apache.pulsar pulsar-functions-runtime 3.2.4 org.apache.pulsar pulsar-functions-runtime-all 3.2.4 org.apache.pulsar pulsar-functions-secrets 3.2.4 org.apache.pulsar pulsar-functions-utils 3.2.4 org.apache.pulsar pulsar-functions-worker 3.2.4 org.apache.pulsar pulsar-io 3.2.4 org.apache.pulsar pulsar-io-aerospike 3.2.4 org.apache.pulsar pulsar-io-alluxio 3.2.4 org.apache.pulsar pulsar-io-aws 3.2.4 org.apache.pulsar pulsar-io-batch-data-generator 3.2.4 org.apache.pulsar pulsar-io-batch-discovery-triggerers 3.2.4 org.apache.pulsar pulsar-io-canal 3.2.4 org.apache.pulsar pulsar-io-cassandra 3.2.4 org.apache.pulsar pulsar-io-common 3.2.4 org.apache.pulsar pulsar-io-core 3.2.4 org.apache.pulsar pulsar-io-data-generator 3.2.4 org.apache.pulsar pulsar-io-debezium 3.2.4 org.apache.pulsar pulsar-io-debezium-core 3.2.4 org.apache.pulsar pulsar-io-debezium-mongodb 3.2.4 org.apache.pulsar pulsar-io-debezium-mssql 3.2.4 org.apache.pulsar pulsar-io-debezium-mysql 3.2.4 org.apache.pulsar pulsar-io-debezium-oracle 3.2.4 org.apache.pulsar pulsar-io-debezium-postgres 3.2.4 org.apache.pulsar pulsar-io-distribution 3.2.4 org.apache.pulsar pulsar-io-docs 3.2.4 org.apache.pulsar pulsar-io-dynamodb 3.2.4 org.apache.pulsar pulsar-io-elastic-search 3.2.4 org.apache.pulsar pulsar-io-file 3.2.4 org.apache.pulsar pulsar-io-flume 3.2.4 org.apache.pulsar pulsar-io-hbase 3.2.4 org.apache.pulsar pulsar-io-hdfs2 3.2.4 org.apache.pulsar pulsar-io-hdfs3 3.2.4 org.apache.pulsar pulsar-io-http 3.2.4 org.apache.pulsar pulsar-io-influxdb 3.2.4 org.apache.pulsar pulsar-io-jdbc 3.2.4 org.apache.pulsar pulsar-io-jdbc-clickhouse 3.2.4 org.apache.pulsar pulsar-io-jdbc-core 3.2.4 org.apache.pulsar pulsar-io-jdbc-mariadb 3.2.4 org.apache.pulsar pulsar-io-jdbc-openmldb 3.2.4 org.apache.pulsar pulsar-io-jdbc-postgres 3.2.4 org.apache.pulsar pulsar-io-jdbc-sqlite 3.2.4 org.apache.pulsar pulsar-io-kafka 3.2.4 org.apache.pulsar pulsar-io-kafka-connect-adaptor 3.2.4 org.apache.pulsar pulsar-io-kafka-connect-adaptor-nar 3.2.4 org.apache.pulsar pulsar-io-kinesis 3.2.4 org.apache.pulsar pulsar-io-mongo 3.2.4 org.apache.pulsar pulsar-io-netty 3.2.4 org.apache.pulsar pulsar-io-nsq 3.2.4 org.apache.pulsar pulsar-io-rabbitmq 3.2.4 org.apache.pulsar pulsar-io-redis 3.2.4 org.apache.pulsar pulsar-io-solr 3.2.4 org.apache.pulsar pulsar-io-twitter 3.2.4 org.apache.pulsar pulsar-metadata 3.2.4 org.apache.pulsar pulsar-offloader-distribution 3.2.4 org.apache.pulsar pulsar-package-bookkeeper-storage 3.2.4 org.apache.pulsar pulsar-package-core 3.2.4 org.apache.pulsar pulsar-package-filesystem-storage 3.2.4 org.apache.pulsar pulsar-package-management 3.2.4 org.apache.pulsar pulsar-proxy 3.2.4 org.apache.pulsar pulsar-server-distribution 3.2.4 org.apache.pulsar pulsar-shell-distribution 3.2.4 org.apache.pulsar pulsar-testclient 3.2.4 org.apache.pulsar pulsar-transaction-common 3.2.4 org.apache.pulsar pulsar-transaction-coordinator 3.2.4 org.apache.pulsar pulsar-transaction-parent 3.2.4 org.apache.pulsar pulsar-websocket 3.2.4 org.apache.pulsar structured-event-log 3.2.4 org.apache.pulsar testmocks 3.2.4 org.apache.pulsar tiered-storage-file-system 3.2.4 org.apache.pulsar tiered-storage-jcloud 3.2.4 org.apache.pulsar tiered-storage-parent 3.2.4 org.apache.tomcat tomcat-annotations-api 10.1.30 org.apache.tomcat tomcat-jdbc 10.1.30 org.apache.tomcat tomcat-jsp-api 10.1.30 org.apache.tomcat.embed tomcat-embed-core 10.1.30 org.apache.tomcat.embed tomcat-embed-el 10.1.30 org.apache.tomcat.embed tomcat-embed-jasper 10.1.30 org.apache.tomcat.embed tomcat-embed-websocket 10.1.30 org.aspectj aspectjrt 1.9.22.1 org.aspectj aspectjtools 1.9.22.1 org.aspectj aspectjweaver 1.9.22.1 org.assertj assertj-core 3.25.3 org.assertj assertj-guava 3.25.3 org.awaitility awaitility 4.2.2 org.awaitility awaitility-groovy 4.2.2 org.awaitility awaitility-kotlin 4.2.2 org.awaitility awaitility-scala 4.2.2 org.cache2k cache2k-api 2.6.1.Final org.cache2k cache2k-config 2.6.1.Final org.cache2k cache2k-core 2.6.1.Final org.cache2k cache2k-jcache 2.6.1.Final org.cache2k cache2k-micrometer 2.6.1.Final org.cache2k cache2k-spring 2.6.1.Final org.codehaus.janino commons-compiler 3.1.12 org.codehaus.janino commons-compiler-jdk 3.1.12 org.codehaus.janino janino 3.1.12 org.crac crac 1.4.0 org.eclipse yasson 3.0.4 org.eclipse.angus angus-activation 2.0.2 org.eclipse.angus angus-core 2.0.3 org.eclipse.angus angus-mail 2.0.3 org.eclipse.angus dsn 2.0.3 org.eclipse.angus gimap 2.0.3 org.eclipse.angus imap 2.0.3 org.eclipse.angus jakarta.mail 2.0.3 org.eclipse.angus logging-mailhandler 2.0.3 org.eclipse.angus pop3 2.0.3 org.eclipse.angus smtp 2.0.3 org.eclipse.jetty jetty-alpn-client 12.0.13 org.eclipse.jetty jetty-alpn-conscrypt-client 12.0.13 org.eclipse.jetty jetty-alpn-conscrypt-server 12.0.13 org.eclipse.jetty jetty-alpn-java-client 12.0.13 org.eclipse.jetty jetty-alpn-java-server 12.0.13 org.eclipse.jetty jetty-alpn-server 12.0.13 org.eclipse.jetty jetty-client 12.0.13 org.eclipse.jetty jetty-deploy 12.0.13 org.eclipse.jetty jetty-http 12.0.13 org.eclipse.jetty jetty-http-spi 12.0.13 org.eclipse.jetty jetty-http-tools 12.0.13 org.eclipse.jetty jetty-io 12.0.13 org.eclipse.jetty jetty-jmx 12.0.13 org.eclipse.jetty jetty-jndi 12.0.13 org.eclipse.jetty jetty-keystore 12.0.13 org.eclipse.jetty jetty-openid 12.0.13 org.eclipse.jetty jetty-osgi 12.0.13 org.eclipse.jetty jetty-plus 12.0.13 org.eclipse.jetty jetty-proxy 12.0.13 org.eclipse.jetty jetty-reactive-httpclient 4.0.7 org.eclipse.jetty jetty-rewrite 12.0.13 org.eclipse.jetty jetty-security 12.0.13 org.eclipse.jetty jetty-server 12.0.13 org.eclipse.jetty jetty-session 12.0.13 org.eclipse.jetty jetty-slf4j-impl 12.0.13 org.eclipse.jetty jetty-start 12.0.13 org.eclipse.jetty jetty-unixdomain-server 12.0.13 org.eclipse.jetty jetty-util 12.0.13 org.eclipse.jetty jetty-util-ajax 12.0.13 org.eclipse.jetty jetty-xml 12.0.13 org.eclipse.jetty.demos jetty-demo-handler 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-annotations 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-apache-jsp 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-cdi 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-fcgi-proxy 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-glassfish-jstl 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-jaspi 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-jndi 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-jspc-maven-plugin 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-maven-plugin 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-plus 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-proxy 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-quickstart 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-runner 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-servlet 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-servlets 12.0.13 org.eclipse.jetty.ee10 jetty-ee10-webapp 12.0.13 org.eclipse.jetty.ee10.osgi jetty-ee10-osgi-alpn 12.0.13 org.eclipse.jetty.ee10.osgi jetty-ee10-osgi-boot 12.0.13 org.eclipse.jetty.ee10.osgi jetty-ee10-osgi-boot-jsp 12.0.13 org.eclipse.jetty.ee10.websocket jetty-ee10-websocket-jakarta-client 12.0.13 org.eclipse.jetty.ee10.websocket jetty-ee10-websocket-jakarta-client-webapp 12.0.13 org.eclipse.jetty.ee10.websocket jetty-ee10-websocket-jakarta-common 12.0.13 org.eclipse.jetty.ee10.websocket jetty-ee10-websocket-jakarta-server 12.0.13 org.eclipse.jetty.ee10.websocket jetty-ee10-websocket-jetty-client-webapp 12.0.13 org.eclipse.jetty.ee10.websocket jetty-ee10-websocket-jetty-server 12.0.13 org.eclipse.jetty.ee10.websocket jetty-ee10-websocket-servlet 12.0.13 org.eclipse.jetty.fcgi jetty-fcgi-client 12.0.13 org.eclipse.jetty.fcgi jetty-fcgi-proxy 12.0.13 org.eclipse.jetty.fcgi jetty-fcgi-server 12.0.13 org.eclipse.jetty.http2 jetty-http2-client 12.0.13 org.eclipse.jetty.http2 jetty-http2-client-transport 12.0.13 org.eclipse.jetty.http2 jetty-http2-common 12.0.13 org.eclipse.jetty.http2 jetty-http2-hpack 12.0.13 org.eclipse.jetty.http2 jetty-http2-server 12.0.13 org.eclipse.jetty.http3 jetty-http3-client 12.0.13 org.eclipse.jetty.http3 jetty-http3-client-transport 12.0.13 org.eclipse.jetty.http3 jetty-http3-common 12.0.13 org.eclipse.jetty.http3 jetty-http3-qpack 12.0.13 org.eclipse.jetty.http3 jetty-http3-server 12.0.13 org.eclipse.jetty.quic jetty-quic-client 12.0.13 org.eclipse.jetty.quic jetty-quic-common 12.0.13 org.eclipse.jetty.quic jetty-quic-quiche-common 12.0.13 org.eclipse.jetty.quic jetty-quic-quiche-foreign 12.0.13 org.eclipse.jetty.quic jetty-quic-quiche-jna 12.0.13 org.eclipse.jetty.quic jetty-quic-server 12.0.13 org.eclipse.jetty.websocket jetty-websocket-core-client 12.0.13 org.eclipse.jetty.websocket jetty-websocket-core-common 12.0.13 org.eclipse.jetty.websocket jetty-websocket-core-server 12.0.13 org.eclipse.jetty.websocket jetty-websocket-jetty-api 12.0.13 org.eclipse.jetty.websocket jetty-websocket-jetty-client 12.0.13 org.eclipse.jetty.websocket jetty-websocket-jetty-common 12.0.13 org.eclipse.jetty.websocket jetty-websocket-jetty-server 12.0.13 org.ehcache ehcache 3.10.8 org.ehcache ehcache-clustered 3.10.8 org.ehcache ehcache-transactions 3.10.8 org.elasticsearch.client elasticsearch-rest-client 8.13.4 org.elasticsearch.client elasticsearch-rest-client-sniffer 8.13.4 org.firebirdsql.jdbc jaybird 5.0.5.java11 org.flywaydb flyway-commandline 10.10.0 org.flywaydb flyway-core 10.10.0 org.flywaydb flyway-database-db2 10.10.0 org.flywaydb flyway-database-derby 10.10.0 org.flywaydb flyway-database-hsqldb 10.10.0 org.flywaydb flyway-database-informix 10.10.0 org.flywaydb flyway-database-mongodb 10.10.0 org.flywaydb flyway-database-oracle 10.10.0 org.flywaydb flyway-database-postgresql 10.10.0 org.flywaydb flyway-database-redshift 10.10.0 org.flywaydb flyway-database-saphana 10.10.0 org.flywaydb flyway-database-snowflake 10.10.0 org.flywaydb flyway-database-sybasease 10.10.0 org.flywaydb flyway-firebird 10.10.0 org.flywaydb flyway-gcp-bigquery 10.10.0 org.flywaydb flyway-gcp-spanner 10.10.0 org.flywaydb flyway-mysql 10.10.0 org.flywaydb flyway-singlestore 10.10.0 org.flywaydb flyway-sqlserver 10.10.0 org.freemarker freemarker 2.3.33 org.glassfish.jaxb codemodel 4.0.5 org.glassfish.jaxb jaxb-core 4.0.5 org.glassfish.jaxb jaxb-jxc 4.0.5 org.glassfish.jaxb jaxb-runtime 4.0.5 org.glassfish.jaxb jaxb-xjc 4.0.5 org.glassfish.jaxb txw2 4.0.5 org.glassfish.jaxb xsom 4.0.5 org.glassfish.jersey.bundles jaxrs-ri 3.1.8 org.glassfish.jersey.connectors jersey-apache-connector 3.1.8 org.glassfish.jersey.connectors jersey-apache5-connector 3.1.8 org.glassfish.jersey.connectors jersey-grizzly-connector 3.1.8 org.glassfish.jersey.connectors jersey-helidon-connector 3.1.8 org.glassfish.jersey.connectors jersey-jdk-connector 3.1.8 org.glassfish.jersey.connectors jersey-jetty-connector 3.1.8 org.glassfish.jersey.connectors jersey-jetty-http2-connector 3.1.8 org.glassfish.jersey.connectors jersey-jetty11-connector 3.1.8 org.glassfish.jersey.connectors jersey-jnh-connector 3.1.8 org.glassfish.jersey.connectors jersey-netty-connector 3.1.8 org.glassfish.jersey.containers jersey-container-grizzly2-http 3.1.8 org.glassfish.jersey.containers jersey-container-grizzly2-servlet 3.1.8 org.glassfish.jersey.containers jersey-container-jdk-http 3.1.8 org.glassfish.jersey.containers jersey-container-jetty-http 3.1.8 org.glassfish.jersey.containers jersey-container-jetty-http2 3.1.8 org.glassfish.jersey.containers jersey-container-jetty-servlet 3.1.8 org.glassfish.jersey.containers jersey-container-jetty11-http 3.1.8 org.glassfish.jersey.containers jersey-container-netty-http 3.1.8 org.glassfish.jersey.containers jersey-container-servlet 3.1.8 org.glassfish.jersey.containers jersey-container-servlet-core 3.1.8 org.glassfish.jersey.containers jersey-container-simple-http 3.1.8 org.glassfish.jersey.containers.glassfish jersey-gf-ejb 3.1.8 org.glassfish.jersey.core jersey-client 3.1.8 org.glassfish.jersey.core jersey-common 3.1.8 org.glassfish.jersey.core jersey-server 3.1.8 org.glassfish.jersey.ext jersey-bean-validation 3.1.8 org.glassfish.jersey.ext jersey-declarative-linking 3.1.8 org.glassfish.jersey.ext jersey-entity-filtering 3.1.8 org.glassfish.jersey.ext jersey-metainf-services 3.1.8 org.glassfish.jersey.ext jersey-micrometer 3.1.8 org.glassfish.jersey.ext jersey-mvc 3.1.8 org.glassfish.jersey.ext jersey-mvc-bean-validation 3.1.8 org.glassfish.jersey.ext jersey-mvc-freemarker 3.1.8 org.glassfish.jersey.ext jersey-mvc-jsp 3.1.8 org.glassfish.jersey.ext jersey-mvc-mustache 3.1.8 org.glassfish.jersey.ext jersey-proxy-client 3.1.8 org.glassfish.jersey.ext jersey-spring6 3.1.8 org.glassfish.jersey.ext jersey-wadl-doclet 3.1.8 org.glassfish.jersey.ext.cdi jersey-cdi-rs-inject 3.1.8 org.glassfish.jersey.ext.cdi jersey-cdi1x 3.1.8 org.glassfish.jersey.ext.cdi jersey-cdi1x-ban-custom-hk2-binding 3.1.8 org.glassfish.jersey.ext.cdi jersey-cdi1x-servlet 3.1.8 org.glassfish.jersey.ext.cdi jersey-cdi1x-transaction 3.1.8 org.glassfish.jersey.ext.cdi jersey-cdi1x-validation 3.1.8 org.glassfish.jersey.ext.cdi jersey-weld2-se 3.1.8 org.glassfish.jersey.ext.microprofile jersey-mp-config 3.1.8 org.glassfish.jersey.ext.microprofile jersey-mp-rest-client 3.1.8 org.glassfish.jersey.ext.rx jersey-rx-client-guava 3.1.8 org.glassfish.jersey.ext.rx jersey-rx-client-rxjava 3.1.8 org.glassfish.jersey.ext.rx jersey-rx-client-rxjava2 3.1.8 org.glassfish.jersey.inject jersey-cdi2-se 3.1.8 org.glassfish.jersey.inject jersey-hk2 3.1.8 org.glassfish.jersey.media jersey-media-jaxb 3.1.8 org.glassfish.jersey.media jersey-media-json-binding 3.1.8 org.glassfish.jersey.media jersey-media-json-gson 3.1.8 org.glassfish.jersey.media jersey-media-json-jackson 3.1.8 org.glassfish.jersey.media jersey-media-json-jettison 3.1.8 org.glassfish.jersey.media jersey-media-json-processing 3.1.8 org.glassfish.jersey.media jersey-media-kryo 3.1.8 org.glassfish.jersey.media jersey-media-moxy 3.1.8 org.glassfish.jersey.media jersey-media-multipart 3.1.8 org.glassfish.jersey.media jersey-media-sse 3.1.8 org.glassfish.jersey.security oauth1-client 3.1.8 org.glassfish.jersey.security oauth1-server 3.1.8 org.glassfish.jersey.security oauth1-signature 3.1.8 org.glassfish.jersey.security oauth2-client 3.1.8 org.glassfish.jersey.test-framework jersey-test-framework-core 3.1.8 org.glassfish.jersey.test-framework jersey-test-framework-util 3.1.8 org.glassfish.jersey.test-framework.providers jersey-test-framework-provider-bundle 3.1.8 org.glassfish.jersey.test-framework.providers jersey-test-framework-provider-external 3.1.8 org.glassfish.jersey.test-framework.providers jersey-test-framework-provider-grizzly2 3.1.8 org.glassfish.jersey.test-framework.providers jersey-test-framework-provider-inmemory 3.1.8 org.glassfish.jersey.test-framework.providers jersey-test-framework-provider-jdk-http 3.1.8 org.glassfish.jersey.test-framework.providers jersey-test-framework-provider-jetty 3.1.8 org.glassfish.jersey.test-framework.providers jersey-test-framework-provider-jetty-http2 3.1.8 org.glassfish.jersey.test-framework.providers jersey-test-framework-provider-netty 3.1.8 org.glassfish.jersey.test-framework.providers jersey-test-framework-provider-simple 3.1.8 org.glassfish.web jakarta.servlet.jsp.jstl 3.0.1 org.hamcrest hamcrest 2.2 org.hamcrest hamcrest-core 2.2 org.hamcrest hamcrest-library 2.2 org.hibernate.orm hibernate-agroal 6.5.3.Final org.hibernate.orm hibernate-ant 6.5.3.Final org.hibernate.orm hibernate-c3p0 6.5.3.Final org.hibernate.orm hibernate-community-dialects 6.5.3.Final org.hibernate.orm hibernate-core 6.5.3.Final org.hibernate.orm hibernate-envers 6.5.3.Final org.hibernate.orm hibernate-graalvm 6.5.3.Final org.hibernate.orm hibernate-hikaricp 6.5.3.Final org.hibernate.orm hibernate-jcache 6.5.3.Final org.hibernate.orm hibernate-jpamodelgen 6.5.3.Final org.hibernate.orm hibernate-micrometer 6.5.3.Final org.hibernate.orm hibernate-proxool 6.5.3.Final org.hibernate.orm hibernate-spatial 6.5.3.Final org.hibernate.orm hibernate-testing 6.5.3.Final org.hibernate.orm hibernate-vibur 6.5.3.Final org.hibernate.validator hibernate-validator 8.0.1.Final org.hibernate.validator hibernate-validator-annotation-processor 8.0.1.Final org.hsqldb hsqldb 2.7.3 org.infinispan infinispan-anchored-keys 15.0.8.Final org.infinispan infinispan-api 15.0.8.Final org.infinispan infinispan-cachestore-jdbc 15.0.8.Final org.infinispan infinispan-cachestore-jdbc-common 15.0.8.Final org.infinispan infinispan-cachestore-remote 15.0.8.Final org.infinispan infinispan-cachestore-rocksdb 15.0.8.Final org.infinispan infinispan-cachestore-sql 15.0.8.Final org.infinispan infinispan-cdi-common 15.0.8.Final org.infinispan infinispan-cdi-embedded 15.0.8.Final org.infinispan infinispan-cdi-remote 15.0.8.Final org.infinispan infinispan-checkstyle 15.0.8.Final org.infinispan infinispan-cli-client 15.0.8.Final org.infinispan infinispan-client-hotrod 15.0.8.Final org.infinispan infinispan-client-rest 15.0.8.Final org.infinispan infinispan-clustered-counter 15.0.8.Final org.infinispan infinispan-clustered-lock 15.0.8.Final org.infinispan infinispan-commons 15.0.8.Final org.infinispan infinispan-commons-graalvm 15.0.8.Final org.infinispan infinispan-commons-test 15.0.8.Final org.infinispan infinispan-component-annotations 15.0.8.Final org.infinispan infinispan-component-processor 15.0.8.Final org.infinispan infinispan-console 15.0.7.Final org.infinispan infinispan-core 15.0.8.Final org.infinispan infinispan-core-graalvm 15.0.8.Final org.infinispan infinispan-hibernate-cache-commons 15.0.8.Final org.infinispan infinispan-hibernate-cache-spi 15.0.8.Final org.infinispan infinispan-hibernate-cache-v62 15.0.8.Final org.infinispan infinispan-hotrod 15.0.8.Final org.infinispan infinispan-jboss-marshalling 15.0.8.Final org.infinispan infinispan-jcache 15.0.8.Final org.infinispan infinispan-jcache-commons 15.0.8.Final org.infinispan infinispan-jcache-remote 15.0.8.Final org.infinispan infinispan-key-value-store-client 15.0.8.Final org.infinispan infinispan-logging-annotations 15.0.8.Final org.infinispan infinispan-logging-processor 15.0.8.Final org.infinispan infinispan-multimap 15.0.8.Final org.infinispan infinispan-objectfilter 15.0.8.Final org.infinispan infinispan-quarkus-embedded 15.0.8.Final org.infinispan infinispan-query 15.0.8.Final org.infinispan infinispan-query-core 15.0.8.Final org.infinispan infinispan-query-dsl 15.0.8.Final org.infinispan infinispan-remote-query-client 15.0.8.Final org.infinispan infinispan-remote-query-server 15.0.8.Final org.infinispan infinispan-scripting 15.0.8.Final org.infinispan infinispan-server-core 15.0.8.Final org.infinispan infinispan-server-hotrod 15.0.8.Final org.infinispan infinispan-server-memcached 15.0.8.Final org.infinispan infinispan-server-resp 15.0.8.Final org.infinispan infinispan-server-rest 15.0.8.Final org.infinispan infinispan-server-router 15.0.8.Final org.infinispan infinispan-server-runtime 15.0.8.Final org.infinispan infinispan-server-testdriver-core 15.0.8.Final org.infinispan infinispan-server-testdriver-junit4 15.0.8.Final org.infinispan infinispan-server-testdriver-junit5 15.0.8.Final org.infinispan infinispan-spring-boot3-starter-embedded 15.0.8.Final org.infinispan infinispan-spring-boot3-starter-remote 15.0.8.Final org.infinispan infinispan-spring6-common 15.0.8.Final org.infinispan infinispan-spring6-embedded 15.0.8.Final org.infinispan infinispan-spring6-remote 15.0.8.Final org.infinispan infinispan-tasks 15.0.8.Final org.infinispan infinispan-tasks-api 15.0.8.Final org.infinispan infinispan-tools 15.0.8.Final org.infinispan.protostream protostream 5.0.8.Final org.infinispan.protostream protostream-processor 5.0.8.Final org.infinispan.protostream protostream-types 5.0.8.Final org.influxdb influxdb-java 2.24 org.jboss.logging jboss-logging 3.5.3.Final org.jdom jdom2 2.0.6.1 org.jetbrains.kotlin kotlin-compiler 1.9.25 org.jetbrains.kotlin kotlin-compiler-embeddable 1.9.25 org.jetbrains.kotlin kotlin-daemon-client 1.9.25 org.jetbrains.kotlin kotlin-main-kts 1.9.25 org.jetbrains.kotlin kotlin-osgi-bundle 1.9.25 org.jetbrains.kotlin kotlin-reflect 1.9.25 org.jetbrains.kotlin kotlin-script-runtime 1.9.25 org.jetbrains.kotlin kotlin-scripting-common 1.9.25 org.jetbrains.kotlin kotlin-scripting-ide-services 1.9.25 org.jetbrains.kotlin kotlin-scripting-jvm 1.9.25 org.jetbrains.kotlin kotlin-scripting-jvm-host 1.9.25 org.jetbrains.kotlin kotlin-stdlib 1.9.25 org.jetbrains.kotlin kotlin-stdlib-common 1.9.25 org.jetbrains.kotlin kotlin-stdlib-jdk7 1.9.25 org.jetbrains.kotlin kotlin-stdlib-jdk8 1.9.25 org.jetbrains.kotlin kotlin-stdlib-js 1.9.25 org.jetbrains.kotlin kotlin-test 1.9.25 org.jetbrains.kotlin kotlin-test-annotations-common 1.9.25 org.jetbrains.kotlin kotlin-test-common 1.9.25 org.jetbrains.kotlin kotlin-test-js 1.9.25 org.jetbrains.kotlin kotlin-test-junit 1.9.25 org.jetbrains.kotlin kotlin-test-junit5 1.9.25 org.jetbrains.kotlin kotlin-test-testng 1.9.25 org.jetbrains.kotlinx kotlinx-coroutines-android 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-core 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-core-jvm 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-debug 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-guava 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-javafx 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-jdk8 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-jdk9 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-play-services 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-reactive 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-reactor 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-rx2 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-rx3 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-slf4j 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-swing 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-test 1.8.1 org.jetbrains.kotlinx kotlinx-coroutines-test-jvm 1.8.1 org.jetbrains.kotlinx kotlinx-serialization-cbor 1.6.3 org.jetbrains.kotlinx kotlinx-serialization-cbor-jvm 1.6.3 org.jetbrains.kotlinx kotlinx-serialization-core 1.6.3 org.jetbrains.kotlinx kotlinx-serialization-core-jvm 1.6.3 org.jetbrains.kotlinx kotlinx-serialization-hocon 1.6.3 org.jetbrains.kotlinx kotlinx-serialization-json 1.6.3 org.jetbrains.kotlinx kotlinx-serialization-json-jvm 1.6.3 org.jetbrains.kotlinx kotlinx-serialization-json-okio 1.6.3 org.jetbrains.kotlinx kotlinx-serialization-json-okio-jvm 1.6.3 org.jetbrains.kotlinx kotlinx-serialization-properties 1.6.3 org.jetbrains.kotlinx kotlinx-serialization-properties-jvm 1.6.3 org.jetbrains.kotlinx kotlinx-serialization-protobuf 1.6.3 org.jetbrains.kotlinx kotlinx-serialization-protobuf-jvm 1.6.3 org.jooq jooq 3.19.11 org.jooq jooq-codegen 3.19.11 org.jooq jooq-kotlin 3.19.11 org.jooq jooq-meta 3.19.11 org.jspecify jspecify 0.3.0 org.junit.jupiter junit-jupiter 5.10.3 org.junit.jupiter junit-jupiter-api 5.10.3 org.junit.jupiter junit-jupiter-engine 5.10.3 org.junit.jupiter junit-jupiter-migrationsupport 5.10.3 org.junit.jupiter junit-jupiter-params 5.10.3 org.junit.platform junit-platform-commons 1.10.3 org.junit.platform junit-platform-console 1.10.3 org.junit.platform junit-platform-engine 1.10.3 org.junit.platform junit-platform-jfr 1.10.3 org.junit.platform junit-platform-launcher 1.10.3 org.junit.platform junit-platform-reporting 1.10.3 org.junit.platform junit-platform-runner 1.10.3 org.junit.platform junit-platform-suite 1.10.3 org.junit.platform junit-platform-suite-api 1.10.3 org.junit.platform junit-platform-suite-commons 1.10.3 org.junit.platform junit-platform-suite-engine 1.10.3 org.junit.platform junit-platform-testkit 1.10.3 org.junit.vintage junit-vintage-engine 5.10.3 org.jvnet.staxex stax-ex 2.1.0 org.liquibase liquibase-cdi 4.27.0 org.liquibase liquibase-core 4.27.0 org.mariadb r2dbc-mariadb 1.2.2 org.mariadb.jdbc mariadb-java-client 3.3.3 org.messaginghub pooled-jms 3.1.6 org.mockito mockito-android 5.11.0 org.mockito mockito-core 5.11.0 org.mockito mockito-errorprone 5.11.0 org.mockito mockito-junit-jupiter 5.11.0 org.mockito mockito-proxy 5.11.0 org.mockito mockito-subclass 5.11.0 org.mongodb bson 5.0.1 org.mongodb bson-record-codec 5.0.1 org.mongodb mongodb-driver-core 5.0.1 org.mongodb mongodb-driver-legacy 5.0.1 org.mongodb mongodb-driver-reactivestreams 5.0.1 org.mongodb mongodb-driver-sync 5.0.1 org.neo4j.driver neo4j-java-driver 5.23.0 org.osgi org.osgi.annotation.bundle 2.0.0 org.osgi org.osgi.annotation.versioning 1.1.2 org.osgi osgi.annotation 8.1.0 org.postgresql postgresql 42.7.4 org.postgresql r2dbc-postgresql 1.0.5.RELEASE org.projectlombok lombok 1.18.34 org.quartz-scheduler quartz 2.3.2 org.quartz-scheduler quartz-jobs 2.3.2 org.reactivestreams reactive-streams 1.0.4 org.seleniumhq.selenium htmlunit-driver 4.13.0 org.seleniumhq.selenium selenium-api 4.19.1 org.seleniumhq.selenium selenium-chrome-driver 4.19.1 org.seleniumhq.selenium selenium-chromium-driver 4.19.1 org.seleniumhq.selenium selenium-devtools-v121 4.19.1 org.seleniumhq.selenium selenium-devtools-v122 4.19.1 org.seleniumhq.selenium selenium-devtools-v123 4.19.1 org.seleniumhq.selenium selenium-devtools-v85 4.19.1 org.seleniumhq.selenium selenium-edge-driver 4.19.1 org.seleniumhq.selenium selenium-firefox-driver 4.19.1 org.seleniumhq.selenium selenium-grid 4.19.1 org.seleniumhq.selenium selenium-http 4.19.1 org.seleniumhq.selenium selenium-ie-driver 4.19.1 org.seleniumhq.selenium selenium-java 4.19.1 org.seleniumhq.selenium selenium-json 4.19.1 org.seleniumhq.selenium selenium-manager 4.19.1 org.seleniumhq.selenium selenium-remote-driver 4.19.1 org.seleniumhq.selenium selenium-safari-driver 4.19.1 org.seleniumhq.selenium selenium-session-map-jdbc 4.19.1 org.seleniumhq.selenium selenium-session-map-redis 4.19.1 org.seleniumhq.selenium selenium-support 4.19.1 org.skyscreamer jsonassert 1.5.3 org.slf4j jcl-over-slf4j 2.0.16 org.slf4j jul-to-slf4j 2.0.16 org.slf4j log4j-over-slf4j 2.0.16 org.slf4j slf4j-api 2.0.16 org.slf4j slf4j-ext 2.0.16 org.slf4j slf4j-jdk-platform-logging 2.0.16 org.slf4j slf4j-jdk14 2.0.16 org.slf4j slf4j-log4j12 2.0.16 org.slf4j slf4j-nop 2.0.16 org.slf4j slf4j-reload4j 2.0.16 org.slf4j slf4j-simple 2.0.16 org.springframework spring-aop 6.1.13 org.springframework spring-aspects 6.1.13 org.springframework spring-beans 6.1.13 org.springframework spring-context 6.1.13 org.springframework spring-context-indexer 6.1.13 org.springframework spring-context-support 6.1.13 org.springframework spring-core 6.1.13 org.springframework spring-core-test 6.1.13 org.springframework spring-expression 6.1.13 org.springframework spring-instrument 6.1.13 org.springframework spring-jcl 6.1.13 org.springframework spring-jdbc 6.1.13 org.springframework spring-jms 6.1.13 org.springframework spring-messaging 6.1.13 org.springframework spring-orm 6.1.13 org.springframework spring-oxm 6.1.13 org.springframework spring-r2dbc 6.1.13 org.springframework spring-test 6.1.13 org.springframework spring-tx 6.1.13 org.springframework spring-web 6.1.13 org.springframework spring-webflux 6.1.13 org.springframework spring-webmvc 6.1.13 org.springframework spring-websocket 6.1.13 org.springframework.amqp spring-amqp 3.1.7 org.springframework.amqp spring-rabbit 3.1.7 org.springframework.amqp spring-rabbit-junit 3.1.7 org.springframework.amqp spring-rabbit-stream 3.1.7 org.springframework.amqp spring-rabbit-test 3.1.7 org.springframework.batch spring-batch-core 5.1.2 org.springframework.batch spring-batch-infrastructure 5.1.2 org.springframework.batch spring-batch-integration 5.1.2 org.springframework.batch spring-batch-test 5.1.2 org.springframework.boot spring-boot 3.3.4 org.springframework.boot spring-boot-actuator 3.3.4 org.springframework.boot spring-boot-actuator-autoconfigure 3.3.4 org.springframework.boot spring-boot-autoconfigure 3.3.4 org.springframework.boot spring-boot-autoconfigure-processor 3.3.4 org.springframework.boot spring-boot-buildpack-platform 3.3.4 org.springframework.boot spring-boot-configuration-metadata 3.3.4 org.springframework.boot spring-boot-configuration-processor 3.3.4 org.springframework.boot spring-boot-devtools 3.3.4 org.springframework.boot spring-boot-docker-compose 3.3.4 org.springframework.boot spring-boot-jarmode-tools 3.3.4 org.springframework.boot spring-boot-loader 3.3.4 org.springframework.boot spring-boot-loader-classic 3.3.4 org.springframework.boot spring-boot-loader-tools 3.3.4 org.springframework.boot spring-boot-properties-migrator 3.3.4 org.springframework.boot spring-boot-starter 3.3.4 org.springframework.boot spring-boot-starter-activemq 3.3.4 org.springframework.boot spring-boot-starter-actuator 3.3.4 org.springframework.boot spring-boot-starter-amqp 3.3.4 org.springframework.boot spring-boot-starter-aop 3.3.4 org.springframework.boot spring-boot-starter-artemis 3.3.4 org.springframework.boot spring-boot-starter-batch 3.3.4 org.springframework.boot spring-boot-starter-cache 3.3.4 org.springframework.boot spring-boot-starter-data-cassandra 3.3.4 org.springframework.boot spring-boot-starter-data-cassandra-reactive 3.3.4 org.springframework.boot spring-boot-starter-data-couchbase 3.3.4 org.springframework.boot spring-boot-starter-data-couchbase-reactive 3.3.4 org.springframework.boot spring-boot-starter-data-elasticsearch 3.3.4 org.springframework.boot spring-boot-starter-data-jdbc 3.3.4 org.springframework.boot spring-boot-starter-data-jpa 3.3.4 org.springframework.boot spring-boot-starter-data-ldap 3.3.4 org.springframework.boot spring-boot-starter-data-mongodb 3.3.4 org.springframework.boot spring-boot-starter-data-mongodb-reactive 3.3.4 org.springframework.boot spring-boot-starter-data-neo4j 3.3.4 org.springframework.boot spring-boot-starter-data-r2dbc 3.3.4 org.springframework.boot spring-boot-starter-data-redis 3.3.4 org.springframework.boot spring-boot-starter-data-redis-reactive 3.3.4 org.springframework.boot spring-boot-starter-data-rest 3.3.4 org.springframework.boot spring-boot-starter-freemarker 3.3.4 org.springframework.boot spring-boot-starter-graphql 3.3.4 org.springframework.boot spring-boot-starter-groovy-templates 3.3.4 org.springframework.boot spring-boot-starter-hateoas 3.3.4 org.springframework.boot spring-boot-starter-integration 3.3.4 org.springframework.boot spring-boot-starter-jdbc 3.3.4 org.springframework.boot spring-boot-starter-jersey 3.3.4 org.springframework.boot spring-boot-starter-jetty 3.3.4 org.springframework.boot spring-boot-starter-jooq 3.3.4 org.springframework.boot spring-boot-starter-json 3.3.4 org.springframework.boot spring-boot-starter-log4j2 3.3.4 org.springframework.boot spring-boot-starter-logging 3.3.4 org.springframework.boot spring-boot-starter-mail 3.3.4 org.springframework.boot spring-boot-starter-mustache 3.3.4 org.springframework.boot spring-boot-starter-oauth2-authorization-server 3.3.4 org.springframework.boot spring-boot-starter-oauth2-client 3.3.4 org.springframework.boot spring-boot-starter-oauth2-resource-server 3.3.4 org.springframework.boot spring-boot-starter-pulsar 3.3.4 org.springframework.boot spring-boot-starter-pulsar-reactive 3.3.4 org.springframework.boot spring-boot-starter-quartz 3.3.4 org.springframework.boot spring-boot-starter-reactor-netty 3.3.4 org.springframework.boot spring-boot-starter-rsocket 3.3.4 org.springframework.boot spring-boot-starter-security 3.3.4 org.springframework.boot spring-boot-starter-test 3.3.4 org.springframework.boot spring-boot-starter-thymeleaf 3.3.4 org.springframework.boot spring-boot-starter-tomcat 3.3.4 org.springframework.boot spring-boot-starter-undertow 3.3.4 org.springframework.boot spring-boot-starter-validation 3.3.4 org.springframework.boot spring-boot-starter-web 3.3.4 org.springframework.boot spring-boot-starter-web-services 3.3.4 org.springframework.boot spring-boot-starter-webflux 3.3.4 org.springframework.boot spring-boot-starter-websocket 3.3.4 org.springframework.boot spring-boot-test 3.3.4 org.springframework.boot spring-boot-test-autoconfigure 3.3.4 org.springframework.boot spring-boot-testcontainers 3.3.4 org.springframework.data spring-data-cassandra 4.3.4 org.springframework.data spring-data-commons 3.3.4 org.springframework.data spring-data-couchbase 5.3.4 org.springframework.data spring-data-elasticsearch 5.3.4 org.springframework.data spring-data-envers 3.3.4 org.springframework.data spring-data-jdbc 3.3.4 org.springframework.data spring-data-jpa 3.3.4 org.springframework.data spring-data-keyvalue 3.3.4 org.springframework.data spring-data-ldap 3.3.4 org.springframework.data spring-data-mongodb 4.3.4 org.springframework.data spring-data-neo4j 7.3.4 org.springframework.data spring-data-r2dbc 3.3.4 org.springframework.data spring-data-redis 3.3.4 org.springframework.data spring-data-relational 3.3.4 org.springframework.data spring-data-rest-core 4.3.4 org.springframework.data spring-data-rest-hal-explorer 4.3.4 org.springframework.data spring-data-rest-webmvc 4.3.4 org.springframework.graphql spring-graphql 1.3.2 org.springframework.graphql spring-graphql-test 1.3.2 org.springframework.hateoas spring-hateoas 2.3.3 org.springframework.integration spring-integration-amqp 6.3.4 org.springframework.integration spring-integration-camel 6.3.4 org.springframework.integration spring-integration-cassandra 6.3.4 org.springframework.integration spring-integration-core 6.3.4 org.springframework.integration spring-integration-debezium 6.3.4 org.springframework.integration spring-integration-event 6.3.4 org.springframework.integration spring-integration-feed 6.3.4 org.springframework.integration spring-integration-file 6.3.4 org.springframework.integration spring-integration-ftp 6.3.4 org.springframework.integration spring-integration-graphql 6.3.4 org.springframework.integration spring-integration-groovy 6.3.4 org.springframework.integration spring-integration-hazelcast 6.3.4 org.springframework.integration spring-integration-http 6.3.4 org.springframework.integration spring-integration-ip 6.3.4 org.springframework.integration spring-integration-jdbc 6.3.4 org.springframework.integration spring-integration-jms 6.3.4 org.springframework.integration spring-integration-jmx 6.3.4 org.springframework.integration spring-integration-jpa 6.3.4 org.springframework.integration spring-integration-kafka 6.3.4 org.springframework.integration spring-integration-mail 6.3.4 org.springframework.integration spring-integration-mongodb 6.3.4 org.springframework.integration spring-integration-mqtt 6.3.4 org.springframework.integration spring-integration-r2dbc 6.3.4 org.springframework.integration spring-integration-redis 6.3.4 org.springframework.integration spring-integration-rsocket 6.3.4 org.springframework.integration spring-integration-scripting 6.3.4 org.springframework.integration spring-integration-sftp 6.3.4 org.springframework.integration spring-integration-smb 6.3.4 org.springframework.integration spring-integration-stomp 6.3.4 org.springframework.integration spring-integration-stream 6.3.4 org.springframework.integration spring-integration-syslog 6.3.4 org.springframework.integration spring-integration-test 6.3.4 org.springframework.integration spring-integration-test-support 6.3.4 org.springframework.integration spring-integration-webflux 6.3.4 org.springframework.integration spring-integration-websocket 6.3.4 org.springframework.integration spring-integration-ws 6.3.4 org.springframework.integration spring-integration-xml 6.3.4 org.springframework.integration spring-integration-xmpp 6.3.4 org.springframework.integration spring-integration-zeromq 6.3.4 org.springframework.integration spring-integration-zip 6.3.4 org.springframework.integration spring-integration-zookeeper 6.3.4 org.springframework.kafka spring-kafka 3.2.4 org.springframework.kafka spring-kafka-test 3.2.4 org.springframework.ldap spring-ldap-core 3.2.6 org.springframework.ldap spring-ldap-ldif-core 3.2.6 org.springframework.ldap spring-ldap-odm 3.2.6 org.springframework.ldap spring-ldap-test 3.2.6 org.springframework.pulsar spring-pulsar 1.1.4 org.springframework.pulsar spring-pulsar-cache-provider 1.1.4 org.springframework.pulsar spring-pulsar-cache-provider-caffeine 1.1.4 org.springframework.pulsar spring-pulsar-reactive 1.1.4 org.springframework.pulsar spring-pulsar-test 1.1.4 org.springframework.restdocs spring-restdocs-asciidoctor 3.0.1 org.springframework.restdocs spring-restdocs-core 3.0.1 org.springframework.restdocs spring-restdocs-mockmvc 3.0.1 org.springframework.restdocs spring-restdocs-restassured 3.0.1 org.springframework.restdocs spring-restdocs-webtestclient 3.0.1 org.springframework.retry spring-retry 2.0.9 org.springframework.security spring-security-acl 6.3.3 org.springframework.security spring-security-aspects 6.3.3 org.springframework.security spring-security-cas 6.3.3 org.springframework.security spring-security-config 6.3.3 org.springframework.security spring-security-core 6.3.3 org.springframework.security spring-security-crypto 6.3.3 org.springframework.security spring-security-data 6.3.3 org.springframework.security spring-security-ldap 6.3.3 org.springframework.security spring-security-messaging 6.3.3 org.springframework.security spring-security-oauth2-authorization-server 1.3.2 org.springframework.security spring-security-oauth2-client 6.3.3 org.springframework.security spring-security-oauth2-core 6.3.3 org.springframework.security spring-security-oauth2-jose 6.3.3 org.springframework.security spring-security-oauth2-resource-server 6.3.3 org.springframework.security spring-security-rsocket 6.3.3 org.springframework.security spring-security-saml2-service-provider 6.3.3 org.springframework.security spring-security-taglibs 6.3.3 org.springframework.security spring-security-test 6.3.3 org.springframework.security spring-security-web 6.3.3 org.springframework.session spring-session-core 3.3.2 org.springframework.session spring-session-data-mongodb 3.3.2 org.springframework.session spring-session-data-redis 3.3.2 org.springframework.session spring-session-hazelcast 3.3.2 org.springframework.session spring-session-jdbc 3.3.2 org.springframework.ws spring-ws-core 4.0.11 org.springframework.ws spring-ws-security 4.0.11 org.springframework.ws spring-ws-support 4.0.11 org.springframework.ws spring-ws-test 4.0.11 org.springframework.ws spring-xml 4.0.11 org.testcontainers activemq 1.19.8 org.testcontainers azure 1.19.8 org.testcontainers cassandra 1.19.8 org.testcontainers chromadb 1.19.8 org.testcontainers clickhouse 1.19.8 org.testcontainers cockroachdb 1.19.8 org.testcontainers consul 1.19.8 org.testcontainers couchbase 1.19.8 org.testcontainers cratedb 1.19.8 org.testcontainers database-commons 1.19.8 org.testcontainers db2 1.19.8 org.testcontainers dynalite 1.19.8 org.testcontainers elasticsearch 1.19.8 org.testcontainers gcloud 1.19.8 org.testcontainers hivemq 1.19.8 org.testcontainers influxdb 1.19.8 org.testcontainers jdbc 1.19.8 org.testcontainers junit-jupiter 1.19.8 org.testcontainers k3s 1.19.8 org.testcontainers k6 1.19.8 org.testcontainers kafka 1.19.8 org.testcontainers localstack 1.19.8 org.testcontainers mariadb 1.19.8 org.testcontainers milvus 1.19.8 org.testcontainers minio 1.19.8 org.testcontainers mockserver 1.19.8 org.testcontainers mongodb 1.19.8 org.testcontainers mssqlserver 1.19.8 org.testcontainers mysql 1.19.8 org.testcontainers neo4j 1.19.8 org.testcontainers nginx 1.19.8 org.testcontainers oceanbase 1.19.8 org.testcontainers ollama 1.19.8 org.testcontainers openfga 1.19.8 org.testcontainers oracle-free 1.19.8 org.testcontainers oracle-xe 1.19.8 org.testcontainers orientdb 1.19.8 org.testcontainers postgresql 1.19.8 org.testcontainers presto 1.19.8 org.testcontainers pulsar 1.19.8 org.testcontainers qdrant 1.19.8 org.testcontainers questdb 1.19.8 org.testcontainers r2dbc 1.19.8 org.testcontainers rabbitmq 1.19.8 org.testcontainers redpanda 1.19.8 org.testcontainers selenium 1.19.8 org.testcontainers solace 1.19.8 org.testcontainers solr 1.19.8 org.testcontainers spock 1.19.8 org.testcontainers testcontainers 1.19.8 org.testcontainers tidb 1.19.8 org.testcontainers toxiproxy 1.19.8 org.testcontainers trino 1.19.8 org.testcontainers vault 1.19.8 org.testcontainers weaviate 1.19.8 org.testcontainers yugabytedb 1.19.8 org.thymeleaf thymeleaf 3.1.2.RELEASE org.thymeleaf thymeleaf-spring6 3.1.2.RELEASE org.thymeleaf.extras thymeleaf-extras-springsecurity6 3.1.2.RELEASE org.webjars webjars-locator-core 0.58 org.xerial sqlite-jdbc 3.45.3.0 org.xmlunit xmlunit-assertj 2.9.1 org.xmlunit xmlunit-assertj3 2.9.1 org.xmlunit xmlunit-core 2.9.1 org.xmlunit xmlunit-jakarta-jaxb-impl 2.9.1 org.xmlunit xmlunit-legacy 2.9.1 org.xmlunit xmlunit-matchers 2.9.1 org.xmlunit xmlunit-placeholders 2.9.1 org.yaml snakeyaml 2.2 redis.clients jedis 5.0.2 wsdl4j wsdl4j 1.6.3"
"https://docs.spring.io/spring-boot/appendix/dependency-versions/properties.html","Version Properties: The following table provides all properties that can be used to override the versions managed by Spring Boot. Browse the spring-boot-dependencies build.gradle(https://github.com/spring-projects/spring-boot/tree/v3.3.4/spring-boot-project/spring-boot-dependencies/build.gradle) for a complete list of dependencies. You can learn how to customize these versions in your application in the Build Tool Plugins(../../build-tool-plugin/index.html) documentation. Library Version Property ActiveMQ activemq.version Angus Mail angus-mail.version Artemis artemis.version AspectJ aspectj.version AssertJ assertj.version Awaitility awaitility.version Brave brave.version Build Helper Maven Plugin build-helper-maven-plugin.version Byte Buddy byte-buddy.version cache2k cache2k.version Caffeine caffeine.version Cassandra Driver cassandra-driver.version Classmate classmate.version Commons Codec commons-codec.version Commons DBCP2 commons-dbcp2.version Commons Lang3 commons-lang3.version Commons Pool commons-pool.version Commons Pool2 commons-pool2.version Couchbase Client couchbase-client.version Crac crac.version CycloneDX Maven Plugin cyclonedx-maven-plugin.version DB2 JDBC db2-jdbc.version Dependency Management Plugin dependency-management-plugin.version Derby derby.version Ehcache3 ehcache3.version Elasticsearch Client elasticsearch-client.version Flyway flyway.version FreeMarker freemarker.version Git Commit ID Maven Plugin git-commit-id-maven-plugin.version Glassfish JAXB glassfish-jaxb.version Glassfish JSTL glassfish-jstl.version GraphQL Java graphql-java.version Groovy groovy.version Gson gson.version H2 h2.version Hamcrest hamcrest.version Hazelcast hazelcast.version Hibernate hibernate.version Hibernate Validator hibernate-validator.version HikariCP hikaricp.version HSQLDB hsqldb.version HtmlUnit htmlunit.version HttpAsyncClient httpasyncclient.version HttpClient5 httpclient5.version HttpCore httpcore.version HttpCore5 httpcore5.version Infinispan infinispan.version InfluxDB Java influxdb-java.version Jackson Bom jackson-bom.version Jakarta Activation jakarta-activation.version Jakarta Annotation jakarta-annotation.version Jakarta Inject jakarta-inject.version Jakarta JMS jakarta-jms.version Jakarta Json jakarta-json.version Jakarta Json Bind jakarta-json-bind.version Jakarta Mail jakarta-mail.version Jakarta Management jakarta-management.version Jakarta Persistence jakarta-persistence.version Jakarta Servlet jakarta-servlet.version Jakarta Servlet JSP JSTL jakarta-servlet-jsp-jstl.version Jakarta Transaction jakarta-transaction.version Jakarta Validation jakarta-validation.version Jakarta WebSocket jakarta-websocket.version Jakarta WS RS jakarta-ws-rs.version Jakarta XML Bind jakarta-xml-bind.version Jakarta XML SOAP jakarta-xml-soap.version Jakarta XML WS jakarta-xml-ws.version Janino janino.version Javax Cache javax-cache.version Javax Money javax-money.version Jaxen jaxen.version Jaybird jaybird.version JBoss Logging jboss-logging.version JDOM2 jdom2.version Jedis jedis.version Jersey jersey.version Jetty jetty.version Jetty Reactive HTTPClient jetty-reactive-httpclient.version JMustache jmustache.version jOOQ jooq.version Json Path json-path.version Json-smart json-smart.version JsonAssert jsonassert.version JTDS jtds.version JUnit junit.version JUnit Jupiter junit-jupiter.version Kafka kafka.version Kotlin kotlin.version Kotlin Coroutines kotlin-coroutines.version Kotlin Serialization kotlin-serialization.version Lettuce lettuce.version Liquibase liquibase.version Log4j2 log4j2.version Logback logback.version Lombok lombok.version MariaDB mariadb.version Maven AntRun Plugin maven-antrun-plugin.version Maven Assembly Plugin maven-assembly-plugin.version Maven Clean Plugin maven-clean-plugin.version Maven Compiler Plugin maven-compiler-plugin.version Maven Dependency Plugin maven-dependency-plugin.version Maven Deploy Plugin maven-deploy-plugin.version Maven Enforcer Plugin maven-enforcer-plugin.version Maven Failsafe Plugin maven-failsafe-plugin.version Maven Help Plugin maven-help-plugin.version Maven Install Plugin maven-install-plugin.version Maven Invoker Plugin maven-invoker-plugin.version Maven Jar Plugin maven-jar-plugin.version Maven Javadoc Plugin maven-javadoc-plugin.version Maven Resources Plugin maven-resources-plugin.version Maven Shade Plugin maven-shade-plugin.version Maven Source Plugin maven-source-plugin.version Maven Surefire Plugin maven-surefire-plugin.version Maven War Plugin maven-war-plugin.version Micrometer micrometer.version Micrometer Tracing micrometer-tracing.version Mockito mockito.version MongoDB mongodb.version MSSQL JDBC mssql-jdbc.version MySQL mysql.version Native Build Tools Plugin native-build-tools-plugin.version NekoHTML nekohtml.version Neo4j Java Driver neo4j-java-driver.version Netty netty.version OkHttp okhttp.version OpenTelemetry opentelemetry.version Oracle Database oracle-database.version Oracle R2DBC oracle-r2dbc.version Pooled JMS pooled-jms.version Postgresql postgresql.version Prometheus Client prometheus-client.version Prometheus Simpleclient prometheus-simpleclient.version Pulsar pulsar.version Pulsar Reactive pulsar-reactive.version Quartz quartz.version QueryDSL querydsl.version R2DBC H2 r2dbc-h2.version R2DBC MariaDB r2dbc-mariadb.version R2DBC MSSQL r2dbc-mssql.version R2DBC MySQL r2dbc-mysql.version R2DBC Pool r2dbc-pool.version R2DBC Postgresql r2dbc-postgresql.version R2DBC Proxy r2dbc-proxy.version R2DBC SPI r2dbc-spi.version Rabbit AMQP Client rabbit-amqp-client.version Rabbit Stream Client rabbit-stream-client.version Reactive Streams reactive-streams.version Reactor Bom reactor-bom.version REST Assured rest-assured.version RSocket rsocket.version RxJava3 rxjava3.version SAAJ Impl saaj-impl.version Selenium selenium.version Selenium HtmlUnit selenium-htmlunit.version SendGrid sendgrid.version SLF4J slf4j.version SnakeYAML snakeyaml.version Spring AMQP spring-amqp.version Spring Authorization Server spring-authorization-server.version Spring Batch spring-batch.version Spring Data Bom spring-data-bom.version Spring Framework spring-framework.version Spring GraphQL spring-graphql.version Spring HATEOAS spring-hateoas.version Spring Integration spring-integration.version Spring Kafka spring-kafka.version Spring LDAP spring-ldap.version Spring Pulsar spring-pulsar.version Spring RESTDocs spring-restdocs.version Spring Retry spring-retry.version Spring Security spring-security.version Spring Session spring-session.version Spring WS spring-ws.version SQLite JDBC sqlite-jdbc.version Testcontainers testcontainers.version Thymeleaf thymeleaf.version Thymeleaf Extras Data Attribute thymeleaf-extras-data-attribute.version Thymeleaf Extras SpringSecurity thymeleaf-extras-springsecurity.version Thymeleaf Layout Dialect thymeleaf-layout-dialect.version Tomcat tomcat.version UnboundID LDAPSDK unboundid-ldapsdk.version Undertow undertow.version Versions Maven Plugin versions-maven-plugin.version WebJars Locator Core webjars-locator-core.version WSDL4j wsdl4j.version XML Maven Plugin xml-maven-plugin.version XmlUnit2 xmlunit2.version Yasson yasson.version Zipkin Reporter zipkin-reporter.version"
