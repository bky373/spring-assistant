"url","content"
"https://docs.spring.io/spring-cloud-commons/reference/index.html","Cloud Native Applications: Spring Cloud is released under the non-restrictive Apache 2.0 license. If you would like to contribute to this section of the documentation or if you find an error, you can find the source code and issue trackers for the project at github(https://github.com/spring-cloud/spring-cloud-commons/issues/) ."
"https://docs.spring.io/spring-cloud-commons/reference/intro.html","Introduction: Cloud Native(https://pivotal.io/platform-as-a-service/migrating-to-cloud-native-application-architectures-ebook) is a style of application development that encourages easy adoption of best practices in the areas of continuous delivery and value-driven development. A related discipline is that of building 12-factor Applications(https://12factor.net/) , in which development practices are aligned with delivery and operations goals — for instance, by using declarative programming and management and monitoring. Spring Cloud facilitates these styles of development in a number of specific ways. The starting point is a set of features to which all components in a distributed system need easy access. Many of those features are covered by Spring Boot(https://projects.spring.io/spring-boot) , on which Spring Cloud builds. Some more features are delivered by Spring Cloud as two libraries: Spring Cloud Context and Spring Cloud Commons. Spring Cloud Context provides utilities and special services for the ApplicationContext of a Spring Cloud application (bootstrap context, encryption, refresh scope, and environment endpoints). Spring Cloud Commons is a set of abstractions and common classes used in different Spring Cloud implementations (such as Spring Cloud Netflix and Spring Cloud Consul)."
"https://docs.spring.io/spring-cloud-commons/reference/spring-cloud-commons/application-context-services.html","Spring Cloud Context: Application Context Services: Spring Boot has an opinionated view of how to build an application with Spring. For instance, it has conventional locations for common configuration files and has endpoints for common management and monitoring tasks. Spring Cloud builds on top of that and adds a few features that many components in a system would use or occasionally need. The Bootstrap Application Context: A Spring Cloud application operates by creating a “bootstrap” context, which is a parent context for the main application. This context is responsible for loading configuration properties from the external sources and for decrypting properties in the local external configuration files. The two contexts share an Environment , which is the source of external properties for any Spring application. By default, bootstrap properties (not bootstrap.properties but properties that are loaded during the bootstrap phase) are added with high precedence, so they cannot be overridden by local configuration. The bootstrap context uses a different convention for locating external configuration than the main application context. Instead of application.yml (or .properties ), you can use bootstrap.yml , keeping the external configuration for bootstrap and main context nicely separate. The following listing shows an example: bootstrap.yml spring: application: name: foo cloud: config: uri: ${SPRING_CONFIG_URI:http://localhost:8888} If your application needs any application-specific configuration from the server, it is a good idea to set the spring.application.name (in bootstrap.yml or application.yml ). For the property spring.application.name to be used as the application’s context ID, you must set it in bootstrap.[properties | yml] . If you want to retrieve specific profile configuration, you should also set spring.profiles.active in bootstrap.[properties | yml] . You can disable the bootstrap process completely by setting spring.cloud.bootstrap.enabled=false (for example, in system properties). Application Context Hierarchies: If you build an application context from SpringApplication or SpringApplicationBuilder , the Bootstrap context is added as a parent to that context. It is a feature of Spring that child contexts inherit property sources and profiles from their parent, so the “main” application context contains additional property sources, compared to building the same context without Spring Cloud Config. The additional property sources are: “bootstrap”: If any PropertySourceLocators are found in the bootstrap context and if they have non-empty properties, an optional CompositePropertySource appears with high priority. An example would be properties from the Spring Cloud Config Server. See “ Customizing the Bootstrap Property Sources(#customizing-bootstrap-property-sources) ” for how to customize the contents of this property source. Prior to Spring Cloud 2022.0.3 PropertySourceLocators (including the ones for Spring Cloud Config) were run during the main application context and not in the Bootstrap context. You can force PropertySourceLocators to be run during the Bootstrap context by setting spring.cloud.config.initialize-on-context-refresh=true in bootstrap.[properties | yaml] . “applicationConfig: [classpath:bootstrap.yml]” (and related files if Spring profiles are active): If you have a bootstrap.yml (or .properties ), those properties are used to configure the bootstrap context. Then they get added to the child context when its parent is set. They have lower precedence than the application.yml (or .properties ) and any other property sources that are added to the child as a normal part of the process of creating a Spring Boot application. See “ Changing the Location of Bootstrap Properties(#customizing-bootstrap-properties) ” for how to customize the contents of these property sources. Because of the ordering rules of property sources, the “bootstrap” entries take precedence. However, note that these do not contain any data from bootstrap.yml , which has very low precedence but can be used to set defaults. You can extend the context hierarchy by setting the parent context of any ApplicationContext you create — for example, by using its own interface or with the SpringApplicationBuilder convenience methods ( parent() , child() and sibling() ). The bootstrap context is the parent of the most senior ancestor that you create yourself. Every context in the hierarchy has its own “bootstrap” (possibly empty) property source to avoid promoting values inadvertently from parents down to their descendants. If there is a config server, every context in the hierarchy can also (in principle) have a different spring.application.name and, hence, a different remote property source. Normal Spring application context behavior rules apply to property resolution: properties from a child context override those in the parent, by name and also by property source name. (If the child has a property source with the same name as the parent, the value from the parent is not included in the child). Note that the SpringApplicationBuilder lets you share an Environment amongst the whole hierarchy, but that is not the default. Thus, sibling contexts (in particular) do not need to have the same profiles or property sources, even though they may share common values with their parent. Changing the Location of Bootstrap Properties: The bootstrap.yml (or .properties ) location can be specified by setting spring.cloud.bootstrap.name (default: bootstrap ), spring.cloud.bootstrap.location (default: empty) or spring.cloud.bootstrap.additional-location (default: empty) — for example, in System properties. Those properties behave like the spring.config.* variants with the same name. With spring.cloud.bootstrap.location the default locations are replaced and only the specified ones are used. To add locations to the list of default ones, spring.cloud.bootstrap.additional-location can be used. In fact, they are used to set up the bootstrap ApplicationContext by setting those properties in its Environment . If there is an active profile (from spring.profiles.active or through the Environment API in the context you are building), properties in that profile get loaded as well, the same as in a regular Spring Boot app — for example, from bootstrap-development.properties for a development profile. Overriding the Values of Remote Properties: The property sources that are added to your application by the bootstrap context are often “remote” (from example, from Spring Cloud Config Server). By default, they cannot be overridden locally. If you want to let your applications override the remote properties with their own system properties or config files, the remote property source has to grant it permission by setting spring.cloud.config.allowOverride=true (it does not work to set this locally). Once that flag is set, two finer-grained settings control the location of the remote properties in relation to system properties and the application’s local configuration: spring.cloud.config.overrideNone=true : Override from any local property source. spring.cloud.config.overrideSystemProperties=false : Only system properties, command line arguments, and environment variables (but not the local config files) should override the remote settings. Customizing the Bootstrap Configuration: The bootstrap context can be set to do anything you like by adding entries to /META-INF/spring.factories under a key named org.springframework.cloud.bootstrap.BootstrapConfiguration . This holds a comma-separated list of Spring @Configuration classes that are used to create the context. Any beans that you want to be available to the main application context for autowiring can be created here. There is a special contract for @Beans of type ApplicationContextInitializer . If you want to control the startup sequence, you can mark classes with the @Order annotation (the default order is last ). When adding custom BootstrapConfiguration , be careful that the classes you add are not @ComponentScanned by mistake into your “main” application context, where they might not be needed. Use a separate package name for boot configuration classes and make sure that name is not already covered by your @ComponentScan or @SpringBootApplication annotated configuration classes. The bootstrap process ends by injecting initializers into the main SpringApplication instance (which is the normal Spring Boot startup sequence, whether it runs as a standalone application or is deployed in an application server). First, a bootstrap context is created from the classes found in spring.factories . Then, all @Beans of type ApplicationContextInitializer are added to the main SpringApplication before it is started. Customizing the Bootstrap Property Sources: The default property source for external configuration added by the bootstrap process is the Spring Cloud Config Server, but you can add additional sources by adding beans of type PropertySourceLocator to the bootstrap context (through spring.factories ). For instance, you can insert additional properties from a different server or from a database. As an example, consider the following custom locator: @Configuration public class CustomPropertySourceLocator implements PropertySourceLocator { @Override public PropertySource<?> locate(Environment environment) { return new MapPropertySource(""customProperty"", Collections.<String, Object>singletonMap(""property.from.sample.custom.source"", ""worked as intended"")); } } The Environment that is passed in is the one for the ApplicationContext about to be created — in other words, the one for which we supply additional property sources. It already has its normal Spring Boot-provided property sources, so you can use those to locate a property source specific to this Environment (for example, by keying it on spring.application.name , as is done in the default Spring Cloud Config Server property source locator). If you create a jar with this class in it and then add a META-INF/spring.factories containing the following setting, the customProperty PropertySource appears in any application that includes that jar on its classpath: org.springframework.cloud.bootstrap.BootstrapConfiguration=sample.custom.CustomPropertySourceLocator As of Spring Cloud 2022.0.3, Spring Cloud will now call PropertySourceLocators twice. The first fetch will retrieve any property sources without any profiles. These property sources will have the opportunity to activate profiles using spring.profiles.active . After the main application context starts PropertySourceLocators will be called a second time, this time with any active profiles allowing PropertySourceLocators to locate any additional PropertySources with profiles. Logging Configuration: If you use Spring Boot to configure log settings, you should place this configuration in bootstrap.[yml | properties] if you would like it to apply to all events. For Spring Cloud to initialize logging configuration properly, you cannot use a custom prefix. For example, using custom.loggin.logpath is not recognized by Spring Cloud when initializing the logging system. Environment Changes: The application listens for an EnvironmentChangeEvent and reacts to the change in a couple of standard ways (additional ApplicationListeners can be added as @Beans in the normal way). When an EnvironmentChangeEvent is observed, it has a list of key values that have changed, and the application uses those to: Re-bind any @ConfigurationProperties beans in the context. Set the logger levels for any properties in logging.level.* . Note that the Spring Cloud Config Client does not, by default, poll for changes in the Environment . Generally, we would not recommend that approach for detecting changes (although you can set it up with a @Scheduled annotation). If you have a scaled-out client application, it is better to broadcast the EnvironmentChangeEvent to all the instances instead of having them polling for changes (for example, by using the Spring Cloud Bus(https://github.com/spring-cloud/spring-cloud-bus) ). The EnvironmentChangeEvent covers a large class of refresh use cases, as long as you can actually make a change to the Environment and publish the event. Note that those APIs are public and part of core Spring). You can verify that the changes are bound to @ConfigurationProperties beans by visiting the /configprops endpoint (a standard Spring Boot Actuator feature). For instance, a DataSource can have its maxPoolSize changed at runtime (the default DataSource created by Spring Boot is a @ConfigurationProperties bean) and grow capacity dynamically. Re-binding @ConfigurationProperties does not cover another large class of use cases, where you need more control over the refresh and where you need a change to be atomic over the whole ApplicationContext . To address those concerns, we have @RefreshScope . Refresh Scope: When there is a configuration change, a Spring @Bean that is marked as @RefreshScope gets special treatment. This feature addresses the problem of stateful beans that get their configuration injected only when they are initialized. For instance, if a DataSource has open connections when the database URL is changed through the Environment , you probably want the holders of those connections to be able to complete what they are doing. Then, the next time something borrows a connection from the pool, it gets one with the new URL. Sometimes, it might even be mandatory to apply the @RefreshScope annotation on some beans that can be only initialized once. If a bean is “immutable”, you have to either annotate the bean with @RefreshScope or specify the classname under the property key: spring.cloud.refresh.extra-refreshable . If you hava a DataSource bean that is a HikariDataSource , it can not be refreshed. It is the default value for spring.cloud.refresh.never-refreshable . Choose a different DataSource implementation if you need it to be refreshed. Refresh scope beans are lazy proxies that initialize when they are used (that is, when a method is called), and the scope acts as a cache of initialized values. To force a bean to re-initialize on the next method call, you must invalidate its cache entry. The RefreshScope is a bean in the context and has a public refreshAll() method to refresh all beans in the scope by clearing the target cache. The /refresh endpoint exposes this functionality (over HTTP or JMX). To refresh an individual bean by name, there is also a refresh(String) method. To expose the /refresh endpoint, you need to add following configuration to your application: management: endpoints: web: exposure: include: refresh @RefreshScope works (technically) on a @Configuration class, but it might lead to surprising behavior. For example, it does not mean that all the @Beans defined in that class are themselves in @RefreshScope . Specifically, anything that depends on those beans cannot rely on them being updated when a refresh is initiated, unless it is itself in @RefreshScope . In that case, it is rebuilt on a refresh and its dependencies are re-injected. At that point, they are re-initialized from the refreshed @Configuration ). Removing a configuration value and then performing a refresh will not update the presence of the configuration value. The configuration property must be present in order to update the value after a refresh. If you are relying on the presence of a value in your application you might want to switch your logic to rely on its absence instead. Another option would be to rely on the value changing rather than not being present in the application’s configuration. Context Refresh is not supported for Spring AOT transformations and native images. For AOT and native images, spring.cloud.refresh.enabled needs to be set to false . Refresh Scope on Restart: Seamlessly refreshing beans on restart is especially useful for applications that run with JVM Checkpoint Restore (such as Project CRaC(https://github.com/CRaC) ). To allow this ability, we now instantiate a RefreshScopeLifecycle bean that triggers Context Refresh on restart, resulting in rebinding configuration properties and refreshing any beans annotated with @RefreshScope . You can disable this behavior by setting spring.cloud.refresh.on-restart.enabled to false . Encryption and Decryption: Spring Cloud has an Environment pre-processor for decrypting property values locally. It follows the same rules as the Spring Cloud Config Server and has the same external configuration through encrypt.* . Thus, you can use encrypted values in the form of {cipher}* , and, as long as there is a valid key, they are decrypted before the main application context gets the Environment settings. To use the encryption features in an application, you need to include Spring Security RSA in your classpath (Maven co-ordinates: org.springframework.security:spring-security-rsa ), and you also need the full strength JCE extensions in your JVM. If you get an exception due to ""Illegal key size"" and you use Sun’s JDK, you need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files. See the following links for more information: Java 6 JCE(https://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html) Java 7 JCE(https://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html) Java 8 JCE(https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html) Extract the files into the JDK/jre/lib/security folder for whichever version of JRE/JDK x64/x86 you use. Endpoints: For a Spring Boot Actuator application, some additional management endpoints are available. You can use: POST to /actuator/env to update the Environment and rebind @ConfigurationProperties and log levels. To enabled this endpoint you must set management.endpoint.env.post.enabled=true . /actuator/refresh to re-load the boot strap context and refresh the @RefreshScope beans. /actuator/restart to close the ApplicationContext and restart it (disabled by default). /actuator/pause and /actuator/resume for calling the Lifecycle methods ( stop() and start() on the ApplicationContext ). While enabling the POST method for /actuator/env endpoint can provide flexibility and convenience in managing your application environment variables, it’s critical to ensure that the endpoint is secured and monitored to prevent potential security risks. Add a spring-boot-starter-security dependency to configure access control for the actuator’s endpoint. If you disable the /actuator/restart endpoint then the /actuator/pause and /actuator/resume endpoints will also be disabled since they are just a special case of /actuator/restart ."
"https://docs.spring.io/spring-cloud-commons/reference/spring-cloud-commons/common-abstractions.html","Spring Cloud Commons: Common Abstractions: Patterns such as service discovery, load balancing, and circuit breakers lend themselves to a common abstraction layer that can be consumed by all Spring Cloud clients, independent of the implementation (for example, discovery with Eureka or Consul). The @EnableDiscoveryClient Annotation: Spring Cloud Commons provides the @EnableDiscoveryClient annotation. This looks for implementations of the DiscoveryClient and ReactiveDiscoveryClient interfaces with META-INF/spring.factories . Implementations of the discovery client add a configuration class to spring.factories under the org.springframework.cloud.client.discovery.EnableDiscoveryClient key. Examples of DiscoveryClient implementations include Spring Cloud Netflix Eureka(https://cloud.spring.io/spring-cloud-netflix/) , Spring Cloud Consul Discovery(https://cloud.spring.io/spring-cloud-consul/) , and Spring Cloud Zookeeper Discovery(https://cloud.spring.io/spring-cloud-zookeeper/) . Spring Cloud will provide both the blocking and reactive service discovery clients by default. You can disable the blocking and/or reactive clients easily by setting spring.cloud.discovery.blocking.enabled=false or spring.cloud.discovery.reactive.enabled=false . To completely disable service discovery you just need to set spring.cloud.discovery.enabled=false . By default, implementations of DiscoveryClient auto-register the local Spring Boot server with the remote discovery server. This behavior can be disabled by setting autoRegister=false in @EnableDiscoveryClient . @EnableDiscoveryClient is no longer required. You can put a DiscoveryClient implementation on the classpath to cause the Spring Boot application to register with the service discovery server. Health Indicators: Commons auto-configures the following Spring Boot health indicators. DiscoveryClientHealthIndicator: This health indicator is based on the currently registered DiscoveryClient implementation. To disable entirely, set spring.cloud.discovery.client.health-indicator.enabled=false . To disable the description field, set spring.cloud.discovery.client.health-indicator.include-description=false . Otherwise, it can bubble up as the description of the rolled up HealthIndicator . To disable service retrieval, set spring.cloud.discovery.client.health-indicator.use-services-query=false . By default, the indicator invokes the client’s getServices method. In deployments with many registered services it may too costly to retrieve all services during every check. This will skip the service retrieval and instead use the client’s probe method. DiscoveryCompositeHealthContributor: This composite health indicator is based on all registered DiscoveryHealthIndicator beans. To disable, set spring.cloud.discovery.client.composite-indicator.enabled=false . Ordering DiscoveryClient instances: DiscoveryClient interface extends Ordered . This is useful when using multiple discovery clients, as it allows you to define the order of the returned discovery clients, similar to how you can order the beans loaded by a Spring application. By default, the order of any DiscoveryClient is set to 0 . If you want to set a different order for your custom DiscoveryClient implementations, you just need to override the getOrder() method so that it returns the value that is suitable for your setup. Apart from this, you can use properties to set the order of the DiscoveryClient implementations provided by Spring Cloud, among others ConsulDiscoveryClient , EurekaDiscoveryClient and ZookeeperDiscoveryClient . In order to do it, you just need to set the spring.cloud.{clientIdentifier}.discovery.order (or eureka.client.order for Eureka) property to the desired value. SimpleDiscoveryClient: If there is no Service-Registry-backed DiscoveryClient in the classpath, SimpleDiscoveryClient instance, that uses properties to get information on service and instances, will be used. The information about the available instances should be passed to via properties in the following format: spring.cloud.discovery.client.simple.instances.service1[0].uri=http://s11:8080 , where spring.cloud.discovery.client.simple.instances is the common prefix, then service1 stands for the ID of the service in question, while [0] indicates the index number of the instance (as visible in the example, indexes start with 0 ), and then the value of uri is the actual URI under which the instance is available. ServiceRegistry: Commons now provides a ServiceRegistry interface that provides methods such as register(Registration) and deregister(Registration) , which let you provide custom registered services. Registration is a marker interface. The following example shows the ServiceRegistry in use: @Configuration @EnableDiscoveryClient(autoRegister=false) public class MyConfiguration { private ServiceRegistry registry; public MyConfiguration(ServiceRegistry registry) { this.registry = registry; } // called through some external process, such as an event or a custom actuator endpoint public void register() { Registration registration = constructRegistration(); this.registry.register(registration); } } Each ServiceRegistry implementation has its own Registry implementation. ZookeeperRegistration used with ZookeeperServiceRegistry EurekaRegistration used with EurekaServiceRegistry ConsulRegistration used with ConsulServiceRegistry If you are using the ServiceRegistry interface, you are going to need to pass the correct Registry implementation for the ServiceRegistry implementation you are using. ServiceRegistry Auto-Registration: By default, the ServiceRegistry implementation auto-registers the running service. To disable that behavior, you can set: * @EnableDiscoveryClient(autoRegister=false) to permanently disable auto-registration. * spring.cloud.service-registry.auto-registration.enabled=false to disable the behavior through configuration. ServiceRegistry Auto-Registration Events: There are two events that will be fired when a service auto-registers. The first event, called InstancePreRegisteredEvent , is fired before the service is registered. The second event, called InstanceRegisteredEvent , is fired after the service is registered. You can register an ApplicationListener (s) to listen to and react to these events. These events will not be fired if the spring.cloud.service-registry.auto-registration.enabled property is set to false . Service Registry Actuator Endpoint: Spring Cloud Commons provides a /serviceregistry actuator endpoint. This endpoint relies on a Registration bean in the Spring Application Context. Calling /serviceregistry with GET returns the status of the Registration . Using POST to the same endpoint with a JSON body changes the status of the current Registration to the new value. The JSON body has to include the status field with the preferred value. Please see the documentation of the ServiceRegistry implementation you use for the allowed values when updating the status and the values returned for the status. For instance, Eureka’s supported statuses are UP , DOWN , OUT_OF_SERVICE , and UNKNOWN . Spring RestTemplate as a LoadBalancer Client: You can configure a RestTemplate to use a Load-balancer client. To create a load-balanced RestTemplate , create a RestTemplate @Bean and use the @LoadBalanced qualifier, as the following example shows: @Configuration public class MyConfiguration { @LoadBalanced @Bean RestTemplate restTemplate() { return new RestTemplate(); } } public class MyClass { @Autowired private RestTemplate restTemplate; public String doOtherStuff() { String result = restTemplate.getForObject(""http://stores/stores"", String.class); return result; } } A RestTemplate bean is no longer created through auto-configuration. Individual applications must create it. The URI needs to use a virtual host name (that is, a service name, not a host name). The BlockingLoadBalancerClient is used to create a full physical address. To use a load-balanced RestTemplate , you need to have a Spring Cloud LoadBalancer implementation in your classpath. Add Spring Cloud LoadBalancer starter(loadbalancer.html#spring-cloud-loadbalancer-starter) to your project in order to use it. Multiple RestTemplate Objects: If you want a RestTemplate that is not load-balanced, create a RestTemplate bean and inject it. To access the load-balanced RestTemplate , use the @LoadBalanced qualifier when you create your @Bean , as the following example shows: @Configuration public class MyConfiguration { @LoadBalanced @Bean RestTemplate loadBalanced() { return new RestTemplate(); } @Primary @Bean RestTemplate restTemplate() { return new RestTemplate(); } } public class MyClass { @Autowired private RestTemplate restTemplate; @Autowired @LoadBalanced private RestTemplate loadBalanced; public String doOtherStuff() { return loadBalanced.getForObject(""http://stores/stores"", String.class); } public String doStuff() { return restTemplate.getForObject(""http://example.com"", String.class); } } Notice the use of the @Primary annotation on the plain RestTemplate declaration in the preceding example to disambiguate the unqualified @Autowired injection. If you see errors such as java.lang.IllegalArgumentException: Can not set org.springframework.web.client.RestTemplate field com.my.app.Foo.restTemplate to com.sun.proxy.$Proxy89 , try injecting RestOperations or setting spring.aop.proxyTargetClass=true . Spring RestClient as a LoadBalancer Client: You can configure a RestClient to use a Load-balancer client. To create a load-balanced RestClient , create a RestClient.Builder @Bean and use the @LoadBalanced qualifier, as the following example shows: @Configuration public class MyConfiguration { @LoadBalanced @Bean RestClient.Builder restClientBuilder() { return RestClient.builder(); } } public class MyClass { @Autowired private RestClient.Builder restClientBuilder; public String doOtherStuff() { return restClientBuilder.build().get().uri(URI.create(""http://stores/stores"")).retrieve().body(String.class); } } The URI needs to use a virtual host name (that is, a service name, not a host name). The BlockingLoadBalancerClient is used to create a full physical address. To use it, add Spring Cloud LoadBalancer starter(loadbalancer.html#spring-cloud-loadbalancer-starter) to your project. Multiple RestClient.Builder Objects: If you want a RestClient.Builder that is not load-balanced, create a RestClient.Builder bean and inject it. To access the load-balanced RestClient , use the @LoadBalanced qualifier when you create your @Bean , as the following example shows: @Configuration public class MyConfiguration { @LoadBalanced @Bean RestClient.Builder loadBalanced() { return RestClient.builder(); } @Primary @Bean RestClient.Builder restClientBuilder() { return RestClient.builder(); } } public class MyClass { @Autowired private RestClient.Builder restClientBuilder; @Autowired @LoadBalanced private RestClient.Builder loadBalanced; public String doOtherStuff() { return loadBalanced.build().get().uri(""http://stores/stores"") .retrieve().body(String.class); } public String doStuff() { return restClientBuilder.build().get().uri(""http://example.com"") .retrieve().body(String.class); } } Notice the use of the @Primary annotation on the plain RestTemplate declaration in the preceding example to disambiguate the unqualified @Autowired injection. Spring WebClient as a LoadBalancer Client: You can configure WebClient to automatically use a load-balancer client. To create a load-balanced WebClient , create a WebClient.Builder @Bean and use the @LoadBalanced qualifier, as follows: @Configuration public class MyConfiguration { @Bean @LoadBalanced public WebClient.Builder loadBalancedWebClientBuilder() { return WebClient.builder(); } } public class MyClass { @Autowired private WebClient.Builder webClientBuilder; public Mono<String> doOtherStuff() { return webClientBuilder.build().get().uri(""http://stores/stores"") .retrieve().bodyToMono(String.class); } } The URI needs to use a virtual host name (that is, a service name, not a host name). The Spring Cloud LoadBalancer is used to create a full physical address. If you want to use a @LoadBalanced WebClient.Builder , you need to have a Spring Cloud LoadBalancer implementation in the classpath. We recommend that you add the Spring Cloud LoadBalancer starter(loadbalancer.html#spring-cloud-loadbalancer-starter) to your project. Then, ReactiveLoadBalancer is used underneath. Multiple WebClient.Builder Objects: If you want a WebClient.Buider that is not load-balanced, create a WebClient bean and inject it. To access the load-balanced WebClient.Builder , use the @LoadBalanced qualifier when you create your @Bean , as the following example shows: @Configuration public class MyConfiguration { @LoadBalanced @Bean WebClient.Builder loadBalanced() { return WebClient.builder(); } @Primary @Bean WebClient.Builder webClientBuilder() { return WebClient.builder(); } } public class MyClass { @Autowired private WebClient.Builder webClientBuilder; @Autowired @LoadBalanced private WebClient.Builder loadBalanced; public Mono<String> doOtherStuff() { return loadBalanced.build().get().uri(""http://stores/stores"") .retrieve().bodyToMono(String.class); } public Mono<String> doStuff() { return webClientBuilder.build().get().uri(""http://example.com"") .retrieve().bodyToMono(String.class); } } Retrying Failed Requests: A load-balanced RestTemplate can be configured to retry failed requests. By default, this logic is disabled. For the non-reactive version (with RestTemplate ), you can enable it by adding Spring Retry(https://github.com/spring-projects/spring-retry) to your application’s classpath. For the reactive version (with WebTestClient ), you need to set spring.cloud.loadbalancer.retry.enabled=true . If you would like to disable the retry logic with Spring Retry or Reactive Retry on the classpath, you can set spring.cloud.loadbalancer.retry.enabled=false . For the non-reactive implementation, if you would like to implement a BackOffPolicy in your retries, you need to create a bean of type LoadBalancedRetryFactory and override the createBackOffPolicy() method. For the reactive implementation, you just need to enable it by setting spring.cloud.loadbalancer.retry.backoff.enabled to false . You can set: spring.cloud.loadbalancer.retry.maxRetriesOnSameServiceInstance - indicates how many times a request should be retried on the same ServiceInstance (counted separately for every selected instance) spring.cloud.loadbalancer.retry.maxRetriesOnNextServiceInstance - indicates how many times a request should be retried a newly selected ServiceInstance spring.cloud.loadbalancer.retry.retryableStatusCodes - the status codes on which to always retry a failed request. For the reactive implementation, you can additionally set: - spring.cloud.loadbalancer.retry.backoff.minBackoff - Sets the minimum backoff duration (by default, 5 milliseconds) - spring.cloud.loadbalancer.retry.backoff.maxBackoff - Sets the maximum backoff duration (by default, max long value of milliseconds) - spring.cloud.loadbalancer.retry.backoff.jitter - Sets the jitter used for calculating the actual backoff duration for each call (by default, 0.5). For the reactive implementation, you can also implement your own LoadBalancerRetryPolicy to have more detailed control over the load-balanced call retries. For both implementations, you can also set the exceptions that trigger the replies by adding a list of values under the spring.cloud.loadbalancer.[serviceId].retry.retryable-exceptions property. If you do, we make sure to add RetryableStatusCodeExceptions to the list of exceptions provided by you, so that we also retry on retryable status codes. If you do not specify any exceptions via properties, the exceptions we use by default are IOException , TimeoutException and RetryableStatusCodeException . You can also enable retrying on all exceptions by setting spring.cloud.loadbalancer.[serviceId].retry.retry-on-all-exceptions to true . If you use the blocking implementation with Spring Retries, if you want to keep the behaviour from previous releases, set spring.cloud.loadbalancer.[serviceId].retry.retry-on-all-exceptions to true as that used to be the default mode for the blocking implementation. Individual Loadbalancer clients may be configured individually with the same properties as above except the prefix is spring.cloud.loadbalancer.clients.<clientId>.* where clientId is the name of the loadbalancer. For load-balanced retries, by default, we wrap the ServiceInstanceListSupplier bean with RetryAwareServiceInstanceListSupplier to select a different instance from the one previously chosen, if available. You can disable this behavior by setting the value of spring.cloud.loadbalancer.retry.avoidPreviousInstance to false . @Configuration public class MyConfiguration { @Bean LoadBalancedRetryFactory retryFactory() { return new LoadBalancedRetryFactory() { @Override public BackOffPolicy createBackOffPolicy(String service) { return new ExponentialBackOffPolicy(); } }; } } If you want to add one or more RetryListener implementations to your retry functionality, you need to create a bean of type LoadBalancedRetryListenerFactory and return the RetryListener array you would like to use for a given service, as the following example shows: @Configuration public class MyConfiguration { @Bean LoadBalancedRetryListenerFactory retryListenerFactory() { return new LoadBalancedRetryListenerFactory() { @Override public RetryListener[] createRetryListeners(String service) { return new RetryListener[]{new RetryListener() { @Override public <T, E extends Throwable> boolean open(RetryContext context, RetryCallback<T, E> callback) { //TODO Do you business... return true; } @Override public <T, E extends Throwable> void close(RetryContext context, RetryCallback<T, E> callback, Throwable throwable) { //TODO Do you business... } @Override public <T, E extends Throwable> void onError(RetryContext context, RetryCallback<T, E> callback, Throwable throwable) { //TODO Do you business... } }}; } }; } } Spring WebFlux WebClient as a Load Balancer Client: The Spring WebFlux can work with both reactive and non-reactive WebClient configurations, as the topics describe: Spring WebFlux WebClient with ReactorLoadBalancerExchangeFilterFunction(#webflux-with-reactive-loadbalancer) Spring WebFlux WebClient with a Non-reactive Load Balancer Client(#load-balancer-exchange-filter-function) Spring WebFlux WebClient with ReactorLoadBalancerExchangeFilterFunction: You can configure WebClient to use the ReactiveLoadBalancer . If you add Spring Cloud LoadBalancer starter(loadbalancer.html#spring-cloud-loadbalancer-starter) to your project and if spring-webflux is on the classpath, ReactorLoadBalancerExchangeFilterFunction is auto-configured. The following example shows how to configure a WebClient to use reactive load-balancer: public class MyClass { @Autowired private ReactorLoadBalancerExchangeFilterFunction lbFunction; public Mono<String> doOtherStuff() { return WebClient.builder().baseUrl(""http://stores"") .filter(lbFunction) .build() .get() .uri(""/stores"") .retrieve() .bodyToMono(String.class); } } The URI needs to use a virtual host name (that is, a service name, not a host name). The ReactorLoadBalancer is used to create a full physical address. Spring WebFlux WebClient with a Non-reactive Load Balancer Client: If spring-webflux is on the classpath, LoadBalancerExchangeFilterFunction is auto-configured. Note, however, that this uses a non-reactive client under the hood. The following example shows how to configure a WebClient to use load-balancer: public class MyClass { @Autowired private LoadBalancerExchangeFilterFunction lbFunction; public Mono<String> doOtherStuff() { return WebClient.builder().baseUrl(""http://stores"") .filter(lbFunction) .build() .get() .uri(""/stores"") .retrieve() .bodyToMono(String.class); } } The URI needs to use a virtual host name (that is, a service name, not a host name). The LoadBalancerClient is used to create a full physical address. WARN: This approach is now deprecated. We suggest that you use WebFlux with reactive Load-Balancer(#webflux-with-reactive-loadbalancer) instead. Ignore Network Interfaces: Sometimes, it is useful to ignore certain named network interfaces so that they can be excluded from Service Discovery registration (for example, when running in a Docker container). A list of regular expressions can be set to cause the desired network interfaces to be ignored. The following configuration ignores the docker0 interface and all interfaces that start with veth : application.yml spring: cloud: inetutils: ignoredInterfaces: - docker0 - veth.* You can also force the use of only specified network addresses by using a list of regular expressions, as the following example shows: bootstrap.yml spring: cloud: inetutils: preferredNetworks: - 192.168 - 10.0 You can also force the use of only site-local addresses, as the following example shows: application.yml spring: cloud: inetutils: useOnlySiteLocalInterfaces: true See Inet4Address.html.isSiteLocalAddress()(https://docs.oracle.com/javase/8/docs/api/java/net/Inet4Address.html#isSiteLocalAddress--) for more details about what constitutes a site-local address. HTTP Client Factories: Spring Cloud Commons provides beans for creating both Apache HTTP clients ( ApacheHttpClientFactory ) and OK HTTP clients ( OkHttpClientFactory ). The OkHttpClientFactory bean is created only if the OK HTTP jar is on the classpath. In addition, Spring Cloud Commons provides beans for creating the connection managers used by both clients: ApacheHttpClientConnectionManagerFactory for the Apache HTTP client and OkHttpClientConnectionPoolFactory for the OK HTTP client. If you would like to customize how the HTTP clients are created in downstream projects, you can provide your own implementation of these beans. In addition, if you provide a bean of type HttpClientBuilder or OkHttpClient.Builder , the default factories use these builders as the basis for the builders returned to downstream projects. You can also disable the creation of these beans by setting spring.cloud.httpclientfactories.apache.enabled or spring.cloud.httpclientfactories.ok.enabled to false . Enabled Features: Spring Cloud Commons provides a /features actuator endpoint. This endpoint returns features available on the classpath and whether they are enabled. The information returned includes the feature type, name, version, and vendor. Feature types: There are two types of 'features': abstract and named. Abstract features are features where an interface or abstract class is defined and that an implementation the creates, such as DiscoveryClient , LoadBalancerClient , or LockService . The abstract class or interface is used to find a bean of that type in the context. The version displayed is bean.getClass().getPackage().getImplementationVersion() . Named features are features that do not have a particular class they implement. These features include “Circuit Breaker”, “API Gateway”, “Spring Cloud Bus”, and others. These features require a name and a bean type. Declaring features: Any module can declare any number of HasFeature beans, as the following examples show: @Bean public HasFeatures commonsFeatures() { return HasFeatures.abstractFeatures(DiscoveryClient.class, LoadBalancerClient.class); } @Bean public HasFeatures consulFeatures() { return HasFeatures.namedFeatures( new NamedFeature(""Spring Cloud Bus"", ConsulBusAutoConfiguration.class), new NamedFeature(""Circuit Breaker"", HystrixCommandAspect.class)); } @Bean HasFeatures localFeatures() { return HasFeatures.builder() .abstractFeature(Something.class) .namedFeature(new NamedFeature(""Some Other Feature"", Someother.class)) .abstractFeature(Somethingelse.class) .build(); } Each of these beans should go in an appropriately guarded @Configuration . Spring Cloud Compatibility Verification: Due to the fact that some users have problem with setting up Spring Cloud application, we’ve decided to add a compatibility verification mechanism. It will break if your current setup is not compatible with Spring Cloud requirements, together with a report, showing what exactly went wrong. At the moment we verify which version of Spring Boot is added to your classpath. Example of a report *************************** APPLICATION FAILED TO START *************************** Description: Your project setup is incompatible with our requirements due to following reasons: - Spring Boot [2.1.0.RELEASE] is not compatible with this Spring Cloud release train Action: Consider applying the following actions: - Change Spring Boot version to one of the following versions [1.2.x, 1.3.x] . You can find the latest Spring Boot versions here [https://spring.io/projects/spring-boot#learn]. If you want to learn more about the Spring Cloud Release train compatibility, you can visit this page [https://spring.io/projects/spring-cloud#overview] and check the [Release Trains] section. In order to disable this feature, set spring.cloud.compatibility-verifier.enabled to false . If you want to override the compatible Spring Boot versions, just set the spring.cloud.compatibility-verifier.compatible-boot-versions property with a comma separated list of compatible Spring Boot versions."
"https://docs.spring.io/spring-cloud-commons/reference/spring-cloud-commons/loadbalancer.html","Spring Cloud LoadBalancer: Spring Cloud provides its own client-side load-balancer abstraction and implementation. For the load-balancing mechanism, ReactiveLoadBalancer interface has been added and a Round-Robin-based and Random implementations have been provided for it. In order to get instances to select from reactive ServiceInstanceListSupplier is used. Currently we support a service-discovery-based implementation of ServiceInstanceListSupplier that retrieves available instances from Service Discovery using a Discovery Client(common-abstractions.html#discovery-client) available in the classpath. It is possible to disable Spring Cloud LoadBalancer by setting the value of spring.cloud.loadbalancer.enabled to false . Eager loading of LoadBalancer contexts: Spring Cloud LoadBalancer creates a separate Spring child context for each service id. By default, these contexts are initialised lazily, whenever the first request for a service id is being load-balanced. You can choose to load those contexts eagerly. In order to do that, specify the service ids for which you want to do eager load using the spring.cloud.loadbalancer.eager-load.clients property, for example: spring.cloud-loadbalancer.eager-load.clients[0]=my-first-client spring.cloud-loadbalancer.eager-load.clients[1]=my-second-client Switching between the load-balancing algorithms: The ReactiveLoadBalancer implementation that is used by default is RoundRobinLoadBalancer . To switch to a different implementation, either for selected services or all of them, you can use the custom LoadBalancer configurations mechanism(#custom-loadbalancer-configuration) . For example, the following configuration can be passed via @LoadBalancerClient annotation to switch to using the RandomLoadBalancer : public class CustomLoadBalancerConfiguration { @Bean ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory) { String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); return new RandomLoadBalancer(loadBalancerClientFactory .getLazyProvider(name, ServiceInstanceListSupplier.class), name); } } The classes you pass as @LoadBalancerClient or @LoadBalancerClients configuration arguments should either not be annotated with @Configuration or be outside component scan scope. Spring Cloud LoadBalancer integrations: To make it easy to use Spring Cloud LoadBalancer, we provide ReactorLoadBalancerExchangeFilterFunction (which can be used with WebClient ) and BlockingLoadBalancerClient (which works with RestTemplate and RestClient ). You can see more information and examples of usage in the following sections: Spring RestTemplate as a LoadBalancer Client(common-abstractions.html#rest-template-loadbalancer-client) Spring RestClient as a LoadBalancer Client(common-abstractions.html#rest-client-loadbalancer-client) Spring WebClient as a LoadBalancer Client(common-abstractions.html#webclinet-loadbalancer-client) Spring WebFlux WebClient with ReactorLoadBalancerExchangeFilterFunction(common-abstractions.html#webflux-with-reactive-loadbalancer) Spring Cloud LoadBalancer Caching: Apart from the basic ServiceInstanceListSupplier implementation that retrieves instances via DiscoveryClient each time it has to choose an instance, we provide two caching implementations. Caffeine-backed LoadBalancer Cache Implementation: If you have com.github.ben-manes.caffeine:caffeine in the classpath, Caffeine-based implementation will be used. See the LoadBalancerCacheConfiguration(#loadbalancer-cache-configuration) section for information on how to configure it. If you are using Caffeine, you can also override the default Caffeine Cache setup for the LoadBalancer by passing your own Caffeine Specification(https://static.javadoc.io/com.github.ben-manes.caffeine/caffeine/2.2.2/com/github/benmanes/caffeine/cache/CaffeineSpec.html) in the spring.cloud.loadbalancer.cache.caffeine.spec property. WARN: Passing your own Caffeine specification will override any other LoadBalancerCache settings, including General LoadBalancer Cache Configuration(#loadbalancer-cache-configuration) fields, such as ttl and capacity . Default LoadBalancer Cache Implementation: If you do not have Caffeine in the classpath, the DefaultLoadBalancerCache , which comes automatically with spring-cloud-starter-loadbalancer , will be used. See the LoadBalancerCacheConfiguration(#loadbalancer-cache-configuration) section for information on how to configure it. To use Caffeine instead of the default cache, add the com.github.ben-manes.caffeine:caffeine dependency to classpath. LoadBalancer Cache Configuration: You can set your own ttl value (the time after write after which entries should be expired), expressed as Duration , by passing a String compliant with the Spring Boot String to Duration converter syntax(https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config-conversion-duration) . as the value of the spring.cloud.loadbalancer.cache.ttl property. You can also set your own LoadBalancer cache initial capacity by setting the value of the spring.cloud.loadbalancer.cache.capacity property. The default setup includes ttl set to 35 seconds and the default initialCapacity is 256 . You can also altogether disable loadBalancer caching by setting the value of spring.cloud.loadbalancer.cache.enabled to false . Although the basic, non-cached, implementation is useful for prototyping and testing, it’s much less efficient than the cached versions, so we recommend always using the cached version in production. If the caching is already done by the DiscoveryClient implementation, for example EurekaDiscoveryClient , the load-balancer caching should be disabled to prevent double caching. When you create your own configuration, if you use CachingServiceInstanceListSupplier make sure to place it in the hierarchy directly after the supplier that retrieves the instances over the network, for example, DiscoveryClientServiceInstanceListSupplier , before any other filtering suppliers. Weighted Load-Balancing: To enable weighted load-balancing, we provide the WeightedServiceInstanceListSupplier . We use WeightFunction to calculate the weight of each instance. By default, we try to read and parse the weight from the metadata map (the key is weight ). If the weight is not specified in the metadata map, we default the weight of this instance to be 1. You can configure it either by setting the value of spring.cloud.loadbalancer.configurations to weighted or by providing your own ServiceInstanceListSupplier bean, for example: public class CustomLoadBalancerConfiguration { @Bean public ServiceInstanceListSupplier discoveryClientServiceInstanceListSupplier( ConfigurableApplicationContext context) { return ServiceInstanceListSupplier.builder() .withDiscoveryClient() .withWeighted() .withCaching() .build(context); } } You can also customize the weight calculation logic by providing WeightFunction . You can use this sample configuration to make all instances have a random weight: public class CustomLoadBalancerConfiguration { @Bean public ServiceInstanceListSupplier discoveryClientServiceInstanceListSupplier( ConfigurableApplicationContext context) { return ServiceInstanceListSupplier.builder() .withDiscoveryClient() .withWeighted(instance -> ThreadLocalRandom.current().nextInt(1, 101)) .withCaching() .build(context); } } Zone-Based Load-Balancing: To enable zone-based load-balancing, we provide the ZonePreferenceServiceInstanceListSupplier . We use DiscoveryClient -specific zone configuration (for example, eureka.instance.metadata-map.zone ) to pick the zone that the client tries to filter available service instances for. You can also override DiscoveryClient -specific zone setup by setting the value of spring.cloud.loadbalancer.zone property. For the time being, only Eureka Discovery Client is instrumented to set the LoadBalancer zone. For other discovery client, set the spring.cloud.loadbalancer.zone property. More instrumentations coming shortly. To determine the zone of a retrieved ServiceInstance , we check the value under the ""zone"" key in its metadata map. The ZonePreferenceServiceInstanceListSupplier filters retrieved instances and only returns the ones within the same zone. If the zone is null or there are no instances within the same zone, it returns all the retrieved instances. In order to use the zone-based load-balancing approach, you will have to instantiate a ZonePreferenceServiceInstanceListSupplier bean in a custom configuration(#custom-loadbalancer-configuration) . We use delegates to work with ServiceInstanceListSupplier beans. We suggest using a DiscoveryClientServiceInstanceListSupplier delegate, wrapping it with a CachingServiceInstanceListSupplier to leverage LoadBalancer caching mechanism(#loadbalancer-caching) , and then passing the resulting bean in the constructor of ZonePreferenceServiceInstanceListSupplier . You can use this sample configuration to set it up: public class CustomLoadBalancerConfiguration { @Bean public ServiceInstanceListSupplier discoveryClientServiceInstanceListSupplier( ConfigurableApplicationContext context) { return ServiceInstanceListSupplier.builder() .withDiscoveryClient() .withCaching() .withZonePreference() .build(context); } } Instance Health-Check for LoadBalancer: It is possible to enable a scheduled HealthCheck for the LoadBalancer. The HealthCheckServiceInstanceListSupplier is provided for that. It regularly verifies if the instances provided by a delegate ServiceInstanceListSupplier are still alive and only returns the healthy instances, unless there are none - then it returns all the retrieved instances. This mechanism is particularly helpful while using the SimpleDiscoveryClient . For the clients backed by an actual Service Registry, it’s not necessary to use, as we already get healthy instances after querying the external ServiceDiscovery. This supplier is also recommended for setups with a small number of instances per service in order to avoid retrying calls on a failing instance. If using any of the Service Discovery-backed suppliers, adding this health-check mechanism is usually not necessary, as we retrieve the health state of the instances directly from the Service Registry. The HealthCheckServiceInstanceListSupplier relies on having updated instances provided by a delegate flux. In the rare cases when you want to use a delegate that does not refresh the instances, even though the list of instances may change (such as the DiscoveryClientServiceInstanceListSupplier provided by us), you can set spring.cloud.loadbalancer.health-check.refetch-instances to true to have the instance list refreshed by the HealthCheckServiceInstanceListSupplier . You can then also adjust the refretch intervals by modifying the value of spring.cloud.loadbalancer.health-check.refetch-instances-interval and opt to disable the additional healthcheck repetitions by setting spring.cloud.loadbalancer.health-check.repeat-health-check to false as every instances refetch will also trigger a healthcheck. HealthCheckServiceInstanceListSupplier uses properties prefixed with spring.cloud.loadbalancer.health-check . You can set the initialDelay and interval for the scheduler. You can set the default path for the healthcheck URL by setting the value of the spring.cloud.loadbalancer.health-check.path.default property. You can also set a specific value for any given service by setting the value of the spring.cloud.loadbalancer.health-check.path.[SERVICE_ID] property, substituting [SERVICE_ID] with the correct ID of your service. If the [SERVICE_ID] is not specified, /actuator/health is used by default. If the [SERVICE_ID] is set to null or empty as a value, then the health check will not be executed. You can also set a custom port for health-check requests by setting the value of spring.cloud.loadbalancer.health-check.port . If none is set, the port under which the requested service is available at the service instance. If you rely on the default path ( /actuator/health ), make sure you add spring-boot-starter-actuator to your collaborator’s dependencies, unless you are planning to add such an endpoint on your own. By default, the healthCheckFlux will emit on each alive ServiceInstance that has been retrieved. You can modify this behaviour by setting the value of spring.cloud.loadbalancer.health-check.update-results-list to false . If this property is set to false , the entire alive instances sequence is first collected into a list and only then emitted, which ensures the flux does not emit values in between the health-check intervals set in properties. In order to use the health-check scheduler approach, you will have to instantiate a HealthCheckServiceInstanceListSupplier bean in a custom configuration(#custom-loadbalancer-configuration) . We use delegates to work with ServiceInstanceListSupplier beans. We suggest passing a DiscoveryClientServiceInstanceListSupplier delegate in the constructor of HealthCheckServiceInstanceListSupplier . You can use this sample configuration to set it up: public class CustomLoadBalancerConfiguration { @Bean public ServiceInstanceListSupplier discoveryClientServiceInstanceListSupplier( ConfigurableApplicationContext context) { return ServiceInstanceListSupplier.builder() .withDiscoveryClient() .withHealthChecks() .build(context); } } For the non-reactive stack, create this supplier with the withBlockingHealthChecks() . You can also pass your own WebClient , RestTemplate or RestClient instance to be used for the checks. HealthCheckServiceInstanceListSupplier has its own caching mechanism based on Reactor Flux replay() . Therefore, if it’s being used, you may want to skip wrapping that supplier with CachingServiceInstanceListSupplier . When you create your own configuration, HealthCheckServiceInstanceListSupplier , make sure to place it in the hierarchy directly after the supplier that retrieves the instances over the network, for example, DiscoveryClientServiceInstanceListSupplier , before any other filtering suppliers. Same instance preference for LoadBalancer: You can set up the LoadBalancer in such a way that it prefers the instance that was previously selected, if that instance is available. For that, you need to use SameInstancePreferenceServiceInstanceListSupplier . You can configure it either by setting the value of spring.cloud.loadbalancer.configurations to same-instance-preference or by providing your own ServiceInstanceListSupplier bean — for example: public class CustomLoadBalancerConfiguration { @Bean public ServiceInstanceListSupplier discoveryClientServiceInstanceListSupplier( ConfigurableApplicationContext context) { return ServiceInstanceListSupplier.builder() .withDiscoveryClient() .withSameInstancePreference() .build(context); } } This is also a replacement for Zookeeper StickyRule . Request-based Sticky Session for LoadBalancer: You can set up the LoadBalancer in such a way that it prefers the instance with instanceId provided in a request cookie. We currently support this if the request is being passed to the LoadBalancer through either ClientRequestContext or ServerHttpRequestContext , which are used by the SC LoadBalancer exchange filter functions and filters. For that, you need to use the RequestBasedStickySessionServiceInstanceListSupplier . You can configure it either by setting the value of spring.cloud.loadbalancer.configurations to request-based-sticky-session or by providing your own ServiceInstanceListSupplier bean — for example: public class CustomLoadBalancerConfiguration { @Bean public ServiceInstanceListSupplier discoveryClientServiceInstanceListSupplier( ConfigurableApplicationContext context) { return ServiceInstanceListSupplier.builder() .withDiscoveryClient() .withRequestBasedStickySession() .build(context); } } For that functionality, it is useful to have the selected service instance (which can be different from the one in the original request cookie if that one is not available) to be updated before sending the request forward. To do that, set the value of spring.cloud.loadbalancer.sticky-session.add-service-instance-cookie to true . By default, the name of the cookie is sc-lb-instance-id . You can modify it by changing the value of the spring.cloud.loadbalancer.instance-id-cookie-name property. This feature is currently supported for WebClient-backed load-balancing. Spring Cloud LoadBalancer Hints: Spring Cloud LoadBalancer lets you set String hints that are passed to the LoadBalancer within the Request object and that can later be used in ReactiveLoadBalancer implementations that can handle them. You can set a default hint for all services by setting the value of the spring.cloud.loadbalancer.hint.default property. You can also set a specific value for any given service by setting the value of the spring.cloud.loadbalancer.hint.[SERVICE_ID] property, substituting [SERVICE_ID] with the correct ID of your service. If the hint is not set by the user, default is used. Hint-Based Load-Balancing: We also provide a HintBasedServiceInstanceListSupplier , which is a ServiceInstanceListSupplier implementation for hint-based instance selection. HintBasedServiceInstanceListSupplier checks for a hint request header (the default header-name is X-SC-LB-Hint , but you can modify it by changing the value of the spring.cloud.loadbalancer.hint-header-name property) and, if it finds a hint request header, uses the hint value passed in the header to filter service instances. If no hint header has been added, HintBasedServiceInstanceListSupplier uses hint values from properties(#spring-cloud-loadbalancer-hints) to filter service instances. If no hint is set, either by the header or by properties, all service instances provided by the delegate are returned. While filtering, HintBasedServiceInstanceListSupplier looks for service instances that have a matching value set under the hint key in their metadataMap . If no matching instances are found, all instances provided by the delegate are returned. You can use the following sample configuration to set it up: public class CustomLoadBalancerConfiguration { @Bean public ServiceInstanceListSupplier discoveryClientServiceInstanceListSupplier( ConfigurableApplicationContext context) { return ServiceInstanceListSupplier.builder() .withDiscoveryClient() .withCaching() .withHints() .build(context); } } Transform the load-balanced HTTP request: You can use the selected ServiceInstance to transform the load-balanced HTTP Request. For RestTemplate and RestClient , you need to implement and define LoadBalancerRequestTransformer as follows: @Bean public LoadBalancerRequestTransformer transformer() { return new LoadBalancerRequestTransformer() { @Override public HttpRequest transformRequest(HttpRequest request, ServiceInstance instance) { return new HttpRequestWrapper(request) { @Override public HttpHeaders getHeaders() { HttpHeaders headers = new HttpHeaders(); headers.putAll(super.getHeaders()); headers.add(""X-InstanceId"", instance.getInstanceId()); return headers; } }; } }; } For WebClient , you need to implement and define LoadBalancerClientRequestTransformer as follows: @Bean public LoadBalancerClientRequestTransformer transformer() { return new LoadBalancerClientRequestTransformer() { @Override public ClientRequest transformRequest(ClientRequest request, ServiceInstance instance) { return ClientRequest.from(request) .header(""X-InstanceId"", instance.getInstanceId()) .build(); } }; } If multiple transformers are defined, they are applied in the order in which Beans are defined. Alternatively, you can use LoadBalancerRequestTransformer.DEFAULT_ORDER or LoadBalancerClientRequestTransformer.DEFAULT_ORDER to specify the order. Spring Cloud LoadBalancer Subset: SubsetServiceInstanceListSupplier implements a deterministic subsetting algorithm(https://sre.google/sre-book/load-balancing-datacenter/) to select a limited number of instances in the ServiceInstanceListSupplier delegates hierarchy. You can configure it either by setting the value of spring.cloud.loadbalancer.configurations to subset or by providing your own ServiceInstanceListSupplier bean — for example: public class CustomLoadBalancerConfiguration { @Bean public ServiceInstanceListSupplier discoveryClientServiceInstanceListSupplier( ConfigurableApplicationContext context) { return ServiceInstanceListSupplier.builder() .withDiscoveryClient() .withSubset() .withCaching() .build(context); } } By default, each service instance is assigned a unique instanceId , and different instanceId values often select different subsets. Normally, you need not pay attention to it. However, if you need to have multiple instances select the same subset, you can set it with spring.cloud.loadbalancer.subset.instance-id (which supports placeholders). By default, the size of the subset is set to 100. You can also set it with spring.cloud.loadbalancer.subset.size . Spring Cloud LoadBalancer Starter: We also provide a starter that allows you to easily add Spring Cloud LoadBalancer in a Spring Boot app. In order to use it, just add org.springframework.cloud:spring-cloud-starter-loadbalancer to your Spring Cloud dependencies in your build file. Spring Cloud LoadBalancer starter includes Spring Boot Caching(https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-caching.html) and Evictor(https://github.com/stoyanr/Evictor) . Passing Your Own Spring Cloud LoadBalancer Configuration: You can also use the @LoadBalancerClient annotation to pass your own load-balancer client configuration, passing the name of the load-balancer client and the configuration class, as follows: @Configuration @LoadBalancerClient(value = ""stores"", configuration = CustomLoadBalancerConfiguration.class) public class MyConfiguration { @Bean @LoadBalanced public WebClient.Builder loadBalancedWebClientBuilder() { return WebClient.builder(); } } In order to make working on your own LoadBalancer configuration easier, we have added a builder() method to the ServiceInstanceListSupplier class. You can also use our alternative predefined configurations in place of the default ones by setting the value of spring.cloud.loadbalancer.configurations property to zone-preference to use ZonePreferenceServiceInstanceListSupplier with caching or to health-check to use HealthCheckServiceInstanceListSupplier with caching. You can use this feature to instantiate different implementations of ServiceInstanceListSupplier or ReactorLoadBalancer , either written by you, or provided by us as alternatives (for example ZonePreferenceServiceInstanceListSupplier ) to override the default setup. You can see an example of a custom configuration here(#zoned-based-custom-loadbalancer-configuration) . The annotation value arguments ( stores in the example above) specifies the service id of the service that we should send the requests to with the given custom configuration. You can also pass multiple configurations (for more than one load-balancer client) through the @LoadBalancerClients annotation, as the following example shows: @Configuration @LoadBalancerClients({@LoadBalancerClient(value = ""stores"", configuration = StoresLoadBalancerClientConfiguration.class), @LoadBalancerClient(value = ""customers"", configuration = CustomersLoadBalancerClientConfiguration.class)}) public class MyConfiguration { @Bean @LoadBalanced public WebClient.Builder loadBalancedWebClientBuilder() { return WebClient.builder(); } } The classes you pass as @LoadBalancerClient or @LoadBalancerClients configuration arguments should either not be annotated with @Configuration or be outside component scan scope. When you create your own configuration, if you use CachingServiceInstanceListSupplier or HealthCheckServiceInstanceListSupplier , makes sure to use one of them, not both, and make sure to place it in the hierarchy directly after the supplier that retrieves the instances over the network, for example, DiscoveryClientServiceInstanceListSupplier , before any other filtering suppliers. Spring Cloud LoadBalancer Lifecycle: One type of bean that it may be useful to register using Custom LoadBalancer configuration(#custom-loadbalancer-configuration) is LoadBalancerLifecycle . The LoadBalancerLifecycle beans provide callback methods, named onStart(Request<RC> request) , onStartRequest(Request<RC> request, Response<T> lbResponse) and onComplete(CompletionContext<RES, T, RC> completionContext) , that you should implement to specify what actions should take place before and after load-balancing. onStart(Request<RC> request) takes a Request object as a parameter. It contains data that is used to select an appropriate instance, including the downstream client request and hint(#spring-cloud-loadbalancer-hints) . onStartRequest also takes the Request object and, additionally, the Response<T> object as parameters. On the other hand, a CompletionContext object is provided to the onComplete(CompletionContext<RES, T, RC> completionContext) method. It contains the LoadBalancer Response , including the selected service instance, the Status of the request executed against that service instance and (if available) the response returned to the downstream client, and (if an exception has occurred) the corresponding Throwable . The supports(Class requestContextClass, Class responseClass, Class serverTypeClass) method can be used to determine whether the processor in question handles objects of provided types. If not overridden by the user, it returns true . In the preceding method calls, RC means RequestContext type, RES means client response type, and T means returned server type. Spring Cloud LoadBalancer Statistics: We provide a LoadBalancerLifecycle bean called MicrometerStatsLoadBalancerLifecycle , which uses Micrometer to provide statistics for load-balanced calls. In order to get this bean added to your application context, set the value of the spring.cloud.loadbalancer.stats.micrometer.enabled to true and have a MeterRegistry available (for example, by adding Spring Boot Actuator(https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html) to your project). MicrometerStatsLoadBalancerLifecycle registers the following meters in MeterRegistry : loadbalancer.requests.active : A gauge that allows you to monitor the number of currently active requests for any service instance (service instance data available via tags); loadbalancer.requests.success : A timer that measures the time of execution of any load-balanced requests that have ended in passing a response on to the underlying client; loadbalancer.requests.failed : A timer that measures the time of execution of any load-balanced requests that have ended with an exception; loadbalancer.requests.discard : A counter that measures the number of discarded load-balanced requests, i.e. requests where a service instance to run the request on has not been retrieved by the LoadBalancer. Additional information regarding the service instances, request data, and response data is added to metrics via tags whenever available. For some implementations, such as BlockingLoadBalancerClient , request and response data might not be available, as we establish generic types from arguments and might not be able to determine the types and read the data. The meters are registered in the registry when at least one record is added for a given meter. You can further configure the behavior of those metrics (for example, add publishing percentiles and histograms(https://micrometer.io/docs/concepts#_histograms_and_percentiles) ) by adding MeterFilters(https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-metrics-per-meter-properties) . Configuring Individual LoadBalancerClients: Individual Loadbalancer clients may be configured individually with a different prefix spring.cloud.loadbalancer.clients.<clientId>. where clientId is the name of the loadbalancer. Default configuration values may be set in the spring.cloud.loadbalancer. namespace and will be merged with the client specific values taking precedence application.yml spring: cloud: loadbalancer: health-check: initial-delay: 1s clients: myclient: health-check: interval: 30s The above example will result in a merged health-check @ConfigurationProperties object with initial-delay=1s and interval=30s . The per-client configuration properties work for most of the properties, apart from the following global ones: spring.cloud.loadbalancer.enabled - globally enables or disables load-balancing spring.cloud.loadbalancer.retry.enabled - globally enables or disables load-balanced retries. If you enable it globally, you can still disable retries for specific clients using the client -prefixed properties, but not the other way round spring.cloud.loadbalancer.cache.enabled - globally enables or disables LoadBalancer caching. If you enable it globally, you can still disable caching for specific clients by creating a custom configuration(#custom-loadbalancer-configuration) that does not include the CachingServiceInstanceListSupplier in the ServiceInstanceListSupplier delegates hierarchy, but not the other way round. spring.cloud.loadbalancer.stats.micrometer.enabled - globally enables or disables LoadBalancer Micrometer metrics For the properties where maps where already used, where you can specify a different value per-client without using the clients keyword (for example, hints , health-check.path ), we have kept that behaviour in order to keep the library backwards compatible. It will be modified in the next major release. Starting with 4.1.0 , we have introduced the callGetWithRequestOnDelegates flag in LoadBalancerProperties . If this flag is set to true , ServiceInstanceListSupplier#get(Request request) method will be implemented to call delegate.get(request) in classes assignable from DelegatingServiceInstanceListSupplier that don’t already implement that method, with the exclusion of CachingServiceInstanceListSupplier and HealthCheckServiceInstanceListSupplier , which should be placed in the instance supplier hierarchy directly after the supplier performing instance retrieval over the network, before any request-based filtering is done. It is set to true by default. [[-aot-and-native-image-support]] == AOT and Native Image Support Since 4.0.0 , Spring Cloud LoadBalancer supports Spring AOT transformations and native images. However, to use this feature, you need to explicitly define your LoadBalancerClient service IDs. You can do so by using the value or name attributes of the @LoadBalancerClient annotation or as values of the spring.cloud.loadbalancer.eager-load.clients property."
"https://docs.spring.io/spring-cloud-commons/reference/spring-cloud-commons/cachedrandompropertysource.html","CachedRandomPropertySource: Spring Cloud Context provides a PropertySource that caches random values based on a key. Outside of the caching functionality it works the same as Spring Boot’s RandomValuePropertySource(https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/env/RandomValuePropertySource.java) . This random value might be useful in the case where you want a random value that is consistent even after the Spring Application context restarts. The property value takes the form of cachedrandom.[yourkey].[type] where yourkey is the key in the cache. The type value can be any type supported by Spring Boot’s RandomValuePropertySource . myrandom=${cachedrandom.appname.value}"
"https://docs.spring.io/spring-cloud-commons/reference/spring-cloud-commons/security.html","Security: Single Sign On: All of the OAuth2 SSO and resource server features moved to Spring Boot in version 1.3. You can find documentation in the Spring Boot user guide(https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/) . Client Token Relay: If your app is a user facing OAuth2 client (i.e. has declared @EnableOAuth2Sso or @EnableOAuth2Client ) then it has an OAuth2ClientContext in request scope from Spring Boot. You can create your own OAuth2RestTemplate from this context and an autowired OAuth2ProtectedResourceDetails , and then the context will always forward the access token downstream, also refreshing the access token automatically if it expires. (These are features of Spring Security and Spring Boot.) Resource Server Token Relay: If your app has @EnableResourceServer you might want to relay the incoming token downstream to other services. If you use a RestTemplate to contact the downstream services then this is just a matter of how to create the template with the right context. If your service uses UserInfoTokenServices to authenticate incoming tokens (i.e. it is using the security.oauth2.user-info-uri configuration), then you can simply create an OAuth2RestTemplate using an autowired OAuth2ClientContext (it will be populated by the authentication process before it hits the backend code). Equivalently (with Spring Boot 1.4), you can inject a UserInfoRestTemplateFactory and grab its OAuth2RestTemplate in your configuration. For example: MyConfiguration.java @Bean public OAuth2RestTemplate restTemplate(UserInfoRestTemplateFactory factory) { return factory.getUserInfoRestTemplate(); } This rest template will then have the same OAuth2ClientContext (request-scoped) that is used by the authentication filter, so you can use it to send requests with the same access token. If your app is not using UserInfoTokenServices but is still a client (i.e. it declares @EnableOAuth2Client or @EnableOAuth2Sso ), then with Spring Security Cloud any OAuth2RestOperations that the user creates from an @Autowired OAuth2Context will also forward tokens. This feature is implemented by default as an MVC handler interceptor, so it only works in Spring MVC. If you are not using MVC you can use a custom filter or AOP interceptor wrapping an AccessTokenContextRelay to provide the same feature. Here’s a basic example showing the use of an autowired rest template created elsewhere (""foo.com"" is a Resource Server accepting the same tokens as the surrounding app): MyController.java @Autowired private OAuth2RestOperations restTemplate; @RequestMapping(""/relay"") public String relay() { ResponseEntity<String> response = restTemplate.getForEntity(""https://foo.com/bar"", String.class); return ""Success! ("" + response.getBody() + "")""; } If you don’t want to forward tokens (and that is a valid choice, since you might want to act as yourself, rather than the client that sent you the token), then you only need to create your own OAuth2Context instead of autowiring the default one. Feign clients will also pick up an interceptor that uses the OAuth2ClientContext if it is available, so they should also do a token relay anywhere where a RestTemplate would."
"https://docs.spring.io/spring-cloud-commons/reference/spring-cloud-circuitbreaker.html","Spring Cloud Circuit Breaker: Spring Cloud Circuit breaker provides an abstraction across different circuit breaker implementations. It provides a consistent API to use in your applications, letting you, the developer, choose the circuit breaker implementation that best fits your needs for your application. Supported Implementations: Spring Cloud supports the following circuit-breaker implementations: Resilience4J(https://github.com/resilience4j/resilience4j) Sentinel(https://github.com/alibaba/Sentinel) Spring Retry(https://github.com/spring-projects/spring-retry) Core Concepts: To create a circuit breaker in your code, you can use the CircuitBreakerFactory API. When you include a Spring Cloud Circuit Breaker starter on your classpath, a bean that implements this API is automatically created for you. The following example shows a simple example of how to use this API: @Service public static class DemoControllerService { private RestTemplate rest; private CircuitBreakerFactory cbFactory; public DemoControllerService(RestTemplate rest, CircuitBreakerFactory cbFactory) { this.rest = rest; this.cbFactory = cbFactory; } public String slow() { return cbFactory.create(""slow"").run(() -> rest.getForObject(""/slow"", String.class), throwable -> ""fallback""); } } The CircuitBreakerFactory.create API creates an instance of a class called CircuitBreaker . The run method takes a Supplier and a Function . The Supplier is the code that you are going to wrap in a circuit breaker. The Function is the fallback that is run if the circuit breaker is tripped. The function is passed the Throwable that caused the fallback to be triggered. You can optionally exclude the fallback if you do not want to provide one. Circuit Breakers In Reactive Code: If Project Reactor is on the class path, you can also use ReactiveCircuitBreakerFactory for your reactive code. The following example shows how to do so: @Service public static class DemoControllerService { private ReactiveCircuitBreakerFactory cbFactory; private WebClient webClient; public DemoControllerService(WebClient webClient, ReactiveCircuitBreakerFactory cbFactory) { this.webClient = webClient; this.cbFactory = cbFactory; } public Mono<String> slow() { return webClient.get().uri(""/slow"").retrieve().bodyToMono(String.class).transform( it -> cbFactory.create(""slow"").run(it, throwable -> return Mono.just(""fallback""))); } } The ReactiveCircuitBreakerFactory.create API creates an instance of a class called ReactiveCircuitBreaker . The run method takes a Mono or a Flux and wraps it in a circuit breaker. You can optionally profile a fallback Function , which will be called if the circuit breaker is tripped and is passed the Throwable that caused the failure. Configuration: You can configure your circuit breakers by creating beans of type Customizer . The Customizer interface has a single method (called customize ) that takes the Object to customize. For detailed information on how to customize a given implementation see the following documentation: Resilience4J(../../../../spring-cloud-circuitbreaker/current/reference/html/spring-cloud-circuitbreaker.html#configuring-resilience4j-circuit-breakers) Sentinel(https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-docs/src/main/asciidoc/circuitbreaker-sentinel.adoc#circuit-breaker-spring-cloud-circuit-breaker-with-sentinel—​configuring-sentinel-circuit-breakers) Spring Retry(../../../../../spring-cloud-circuitbreaker/docs/current/reference/html/spring-cloud-circuitbreaker.html#configuring-spring-retry-circuit-breakers) Some CircuitBreaker implementations such as Resilience4JCircuitBreaker call customize method every time CircuitBreaker#run is called. It can be inefficient. In that case, you can use CircuitBreaker#once method. It is useful where calling customize many times doesn’t make sense, for example, in case of consuming Resilience4j’s events(https://resilience4j.readme.io/docs/circuitbreaker#section-consume-emitted-circuitbreakerevents) . The following example shows the way for each io.github.resilience4j.circuitbreaker.CircuitBreaker to consume events. Customizer.once(circuitBreaker -> { circuitBreaker.getEventPublisher() .onStateTransition(event -> log.info(""{}: {}"", event.getCircuitBreakerName(), event.getStateTransition())); }, CircuitBreaker::getName)"
"https://docs.spring.io/spring-cloud-commons/reference/appendix.html","Common application properties: Various properties can be specified inside your application.properties file, inside your application.yml file, or as command line switches. This appendix provides a list of common Spring Cloud Commons properties and references to the underlying classes that consume them. Property contributions can come from additional jar files on your classpath, so you should not consider this an exhaustive list. Also, you can define your own properties. Observability metadata: Observability - Metrics: Below you can find a list of all metrics declared by this project. Circuit Breaker Function Observation: Observation created when we wrap a Function passed to the CircuitBreaker as fallback. Metric name spring.cloud.circuitbreaker (defined by convention class org.springframework.cloud.client.circuitbreaker.observation.DefaultCircuitBreakerObservationConvention ). Type timer . Metric name spring.cloud.circuitbreaker.active (defined by convention class org.springframework.cloud.client.circuitbreaker.observation.DefaultCircuitBreakerObservationConvention ). Type long task timer . KeyValues that are added after starting the Observation might be missing from the *.active metrics. Micrometer internally uses nanoseconds for the baseunit. However, each backend determines the actual baseunit. (i.e. Prometheus uses seconds) Fully qualified name of the enclosing class org.springframework.cloud.client.circuitbreaker.observation.CircuitBreakerObservationDocumentation . All tags must be prefixed with spring.cloud.circuitbreaker prefix! Table 1. Low cardinality Keys Name Description spring.cloud.circuitbreaker.type (required) Defines the type of wrapped lambda. Circuit Breaker Supplier Observation: Observation created when we wrap a Supplier passed to the CircuitBreaker. Metric name spring.cloud.circuitbreaker (defined by convention class org.springframework.cloud.client.circuitbreaker.observation.DefaultCircuitBreakerObservationConvention ). Type timer . Metric name spring.cloud.circuitbreaker.active (defined by convention class org.springframework.cloud.client.circuitbreaker.observation.DefaultCircuitBreakerObservationConvention ). Type long task timer . KeyValues that are added after starting the Observation might be missing from the *.active metrics. Micrometer internally uses nanoseconds for the baseunit. However, each backend determines the actual baseunit. (i.e. Prometheus uses seconds) Fully qualified name of the enclosing class org.springframework.cloud.client.circuitbreaker.observation.CircuitBreakerObservationDocumentation . All tags must be prefixed with spring.cloud.circuitbreaker prefix! Table 2. Low cardinality Keys Name Description spring.cloud.circuitbreaker.type (required) Defines the type of wrapped lambda. Observability - Spans: Below you can find a list of all spans declared by this project. Circuit Breaker Function Observation Span: Observation created when we wrap a Function passed to the CircuitBreaker as fallback. Span name spring.cloud.circuitbreaker (defined by convention class org.springframework.cloud.client.circuitbreaker.observation.DefaultCircuitBreakerObservationConvention ). Fully qualified name of the enclosing class org.springframework.cloud.client.circuitbreaker.observation.CircuitBreakerObservationDocumentation . All tags must be prefixed with spring.cloud.circuitbreaker prefix! Table 3. Tag Keys Name Description spring.cloud.circuitbreaker.type (required) Defines the type of wrapped lambda. Circuit Breaker Supplier Observation Span: Observation created when we wrap a Supplier passed to the CircuitBreaker. Span name spring.cloud.circuitbreaker (defined by convention class org.springframework.cloud.client.circuitbreaker.observation.DefaultCircuitBreakerObservationConvention ). Fully qualified name of the enclosing class org.springframework.cloud.client.circuitbreaker.observation.CircuitBreakerObservationDocumentation . All tags must be prefixed with spring.cloud.circuitbreaker prefix! Table 4. Tag Keys Name Description spring.cloud.circuitbreaker.type (required) Defines the type of wrapped lambda."
"https://docs.spring.io/spring-cloud-commons/reference/configprops.html","Configuration Properties: Below you can find a list of configuration properties. Name Default Description spring.cloud.compatibility-verifier.compatible-boot-versions Default accepted versions for the Spring Boot dependency. You can set {@code x} for the patch version if you don’t want to specify a concrete value. Example: {@code 3.4.x} spring.cloud.compatibility-verifier.enabled false Enables creation of Spring Cloud compatibility verification. spring.cloud.config.allow-override true Flag to indicate that {@link #isOverrideSystemProperties() systemPropertiesOverride} can be used. Set to false to prevent users from changing the default accidentally. Default true. spring.cloud.config.initialize-on-context-refresh false Flag to initialize bootstrap configuration on context refresh event. Default false. spring.cloud.config.override-none false Flag to indicate that when {@link #setAllowOverride(boolean) allowOverride} is true, external properties should take lowest priority and should not override any existing property sources (including local config files). Default false. This will only have an effect when using config first bootstrap. spring.cloud.config.override-system-properties true Flag to indicate that the external properties should override system properties. Default true. spring.cloud.decrypt-environment-post-processor.enabled true Enable the DecryptEnvironmentPostProcessor. spring.cloud.discovery.client.composite-indicator.enabled true Enables discovery client composite health indicator. spring.cloud.discovery.client.health-indicator.enabled true spring.cloud.discovery.client.health-indicator.include-description false spring.cloud.discovery.client.health-indicator.use-services-query true Whether or not the indicator should use {@link DiscoveryClient#getServices} to check its health. When set to {@code false} the indicator instead uses the lighter {@link DiscoveryClient#probe()}. This can be helpful in large deployments where the number of services returned makes the operation unnecessarily heavy. spring.cloud.discovery.client.simple.instances spring.cloud.discovery.client.simple.local.host spring.cloud.discovery.client.simple.local.instance-id spring.cloud.discovery.client.simple.local.metadata spring.cloud.discovery.client.simple.local.port 0 spring.cloud.discovery.client.simple.local.secure false spring.cloud.discovery.client.simple.local.service-id spring.cloud.discovery.client.simple.local.uri spring.cloud.discovery.client.simple.order spring.cloud.discovery.enabled true Enables discovery client health indicators. spring.cloud.features.enabled true Enables the features endpoint. spring.cloud.httpclientfactories.apache.enabled true Enables creation of Apache Http Client factory beans. spring.cloud.httpclientfactories.ok.enabled true Enables creation of OK Http Client factory beans. spring.cloud.hypermedia.refresh.fixed-delay 5000 spring.cloud.hypermedia.refresh.initial-delay 10000 spring.cloud.inetutils.default-hostname localhost The default hostname. Used in case of errors. spring.cloud.inetutils.default-ip-address 127.0.0.1 The default IP address. Used in case of errors. spring.cloud.inetutils.ignored-interfaces List of Java regular expressions for network interfaces that will be ignored. spring.cloud.inetutils.preferred-networks List of Java regular expressions for network addresses that will be preferred. spring.cloud.inetutils.timeout-seconds 1 Timeout, in seconds, for calculating hostname. spring.cloud.inetutils.use-only-site-local-interfaces false Whether to use only interfaces with site local addresses. See {@link InetAddress#isSiteLocalAddress()} for more details. spring.cloud.loadbalancer.cache.caffeine.spec The spec to use to create caches. See CaffeineSpec for more details on the spec format. spring.cloud.loadbalancer.cache.capacity 256 Initial cache capacity expressed as int. spring.cloud.loadbalancer.cache.enabled true Enables Spring Cloud LoadBalancer caching mechanism. spring.cloud.loadbalancer.cache.ttl 35s Time To Live - time counted from writing of the record, after which cache entries are expired, expressed as a {@link Duration}. The property {@link String} has to be in keeping with the appropriate syntax as specified in Spring Boot <code>StringToDurationConverter</code>. @see <a href= ""https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/convert/StringToDurationConverter.java"">StringToDurationConverter.java</a> spring.cloud.loadbalancer.call-get-with-request-on-delegates true If this flag is set to {@code true}, {@code ServiceInstanceListSupplier#get(Request request)} method will be implemented to call {@code delegate.get(request)} in classes assignable from {@code DelegatingServiceInstanceListSupplier} that don’t already implement that method, with the exclusion of {@code CachingServiceInstanceListSupplier} and {@code HealthCheckServiceInstanceListSupplier}, which should be placed in the instance supplier hierarchy directly after the supplier performing instance retrieval over the network, before any request-based filtering is done, {@code true} by default. spring.cloud.loadbalancer.clients spring.cloud.loadbalancer.configurations default Enables a predefined LoadBalancer configuration. spring.cloud.loadbalancer.eager-load.clients Names of the clients. spring.cloud.loadbalancer.enabled true Enables Spring Cloud LoadBalancer. spring.cloud.loadbalancer.health-check.initial-delay 0 Initial delay value for the HealthCheck scheduler. spring.cloud.loadbalancer.health-check.interval 25s Interval for rerunning the HealthCheck scheduler. spring.cloud.loadbalancer.health-check.interval 25s Interval for rerunning the HealthCheck scheduler. spring.cloud.loadbalancer.health-check.path Path at which the health-check request should be made. Can be set up per serviceId . A default value can be set up as well. If none is set up, /actuator/health will be used. spring.cloud.loadbalancer.health-check.port Path at which the health-check request should be made. If none is set, the port under which the requested service is available at the service instance. spring.cloud.loadbalancer.health-check.refetch-instances false Indicates whether the instances should be refetched by the HealthCheckServiceInstanceListSupplier . This can be used if the instances can be updated and the underlying delegate does not provide an ongoing flux. spring.cloud.loadbalancer.health-check.refetch-instances-interval 25s Interval for refetching available service instances. spring.cloud.loadbalancer.health-check.repeat-health-check true Indicates whether health checks should keep repeating. It might be useful to set it to false if periodically refetching the instances, as every refetch will also trigger a healthcheck. spring.cloud.loadbalancer.health-check.update-results-list true Indicates whether the {@code healthCheckFlux} should emit on each alive {@link ServiceInstance} that has been retrieved. If set to {@code false}, the entire alive instances sequence is first collected into a list and only then emitted. spring.cloud.loadbalancer.hint Allows setting the value of <code>hint</code> that is passed on to the LoadBalancer request and can subsequently be used in {@link ReactiveLoadBalancer} implementations. spring.cloud.loadbalancer.hint-header-name X-SC-LB-Hint Allows setting the name of the header used for passing the hint for hint-based service instance filtering. spring.cloud.loadbalancer.retry.avoid-previous-instance true Enables wrapping ServiceInstanceListSupplier beans with RetryAwareServiceInstanceListSupplier if Spring-Retry is in the classpath. spring.cloud.loadbalancer.retry.backoff.enabled false Indicates whether Reactor Retry backoffs should be applied. spring.cloud.loadbalancer.retry.backoff.jitter 0.5 Used to set RetryBackoffSpec.jitter . spring.cloud.loadbalancer.retry.backoff.max-backoff Long.MAX ms Used to set RetryBackoffSpec.maxBackoff . spring.cloud.loadbalancer.retry.backoff.min-backoff 5 ms Used to set RetryBackoffSpec#minBackoff . spring.cloud.loadbalancer.retry.enabled true Enables LoadBalancer retries. spring.cloud.loadbalancer.retry.max-retries-on-next-service-instance 1 Number of retries to be executed on the next ServiceInstance . A ServiceInstance is chosen before each retry call. spring.cloud.loadbalancer.retry.max-retries-on-same-service-instance 0 Number of retries to be executed on the same ServiceInstance . spring.cloud.loadbalancer.retry.retry-on-all-exceptions false Indicates retries should be attempted for all exceptions, not only those specified in retryableExceptions . spring.cloud.loadbalancer.retry.retry-on-all-operations false Indicates retries should be attempted on operations other than HttpMethod.GET . spring.cloud.loadbalancer.retry.retryable-exceptions {} A Set of Throwable classes that should trigger a retry. spring.cloud.loadbalancer.retry.retryable-status-codes {} A Set of status codes that should trigger a retry. spring.cloud.loadbalancer.service-discovery.timeout String representation of Duration of the timeout for calls to service discovery. spring.cloud.loadbalancer.stats.micrometer.enabled false Enables Spring Cloud LoadBalancer Micrometer stats. spring.cloud.loadbalancer.sticky-session.add-service-instance-cookie false Indicates whether a cookie with the newly selected instance should be added by LoadBalancer. spring.cloud.loadbalancer.sticky-session.instance-id-cookie-name sc-lb-instance-id The name of the cookie holding the preferred instance id. spring.cloud.loadbalancer.subset.instance-id Instance id of deterministic subsetting. If not set, {@link IdUtils#getDefaultInstanceId(PropertyResolver)} will be used. spring.cloud.loadbalancer.subset.size 100 Max subset size of deterministic subsetting. spring.cloud.loadbalancer.x-forwarded.enabled false To Enable X-Forwarded Headers. spring.cloud.loadbalancer.zone Spring Cloud LoadBalancer zone. spring.cloud.refresh.additional-property-sources-to-retain Additional property sources to retain during a refresh. Typically only system property sources are retained. This property allows property sources, such as property sources created by EnvironmentPostProcessors to be retained as well. spring.cloud.refresh.enabled true Enables autoconfiguration for the refresh scope and associated features. spring.cloud.refresh.extra-refreshable true Additional class names for beans to post process into refresh scope. spring.cloud.refresh.never-refreshable true Comma separated list of class names for beans to never be refreshed or rebound. spring.cloud.refresh.on-restart.enabled true Enable refreshing context on start. spring.cloud.service-registry.auto-registration.enabled true Whether service auto-registration is enabled. Defaults to true. spring.cloud.service-registry.auto-registration.fail-fast false Whether startup fails if there is no AutoServiceRegistration. Defaults to false. spring.cloud.service-registry.auto-registration.register-management true Whether to register the management as a service. Defaults to true. spring.cloud.util.enabled true Enables creation of Spring Cloud utility beans."
