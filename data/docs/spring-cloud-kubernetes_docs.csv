"url","content"
"https://docs.spring.io/spring-cloud-kubernetes/reference/index.html","Spring Cloud Kubernetes: This reference guide covers how to use Spring Cloud Kubernetes. Why do you need Spring Cloud Kubernetes?: Spring Cloud Kubernetes provides implementations of well known Spring Cloud interfaces allowing developers to build and run Spring Cloud applications on Kubernetes. While this project may be useful to you when building a cloud native application, it is also not a requirement in order to deploy a Spring Boot app on Kubernetes. If you are just getting started in your journey to running your Spring Boot app on Kubernetes you can accomplish a lot with nothing more than a basic Spring Boot app and Kubernetes itself. To learn more, you can get started by reading the Spring Boot reference documentation for deploying to Kubernetes(https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#cloud-deployment-kubernetes) and also working through the workshop material Spring and Kubernetes(https://hackmd.io/@ryanjbaxter/spring-on-k8s-workshop) . Configuration properties: To see the list of all Kubernetes related configuration properties please check the Appendix page(appendix.html) . Building: Click here(https://docs.spring.io/spring-cloud-build/reference/building.html) for basic building instructions. Contributing: Click here(https://docs.spring.io/spring-cloud-build/reference/contributing.html) for instructions on contributing to this project. AOT and native image support: At this point, Spring Cloud Kubernetes does not support Spring Boot AOT transformations or native images. Partial support might be added in future releases."
"https://docs.spring.io/spring-cloud-kubernetes/reference/getting-started.html","Starters: Starters are convenient dependency descriptors you can include in your application. Include a starter to get the dependencies and Spring Boot auto-configuration for a feature set. Starters that begin with spring-cloud-starter-kubernetes-fabric8 provide implementations using the Fabric8 Kubernetes Java Client(https://github.com/fabric8io/kubernetes-client) . Starters that begin with spring-cloud-starter-kubernetes-client provide implementations using the Kubernetes Java Client(https://github.com/kubernetes-client/java) . You CANNOT combine starters from Fabric8 and Kubernetes Java Clients. You must pick one library to use and use the starters for that library only. Starter Features Fabric8 Dependency <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-kubernetes-fabric8</artifactId> </dependency> Kubernetes Client Dependency <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-kubernetes-client</artifactId> </dependency> Discovery Client(#DiscoveryClient for Kubernetes) implementation that resolves service names to Kubernetes Services. Fabric8 Dependency <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-kubernetes-fabric8-config</artifactId> </dependency> Kubernetes Client Dependency <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-kubernetes-client-config</artifactId> </dependency> Load application properties from Kubernetes ConfigMaps(property-source-config/configmap-propertysource.html) and Secrets(#Secrets PropertySource) . Reload(property-source-config/propertysource-reload.html) application properties when a ConfigMap or Secret changes. Fabric8 Dependency <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-kubernetes-fabric8-all</artifactId> </dependency> Kubernetes Client Dependency <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-kubernetes-client-all</artifactId> </dependency> All Spring Cloud Kubernetes features."
"https://docs.spring.io/spring-cloud-kubernetes/reference/discovery-client.html","DiscoveryClient for Kubernetes: This project provides an implementation of Discovery Client(https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/discovery/DiscoveryClient.java) for Kubernetes(https://kubernetes.io) . This client lets you query Kubernetes endpoints (see services(https://kubernetes.io/docs/user-guide/services/) ) by name. A service is typically exposed by the Kubernetes API server as a collection of endpoints that represent http and https addresses and that a client can access from a Spring Boot application running as a pod. DiscoveryClient can also find services of type ExternalName (see ExternalName services(https://kubernetes.io/docs/concepts/services-networking/service/#externalname) ). At the moment, external name support type of services is only available if the following property spring.cloud.kubernetes.discovery.include-external-name-services is set to true (it is false by default). There are 3 types of discovery clients that we support: 1. Fabric8 Kubernetes Client <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-kubernetes-fabric8</artifactId> </dependency> 2. Kubernetes Java Client <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-kubernetes-client</artifactId> </dependency> 3. HTTP Based DiscoveryClient <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-kubernetes-discoveryclient</artifactId> </dependency> spring-cloud-starter-kubernetes-discoveryclient is designed to be used with the Spring Cloud Kubernetes DiscoveryServer(#spring-cloud-kubernetes-discoveryserver) . To enable loading of the DiscoveryClient , add @EnableDiscoveryClient to the according configuration or application class, as the following example shows: @SpringBootApplication @EnableDiscoveryClient public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } Then you can inject the client in your code simply by autowiring it, as the following example shows: @Autowired private DiscoveryClient discoveryClient; The first question you should ask yourself is where a DiscoveryClient supposed to discover services. In the kubernetes world, this means what namespace(s). There are 3 options here: selective namespaces . For example: spring.cloud.kubernetes.discovery.namespaces[0]=ns1 spring.cloud.kubernetes.discovery.namespaces[1]=ns2 Such a configuration makes discovery client only search for services in two namespaces ns1 and ns2 . all-namespaces . spring.cloud.kubernetes.discovery.all-namespaces=true While such an option exists, this can be a burden on both kube-api and your application. It is rare to need such a setting. one namespace . This is the default setting, if you do not specify any of the above. It works on the rules outlined in Namespace Resolution(property-source-config.html#namespace-resolution) . The above options work exactly as written for fabric8 and k8s clients. For the HTTP based client, you need to enable those options on the server . That can be achieved by setting them in deployment.yaml used to deploy the image in the cluster, using env variable(s). For example: containers: - name: discovery-server image: springcloud/spring-cloud-kubernetes-discoveryserver:3.0.5-SNAPSHOT env: - name: SPRING_CLOUD_KUBERNETES_DISCOVERY_NAMESPACES_0 value: ""namespace-a"" Once namespaces have been configured, the next question to answer is what services to discover. Think about it as what filter to apply. By default, no filtering is applied at all and all services are discovered. If you need to narrow what discovery client can find, you have two options: Only take services that match certain service labels. This property is specified with: spring.cloud.kubernetes.discovery.service-labels . It accepts a Map and only those services that have such labels (as seen in metadata.labels in the service definition) will be taken into account. The other option is to use SpEL expression(https://docs.spring.io/spring-framework/reference/core/expressions.html) . This is denoted by the spring.cloud.kubernetes.discovery.filter property, and its value depends on the client that you chose. If you use the fabric8 client, this SpEL expression must be created against io.fabric8.kubernetes.api.model.Service class. One such example could be: spring.cloud.kubernetes.discovery.filter='#root.metadata.namespace matches ""^.+A$""' which tells discovery client to only get services that have the metadata.namespace that ends in upper case A . If your discovery client is based on k8s-native client, then the SpEL expression must be based on io.kubernetes.client.openapi.models.V1Service class. The same filter showed above would work here. If your discovery client is the http based one, then the SeEL expression has to be based on the same io.kubernetes.client.openapi.models.V1Service class, with the only distinction that this needs to be set as an env variable in the deployment yaml: containers: - name: discovery-server image: springcloud/spring-cloud-kubernetes-discoveryserver:3.0.5-SNAPSHOT env: - name: SPRING_CLOUD_KUBERNETES_DISCOVERY_FILTER value: '#root.metadata.namespace matches ""^.+A$""' It’s now time to think what discovery client is supposed to return back. In general, there are two methods that DiscoveryClient has: getServices and getInstances . getServices will return the service names as seen in the metadata.name . This method will return unique service names, even if there are duplicates across different namespaces (that you chose for the search). getInstances returns a List<ServiceInstance> . Besides the usual fields that a ServiceInstance has, we also add some data, like namespace or pod metadata (more explanation about these will follow in the document). Here is the data that we return at the moment: instanceId - unique id of the service instance serviceId - the name of the service (it is the same as the one reported by calling getServices ) host - IP of the instance (or name in case of the ExternalName type of service) port - port number of the instance. This requires a bit more explanation, as choosing the port number has its rules: service has no port defined, 0 (zero) will be returned. service has a single port defined, that one will be returned. If the service has a label primary-port-name , we will use the port number that has the name specified in the label’s value. If the above label is not present, then we will use the port name specified in spring.cloud.kubernetes.discovery.primary-port-name to find the port number. If neither of the above are specified, we will use the port named https or http to compute the port number. As a last resort we wil pick the first port in the list of ports. This last option may result in non-deterministic behaviour. uri of the service instance scheme either http or https (depending on the secure result) metadata of the service: labels (if requested via spring.cloud.kubernetes.discovery.metadata.add-labels=true ). Label keys can be ""prefixed"" with the value of spring.cloud.kubernetes.discovery.metadata.labels-prefix if it is set. annotations (if requested via spring.cloud.kubernetes.discovery.metadata.add-annotations=true ). Annotations keys can be ""prefixed"" with the value of spring.cloud.kubernetes.discovery.metadata.annotations-prefix if it is set. ports (if requested via spring.cloud.kubernetes.discovery.metadata.add-ports=true ). Port keys can be ""prefixed"" with the value of spring.cloud.kubernetes.discovery.metadata.ports-prefix if it is set. k8s_namespace with the value of the namespace where instance resides. type that holds the service type, for example ClusterIP or ExternalName secure if the port that was discovered should be treated as secure. We will use the same rules outlined above to find the port name and number, and then: If this service has a label called secured with any of the values : [""true"", ""on"", ""yes"", ""1""] , then treat the port that was found as secure. If such a label is not found, search for an annotation called secured and apply the same above rules. If this port number is part of spring.cloud.kubernetes.discovery.known-secure-ports (by default this value holds [443, 8443] ), treat port number as secured. Last resort is to see if port name matches https ; if it does treat this port as secured. namespace - the namespace of the found instance. pod-metadata labels and annotations of the service instance (pod), in the form of Map<String, Map<String, String>> . This support needs to be enabled via spring.cloud.kubernetes.discovery.metadata.add-pod-labels=true and/or spring.cloud.kubernetes.discovery.metadata.add-pod-annotaations=true To discover service endpoint addresses that are not marked as ""ready"" by the kubernetes api server, you can set the following property in application.properties (default: false): spring.cloud.kubernetes.discovery.include-not-ready-addresses=true This might be useful when discovering services for monitoring purposes, and would enable inspecting the /health endpoint of not-ready service instances. If you want to get the list of ServiceInstance to also include the ExternalName type services, you need to enable that support via: spring.cloud.kubernetes.discovery.include-external-name-services=true . As such, when calling DiscoveryClient::getInstances those will be returned also. You can distinguish between ExternalName and any other types by inspecting ServiceInstance::getMetadata and lookup for a field called type . This will be the type of the service returned : ExternalName / ClusterIP , etc. If, for any reason, you need to disable the DiscoveryClient , you can set the following property in application.properties : spring.main.cloud-platform=NONE Note that the support of discovery client is automatic , depending on where you run the application. So the above setting might not be needed. Some Spring Cloud components use the DiscoveryClient in order to obtain information about the local service instance. For this to work, you need to align the Kubernetes service name with the spring.application.name property. spring.application.name has no effect as far as the name registered for the application within Kubernetes Spring Cloud Kubernetes can also watch the Kubernetes service catalog for changes and update the DiscoveryClient implementation accordingly. In order to enable this functionality you need to add @EnableScheduling on a configuration class in your application. By ""watch"", we mean that we will publish a heartbeat event every spring.cloud.kubernetes.discovery.catalog-services-watch-delay milliseconds (by default it is 30000 ). For the http discovery server this must be an environment variable set in deployment yaml: containers: - name: discovery-server image: springcloud/spring-cloud-kubernetes-discoveryserver:3.0.5-SNAPSHOT env: - name: SPRING_CLOUD_KUBERNETES_DISCOVERY_CATALOGSERVICESWATCHDELAY value: 3000 The heartbeat event will contain the target references (and their namespaces of the addresses of all endpoints (for the exact details of what will get returned you can take a look inside KubernetesCatalogWatch ). This is an implementation detail, and listeners of the heartbeat event should not rely on the details. Instead, they should see if there are differences between two subsequent heartbeats via equals method. We will take care to return a correct implementation that adheres to the equals contract. The endpoints will be queried in either : - all-namespaces (enabled via spring.cloud.kubernetes.discovery.all-namespaces=true ) selective namespaces (enabled via spring.cloud.kubernetes.discovery.namespaces ), for example: one namespace via Namespace Resolution(property-source-config.html#namespace-resolution) if the above two paths are not taken. If, for any reasons, you want to disable catalog watcher, you need to set spring.cloud.kubernetes.discovery.catalog-services-watch.enabled=false . For the http discovery server, this needs to be an environment variable set in deployment for example: SPRING_CLOUD_KUBERNETES_DISCOVERY_CATALOGSERVICESWATCH_ENABLED=FALSE The functionality of catalog watch works for all 3 discovery clients that we support, with some caveats that you need to be aware of in case of the http client. The first is that this functionality is disabled by default, and it needs to be enabled in two places: in discovery server via an environment variable in the deployment manifest, for example: containers: - name: discovery-server image: springcloud/spring-cloud-kubernetes-discoveryserver:3.0.5-SNAPSHOT env: - name: SPRING_CLOUD_KUBERNETES_HTTP_DISCOVERY_CATALOG_WATCHER_ENABLED value: ""TRUE"" in discovery client, via a property in your application.properties for example: spring.cloud.kubernetes.http.discovery.catalog.watcher.enabled=true The second point is that this is only supported since version 3.0.6 and upwards. Since http discovery has two components : server and client, we strongly recommend to align versions between them, otherwise things might not work. If you decide to disable catalog watcher, you need to disable it in both server and client. By default, we use the Endpoints (see kubernetes.io/docs/concepts/services-networking/service/#endpoints(https://kubernetes.io/docs/concepts/services-networking/service/#endpoints) ) API to find out the current state of services. There is another way though, via EndpointSlices ( kubernetes.io/docs/concepts/services-networking/endpoint-slices/(https://kubernetes.io/docs/concepts/services-networking/endpoint-slices/) ). Such support can be enabled via a property: spring.cloud.kubernetes.discovery.use-endpoint-slices=true (by default it is false ). Of course, your cluster has to support it also. As a matter of fact, if you enable this property, but your cluster does not support it, we will fail starting the application. If you decide to enable such support, you also need proper Role/ClusterRole set-up. For example: apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: namespace-reader rules: - apiGroups: [""discovery.k8s.io""] resources: [""endpointslices""] verbs: [""get"", ""list"", ""watch""]"
"https://docs.spring.io/spring-cloud-kubernetes/reference/discovery-kubernetes-native.html","Kubernetes native service discovery: Kubernetes itself is capable of (server side) service discovery (see: kubernetes.io/docs/concepts/services-networking/service/#discovering-services(https://kubernetes.io/docs/concepts/services-networking/service/#discovering-services) ). Using native kubernetes service discovery ensures compatibility with additional tooling, such as Istio ( istio.io(https://istio.io) ), a service mesh that is capable of load balancing, circuit breaker, failover, and much more. The caller service then need only refer to names resolvable in a particular Kubernetes cluster. A simple implementation might use a spring RestTemplate that refers to a fully qualified domain name (FQDN), such as {service-name}.{namespace}.svc.{cluster}.local:{service-port}(https://{service-name}.{namespace}.svc.{cluster}.local:{service-port}) . Additionally, you can use Hystrix for: Circuit breaker implementation on the caller side, by annotating the spring boot application class with @EnableCircuitBreaker Fallback functionality, by annotating the respective method with @HystrixCommand(fallbackMethod="
"https://docs.spring.io/spring-cloud-kubernetes/reference/property-source-config.html","Kubernetes PropertySource implementations: The most common approach to configuring your Spring Boot application is to create an application.properties or application.yaml or an application-profile.properties or application-profile.yaml file that contains key-value pairs that provide customization values to your application or Spring Boot starters. You can override these properties by specifying system properties or environment variables. To enable this functionality you need to set the spring.config.import application configuration property to kubernetes: (escape with quotes when using yaml eg. ""kubernetes:"" ). Currently you can not specify a ConfigMap or Secret to load using spring.config.import , by default Spring Cloud Kubernetes will load a ConfigMap and/or Secret based on the spring.application.name property. If spring.application.name is not set it will load a ConfigMap and/or Secret with the name application . If you would like to load Kubernetes PropertySource s during the bootstrap phase like it worked prior to the 3.0.x release you can either add spring-cloud-starter-bootstrap to your application’s classpath or set spring.cloud.bootstrap.enabled=true as an environment variable. Section Summary: Using a ConfigMap PropertySource(property-source-config/configmap-propertysource.html) Secrets PropertySource(property-source-config/secrets-propertysource.html) Namespace resolution(property-source-config/namespace-resolution.html) Order of ConfigMaps and Secrets(property-source-config/order_of_configMaps_and_secrets.html) PropertySource Reload(property-source-config/propertysource-reload.html) Reload namespace and label filtering(property-source-config/namespace-label-filtering.html)"
"https://docs.spring.io/spring-cloud-kubernetes/reference/property-source-config/configmap-propertysource.html","Using a ConfigMap PropertySource: Kubernetes provides a resource named ConfigMap(https://kubernetes.io/docs/user-guide/configmap/) to externalize the parameters to pass to your application in the form of key-value pairs or embedded application.properties or application.yaml files. The Spring Cloud Kubernetes Config(https://github.com/spring-cloud/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-fabric8-config) project makes Kubernetes ConfigMap instances available during application startup and triggers hot reloading of beans or Spring context when changes are detected on observed ConfigMap instances. Everything that follows is explained mainly referring to examples using ConfigMaps, but the same stands for Secrets, i.e.: every feature is supported for both. The default behavior is to create a Fabric8ConfigMapPropertySource (or a KubernetesClientConfigMapPropertySource ) based on a Kubernetes ConfigMap that has metadata.name of either: value of spring.cloud.kubernetes.config.name value of your Spring application (as defined by spring.application.name property) the String literal ""application"" However, more advanced configuration is possible where you can use multiple ConfigMap instances. The spring.cloud.kubernetes.config.sources list makes this possible. For example, you could define the following ConfigMap instances: spring: application: name: cloud-k8s-app cloud: kubernetes: config: name: default-name namespace: default-namespace sources: # Spring Cloud Kubernetes looks up a ConfigMap named c1 in namespace default-namespace - name: c1 # Spring Cloud Kubernetes looks up a ConfigMap named default-name in whatever namespace n2 - namespace: n2 # Spring Cloud Kubernetes looks up a ConfigMap named c3 in namespace n3 - namespace: n3 name: c3 In the preceding example, if spring.cloud.kubernetes.config.namespace had not been set, the ConfigMap named c1 would be looked up in the namespace that the application runs. See Namespace resolution(namespace-resolution.html) to get a better understanding of how the namespace of the application is resolved. Any matching ConfigMap that is found is processed as follows: Apply individual configuration properties. Apply as yaml (or properties ) the content of any property that is named by the value of spring.application.name (if it’s not present, by application.yaml/properties ) Apply as a properties file the content of the above name + each active profile. An example should make a lot more sense. Let’s suppose that spring.application.name=my-app and that we have a single active profile called k8s . For a configuration as below: kind: ConfigMap apiVersion: v1 metadata: name: my-app data: my-app.yaml: |- ... my-app-k8s.yaml: |- .. my-app-dev.yaml: |- .. not-my-app.yaml: |- .. someProp: someValue This is what we will end-up loading: my-app.yaml treated as a file my-app-k8s.yaml treated as a file my-app-dev.yaml ignored , since dev is not an active profile not-my-app.yaml ignored , since it does not match spring.application.name someProp: someValue plain property The order of loading properties is a as follows: first load all properties from my-app.yaml then all from profile-based sources: my-app-k8s.yaml then all plain properties someProp: someValue This means that profile based sources take precedence over non-profile based sources (just like in a vanilla Spring app); and plain properties take precedence over both profile and non-profile based sources. Here is an example: kind: ConfigMap apiVersion: v1 metadata: name: my-app data: my-app-k8s.yaml: |- key1=valueA key2=valueB my-app.yaml: |- key1=valueC key2=valueA key1: valueD After processing such a ConfigMap, this is what you will get in the properties: key1=valueD , key2=valueB . The single exception to the aforementioned flow is when the ConfigMap contains a single key that indicates the file is a YAML or properties file. In that case, the name of the key does NOT have to be application.yaml or application.properties (it can be anything) and the value of the property is treated correctly. This features facilitates the use case where the ConfigMap was created by using something like the following: kubectl create configmap game-config --from-file=/path/to/app-config.yaml Assume that we have a Spring Boot application named demo that uses the following properties to read its thread pool configuration. pool.size.core pool.size.maximum This can be externalized to config map in yaml format as follows: kind: ConfigMap apiVersion: v1 metadata: name: demo data: pool.size.core: 1 pool.size.max: 16 Individual properties work fine for most cases. However, sometimes, embedded yaml is more convenient. In this case, we use a single property named application.yaml to embed our yaml , as follows: kind: ConfigMap apiVersion: v1 metadata: name: demo data: application.yaml: |- pool: size: core: 1 max:16 The following example also works: kind: ConfigMap apiVersion: v1 metadata: name: demo data: custom-name.yaml: |- pool: size: core: 1 max:16 You can also define the search to happen based on labels, for example: spring: application: name: labeled-configmap-with-prefix cloud: kubernetes: config: enableApi: true useNameAsPrefix: true namespace: spring-k8s sources: - labels: letter: a This will search for every configmap in namespace spring-k8s that has labels {letter : a} . The important thing to notice here is that unlike reading a configmap by name, this can result in multiple config maps read. As usual, the same feature is supported for secrets. You can also configure Spring Boot applications differently depending on active profiles that are merged together when the ConfigMap is read. You can provide different property values for different profiles by using an application.properties or application.yaml property, specifying profile-specific values, each in their own document (indicated by the --- sequence), as follows: kind: ConfigMap apiVersion: v1 metadata: name: demo data: application.yml: |- greeting: message: Say Hello to the World farewell: message: Say Goodbye --- spring: profiles: development greeting: message: Say Hello to the Developers farewell: message: Say Goodbye to the Developers --- spring: profiles: production greeting: message: Say Hello to the Ops In the preceding case, the configuration loaded into your Spring Application with the development profile is as follows: greeting: message: Say Hello to the Developers farewell: message: Say Goodbye to the Developers However, if the production profile is active, the configuration becomes: greeting: message: Say Hello to the Ops farewell: message: Say Goodbye If both profiles are active, the property that appears last within the ConfigMap overwrites any preceding values. Another option is to create a different config map per profile and spring boot will automatically fetch it based on active profiles kind: ConfigMap apiVersion: v1 metadata: name: demo data: application.yml: |- greeting: message: Say Hello to the World farewell: message: Say Goodbye kind: ConfigMap apiVersion: v1 metadata: name: demo-development data: application.yml: |- spring: profiles: development greeting: message: Say Hello to the Developers farewell: message: Say Goodbye to the Developers kind: ConfigMap apiVersion: v1 metadata: name: demo-production data: application.yml: |- spring: profiles: production greeting: message: Say Hello to the Ops farewell: message: Say Goodbye To tell Spring Boot which profile should be enabled see the Spring Boot documentation(https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.profiles) . One option for activating a specific profile when deploying to Kubernetes is to launch your Spring Boot application with an environment variable that you can define in the PodSpec at the container specification. Deployment resource file, as follows: apiVersion: apps/v1 kind: Deployment metadata: name: deployment-name labels: app: deployment-name spec: replicas: 1 selector: matchLabels: app: deployment-name template: metadata: labels: app: deployment-name spec: containers: - name: container-name image: your-image env: - name: SPRING_PROFILES_ACTIVE value: ""development"" You could run into a situation where there are multiple configs maps that have the same property names. For example: kind: ConfigMap apiVersion: v1 metadata: name: config-map-one data: application.yml: |- greeting: message: Say Hello from one and kind: ConfigMap apiVersion: v1 metadata: name: config-map-two data: application.yml: |- greeting: message: Say Hello from two Depending on the order in which you place these in bootstrap.yaml|properties , you might end up with an un-expected result (the last config map wins). For example: spring: application: name: cloud-k8s-app cloud: kubernetes: config: namespace: default-namespace sources: - name: config-map-two - name: config-map-one will result in property greetings.message being Say Hello from one . There is a way to change this default configuration by specifying useNameAsPrefix . For example: spring: application: name: with-prefix cloud: kubernetes: config: useNameAsPrefix: true namespace: default-namespace sources: - name: config-map-one useNameAsPrefix: false - name: config-map-two Such a configuration will result in two properties being generated: greetings.message equal to Say Hello from one . config-map-two.greetings.message equal to Say Hello from two Notice that spring.cloud.kubernetes.config.useNameAsPrefix has a lower priority than spring.cloud.kubernetes.config.sources.useNameAsPrefix . This allows you to set a ""default"" strategy for all sources, at the same time allowing to override only a few. If using the config map name is not an option, you can specify a different strategy, called : explicitPrefix . Since this is an explicit prefix that you select, it can only be supplied to the sources level. At the same time it has a higher priority than useNameAsPrefix . Let’s suppose we have a third config map with these entries: kind: ConfigMap apiVersion: v1 metadata: name: config-map-three data: application.yml: |- greeting: message: Say Hello from three A configuration like the one below: spring: application: name: with-prefix cloud: kubernetes: config: useNameAsPrefix: true namespace: default-namespace sources: - name: config-map-one useNameAsPrefix: false - name: config-map-two explicitPrefix: two - name: config-map-three will result in three properties being generated: greetings.message equal to Say Hello from one . two.greetings.message equal to Say Hello from two . config-map-three.greetings.message equal to Say Hello from three . The same way you configure a prefix for configmaps, you can do it for secrets also; both for secrets that are based on name and the ones based on labels. For example: spring: application: name: prefix-based-secrets cloud: kubernetes: secrets: enableApi: true useNameAsPrefix: true namespace: spring-k8s sources: - labels: letter: a useNameAsPrefix: false - labels: letter: b explicitPrefix: two - labels: letter: c - labels: letter: d useNameAsPrefix: true - name: my-secret The same processing rules apply when generating property source as for config maps. The only difference is that potentially, looking up secrets by labels can mean that we find more than one source. In such a case, prefix (if specified via useNameAsPrefix ) will be the names of all secrets found for those particular labels. One more thing to bear in mind is that we support prefix per source , not per secret. The easiest way to explain this is via an example: spring: application: name: prefix-based-secrets cloud: kubernetes: secrets: enableApi: true useNameAsPrefix: true namespace: spring-k8s sources: - labels: color: blue useNameAsPrefix: true Suppose that a query matching such a label will provide two secrets as a result: secret-a and secret-b . Both of these secrets have the same property name: color=sea-blue and color=ocean-blue . It is undefined which color will end-up as part of property sources, but the prefix for it will be secret-a.secret-b (concatenated sorted naturally, names of the secrets). If you need more fine-grained results, adding more labels to identify the secret uniquely would be an option. By default, besides reading the config map that is specified in the sources configuration, Spring will also try to read all properties from ""profile aware"" sources. The easiest way to explain this is via an example. Let’s suppose your application enables a profile called ""dev"" and you have a configuration like the one below: spring: application: name: spring-k8s cloud: kubernetes: config: namespace: default-namespace sources: - name: config-map-one Besides reading the config-map-one , Spring will also try to read config-map-one-dev ; in this particular order. Each active profile generates such a profile aware config map. Though your application should not be impacted by such a config map, it can be disabled if needed: spring: application: name: spring-k8s cloud: kubernetes: config: includeProfileSpecificSources: false namespace: default-namespace sources: - name: config-map-one includeProfileSpecificSources: false Notice that just like before, there are two levels where you can specify this property: for all config maps or for individual ones; the latter having a higher priority. You should check the security configuration section. To access config maps from inside a pod you need to have the correct Kubernetes service accounts, roles and role bindings. Another option for using ConfigMap instances is to mount them into the Pod by running the Spring Cloud Kubernetes application and having Spring Cloud Kubernetes read them from the file system. This feature is deprecated and will be removed in a future release (Use spring.config.import instead). This behavior is controlled by the spring.cloud.kubernetes.config.paths property. You can use it in addition to or instead of the mechanism described earlier. spring.cloud.kubernetes.config.paths expects a List of full paths to each property file, because directories are not being recursively parsed. For example: spring: cloud: kubernetes: config: paths: - /tmp/application.properties - /var/application.yaml If you use spring.cloud.kubernetes.config.paths or spring.cloud.kubernetes.secrets.path the automatic reload functionality will not work. You will need to make a POST request to the /actuator/refresh endpoint or restart/redeploy the application. In some cases, your application may be unable to load some of your ConfigMaps using the Kubernetes API. If you want your application to fail the start-up process in such cases, you can set spring.cloud.kubernetes.config.fail-fast=true to make the application start-up fail with an Exception. You can also make your application retry loading ConfigMap property sources on a failure. First, you need to set spring.cloud.kubernetes.config.fail-fast=true . Then you need to add spring-retry and spring-boot-starter-aop to your classpath. You can configure retry properties such as the maximum number of attempts, backoff options like initial interval, multiplier, max interval by setting the spring.cloud.kubernetes.config.retry.* properties. If you already have spring-retry and spring-boot-starter-aop on the classpath for some reason and want to enable fail-fast, but do not want retry to be enabled; you can disable retry for ConfigMap PropertySources by setting spring.cloud.kubernetes.config.retry.enabled=false . Table 1. Properties: Name Type Default Description spring.cloud.kubernetes.config.enabled Boolean true Enable ConfigMaps PropertySource spring.cloud.kubernetes.config.name String ${spring.application.name} Sets the name of ConfigMap to look up spring.cloud.kubernetes.config.namespace String Client namespace Sets the Kubernetes namespace where to lookup spring.cloud.kubernetes.config.paths List null Sets the paths where ConfigMap instances are mounted spring.cloud.kubernetes.config.enableApi Boolean true Enable or disable consuming ConfigMap instances through APIs spring.cloud.kubernetes.config.fail-fast Boolean false Enable or disable failing the application start-up when an error occurred while loading a ConfigMap spring.cloud.kubernetes.config.retry.enabled Boolean true Enable or disable config retry. spring.cloud.kubernetes.config.retry.initial-interval Long 1000 Initial retry interval in milliseconds. spring.cloud.kubernetes.config.retry.max-attempts Integer 6 Maximum number of attempts. spring.cloud.kubernetes.config.retry.max-interval Long 2000 Maximum interval for backoff. spring.cloud.kubernetes.config.retry.multiplier Double 1.1 Multiplier for next interval."
"https://docs.spring.io/spring-cloud-kubernetes/reference/property-source-config/secrets-propertysource.html","Secrets PropertySource: Kubernetes has the notion of Secrets(https://kubernetes.io/docs/concepts/configuration/secret/) for storing sensitive data such as passwords, OAuth tokens, and so on. This project provides integration with Secrets to make secrets accessible by Spring Boot applications. You can explicitly enable or disable This feature by setting the spring.cloud.kubernetes.secrets.enabled property. When enabled, the Fabric8SecretsPropertySource looks up Kubernetes for Secrets from the following sources: Reading recursively from secrets mounts Named after the application (as defined by spring.application.name ) Matching some labels Note: By default, consuming Secrets through the API (points 2 and 3 above) is not enabled for security reasons. The permission 'list' on secrets allows clients to inspect secrets values in the specified namespace. Further, we recommend that containers share secrets through mounted volumes. If you enable consuming Secrets through the API, we recommend that you limit access to Secrets by using an authorization policy, such as RBAC. For more information about risks and best practices when consuming Secrets through the API refer to this doc(https://kubernetes.io/docs/concepts/configuration/secret/#best-practices) . If the secrets are found, their data is made available to the application. Assume that we have a spring boot application named demo that uses properties to read its database configuration. We can create a Kubernetes secret by using the following command: kubectl create secret generic db-secret --from-literal=username=user --from-literal=password=p455w0rd The preceding command would create the following secret (which you can see by using kubectl get secrets db-secret -o yaml ): apiVersion: v1 data: password: cDQ1NXcwcmQ= username: dXNlcg== kind: Secret metadata: creationTimestamp: 2017-07-04T09:15:57Z name: db-secret namespace: default resourceVersion: ""357496"" selfLink: /api/v1/namespaces/default/secrets/db-secret uid: 63c89263-6099-11e7-b3da-76d6186905a8 type: Opaque Note that the data contains Base64-encoded versions of the literal provided by the create command. Your application can then use this secret — for example, by exporting the secret’s value as environment variables: apiVersion: v1 kind: Deployment metadata: name: ${project.artifactId} spec: template: spec: containers: - env: - name: DB_USERNAME valueFrom: secretKeyRef: name: db-secret key: username - name: DB_PASSWORD valueFrom: secretKeyRef: name: db-secret key: password You can select the Secrets to consume in a number of ways: By listing the directories where secrets are mapped: -Dspring.cloud.kubernetes.secrets.paths=/etc/secrets/db-secret,etc/secrets/postgresql If you have all the secrets mapped to a common root, you can set them like: -Dspring.cloud.kubernetes.secrets.paths=/etc/secrets By setting a named secret: -Dspring.cloud.kubernetes.secrets.name=db-secret By defining a list of labels: -Dspring.cloud.kubernetes.secrets.labels.broker=activemq -Dspring.cloud.kubernetes.secrets.labels.db=postgresql As the case with ConfigMap , more advanced configuration is also possible where you can use multiple Secret instances. The spring.cloud.kubernetes.secrets.sources list makes this possible. For example, you could define the following Secret instances: spring: application: name: cloud-k8s-app cloud: kubernetes: secrets: name: default-name namespace: default-namespace sources: # Spring Cloud Kubernetes looks up a Secret named s1 in namespace default-namespace - name: s1 # Spring Cloud Kubernetes looks up a Secret named default-name in namespace n2 - namespace: n2 # Spring Cloud Kubernetes looks up a Secret named s3 in namespace n3 - namespace: n3 name: s3 In the preceding example, if spring.cloud.kubernetes.secrets.namespace had not been set, the Secret named s1 would be looked up in the namespace that the application runs. See namespace-resolution(namespace-resolution.html) to get a better understanding of how the namespace of the application is resolved. Similar to the ConfigMaps(configmap-propertysource.html#config-map-fail-fast) ; if you want your application to fail to start when it is unable to load Secrets property sources, you can set spring.cloud.kubernetes.secrets.fail-fast=true . It is also possible to enable retry for Secret property sources like the ConfigMaps(configmap-propertysource.html#config-map-retry) . As with the ConfigMap property sources, first you need to set spring.cloud.kubernetes.secrets.fail-fast=true . Then you need to add spring-retry and spring-boot-starter-aop to your classpath. Retry behavior of the Secret property sources can be configured by setting the spring.cloud.kubernetes.secrets.retry.* properties. If you already have spring-retry and spring-boot-starter-aop on the classpath for some reason and want to enable fail-fast, but do not want retry to be enabled; you can disable retry for Secrets PropertySources by setting spring.cloud.kubernetes.secrets.retry.enabled=false . Since data coming from Secrets is usually treated as sensitive, endpoints of the actuator /env and /configprops can be made to sanitize data, so that it is not displayed in plain text. In order to do that, you need to set: spring.cloud.kubernetes.sanitize.secrets=true This setting is supported since 3.0.6 and upwards. Table 1. Properties: Name Type Default Description spring.cloud.kubernetes.secrets.enabled Boolean true Enable Secrets PropertySource spring.cloud.kubernetes.secrets.name String ${spring.application.name} Sets the name of the secret to look up spring.cloud.kubernetes.secrets.namespace String Client namespace Sets the Kubernetes namespace where to look up spring.cloud.kubernetes.secrets.labels Map null Sets the labels used to lookup secrets spring.cloud.kubernetes.secrets.paths List null Sets the paths where secrets are mounted (example 1) spring.cloud.kubernetes.secrets.enableApi Boolean false Enables or disables consuming secrets through APIs (examples 2 and 3) spring.cloud.kubernetes.secrets.fail-fast Boolean false Enable or disable failing the application start-up when an error occurred while loading a Secret spring.cloud.kubernetes.secrets.retry.enabled Boolean true Enable or disable secrets retry. spring.cloud.kubernetes.secrets.retry.initial-interval Long 1000 Initial retry interval in milliseconds. spring.cloud.kubernetes.secrets.retry.max-attempts Integer 6 Maximum number of attempts. spring.cloud.kubernetes.secrets.retry.max-interval Long 2000 Maximum interval for backoff. spring.cloud.kubernetes.secrets.retry.multiplier Double 1.1 Multiplier for next interval. Notes: The spring.cloud.kubernetes.secrets.labels property behaves as defined by Map-based binding(https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Configuration-Binding#map-based-binding) . The spring.cloud.kubernetes.secrets.paths property behaves as defined by Collection-based binding(https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Configuration-Binding#collection-based-binding) . Access to secrets through the API may be restricted for security reasons. The preferred way is to mount secrets to the Pod. You can find an example of an application that uses secrets (though it has not been updated to use the new spring-cloud-kubernetes project) at spring-boot-camel-config(https://github.com/fabric8-quickstarts/spring-boot-camel-config)"
"https://docs.spring.io/spring-cloud-kubernetes/reference/property-source-config/namespace-resolution.html","Namespace resolution: Finding an application namespace happens on a best-effort basis. There are some steps that we iterate in order to find it. The easiest and most common one, is to specify it in the proper configuration, for example: spring: application: name: app cloud: kubernetes: secrets: name: secret namespace: default sources: # Spring Cloud Kubernetes looks up a Secret named 'a' in namespace 'default' - name: a # Spring Cloud Kubernetes looks up a Secret named 'secret' in namespace 'b' - namespace: b # Spring Cloud Kubernetes looks up a Secret named 'd' in namespace 'c' - namespace: c name: d Remember that the same can be done for config maps. If such a namespace is not specified, it will be read (in this order): from property spring.cloud.kubernetes.client.namespace from a String residing in a file denoted by spring.cloud.kubernetes.client.serviceAccountNamespacePath property from a String residing in /var/run/secrets/kubernetes.io/serviceaccount/namespace file (kubernetes default namespace path) from a designated client method call (for example fabric8’s : KubernetesClient::getNamespace ), if the client provides such a method. This, in turn, could be configured via environment properties. For example fabric8 client can be configured via ""KUBERNETES_NAMESPACE"" property; consult the client documentation for exact details. Failure to find a namespace from the above steps will result in an Exception being raised."
"https://docs.spring.io/spring-cloud-kubernetes/reference/property-source-config/order_of_configMaps_and_secrets.html","Order of ConfigMaps and Secrets: If, for whatever reason, you enabled both configmaps and secrets, and there is a common property between them, the value from the ConfigMap will have a higher precedence. That is: it will override whatever values are found in secrets."
"https://docs.spring.io/spring-cloud-kubernetes/reference/property-source-config/propertysource-reload.html","PropertySource Reload: This functionality has been deprecated in the 2020.0 release. Please see the null(../spring-cloud-kubernetes-configuration-watcher.html#spring-cloud-kubernetes-configuration-watcher) controller for an alternative way to achieve the same functionality. Some applications may need to detect changes on external property sources and update their internal status to reflect the new configuration. The reload feature of Spring Cloud Kubernetes is able to trigger an application reload when a related ConfigMap or Secret changes. By default, this feature is disabled. You can enable it by using the spring.cloud.kubernetes.reload.enabled=true configuration property (for example, in the application.properties file). Please notice that this will enable monitoring of configmaps only (i.e.: spring.cloud.kubernetes.reload.monitoring-config-maps will be set to true ). If you want to enable monitoring of secrets, this must be done explicitly via : spring.cloud.kubernetes.reload.monitoring-secrets=true . The following levels of reload are supported (by setting the spring.cloud.kubernetes.reload.strategy property): refresh (default): Only configuration beans annotated with @ConfigurationProperties or @RefreshScope are reloaded. This reload level leverages the refresh feature of Spring Cloud Context. restart_context : the whole Spring ApplicationContext is gracefully restarted. Beans are recreated with the new configuration. In order for the restart context functionality to work properly you must enable and expose the restart actuator endpoint management: endpoint: restart: enabled: true endpoints: web: exposure: include: restart shutdown : the Spring ApplicationContext is shut down to activate a restart of the container. When you use this level, make sure that the lifecycle of all non-daemon threads is bound to the ApplicationContext and that a replication controller or replica set is configured to restart the pod. Assuming that the reload feature is enabled with default settings ( refresh mode), the following bean is refreshed when the config map changes: @Configuration @ConfigurationProperties(prefix = ""bean"") public class MyConfig { private String message = ""a message that can be changed live""; // getter and setters } To see that changes effectively happen, you can create another bean that prints the message periodically, as follows @Component public class MyBean { @Autowired private MyConfig config; @Scheduled(fixedDelay = 5000) public void hello() { System.out.println(""The message is: "" + config.getMessage()); } } You can change the message printed by the application by using a ConfigMap , as follows: apiVersion: v1 kind: ConfigMap metadata: name: reload-example data: application.properties: |- bean.message=Hello World! Any change to the property named bean.message in the ConfigMap associated with the pod is reflected in the output. More generally speaking, changes associated to properties prefixed with the value defined by the prefix field of the @ConfigurationProperties annotation are detected and reflected in the application. Associating a ConfigMap with a pod(configmap-propertysource.html) is explained earlier in this chapter. The reload feature supports two operating modes: Event (default): Watches for changes in config maps or secrets by using the Kubernetes API (web socket). Any event produces a re-check on the configuration and, in case of changes, a reload. The view role on the service account is required in order to listen for config map changes. A higher level role (such as edit ) is required for secrets (by default, secrets are not monitored). Polling: Periodically re-creates the configuration from config maps and secrets to see if it has changed. You can configure the polling period by using the spring.cloud.kubernetes.reload.period property and defaults to 15 seconds. It requires the same role as the monitored property source. This means, for example, that using polling on file-mounted secret sources does not require particular privileges."
"https://docs.spring.io/spring-cloud-kubernetes/reference/property-source-config/namespace-label-filtering.html","Reload namespace and label filtering: By default, a namespace chosen using the steps outlined in Namespace resolution(namespace-resolution.html) will be used to listen to changes in configmaps and secrets. i.e.: if you do not tell reload what namespaces and configmaps/secrets to watch for, it will watch all configmaps/secrets from the namespace that will be computed using the above algorithm. On the other hand, you can define a more fine-grained approach. For example, you can specify the namespaces where changes will be monitored: spring: application: name: event-reload cloud: kubernetes: reload: enabled: true strategy: shutdown mode: event namespaces: - my-namespace Such a configuration will make the app watch changes only in the my-namespace namespace. Mind that this will watch all configmaps/secrets (depending on which one you enable). If you want an even more fine-grained approach, you can enable ""label-filtering"". First we need to enable such support via : enable-reload-filtering: true spring: application: name: event-reload cloud: kubernetes: reload: enabled: true strategy: shutdown mode: event namespaces: - my-namespaces monitoring-config-maps: true enable-reload-filtering: true What this will do, is watch configmaps/secrets that only have the spring.cloud.kubernetes.config.informer.enabled: true label. Table 1. Properties: Name Type Default Description spring.cloud.kubernetes.reload.enabled Boolean false Enables monitoring of property sources and configuration reload spring.cloud.kubernetes.reload.monitoring-config-maps Boolean true Allow monitoring changes in config maps spring.cloud.kubernetes.reload.monitoring-secrets Boolean false Allow monitoring changes in secrets spring.cloud.kubernetes.reload.strategy Enum refresh The strategy to use when firing a reload ( refresh , restart_context , or shutdown ) spring.cloud.kubernetes.reload.mode Enum event Specifies how to listen for changes in property sources ( event or polling ) spring.cloud.kubernetes.reload.period Duration 15s The period for verifying changes when using the polling strategy spring.cloud.kubernetes.reload.namespaces String[] namespaces where we should watch for changes spring.cloud.kubernetes.reload.enable-reload-filtering String enabled labeled filtering for reload functionality Notes: You should not use properties under spring.cloud.kubernetes.reload in config maps or secrets. Changing such properties at runtime may lead to unexpected results. Deleting a property or the whole config map does not restore the original state of the beans when you use the refresh level."
"https://docs.spring.io/spring-cloud-kubernetes/reference/kubernetes-awareness.html","Kubernetes Ecosystem Awareness: All features described earlier in this guide work equally well, regardless of whether your application is running inside Kubernetes. This is really helpful for development and troubleshooting. From a development point of view, this lets you start your Spring Boot application and debug one of the modules that is part of this project. You need not deploy it in Kubernetes, as the code of the project relies on the Fabric8 Kubernetes Java client(https://github.com/fabric8io/kubernetes-client) , which is a fluent DSL that can communicate by using http protocol to the REST API of the Kubernetes Server. Kubernetes awareness is based on Spring Boot API, specifically on ConditionalOnCloudPlatform(https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/condition/ConditionalOnCloudPlatform.html) . That property will auto-detect if your application is currently deployed in kubernetes or not. It is possible to override that setting via spring.main.cloud-platform . For example, if you need to test some features, but do not want to deploy to a cluster, it is enough to set the: spring.main.cloud-platform=KUBERNETES . This will make spring-cloud-kubernetes act as-if it is deployed in a real cluster. If you have spring-cloud-starter-bootstrap on your classpath or are setting spring.cloud.bootstrap.enabled=true then you will have to set spring.main.cloud-platform should be set in bootstrap.{properties|yml} (or the profile specific one). Also note that these properties: spring.cloud.kubernetes.config.enabled and spring.cloud.kubernetes.secrets.enabled will only take effect when set in bootstrap.{properties|yml} when you have spring-cloud-starter-bootstrap on your classpath or are setting spring.cloud.bootstrap.enabled=true . Breaking Changes In 3.0.x: In versions of Spring Cloud Kubernetes prior to 3.0.x , Kubernetes awareness was implemented using spring.cloud.kubernetes.enabled property. This property was removed and is un-supported. Instead, we use Spring Boot API: ConditionalOnCloudPlatform(https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/condition/ConditionalOnCloudPlatform.html) . If it is needed to explicitly enable or disable this awareness, use spring.main.cloud-platform=NONE/KUBERNETES . Another breaking change is the additional list verb needed for loading configmaps/secrets. For example: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: cluster-role rules: - apiGroups: ["""", ""extensions"", ""apps"", ""discovery.k8s.io""] resources: [""configmaps"", ""pods"", ""services"", ""endpoints"", ""secrets"", ""endpointslices""] verbs: [""get"", ""list"", ""watch""] Kubernetes Profile Autoconfiguration: When the application runs as a pod inside Kubernetes, a Spring profile named kubernetes automatically gets activated. This lets you customize the configuration, to define beans that are applied when the Spring Boot application is deployed within the Kubernetes platform (for example, different development and production configuration). Istio Awareness: When you include the spring-cloud-kubernetes-fabric8-istio module in the application classpath, a new profile is added to the application, provided the application is running inside a Kubernetes Cluster with Istio(https://istio.io) installed. You can then use spring @Profile(""istio"") annotations in your Beans and @Configuration classes. The Istio awareness module uses me.snowdrop:istio-client to interact with Istio APIs, letting us discover traffic rules, circuit breakers, and so on, making it easy for our Spring Boot applications to consume this data to dynamically configure themselves according to the environment."
"https://docs.spring.io/spring-cloud-kubernetes/reference/pod-health-indicator.html","Pod Health Indicator: Spring Boot uses HealthIndicator(https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthEndpoint.java) to expose info about the health of an application. That makes it really useful for exposing health-related information to the user and makes it a good fit for use as readiness probes(https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/) . The Kubernetes health indicator (which is part of the core module) exposes the following info: Pod name, IP address, namespace, service account, node name, and its IP address A flag that indicates whether the Spring Boot application is internal or external to Kubernetes You can disable this HealthContributor by setting management.health.kubernetes.enabled to false in application.[properties | yaml] ."
"https://docs.spring.io/spring-cloud-kubernetes/reference/info-contributor.html","Info Contributor: Spring Cloud Kubernetes includes an InfoContributor which adds Pod information to Spring Boot’s /info Actuator endpoint. You can disable this InfoContributor by setting management.info.kubernetes.enabled to false in application.[properties | yaml] ."
"https://docs.spring.io/spring-cloud-kubernetes/reference/leader-election.html","Leader Election: The Spring Cloud Kubernetes leader election mechanism implements the leader election API of Spring Integration using a Kubernetes ConfigMap. Multiple application instances compete for leadership, but leadership will only be granted to one. When granted leadership, a leader application receives an OnGrantedEvent application event with leadership Context . Applications periodically attempt to gain leadership, with leadership granted to the first caller. A leader will remain a leader until either it is removed from the cluster, or it yields its leadership. When leadership removal occurs, the previous leader receives OnRevokedEvent application event. After removal, any instances in the cluster may become the new leader, including the old leader. To include it in your project, add the following dependency. Fabric8 Leader Implementation <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-kubernetes-fabric8-leader</artifactId> </dependency> To specify the name of the configmap used for leader election use the following property. spring.cloud.kubernetes.leader.config-map-name=leader"
"https://docs.spring.io/spring-cloud-kubernetes/reference/load-balancer.html","LoadBalancer for Kubernetes: This project includes Spring Cloud Load Balancer for load balancing based on either Kubernetes Endpoints or Kubernetes Service. To include it to your project add the following dependency. Fabric8 Implementation <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-kubernetes-fabric8-loadbalancer</artifactId> </dependency> Kubernetes Java Client Implementation <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-kubernetes-client-loadbalancer</artifactId> </dependency> There are two ""modes"" in which load balancer works: POD and SERVICE , denoted by the property (default being POD ) spring.cloud.kubernetes.loadbalancer.mode=SERVICE or spring.cloud.kubernetes.loadbalancer.mode=POD In POD mode, we will use the DiscoveryClient to find all services that match your load balancer name. For example, if you have a configuration like this: @Bean @LoadBalanced WebClient.Builder client() { return WebClient.builder(); } and issue a request to service-a(http://service-a) using that WebClient , we will use service-a to call DiscoveryClient::getInstances with this value. Since this is using DiscoveryClient , all the configuration specific to it apply, which are explained in the relevant part of the documentation. On the other hand, if you use SERVICE mode, things are a bit different, but closely resemble discovery client settings. For example, to answer the question in which namespace(s) to look for service(s) with name service-a , we will use one of the settings: spring.cloud.kubernetes.discovery.all-namespaces spring.cloud.kubernetes.discovery.namespaces to either search in all-namespaces, or the so-called ""selective namespaces"". If none of the above are specified, Namespace Resolution(property-source-config.html#namespace-resolution) kicks in. Once we find all the services, we need to know what port to call them by. If the service in question has a single port defined, that is what we will use, no matter of its name. If there are no ports defined, this service will not be considered for load balancing and will be skipped. If there are more then one ports defined, we will try to match its name to the value of the property ( http by default): spring.cloud.kubernetes.loadbalancer.portName In case such a match is found, that port number will be used. Otherwise, the ""first"" port from the list will be used. This last option is non-deterministic and care must be taken. Once we know the port, we know how to call that service. The URL will have the form: service-a.<SERVICE_NAMESPACE>.svc.<DOMAIN>:<FOUND_PORT> <SERVICE_NAMESPACE> is the namespace where the service resides, DOMAIN is the value of the property (by default it is equal to cluster.local ): spring.cloud.kubernetes.loadbalancer.clusterDomain and <FOUND_PORT> is the port of the service that we have chosen described in the process above. If a service needs to be accessed over HTTPS, you need to explicitly configure that. The rules for that are exactly the same as for the discovery implementation and can be found in the relevant part of the documentation regarding discovery-client."
"https://docs.spring.io/spring-cloud-kubernetes/reference/security-service-accounts.html","Security Configurations Inside Kubernetes: Namespace: Most of the components provided in this project need to know the namespace. For Kubernetes (1.3+), the namespace is made available to the pod as part of the service account secret and is automatically detected by the client. For earlier versions, it needs to be specified as an environment variable to the pod. A quick way to do this is as follows: env: - name: ""KUBERNETES_NAMESPACE"" valueFrom: fieldRef: fieldPath: ""metadata.namespace"" Service Account: For distributions of Kubernetes that support more fine-grained role-based access within the cluster, you need to make sure a pod that runs with spring-cloud-kubernetes has access to the Kubernetes API. For any service accounts you assign to a deployment or pod, you need to make sure they have the correct roles. Depending on the requirements, you’ll need get , list and watch permission on the following resources: Table 1. Kubernetes Resource Permissions Dependency Resources spring-cloud-starter-kubernetes-fabric8 pods, services, endpoints spring-cloud-starter-kubernetes-fabric8-config configmaps, secrets spring-cloud-starter-kubernetes-client pods, services, endpoints spring-cloud-starter-kubernetes-client-config configmaps, secrets For development purposes, you can add cluster-reader permissions to your default service account. On a production system you’ll likely want to provide more granular permissions. The following Role and RoleBinding are an example for namespaced permissions for the default account: kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: namespace: YOUR-NAME-SPACE name: namespace-reader rules: - apiGroups: [""""] resources: [""configmaps"", ""pods"", ""services"", ""endpoints"", ""secrets""] verbs: [""get"", ""list"", ""watch""] --- kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: namespace-reader-binding namespace: YOUR-NAME-SPACE subjects: - kind: ServiceAccount name: default apiGroup: """" roleRef: kind: Role name: namespace-reader apiGroup: """""
"https://docs.spring.io/spring-cloud-kubernetes/reference/service-registry.html","Service Registry Implementation: In Kubernetes service registration is controlled by the platform, the application itself does not control registration as it may do in other platforms. For this reason using spring.cloud.service-registry.auto-registration.enabled or setting @EnableDiscoveryClient(autoRegister=false) will have no effect in Spring Cloud Kubernetes."
"https://docs.spring.io/spring-cloud-kubernetes/reference/spring-cloud-kubernetes-configuration-watcher.html","Spring Cloud Kubernetes Configuration Watcher: Kubernetes provides the ability to mount a ConfigMap or Secret as a volume(https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#add-configmap-data-to-a-volume) in the container of your application. When the contents of the ConfigMap or Secret changes, the mounted volume will be updated with those changes(https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#mounted-configmaps-are-updated-automatically) . However, Spring Boot will not automatically update those changes unless you restart the application. Spring Cloud provides the ability refresh the application context without restarting the application by either hitting the actuator endpoint /refresh or via publishing a RefreshRemoteApplicationEvent using Spring Cloud Bus. To achieve this configuration refresh of a Spring Cloud app running on Kubernetes, you can deploy the Spring Cloud Kubernetes Configuration Watcher controller into your Kubernetes cluster. The application is published as a container and is available on Docker Hub(https://hub.docker.com/r/springcloud/spring-cloud-kubernetes-configuration-watcher) . However, if you need to customize the config watcher behavior or prefer to build the image yourself you can easily build your own image from the source code on GitHub(https://github.com/spring-cloud/spring-cloud-kubernetes/tree/main/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configuration-watcher) and use that. Another option to configure it is to provide some environment variables in the deployment.yaml used to deploy configuration watcher. Here are some important ones: env: - name: LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_KUBERNETES_CONFIGURATION_WATCHER value: DEBUG - name: LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_KUBERNETES_CLIENT_CONFIG_RELOAD value: DEBUG - name: LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_KUBERNETES_COMMONS_CONFIG_RELOAD value: DEBUG These enable debug logging on the configuration watcher and are particular useful on the initial set-up, to be able to diagnose potential miss-configurations. env: - name: SPRING_CLOUD_KUBERNETES_RELOAD_NAMESPACES_0 value: ""namespace-a"" This one lets watcher know where to search for secrets and configmaps. You have two options here: selective namespaces (the setting above) and a namespace chosen by Namespace Resolution(property-source-config.html#namespace-resolution) (this is the default option). Keep in mind that all these options require proper RBAC rules. Changes from configmaps/secrets will only trigger an event being fired from configuration watcher if that particular change came from a source that has a label: spring.cloud.kubernetes.config=true or spring.cloud.kubernetes.secret=true . To put it simpler, if you change a configmap (or secret), that does not have the label above, configuration watcher will skip firing an event for it (if you enabled debug logging, this will be visible in logs). By default, configuration watcher will monitor all configmaps/secrets in the configured namespace(s). If you want to filter to watch only particular sources, you can do that by setting: SPRING_CLOUD_KUBERNETES_CONFIG_INFORMER_ENABLED=TRUE This will tell watcher to only monitor sources that have a label: spring.cloud.kubernetes.config.informer.enabled=true . One more important configuration, especially for configmaps and secrets that are mounted as volumes (via spring.cloud.kubernetes.config.paths / spring.cloud.kubernetes.secrets.paths or using spring.config.import ) is: - name: SPRING_CLOUD_KUBERNETES_CONFIGURATION_WATCHER_REFRESHDELAY value: ""10000"" This tells how many milliseconds should we wait before firing the event from configuration watcher. This is important because kubernetes documentation says: When a ConfigMap currently consumed in a volume is updated, projected keys are eventually updated as well. You need to ""match"" this eventually part to that value in milliseconds on your cluster. Spring Cloud Kubernetes Configuration Watcher can send refresh notifications to applications in two ways. Over HTTP, in which case the application being notified, must have the /refresh actuator endpoint exposed and accessible from within the cluster Using Spring Cloud Bus, in which case you will need a message broker deployed to your custer for the application to use. Deployment YAML: Below is a sample deployment YAML you can use to deploy the Kubernetes Configuration Watcher to Kubernetes. --- apiVersion: v1 kind: List items: - apiVersion: v1 kind: Service metadata: labels: app: spring-cloud-kubernetes-configuration-watcher name: spring-cloud-kubernetes-configuration-watcher spec: ports: - name: http port: 8888 targetPort: 8888 selector: app: spring-cloud-kubernetes-configuration-watcher type: ClusterIP - apiVersion: v1 kind: ServiceAccount metadata: labels: app: spring-cloud-kubernetes-configuration-watcher name: spring-cloud-kubernetes-configuration-watcher - apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: labels: app: spring-cloud-kubernetes-configuration-watcher name: spring-cloud-kubernetes-configuration-watcher:view roleRef: kind: Role apiGroup: rbac.authorization.k8s.io name: namespace-reader subjects: - kind: ServiceAccount name: spring-cloud-kubernetes-configuration-watcher - apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: namespace-reader rules: - apiGroups: ["""", ""extensions"", ""apps""] resources: [""configmaps"", ""pods"", ""services"", ""endpoints"", ""secrets""] verbs: [""get"", ""list"", ""watch""] - apiVersion: apps/v1 kind: Deployment metadata: name: spring-cloud-kubernetes-configuration-watcher-deployment spec: selector: matchLabels: app: spring-cloud-kubernetes-configuration-watcher template: metadata: labels: app: spring-cloud-kubernetes-configuration-watcher spec: serviceAccount: spring-cloud-kubernetes-configuration-watcher containers: - name: spring-cloud-kubernetes-configuration-watcher image: springcloud/spring-cloud-kubernetes-configuration-watcher:3.1.3 imagePullPolicy: IfNotPresent readinessProbe: httpGet: port: 8888 path: /actuator/health/readiness livenessProbe: httpGet: port: 8888 path: /actuator/health/liveness ports: - containerPort: 8888 The Service Account and associated Role Binding is important for Spring Cloud Kubernetes Configuration to work properly. The controller needs access to read data about ConfigMaps, Pods, Services, Endpoints and Secrets in the Kubernetes cluster. Monitoring ConfigMaps and Secrets: If a change is made to a ConfigMap or Secret with valid labels (as detailed above), then Spring Cloud Kubernetes Configuration Watcher will take the name of the ConfigMap or Secret and send a notification to the application with that name. This might not be enough for your use-case though, you could for example want to: bind a config-map to multiple applications, so that a change inside a single configmap triggers a refresh for many services have profile based sources trigger events for your application For that reasons there is an addition annotation you could specify: spring.cloud.kubernetes.configmap.apps or spring.cloud.kubernetes.secret.apps . It takes a String of apps separated by comma, that specifies the names of applications that will receive a notification when changes happen in this secret/configmap. For example: kind: ConfigMap apiVersion: v1 metadata: name: example-configmap labels: spring.cloud.kubernetes.config: ""true"" annotations: spring.cloud.kubernetes.configmap.apps: ""app-a, app-b"" HTTP Implementation: The HTTP implementation is what is used by default. When this implementation is used, Spring Cloud Kubernetes Configuration Watcher and a change to a ConfigMap or Secret occurs then the HTTP implementation will use the Spring Cloud Kubernetes Discovery Client to fetch all instances of the application which match the name of the ConfigMap or Secret and send an HTTP POST request to the application’s actuator /refresh endpoint. By default, it will send the post request to /actuator/refresh using the port registered in the discovery client. Non-Default Management Port and Actuator Path: If the application is using a non-default actuator path and/or using a different port for the management endpoints, the Kubernetes service for the application can add an annotation called boot.spring.io/actuator and set its value to the path and port used by the application. For example apiVersion: v1 kind: Service metadata: labels: app: config-map-demo name: config-map-demo annotations: boot.spring.io/actuator: http://:9090/myactuator/home spec: ports: - name: http port: 8080 targetPort: 8080 selector: app: config-map-demo Another way you can choose to configure the actuator path and/or management port is by setting spring.cloud.kubernetes.configuration.watcher.actuatorPath and spring.cloud.kubernetes.configuration.watcher.actuatorPort . Messaging Implementation: The messaging implementation can be enabled by setting profile to either bus-amqp (RabbitMQ) or bus-kafka (Kafka) when the Spring Cloud Kubernetes Configuration Watcher application is deployed to Kubernetes. Configuring RabbitMQ: When the bus-amqp profile is enabled you will need to configure Spring RabbitMQ to point it to the location of the RabbitMQ instance you would like to use as well as any credentials necessary to authenticate. This can be done by setting the standard Spring RabbitMQ properties, for example spring: rabbitmq: username: user password: password host: rabbitmq Configuring Kafka: When the bus-kafka profile is enabled you will need to configure Spring Kafka to point it to the location of the Kafka Broker instance you would like to use. This can be done by setting the standard Spring Kafka properties, for example spring: kafka: producer: bootstrap-servers: localhost:9092"
"https://docs.spring.io/spring-cloud-kubernetes/reference/spring-cloud-kubernetes-configserver.html","Spring Cloud Kubernetes Config Server: The Spring Cloud Kubernetes Config Server, is based on Spring Cloud Config Server(https://spring.io/projects/spring-cloud-config) and adds an environment repository(https://docs.spring.io/spring-cloud-config/docs/current/reference/html/#_environment_repository) for Kubernetes Config Maps(https://kubernetes.io/docs/concepts/configuration/configmap/) and Secrets(https://kubernetes.io/docs/concepts/configuration/secret/) . This is component is completely optional. However, it allows you to continue to leverage configuration you may have stored in existing environment repositories (Git, SVN, Vault, etc) with applications that you are running on Kubernetes. A default image is located on Docker Hub(https://hub.docker.com/r/springcloud/spring-cloud-kubernetes-configserver) which will allow you to easily get a Config Server deployed on Kubernetes without building the code and image yourself. However, if you need to customize the config server behavior or prefer to build the image yourself you can easily build your own image from the source code on GitHub(https://github.com/spring-cloud/spring-cloud-kubernetes/tree/main/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-configserver) and use that. Configuration: Enabling The Kubernetes Environment Repository: To enable the Kubernetes environment repository the kubernetes profile must be included in the list of active profiles. You may activate other profiles as well to use other environment repository implementations. Config Map and Secret PropertySources: By default, only Config Map data will be fetched. To enable Secrets as well you will need to set spring.cloud.kubernetes.secrets.enableApi=true . You can disable the Config Map PropertySource by setting spring.cloud.kubernetes.config.enableApi=false . Fetching Config Map and Secret Data From Additional Namespaces: By default, the Kubernetes environment repository will only fetch Config Map and Secrets from the namespace in which it is deployed. If you want to include data from other namespaces you can set spring.cloud.kubernetes.configserver.config-map-namespaces and/or spring.cloud.kubernetes.configserver.secrets-namespaces to a comma separated list of namespace values. If you set spring.cloud.kubernetes.configserver.config-map-namespaces and/or spring.cloud.kubernetes.configserver.secrets-namespaces you will need to include the namespace in which the Config Server is deployed in order to continue to fetch Config Map and Secret data from that namespace. Kubernetes Access Controls: The Kubernetes Config Server uses the Kubernetes API server to fetch Config Map and Secret data. In order for it to do that it needs ability to get and list Config Map and Secrets (depending on what you enable/disable). Deployment Yaml: Below is a sample deployment, service and permissions configuration you can use to deploy a basic Config Server to Kubernetes. --- apiVersion: v1 kind: List items: - apiVersion: v1 kind: Service metadata: labels: app: spring-cloud-kubernetes-configserver name: spring-cloud-kubernetes-configserver spec: ports: - name: http port: 8888 targetPort: 8888 selector: app: spring-cloud-kubernetes-configserver type: ClusterIP - apiVersion: v1 kind: ServiceAccount metadata: labels: app: spring-cloud-kubernetes-configserver name: spring-cloud-kubernetes-configserver - apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: labels: app: spring-cloud-kubernetes-configserver name: spring-cloud-kubernetes-configserver:view roleRef: kind: Role apiGroup: rbac.authorization.k8s.io name: namespace-reader subjects: - kind: ServiceAccount name: spring-cloud-kubernetes-configserver - apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: namespace-reader rules: - apiGroups: ["""", ""extensions"", ""apps""] resources: [""configmaps"", ""secrets""] verbs: [""get"", ""list""] - apiVersion: apps/v1 kind: Deployment metadata: name: spring-cloud-kubernetes-configserver-deployment spec: selector: matchLabels: app: spring-cloud-kubernetes-configserver template: metadata: labels: app: spring-cloud-kubernetes-configserver spec: serviceAccount: spring-cloud-kubernetes-configserver containers: - name: spring-cloud-kubernetes-configserver image: springcloud/spring-cloud-kubernetes-configserver imagePullPolicy: IfNotPresent env: - name: SPRING_PROFILES_INCLUDE value: ""kubernetes"" readinessProbe: httpGet: port: 8888 path: /actuator/health/readiness livenessProbe: httpGet: port: 8888 path: /actuator/health/liveness ports: - containerPort: 8888"
"https://docs.spring.io/spring-cloud-kubernetes/reference/spring-cloud-kubernetes-discoveryserver.html","Spring Cloud Kubernetes Discovery Server: The Spring Cloud Kubernetes Discovery Server provides HTTP endpoints apps can use to gather information about services available within a Kubernetes cluster. The Spring Cloud Kubernetes Discovery Server can be used by apps using the spring-cloud-starter-kubernetes-discoveryclient to provide data to the DiscoveryClient implementation provided by that starter. Permissions: The Spring Cloud Discovery server uses the Kubernetes API server to get data about Pod, Service and Endpoint resources, so it needs list, watch, and get permissions to use those endpoints. See the below sample Kubernetes deployment YAML for an example of how to configure the Service Account on Kubernetes. Endpoints: There are three endpoints exposed by the server. /apps: A GET request sent to /apps will return a JSON array of available services. Each item contains the name of the Kubernetes service and service instance information. Below is a sample response. [ { ""name"":""spring-cloud-kubernetes-discoveryserver"", ""serviceInstances"":[ { ""instanceId"":""836a2f25-daee-4af2-a1be-aab9ce2b938f"", ""serviceId"":""spring-cloud-kubernetes-discoveryserver"", ""host"":""10.244.1.6"", ""port"":8761, ""uri"":""http://10.244.1.6:8761"", ""secure"":false, ""metadata"":{ ""app"":""spring-cloud-kubernetes-discoveryserver"", ""kubectl.kubernetes.io/last-applied-configuration"":""{\""apiVersion\"":\""v1\"",\""kind\"":\""Service\"",\""metadata\"":{\""annotations\"":{},\""labels\"":{\""app\"":\""spring-cloud-kubernetes-discoveryserver\""},\""name\"":\""spring-cloud-kubernetes-discoveryserver\"",\""namespace\"":\""default\""},\""spec\"":{\""ports\"":[{\""name\"":\""http\"",\""port\"":80,\""targetPort\"":8761}],\""selector\"":{\""app\"":\""spring-cloud-kubernetes-discoveryserver\""},\""type\"":\""ClusterIP\""}}\n"", ""http"":""8761"" }, ""namespace"":""default"", ""scheme"":""http"" } ] }, { ""name"":""kubernetes"", ""serviceInstances"":[ { ""instanceId"":""1234"", ""serviceId"":""kubernetes"", ""host"":""172.18.0.3"", ""port"":6443, ""uri"":""http://172.18.0.3:6443"", ""secure"":false, ""metadata"":{ ""provider"":""kubernetes"", ""component"":""apiserver"", ""https"":""6443"" }, ""namespace"":""default"", ""scheme"":""http"" } ] } ] /apps/{name}: A GET request to /apps/{name} can be used to get instance data for all instances of a given service. Below is a sample response when a GET request is made to /apps/kubernetes . [ { ""instanceId"":""1234"", ""serviceId"":""kubernetes"", ""host"":""172.18.0.3"", ""port"":6443, ""uri"":""http://172.18.0.3:6443"", ""secure"":false, ""metadata"":{ ""provider"":""kubernetes"", ""component"":""apiserver"", ""https"":""6443"" }, ""namespace"":""default"", ""scheme"":""http"" } ] /app/{name}/{instanceid}: A GET request made to /app/{name}/{instanceid} will return the instance data for a specific instance of a given service. Below is a sample response when a GET request is made to /app/kubernetes/1234 . { ""instanceId"":""1234"", ""serviceId"":""kubernetes"", ""host"":""172.18.0.3"", ""port"":6443, ""uri"":""http://172.18.0.3:6443"", ""secure"":false, ""metadata"":{ ""provider"":""kubernetes"", ""component"":""apiserver"", ""https"":""6443"" }, ""namespace"":""default"", ""scheme"":""http"" } Deployment YAML: An image of the Spring Cloud Discovery Server is hosted on Docker Hub(https://hub.docker.com/r/springcloud/spring-cloud-kubernetes-discoveryserver) . However, if you need to customize the discovery server behavior or prefer to build the image yourself you can easily build your own image from the source code on GitHub(https://github.com/spring-cloud/spring-cloud-kubernetes/tree/main/spring-cloud-kubernetes-controllers/spring-cloud-kubernetes-discoveryserver) and use that. Below is a sample deployment YAML you can use to deploy the Kubernetes Discovery Server to Kubernetes. --- apiVersion: v1 kind: List items: - apiVersion: v1 kind: Service metadata: labels: app: spring-cloud-kubernetes-discoveryserver name: spring-cloud-kubernetes-discoveryserver spec: ports: - name: http port: 80 targetPort: 8761 selector: app: spring-cloud-kubernetes-discoveryserver type: ClusterIP - apiVersion: v1 kind: ServiceAccount metadata: labels: app: spring-cloud-kubernetes-discoveryserver name: spring-cloud-kubernetes-discoveryserver - apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: labels: app: spring-cloud-kubernetes-discoveryserver name: spring-cloud-kubernetes-discoveryserver:view roleRef: kind: Role apiGroup: rbac.authorization.k8s.io name: namespace-reader subjects: - kind: ServiceAccount name: spring-cloud-kubernetes-discoveryserver - apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: namespace-reader rules: - apiGroups: ["""", ""extensions"", ""apps""] resources: [""pods"", ""services"", ""endpoints""] verbs: [""get"", ""list"", ""watch""] - apiVersion: apps/v1 kind: Deployment metadata: name: spring-cloud-kubernetes-discoveryserver-deployment spec: selector: matchLabels: app: spring-cloud-kubernetes-discoveryserver template: metadata: labels: app: spring-cloud-kubernetes-discoveryserver spec: serviceAccountName: spring-cloud-kubernetes-discoveryserver containers: - name: spring-cloud-kubernetes-discoveryserver image: springcloud/spring-cloud-kubernetes-discoveryserver:3.1.0 imagePullPolicy: IfNotPresent readinessProbe: httpGet: port: 8761 path: /actuator/health/readiness livenessProbe: httpGet: port: 8761 path: /actuator/health/liveness ports: - containerPort: 8761"
"https://docs.spring.io/spring-cloud-kubernetes/reference/examples.html","Examples: Spring Cloud Kubernetes tries to make it transparent for your applications to consume Kubernetes Native Services by following the Spring Cloud interfaces. In your applications, you need to add the spring-cloud-kubernetes-discovery dependency to your classpath and remove any other dependency that contains a DiscoveryClient implementation (that is, a Eureka discovery client). The same applies for PropertySourceLocator , where you need to add to the classpath the spring-cloud-kubernetes-config and remove any other dependency that contains a PropertySourceLocator implementation (that is, a configuration server client). The following projects highlight the usage of these dependencies and demonstrate how you can use these libraries from any Spring Boot application: Spring Cloud Kubernetes Examples(https://github.com/spring-cloud/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-examples) : the ones located inside this repository. Spring Cloud Kubernetes Full Example: Minions and Boss Minion(https://github.com/salaboy/spring-cloud-k8s-minion) Boss(https://github.com/salaboy/spring-cloud-k8s-boss) Spring Cloud Kubernetes Full Example: SpringOne Platform Tickets Service(https://github.com/salaboy/s1p_docs) Spring Cloud Gateway with Spring Cloud Kubernetes Discovery and Config(https://github.com/salaboy/s1p_gateway) Spring Boot Admin with Spring Cloud Kubernetes Discovery and Config(https://github.com/salaboy/showcase-admin-tool)"
"https://docs.spring.io/spring-cloud-kubernetes/reference/other-resources.html","Other Resources: This section lists other resources, such as presentations (slides) and videos about Spring Cloud Kubernetes. S1P Spring Cloud on PKS(https://salaboy.com/2018/09/27/the-s1p-experience/) Spring Cloud, Docker, Kubernetes → London Java Community July 2018(https://salaboy.com/2018/07/18/ljc-july-18-spring-cloud-docker-k8s/) Please feel free to submit other resources through pull requests to this repository(https://github.com/spring-cloud/spring-cloud-kubernetes) ."
"https://docs.spring.io/spring-cloud-kubernetes/reference/appendix.html","Common application properties: Various properties can be specified inside your application.properties file, inside your application.yml file, or as command line switches. This appendix provides a list of common Spring Cloud Kubernetes properties and references to the underlying classes that consume them. Property contributions can come from additional jar files on your classpath, so you should not consider this an exhaustive list. Also, you can define your own properties. Name Default Description spring.cloud.kubernetes.client.api-version spring.cloud.kubernetes.client.apiVersion v1 Kubernetes API Version spring.cloud.kubernetes.client.ca-cert-data spring.cloud.kubernetes.client.ca-cert-file spring.cloud.kubernetes.client.caCertData Kubernetes API CACertData spring.cloud.kubernetes.client.caCertFile Kubernetes API CACertFile spring.cloud.kubernetes.client.client-cert-data spring.cloud.kubernetes.client.client-cert-file spring.cloud.kubernetes.client.client-key-algo spring.cloud.kubernetes.client.client-key-data spring.cloud.kubernetes.client.client-key-file spring.cloud.kubernetes.client.client-key-passphrase spring.cloud.kubernetes.client.clientCertData Kubernetes API ClientCertData spring.cloud.kubernetes.client.clientCertFile Kubernetes API ClientCertFile spring.cloud.kubernetes.client.clientKeyAlgo RSA Kubernetes API ClientKeyAlgo spring.cloud.kubernetes.client.clientKeyData Kubernetes API ClientKeyData spring.cloud.kubernetes.client.clientKeyFile Kubernetes API ClientKeyFile spring.cloud.kubernetes.client.clientKeyPassphrase changeit Kubernetes API ClientKeyPassphrase spring.cloud.kubernetes.client.connection-timeout spring.cloud.kubernetes.client.connectionTimeout 10s Connection timeout spring.cloud.kubernetes.client.http-proxy spring.cloud.kubernetes.client.https-proxy spring.cloud.kubernetes.client.logging-interval spring.cloud.kubernetes.client.loggingInterval 20s Logging interval spring.cloud.kubernetes.client.master-url spring.cloud.kubernetes.client.masterUrl https://kubernetes.default.svc Kubernetes API Master Node URL spring.cloud.kubernetes.client.namespace true Kubernetes Namespace spring.cloud.kubernetes.client.no-proxy spring.cloud.kubernetes.client.oauth-token spring.cloud.kubernetes.client.oauthToken Kubernetes API Oauth Token spring.cloud.kubernetes.client.password Kubernetes API Password spring.cloud.kubernetes.client.proxy-password spring.cloud.kubernetes.client.proxy-username spring.cloud.kubernetes.client.request-timeout spring.cloud.kubernetes.client.requestTimeout 10s Request timeout spring.cloud.kubernetes.client.rolling-timeout spring.cloud.kubernetes.client.rollingTimeout 900s Rolling timeout spring.cloud.kubernetes.client.service-account-namespace-path /var/run/secrets/kubernetes.io/serviceaccount/namespace spring.cloud.kubernetes.client.trust-certs spring.cloud.kubernetes.client.trustCerts false Kubernetes API Trust Certificates spring.cloud.kubernetes.client.user-agent Spring-Cloud-Kubernetes-Application spring.cloud.kubernetes.client.username Kubernetes API Username spring.cloud.kubernetes.client.watch-reconnect-interval spring.cloud.kubernetes.client.watch-reconnect-limit spring.cloud.kubernetes.client.watchReconnectInterval 1s Reconnect Interval spring.cloud.kubernetes.client.watchReconnectLimit -1 Reconnect Interval limit retries spring.cloud.kubernetes.config.enable-api true spring.cloud.kubernetes.config.enabled true Enable the ConfigMap property source locator. spring.cloud.kubernetes.config.fail-fast false spring.cloud.kubernetes.config.include-profile-specific-sources true spring.cloud.kubernetes.config.labels spring.cloud.kubernetes.config.name spring.cloud.kubernetes.config.namespace spring.cloud.kubernetes.config.paths spring.cloud.kubernetes.config.retry spring.cloud.kubernetes.config.sources spring.cloud.kubernetes.config.use-name-as-prefix false spring.cloud.kubernetes.discovery.all-namespaces false spring.cloud.kubernetes.discovery.cache-loading-timeout-seconds 60 spring.cloud.kubernetes.discovery.discovery-server-url spring.cloud.kubernetes.discovery.enabled true spring.cloud.kubernetes.discovery.filter spring.cloud.kubernetes.discovery.include-external-name-services false spring.cloud.kubernetes.discovery.include-not-ready-addresses false spring.cloud.kubernetes.discovery.known-secure-ports [443, 8443] spring.cloud.kubernetes.discovery.metadata.add-annotations true spring.cloud.kubernetes.discovery.metadata.add-labels true spring.cloud.kubernetes.discovery.metadata.add-pod-annotations false spring.cloud.kubernetes.discovery.metadata.add-pod-labels false spring.cloud.kubernetes.discovery.metadata.add-ports true spring.cloud.kubernetes.discovery.metadata.annotations-prefix spring.cloud.kubernetes.discovery.metadata.labels-prefix spring.cloud.kubernetes.discovery.metadata.ports-prefix port. spring.cloud.kubernetes.discovery.namespaces spring.cloud.kubernetes.discovery.order 0 spring.cloud.kubernetes.discovery.primary-port-name spring.cloud.kubernetes.discovery.service-labels spring.cloud.kubernetes.discovery.use-endpoint-slices false spring.cloud.kubernetes.discovery.wait-cache-ready true spring.cloud.kubernetes.leader.auto-startup true Should leader election be started automatically on startup. Default: true spring.cloud.kubernetes.leader.config-map-name leaders Kubernetes ConfigMap where leaders information will be stored. Default: leaders spring.cloud.kubernetes.leader.create-config-map true Enable/disable creating ConfigMap if it does not exist. Default: true spring.cloud.kubernetes.leader.enabled true Should leader election be enabled. Default: true spring.cloud.kubernetes.leader.leader-id-prefix leader.id. Leader id property prefix for the ConfigMap. Default: leader.id. spring.cloud.kubernetes.leader.namespace Kubernetes namespace where the leaders ConfigMap and candidates are located. spring.cloud.kubernetes.leader.publish-failed-events false Enable/disable publishing events in case leadership acquisition fails. Default: false spring.cloud.kubernetes.leader.role Role for which leadership this candidate will compete. spring.cloud.kubernetes.leader.update-period 60000ms Leadership status check period. Default: 60s spring.cloud.kubernetes.loadbalancer.cluster-domain cluster.local cluster domain. spring.cloud.kubernetes.loadbalancer.enabled true Load balancer enabled,default true. spring.cloud.kubernetes.loadbalancer.mode {@link KubernetesLoadBalancerMode} setting load balancer server list with ip of pod or service name. default value is POD. spring.cloud.kubernetes.loadbalancer.port-name http service port name. spring.cloud.kubernetes.reload.enable-reload-filtering false spring.cloud.kubernetes.reload.enabled false spring.cloud.kubernetes.reload.max-wait-for-restart 2s spring.cloud.kubernetes.reload.mode EVENT spring.cloud.kubernetes.reload.monitoring-config-maps true spring.cloud.kubernetes.reload.monitoring-secrets false spring.cloud.kubernetes.reload.namespaces spring.cloud.kubernetes.reload.period 15000ms spring.cloud.kubernetes.reload.strategy REFRESH spring.cloud.kubernetes.secrets.enable-api false spring.cloud.kubernetes.secrets.enabled true Enable the Secrets property source locator. spring.cloud.kubernetes.secrets.fail-fast false spring.cloud.kubernetes.secrets.include-profile-specific-sources true spring.cloud.kubernetes.secrets.labels spring.cloud.kubernetes.secrets.name spring.cloud.kubernetes.secrets.namespace spring.cloud.kubernetes.secrets.paths spring.cloud.kubernetes.secrets.retry spring.cloud.kubernetes.secrets.sources spring.cloud.kubernetes.secrets.use-name-as-prefix false"
