"url","content"
"https://docs.spring.io/spring-cloud-gateway/reference/index.html","Spring Cloud Gateway: This project provides an API Gateway built on top of the Spring Ecosystem, including: Spring 6, Spring Boot 3 and Project Reactor. Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring/metrics, and resiliency. There are two distinct flavors of Spring Cloud Gateway: Server and Proxy Exchange . Each flavor offers WebFlux and MVC compatibility. The Server variant is a full-featured API gateway that can be standalone or embedded in a Spring Boot application. The Proxy Exchange variant is exclusively for use in annotation based WebFlux or MVC applications and allows the use of a special ProxyExchange object as a parameter to a web handler method."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway.html","Spring Cloud Gateway Reactive Server: 4.1.5"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/starter.html","How to Include Spring Cloud Gateway: To include Spring Cloud Gateway in your project, use the starter with a group ID of org.springframework.cloud and an artifact ID of spring-cloud-starter-gateway . See the Spring Cloud Project page(https://projects.spring.io/spring-cloud/) for details on setting up your build system with the current Spring Cloud Release Train. If you include the starter, but you do not want the gateway to be enabled, set spring.cloud.gateway.enabled=false . Spring Cloud Gateway is built on Spring Boot(https://spring.io/projects/spring-boot#learn) , Spring WebFlux(https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html) , and Project Reactor(https://projectreactor.io/docs) . As a consequence, many of the familiar synchronous libraries (Spring Data and Spring Security, for example) and patterns you know may not apply when you use Spring Cloud Gateway. If you are unfamiliar with these projects, we suggest you begin by reading their documentation to familiarize yourself with some new concepts before working with Spring Cloud Gateway. Spring Cloud Gateway requires the Netty runtime provided by Spring Boot and Spring Webflux. It does not work in a traditional Servlet Container or when built as a WAR."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/glossary.html","Glossary: Route : The basic building block of the gateway. It is defined by an ID, a destination URI, a collection of predicates, and a collection of filters. A route is matched if the aggregate predicate is true. Predicate : This is a Java 8 Function Predicate(https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html) . The input type is a Spring Framework ServerWebExchange(https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/ServerWebExchange.html) . This lets you match on anything from the HTTP request, such as headers or parameters. Filter : These are instances of GatewayFilter(https://github.com/spring-cloud/spring-cloud-gateway/blob/main/spring-cloud-gateway-server/src/main/java/org/springframework/cloud/gateway/filter/GatewayFilter.java) that have been constructed with a specific factory. Here, you can modify requests and responses before or after sending the downstream request."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/how-it-works.html","How It Works: The following diagram provides a high-level overview of how Spring Cloud Gateway works: Clients make requests to Spring Cloud Gateway. If the Gateway Handler Mapping determines that a request matches a route, it is sent to the Gateway Web Handler. This handler runs the request through a filter chain that is specific to the request. The reason the filters are divided by the dotted line is that filters can run logic both before and after the proxy request is sent. All “pre” filter logic is executed. Then the proxy request is made. After the proxy request is made, the “post” filter logic is run. URIs defined in routes without a port get default port values of 80 and 443 for the HTTP and HTTPS URIs, respectively. Any path defined on a route URI will be ignored."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/configuring-route-predicate-factories-and-filter-factories.html","Configuring Route Predicate Factories and Gateway Filter Factories: There are two ways to configure predicates and filters: shortcuts and fully expanded arguments. Most examples below use the shortcut way. The name and argument names are listed as code in the first sentence or two of each section. The arguments are typically listed in the order that are needed for the shortcut configuration. Shortcut Configuration: Shortcut configuration is recognized by the filter name, followed by an equals sign ( = ), followed by argument values separated by commas ( , ). application.yml spring: cloud: gateway: routes: - id: after_route uri: https://example.org predicates: - Cookie=mycookie,mycookievalue The previous sample defines the Cookie Route Predicate Factory with two arguments, the cookie name, mycookie and the value to match mycookievalue . Fully Expanded Arguments: Fully expanded arguments appear more like standard yaml configuration with name/value pairs. Typically, there will be a name key and an args key. The args key is a map of key value pairs to configure the predicate or filter. application.yml spring: cloud: gateway: routes: - id: after_route uri: https://example.org predicates: - name: Cookie args: name: mycookie regexp: mycookievalue This is the full configuration of the shortcut configuration of the Cookie predicate shown above."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/request-predicates-factories.html","Route Predicate Factories: Spring Cloud Gateway matches routes as part of the Spring WebFlux HandlerMapping infrastructure. Spring Cloud Gateway includes many built-in route predicate factories. All of these predicates match on different attributes of the HTTP request. You can combine multiple route predicate factories with logical and statements. The After Route Predicate Factory: The After route predicate factory takes one parameter, a datetime (which is a java ZonedDateTime ). This predicate matches requests that happen after the specified datetime. The following example configures an after route predicate: application.yml spring: cloud: gateway: routes: - id: after_route uri: https://example.org predicates: - After=2017-01-20T17:42:47.789-07:00[America/Denver] This route matches any request made after Jan 20, 2017 17:42 Mountain Time (Denver). The Before Route Predicate Factory: The Before route predicate factory takes one parameter, a datetime (which is a java ZonedDateTime ). This predicate matches requests that happen before the specified datetime . The following example configures a before route predicate: application.yml spring: cloud: gateway: routes: - id: before_route uri: https://example.org predicates: - Before=2017-01-20T17:42:47.789-07:00[America/Denver] This route matches any request made before Jan 20, 2017 17:42 Mountain Time (Denver). The Between Route Predicate Factory: The Between route predicate factory takes two parameters, datetime1 and datetime2 which are java ZonedDateTime objects. This predicate matches requests that happen after datetime1 and before datetime2 . The datetime2 parameter must be after datetime1 . The following example configures a between route predicate: application.yml spring: cloud: gateway: routes: - id: between_route uri: https://example.org predicates: - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver] This route matches any request made after Jan 20, 2017 17:42 Mountain Time (Denver) and before Jan 21, 2017 17:42 Mountain Time (Denver). This could be useful for maintenance windows. The Cookie Route Predicate Factory: The Cookie route predicate factory takes two parameters, the cookie name and a regexp (which is a Java regular expression). This predicate matches cookies that have the given name and whose values match the regular expression. The following example configures a cookie route predicate factory: application.yml spring: cloud: gateway: routes: - id: cookie_route uri: https://example.org predicates: - Cookie=chocolate, ch.p This route matches requests that have a cookie named chocolate whose value matches the ch.p regular expression. The Header Route Predicate Factory: The Header route predicate factory takes two parameters, the header and a regexp (which is a Java regular expression). This predicate matches with a header that has the given name whose value matches the regular expression. The following example configures a header route predicate: application.yml spring: cloud: gateway: routes: - id: header_route uri: https://example.org predicates: - Header=X-Request-Id, \d+ This route matches if the request has a header named X-Request-Id whose value matches the \d+ regular expression (that is, it has a value of one or more digits). The Host Route Predicate Factory: The Host route predicate factory takes one parameter: a list of host name patterns . The pattern is an Ant-style pattern with . as the separator. This predicates matches the Host header that matches the pattern. The following example configures a host route predicate: application.yml spring: cloud: gateway: routes: - id: host_route uri: https://example.org predicates: - Host=**.somehost.org,**.anotherhost.org URI template variables (such as {sub}.myhost.org ) are supported as well. This route matches if the request has a Host header with a value of www.somehost.org or beta.somehost.org or www.anotherhost.org . This predicate extracts the URI template variables (such as sub , defined in the preceding example) as a map of names and values and places it in the ServerWebExchange.getAttributes() with a key defined in ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE . Those values are then available for use by GatewayFilter factories(#gateway-route-filters) The Method Route Predicate Factory: The Method Route Predicate Factory takes a methods argument which is one or more parameters: the HTTP methods to match. The following example configures a method route predicate: application.yml spring: cloud: gateway: routes: - id: method_route uri: https://example.org predicates: - Method=GET,POST This route matches if the request method was a GET or a POST . The Path Route Predicate Factory: The Path Route Predicate Factory takes two parameters: a list of Spring PathMatcher patterns and an optional flag called matchTrailingSlash (defaults to true ). The following example configures a path route predicate: application.yml spring: cloud: gateway: routes: - id: path_route uri: https://example.org predicates: - Path=/red/{segment},/blue/{segment} This route matches if the request path was, for example: /red/1 or /red/1/ or /red/blue or /blue/green . If matchTrailingSlash is set to false , then request path /red/1/ will not be matched. This predicate extracts the URI template variables (such as segment , defined in the preceding example) as a map of names and values and places it in the ServerWebExchange.getAttributes() with a key defined in ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE . Those values are then available for use by GatewayFilter factories(#gateway-route-filters) A utility method (called get ) is available to make access to these variables easier. The following example shows how to use the get method: Map<String, String> uriVariables = ServerWebExchangeUtils.getUriTemplateVariables(exchange); String segment = uriVariables.get(""segment""); The Query Route Predicate Factory: The Query route predicate factory takes two parameters: a required param and an optional regexp (which is a Java regular expression). The following example configures a query route predicate: application.yml spring: cloud: gateway: routes: - id: query_route uri: https://example.org predicates: - Query=green The preceding route matches if the request contained a green query parameter. application.yml spring: cloud: gateway: routes: - id: query_route uri: https://example.org predicates: - Query=red, gree. The preceding route matches if the request contained a red query parameter whose value matched the gree. regexp, so green and greet would match. The RemoteAddr Route Predicate Factory: The RemoteAddr route predicate factory takes a list (min size 1) of sources , which are CIDR-notation (IPv4 or IPv6) strings, such as 192.168.0.1/16 (where 192.168.0.1 is an IP address and 16 is a subnet mask). The following example configures a RemoteAddr route predicate: application.yml spring: cloud: gateway: routes: - id: remoteaddr_route uri: https://example.org predicates: - RemoteAddr=192.168.1.1/24 This route matches if the remote address of the request was, for example, 192.168.1.10 . Modifying the Way Remote Addresses Are Resolved: By default, the RemoteAddr route predicate factory uses the remote address from the incoming request. This may not match the actual client IP address if Spring Cloud Gateway sits behind a proxy layer. You can customize the way that the remote address is resolved by setting a custom RemoteAddressResolver . Spring Cloud Gateway comes with one non-default remote address resolver that is based off of the X-Forwarded-For header(https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For) , XForwardedRemoteAddressResolver . XForwardedRemoteAddressResolver has two static constructor methods, which take different approaches to security: XForwardedRemoteAddressResolver::trustAll returns a RemoteAddressResolver that always takes the first IP address found in the X-Forwarded-For header. This approach is vulnerable to spoofing, as a malicious client could set an initial value for the X-Forwarded-For , which would be accepted by the resolver. XForwardedRemoteAddressResolver::maxTrustedIndex takes an index that correlates to the number of trusted infrastructure running in front of Spring Cloud Gateway. If Spring Cloud Gateway is, for example only accessible through HAProxy, then a value of 1 should be used. If two hops of trusted infrastructure are required before Spring Cloud Gateway is accessible, then a value of 2 should be used. Consider the following header value: X-Forwarded-For: 0.0.0.1, 0.0.0.2, 0.0.0.3 The following maxTrustedIndex values yield the following remote addresses: maxTrustedIndex result [ Integer.MIN_VALUE ,0] (invalid, IllegalArgumentException during initialization) 1 0.0.0.3 2 0.0.0.2 3 0.0.0.1 [4, Integer.MAX_VALUE ] 0.0.0.1 The following example shows how to achieve the same configuration with Java: GatewayConfig.java RemoteAddressResolver resolver = XForwardedRemoteAddressResolver .maxTrustedIndex(1); ... .route(""direct-route"", r -> r.remoteAddr(""10.1.1.1"", ""10.10.1.1/24"") .uri(""https://downstream1"") .route(""proxied-route"", r -> r.remoteAddr(resolver, ""10.10.1.1"", ""10.10.1.1/24"") .uri(""https://downstream2"") ) The Weight Route Predicate Factory: The Weight route predicate factory takes two arguments: group and weight (an int). The weights are calculated per group. The following example configures a weight route predicate: application.yml spring: cloud: gateway: routes: - id: weight_high uri: https://weighthigh.org predicates: - Weight=group1, 8 - id: weight_low uri: https://weightlow.org predicates: - Weight=group1, 2 This route would forward ~80% of traffic to weighthigh.org(https://weighthigh.org) and ~20% of traffic to weightlow.org(https://weightlow.org) The XForwarded Remote Addr Route Predicate Factory: The XForwarded Remote Addr route predicate factory takes a list (min size 1) of sources , which are CIDR-notation (IPv4 or IPv6) strings, such as 192.168.0.1/16 (where 192.168.0.1 is an IP address and 16 is a subnet mask). This route predicate allows requests to be filtered based on the X-Forwarded-For HTTP header. This can be used with reverse proxies such as load balancers or web application firewalls where the request should only be allowed if it comes from a trusted list of IP addresses used by those reverse proxies. The following example configures a XForwardedRemoteAddr route predicate: application.yml spring: cloud: gateway: routes: - id: xforwarded_remoteaddr_route uri: https://example.org predicates: - XForwardedRemoteAddr=192.168.1.1/24 This route matches if the X-Forwarded-For header contains, for example, 192.168.1.10 ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories.html","GatewayFilter Factories: Route filters allow the modification of the incoming HTTP request or outgoing HTTP response in some manner. Route filters are scoped to a particular route. Spring Cloud Gateway includes many built-in GatewayFilter Factories. For more detailed examples of how to use any of the following filters, take a look at the unit tests(https://github.com/spring-cloud/spring-cloud-gateway/tree/master/spring-cloud-gateway-server/src/test/java/org/springframework/cloud/gateway/filter/factory) ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/addrequestheader-factory.html","AddRequestHeader GatewayFilter Factory: The AddRequestHeader GatewayFilter factory takes a name and value parameter. The following example configures an AddRequestHeader GatewayFilter : application.yml spring: cloud: gateway: routes: - id: add_request_header_route uri: https://example.org filters: - AddRequestHeader=X-Request-red, blue This listing adds X-Request-red:blue header to the downstream request’s headers for all matching requests. AddRequestHeader is aware of the URI variables used to match a path or host. URI variables may be used in the value and are expanded at runtime. The following example configures an AddRequestHeader GatewayFilter that uses a variable: application.yml spring: cloud: gateway: routes: - id: add_request_header_route uri: https://example.org predicates: - Path=/red/{segment} filters: - AddRequestHeader=X-Request-Red, Blue-{segment}"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/addrequestheadersifnotpresent-factory.html","AddRequestHeadersIfNotPresent GatewayFilter Factory: The AddRequestHeadersIfNotPresent GatewayFilter factory takes a collection of name and value pairs separated by colon. The following example configures an AddRequestHeadersIfNotPresent GatewayFilter : application.yml spring: cloud: gateway: routes: - id: add_request_headers_route uri: https://example.org filters: - AddRequestHeadersIfNotPresent=X-Request-Color-1:blue,X-Request-Color-2:green This listing adds 2 headers X-Request-Color-1:blue and X-Request-Color-2:green to the downstream request’s headers for all matching requests. This is similar to how AddRequestHeader works, but unlike AddRequestHeader it will do it only if the header is not already there. Otherwise, the original value in the client request is sent. Additionally, to set a multi-valued header, use the header name multiple times like AddRequestHeadersIfNotPresent=X-Request-Color-1:blue,X-Request-Color-1:green . AddRequestHeadersIfNotPresent also supports URI variables used to match a path or host. URI variables may be used in the value and are expanded at runtime. The following example configures an AddRequestHeadersIfNotPresent GatewayFilter that uses a variable: application.yml spring: cloud: gateway: routes: - id: add_request_header_route uri: https://example.org predicates: - Path=/red/{segment} filters: - AddRequestHeadersIfNotPresent=X-Request-Red:Blue-{segment}"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/addrequestparameter-factory.html","AddRequestParameter GatewayFilter Factory: The AddRequestParameter GatewayFilter Factory takes a name and value parameter. The following example configures an AddRequestParameter GatewayFilter : application.yml spring: cloud: gateway: routes: - id: add_request_parameter_route uri: https://example.org filters: - AddRequestParameter=red, blue This will add red=blue to the downstream request’s query string for all matching requests. AddRequestParameter is aware of the URI variables used to match a path or host. URI variables may be used in the value and are expanded at runtime. The following example configures an AddRequestParameter GatewayFilter that uses a variable: application.yml spring: cloud: gateway: routes: - id: add_request_parameter_route uri: https://example.org predicates: - Host: {segment}.myhost.org filters: - AddRequestParameter=foo, bar-{segment}"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/addresponseheader-factory.html","AddResponseHeader GatewayFilter Factory: The AddResponseHeader GatewayFilter Factory takes a name and value parameter. The following example configures an AddResponseHeader GatewayFilter : application.yml spring: cloud: gateway: routes: - id: add_response_header_route uri: https://example.org filters: - AddResponseHeader=X-Response-Red, Blue This adds X-Response-Red:Blue header to the downstream response’s headers for all matching requests. AddResponseHeader is aware of URI variables used to match a path or host. URI variables may be used in the value and are expanded at runtime. The following example configures an AddResponseHeader GatewayFilter that uses a variable: application.yml spring: cloud: gateway: routes: - id: add_response_header_route uri: https://example.org predicates: - Host: {segment}.myhost.org filters: - AddResponseHeader=foo, bar-{segment}"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/circuitbreaker-filter-factory.html","CircuitBreaker GatewayFilter Factory: The Spring Cloud CircuitBreaker GatewayFilter factory uses the Spring Cloud CircuitBreaker APIs to wrap Gateway routes in a circuit breaker. Spring Cloud CircuitBreaker supports multiple libraries that can be used with Spring Cloud Gateway. Spring Cloud supports Resilience4J out of the box. To enable the Spring Cloud CircuitBreaker filter, you need to place spring-cloud-starter-circuitbreaker-reactor-resilience4j on the classpath. The following example configures a Spring Cloud CircuitBreaker GatewayFilter : application.yml spring: cloud: gateway: routes: - id: circuitbreaker_route uri: https://example.org filters: - CircuitBreaker=myCircuitBreaker To configure the circuit breaker, see the configuration for the underlying circuit breaker implementation you are using. Resilience4J Documentation(https://cloud.spring.io/spring-cloud-circuitbreaker/reference/html/spring-cloud-circuitbreaker.html) The Spring Cloud CircuitBreaker filter can also accept an optional fallbackUri parameter. Currently, only forward: schemed URIs are supported. If the fallback is called, the request is forwarded to the controller matched by the URI. The following example configures such a fallback: application.yml spring: cloud: gateway: routes: - id: circuitbreaker_route uri: lb://backing-service:8088 predicates: - Path=/consumingServiceEndpoint filters: - name: CircuitBreaker args: name: myCircuitBreaker fallbackUri: forward:/inCaseOfFailureUseThis - RewritePath=/consumingServiceEndpoint, /backingServiceEndpoint The following listing does the same thing in Java: Application.java @Bean public RouteLocator routes(RouteLocatorBuilder builder) { return builder.routes() .route(""circuitbreaker_route"", r -> r.path(""/consumingServiceEndpoint"") .filters(f -> f.circuitBreaker(c -> c.name(""myCircuitBreaker"").fallbackUri(""forward:/inCaseOfFailureUseThis"")) .rewritePath(""/consumingServiceEndpoint"", ""/backingServiceEndpoint"")).uri(""lb://backing-service:8088"") .build(); } This example forwards to the /inCaseofFailureUseThis URI when the circuit breaker fallback is called. Note that this example also demonstrates the (optional) Spring Cloud LoadBalancer load-balancing (defined by the lb prefix on the destination URI). CircuitBreaker also supports URI variables in the fallbackUri . This allows more complex routing options, like forwarding sections of the original host or url path using PathPattern expression(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/util/pattern/PathPattern.html) . In the example below the call consumingServiceEndpoint/users/1 will be redirected to inCaseOfFailureUseThis/users/1 . application.yml spring: cloud: gateway: routes: - id: circuitbreaker_route uri: lb://backing-service:8088 predicates: - Path=/consumingServiceEndpoint/{*segments} filters: - name: CircuitBreaker args: name: myCircuitBreaker fallbackUri: forward:/inCaseOfFailureUseThis/{segments} The primary scenario is to use the fallbackUri to define an internal controller or handler within the gateway application. However, you can also reroute the request to a controller or handler in an external application, as follows: application.yml spring: cloud: gateway: routes: - id: ingredients uri: lb://ingredients predicates: - Path=//ingredients/** filters: - name: CircuitBreaker args: name: fetchIngredients fallbackUri: forward:/fallback - id: ingredients-fallback uri: http://localhost:9994 predicates: - Path=/fallback In this example, there is no fallback endpoint or handler in the gateway application. However, there is one in another application, registered under localhost:9994(http://localhost:9994) . In case of the request being forwarded to fallback, the Spring Cloud CircuitBreaker Gateway filter also provides the Throwable that has caused it. It is added to the ServerWebExchange as the ServerWebExchangeUtils.CIRCUITBREAKER_EXECUTION_EXCEPTION_ATTR attribute that can be used when handling the fallback within the gateway application. For the external controller/handler scenario, headers can be added with exception details. You can find more information on doing so in the FallbackHeaders GatewayFilter Factory section(fallback-headers.html) . Tripping The Circuit Breaker On Status Codes: In some cases you might want to trip a circuit breaker based on the status code returned from the route it wraps. The circuit breaker config object takes a list of status codes that if returned will cause the circuit breaker to be tripped. When setting the status codes you want to trip the circuit breaker you can either use an integer with the status code value or the String representation of the HttpStatus enumeration. application.yml spring: cloud: gateway: routes: - id: circuitbreaker_route uri: lb://backing-service:8088 predicates: - Path=/consumingServiceEndpoint filters: - name: CircuitBreaker args: name: myCircuitBreaker fallbackUri: forward:/inCaseOfFailureUseThis statusCodes: - 500 - ""NOT_FOUND"" Application.java @Bean public RouteLocator routes(RouteLocatorBuilder builder) { return builder.routes() .route(""circuitbreaker_route"", r -> r.path(""/consumingServiceEndpoint"") .filters(f -> f.circuitBreaker(c -> c.name(""myCircuitBreaker"").fallbackUri(""forward:/inCaseOfFailureUseThis"").addStatusCode(""INTERNAL_SERVER_ERROR"")) .rewritePath(""/consumingServiceEndpoint"", ""/backingServiceEndpoint"")).uri(""lb://backing-service:8088"") .build(); }"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/cacherequestbody-factory.html","CacheRequestBody GatewayFilter Factory: Some situations necessitate reading the request body. Since the request can be read only once, we need to cache the request body. You can use the CacheRequestBody filter to cache the request body before sending it downstream and getting the body from exchange attribute. The following listing shows how to cache the request body GatewayFilter : @Bean public RouteLocator routes(RouteLocatorBuilder builder) { return builder.routes() .route(""cache_request_body_route"", r -> r.path(""/downstream/**"") .filters(f -> f.prefixPath(""/httpbin"") .cacheRequestBody(String.class).uri(uri)) .build(); } application.yml spring: cloud: gateway: routes: - id: cache_request_body_route uri: lb://downstream predicates: - Path=/downstream/** filters: - name: CacheRequestBody args: bodyClass: java.lang.String CacheRequestBody extracts the request body and converts it to a body class (such as java.lang.String , defined in the preceding example). CacheRequestBody then places it in the attributes available from ServerWebExchange.getAttributes() , with a key defined in ServerWebExchangeUtils.CACHED_REQUEST_BODY_ATTR . This filter works only with HTTP (including HTTPS) requests."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/deduperesponseheader-factory.html","DedupeResponseHeader GatewayFilter Factory: The DedupeResponseHeader GatewayFilter factory takes a name parameter and an optional strategy parameter. name can contain a space-separated list of header names. The following example configures a DedupeResponseHeader GatewayFilter : application.yml spring: cloud: gateway: routes: - id: dedupe_response_header_route uri: https://example.org filters: - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin This removes duplicate values of Access-Control-Allow-Credentials and Access-Control-Allow-Origin response headers in cases when both the gateway CORS logic and the downstream logic add them. The DedupeResponseHeader filter also accepts an optional strategy parameter. The accepted values are RETAIN_FIRST (default), RETAIN_LAST , and RETAIN_UNIQUE ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/fallback-headers.html","FallbackHeaders GatewayFilter Factory: The FallbackHeaders factory lets you add Spring Cloud CircuitBreaker execution exception details in the headers of a request forwarded to a fallbackUri in an external application, as in the following scenario: application.yml spring: cloud: gateway: routes: - id: ingredients uri: lb://ingredients predicates: - Path=//ingredients/** filters: - name: CircuitBreaker args: name: fetchIngredients fallbackUri: forward:/fallback - id: ingredients-fallback uri: http://localhost:9994 predicates: - Path=/fallback filters: - name: FallbackHeaders args: executionExceptionTypeHeaderName: Test-Header In this example, after an execution exception occurs while running the circuit breaker, the request is forwarded to the fallback endpoint or handler in an application running on localhost:9994 . The headers with the exception type, message and (if available) root cause exception type and message are added to that request by the FallbackHeaders filter. You can overwrite the names of the headers in the configuration by setting the values of the following arguments (shown with their default values): executionExceptionTypeHeaderName ( ""Execution-Exception-Type"" ) executionExceptionMessageHeaderName ( ""Execution-Exception-Message"" ) rootCauseExceptionTypeHeaderName ( ""Root-Cause-Exception-Type"" ) rootCauseExceptionMessageHeaderName ( ""Root-Cause-Exception-Message"" ) For more information on circuit breakers and the gateway see the Spring Cloud CircuitBreaker Factory section(circuitbreaker-filter-factory.html) ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/jsontogrpc-factory.html","JsonToGrpc GatewayFilter Factory: The JSONToGRPC GatewayFilter Factory converts a JSON payload to a gRPC request. The filter takes the following arguments: protoDescriptor : Proto descriptor file. This file can be generated using protoc and specifying the --descriptor_set_out flag: protoc --proto_path=src/main/resources/proto/ \ --descriptor_set_out=src/main/resources/proto/hello.pb \ src/main/resources/proto/hello.proto protoFile : Proto definition file. service : Short name of the service that handles the request. method : Method name in the service that handles the request. streaming is not supported. application.yml. @Bean public RouteLocator routes(RouteLocatorBuilder builder) { return builder.routes() .route(""json-grpc"", r -> r.path(""/json/hello"").filters(f -> { String protoDescriptor = ""file:src/main/proto/hello.pb""; String protoFile = ""file:src/main/proto/hello.proto""; String service = ""HelloService""; String method = ""hello""; return f.jsonToGRPC(protoDescriptor, protoFile, service, method); }).uri(uri)) spring: cloud: gateway: routes: - id: json-grpc uri: https://localhost:6565/testhello predicates: - Path=/json/** filters: - name: JsonToGrpc args: protoDescriptor: file:proto/hello.pb protoFile: file:proto/hello.proto service: HelloService method: hello When a request is made through the gateway to /json/hello , the request is transformed by using the definition provided in hello.proto , sent to HelloService/hello , and the response back is transformed to JSON. By default, it creates a NettyChannel by using the default TrustManagerFactory . However, you can customize this TrustManager by creating a bean of type GrpcSslConfigurer : @Configuration public class GRPCLocalConfiguration { @Bean public GRPCSSLContext sslContext() { TrustManager trustManager = trustAllCerts(); return new GRPCSSLContext(trustManager); } }"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/local-cache-response-filter.html","LocalResponseCache GatewayFilter Factory: This filter allows caching the response body and headers to follow these rules: It can only cache bodiless GET requests. It caches the response only for one of the following status codes: HTTP 200 (OK), HTTP 206 (Partial Content), or HTTP 301 (Moved Permanently). Response data is not cached if Cache-Control header does not allow it ( no-store present in the request or no-store or private present in the response). If the response is already cached and a new request is performed with no-cache value in Cache-Control header, it returns a bodiless response with 304 (Not Modified). This filter configures the local response cache per route and is available only if the spring.cloud.gateway.filter.local-response-cache.enabled property is enabled. And a local response cache configured globally(../global-filters.html#local-cache-response-global-filter) is also available as feature. It accepts the first parameter to override the time to expire a cache entry (expressed in s for seconds, m for minutes, and h for hours) and a second parameter to set the maximum size of the cache to evict entries for this route ( KB , MB , or GB ). The following listing shows how to add local response cache GatewayFilter : @Bean public RouteLocator routes(RouteLocatorBuilder builder) { return builder.routes() .route(""rewrite_response_upper"", r -> r.host(""*.rewriteresponseupper.org"") .filters(f -> f.prefixPath(""/httpbin"") .localResponseCache(Duration.ofMinutes(30), ""500MB"") ).uri(uri)) .build(); } or this application.yaml spring: cloud: gateway: routes: - id: resource uri: http://localhost:9000 predicates: - Path=/resource filters: - LocalResponseCache=30m,500MB This filter also automatically calculates the max-age value in the HTTP Cache-Control header. Only if max-age is present on the original response is the value rewritten with the number of seconds set in the timeToLive configuration parameter. In consecutive calls, this value is recalculated with the number of seconds left until the response expires. To enable this feature, add com.github.ben-manes.caffeine:caffeine and spring-boot-starter-cache as project dependencies. If your project creates custom CacheManager beans, it will either need to be marked with @Primary or injected using @Qualifier ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/maprequestheader-factory.html","MapRequestHeader GatewayFilter Factory: The MapRequestHeader GatewayFilter factory takes fromHeader and toHeader parameters. It creates a new named header ( toHeader ), and the value is extracted out of an existing named header ( fromHeader ) from the incoming http request. If the input header does not exist, the filter has no impact. If the new named header already exists, its values are augmented with the new values. The following example configures a MapRequestHeader : application.yml spring: cloud: gateway: routes: - id: map_request_header_route uri: https://example.org filters: - MapRequestHeader=Blue, X-Request-Red This adds the X-Request-Red:<values> header to the downstream request with updated values from the incoming HTTP request’s Blue header."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/modifyrequestbody-factory.html","ModifyRequestBody GatewayFilter Factory: You can use the ModifyRequestBody filter to modify the request body before it is sent downstream by the gateway. This filter can be configured only by using the Java DSL. The following listing shows how to modify a request body GatewayFilter : @Bean public RouteLocator routes(RouteLocatorBuilder builder) { return builder.routes() .route(""rewrite_request_obj"", r -> r.host(""*.rewriterequestobj.org"") .filters(f -> f.prefixPath(""/httpbin"") .modifyRequestBody(String.class, Hello.class, MediaType.APPLICATION_JSON_VALUE, (exchange, s) -> Mono.just(new Hello(s.toUpperCase())))).uri(uri)) .build(); } static class Hello { String message; public Hello() { } public Hello(String message) { this.message = message; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } } If the request has no body, the RewriteFilter is passed null . Mono.empty() should be returned to assign a missing body in the request."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/modifyresponsebody-factory.html","ModifyResponseBody GatewayFilter Factory: You can use the ModifyResponseBody filter to modify the response body before it is sent back to the client. This filter can be configured only by using the Java DSL. The following listing shows how to modify a response body GatewayFilter : @Bean public RouteLocator routes(RouteLocatorBuilder builder) { return builder.routes() .route(""rewrite_response_upper"", r -> r.host(""*.rewriteresponseupper.org"") .filters(f -> f.prefixPath(""/httpbin"") .modifyResponseBody(String.class, String.class, (exchange, s) -> Mono.just(s.toUpperCase()))).uri(uri)) .build(); } If the response has no body, the RewriteFilter is passed null . Mono.empty() should be returned to assign a missing body in the response."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/prefixpath-factory.html","PrefixPath GatewayFilter Factory: The PrefixPath GatewayFilter factory takes a single prefix parameter. The following example configures a PrefixPath GatewayFilter : application.yml spring: cloud: gateway: routes: - id: prefixpath_route uri: https://example.org filters: - PrefixPath=/mypath This prefixes /mypath to the path of all matching requests. So a request to /hello is sent to /mypath/hello ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/preservehostheader-factory.html","PreserveHostHeader GatewayFilter Factory: The PreserveHostHeader GatewayFilter factory has no parameters. This filter sets a request attribute that the routing filter inspects to determine if the original host header should be sent rather than the host header determined by the HTTP client. The following example configures a PreserveHostHeader GatewayFilter : application.yml spring: cloud: gateway: routes: - id: preserve_host_route uri: https://example.org filters: - PreserveHostHeader"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/redirectto-factory.html","RedirectTo GatewayFilter Factory: The RedirectTo GatewayFilter factory takes three parameters, status , url , and optionally includeRequestParams . The status parameter should be a 300 series redirect HTTP code, such as 301. The url parameter should be a valid URL. This is the value of the Location header. The includeRequestParams parameter indicates whether request query parameters should be included on the url . When not set, it will be treated as false . For relative redirects, you should use uri: no://op as the uri of your route definition. The following listing configures a RedirectTo GatewayFilter : application.yml spring: cloud: gateway: routes: - id: prefixpath_route uri: https://example.org filters: - RedirectTo=302, https://acme.org This will send a status 302 with a Location:https://acme.org header to perform a redirect. The following example configures a RedirectTo GatewayFilter with includeRequestParams set to true . application.yml spring: cloud: gateway: routes: - id: prefixpath_route uri: https://example.org filters: - RedirectTo=302, https://acme.org, true When a request with query ?skip=10 is made to the gateway, the gateway will send a status 302 with a Location:https://acme.org?skip=10 header to perform a redirect."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/removejsonattributesresponsebody-factory.html","RemoveJsonAttributesResponseBody GatewayFilter Factory: The RemoveJsonAttributesResponseBody GatewayFilter factory takes a collection of attribute names to search for, an optional last parameter from the list can be a boolean to remove the attributes just at root level (that’s the default value if not present at the end of the parameter configuration, false ) or recursively ( true ). It provides a convenient method to apply a transformation to JSON body content by deleting attributes from it. The following example configures an RemoveJsonAttributesResponseBody GatewayFilter : application.yml spring: cloud: gateway: routes: - id: removejsonattributes_route uri: https://example.org filters: - RemoveJsonAttributesResponseBody=id,color This removes attributes ""id"" and ""color"" from the JSON content body at root level. The following example configures an RemoveJsonAttributesResponseBody GatewayFilter that uses the optional last parameter: application.yml spring: cloud: gateway: routes: - id: removejsonattributes_recursively_route uri: https://example.org predicates: - Path=/red/{segment} filters: - RemoveJsonAttributesResponseBody=id,color,true This removes attributes ""id"" and ""color"" from the JSON content body at any level."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/removerequestheader-factory.html","RemoveRequestHeader GatewayFilter Factory: The RemoveRequestHeader GatewayFilter factory takes a name parameter. It is the name of the header to be removed. The following listing configures a RemoveRequestHeader GatewayFilter : application.yml spring: cloud: gateway: routes: - id: removerequestheader_route uri: https://example.org filters: - RemoveRequestHeader=X-Request-Foo This removes the X-Request-Foo header before it is sent downstream."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/removerequestparameter-factory.html","RemoveRequestParameter GatewayFilter Factory: The RemoveRequestParameter GatewayFilter factory takes a name parameter. It is the name of the query parameter to be removed. The following example configures a RemoveRequestParameter GatewayFilter : application.yml spring: cloud: gateway: routes: - id: removerequestparameter_route uri: https://example.org filters: - RemoveRequestParameter=red This will remove the red parameter before it is sent downstream."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/removeresponseheader-factory.html","RemoveResponseHeader GatewayFilter Factory: The RemoveResponseHeader GatewayFilter factory takes a name parameter. It is the name of the header to be removed. The following listing configures a RemoveResponseHeader GatewayFilter : application.yml spring: cloud: gateway: routes: - id: removeresponseheader_route uri: https://example.org filters: - RemoveResponseHeader=X-Response-Foo This will remove the X-Response-Foo header from the response before it is returned to the gateway client. To remove any kind of sensitive header, you should configure this filter for any routes for which you may want to do so. In addition, you can configure this filter once by using spring.cloud.gateway.default-filters and have it applied to all routes."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/requestheadersize-factory.html","RequestHeaderSize GatewayFilter Factory: The RequestHeaderSize GatewayFilter factory takes maxSize and errorHeaderName parameters. The maxSize parameter is the maximum data size allowed by the request header (including key and value). The errorHeaderName parameter sets the name of the response header containing an error message, by default it is ""errorMessage"". The following listing configures a RequestHeaderSize GatewayFilter : application.yml spring: cloud: gateway: routes: - id: requestheadersize_route uri: https://example.org filters: - RequestHeaderSize=1000B This will send a status 431 if size of any request header is greater than 1000 Bytes."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/requestratelimiter-factory.html","RequestRateLimiter GatewayFilter Factory: The RequestRateLimiter GatewayFilter factory uses a RateLimiter implementation to determine if the current request is allowed to proceed. If it is not, a status of HTTP 429 - Too Many Requests (by default) is returned. This filter takes an optional keyResolver parameter and parameters specific to the rate limiter (described later in this section(#key-resolver-section) ). keyResolver is a bean that implements the KeyResolver interface. In configuration, reference the bean by name using SpEL. #{@myKeyResolver} is a SpEL expression that references a bean named myKeyResolver . The following listing shows the KeyResolver interface: KeyResolver.java public interface KeyResolver { Mono<String> resolve(ServerWebExchange exchange); } The KeyResolver interface lets pluggable strategies derive the key for limiting requests. In future milestone releases, there will be some KeyResolver implementations. The default implementation of KeyResolver is the PrincipalNameKeyResolver , which retrieves the Principal from the ServerWebExchange and calls Principal.getName() . By default, if the KeyResolver does not find a key, requests are denied. You can adjust this behavior by setting the spring.cloud.gateway.filter.request-rate-limiter.deny-empty-key ( true or false ) and spring.cloud.gateway.filter.request-rate-limiter.empty-key-status-code properties. The RequestRateLimiter is not configurable with the ""shortcut"" notation. The following example below is invalid : application.properties # INVALID SHORTCUT CONFIGURATION spring.cloud.gateway.routes[0].filters[0]=RequestRateLimiter=2, 2, #{@userkeyresolver} Here is a valid yaml reference: application.yml spring: cloud: gateway: routes: - id: limit uri: https://example.org filters: - name: RequestRateLimiter args: key-resolver: ""#{@userkeyresolver}"" The Redis RateLimiter: The Redis implementation is based on work done at Stripe(https://stripe.com/blog/rate-limiters) . It requires the use of the spring-boot-starter-data-redis-reactive Spring Boot starter. The algorithm used is the Token Bucket Algorithm(https://en.wikipedia.org/wiki/Token_bucket) . The redis-rate-limiter.replenishRate property defines how many requests per second to allow (without any dropped requests). This is the rate at which the token bucket is filled. The redis-rate-limiter.burstCapacity property is the maximum number of requests a user is allowed in a single second (without any dropped requests). This is the number of tokens the token bucket can hold. Setting this value to zero blocks all requests. The redis-rate-limiter.requestedTokens property is how many tokens a request costs. This is the number of tokens taken from the bucket for each request and defaults to 1 . A steady rate is accomplished by setting the same value in replenishRate and burstCapacity . Temporary bursts can be allowed by setting burstCapacity higher than replenishRate . In this case, the rate limiter needs to be allowed some time between bursts (according to replenishRate ), as two consecutive bursts results in dropped requests ( HTTP 429 - Too Many Requests ). The following listing configures a redis-rate-limiter : Rate limits below 1 request/s are accomplished by setting replenishRate to the wanted number of requests, requestedTokens to the timespan in seconds, and burstCapacity to the product of replenishRate and requestedTokens . For example, setting replenishRate=1 , requestedTokens=60 , and burstCapacity=60 results in a limit of 1 request/min . .application.yml spring: cloud: gateway: routes: - id: requestratelimiter_route uri: https://example.org filters: - name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 10 redis-rate-limiter.burstCapacity: 20 redis-rate-limiter.requestedTokens: 1 The following example configures a KeyResolver in Java: Config.java @Bean KeyResolver userKeyResolver() { return exchange -> Mono.just(exchange.getRequest().getQueryParams().getFirst(""user"")); } This defines a request rate limit of 10 per user. A burst of 20 is allowed, but, in the next second, only 10 requests are available. The KeyResolver is a simple one that gets the user request parameter NOTE: This is not recommended for production You can also define a rate limiter as a bean that implements the RateLimiter interface. In configuration, you can reference the bean by name using SpEL. #{@myRateLimiter} is a SpEL expression that references a bean with named myRateLimiter . The following listing defines a rate limiter that uses the KeyResolver defined in the previous listing: application.yml spring: cloud: gateway: routes: - id: requestratelimiter_route uri: https://example.org filters: - name: RequestRateLimiter args: rate-limiter: ""#{@myRateLimiter}"" key-resolver: ""#{@userKeyResolver}"""
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/rewritelocationresponseheader-factory.html","RewriteLocationResponseHeader GatewayFilter Factory: The RewriteLocationResponseHeader GatewayFilter factory modifies the value of the Location response header, usually to get rid of backend-specific details. It takes the Mode , locationHeaderName , hostValue , and protocols parameters. The following listing configures a RewriteLocationResponseHeader GatewayFilter : application.yml spring: cloud: gateway: routes: - id: rewritelocationresponseheader_route uri: http://example.org filters: - RewriteLocationResponseHeader=AS_IN_REQUEST, Location, , For example, for a request of POST api.example.com/some/object/name(https://api.example.com/some/object/name) , the Location response header value of object-service.prod.example.net/v2/some/object/id(https://object-service.prod.example.net/v2/some/object/id) is rewritten as api.example.com/some/object/id(https://api.example.com/some/object/id) . The Mode parameter has the following possible values: NEVER_STRIP , AS_IN_REQUEST (default), and ALWAYS_STRIP . NEVER_STRIP : The version is not stripped, even if the original request path contains no version. AS_IN_REQUEST : The version is stripped only if the original request path contains no version. ALWAYS_STRIP : The version is always stripped, even if the original request path contains version. The hostValue parameter, if provided, is used to replace the host:port portion of the response Location header. If it is not provided, the value of the Host request header is used. The protocols parameter must be a valid regex String , against which the protocol name is matched. If it is not matched, the filter does nothing. The default is https?|ftps? ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/rewritepath-factory.html","RewritePath GatewayFilter Factory: The RewritePath GatewayFilter factory takes a path regexp parameter and a replacement parameter. This uses Java regular expressions for a flexible way to rewrite the request path. The following listing configures a RewritePath GatewayFilter : application.yml spring: cloud: gateway: routes: - id: rewritepath_route uri: https://example.org predicates: - Path=/red/** filters: - RewritePath=/red/?(?<segment>.*), /$\{segment} For a request path of /red/blue , this sets the path to /blue before making the downstream request. Note that the $ should be replaced with $\ because of the YAML specification."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/rewriterequestparameter-factory.html","RewriteRequestParameter GatewayFilter Factory: The RewriteRequestParameter GatewayFilter factory takes a name parameter and a replacement parameter. It will rewrite the value of the request parameter of the given name . If multiple request parameters with the same name are set, they will be replaced with a single value. If no request parameter is found, no changes will be made. The following listing configures a RewriteRequestParameter GatewayFilter : Example 1. application.yml spring: cloud: gateway: routes: - id: rewriterequestparameter_route uri: https://example.org predicates: - Path=/products filters: - RewriteRequestParameter=campaign,fall2023 For a request to /products?campaign=old , this sets the request parameter to campaign=fall2023 ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/rewriteresponseheader-factory.html","RewriteResponseHeader GatewayFilter Factory: The RewriteResponseHeader GatewayFilter factory takes name , regexp , and replacement parameters. It uses Java regular expressions for a flexible way to rewrite the response header value. The following example configures a RewriteResponseHeader GatewayFilter : application.yml spring: cloud: gateway: routes: - id: rewriteresponseheader_route uri: https://example.org filters: - RewriteResponseHeader=X-Response-Red, , password=[^&]+, password=*** For a header value of /42?user=ford&password=omg!what&flag=true , it is set to /42?user=ford&password=***&flag=true after making the downstream request. You must use $\ to mean $ because of the YAML specification."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/savesession-factory.html","SaveSession GatewayFilter Factory: The SaveSession GatewayFilter factory forces a WebSession::save operation before forwarding the call downstream. This is of particular use when using something like Spring Session(https://projects.spring.io/spring-session/) with a lazy data store, and you need to ensure the session state has been saved before making the forwarded call. The following example configures a SaveSession GatewayFilter : application.yml spring: cloud: gateway: routes: - id: save_session uri: https://example.org predicates: - Path=/foo/** filters: - SaveSession If you integrate Spring Security(https://projects.spring.io/spring-security/) with Spring Session and want to ensure security details have been forwarded to the remote process, this is critical."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/secureheaders-factory.html","SecureHeaders GatewayFilter Factory: The SecureHeaders GatewayFilter factory adds a number of headers to the response, per the recommendation made in this blog post(https://blog.appcanary.com/2017/http-security-headers.html) . The following headers (shown with their default values) are added: X-Xss-Protection:1 (mode=block ) Strict-Transport-Security (max-age=631138519 ) X-Frame-Options (DENY) X-Content-Type-Options (nosniff) Referrer-Policy (no-referrer) Content-Security-Policy (default-src 'self' https:; font-src 'self' https: data:; img-src 'self' https: data:; object-src 'none'; script-src https:; style-src 'self' https: 'unsafe-inline)' X-Download-Options (noopen) X-Permitted-Cross-Domain-Policies (none) To change the default values, set the appropriate property in the spring.cloud.gateway.filter.secure-headers namespace. The following properties are available: xss-protection-header strict-transport-security frame-options content-type-options referrer-policy content-security-policy download-options permitted-cross-domain-policies To disable the default values set the spring.cloud.gateway.filter.secure-headers.disable property with comma-separated values. The following example shows how to do so: spring.cloud.gateway.filter.secure-headers.disable=x-frame-options,strict-transport-security The lowercase full name of the secure header needs to be used to disable it.."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/setpath-factory.html","SetPath GatewayFilter Factory: The SetPath GatewayFilter factory takes a path template parameter. It offers a simple way to manipulate the request path by allowing templated segments of the path. This uses the URI templates from Spring Framework. Multiple matching segments are allowed. The following example configures a SetPath GatewayFilter : application.yml spring: cloud: gateway: routes: - id: setpath_route uri: https://example.org predicates: - Path=/red/{segment} filters: - SetPath=/{segment} For a request path of /red/blue , this sets the path to /blue before making the downstream request."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/setrequestheader-factory.html","SetRequestHeader GatewayFilter Factory: The SetRequestHeader GatewayFilter factory takes name and value parameters. The following listing configures a SetRequestHeader GatewayFilter : application.yml spring: cloud: gateway: routes: - id: setrequestheader_route uri: https://example.org filters: - SetRequestHeader=X-Request-Red, Blue This GatewayFilter replaces (rather than adding) all headers with the given name. So, if the downstream server responded with X-Request-Red:1234 , it will be replaced with X-Request-Red:Blue , which is what the downstream service would receive. SetRequestHeader is aware of URI variables used to match a path or host. URI variables may be used in the value and are expanded at runtime. The following example configures an SetRequestHeader GatewayFilter that uses a variable: application.yml spring: cloud: gateway: routes: - id: setrequestheader_route uri: https://example.org predicates: - Host: {segment}.myhost.org filters: - SetRequestHeader=foo, bar-{segment}"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/setresponseheader-factory.html","SetResponseHeader GatewayFilter Factory: The SetResponseHeader GatewayFilter factory takes name and value parameters. The following listing configures a SetResponseHeader GatewayFilter : application.yml spring: cloud: gateway: routes: - id: setresponseheader_route uri: https://example.org filters: - SetResponseHeader=X-Response-Red, Blue This GatewayFilter replaces (rather than adding) all headers with the given name. So, if the downstream server responded with X-Response-Red:1234 , it will be replaced with X-Response-Red:Blue , which is what the gateway client would receive. SetResponseHeader is aware of URI variables used to match a path or host. URI variables may be used in the value and will be expanded at runtime. The following example configures an SetResponseHeader GatewayFilter that uses a variable: application.yml spring: cloud: gateway: routes: - id: setresponseheader_route uri: https://example.org predicates: - Host: {segment}.myhost.org filters: - SetResponseHeader=foo, bar-{segment}"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/setstatus-factory.html","SetStatus GatewayFilter Factory: The SetStatus GatewayFilter factory takes a single parameter, status . It must be a valid Spring HttpStatus . It may be the integer value 404 or the string representation of the enumeration: NOT_FOUND . The following listing configures a SetStatus GatewayFilter : application.yml spring: cloud: gateway: routes: - id: setstatusstring_route uri: https://example.org filters: - SetStatus=UNAUTHORIZED - id: setstatusint_route uri: https://example.org filters: - SetStatus=401 In either case, the HTTP status of the response is set to 401. You can configure the SetStatus GatewayFilter to return the original HTTP status code from the proxied request in a header in the response. The header is added to the response if configured with the following property: application.yml spring: cloud: gateway: set-status: original-status-header-name: original-http-status"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/stripprefix-factory.html","StripPrefix GatewayFilter Factory: The StripPrefix GatewayFilter factory takes one parameter, parts . The parts parameter indicates the number of parts in the path to strip from the request before sending it downstream. The following listing configures a StripPrefix GatewayFilter : application.yml spring: cloud: gateway: routes: - id: nameRoot uri: https://nameservice predicates: - Path=/name/** filters: - StripPrefix=2 When a request is made through the gateway to /name/blue/red , the request made to nameservice looks like nameservice/red(https://nameservice/red) ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/retry-factory.html","Retry GatewayFilter Factory: The Retry GatewayFilter factory supports the following parameters: retries : The number of retries that should be attempted. statuses : The HTTP status codes that should be retried, represented by using org.springframework.http.HttpStatus . methods : The HTTP methods that should be retried, represented by using org.springframework.http.HttpMethod . series : The series of status codes to be retried, represented by using org.springframework.http.HttpStatus.Series . exceptions : A list of thrown exceptions that should be retried. backoff : The configured exponential backoff for the retries. Retries are performed after a backoff interval of firstBackoff * (factor ^ n) , where n is the iteration. If maxBackoff is configured, the maximum backoff applied is limited to maxBackoff . If basedOnPreviousValue is true, the backoff is calculated by using prevBackoff * factor . The following defaults are configured for Retry filter, if enabled: retries : Three times series : 5XX series methods : GET method exceptions : IOException and TimeoutException backoff : disabled The following listing configures a Retry GatewayFilter : application.yml spring: cloud: gateway: routes: - id: retry_test uri: http://localhost:8080/flakey predicates: - Host=*.retry.com filters: - name: Retry args: retries: 3 statuses: BAD_GATEWAY methods: GET,POST backoff: firstBackoff: 10ms maxBackoff: 50ms factor: 2 basedOnPreviousValue: false When using the retry filter with a forward: prefixed URL, the target endpoint should be written carefully so that, in case of an error, it does not do anything that could result in a response being sent to the client and committed. For example, if the target endpoint is an annotated controller, the target controller method should not return ResponseEntity with an error status code. Instead, it should throw an Exception or signal an error (for example, through a Mono.error(ex) return value), which the retry filter can be configured to handle by retrying. When using the retry filter with any HTTP method with a body, the body will be cached and the gateway will become memory constrained. The body is cached in a request attribute defined by ServerWebExchangeUtils.CACHED_REQUEST_BODY_ATTR . The type of the object is org.springframework.core.io.buffer.DataBuffer . A simplified ""shortcut"" notation can be added with a single status and method . The following two examples are equivalent: application.yml spring: cloud: gateway: routes: - id: retry_route uri: https://example.org filters: - name: Retry args: retries: 3 statuses: INTERNAL_SERVER_ERROR methods: GET backoff: firstBackoff: 10ms maxBackoff: 50ms factor: 2 basedOnPreviousValue: false - id: retryshortcut_route uri: https://example.org filters: - Retry=3,INTERNAL_SERVER_ERROR,GET,10ms,50ms,2,false"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/requestsize-factory.html","RequestSize GatewayFilter Factory: When the request size is greater than the permissible limit, the RequestSize GatewayFilter factory can restrict a request from reaching the downstream service. The filter takes a maxSize parameter. The maxSize is a DataSize type, so values can be defined as a number followed by an optional DataUnit suffix such as 'KB' or 'MB'. The default is 'B' for bytes. It is the permissible size limit of the request defined in bytes. The following listing configures a RequestSize GatewayFilter : application.yml spring: cloud: gateway: routes: - id: request_size_route uri: http://localhost:8080/upload predicates: - Path=/upload filters: - name: RequestSize args: maxSize: 5000000 The RequestSize GatewayFilter factory sets the response status as 413 Payload Too Large with an additional header errorMessage when the request is rejected due to size. The following example shows such an errorMessage : errorMessage : Request size is larger than permissible limit. Request size is 6.0 MB where permissible limit is 5.0 MB The default request size is set to five MB if not provided as a filter argument in the route definition."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/setrequesthostheader-factory.html","SetRequestHostHeader GatewayFilter Factory: There are certain situation when the host header may need to be overridden. In this situation, the SetRequestHostHeader GatewayFilter factory can replace the existing host header with a specified value. The filter takes a host parameter. The following listing configures a SetRequestHostHeader GatewayFilter : application.yml spring: cloud: gateway: routes: - id: set_request_host_header_route uri: http://localhost:8080/headers predicates: - Path=/headers filters: - name: SetRequestHostHeader args: host: example.org The SetRequestHostHeader GatewayFilter factory replaces the value of the host header with example.org ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/tokenrelay-factory.html","TokenRelay GatewayFilter Factory: A Token Relay is where an OAuth2 consumer acts as a Client and forwards the incoming token to outgoing resource requests. The consumer can be a pure Client (like an SSO application) or a Resource Server. Spring Cloud Gateway can forward OAuth2 access tokens downstream to the services it is proxying using the TokenRelay GatewayFilter . The TokenRelay GatewayFilter takes one optional parameter, clientRegistrationId . The following example configures a TokenRelay GatewayFilter : App.java @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) { return builder.routes() .route(""resource"", r -> r.path(""/resource"") .filters(f -> f.tokenRelay(""myregistrationid"")) .uri(""http://localhost:9000"")) .build(); } or this application.yaml spring: cloud: gateway: routes: - id: resource uri: http://localhost:9000 predicates: - Path=/resource filters: - TokenRelay=myregistrationid The example above specifies a clientRegistrationId , which can be used to obtain and forward an OAuth2 access token for any available ClientRegistration . Spring Cloud Gateway can also forward the OAuth2 access token of the currently authenticated user oauth2Login() is used to authenticate the user. To add this functionality to the gateway, you can omit the clientRegistrationId parameter like this: App.java @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) { return builder.routes() .route(""resource"", r -> r.path(""/resource"") .filters(f -> f.tokenRelay()) .uri(""http://localhost:9000"")) .build(); } or this application.yaml spring: cloud: gateway: routes: - id: resource uri: http://localhost:9000 predicates: - Path=/resource filters: - TokenRelay= and it will (in addition to logging the user in and grabbing a token) pass the authentication token downstream to the services (in this case /resource ). To enable this for Spring Cloud Gateway add the following dependencies org.springframework.boot:spring-boot-starter-oauth2-client How does it work? The filter(https://github.com/spring-cloud/spring-cloud-gateway/blob/main/spring-cloud-gateway-server/src/main/java/org/springframework/cloud/gateway/filter/factory/TokenRelayGatewayFilterFactory.java) extracts an OAuth2 access token from the currently authenticated user for the provided clientRegistrationId . If no clientRegistrationId is provided, the currently authenticated user’s own access token (obtained during login) is used. In either case, the extracted access token is placed in a request header for the downstream requests. For a full working sample see this project(https://github.com/spring-cloud-samples/sample-gateway-oauth2login) . A TokenRelayGatewayFilterFactory bean will only be created if the proper spring.security.oauth2.client.* properties are set which will trigger creation of a ReactiveClientRegistrationRepository bean. The default implementation of ReactiveOAuth2AuthorizedClientService used by TokenRelayGatewayFilterFactory uses an in-memory data store. You will need to provide your own implementation ReactiveOAuth2AuthorizedClientService if you need a more robust solution."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories/default-filters.html","Default Filters: To add a filter and apply it to all routes, you can use spring.cloud.gateway.default-filters . This property takes a list of filters. The following listing defines a set of default filters: application.yml spring: cloud: gateway: default-filters: - AddResponseHeader=X-Response-Default-Red, Default-Blue - PrefixPath=/httpbin"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/global-filters.html","Global Filters: The GlobalFilter interface has the same signature as GatewayFilter . These are special filters that are conditionally applied to all routes. This interface and its usage are subject to change in future milestone releases. Combined Global Filter and GatewayFilter Ordering: When a request matches a route, the filtering web handler adds all instances of GlobalFilter and all route-specific instances of GatewayFilter to a filter chain. This combined filter chain is sorted by the org.springframework.core.Ordered interface, which you can set by implementing the getOrder() method. As Spring Cloud Gateway distinguishes between “pre” and “post” phases for filter logic execution (see How it Works(how-it-works.html) ), the filter with the highest precedence is the first in the “pre”-phase and the last in the “post”-phase. The following listing configures a filter chain: ExampleConfiguration.java @Bean public GlobalFilter customFilter() { return new CustomGlobalFilter(); } public class CustomGlobalFilter implements GlobalFilter, Ordered { @Override public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) { log.info(""custom global filter""); return chain.filter(exchange); } @Override public int getOrder() { return -1; } } The Gateway Metrics Filter: To enable gateway metrics, add spring-boot-starter-actuator as a project dependency. Then, by default, the gateway metrics filter runs as long as the spring.cloud.gateway.metrics.enabled property is not set to false . This filter adds a timer metric named spring.cloud.gateway.requests with the following tags: routeId : The route ID. routeUri : The URI to which the API is routed. outcome : The outcome, as classified by HttpStatus.Series(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.Series.html) . status : The HTTP status of the request returned to the client. httpStatusCode : The HTTP Status of the request returned to the client. httpMethod : The HTTP method used for the request. In addition, through the spring.cloud.gateway.metrics.tags.path.enabled property (by default, false ), you can activate an extra metric with the path tag: path : The path of the request. These metrics are then available to be scraped from /actuator/metrics/spring.cloud.gateway.requests and can be easily integrated with Prometheus to create a Grafana(images/gateway-grafana-dashboard.jpeg) dashboard(gateway-grafana-dashboard.json) . To enable the prometheus endpoint, add micrometer-registry-prometheus as a project dependency. The Local Response Cache Filter: The LocalResponseCache runs if associated properties are enabled: spring.cloud.gateway.global-filter.local-response-cache.enabled : Activates the global cache for all routes spring.cloud.gateway.filter.local-response-cache.enabled : Activates the associated filter to use at route level This feature enables a local cache using Caffeine for all responses that meet the following criteria: The request is a bodiless GET. The response has one of the following status codes: HTTP 200 (OK), HTTP 206 (Partial Content), or HTTP 301 (Moved Permanently). The HTTP Cache-Control header allows caching (that means it does not have any of the following values: no-store present in the request and no-store or private present in the response). It accepts two configuration parameters: spring.cloud.gateway.filter.local-response-cache.size : Sets the maximum size of the cache to evict entries for this route (in KB, MB and GB). spring.cloud.gateway.filter.local-response-cache.time-to-live Sets the time to expire a cache entry (expressed in s for seconds, m for minutes, and h for hours). If none of these parameters are configured but the global filter is enabled, by default, it configures 5 minutes of time to live for the cached response. This filter also implements the automatic calculation of the max-age value in the HTTP Cache-Control header. If max-age is present on the original response, the value is rewritten with the number of seconds set in the timeToLive configuration parameter. In subsequent calls, this value is recalculated with the number of seconds left until the response expires. Setting spring.cloud.gateway.global-filter.local-response-cache.enabled to false deactivate the local response cache for all routes, the LocalResponseCache filter(gatewayfilter-factories/local-cache-response-filter.html) allows to use this functionality at route level. To enable this feature, add com.github.ben-manes.caffeine:caffeine and spring-boot-starter-cache as project dependencies. If your project creates custom CacheManager beans, it will either need to be marked with @Primary or injected using @Qualifier . Forward Routing Filter: The ForwardRoutingFilter looks for a URI in the exchange attribute ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR . If the URL has a forward scheme (such as forward:///localendpoint ), it uses the Spring DispatcherHandler to handle the request. The path part of the request URL is overridden with the path in the forward URL. The unmodified original URL is appended to the list in the ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR attribute. The Netty Routing Filter: The Netty routing filter runs if the URL located in the ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR exchange attribute has a http or https scheme. It uses the Netty HttpClient to make the downstream proxy request. The response is put in the ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR exchange attribute for use in a later filter. (There is also an experimental WebClientHttpRoutingFilter that performs the same function but does not require Netty.) The Netty Write Response Filter: The NettyWriteResponseFilter runs if there is a Netty HttpClientResponse in the ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR exchange attribute. It runs after all other filters have completed and writes the proxy response back to the gateway client response. (There is also an experimental WebClientWriteResponseFilter that performs the same function but does not require Netty.) ReactiveLoadBalancerClientFilter: The ReactiveLoadBalancerClientFilter looks for a URI in the exchange attribute named ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR . If the URL has a lb scheme (such as lb://myservice ), it uses the Spring Cloud ReactorLoadBalancer to resolve the name ( myservice in this example) to an actual host and port and replaces the URI in the same attribute. The unmodified original URL is appended to the list in the ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR attribute. The filter also looks in the ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR attribute to see if it equals lb . If so, the same rules apply. The following listing configures a ReactiveLoadBalancerClientFilter : application.yml spring: cloud: gateway: routes: - id: myRoute uri: lb://service predicates: - Path=/service/** By default, when a service instance cannot be found by the ReactorLoadBalancer , a 503 is returned. You can configure the gateway to return a 404 by setting spring.cloud.gateway.loadbalancer.use404=true . The isSecure value of the ServiceInstance returned from the ReactiveLoadBalancerClientFilter overrides the scheme specified in the request made to the Gateway. For example, if the request comes into the Gateway over HTTPS but the ServiceInstance indicates it is not secure, the downstream request is made over HTTP . The opposite situation can also apply. However, if GATEWAY_SCHEME_PREFIX_ATTR is specified for the route in the Gateway configuration, the prefix is stripped and the resulting scheme from the route URL overrides the ServiceInstance configuration. Gateway supports all the LoadBalancer features. You can read more about them in the Spring Cloud Commons documentation(https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer) . RouteToRequestUrl Filter: If there is a Route object in the ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR exchange attribute, the RouteToRequestUrlFilter runs. It creates a new URI, based off of the request URI but updated with the URI attribute of the Route object. The new URI is placed in the ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR exchange attribute. If the URI has a scheme prefix, such as lb:ws://serviceid , the lb scheme is stripped from the URI and placed in the ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR for use later in the filter chain. The Websocket Routing Filter: If the URL located in the ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR exchange attribute has a ws or wss scheme, the websocket routing filter runs. It uses the Spring WebSocket infrastructure to forward the websocket request downstream. You can load-balance websockets by prefixing the URI with lb , such as lb:ws://serviceid . If you use SockJS(https://github.com/sockjs) as a fallback over normal HTTP, you should configure a normal HTTP route as well as the websocket Route. The following listing configures a websocket routing filter: application.yml spring: cloud: gateway: routes: # SockJS route - id: websocket_sockjs_route uri: http://localhost:3001 predicates: - Path=/websocket/info/** # Normal Websocket route - id: websocket_route uri: ws://localhost:3001 predicates: - Path=/websocket/** Marking An Exchange As Routed: After the gateway has routed a ServerWebExchange , it marks that exchange as “routed” by adding gatewayAlreadyRouted to the exchange attributes. Once a request has been marked as routed, other routing filters will not route the request again, essentially skipping the filter. There are convenience methods that you can use to mark an exchange as routed or check if an exchange has already been routed. ServerWebExchangeUtils.isAlreadyRouted takes a ServerWebExchange object and checks if it has been “routed”. ServerWebExchangeUtils.setAlreadyRouted takes a ServerWebExchange object and marks it as “routed”."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/httpheadersfilters.html","HttpHeadersFilters: HttpHeadersFilters are applied to the requests before sending them downstream, such as in the NettyRoutingFilter . Forwarded Headers Filter: The Forwarded Headers Filter creates a Forwarded header to send to the downstream service. It adds the Host header, scheme and port of the current request to any existing Forwarded header. RemoveHopByHop Headers Filter: The RemoveHopByHop Headers Filter removes headers from forwarded requests. The default list of headers that is removed comes from the IETF(https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-14#section-7.1.3) . The default removed headers are: Connection Keep-Alive Proxy-Authenticate Proxy-Authorization TE Trailer Transfer-Encoding Upgrade To change this, set the spring.cloud.gateway.filter.remove-hop-by-hop.headers property to the list of header names to remove. XForwarded Headers Filter: The XForwarded Headers Filter creates various X-Forwarded-* headers to send to the downstream service. It uses the Host header, scheme, port and path of the current request to create the various headers. Creating of individual headers can be controlled by the following boolean properties (defaults to true): spring.cloud.gateway.x-forwarded.for-enabled spring.cloud.gateway.x-forwarded.host-enabled spring.cloud.gateway.x-forwarded.port-enabled spring.cloud.gateway.x-forwarded.proto-enabled spring.cloud.gateway.x-forwarded.prefix-enabled Appending multiple headers can be controlled by the following boolean properties (defaults to true): spring.cloud.gateway.x-forwarded.for-append spring.cloud.gateway.x-forwarded.host-append spring.cloud.gateway.x-forwarded.port-append spring.cloud.gateway.x-forwarded.proto-append spring.cloud.gateway.x-forwarded.prefix-append"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/tls-and-ssl.html","TLS and SSL: The gateway can listen for requests on HTTPS by following the usual Spring server configuration. The following example shows how to do so: application.yml server: ssl: enabled: true key-alias: scg key-store-password: scg1234 key-store: classpath:scg-keystore.p12 key-store-type: PKCS12 You can route gateway routes to both HTTP and HTTPS backends. If you are routing to an HTTPS backend, you can configure the gateway to trust all downstream certificates with the following configuration: application.yml spring: cloud: gateway: httpclient: ssl: useInsecureTrustManager: true Using an insecure trust manager is not suitable for production. For a production deployment, you can configure the gateway with a set of known certificates that it can trust with the following configuration: application.yml spring: cloud: gateway: httpclient: ssl: trustedX509Certificates: - cert1.pem - cert2.pem If the Spring Cloud Gateway is not provisioned with trusted certificates, the default trust store is used (which you can override by setting the javax.net.ssl.trustStore system property). TLS Handshake: The gateway maintains a client pool that it uses to route to backends. When communicating over HTTPS, the client initiates a TLS handshake. A number of timeouts are associated with this handshake. You can configure these timeouts can be configured (defaults shown) as follows: application.yml spring: cloud: gateway: httpclient: ssl: handshake-timeout-millis: 10000 close-notify-flush-timeout-millis: 3000 close-notify-read-timeout-millis: 0"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/configuration.html","Configuration: Configuration for Spring Cloud Gateway is driven by a collection of RouteDefinitionLocator instances. The following listing shows the definition of the RouteDefinitionLocator interface: RouteDefinitionLocator.java public interface RouteDefinitionLocator { Flux<RouteDefinition> getRouteDefinitions(); } By default, a PropertiesRouteDefinitionLocator loads properties by using Spring Boot’s @ConfigurationProperties mechanism. The earlier configuration examples all use a shortcut notation that uses positional arguments rather than named ones. The following two examples are equivalent: application.yml spring: cloud: gateway: routes: - id: setstatus_route uri: https://example.org filters: - name: SetStatus args: status: 401 - id: setstatusshortcut_route uri: https://example.org filters: - SetStatus=401 For some usages of the gateway, properties are adequate, but some production use cases benefit from loading configuration from an external source, such as a database. Future milestone versions will have RouteDefinitionLocator implementations based off of Spring Data Repositories, such as Redis, MongoDB, and Cassandra. RouteDefinition Metrics: To enable RouteDefinition metrics, add spring-boot-starter-actuator as a project dependency. Then, by default, the metrics will be available as long as the property spring.cloud.gateway.metrics.enabled is set to true . A gauge metric named spring.cloud.gateway.routes.count will be added, whose value is the number of RouteDefinitions . This metric will be available from /actuator/metrics/spring.cloud.gateway.routes.count ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/route-metadata-configuration.html","Route Metadata Configuration: You can configure additional parameters for each route by using metadata, as follows: application.yml spring: cloud: gateway: routes: - id: route_with_metadata uri: https://example.org metadata: optionName: ""OptionValue"" compositeObject: name: ""value"" iAmNumber: 1 You could acquire all metadata properties from an exchange, as follows: Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR); // get all metadata properties route.getMetadata(); // get a single metadata property route.getMetadata(someKey);"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/http-timeouts-configuration.html","Http timeouts configuration: Http timeouts (response and connect) can be configured for all routes and overridden for each specific route. Global timeouts: To configure Global http timeouts: connect-timeout must be specified in milliseconds. response-timeout must be specified as a java.time.Duration global http timeouts example spring: cloud: gateway: httpclient: connect-timeout: 1000 response-timeout: 5s Per-route timeouts: To configure per-route timeouts: connect-timeout must be specified in milliseconds. response-timeout must be specified in milliseconds. per-route http timeouts configuration via configuration - id: per_route_timeouts uri: https://example.org predicates: - name: Path args: pattern: /delay/{timeout} metadata: response-timeout: 200 connect-timeout: 200 per-route timeouts configuration using Java DSL import static org.springframework.cloud.gateway.support.RouteMetadataUtils.CONNECT_TIMEOUT_ATTR; import static org.springframework.cloud.gateway.support.RouteMetadataUtils.RESPONSE_TIMEOUT_ATTR; @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder routeBuilder){ return routeBuilder.routes() .route(""test1"", r -> { return r.host(""*.somehost.org"").and().path(""/somepath"") .filters(f -> f.addRequestHeader(""header1"", ""header-value-1"")) .uri(""http://someuri"") .metadata(RESPONSE_TIMEOUT_ATTR, 200) .metadata(CONNECT_TIMEOUT_ATTR, 200); }) .build(); } A per-route response-timeout with a negative value will disable the global response-timeout value. - id: per_route_timeouts uri: https://example.org predicates: - name: Path args: pattern: /delay/{timeout} metadata: response-timeout: -1"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/fluent-java-routes-api.html","Fluent Java Routes API: To allow for simple configuration in Java, the RouteLocatorBuilder bean includes a fluent API. The following listing shows how it works: GatewaySampleApplication.java // static imports from GatewayFilters and RoutePredicates @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder, ThrottleGatewayFilterFactory throttle) { return builder.routes() .route(r -> r.host(""**.abc.org"").and().path(""/image/png"") .filters(f -> f.addResponseHeader(""X-TestHeader"", ""foobar"")) .uri(""http://httpbin.org:80"") ) .route(r -> r.path(""/image/webp"") .filters(f -> f.addResponseHeader(""X-AnotherHeader"", ""baz"")) .uri(""http://httpbin.org:80"") .metadata(""key"", ""value"") ) .route(r -> r.order(-1) .host(""**.throttle.org"").and().path(""/get"") .filters(f -> f.filter(throttle.apply(1, 1, 10, TimeUnit.SECONDS))) .uri(""http://httpbin.org:80"") .metadata(""key"", ""value"") ) .build(); } This style also allows for more custom predicate assertions. The predicates defined by RouteDefinitionLocator beans are combined using logical and . By using the fluent Java API, you can use the and() , or() , and negate() operators on the Predicate class."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/the-discoveryclient-route-definition-locator.html","DiscoveryClient Route Definition Locator: You can configure the gateway to create routes based on services registered with a DiscoveryClient compatible service registry. By default, the routes created use the protocol lb://service-name (where service-name is the String that DiscoveryClient::getServices will return) and this means that they are load-balanced. For that reason, you also need to include the org.springframework.cloud:spring-cloud-starter-loadbalancer dependency, so that it is available on the classpath. To enable this, set spring.cloud.gateway.discovery.locator.enabled=true and make sure a DiscoveryClient implementation (such as Netflix Eureka, Consul, Zookeeper or Kubernetes) is on the classpath and enabled. Configuring Predicates and Filters For DiscoveryClient Routes: By default, the gateway defines a single predicate and filter for routes created with a DiscoveryClient . The default predicate is a path predicate defined with the pattern /serviceId/** , where serviceId is the ID of the service from the DiscoveryClient . The default filter is a rewrite path filter with the regex /serviceId/?(?<remaining>.*) and the replacement /${remaining} . This strips the service ID from the path before the request is sent downstream. If you want to customize the predicates or filters used by the DiscoveryClient routes, set spring.cloud.gateway.discovery.locator.predicates[x] and spring.cloud.gateway.discovery.locator.filters[y] . When doing so, you need to make sure to include the default predicate and filter shown earlier, if you want to retain that functionality. The following examples shows what this looks like in properties and yaml format: Example 1. application.properties spring.cloud.gateway.discovery.locator.predicates[0].name=Path spring.cloud.gateway.discovery.locator.predicates[0].args[pattern]=""'/'+serviceId+'/**'"" spring.cloud.gateway.discovery.locator.predicates[1].name=Host spring.cloud.gateway.discovery.locator.predicates[1].args[pattern]=""'**.foo.com'"" spring.cloud.gateway.discovery.locator.filters[0].name=CircuitBreaker spring.cloud.gateway.discovery.locator.filters[0].args[name]=serviceId spring.cloud.gateway.discovery.locator.filters[1].name=RewritePath spring.cloud.gateway.discovery.locator.filters[1].args[regexp]=""'/' + serviceId + '/?(?<remaining>.*)'"" spring.cloud.gateway.discovery.locator.filters[1].args[replacement]=""'/$\{remaining}'"" Example 2. application.yml spring: cloud: gateway: discovery: locator: predicates: - name: Host args: pattern: ""'**.foo.com'"" - name: Path args: pattern: ""'/'+serviceId+'/**'"" filters: - name: CircuitBreaker args: name: serviceId - name: RewritePath args: regexp: ""'/' + serviceId + '/?(?<remaining>.*)'"" replacement: ""'/${remaining}'"""
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/reactor-netty-access-logs.html","Reactor Netty Access Logs: To enable Reactor Netty access logs, set -Dreactor.netty.http.server.accessLogEnabled=true . It must be a Java System Property, not a Spring Boot property. You can configure the logging system to have a separate access log file. The following example creates a Logback configuration: logback.xml <appender name=""accessLog"" class=""ch.qos.logback.core.FileAppender""> <file>access_log.log</file> <encoder> <pattern>%msg%n</pattern> </encoder> </appender> <appender name=""async"" class=""ch.qos.logback.classic.AsyncAppender""> <appender-ref ref=""accessLog"" /> </appender> <logger name=""reactor.netty.http.server.AccessLog"" level=""INFO"" additivity=""false""> <appender-ref ref=""async""/> </logger>"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/cors-configuration.html","CORS Configuration: You can configure the gateway to control CORS behavior globally or per route. Both offer the same possibilities. Global CORS Configuration: The “global” CORS configuration is a map of URL patterns to Spring Framework CorsConfiguration(https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/cors/CorsConfiguration.html) . The following example configures CORS: application.yml spring: cloud: gateway: globalcors: cors-configurations: '[/**]': allowedOrigins: ""https://docs.spring.io"" allowedMethods: - GET In the preceding example, CORS requests are allowed from requests that originate from docs.spring.io for all GET requested paths. To provide the same CORS configuration to requests that are not handled by some gateway route predicate, set the spring.cloud.gateway.globalcors.add-to-simple-url-handler-mapping property to true . This is useful when you try to support CORS preflight requests and your route predicate does not evaluate to true because the HTTP method is options . Route CORS Configuration: The “route” configuration allows applying CORS directly to a route as metadata with key cors . Like in the case of global configuration, the properties belong to Spring Framework CorsConfiguration(https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/cors/CorsConfiguration.html) . If no Path predicate is present in the route '/**' will be applied. application.yml spring: cloud: gateway: routes: - id: cors_route uri: https://example.org predicates: - Path=/service/** metadata: cors: allowedOrigins: '*' allowedMethods: - GET - POST allowedHeaders: '*' maxAge: 30"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/actuator-api.html","Actuator API: The /gateway actuator endpoint lets you monitor and interact with a Spring Cloud Gateway application. To be remotely accessible, the endpoint has to be enabled(https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-enabling-endpoints) and exposed over HTTP or JMX(https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-exposing-endpoints) in the application properties. The following listing shows how to do so: application.properties management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway This endpoint provides an overview of what is available on the child actuator endpoint and the available methods for each reference. The resulting response is similar to the following: [ { ""href"":""/actuator/gateway/"", ""methods"":[ ""GET"" ] }, { ""href"":""/actuator/gateway/routedefinitions"", ""methods"":[ ""GET"" ] }, { ""href"":""/actuator/gateway/globalfilters"", ""methods"":[ ""GET"" ] }, { ""href"":""/actuator/gateway/routefilters"", ""methods"":[ ""GET"" ] }, { ""href"":""/actuator/gateway/routes"", ""methods"":[ ""POST"", ""GET"" ] }, { ""href"":""/actuator/gateway/routepredicates"", ""methods"":[ ""GET"" ] }, { ""href"":""/actuator/gateway/refresh"", ""methods"":[ ""POST"" ] }, { ""href"":""/actuator/gateway/routes/route-id-1/combinedfilters"", ""methods"":[ ""GET"" ] }, { ""href"":""/actuator/gateway/routes/route-id-1"", ""methods"":[ ""POST"", ""DELETE"", ""GET"" ] } ] Verbose Actuator Format: A new, more verbose format has been added to Spring Cloud Gateway. It adds more detail to each route, letting you view the predicates and filters associated with each route along with any configuration that is available. The following example configures /actuator/gateway/routes : [ { ""predicate"": ""(Hosts: [**.addrequestheader.org] && Paths: [/headers], match trailing slash: true)"", ""route_id"": ""add_request_header_test"", ""filters"": [ ""[[AddResponseHeader X-Response-Default-Foo = 'Default-Bar'], order = 1]"", ""[[AddRequestHeader X-Request-Foo = 'Bar'], order = 1]"", ""[[PrefixPath prefix = '/httpbin'], order = 2]"" ], ""uri"": ""lb://testservice"", ""order"": 0 } ] This feature is enabled by default. To disable it, set the following property: application.properties spring.cloud.gateway.actuator.verbose.enabled=false This will default to true in a future release. Retrieving Route Filters: This section details how to retrieve route filters, including: Global Filters(#gateway-global-filters) Route Filters(#gateway-route-filters) Global Filters: To retrieve the global filters(global-filters.html) applied to all routes, make a GET request to /actuator/gateway/globalfilters . The resulting response is similar to the following: { ""org.springframework.cloud.gateway.filter.ReactiveLoadBalancerClientFilter@77856cc5"": 10100, ""org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter@4f6fd101"": 10000, ""org.springframework.cloud.gateway.filter.NettyWriteResponseFilter@32d22650"": -1, ""org.springframework.cloud.gateway.filter.ForwardRoutingFilter@106459d9"": 2147483647, ""org.springframework.cloud.gateway.filter.NettyRoutingFilter@1fbd5e0"": 2147483647, ""org.springframework.cloud.gateway.filter.ForwardPathFilter@33a71d23"": 0, ""org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter@135064ea"": 2147483637, ""org.springframework.cloud.gateway.filter.WebsocketRoutingFilter@23c05889"": 2147483646 } The response contains the details of the global filters that are in place. For each global filter, there is a string representation of the filter object (for example, org.springframework.cloud.gateway.filter.ReactiveLoadBalancerClientFilter@77856cc5 ) and the corresponding order(global-filters.html#gateway-combined-global-filter-and-gatewayfilter-ordering) in the filter chain. Route Filters: To retrieve the GatewayFilter factories(gatewayfilter-factories.html) applied to routes, make a GET request to /actuator/gateway/routefilters . The resulting response is similar to the following: { ""[AddRequestHeaderGatewayFilterFactory@570ed9c configClass = AbstractNameValueGatewayFilterFactory.NameValueConfig]"": null, ""[SecureHeadersGatewayFilterFactory@fceab5d configClass = Object]"": null, ""[SaveSessionGatewayFilterFactory@4449b273 configClass = Object]"": null } The response contains the details of the GatewayFilter factories applied to any particular route. For each factory there is a string representation of the corresponding object (for example, [SecureHeadersGatewayFilterFactory@fceab5d configClass = Object] ). Note that the null value is due to an incomplete implementation of the endpoint controller, because it tries to set the order of the object in the filter chain, which does not apply to a GatewayFilter factory object. Refreshing the Route Cache: To clear the routes cache, make a POST request to /actuator/gateway/refresh . The request returns a 200 without a response body. To clear the routes with specific metadata values, add the Query parameter metadata specifying the key:value pairs that the routes to be cleared should match. If an error is produced during the asynchronous refresh, the refresh will not modify the existing routes. Sending POST request to /actuator/gateway/refresh?metadata=group:group-1 will only refresh the routes whose group metadata is group-1 : first_route and third_route . [{ ""route_id"": ""first_route"", ""route_object"": { ""predicate"": ""..."", }, ""metadata"": { ""group"": ""group-1"" } }, { ""route_id"": ""second_route"", ""route_object"": { ""predicate"": ""..."", }, ""metadata"": { ""group"": ""group-2"" } }, { ""route_id"": ""third_route"", ""route_object"": { ""predicate"": ""..."", }, ""metadata"": { ""group"": ""group-1"" } }] Retrieving the Routes Defined in the Gateway: To retrieve the routes defined in the gateway, make a GET request to /actuator/gateway/routes . The resulting response is similar to the following: [{ ""route_id"": ""first_route"", ""route_object"": { ""predicate"": ""org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$432/1736826640@1e9d7e7d"", ""filters"": [ ""OrderedGatewayFilter{delegate=org.springframework.cloud.gateway.filter.factory.PreserveHostHeaderGatewayFilterFactory$$Lambda$436/674480275@6631ef72, order=0}"" ] }, ""order"": 0 }, { ""route_id"": ""second_route"", ""route_object"": { ""predicate"": ""org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$432/1736826640@cd8d298"", ""filters"": [] }, ""order"": 0 }] The response contains the details of all the routes defined in the gateway. The following table describes the structure of each element (each is a route) of the response: Path Type Description route_id String The route ID. route_object.predicate Object The route predicate. route_object.filters Array The GatewayFilter factories(gatewayfilter-factories.html) applied to the route. order Number The route order. Retrieving Information about a Particular Route: To retrieve information about a single route, make a GET request to /actuator/gateway/routes/{id} (for example, /actuator/gateway/routes/first_route ). The resulting response is similar to the following: { ""id"": ""first_route"", ""predicates"": [{ ""name"": ""Path"", ""args"": {""_genkey_0"":""/first""} }], ""filters"": [], ""uri"": ""https://www.uri-destination.org"", ""order"": 0 } The following table describes the structure of the response: Path Type Description id String The route ID. predicates Array The collection of route predicates. Each item defines the name and the arguments of a given predicate. filters Array The collection of filters applied to the route. uri String The destination URI of the route. order Number The route order. Creating and Deleting a Particular Route Definition: To create a route definition, make a POST request to /gateway/routes/{id_route_to_create} with a JSON body that specifies the fields of the route (see Retrieving Information about a Particular Route(#gateway-retrieving-information-about-a-particular-route) ). To delete a route definition, make a DELETE request to /gateway/routes/{id_route_to_delete} . Creating multiple Route Definitions: To create multiple route definitions in a single request, make a POST request to /gateway/routes with a JSON body that specifies the fields of the route, including the route id (see Retrieving Information about a Particular Route(#gateway-retrieving-information-about-a-particular-route) ). The route definitions will be discarded if any route raises an error during the creation of the routes. Recap: The List of All endpoints: The following table below summarizes the Spring Cloud Gateway actuator endpoints (note that each endpoint has /actuator/gateway as the base-path): ID HTTP Method Description globalfilters GET Displays the list of global filters applied to the routes. routefilters GET Displays the list of GatewayFilter factories applied to a particular route. refresh POST Clears the routes cache. routes GET Displays the list of routes defined in the gateway. routes/{id} GET Displays information about a particular route. routes/{id} POST Adds a new route to the gateway. routes/{id} DELETE Removes an existing route from the gateway."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/sharing-routes.html","Sharing Routes between multiple Gateway instances: Spring Cloud Gateway offers two RouteDefinitionRepository implementations. The first one is the InMemoryRouteDefinitionRepository which only lives within the memory of one Gateway instance. This type of Repository is not suited to populate Routes across multiple Gateway instances. In order to share Routes across a cluster of Spring Cloud Gateway instances, RedisRouteDefinitionRepository can be used. To enable this kind of repository, the following property has to set to true: spring.cloud.gateway.redis-route-definition-repository.enabled Likewise to the RedisRateLimiter Filter Factory it requires the use of the spring-boot-starter-data-redis-reactive Spring Boot starter."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/troubleshooting.html","Troubleshooting: This section covers common problems that may arise when you use Spring Cloud Gateway. Log Levels: The following loggers may contain valuable troubleshooting information at the DEBUG and TRACE levels: org.springframework.cloud.gateway org.springframework.http.server.reactive org.springframework.web.reactive org.springframework.boot.autoconfigure.web reactor.netty redisratelimiter Wiretap: The Reactor Netty HttpClient and HttpServer can have wiretap enabled. When combined with setting the reactor.netty log level to DEBUG or TRACE , it enables the logging of information, such as headers and bodies sent and received across the wire. To enable wiretap, set spring.cloud.gateway.httpserver.wiretap=true or spring.cloud.gateway.httpclient.wiretap=true for the HttpServer and HttpClient , respectively."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/developer-guide.html","Developer Guide: These are basic guides to writing some custom components of the gateway. Writing Custom Route Predicate Factories: In order to write a Route Predicate you will need to implement RoutePredicateFactory as a bean. There is an abstract class called AbstractRoutePredicateFactory which you can extend. MyRoutePredicateFactory.java @Component public class MyRoutePredicateFactory extends AbstractRoutePredicateFactory<MyRoutePredicateFactory.Config> { public MyRoutePredicateFactory() { super(Config.class); } @Override public Predicate<ServerWebExchange> apply(Config config) { // grab configuration from Config object return exchange -> { //grab the request ServerHttpRequest request = exchange.getRequest(); //take information from the request to see if it //matches configuration. return matches(config, request); }; } public static class Config { //Put the configuration properties for your filter here } } Writing Custom GatewayFilter Factories: To write a GatewayFilter , you must implement GatewayFilterFactory as a bean. You can extend an abstract class called AbstractGatewayFilterFactory . The following examples show how to do so: Example 1. PreGatewayFilterFactory.java @Component public class PreGatewayFilterFactory extends AbstractGatewayFilterFactory<PreGatewayFilterFactory.Config> { public PreGatewayFilterFactory() { super(Config.class); } @Override public GatewayFilter apply(Config config) { // grab configuration from Config object return (exchange, chain) -> { //If you want to build a ""pre"" filter you need to manipulate the //request before calling chain.filter ServerHttpRequest.Builder builder = exchange.getRequest().mutate(); //use builder to manipulate the request return chain.filter(exchange.mutate().request(builder.build()).build()); }; } public static class Config { //Put the configuration properties for your filter here } } PostGatewayFilterFactory.java @Component public class PostGatewayFilterFactory extends AbstractGatewayFilterFactory<PostGatewayFilterFactory.Config> { public PostGatewayFilterFactory() { super(Config.class); } @Override public GatewayFilter apply(Config config) { // grab configuration from Config object return (exchange, chain) -> { return chain.filter(exchange).then(Mono.fromRunnable(() -> { ServerHttpResponse response = exchange.getResponse(); //Manipulate the response in some way })); }; } public static class Config { //Put the configuration properties for your filter here } } Naming Custom Filters And References In Configuration: Custom filters class names should end in GatewayFilterFactory . For example, to reference a filter named Something in configuration files, the filter must be in a class named SomethingGatewayFilterFactory . It is possible to create a gateway filter named without the GatewayFilterFactory suffix, such as class AnotherThing . This filter could be referenced as AnotherThing in configuration files. This is not a supported naming convention and this syntax may be removed in future releases. Please update the filter name to be compliant. Writing Custom Global Filters: To write a custom global filter, you must implement GlobalFilter interface as a bean. This applies the filter to all requests. The following examples show how to set up global pre- and post-filters, respectively: @Bean public GlobalFilter customGlobalFilter() { return (exchange, chain) -> exchange.getPrincipal() .map(Principal::getName) .defaultIfEmpty(""Default User"") .map(userName -> { //adds header to proxied request exchange.getRequest().mutate().header(""CUSTOM-REQUEST-HEADER"", userName).build(); return exchange; }) .flatMap(chain::filter); } @Bean public GlobalFilter customGlobalPostFilter() { return (exchange, chain) -> chain.filter(exchange) .then(Mono.just(exchange)) .map(serverWebExchange -> { //adds header to response serverWebExchange.getResponse().getHeaders().set(""CUSTOM-RESPONSE-HEADER"", HttpStatus.OK.equals(serverWebExchange.getResponse().getStatusCode()) ? ""It worked"": ""It did not work""); return serverWebExchange; }) .then(); }"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/aot-and-native-image-support.html","AOT and Native Image Support: Since 4.0.0 , Spring Cloud Gateway supports Spring AOT transformations and native images. If you’re using load-balanced routes, you need to explicitly define your LoadBalancerClient service IDs. You can do so by using the value or name attributes of the @LoadBalancerClient annotation or as values of the spring.cloud.loadbalancer.eager-load.clients property."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/configuration-properties.html","Configuration properties: To see the list of all Spring Cloud Gateway related configuration properties, see the appendix(appendix.html) ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc.html","Spring Cloud Gateway Server MVC:"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/starter.html","How to Include Spring Cloud Gateway Server MVC: To include Spring Cloud Gateway Server MVC in your project, use the starter with a group ID of org.springframework.cloud and an artifact ID of spring-cloud-starter-gateway-mvc . See the Spring Cloud Project page(https://projects.spring.io/spring-cloud/) for details on setting up your build system with the current Spring Cloud Release Train. If you include the starter, but you do not want the gateway to be enabled, set spring.cloud.gateway.mvc.enabled=false . Spring Cloud Gateway Server MVC is built on Spring Boot(https://spring.io/projects/spring-boot#learn) and Spring WebMvc.fn(https://docs.spring.io/spring-framework/reference/web/webmvc-functional.html) . As a consequence, many of the asynchronous or reactive libraries may not apply when you use Spring Cloud Gateway Server MVC. Spring Cloud Gateway Server MVC works with traditional Servlet runtimes such as Tomcat and Jetty."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/glossary.html","Glossary: Route : The basic building block of the gateway. It is defined by an ID, a destination URI, a collection of predicates, and a collection of filters. A route is matched if the aggregate predicate is true. Predicate : This is a Spring WebMvc.fn RequestPredicate(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RequestPredicate.html) . The input type is a Spring WebMvc.fn ServerRequest(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/ServerRequest.html) . This lets you match on anything from the HTTP request, such as headers or parameters. Filter : These are instances of HandlerFilterFunction(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/HandlerFilterFunction.html) . Here, you can modify requests and responses before or after sending the downstream request. Filters may also implement Function<ServerRequest, ServerRequest> and adapted to a HandlerFilterFunction by HandlerFilterFunction.ofRequestProcessor()(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/HandlerFilterFunction.html#ofRequestProcessor(java.util.function.Function)) for 'before' filters. For 'after' filters, BiFunction<ServerRequest,T extends ServerResponse,R extends ServerResponse> may be implemented and adapted by HandlerFilterFunction.ofResponseProcessor()(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/HandlerFilterFunction.html#ofResponseProcessor(java.util.function.BiFunction)) ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/how-it-works.html","How It Works: The following diagram provides a high-level overview of how Spring Cloud Gateway works: In Spring Cloud Gateway Server MVC routes are normal WebMvc.fn RouterFunction instances with a special HandlerFunction(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/HandlerFunction.html) to forward the requests over HTTP defined in org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions(https://github.com/spring-cloud/spring-cloud-gateway/blob/main/spring-cloud-gateway-server-mvc/src/main/java/org/springframework/cloud/gateway/server/mvc/handler/HandlerFunctions.java) . Please see the WebMvc.fn(https://docs.spring.io/spring-framework/reference/web/webmvc-functional.html) documentation for regular use of the functional API. In addition to custom HandlerFunctions for HTTP forwarding, Spring Cloud Gateway Server MVC provides additional RequestPredicate implementations in org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates(https://github.com/spring-cloud/spring-cloud-gateway/blob/main/spring-cloud-gateway-server-mvc/src/main/java/org/springframework/cloud/gateway/server/mvc/predicate/GatewayRequestPredicates.java) and HandlerFilterFunctions implementations in org.springframework.cloud.gateway.server.mvc.filter.FilterFunctions(https://github.com/spring-cloud/spring-cloud-gateway/blob/main/spring-cloud-gateway-server-mvc/src/main/java/org/springframework/cloud/gateway/server/mvc/filter/FilterFunctions.java) . All the custom filters that can be pure 'before' filters are implemented in org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions(https://github.com/spring-cloud/spring-cloud-gateway/blob/main/spring-cloud-gateway-server-mvc/src/main/java/org/springframework/cloud/gateway/server/mvc/filter/BeforeFilterFunctions.java) and adapted in FilterFunctions as request processors. The custom 'after' filters in org.springframework.cloud.gateway.server.mvc.filter.AfterFilterFunctions(https://github.com/spring-cloud/spring-cloud-gateway/blob/main/spring-cloud-gateway-server-mvc/src/main/java/org/springframework/cloud/gateway/server/mvc/filter/AfterFilterFunctions.java) are also adapted in FilterFunctions as response processors. There are additional *FilterFunctions classes for optional filters that will are documented along with each filter. Any path defined on a route URI will be ignored."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/java-routes-api.html","Java Routes API: Spring Cloud Gateway Server MVC uses the Spring WebMvc.fn RouterFunctions.Builder(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RouterFunctions.Builder.html) as the default way to create Routes, which are WebMvc.fn RouterFunction(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RouterFunction.html) instances. A RouterFunctions.Builder(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RouterFunctions.Builder.html) instance is obtained by calling RouterFunctions.route()(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RouterFunctions.html#route()) GatewaySampleApplication.java import static org.springframework.web.servlet.function.RouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; class SimpleGateway { @Bean public RouterFunction<ServerResponse> getRoute() { return route().GET(""/get"", http(""https://httpbin.org"")).build(); } } There are methods in RouterFunctions.Builder for each HTTP methods (GET, POST, etc…​) combined with a path predicate, such as /get as above. The final parameter is the HandlerFilterFunction , in this case HandlerFunctions.http() . There are overloaded methods for each HTTP method for additional RequestPredicate parameters as well as a generic route(RequestPredicate, HandlerFunction ) method for general use. Gateway MVC implementation of RouterFunctions.Builder: Some advanced filters require some metadata to be added to request attributes. To accommodate this, there is a org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions class. GatewayRouterFunctions.route(String routeId) creates a `RouterFunctions.Builder instance then adds a 'before' filter to add the routeId as request metadata. GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; class SimpleGateway { @Bean public RouterFunction<ServerResponse> getRoute() { return route(""simple_route"").GET(""/get"", http(""https://httpbin.org"")).build(); } } Gateway MVC Handler Functions: Various RouterFunctions.Builder methods require a HandlerFunction<ServerResponse> . To create a route that is proxied by the MVC Gateway, HandlerFunction implementations are supplied in org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions . The most basic is the http() HandlerFunction . If a URI is supplied as a parameter, that is the URI used as the downstream target for sending the HTTP requests (as seen in the example above). If no parameter is passed, the function looks for a URI in the org.springframework.cloud.gateway.server.mvc.common.MvcUtils.GATEWAY_REQUEST_URL_ATTR request attribute. This allows for dynamic targets such as load balancing to set the URI ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/gateway-request-predicates.html","Gateway Request Predicates: Spring Cloud Gateway MVC matches routes as part of the Spring WebMvc.fn HandlerMapping infrastructure. Spring Cloud Gateway reuses many RequestPredicate(https://docs.spring.io/spring-framework/reference/web/webmvc-functional.html#webmvc-fn-predicates) implementations from WebMvc.fn and includes other custom RequestPredicate implementations All of these predicates match on different attributes of the HTTP request. You can combine multiple route predicate factories with the RequestPredicate.and() and RequestPredicate.or() methods. The After Request Predicate: The After route predicate factory takes one parameter, a datetime (which is a java ZonedDateTime ). This predicate matches requests that happen after the specified datetime. The following example configures an after route predicate: application.yml spring: cloud: gateway: mvc: routes: - id: after_route uri: https://example.org predicates: - After=2017-01-20T17:42:47.789-07:00[America/Denver] GatewaySampleApplication.java import java.time.ZonedDateTime; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.after; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAfter() { return route(""after_route"") .route(after(ZonedDateTime.parse(""2017-01-20T17:42:47.789-07:00[America/Denver]"")), http(""https://example.org"")) .build(); } } This route matches any request made after Jan 20, 2017 17:42 Mountain Time (Denver). The Before Request Predicate: The Before route predicate factory takes one parameter, a datetime (which is a java ZonedDateTime ). This predicate matches requests that happen before the specified datetime . The following example configures a before route predicate: application.yml spring: cloud: gateway: mvc: routes: - id: before_route uri: https://example.org predicates: - Before=2017-01-20T17:42:47.789-07:00[America/Denver] GatewaySampleApplication.java import java.time.ZonedDateTime; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.before; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsBefore() { return route(""before_route"") .route(before(ZonedDateTime.parse(""2017-01-20T17:42:47.789-07:00[America/Denver]"")), http(""https://example.org"")) .build(); } } This route matches any request made before Jan 20, 2017 17:42 Mountain Time (Denver). The Between Request Predicate: The Between route predicate factory takes two parameters, datetime1 and datetime2 which are java ZonedDateTime objects. This predicate matches requests that happen after datetime1 and before datetime2 . The datetime2 parameter must be after datetime1 . The following example configures a between route predicate: application.yml spring: cloud: gateway: mvc: routes: - id: between_route uri: https://example.org predicates: - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver] GatewaySampleApplication.java import java.time.ZonedDateTime; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.between; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsBetween() { return route(""between_route"") .route(between(ZonedDateTime.parse(""2017-01-20T17:42:47.789-07:00[America/Denver]""), ZonedDateTime.parse(""2017-01-21T17:42:47.789-07:00[America/Denver]"")), http(""https://example.org"")) .build(); } } This route matches any request made after Jan 20, 2017 17:42 Mountain Time (Denver) and before Jan 21, 2017 17:42 Mountain Time (Denver). This could be useful for maintenance windows. The Cookie Request Predicate: The Cookie route predicate factory takes two parameters, the cookie name and a regexp (which is a Java regular expression). This predicate matches cookies that have the given name and whose values match the regular expression. The following example configures a cookie route predicate factory: application.yml spring: cloud: gateway: mvc: routes: - id: cookie_route uri: https://example.org predicates: - Cookie=chocolate, ch.p GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.between; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsCookie() { return route(""cookie_route"") .route(cookie(""chocolate"", ""ch.p""), http(""https://example.org"")) .build(); } } This route matches requests that have a cookie named chocolate whose value matches the ch.p regular expression. The Header Request Predicate: The Header route predicate factory takes two parameters, the header and a regexp (which is a Java regular expression). This predicate matches with a header that has the given name whose value matches the regular expression. The following example configures a header route predicate: application.yml spring: cloud: gateway: mvc: routes: - id: header_route uri: https://example.org predicates: - Header=X-Request-Id, \d+ GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.header; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsCookie() { return route(""cookie_route"") .route(header(""X-Request-Id"", ""\\d+""), http(""https://example.org"")) .build(); } } This route matches if the request has a header named X-Request-Id whose value matches the \d+ regular expression (that is, it has a value of one or more digits). The Host Request Predicate: The Host route predicate factory takes one parameter: a list of host name patterns . The pattern is an Ant-style pattern with . as the separator. This predicates matches the Host header that matches the pattern. The following example configures a host route predicate: application.yml spring: cloud: gateway: mvc: routes: - id: host_route uri: https://example.org predicates: - Host=**.somehost.org,**.anotherhost.org GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.host; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsHost() { return route(""host_route"") .route(host(""**.somehost.org"", ""**.anotherhost.org""), http(""https://example.org"")) .build(); } } URI template variables (such as {sub}.myhost.org ) are supported as well. This route matches if the request has a Host header with a value of www.somehost.org or beta.somehost.org or www.anotherhost.org . This predicate extracts the URI template variables (such as sub , defined in the preceding example) as a map of names and values and places it in the ServerRequest.attributes() with a key defined in MvcUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE . Those values are then available for use by Gateway Handler Filter Functions. The Method Request Predicate: The Method Request Predicate takes a methods argument which is one or more parameters: the HTTP methods to match. The following example configures a method route predicate: application.yml spring: cloud: gateway: mvc: routes: - id: method_route uri: https://example.org predicates: - Method=GET,POST GatewaySampleApplication.java import org.springframework.http.HttpMethod; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.method; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsMethod() { return route(""method_route"") .route(method(HttpMethod.GET, HttpMethod.POST), http(""https://example.org"")) .build(); } } This route matches if the request method was a GET or a POST . GatewayRequestPredicates.method is a simple alias for RequestPredicates.methods(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RequestPredicates.html#methods(org.springframework.http.HttpMethod…​)) . Also, the RouterFunctions.Builder API includes convenience methods that combine the method and path RequestPredicates . GatewaySampleApplication.java import org.springframework.http.HttpMethod; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.methods; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsMethod() { return route(""method_route"") .GET(""/mypath"", http(""https://example.org"")) .build(); } } This route matches if the request method was a GET and the path was /mypath . The Path Request Predicate: The Path Request Predicate takes two parameters: a list of Spring PathPattern patterns . This Request Predicate uses RequestPredicates.path()(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RequestPredicates.html#path(java.lang.String)) as the underlying implementation. The following example configures a path route predicate: application.yml spring: cloud: gateway: mvc: routes: - id: path_route uri: https://example.org predicates: - Path=/red/{segment},/blue/{segment} GatewaySampleApplication.java import org.springframework.http.HttpMethod; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.method; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsPath() { return route(""path_route"") .route(path(""/red/{segment}"", ""/blue/{segment}""), http(""https://example.org"")) .build(); } } This route matches if the request path was, for example: /red/1 or /red/1/ or /red/blue or /blue/green . This predicate extracts the URI template variables (such as segment , defined in the preceding example) as a map of names and values and places it in the ServerRequest.attributes() with a key defined in RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE . Those values are then available for use by Gateway Handler Filter Functions. A utility method (called get ) is available to make access to these variables easier. The following example shows how to use the get method: Map<String, Object> uriVariables = MvcUtils.getUriTemplateVariables(request); String segment = uriVariables.get(""segment""); The Query Request Predicate: The Query route predicate factory takes two parameters: a required param and an optional regexp (which is a Java regular expression). The following example configures a query route predicate: application.yml spring: cloud: gateway: mvc: routes: - id: query_route uri: https://example.org predicates: - Query=green GatewaySampleApplication.java import org.springframework.http.HttpMethod; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.query; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsQuery() { return route(""query_route"") .route(query(""green""), http(""https://example.org"")) .build(); } } The preceding route matches if the request contained a green query parameter. application.yml spring: cloud: gateway: mvc: routes: - id: query_route uri: https://example.org predicates: - Query=red, gree. GatewaySampleApplication.java import org.springframework.http.HttpMethod; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.query; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsQuery() { return route(""query_route"") .route(query(""red"", ""gree.""), http(""https://example.org"")) .build(); } } The preceding route matches if the request contained a red query parameter whose value matched the gree. regexp, so green and greet would match. The Weight Request Predicate: The Weight route predicate factory takes two arguments: group and weight (an int ). The weights are calculated per group. The following example configures a weight route predicate: application.yml spring: cloud: gateway: mvc: routes: - id: weight_high uri: https://weighthigh.org predicates: - Weight=group1, 8 - id: weight_low uri: https://weightlow.org predicates: - Weight=group1, 2 GatewaySampleApplication.java import org.springframework.http.HttpMethod; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.method; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsWeights() { return route(""weight_high"") .route(weight(""group1"", 8).and(path(""/**"")), http(""https://weighthigh.org"")) .build().and( route(""weight_low"") .route(weight(""group1"", 2).and(path(""/**"")), http(""https://weightlow.org"")) .build()); } } This route would forward ~80% of traffic to weighthigh.org(https://weighthigh.org) and ~20% of traffic to weightlow.org(https://weightlow.org) ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/gateway-handler-filter-functions.html","Gateway Handler Filter Functions: Before Filter Functions: The WebMvc.fn API has the concept of a ""before"" filter function, a java.util.Function<ServerRequest, ServerRequest> that only acts on the request. Many before filter functions are referenced in org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions as static factory methods. They are adapted to generic org.springframework.web.servlet.function.HandlerFilterFunction<ServerResponse, ServerResponse> in org.springframework.cloud.gateway.server.mvc.filter.FilterFunctions . Either may be used, but the more specific BeforeFilterFunctions is preferred, where possible, as it is more explicit. After Filter Functions: The WebMvc.fn API has the concept of a ""after"" filter function, a java.util.BiFunction<ServerRequest, ServerResponse, ServerResponse> that can modify the response. Many after filter functions are referenced in org.springframework.cloud.gateway.server.mvc.filter.AfterFilterFunctions as static factory methods. They are adapted to generic org.springframework.web.servlet.function.HandlerFilterFunction<ServerResponse, ServerResponse> in org.springframework.cloud.gateway.server.mvc.filter.FilterFunctions . Either may be used, but the more specific AfterFilterFunctions is preferred, where possible, as it is more explicit. Advanced Filter Functions: Some filters can not be classified as a simple before or after filter. These filters do work both prior to and after the proxy request has been made. Some of these include filters located in BodyFilterFunctions , Bucket4jFilterFunctions, `CircuitBreakerFilterFunctions , LoadBalancerFilterFunctions , RetryFilterFunctions , and TokenRelayFilterFunctions , all located in the org.springframework.cloud.gateway.server.mvc.filter package."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/addrequestheader.html","AddRequestHeader Filter: The AddRequestHeader is a ""before"" filter that takes a name and value parameter. The following example configures an AddRequestHeader filter: application.yml spring: cloud: gateway: mvc: routes: - id: add_request_header_route uri: https://example.org filters: - AddRequestHeader=X-Request-red, blue GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.addRequestHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddReqHeader() { return route(GET(""/red""), http(""https://example.org"")) .before(addRequestHeader(""X-Request-red"", ""blue"")); } } This listing adds X-Request-red:blue header to the downstream request’s headers for all matching requests. AddRequestHeader is aware of the URI variables used to match a path or host. URI variables may be used in the value and are expanded at runtime. The following example configures an AddRequestHeader filter that uses a variable: GatewaySampleApplication.java @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddReqHeader() { return route(GET(""/red/{segment}""), http(""https://example.org"")) .before(addRequestHeader(""X-Request-red"", ""blue-{segment}"")); } }"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/addrequestheadersifnotpresent.html","AddRequestHeadersIfNotPresent Filter: The AddRequestHeadersIfNotPresent filter takes a collection of name and value pairs separated by colon. The following example configures an AddRequestHeadersIfNotPresent filter: application.yml spring: cloud: gateway: mvc: routes: - id: add_request_headers_route uri: https://example.org filters: - AddRequestHeadersIfNotPresent=X-Request-Color-1:blue,X-Request-Color-2:green GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.addRequestHeadersIfNotPresent; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddReqHeader() { return route(GET(""/red""), http(""https://example.org"")) .before(addRequestHeadersIfNotPresent(""X-Request-Color-1:blue"",""X-Request-Color-2:green"")); } } This listing adds 2 headers X-Request-Color-1:blue and X-Request-Color-2:green to the downstream request’s headers for all matching requests. This is similar to how AddRequestHeader works, but unlike AddRequestHeader it will do it only if the header is not already there. Otherwise, the original value in the client request is sent. Additionally, to set a multi-valued header, use the header name multiple times like addRequestHeadersIfNotPresent(""X-Request-Color-1:blue"",""X-Request-Color-1:green"") . AddRequestHeadersIfNotPresent also supports URI variables used to match a path or host. URI variables may be used in the value and are expanded at runtime. The following example configures an AddRequestHeadersIfNotPresent filter that uses a variable: GatewaySampleApplication.java @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddReqHeader() { return route(GET(""/red/{segment}""), http(""https://example.org"")) .before(addRequestHeadersIfNotPresent(""X-Request-red"", ""blue-{segment}"")); } } application.yml spring: cloud: gateway: routes: - id: add_request_header_route uri: https://example.org predicates: - Path=/red/{segment} filters: - AddRequestHeadersIfNotPresent=X-Request-Red:Blue-{segment}"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/addrequestparameter.html","AddRequestParameter Filter: The AddRequestParameter Filter takes a name and value parameter. The following example configures an AddRequestParameter filter: application.yml spring: cloud: gateway: mvc: routes: - id: add_request_parameter_route uri: https://example.org filters: - AddRequestParameter=red, blue GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.addRequestParameter; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddReqHeader() { return route(""add_request_parameter_route"") .GET(""/anything/addrequestparam"", http(""https://example.org"")) .before(addRequestParameter(""red"", ""blue"")) .build(); } } This will add red=blue to the downstream request’s query string for all matching requests. AddRequestParameter is aware of the URI variables used to match a path or host. URI variables may be used in the value and are expanded at runtime. The following example configures an AddRequestParameter filter that uses a variable: GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.addRequestParameter; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.host; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddReqHeader() { return route(""add_request_parameter_route"") .route(host(""{segment}.myhost.org""), http(""https://example.org"")) .before(addRequestParameter(""foo"", ""bar-{segment}"")) .build(); } }"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/addresponseheader.html","AddResponseHeader Filter: The AddResponseHeader Filter takes a name and value parameter. The following example configures an AddResponseHeader filter: application.yml spring: cloud: gateway: mvc: routes: - id: add_response_header_route uri: https://example.org filters: - AddResponseHeader=X-Response-Red, Blue GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.AfterFilterFunctions.addResponseHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddRespHeader() { return route(""addresponseheader"") .GET(""/anything/addresheader"", http(""https://example.org"")) .after(addResponseHeader(""X-Response-Red"", ""Blue"")) .build(); } } This adds X-Response-Red:Blue header to the downstream response’s headers for all matching requests. AddResponseHeader is aware of URI variables used to match a path or host. URI variables may be used in the value and are expanded at runtime. The following example configures an AddResponseHeader filter that uses a variable: GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.AfterFilterFunctions.addResponseHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.host; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddRespHeader() { return route(""add_response_header_route"") .route(host(""{segment}.myhost.org""), http(""https://example.org"")) .after(addResponseHeader(""foo"", ""bar-{segment}"")) .build(); } }"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/circuitbreaker-filter.html","CircuitBreaker Filter: The Spring Cloud CircuitBreaker GatewayFilter factory uses the Spring Cloud CircuitBreaker APIs to wrap Gateway routes in a circuit breaker. Spring Cloud CircuitBreaker supports multiple libraries that can be used with Spring Cloud Gateway. Spring Cloud supports Resilience4J out of the box. To enable the Spring Cloud CircuitBreaker filter, you need to place spring-cloud-starter-circuitbreaker-reactor-resilience4j on the classpath. The following example configures a Spring Cloud CircuitBreaker filter: application.yml spring: cloud: gateway: mvc: routes: - id: circuitbreaker_route uri: https://example.org filters: - CircuitBreaker=myCircuitBreaker GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.CircuitBreakerFilterFunctions.circuitBreaker; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsCircuitBreakerNoFallback() { return route(""circuitbreakernofallback"") .route(path(""/anything/circuitbreakernofallback""), http(""https://example.org"")) .filter(circuitBreaker(""mycb3"")) .build(); } } To configure the circuit breaker, see the configuration for the underlying circuit breaker implementation you are using. Resilience4J Documentation(https://cloud.spring.io/spring-cloud-circuitbreaker/reference/html/spring-cloud-circuitbreaker.html) The Spring Cloud CircuitBreaker filter can also accept an optional fallbackUri parameter. Currently, only forward: schemed URIs are supported. If the fallback is called, the request is forwarded to the controller matched by the URI. The following example configures such a fallback: application.yml spring: cloud: gateway: mvc: routes: - id: circuitbreaker_route uri: https://example.org predicates: - Path=/consumingServiceEndpoint filters: - name: CircuitBreaker args: name: myCircuitBreaker fallbackUri: forward:/inCaseOfFailureUseThis The following listing does the same thing in Java: GatewaySampleApplication.java import java.net.URI; import static org.springframework.cloud.gateway.server.mvc.filter.CircuitBreakerFilterFunctions.circuitBreaker; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsCircuitBreakerFallback() { return route(""circuitbreaker_route"") .route(path(""/consumingServiceEndpoint""), http(""https://example.org"")) .filter(circuitBreaker(""myCircuitBreaker"", URI.create(""forward:/inCaseOfFailureUseThis""))) .build(); } } This example forwards to the /inCaseofFailureUseThis URI when the circuit breaker fallback is called. CircuitBreaker also supports URI variables in the fallbackUri . This allows more complex routing options, like forwarding sections of the original host or url path using PathPattern expression(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/util/pattern/PathPattern.html) . In the example below the call consumingServiceEndpoint/users/1 will be redirected to inCaseOfFailureUseThis/users/1 . GatewaySampleApplication.java import java.net.URI; import static org.springframework.cloud.gateway.server.mvc.filter.CircuitBreakerFilterFunctions.circuitBreaker; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsCircuitBreakerFallback() { return route(""circuitbreaker_route"") .route(path(""/consumingServiceEndpoint/{*segments}""), http(""https://example.org"")) .filter(circuitBreaker(""myCircuitBreaker"", URI.create(""forward:/inCaseOfFailureUseThis/{segments}""))) .build(); } } The primary scenario is to use the fallbackUri to define an internal controller or handler within the gateway application. However, you can also reroute the request to a controller or handler in an external application, as follows: GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.CircuitBreakerFilterFunctions.circuitBreaker; import static org.springframework.cloud.gateway.server.mvc.filter.LoadBalancerFilterFunctions.lb; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsCircuitBreakerFallbackToGatewayRoute() { return route(""ingredients"") .route(path(""/ingredients/**""), http()) .filter(lb(""ingredients"")) .filter(circuitBreaker(""fetchIngredients"", URI.create(""forward:/fallback""))) .build() .and(route(""ingredients-fallback"") .route(path(""/fallback""), http(""http://localhost:9994"")) .build()); } } In this example, there is no fallback endpoint or handler in the gateway application. However, there is one in another application, registered under localhost:9994(http://localhost:9994) . In case of the request being forwarded to fallback, the Spring Cloud CircuitBreaker Gateway filter also provides the Throwable that has caused it. It is added to the ServerRequest as the MvcUtils.CIRCUITBREAKER_EXECUTION_EXCEPTION_ATTR attribute that can be used when handling the fallback within the gateway application. For the external controller/handler scenario, headers can be added with exception details. You can find more information on doing so in the FallbackHeaders Filters section(fallback-headers.html) . Tripping The Circuit Breaker On Status Codes: In some cases you might want to trip a circuit breaker based on the status code returned from the route it wraps. The circuit breaker config object takes a list of status codes that if returned will cause the circuit breaker to be tripped. When setting the status codes you want to trip the circuit breaker you can either use an integer with the status code value or the String representation of the HttpStatus enumeration. application.yml spring: cloud: gateway: mvc: routes: - id: circuitbreaker_route uri: lb://backing-service:8088 predicates: - Path=/consumingServiceEndpoint filters: - name: CircuitBreaker args: name: myCircuitBreaker fallbackUri: forward:/inCaseOfFailureUseThis statusCodes: - 500 - ""NOT_FOUND"" GatewaySampleApplication.java import java.net.URI; import static org.springframework.cloud.gateway.server.mvc.filter.CircuitBreakerFilterFunctions.circuitBreaker; import static org.springframework.cloud.gateway.server.mvc.filter.LoadBalancerFilterFunctions.lb; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsCircuitBreakerFallback() { return route(""circuitbreaker_route"") .route(path(""/consumingServiceEndpoint""), http()) .filter(lb(""backing-service"")) .filter(circuitBreaker(config -> config.setId(""myCircuitBreaker"").setFallbackUri(""forward:/inCaseOfFailureUseThis"").setStatusCodes(""500"", ""NOT_FOUND""))) .build(); } }"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/deduperesponseheader.html","DedupeResponseHeader Filter: The DedupeResponseHeader GatewayFilter factory takes a name parameter and an optional strategy parameter. name can contain a space-separated list of header names. The following example configures a DedupeResponseHeader filter: application.yml spring: cloud: gateway: mvc: routes: - id: dedupe_response_header_route uri: https://example.org filters: - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.AfterFilterFunctions.dedupeResponseHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.web.servlet.function.RequestPredicates.path; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsDedupeResponseHeader() { return route(""dedupe_response_header_route"") .route(path(""/hello""), http(""https://example.org"")) .after(dedupeResponseHeader(""Access-Control-Allow-Credentials Access-Control-Allow-Origin"")) .build(); } } This removes duplicate values of Access-Control-Allow-Credentials and Access-Control-Allow-Origin response headers in cases when both the gateway CORS logic and the downstream logic add them. The DedupeResponseHeader filter also accepts an optional strategy parameter. The accepted values are RETAIN_FIRST (default), RETAIN_LAST , and RETAIN_UNIQUE ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/fallback-headers.html","FallbackHeaders Filter: The FallbackHeaders factory lets you add Spring Cloud CircuitBreaker execution exception details in the headers of a request forwarded to a fallbackUri in an external application, as in the following scenario: application.yml spring: cloud: gateway: mvc: routes: - id: ingredients uri: lb://ingredients predicates: - Path=//ingredients/** filters: - name: CircuitBreaker args: name: fetchIngredients fallbackUri: forward:/fallback - id: ingredients-fallback uri: http://localhost:9994 predicates: - Path=/fallback filters: - name: FallbackHeaders args: executionExceptionTypeHeaderName: Test-Header GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.CircuitBreakerFilterFunctions.circuitBreaker; import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.fallbackHeaders; import static org.springframework.cloud.gateway.server.mvc.filter.LoadBalancerFilterFunctions.lb; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsCircuitBreakerFallbackToGatewayRoute() { return route(""ingredients"") .route(path(""/ingredients/**""), http()) .filter(lb(""ingredients"")) .filter(circuitBreaker(""fetchIngredients"", URI.create(""forward:/fallback""))) .build() .and(route(""ingredients-fallback"") .route(path(""/fallback""), http(""http://localhost:9994"")) .before(fallbackHeaders()) .build()); } } In this example, after an execution exception occurs while running the circuit breaker, the request is forwarded to the fallback endpoint or handler in an application running on localhost:9994 . The headers with the exception type, message and (if available) root cause exception type and message are added to that request by the FallbackHeaders filter. You can overwrite the names of the headers in the configuration by setting the values of the following arguments (shown with their default values): executionExceptionTypeHeaderName ( ""Execution-Exception-Type"" ) executionExceptionMessageHeaderName ( ""Execution-Exception-Message"" ) rootCauseExceptionTypeHeaderName ( ""Root-Cause-Exception-Type"" ) rootCauseExceptionMessageHeaderName ( ""Root-Cause-Exception-Message"" ) For more information on circuit breakers and the gateway see the Spring Cloud CircuitBreaker Filter section(circuitbreaker-filter.html) ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/loadbalancer.html","LoadBalancer Filter: The LoadBalancer Filter takes a serviceId parameter. The LoadBalancerClient uses this to choose an instance for routing. The LoadBalancer filter needs to be explicitly used in the Java DSL. When using the LoadBalancer Filter, use the empty http() method in org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions . RouteConfiguration.java import static org.springframework.cloud.gateway.server.mvc.filter.LoadBalancerFilterFunctions.lb; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddReqHeader() { return route(""api_route"") .GET(""/api/**"", http()) .filter(lb(""apiservice"")) .build(); } } Using The LoadBalancer Filter In Configuration: The LoadBalancer Filter may be used in configuration by using a URI with the lb scheme (such as lb://myservice ), it uses the Spring Cloud LoadBalancerClient to resolve the name ( myservice in this example) to an actual host and port and replaces the URI in the same attribute. The following listing configures a LoadBalancer Filter: application.yml spring: cloud: gateway: mvc: routes: - id: api_route uri: lb://apiservice predicates: - Path=/api/** By default, when a service instance cannot be found by the ReactorLoadBalancer , a 503 is returned. The isSecure value of the ServiceInstance returned from the LoadBalancerClient overrides the scheme specified in the request made to the Gateway. For example, if the request comes into the Gateway over HTTPS but the ServiceInstance indicates it is not secure, the downstream request is made over HTTP . The opposite situation can also apply. Gateway supports all the LoadBalancer features. You can read more about them in the Spring Cloud Commons documentation(https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer) ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/maprequestheader.html","MapRequestHeader Filter: The MapRequestHeader filter takes fromHeader and toHeader parameters. It creates a new named header ( toHeader ), and the value is extracted out of an existing named header ( fromHeader ) from the incoming http request. If the input header does not exist, the filter has no impact. If the new named header already exists, its values are augmented with the new values. The following example configures a MapRequestHeader : application.yml spring: cloud: gateway: mvc: routes: - id: map_request_header_route uri: https://example.org filters: - MapRequestHeader=Blue, X-Request-Red GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.addRequestParameter; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsMapRequestHeader() { return route(""map_request_header_route"") .GET(""/mypath"", http(""https://example.org"")) .before(mapRequestHeader(""Blue"", ""X-Request-Red"")) .build(); } } This adds the X-Request-Red:<values> header to the downstream request with updated values from the incoming HTTP request’s Blue header."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/modifyrequestbody.html","ModifyRequestBody Filter: You can use the ModifyRequestBody filter to modify the request body before it is sent downstream by the gateway. This filter can be configured only by using the Java DSL. The following listing shows how to modify a request body filter: GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.modifyRequestBody; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.host; import org.springframework.http.MediaType; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddReqHeader() { return route(""rewrite_request_obj"") .route(host(""*.rewriterequestobj.org""), http(""https://example.org"")) .before(modifyRequestBody(String.class, Hello.class, MediaType.APPLICATION_JSON_VALUE, (request, s) -> new Hello(s.toUpperCase()))) .build(); } record Hello(String message) { } } If the request has no body, the RewriteFilter is passed null . Mono.empty() should be returned to assign a missing body in the request."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/prefixpath.html","PrefixPath Filter: The PrefixPath filter takes a single prefix parameter. The following example configures a PrefixPath filter: application.yml spring: cloud: gateway: mvc: routes: - id: prefixpath_route uri: https://example.org filters: - PrefixPath=/mypath GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.prefixPath; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsPrefixPath() { return route(""prefixpath_route"") .GET(""/**"", http(""https://example.org"")) .before(""/mypath"") .build(); } } This prefixes /mypath to the path of all matching requests. So a request to /hello is sent to /mypath/hello ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/preservehostheader.html","PreserveHostHeader Filter: The PreserveHostHeader filter has no parameters. This filter sets a request attribute that the HandlerFunction inspects to determine if the original host header should be sent rather than the host header determined by the HTTP client. The following example configures a PreserveHostHeader filter: application.yml spring: cloud: gateway: mvc: routes: - id: preserve_host_route uri: https://example.org filters: - PreserveHostHeader GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.preserveHostHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsPreserveHostHeader() { return route(""preserve_host_route"") .GET(""/**"", http(""https://example.org"")) .before(preserveHostHeader()) .build(); } }"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/redirectto.html","RedirectTo Filter: The RedirectTo filter takes two parameters, status and url . The status parameter should be a 300 series redirect HTTP code, such as 301. The url parameter should be a valid URL. This is the value of the Location header. For relative redirects, you should use uri: no://op as the uri of your route definition. The following listing configures a RedirectTo filter: application.yml spring: cloud: gateway: mvc: routes: - id: redirectto_route uri: https://example.org filters: - RedirectTo=302, https://acme.org GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.FilterFunctions.redirectTo; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsRedirectTo() { return route(""redirectto_route"") .GET(""/**"", http(""https://example.org"")) .filter(redirectTo(302, URI.create(""acme.org""))) .build(); } } This will send a status 302 with a Location:https://acme.org header to perform a redirect."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/removerequestheader.html","RemoveRequestHeader GatewayFilter Factory: The RemoveRequestHeader filter takes a name parameter. It is the name of the header to be removed. The following listing configures a RemoveRequestHeader filter: application.yml spring: cloud: gateway: mvc: routes: - id: removerequestheader_route uri: https://example.org filters: - RemoveRequestHeader=X-Request-Foo GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.removeRequestHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsremoveRequestHeader() { return route(""removerequestheader_route"") .GET(""/**"", http(""https://example.org"")) .before(removeRequestHeader(""X-Request-Foo"")) .build(); } } This removes the X-Request-Foo header before it is sent downstream."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/removerequestparameter.html","RemoveRequestParameter Filter: The RemoveRequestParameter filter takes a name parameter. It is the name of the query parameter to be removed. The following example configures a RemoveRequestParameter filter: application.yml spring: cloud: gateway: mvc: routes: - id: removerequestparameter_route uri: https://example.org filters: - RemoveRequestParameter=red GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.addRequestParameter; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddReqHeader() { return route(""removerequestparameter_route"") .GET(""/**"", http(""https://example.org"")) .before(removeRequestParameter(""red"")) .build(); } } This will remove the red parameter before it is sent downstream."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/removeresponseheader.html","RemoveResponseHeader Filter: The RemoveResponseHeader filter takes a name parameter. It is the name of the header to be removed. The following listing configures a RemoveResponseHeader filter: application.yml spring: cloud: gateway: mvc: routes: - id: removeresponseheader_route uri: https://example.org filters: - RemoveResponseHeader=X-Response-Foo GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.AfterFilterFunctions.removeResponseHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsRemoveResponseHeader() { return route(""addresponseheader"") .GET(""/anything/addresheader"", http(""https://example.org"")) .after(removeResponseHeader(""X-Response-Foo"")) .build(); } } This will remove the X-Response-Foo header from the response before it is returned to the gateway client. To remove any kind of sensitive header, you should configure this filter for any routes for which you may want to do so. In addition, you can configure this filter once by using spring.cloud.gateway.default-filters and have it applied to all routes."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/requestheadersize.html","RequestHeaderSize Filter: The RequestHeaderSize filter takes maxSize and errorHeaderName parameters. The maxSize parameter is the maximum data size allowed by the request header (including key and value). The errorHeaderName parameter sets the name of the response header containing an error message, by default it is ""errorMessage"". The following listing configures a RequestHeaderSize filter: application.yml spring: cloud: gateway: mvc: routes: - id: requestheadersize_route uri: https://example.org filters: - RequestHeaderSize=1000B GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.requestHeaderSize; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsRequestHeaderSize() { return route(""requestheadersize_route"") .GET(""/**"", http(""https://example.org"")) .before(requestHeaderSize(""1000B"")) .build(); } } This will send a status 431 if size of any request header is greater than 1000 Bytes."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/ratelimiter.html","RateLimiter Filter: The RateLimiter Filter use Bucket4j(https://bucket4j.com/) to determine if the current request is allowed to proceed. If it is not, a status of HTTP 429 - Too Many Requests (by default) is returned. Please review Bucket4j Concepts(https://bucket4j.com/8.7.0/toc.html#concepts) prior to reading this documentation. The algorithm used by Bucket4j is the Token Bucket Algorithm(https://en.wikipedia.org/wiki/Token_bucket) . The filter takes a keyResolver parameter and other Bucket4j configuration parameters. The key resolver is a java.util.Function<ServerRequest, String> . This allows the user to extract any information out of the request to use as a key in the configured Bucket4j distribution(https://github.com/bucket4j/bucket4j#bucket4j-distributed-features) mechanism. A common key would be the Principal retrieved from the ServerRequest . By default, if the key resolver does not find a key, requests are denied with the FORBIDDEN status. Currently, the only way to configure key resolvers is through the Java DSL and not through external properties. Bucket4j Distributed Configuration: A bean of type io.github.bucket4j.distributed.proxy.AsyncProxyManager . To do this, use the ProxyManager.asAsync() method. RateLimiterConfiguration.java import com.github.benmanes.caffeine.cache.Caffeine; import io.github.bucket4j.caffeine.CaffeineProxyManager; @Configuration class RateLimiterConfiguration { @Bean public AsyncProxyManager<String> caffeineProxyManager() { Caffeine<String, RemoteBucketState> builder = (Caffeine) Caffeine.newBuilder().maximumSize(100); return new CaffeineProxyManager<>(builder, Duration.ofMinutes(1)).asAsync(); } } The above configures an AsyncProxyManager using Caffeine , a local in-memory cache, useful for testing. Configuring Buckets: By default, the Bucket is configured using a configured capacity and period . Capacity is how many tokens the bucket has. The period is a java.util.Duration that defines how long for the tokens available in the bucket to be regenerated. Other configuration items are the statusCode returned when the request is denied. By default it is 429, TO_MANY_REQUESTS. The tokens item defines how many tokens are used for each request and defaults to 1. The headerName item is the name of the header that contains the number of remaining tokens, this defaults to X-RateLimit-Remaining . The timeout option defines a Duration for the distributed bucket to return an answer and is not set by default. The following is an example of configuring a route with rate limiting: RouteConfiguration.java import static org.springframework.cloud.gateway.server.mvc.filter.Bucket4jFilterFunctions.rateLimit; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsRateLimited() { return route(""rate_limited_route"") .GET(""/api/**"", http(""https://example.org"")) .filter(rateLimit(c -> c.setCapacity(100) .setPeriod(Duration.ofMinutes(1)) .setKeyResolver(request -> request.servletRequest().getUserPrincipal().getName()))) .build(); } } This configures the rate limiting with a bucket capacity of 100 tokens per minute. The key resolver gets the principle name from the Servlet request."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/rewritelocationresponseheader.html","RewriteLocationResponseHeader Filter: The RewriteLocationResponseHeader filter modifies the value of the Location response header, usually to get rid of backend-specific details. It takes the stripVersionMode , locationHeaderName , hostValue , and protocolsRegex parameters. The following listing configures a RewriteLocationResponseHeader filter: application.yml spring: cloud: gateway: mvc: routes: - id: rewritelocationresponseheader_route uri: http://example.org filters: - RewriteLocationResponseHeader=AS_IN_REQUEST, Location, , GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.AfterFilterFunctions.addResponseHeader; import static org.springframework.cloud.gateway.server.mvc.filter.RewriteLocationResponseHeaderFilterFunctions.StripVersion; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsRewriteLocationResponseHeader() { return route(""rewritelocationresponseheader_route"") .GET(""/**"", http(""https://example.org"")) .after(rewriteLocationResponseHeader(config -> config.setLocationHeaderName(""Location"").setStripVersion(StripVersion.AS_IN_REQUEST))) .build(); } } For example, for a request of POST api.example.com/some/object/name(https://api.example.com/some/object/name) , the Location response header value of object-service.prod.example.net/v2/some/object/id(https://object-service.prod.example.net/v2/some/object/id) is rewritten as api.example.com/some/object/id(https://api.example.com/some/object/id) . The stripVersionMode parameter has the following possible values: NEVER_STRIP , AS_IN_REQUEST (default), and ALWAYS_STRIP . NEVER_STRIP : The version is not stripped, even if the original request path contains no version. AS_IN_REQUEST : The version is stripped only if the original request path contains no version. ALWAYS_STRIP : The version is always stripped, even if the original request path contains version. The hostValue parameter, if provided, is used to replace the host:port portion of the response Location header. If it is not provided, the value of the Host request header is used. The protocolsRegex parameter must be a valid regex String , against which the protocol name is matched. If it is not matched, the filter does nothing. The default is http|https|ftp|ftps ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/rewritepath.html","RewritePath Filter: The RewritePath filter takes a path regexp parameter and a replacement parameter. This uses Java regular expressions for a flexible way to rewrite the request path. The following listing configures a RewritePath filter: application.yml spring: cloud: gateway: mvc: routes: - id: rewritepath_route uri: https://example.org predicates: - Path=/red/** filters: - RewritePath=/red/?(?<segment>.*), /$\{segment} GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.rewritePath; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsRewritePath() { return route(""rewritepath_route"") .GET(""/red/**"", http(""https://example.org"")) .before(rewritePath(""/red/(?<segment>.*)"", ""/${segment}"")) .build(); } } For a request path of /red/blue , this sets the path to /blue before making the downstream request. Note that in application.yml the $ should be replaced with $\ because of the YAML specification."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/rewriteresponseheader.html","RewriteResponseHeader Filter: The RewriteResponseHeader filter takes name , regexp , and replacement parameters. It uses Java regular expressions for a flexible way to rewrite the response header value. The following example configures a RewriteResponseHeader filter: application.yml spring: cloud: gateway: mvc: routes: - id: rewriteresponseheader_route uri: https://example.org filters: - RewriteResponseHeader=X-Response-Red, , password=[^&]+, password=*** GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.AfterFilterFunctions.addResponseHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsRewriteResponseHeader() { return route(""rewriteresponseheader_route"") .GET(""/**"", http(""https://example.org"")) .after(rewriteResponseHeader(""X-Request-Red"", ""password=[^&]+"", ""password=***"")) .build(); } } For a header value of /42?user=ford&password=omg!what&flag=true , it is set to /42?user=ford&password=***&flag=true after making the downstream request. You must use $\ to mean $ because of the YAML specification in application.yml ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/setpath.html","SetPath Filter: The SetPath filter takes a path template parameter. It offers a simple way to manipulate the request path by allowing templated segments of the path. This uses the URI templates from Spring Framework. Multiple matching segments are allowed. The following example configures a SetPath filter: application.yml spring: cloud: gateway: mvc: routes: - id: setpath_route uri: https://example.org predicates: - Path=/red/{segment} filters: - SetPath=/{segment} GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.setPath; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsSetPath() { return route(""add_request_parameter_route"") .GET(""/red/{segment}"", http(""https://example.org"")) .before(setPath(""/{segment"")) .build(); } } For a request path of /red/blue , this sets the path to /blue before making the downstream request."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/setrequestheader.html","SetRequestHeader Filter: The SetRequestHeader filter takes name and value parameters. The following listing configures a SetRequestHeader filter: application.yml spring: cloud: gateway: mvc: routes: - id: setrequestheader_route uri: https://example.org filters: - SetRequestHeader=X-Request-Red, Blue GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.setRequestHostHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsSetRequestHeader() { return route(""add_request_parameter_route"") .GET(""/**"", http(""https://example.org"")) .before(setRequestHostHeader(""X-Request-Red"", ""Blue"")) .build(); } } This filter replaces (rather than adding) all headers with the given name. So, if the downstream server responded with X-Request-Red:1234 , it will be replaced with X-Request-Red:Blue , which is what the downstream service would receive. SetRequestHeader is aware of URI variables used to match a path or host. URI variables may be used in the value and are expanded at runtime. The following example configures an SetRequestHeader filter that uses a variable: application.yml spring: cloud: gateway: routes: - id: setrequestheader_route uri: https://example.org predicates: - Host: {segment}.myhost.org filters: - SetRequestHeader=X-Request-Red, Blue-{segment} GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.setRequestHostHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.host; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsSetRequestHeader() { return route(""add_request_parameter_route"") .route(host(""{segment}.myhost.org""), http(""https://example.org"")) .before(setRequestHostHeader(""X-Request-Red"", ""Blue-{segment}"")) .build(); } }"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/setresponseheader.html","SetResponseHeader Filter: The SetResponseHeader filter takes name and value parameters. The following listing configures a SetResponseHeader filter: application.yml spring: cloud: gateway: mvc: routes: - id: setresponseheader_route uri: https://example.org filters: - SetResponseHeader=X-Response-Red, Blue GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.AfterFilterFunctions.setResponseHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsSetResponseHeader() { return route(""addresponseheader"") .GET(""/anything/addresheader"", http(""https://example.org"")) .after(setResponseHeader(""X-Response-Red"", ""Blue"")) .build(); } } This GatewayFilter replaces (rather than adding) all headers with the given name. So, if the downstream server responded with X-Response-Red:1234 , it will be replaced with X-Response-Red:Blue , which is what the gateway client would receive. SetResponseHeader is aware of URI variables used to match a path or host. URI variables may be used in the value and will be expanded at runtime. The following example configures an SetResponseHeader filter that uses a variable: application.yml spring: cloud: gateway: routes: - id: setresponseheader_route uri: https://example.org predicates: - Host: {segment}.myhost.org filters: - SetResponseHeader=foo, bar-{segment} GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.AfterFilterFunctions.setResponseHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.host; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsSetResponseHeader() { return route(""add_response_header_route"") .route(host(""{segment}.myhost.org""), http(""https://example.org"")) .after(setResponseHeader(""foo"", ""bar-{segment}"")) .build(); } }"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/setstatus.html","SetStatus Filter: The SetStatus filter takes a single parameter, status . It must be a valid Spring HttpStatus . It may be the integer value 404 or the string representation of the enumeration: NOT_FOUND . The following listing configures a SetStatus filter: application.yml spring: cloud: gateway: mvc: routes: - id: setstatusstring_route uri: https://example.org filters: - SetStatus=UNAUTHORIZED - id: setstatusint_route uri: https://example.org filters: - SetStatus=401 GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.AfterFilterFunctions.setStatus; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsSetStatus() { return route(""setstatus_route"") .GET(""/path1"", http(""https://example.org"")) // setStatus(""UNAUTHORIZED"") works as well .after(setStatus(HttpStatus.UNAUTHORIZED)) .build().and(route(""setstatusint_route"") .GET(""/path2"", http(""https://example.org"")) .after(setStatus(""401"")) .build()); } } In either case, the HTTP status of the response is set to 401."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/stripprefix.html","StripPrefix Filter: The StripPrefix filter takes one parameter, parts . The parts parameter indicates the number of parts in the path to strip from the request before sending it downstream. The following listing configures a StripPrefix filter: application.yml spring: cloud: gateway: mvc: routes: - id: nameRoot uri: https://nameservice predicates: - Path=/name/** filters: - StripPrefix=2 GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.stripPrefix; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsStripPrefix() { return route(""nameRoot"") .GET(""/name/**"", http(""https://example.org"")) .before(stripPrefix(2)) .build(); } } When a request is made through the gateway to /name/blue/red , the request made to nameservice looks like nameservice/red(https://nameservice/red) ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/retry.html","Retry Filter: The Retry filter supports the following parameters: retries : The number of retries that should be attempted. methods : The HTTP methods that should be retried, represented by using org.springframework.http.HttpMethod . series : The series of status codes to be retried, represented by using org.springframework.http.HttpStatus.Series . exceptions : A list of thrown exceptions that should be retried. The following defaults are configured for Retry filter, if enabled: retries : Three times series : 5XX series methods : GET method exceptions : IOException , TimeoutException and RetryException The following listing configures a Retry filter: application.yml spring: cloud: gateway: mvc: routes: - id: retry_test uri: http://localhost:8080/flakey predicates: - Host=*.retry.com filters: - name: Retry args: retries: 3 series: SERVER_ERROR methods: GET,POST GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.RetryFilterFunctions.retry; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; import static org.springframework.cloud.gateway.server.mvc.predicate.GatewayRequestPredicates.host; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddReqHeader() { return route(""add_request_parameter_route"") .route(host(""*.retry.com""), http(""https://example.org"")) .filter(retry(config -> config.setRetries(3).setSeries(Set.of(HttpStatus.Series.SERVER_ERROR)).setMethods(Set.of(HttpMethod.GET, HttpMethod.POST)))) .build(); } } When using the retry filter with a forward: prefixed URL, the target endpoint should be written carefully so that, in case of an error, it does not do anything that could result in a response being sent to the client and committed. For example, if the target endpoint is an annotated controller, the target controller method should not return ResponseEntity with an error status code. Instead, it should throw an Exception or signal an error (for example, through a Mono.error(ex) return value), which the retry filter can be configured to handle by retrying. A simplified ""shortcut"" notation can be added with a single status and method . The following two examples are equivalent: application.yml spring: cloud: gateway: routes: - id: retry_route uri: https://example.org filters: - name: Retry args: retries: 3 statuses: INTERNAL_SERVER_ERROR methods: GET - id: retryshortcut_route uri: https://example.org filters: - Retry=3,INTERNAL_SERVER_ERROR,GET"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/requestsize.html","RequestSize Filter: When the request size is greater than the permissible limit, the RequestSize filter can restrict a request from reaching the downstream service. The filter takes a maxSize parameter. The maxSize is a DataSize type, so values can be defined as a number followed by an optional DataUnit suffix such as 'KB' or 'MB'. The default is 'B' for bytes. It is the permissible size limit of the request defined in bytes. The following listing configures a RequestSize filter: application.yml spring: cloud: gateway: mvc: routes: - id: request_size_route uri: http://localhost:8080 predicates: - Path=/upload filters: - name: RequestSize args: maxSize: 5000000 GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.requestSize; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsRequestSize() { return route(""request_size_route"") .GET(""/upload"", http(""http://localhost:8080"")) .before(requestSize(""5000000"")) .build(); } } The RequestSize filter sets the response status as 413 Payload Too Large with an additional header errorMessage when the request is rejected due to size. The following example shows such an errorMessage : errorMessage : Request size is larger than permissible limit. Request size is 6.0 MB where permissible limit is 5.0 MB The default request size is set to five MB if not provided as a filter argument in the route definition."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/setrequesthostheader.html","SetRequestHostHeader Filter: There are certain situation when the host header may need to be overridden. In this situation, the SetRequestHostHeader filter can replace the existing host header with a specified value. The filter takes a host parameter. The following listing configures a SetRequestHostHeader filter: application.yml spring: cloud: gateway: mvc: routes: - id: set_request_host_header_route uri: http://localhost:8080 predicates: - Path=/headers filters: - name: SetRequestHostHeader args: host: example.org GatewaySampleApplication.java import static org.springframework.cloud.gateway.server.mvc.filter.BeforeFilterFunctions.setRequestHostHeader; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsSetRequestHostHeader() { return route(""set_request_host_header_route"") .GET(""/headers"", http(""http://localhost:8080"")) .before(setRequestHostHeader(""example.org"")) .build(); } } The SetRequestHostHeader filter replaces the value of the host header with example.org ."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/filters/tokenrelay.html","TokenRelay Filter: A Token Relay is where an OAuth2 consumer acts as a Client and forwards the incoming token to outgoing resource requests. The consumer can be a pure Client (like an SSO application) or a Resource Server. Spring Cloud Gateway Server MVC can forward the OAuth2 access token of the currently authenticated user oauth2Login() is used to authenticate the user. RouteConfiguration.java import static org.springframework.cloud.gateway.server.mvc.filter.TokenRelayFilterFunctions.tokenRelay; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> gatewayRouterFunctionsAddReqHeader() { return route(""resource"") .GET(""/resource"", http(""http://localhost:9000"")) .filter(tokenRelay()) .build(); } } or this application.yaml spring: cloud: gateway: mvc: routes: - id: resource uri: http://localhost:9000 predicates: - Path=/resource filters: - TokenRelay= and it will (in addition to logging the user in and grabbing a token) pass the authentication token downstream to the services (in this case /resource ). To enable this for Spring Cloud Gateway Server MVC add the following dependencies org.springframework.boot:spring-boot-starter-oauth2-client How does it work? The currently authenticated user’s own access token (obtained during login) is used and the extracted access token is placed in a request header for the downstream requests. The Token Relay filter will only work if the proper spring.security.oauth2.client.* properties are set which will trigger creation of a OAuth2AuthorizedClientManager bean. The default implementation used by the Token Relay filter uses an in-memory data store. You will need to provide your own implementation OAuth2AuthorizedClientService if you need a more robust solution."
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/writing-custom-predicates-and-filters.html","Writing Custom Predicates and Filters: Spring Cloud Gateway Server MVC uses the Spring WebMvc.fn(https://docs.spring.io/spring-framework/reference/web/webmvc-functional.html) API ( javadoc(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/package-summary.html) ) as the basis for the API Gateway functionality. Spring Cloud Gateway Server MVC is extensible using these APIs. Users might commonly expect to write custom implementations of RequestPredicate(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RequestPredicate.html) and HandlerFilterFunction(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/HandlerFilterFunction.html) and two variations of HandlerFilterFunction , one for ""before"" filters and another for ""after"" filters. Fundamentals: The most basic interfaces that are a part of the Spring WebMvc.fn API are ServerRequest(https://docs.spring.io/spring-framework/reference/web/webmvc-functional.html#webmvc-fn-request) ( javadoc(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/ServerRequest.html) ) and ServerResponse(https://docs.spring.io/spring-framework/reference/web/webmvc-functional.html#webmvc-fn-response) ( javadoc(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/ServerResponse.html) ). These provide access to all parts of the HTTP request and response. The Spring WebMvc.fn docs declare(https://docs.spring.io/spring-framework/reference/web/webmvc-functional.html#webmvc-fn-handler-functions) that ""`ServerRequest` and ServerResponse are immutable interfaces. In some cases, Spring Cloud Gateway Server MVC has to provide alternate implementations so that some things can be mutable to satisfy the proxy requirements of an API gateway. Implementing a RequestPredicate: The Spring WebMvc.fn RouterFunctions.Builder(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RouterFunctions.Builder.html) expects a RequestPredicate(https://docs.spring.io/spring-framework/reference/web/webmvc-functional.html#webmvc-fn-predicates) ( javadoc(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RequestPredicate.html) ) to match a given Route(https://docs.spring.io/spring-framework/reference/web/webmvc-functional.html#webmvc-fn-routes) . RequestPredicate is a functional interface and can therefor be implemented with lambdas. The method signature to implement is: boolean test(ServerRequest request) Example RequestPredicate Implementation: For this example, we will show the implementation of a predicate to test that a particular HTTP headers is part of the HTTP request. The RequestPredicate implementations in Spring WebMvc.fn RequestPredicates(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RequestPredicates.html) and in GatewayRequestPredicates(https://github.com/spring-cloud/spring-cloud-gateway/blob/main/spring-cloud-gateway-server-mvc/src/main/java/org/springframework/cloud/gateway/server/mvc/predicate/GatewayRequestPredicates.java) are all implemented as static methods. We will do the same here. SampleRequestPredicates.java import org.springframework.web.reactive.function.server.RequestPredicate; class SampleRequestPredicates { public static RequestPredicate headerExists(String header) { return request -> request.headers().asHttpHeaders().containsKey(header); } } The implementation is a simple lambda that transforms the ServerRequest.Headers(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/ServerRequest.Headers.html) object to the richer API of HttpHeaders(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpHeaders.html) . This allows the predicate to test for the presence of the named header . How To Use A Custom RequestPredicate: To use our new headerExists RequestPredicate , we need to plug it in to an appropriate method on the RouterFunctions.Builder such as route()(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RouterFunctions.Builder.html#route(org.springframework.web.servlet.function.RequestPredicate,org.springframework.web.servlet.function.HandlerFunction)) . Of course, the lambda in the headerExists method could be written inline in the example below. RouteConfiguration.java import static SampleRequestPredicates.headerExists; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> headerExistsRoute() { return route(""header_exists_route"") .route(headerExists(""X-Green""), http(""https://example.org"")) .build(); } } The above route will be matched when an HTTP request has a header named X-Green . Writing Custom HandlerFilterFunction Implementations: The RouterFunctions.Builder has three options to add filters: filter(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RouterFunctions.Builder.html#filter(org.springframework.web.servlet.function.HandlerFilterFunction)) , before(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RouterFunctions.Builder.html#before(java.util.function.Function)) , and after(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/RouterFunctions.Builder.html#after(java.util.function.BiFunction)) . The before and after methods are specializations of the general filter method. Implementing a HandlerFilterFunction: The filter method takes a HandlerFilterFunction(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/HandlerFilterFunction.html) as a parameter. HandlerFilterFunction<T extends ServerResponse, R extends ServerResponse> is a functional interface and can therefor be implemented with lambdas. The method signature to implement is: R filter(ServerRequest request, HandlerFunction<T> next) This allows access to the ServerRequest and after calling next.handle(request) access to the ServerResponse is available. Example HandlerFilterFunction Implementation: This example will show adding a header to both the request and response. SampleHandlerFilterFunctions.java import org.springframework.web.servlet.function.HandlerFilterFunction; import org.springframework.web.servlet.function.ServerRequest; import org.springframework.web.servlet.function.ServerResponse; class SampleHandlerFilterFunctions { public static HandlerFilterFunction<ServerResponse, ServerResponse> instrument(String requestHeader, String responseHeader) { return (request, next) -> { ServerRequest modified = ServerRequest.from(request).header(requestHeader, generateId()); ServerResponse response = next.handle(modified); response.headers().add(responseHeader, generateId()); return response; }; } } First, a new ServerRequest is created from the existing request. This allows us to add the header using the header() method. Then we call next.handle() passing in the modified ServerRequest . Then using the returned ServerResponse we add the header to the response. How To Use Custom HandlerFilterFunction Implementations: RouteConfiguration.java import static SampleHandlerFilterFunctions.instrument; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> instrumentRoute() { return route(""instrument_route"") .GET(""/**"", http(""https://example.org"")) .filter(instrument(""X-Request-Id"", ""X-Response-Id"")) .build(); } } The above route will add a X-Request-Id header to the request and a X-Response-Id header to the response. Writing Custom Before Filter Implementations: The before method takes a Function<ServerRequest, ServerRequest> as a parameter. This allows for creating a new ServerRequest with updated data to be returned from the function. Before functions may be adapted to HandlerFilterFunction instances via HandlerFilterFunction.ofRequestProcessor()(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/HandlerFilterFunction.html#ofRequestProcessor(java.util.function.Function)) . Example Before Filter Implementation: In this example we will add a header with a generated value to the request. SampleBeforeFilterFunctions.java import java.util.function.Function; import org.springframework.web.servlet.function.ServerRequest; class SampleBeforeFilterFunctions { public static Function<ServerRequest, ServerRequest> instrument(String header) { return request -> ServerRequest.from(request).header(header, generateId());; } } A new ServerRequest is created from the existing request. This allows us to add the header using the header() method. This implementation is simpler than the HandlerFilterFunction because we only deal with the ServerRequest . How To Use Custom Before Filter Implementations: RouteConfiguration.java import static SampleBeforeFilterFunctions.instrument; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> instrumentRoute() { return route(""instrument_route"") .GET(""/**"", http(""https://example.org"")) .before(instrument(""X-Request-Id"")) .build(); } } The above route will add a X-Request-Id header to the request. Note the use of the before() method, rather than filter() . Writing Custom After Filter Implementations: The after method takes a BiFunction<ServerRequest,ServerResponse,ServerResponse> . This allows access to both the ServerRequest and the ServerResponse and the ability to return a new ServerResponse with updated information. After functions may be adapted to HandlerFilterFunction instances via HandlerFilterFunction.ofResponseProcessor()(https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/function/HandlerFilterFunction.html#ofResponseProcessor(java.util.function.BiFunction)) . Example After Filter Implementation: In this example we will add a header with a generated value to the response. SampleAfterFilterFunctions.java import java.util.function.BiFunction; import org.springframework.web.servlet.function.ServerRequest; import org.springframework.web.servlet.function.ServerResponse; class SampleAfterFilterFunctions { public static BiFunction<ServerRequest, ServerResponse, ServerResponse> instrument(String header) { return (request, response) -> { response.headers().add(header, generateId()); return response; }; } } In this case we simply add the header to the response and return it. How To Use Custom After Filter Implementations: RouteConfiguration.java import static SampleAfterFilterFunctions.instrument; import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route; import static org.springframework.cloud.gateway.server.mvc.handler.HandlerFunctions.http; @Configuration class RouteConfiguration { @Bean public RouterFunction<ServerResponse> instrumentRoute() { return route(""instrument_route"") .GET(""/**"", http(""https://example.org"")) .after(instrument(""X-Response-Id"")) .build(); } } The above route will add a X-Response-Id header to the response. Note the use of the after() method, rather than filter() . How To Register Custom Predicates and Filters for Configuration: To use custom Predicates and Filters in external configuration you need to create a special Supplier class and register it in META-INF/spring.factories . Registering Custom Predicates: To register custom predicates you need to implement PredicateSupplier . The PredicateDiscoverer looks for static methods that return RequestPredicates to register. SampleFilterSupplier.java import org.springframework.cloud.gateway.server.mvc.predicate.PredicateSupplier; @Configuration class SamplePredicateSupplier implements PredicateSupplier { @Override public Collection<Method> get() { return Arrays.asList(SampleRequestPredicates.class.getMethods()); } } You then need to add the class in META-INF/spring.factories . META-INF/spring.factories org.springframework.cloud.gateway.server.mvc.predicate.PredicateSupplier=\ com.example.SamplePredicateSupplier Registering Custom Filters: The SimpleFilterSupplier allows for easily registering custom filters. The FilterDiscoverer looks for static methods that return HandlerFilterFunction to register. If you need more flexibility than SimpleFilterSupplier you can implement FilterSupplier directly. SampleFilterSupplier.java import org.springframework.cloud.gateway.server.mvc.filter.SimpleFilterSupplier; @Configuration class SampleFilterSupplier extends SimpleFilterSupplier { public SampleFilterSupplier() { super(SampleAfterFilterFunctions.class); } } You then need to add the class in META-INF/spring.factories . META-INF/spring.factories org.springframework.cloud.gateway.server.mvc.filter.FilterSupplier=\ com.example.SampleFilterSupplier"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-mvc/working-with-servlets-and-filters.html","Working with Servlets and Servlet Filters: Spring Cloud Gateway Server MVC is built for Servlet-stack web applications built on the Servlet API and deployed to Servlet containers. If your applications uses Servlets or Servlet Filters you may need to take care in their ordering. Because of the way Servlet Containers handle request parameters, when a Spring WebMVC application receives a content type of application/x-www-form-urlencoded , Servlet containers combine those with query parameters into ""request"" parameters. A special FormFilter bean is included in Spring Cloud Gateway Server MVC to rebuild the form body for downstream applications. Any Servlet Filter that reads request parameters before the filter chain is run will need to be ordered before FormFilter . See the example below. MyFilter.java import jakarta.servlet.Filter; import org.springframework.cloud.gateway.server.mvc.filter.FormFilter; import org.springframework.core.Ordered; class MyFilter implements Filter, Ordered { @Override public int getOrder() { return FormFilter.FORM_FILTER_ORDER - 1; } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException { // ... filterChain.doFilter(request, response); // ... } }"
"https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-proxy-exchange.html","Proxy Exchange Gateway with Spring MVC or Webflux: The following describes an alternative style gateway. None of the Spring Cloud Gateway Server documentation applies to what follows. How to Include Spring Cloud Gateway Proxy Exchange: To include Spring Cloud Gateway Proxy Exchange in your project, use the artifact with a group ID of org.springframework.cloud and an artifact ID of spring-cloud-gateway-mvc for the MVC Proxy Exchange. For the WebFlux Proxy Exchange use artifact with a group ID of org.springframework.cloud and an artifact ID of spring-cloud-gateway-webflux . See the Spring Cloud Project page(https://projects.spring.io/spring-cloud/) for details on setting up your build system with the current Spring Cloud Release Train. Using Proxy Exchange: Spring Cloud Gateway provides a utility object called ProxyExchange . You can use it inside a regular Spring web handler as a method parameter. It supports basic downstream HTTP exchanges through methods that mirror the HTTP verbs. With MVC, it also supports forwarding to a local handler through the forward() method. To use the ProxyExchange , include the right module in your classpath (either spring-cloud-gateway-mvc or spring-cloud-gateway-webflux ). The following MVC example proxies a request to /test downstream to a remote server: @RestController @SpringBootApplication public class GatewaySampleApplication { @Value(""${remote.home}"") private URI home; @GetMapping(""/test"") public ResponseEntity<?> proxy(ProxyExchange<byte[]> proxy) throws Exception { return proxy.uri(home.toString() + ""/image/png"").get(); } } The following example does the same thing with Webflux: @RestController @SpringBootApplication public class GatewaySampleApplication { @Value(""${remote.home}"") private URI home; @GetMapping(""/test"") public Mono<ResponseEntity<?>> proxy(ProxyExchange<byte[]> proxy) throws Exception { return proxy.uri(home.toString() + ""/image/png"").get(); } } Convenience methods on the ProxyExchange enable the handler method to discover and enhance the URI path of the incoming request. For example, you might want to extract the trailing elements of a path to pass them downstream: @GetMapping(""/proxy/path/**"") public ResponseEntity<?> proxyPath(ProxyExchange<byte[]> proxy) throws Exception { String path = proxy.path(""/proxy/path/""); return proxy.uri(home.toString() + ""/foos/"" + path).get(); } All the features of Spring MVC and Webflux are available to gateway handler methods. As a result, you can inject request headers and query parameters, for instance, and you can constrain the incoming requests with declarations in the mapping annotation. See the documentation for @RequestMapping in Spring MVC for more details of those features. You can add headers to the downstream response by using the header() methods on ProxyExchange . You can also manipulate response headers (and anything else you like in the response) by adding a mapper to the get() method (and other methods). The mapper is a Function that takes the incoming ResponseEntity and converts it to an outgoing one. First-class support is provided for “sensitive” headers (by default, cookie and authorization ) and “skipped” headers (by default, content-length and host ), which are not passed downstream, and for “proxy” ( x-forwarded-* ) headers. The idea behind “skipped” headers is that they may result in problems when copied over to the downstream request. For example: because of the way that the ProxyExchange calls the downstream endpoint the content’s length might have changed or even use a Transfer-Encoding: chunked instead of a Content-Length header."
"https://docs.spring.io/spring-cloud-gateway/reference/appendix.html","Common application properties: Various properties can be specified inside your application.properties file, inside your application.yml file, or as command line switches. This appendix provides a list of common Spring Cloud Gateway properties and references to the underlying classes that consume them. Property contributions can come from additional jar files on your classpath, so you should not consider this an exhaustive list. Also, you can define your own properties. Name Default Description spring.cloud.gateway.default-filters List of filter definitions that are applied to every route. spring.cloud.gateway.discovery.locator.enabled false Flag that enables DiscoveryClient gateway integration. spring.cloud.gateway.discovery.locator.filters spring.cloud.gateway.discovery.locator.include-expression true SpEL expression that will evaluate whether to include a service in gateway integration or not, defaults to: true. spring.cloud.gateway.discovery.locator.lower-case-service-id false Option to lower case serviceId in predicates and filters, defaults to false. Useful with eureka when it automatically uppercases serviceId. so MYSERIVCE, would match /myservice/** spring.cloud.gateway.discovery.locator.predicates spring.cloud.gateway.discovery.locator.route-id-prefix The prefix for the routeId, defaults to discoveryClient.getClass().getSimpleName() + ""_"". Service Id will be appended to create the routeId. spring.cloud.gateway.discovery.locator.url-expression 'lb://'+serviceId SpEL expression that create the uri for each route, defaults to: 'lb://'+serviceId. spring.cloud.gateway.enabled true Enables gateway functionality. spring.cloud.gateway.fail-on-route-definition-error true Option to fail on route definition errors, defaults to true. Otherwise, a warning is logged. spring.cloud.gateway.filter.add-request-header.enabled true Enables the add-request-header filter. spring.cloud.gateway.filter.add-request-parameter.enabled true Enables the add-request-parameter filter. spring.cloud.gateway.filter.add-response-header.enabled true Enables the add-response-header filter. spring.cloud.gateway.filter.circuit-breaker.enabled true Enables the circuit-breaker filter. spring.cloud.gateway.filter.dedupe-response-header.enabled true Enables the dedupe-response-header filter. spring.cloud.gateway.filter.fallback-headers.enabled true Enables the fallback-headers filter. spring.cloud.gateway.filter.hystrix.enabled true Enables the hystrix filter. spring.cloud.gateway.filter.json-to-grpc.enabled true Enables the JSON to gRPC filter. spring.cloud.gateway.filter.local-response-cache.enabled false Enables the local-response-cache filter. spring.cloud.gateway.filter.local-response-cache.request.no-cache-strategy spring.cloud.gateway.filter.local-response-cache.size Maximum size of the cache to evict entries for this route (in KB, MB and GB). spring.cloud.gateway.filter.local-response-cache.time-to-live 5m Time to expire a cache entry (expressed in s for seconds, m for minutes, and h for hours). spring.cloud.gateway.filter.map-request-header.enabled true Enables the map-request-header filter. spring.cloud.gateway.filter.modify-request-body.enabled true Enables the modify-request-body filter. spring.cloud.gateway.filter.modify-response-body.enabled true Enables the modify-response-body filter. spring.cloud.gateway.filter.prefix-path.enabled true Enables the prefix-path filter. spring.cloud.gateway.filter.preserve-host-header.enabled true Enables the preserve-host-header filter. spring.cloud.gateway.filter.redirect-to.enabled true Enables the redirect-to filter. spring.cloud.gateway.filter.remove-hop-by-hop.headers spring.cloud.gateway.filter.remove-hop-by-hop.order 0 spring.cloud.gateway.filter.remove-request-header.enabled true Enables the remove-request-header filter. spring.cloud.gateway.filter.remove-request-parameter.enabled true Enables the remove-request-parameter filter. spring.cloud.gateway.filter.remove-response-header.enabled true Enables the remove-response-header filter. spring.cloud.gateway.filter.request-header-size.enabled true Enables the request-header-size filter. spring.cloud.gateway.filter.request-header-to-request-uri.enabled true Enables the request-header-to-request-uri filter. spring.cloud.gateway.filter.request-rate-limiter.default-key-resolver spring.cloud.gateway.filter.request-rate-limiter.default-rate-limiter spring.cloud.gateway.filter.request-rate-limiter.enabled true Enables the request-rate-limiter filter. spring.cloud.gateway.filter.request-size.enabled true Enables the request-size filter. spring.cloud.gateway.filter.retry.enabled true Enables the retry filter. spring.cloud.gateway.filter.rewrite-location-response-header.enabled true Enables the rewrite-location-response-header filter. spring.cloud.gateway.filter.rewrite-location.enabled true Enables the rewrite-location filter. spring.cloud.gateway.filter.rewrite-path.enabled true Enables the rewrite-path filter. spring.cloud.gateway.filter.rewrite-request-parameter.enabled true Enables the rewrite-request-parameter filter. spring.cloud.gateway.filter.rewrite-response-header.enabled true Enables the rewrite-response-header filter. spring.cloud.gateway.filter.save-session.enabled true Enables the save-session filter. spring.cloud.gateway.filter.secure-headers.content-security-policy default-src 'self' https:; font-src 'self' https: data:; img-src 'self' https: data:; object-src 'none'; script-src https:; style-src 'self' https: 'unsafe-inline' spring.cloud.gateway.filter.secure-headers.content-type-options nosniff spring.cloud.gateway.filter.secure-headers.disable spring.cloud.gateway.filter.secure-headers.download-options noopen spring.cloud.gateway.filter.secure-headers.enabled true Enables the secure-headers filter. spring.cloud.gateway.filter.secure-headers.frame-options DENY spring.cloud.gateway.filter.secure-headers.permitted-cross-domain-policies none spring.cloud.gateway.filter.secure-headers.referrer-policy no-referrer spring.cloud.gateway.filter.secure-headers.strict-transport-security max-age=631138519 spring.cloud.gateway.filter.secure-headers.xss-protection-header 1 ; mode=block spring.cloud.gateway.filter.set-path.enabled true Enables the set-path filter. spring.cloud.gateway.filter.set-request-header.enabled true Enables the set-request-header filter. spring.cloud.gateway.filter.set-request-host-header.enabled true Enables the set-request-host-header filter. spring.cloud.gateway.filter.set-response-header.enabled true Enables the set-response-header filter. spring.cloud.gateway.filter.set-status.enabled true Enables the set-status filter. spring.cloud.gateway.filter.strip-prefix.enabled true Enables the strip-prefix filter. spring.cloud.gateway.forwarded.enabled true Enables the ForwardedHeadersFilter. spring.cloud.gateway.global-filter.adapt-cached-body.enabled true Enables the adapt-cached-body global filter. spring.cloud.gateway.global-filter.forward-path.enabled true Enables the forward-path global filter. spring.cloud.gateway.global-filter.forward-routing.enabled true Enables the forward-routing global filter. spring.cloud.gateway.global-filter.load-balancer-client.enabled true Enables the load-balancer-client global filter. spring.cloud.gateway.global-filter.local-response-cache.enabled true Enables the local-response-cache filter for all routes, it allows to add a specific configuration at route level using LocalResponseCache filter. spring.cloud.gateway.global-filter.netty-routing.enabled true Enables the netty-routing global filter. spring.cloud.gateway.global-filter.netty-write-response.enabled true Enables the netty-write-response global filter. spring.cloud.gateway.global-filter.reactive-load-balancer-client.enabled true Enables the reactive-load-balancer-client global filter. spring.cloud.gateway.global-filter.remove-cached-body.enabled true Enables the remove-cached-body global filter. spring.cloud.gateway.global-filter.route-to-request-url.enabled true Enables the route-to-request-url global filter. spring.cloud.gateway.global-filter.websocket-routing.enabled true Enables the websocket-routing global filter. spring.cloud.gateway.globalcors.add-to-simple-url-handler-mapping false If global CORS config should be added to the URL handler. spring.cloud.gateway.globalcors.cors-configurations spring.cloud.gateway.handler-mapping.order 1 The order of RoutePredicateHandlerMapping. spring.cloud.gateway.httpclient.compression false Enables compression for Netty HttpClient. spring.cloud.gateway.httpclient.connect-timeout The connect timeout in millis, the default is 30s. spring.cloud.gateway.httpclient.max-header-size The max response header size. spring.cloud.gateway.httpclient.max-initial-line-length The max initial line length. spring.cloud.gateway.httpclient.pool.acquire-timeout Only for type FIXED, the maximum time in millis to wait for acquiring. spring.cloud.gateway.httpclient.pool.eviction-interval 0 Perform regular eviction checks in the background at a specified interval. Disabled by default ({@link Duration#ZERO}) spring.cloud.gateway.httpclient.pool.max-connections Only for type FIXED, the maximum number of connections before starting pending acquisition on existing ones. spring.cloud.gateway.httpclient.pool.max-idle-time Time in millis after which the channel will be closed. If NULL, there is no max idle time. spring.cloud.gateway.httpclient.pool.max-life-time Duration after which the channel will be closed. If NULL, there is no max life time. spring.cloud.gateway.httpclient.pool.metrics false Enables channel pools metrics to be collected and registered in Micrometer. Disabled by default. spring.cloud.gateway.httpclient.pool.name proxy The channel pool map name, defaults to proxy. spring.cloud.gateway.httpclient.pool.type Type of pool for HttpClient to use, defaults to ELASTIC. spring.cloud.gateway.httpclient.proxy.host Hostname for proxy configuration of Netty HttpClient. spring.cloud.gateway.httpclient.proxy.non-proxy-hosts-pattern Regular expression (Java) for a configured list of hosts. that should be reached directly, bypassing the proxy spring.cloud.gateway.httpclient.proxy.password Password for proxy configuration of Netty HttpClient. spring.cloud.gateway.httpclient.proxy.port Port for proxy configuration of Netty HttpClient. spring.cloud.gateway.httpclient.proxy.type proxyType for proxy configuration of Netty HttpClient. spring.cloud.gateway.httpclient.proxy.username Username for proxy configuration of Netty HttpClient. spring.cloud.gateway.httpclient.response-timeout The response timeout. spring.cloud.gateway.httpclient.ssl.close-notify-flush-timeout 3000ms SSL close_notify flush timeout. Default to 3000 ms. spring.cloud.gateway.httpclient.ssl.close-notify-read-timeout 0 SSL close_notify read timeout. Default to 0 ms. spring.cloud.gateway.httpclient.ssl.handshake-timeout 10000ms SSL handshake timeout. Default to 10000 ms spring.cloud.gateway.httpclient.ssl.key-password Key password, default is same as keyStorePassword. spring.cloud.gateway.httpclient.ssl.key-store Keystore path for Netty HttpClient. spring.cloud.gateway.httpclient.ssl.key-store-password Keystore password. spring.cloud.gateway.httpclient.ssl.key-store-provider Keystore provider for Netty HttpClient, optional field. spring.cloud.gateway.httpclient.ssl.key-store-type JKS Keystore type for Netty HttpClient, default is JKS. spring.cloud.gateway.httpclient.ssl.trusted-x509-certificates Trusted certificates for verifying the remote endpoint’s certificate. spring.cloud.gateway.httpclient.ssl.use-insecure-trust-manager false Installs the netty InsecureTrustManagerFactory. This is insecure and not suitable for production. spring.cloud.gateway.httpclient.websocket.max-frame-payload-length Max frame payload length. spring.cloud.gateway.httpclient.websocket.proxy-ping true Proxy ping frames to downstream services, defaults to true. spring.cloud.gateway.httpclient.wiretap false Enables wiretap debugging for Netty HttpClient. spring.cloud.gateway.httpserver.wiretap false Enables wiretap debugging for Netty HttpServer. spring.cloud.gateway.loadbalancer.use404 false spring.cloud.gateway.metrics.enabled false Enables the collection of metrics data. spring.cloud.gateway.metrics.prefix spring.cloud.gateway The prefix of all metrics emitted by gateway. spring.cloud.gateway.metrics.tags Tags map that added to metrics. spring.cloud.gateway.mvc.form-filter.enabled true Enables the form-filter. spring.cloud.gateway.mvc.forwarded-request-headers-filter.enabled true Enables the forwarded-request-headers-filter. spring.cloud.gateway.mvc.http-client.connect-timeout The HttpClient connect timeout. spring.cloud.gateway.mvc.http-client.read-timeout The HttpClient read timeout. spring.cloud.gateway.mvc.http-client.ssl-bundle The name of the SSL bundle to use. spring.cloud.gateway.mvc.http-client.type The HttpClient type. Defaults to JDK. spring.cloud.gateway.mvc.remove-content-length-request-headers-filter.enabled true Enables the remove-content-length-request-headers-filter. spring.cloud.gateway.mvc.remove-hop-by-hop-request-headers-filter.enabled true Enables the forwarded-request-headers-filter. spring.cloud.gateway.mvc.remove-hop-by-hop-response-headers-filter.enabled true Enables the forwarded-request-headers-filter. spring.cloud.gateway.mvc.routes List of Routes. spring.cloud.gateway.mvc.routes-map Map of Routes. spring.cloud.gateway.mvc.transfer-encoding-normalization-request-headers-filter.enabled true Enables the transfer-encoding-normalization-request-headers-filter. spring.cloud.gateway.mvc.weight-calculator-filter.enabled true Enables the weight-calculator-filter. spring.cloud.gateway.mvc.x-forwarded-request-headers-filter.enabled true If the XForwardedHeadersFilter is enabled. spring.cloud.gateway.mvc.x-forwarded-request-headers-filter.for-append true If appending X-Forwarded-For as a list is enabled. spring.cloud.gateway.mvc.x-forwarded-request-headers-filter.for-enabled true If X-Forwarded-For is enabled. spring.cloud.gateway.mvc.x-forwarded-request-headers-filter.host-append true If appending X-Forwarded-Host as a list is enabled. spring.cloud.gateway.mvc.x-forwarded-request-headers-filter.host-enabled true If X-Forwarded-Host is enabled. spring.cloud.gateway.mvc.x-forwarded-request-headers-filter.order 0 The order of the XForwardedHeadersFilter. spring.cloud.gateway.mvc.x-forwarded-request-headers-filter.port-append true If appending X-Forwarded-Port as a list is enabled. spring.cloud.gateway.mvc.x-forwarded-request-headers-filter.port-enabled true If X-Forwarded-Port is enabled. spring.cloud.gateway.mvc.x-forwarded-request-headers-filter.prefix-append true If appending X-Forwarded-Prefix as a list is enabled. spring.cloud.gateway.mvc.x-forwarded-request-headers-filter.prefix-enabled true If X-Forwarded-Prefix is enabled. spring.cloud.gateway.mvc.x-forwarded-request-headers-filter.proto-append true If appending X-Forwarded-Proto as a list is enabled. spring.cloud.gateway.mvc.x-forwarded-request-headers-filter.proto-enabled true If X-Forwarded-Proto is enabled. spring.cloud.gateway.observability.enabled true If Micrometer Observability support should be turned on. spring.cloud.gateway.predicate.after.enabled true Enables the after predicate. spring.cloud.gateway.predicate.before.enabled true Enables the before predicate. spring.cloud.gateway.predicate.between.enabled true Enables the between predicate. spring.cloud.gateway.predicate.cloud-foundry-route-service.enabled true Enables the cloud-foundry-route-service predicate. spring.cloud.gateway.predicate.cookie.enabled true Enables the cookie predicate. spring.cloud.gateway.predicate.header.enabled true Enables the header predicate. spring.cloud.gateway.predicate.host.enabled true Enables the host predicate. spring.cloud.gateway.predicate.host.include-port true Include the port in matching the host name. spring.cloud.gateway.predicate.method.enabled true Enables the method predicate. spring.cloud.gateway.predicate.path.enabled true Enables the path predicate. spring.cloud.gateway.predicate.query.enabled true Enables the query predicate. spring.cloud.gateway.predicate.read-body.enabled true Enables the read-body predicate. spring.cloud.gateway.predicate.remote-addr.enabled true Enables the remote-addr predicate. spring.cloud.gateway.predicate.weight.enabled true Enables the weight predicate. spring.cloud.gateway.predicate.xforwarded-remote-addr.enabled true Enables the xforwarded-remote-addr predicate. spring.cloud.gateway.redis-rate-limiter.burst-capacity-header X-RateLimit-Burst-Capacity The name of the header that returns the burst capacity configuration. spring.cloud.gateway.redis-rate-limiter.config spring.cloud.gateway.redis-rate-limiter.include-headers true Whether or not to include headers containing rate limiter information, defaults to true. spring.cloud.gateway.redis-rate-limiter.remaining-header X-RateLimit-Remaining The name of the header that returns number of remaining requests during the current second. spring.cloud.gateway.redis-rate-limiter.replenish-rate-header X-RateLimit-Replenish-Rate The name of the header that returns the replenish rate configuration. spring.cloud.gateway.redis-rate-limiter.requested-tokens-header X-RateLimit-Requested-Tokens The name of the header that returns the requested tokens configuration. spring.cloud.gateway.redis-route-definition-repository.enabled true If RedisRouteDefinitionRepository should be enabled. spring.cloud.gateway.restrictive-property-accessor.enabled true Restricts method and property access in SpEL. spring.cloud.gateway.route-refresh-listener.enabled true If RouteRefreshListener should be turned on. spring.cloud.gateway.routes List of Routes. spring.cloud.gateway.set-status.original-status-header-name The name of the header which contains http code of the proxied request. spring.cloud.gateway.streaming-media-types spring.cloud.gateway.x-forwarded.enabled true If the XForwardedHeadersFilter is enabled. spring.cloud.gateway.x-forwarded.for-append true If appending X-Forwarded-For as a list is enabled. spring.cloud.gateway.x-forwarded.for-enabled true If X-Forwarded-For is enabled. spring.cloud.gateway.x-forwarded.host-append true If appending X-Forwarded-Host as a list is enabled. spring.cloud.gateway.x-forwarded.host-enabled true If X-Forwarded-Host is enabled. spring.cloud.gateway.x-forwarded.order 0 The order of the XForwardedHeadersFilter. spring.cloud.gateway.x-forwarded.port-append true If appending X-Forwarded-Port as a list is enabled. spring.cloud.gateway.x-forwarded.port-enabled true If X-Forwarded-Port is enabled. spring.cloud.gateway.x-forwarded.prefix-append true If appending X-Forwarded-Prefix as a list is enabled. spring.cloud.gateway.x-forwarded.prefix-enabled true If X-Forwarded-Prefix is enabled. spring.cloud.gateway.x-forwarded.proto-append true If appending X-Forwarded-Proto as a list is enabled. spring.cloud.gateway.x-forwarded.proto-enabled true If X-Forwarded-Proto is enabled. Observability metadata: Observability - Metrics: Below you can find a list of all metrics declared by this project. Gateway Http Client Observation: Observation created when sending a request through the gateway. Metric name http.client.requests (defined by convention class org.springframework.cloud.gateway.filter.headers.observation.DefaultGatewayObservationConvention ). Type timer . Metric name http.client.requests.active (defined by convention class org.springframework.cloud.gateway.filter.headers.observation.DefaultGatewayObservationConvention ). Type long task timer . KeyValues that are added after starting the Observation might be missing from the *.active metrics. Micrometer internally uses nanoseconds for the baseunit. However, each backend determines the actual baseunit. (i.e. Prometheus uses seconds) Fully qualified name of the enclosing class org.springframework.cloud.gateway.filter.headers.observation.GatewayDocumentedObservation . Table 1. Low cardinality Keys Name Description http.method (required) HTTP Method. http.status_code (required) HTTP Status. spring.cloud.gateway.route.id (required) Route ID. spring.cloud.gateway.route.uri (required) HTTP URI taken from the Route. Table 2. High cardinality Keys Name Description http.uri (required) Full HTTP URI. Observability - Spans: Below you can find a list of all spans declared by this project. Gateway Http Client Observation Span: Observation created when sending a request through the gateway. Span name http.client.requests (defined by convention class org.springframework.cloud.gateway.filter.headers.observation.DefaultGatewayObservationConvention ). Fully qualified name of the enclosing class org.springframework.cloud.gateway.filter.headers.observation.GatewayDocumentedObservation . Table 3. Tag Keys Name Description http.method (required) HTTP Method. http.status_code (required) HTTP Status. http.uri (required) Full HTTP URI. spring.cloud.gateway.route.id (required) Route ID. spring.cloud.gateway.route.uri (required) HTTP URI taken from the Route. Observability - Conventions: Below you can find a list of all GlobalObservationConvention and ObservationConvention declared by this project. Table 4. ObservationConvention implementations ObservationConvention Class Name Applicable ObservationContext Class Name org.springframework.cloud.gateway.filter.headers.observation.DefaultGatewayObservationConvention GatewayContext org.springframework.cloud.gateway.filter.headers.observation.GatewayObservationConvention GatewayContext"
