"url","content"
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/index.html","Overview: Soby Chacko; Chris Bono; Alexander Preuß; Jay Bryant; Christophe Bornet; Jonas Geiregat (v1.1.4) © 2022-2023 VMware, Inc. Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/whats-new.html","What’s new?: What’s New in 1.1 Since 1.0: This section covers the changes made from version 1.0 to version 1.1. Auto Schema support: If there is no chance to know the schema of a Pulsar topic in advance, you can use AUTO Schemas to produce/consume generic records to/from brokers. See Producing with AUTO_SCHEMA(reference/pulsar/message-production.html#template-auto-produce) and Consuming with AUTO_SCHEMA(reference/pulsar/message-consumption.html#listener-auto-consume) for more details. While the above links focus on PulsarTemplate and @PulsarListener , this feature is also supported in ReactivePulsarTemplate , @ReactivePulsarListener , and @PulsarReader . Details for each can be found in their respective section of this reference guide. Default topic/schema via message annotation: You can now mark a message class with @PulsarMessage to specify the default topic(reference/topic-resolution.html#default-topic-via-annotation) and/or default schema(reference/pulsar/message-consumption.html#listener-default-schema-annotation) to use when producing/consuming messages of that type. Remove checked exceptions: The APIs provided by the framework no longer throw the checked PulsarClientException , but rather the unchecked PulsarException . If you were previously catching or rethrowing PulsarClientException just to appease the compiler and were not actually handling the exception, you can simply remove your catch or throws clause. If you were actually handling the exception then you will need to replace PulsarClientException with PulsarException in your catch clause. Testing support: The spring-pulsar-test module is now available to help test your Spring for Apache Pulsar applications. See Testing Applications(reference/testing-applications.html#testing-applications) for more details."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/intro.html","Introduction: This project provides a basic Spring-friendly API for developing Apache Pulsar(https://pulsar.apache.org/) applications. On a very high level, Spring for Apache Pulsar provides a PulsarTemplate for publishing to a Pulsar topic and a PulsarListener annotation for consuming from a Pulsar topic. In addition, it also provides various convenience APIs for Spring developers to ramp up their development journey into Apache Pulsar."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/intro/system-requirements.html","System Requirements: Spring for Apache Pulsar 1.1.4 requires the following: Java 17(https://www.java.com) and is compatible up to and including Java 20 Spring Framework 6.1.13(https://spring.io/projects/spring-framework#learn) or above Apache Pulsar Java Client 3.2.4(https://pulsar.apache.org/docs/3.2.x/client-libraries-java/) or above The version compatibility matrix (including Spring Boot) can be found in the appendix(../appendix/version-compatibility.html#version-compatibility) ."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/intro/building.html","Building the Project: If you have cloned the project locally, follow these steps to build the project from the source code. Gradle 8.x (8.3 or above) is required to build. Run the following command to do a full build of the project: ./gradlew clean build You can build without running tests by using the following command: ./gradlew clean build -x test You can build the reference documentation using this command: ./gradlew :spring-pulsar-docs:antora You can view the generated HTML in docs/build/site directory."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/intro/getting-help.html","Getting Help: If you have trouble with Spring for Apache Pulsar, we would like to help. Learn the Spring basics. Spring for Apache Pulsar builds on several other Spring projects. Check the spring.io(https://spring.io) web-site for a wealth of reference documentation. If you are starting out with Spring, try one of the guides(https://spring.io/guides) . Ask a question. We monitor stackoverflow.com(https://stackoverflow.com) for questions tagged with spring-pulsar(https://stackoverflow.com/tags/spring-pulsar) . Report bugs at github.com/spring-projects/spring-pulsar/issues(https://github.com/spring-projects/spring-pulsar/issues) . All of Spring for Apache Pulsar is open source, including the documentation. If you find problems with the docs or if you want to improve them, please get involved."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/reference.html","Reference: This part of the reference documentation details the various components that comprise Spring for Apache Pulsar."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/pulsar.html","Using Spring for Apache Pulsar: Preface: We recommend using a Spring-Boot-First approach for Spring for Apache Pulsar-based applications, as that simplifies things tremendously. To do so, you can add the spring-boot-starter-pulsar module as a dependency. The majority of this reference expects the reader to be using the starter and gives most directions for configuration with that in mind. However, an effort is made to call out when instructions are specific to the Spring Boot starter usage. Section Summary: Quick Tour(pulsar/quick-tour.html) Pulsar Client(pulsar/pulsar-client.html) Message Production(pulsar/message-production.html) Message Consumption(pulsar/message-consumption.html) Publishing and Consuming Partitioned Topics(pulsar/publishing-consuming-partitioned-topics.html) Transactions(pulsar/transactions.html) Null Payloads and Log Compaction of 'Tombstone' Records(tombstones.html)"
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/pulsar/quick-tour.html","Quick Tour: Table of Contents 1. Dependencies(#_dependencies) 2. Application Code(#_application_code) We will take a quick tour of Spring for Apache Pulsar by showing a sample Spring Boot application that produces and consumes. This is a complete application and does not require any additional configuration, as long as you have a Pulsar cluster running on the default location - localhost:6650 . 1. Dependencies: Spring Boot applications need only the spring-boot-starter-pulsar dependency. The following listings show how to define the dependency for Maven and Gradle, respectively: Maven Gradle <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-pulsar</artifactId> <version>3.3.4</version> </dependency> </dependencies> dependencies { implementation 'org.springframework.boot:spring-boot-starter-pulsar:3.3.4' } 2. Application Code: The following listing shows the Spring Boot application case for the example: @SpringBootApplication public class PulsarBootHelloWorld { public static void main(String[] args) { SpringApplication.run(PulsarBootHelloWorld.class, args); } @Bean ApplicationRunner runner(PulsarTemplate<String> pulsarTemplate) { return (args) -> pulsarTemplate.send(""hello-pulsar-topic"", ""Hello Pulsar World!""); } @PulsarListener(subscriptionName = ""hello-pulsar-sub"", topics = ""hello-pulsar-topic"") void listen(String message) { System.out.println(""Message Received: "" + message); } } Let us quickly go through the higher-level details of this application. Later in the documentation we see these components in much more detail. In the preceding sample, we heavily rely on Spring Boot auto-configuration. Spring Boot auto-configures several components for our application. It automatically provides a PulsarClient , which is used by both the producer and the consumer, for the application. Spring Boot also auto-configures PulsarTemplate , which we inject in the application and start sending records to a Pulsar topic. The application sends messages to a topic named hello-pulsar . Note that the application does not specify any schema information, because Spring for Apache Pulsar library automatically infers the schema type from the type of the data that you send. We use the PulsarListener annotation to consume from the hello-pulsar topic where we publish the data. PulsarListener is a convenience annotation that wraps the message listener container infrastructure in Spring for Apache Pulsar. Behind the scenes, it creates a message listener container to create and manage the Pulsar consumer. As with a regular Pulsar consumer, the default subscription type when using PulsarListener is the Exclusive mode. As records are published in to the hello-pulsar topic, the Pulsarlistener consumes them and prints them on the console. The framework also infers the schema type used from the data type that the PulsarListner method uses as the payload — String , in this case."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/pulsar/pulsar-client.html","Pulsar Client: Table of Contents 1. TLS Encryption (SSL)(#tls-encryption) 2. Authentication(#client-authentication) 3. Automatic Cluster-Level Failover(#auto-cluster-failover) When you use the Pulsar Spring Boot Starter, you get the PulsarClient auto-configured. By default, the application tries to connect to a local Pulsar instance at pulsar://localhost:6650 . This can be adjusted by setting the spring.pulsar.client.service-url property to a different value. The value must be a valid Pulsar Protocol(https://pulsar.apache.org/docs/3.2.x/client-libraries-java/#connection-urls) URL You can further configure the client by specifying any of the spring.pulsar.client.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties. If you are not using the starter, you will need to configure and register the PulsarClient yourself. There is a DefaultPulsarClientFactory that accepts a builder customizer that can be used to help with this. 1. TLS Encryption (SSL): By default, Pulsar clients communicate with Pulsar services in plain text. The following section describes how to configure Pulsar clients to use TLS encryption (SSL). A pre-requisite is that the Broker has also been configured to use TLS encryption. The Spring Boot auto-configuration does not currently support any TLS/SSL configuration properties. You can instead provide a PulsarClientBuilderCustomizer that sets the necessary properties on the Pulsar client builder. Pulsar supports both Privacy Enhanced Mail (PEM) and Java KeyStore (JKS) certificate formats. Follow these steps to configure TLS: Adjust the Pulsar client service url to use the pulsar+ssl:// scheme and TLS port (typically 6651 ). Adjust the admin client service url to use the https:// scheme and TLS web port (typically 8443 ). Provide client builder customizer(s) that sets the relevant properties on the builder. PEM based sample(https://github.com/spring-projects/spring-pulsar/blob/02730275e8d0291525eed9db5babe880c555a7bd/integration-tests/src/intTest/java/org/springframework/pulsar/inttest/app/SamplePemBasedSslConfig.java#L30-L49) JKS based sample(https://github.com/spring-projects/spring-pulsar/blob/02730275e8d0291525eed9db5babe880c555a7bd/integration-tests/src/intTest/java/org/springframework/pulsar/inttest/app/SampleJksBasedSslConfig.java#L30-L57) You can find more information on the above in the official Pulsar TLS Encryption(https://pulsar.apache.org/docs/3.2.x/security-tls-transport/) documentation. 2. Authentication: To connect to a Pulsar cluster that requires authentication, you need to specify which authentication plugin to use and any parameters required by the specified plugin. When using Spring Boot auto-configuration, you can set the plugin and the plugin parameters via configuration properties (in most cases). You need to ensure that names defined under spring.pulsar.client.authentication.param.* exactly match those expected by your auth plugin (which is typically camel cased). Spring Boot will not attempt any kind of relaxed binding for these entries. For example, if you want to configure the issuer url for the AuthenticationOAuth2 auth plugin you must use spring.pulsar.client.authentication.param.issuerUrl . If you use other forms, such as issuerurl or issuer-url , the setting will not be applied to the plugin. Using environment variables for auth parameters is typically problematic because the case sensitivity is lost during translation. For example, consider the following issuerUrl auth parameter set via an environment variable: SPRING_PULSAR_CLIENT_AUTHENTICATION_PARAM_ISSUERURL=https://some.server.com When Spring Boot loads this property it will use issuerurl (lower-cased) rather than the expected issuerUrl (camel-cased). You can get around this limitation by using the value of the env var as the value of the related auth property in your application.yml. Continuing the example above: spring: pulsar: client: authentication: param: issuerUrl: ${SPRING_PULSAR_CLIENT_AUTHENTICATION_PARAM_ISSUERURL} When not using Spring Boot auto-configuration, you can use the org.apache.pulsar.client.api.AuthenticationFactory to create the authentication and then set it directly on the Pulsar client builder in a client customizer that you provide to the client factory. The following listings show how to configure each of the supported authentication mechanisms. Click here for Athenz spring: pulsar: client: authentication: plugin-class-name: org.apache.pulsar.client.impl.auth.AuthenticationAthenz param: tenantDomain: ... tenantService: ... providerDomain: ... privateKey: ... keyId: ... This also requires TLS encryption(#tls-encryption) . Click here for Token spring: pulsar: client: authentication: plugin-class-name: org.apache.pulsar.client.impl.auth.AuthenticationToken param: token: some-token-goes-here Click here for Basic spring: pulsar: client: authentication: plugin-class-name: org.apache.pulsar.client.impl.auth.AuthenticationBasic param: userId: ... password: ... Click here for OAuth2 spring: pulsar: client: authentication: plugin-class-name: org.apache.pulsar.client.impl.auth.oauth2.AuthenticationOAuth2 param: issuerUrl: ... privateKey: ... audience: ... scope: ... Click here for Sasl spring: pulsar: client: authentication: plugin-class-name: org.apache.pulsar.client.impl.auth.AuthenticationSasl param: saslJaasClientSectionName: ... serverType: ... Click here for mTLS (PEM) Because this option requires TLS encryption, which already requires you to provide a client builder customizer(#tls-encryption) , it is recommended to simply add the authentication directly on the client builder in your provided TLS customizer. You can use the org.apache.pulsar.client.api.AuthenticationFactory to help create the authentication object as follows: Authentication auth = AuthenticationFactory.TLS(""/path/to/my-role.cert.pem"", ""/path/to/my-role.key-pk8.pem""); See the official Pulsar documentation on mTLS (PEM)(https://pulsar.apache.org/docs/3.2.x/security-tls-authentication/#configure-mtls-authentication-in-pulsar-clients) . Click here for mTLS (JKS) Because this option requires TLS encryption, which already requires you to provide a client builder customizer(#tls-encryption) , it is recommended to simply add the authentication directly on the client builder in your provided TLS customizer. You can use the org.apache.pulsar.client.api.AuthenticationFactory to help create the authentication object as follows: Authentication auth = AuthenticationFactory.create( ""org.apache.pulsar.client.impl.auth.AuthenticationKeyStoreTls"", Map.of(""keyStoreType"", ""JKS"", ""keyStorePath"", ""/path/to/my/keystore.jks"", ""keyStorePassword"", ""clientpw"")); See the official Pulsar documentation on mTLS (JKS)(https://pulsar.apache.org/docs/3.2.x/security-tls-authentication/#configure-clients) . You can find more information on each of the support plugins and their required properties in the official Pulsar security(https://pulsar.apache.org/docs/3.2.x/security-overview#authentication-providers) documentation. 3. Automatic Cluster-Level Failover: The Pulsar Spring Boot Starter also auto-configures the PulsarClient for automatic cluster-level failover(https://pulsar.apache.org/docs/3.2.x/concepts-cluster-level-failover/) . You can use the spring.pulsar.client.failover.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties to configure cluster-level failover. The following example configures the client with a primary and two backup clusters. application.yml spring: pulsar: client: service-url: ""pulsar://my.primary.server:6650"" failover: delay: 30s switch-back-delay: 15s check-interval: 1s backup-clusters: - service-url: ""pulsar://my.second.server:6650"" authentication: plugin-class-name: org.apache.pulsar.client.impl.auth.AuthenticationToken param: token: ""my-token"" - service-url: ""pulsar://my.third.server:6650"" In addition to the client configuration, there a few prerequisites(https://pulsar.apache.org/docs/3.2.x/client-libraries-cluster-level-failover/#prerequisites) on the broker that must be satisfied in order to use this feature. When not using Spring Boot auto-configuration, you can provide a client customizer that configures the client for cluster-level failover."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/pulsar/message-production.html","Message Production: Table of Contents 1. Pulsar Template(#pulsar-producer) 1.1. Simple API(#_simple_api) 1.2. Fluent API(#_fluent_api) 1.3. Message customization(#_message_customization) 1.4. Producer customization(#single-producer-customize) 2. Specifying Schema Information(#schema-info-template-imperative) 2.1. Custom Schema Mapping(#_custom_schema_mapping) 2.1.1. Configuration properties(#_configuration_properties) 2.1.2. Schema resolver customizer(#_schema_resolver_customizer) 2.1.3. Type mapping annotation(#template-default-schema-annotation) 2.2. Producing with AUTO_SCHEMA(#template-auto-produce) 3. Pulsar Producer Factory(#pulsar-producer-factory) 3.1. Global producer customization(#global-producer-customize) 4. Pulsar Producer Caching(#producer-caching) 4.1. Caution on Lambda customizers(#producer-caching-lambdas) 5. Intercept Messages on the Producer(#_intercept_messages_on_the_producer) 1. Pulsar Template: On the Pulsar producer side, Spring Boot auto-configuration provides a PulsarTemplate for publishing records. The template implements an interface called PulsarOperations and provides methods to publish records through its contract. There are two categories of these send API methods: send and sendAsync . The send methods block calls by using the synchronous sending capabilities on the Pulsar producer. They return the MessageId of the message that was published once the message is persisted on the broker. The sendAsync method calls are asynchronous calls that are non-blocking. They return a CompletableFuture , which you can use to asynchronously receive the message ID once the messages are published. For the API variants that do not include a topic parameter, a topic resolution process(../topic-resolution.html#topic-resolution-process) is used to determine the destination topic. 1.1. Simple API: The template provides a handful of methods ( prefixed with 'send'(https://docs.spring.io/spring-pulsar/docs/1.1.4/api/org/springframework/pulsar/core/PulsarOperations.html) ) for simple send requests. For more complicated send requests, a fluent API lets you configure more options. 1.2. Fluent API: The template provides a fluent builder(https://docs.spring.io/spring-pulsar/docs/1.1.4/api/org/springframework/pulsar/core/PulsarOperations.html#newMessage(T)) to handle more complicated send requests. 1.3. Message customization: You can specify a TypedMessageBuilderCustomizer to configure the outgoing message. For example, the following code shows how to send a keyed message: template.newMessage(msg) .withMessageCustomizer((mb) -> mb.key(""foo-msg-key"")) .send(); 1.4. Producer customization: You can specify a ProducerBuilderCustomizer to configure the underlying Pulsar producer builder that ultimately constructs the producer used to send the outgoing message. Use with caution as this gives full access to the producer builder and invoking some of its methods (such as create ) may have unintended side effects. For example, the following code shows how to disable batching and enable chunking: template.newMessage(msg) .withProducerCustomizer((pb) -> pb.enableChunking(true).enableBatching(false)) .send(); This other example shows how to use custom routing when publishing records to partitioned topics. Specify your custom MessageRouter implementation on the Producer builder such as: template.newMessage(msg) .withProducerCustomizer((pb) -> pb.messageRouter(messageRouter)) .send(); Note that, when using a MessageRouter , the only valid setting for spring.pulsar.producer.message-routing-mode is custom . This other example shows how to add a ProducerInterceptor that will intercept and mutate messages received by the producer before being published to the brokers: template.newMessage(msg) .withProducerCustomizer((pb) -> pb.intercept(interceptor)) .send(); The customizer will only apply to the producer used for the send operation. If you want to apply a customizer to all producers, you must provide them to the producer factory as described in Global producer customization(#global-producer-customize) . The rules described in “ Caution on Lambda customizers(#producer-caching-lambdas) ” must be followed when using Lambda customizers. 2. Specifying Schema Information: If you use Java primitive types, the framework auto-detects the schema for you, and you need not specify any schema types for publishing the data. For non-primitive types, if the Schema is not explicitly specified when invoking send operations on the PulsarTemplate , the Spring for Apache Pulsar framework will try to build a Schema.JSON from the type. Complex Schema types that are currently supported are JSON, AVRO, PROTOBUF, AUTO_PRODUCE_BYTES, and KEY_VALUE w/ INLINE encoding. 2.1. Custom Schema Mapping: As an alternative to specifying the schema when invoking send operations on the PulsarTemplate for complex types, the schema resolver can be configured with mappings for the types. This removes the need to specify the schema as the framework consults the resolver using the outgoing message type. 2.1.1. Configuration properties: Schema mappings can be configured with the spring.pulsar.defaults.type-mappings property. The following example uses application.yml to add mappings for the User and Address complex objects using AVRO and JSON schemas, respectively: spring: pulsar: defaults: type-mappings: - message-type: com.acme.User schema-info: schema-type: AVRO - message-type: com.acme.Address schema-info: schema-type: JSON The message-type is the fully-qualified name of the message class. 2.1.2. Schema resolver customizer: The preferred method of adding mappings is via the property mentioned above. However, if more control is needed you can provide a schema resolver customizer to add the mapping(s). The following example uses a schema resolver customizer to add mappings for the User and Address complex objects using AVRO and JSON schemas, respectively: @Bean public SchemaResolverCustomizer<DefaultSchemaResolver> schemaResolverCustomizer() { return (schemaResolver) -> { schemaResolver.addCustomSchemaMapping(User.class, Schema.AVRO(User.class)); schemaResolver.addCustomSchemaMapping(Address.class, Schema.JSON(Address.class)); } } 2.1.3. Type mapping annotation: Another option for specifying default schema information to use for a particular message type is to mark the message class with the @PulsarMessage annotation. The schema info can be specified via the schemaType attribute on the annotation. The following example configures the system to use JSON as the default schema when producing or consuming messages of type Foo : @PulsarMessage(schemaType = SchemaType.JSON) record Foo(String value) { } With this configuration in place, there is no need to set specify the schema on send operations. 2.2. Producing with AUTO_SCHEMA: If there is no chance to know the type of schema of a Pulsar topic in advance, you can use an AUTO_PRODUCE(https://pulsar.apache.org/docs/3.2.x/schema-get-started/#auto_produce) schema to publish a raw JSON or Avro payload as a byte[] safely. In this case, the producer validates whether the outbound bytes are compatible with the schema of the destination topic. Simply specify a schema of Schema.AUTO_PRODUCE_BYTES() on your template send operations as shown in the example below: void sendUserAsBytes(PulsarTemplate<byte[]> template, byte[] userAsBytes) { template.send(""user-topic"", userAsBytes, Schema.AUTO_PRODUCE_BYTES()); } This is only supported with Avro and JSON schema types. 3. Pulsar Producer Factory: The PulsarTemplate relies on a PulsarProducerFactory to actually create the underlying producer. Spring Boot auto-configuration also provides this producer factory which you can further configure by specifying any of the spring.pulsar.producer.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties. If topic information is not specified when using the producer factory APIs directly, the same topic resolution process(../topic-resolution.html#topic-resolution-process) used by the PulsarTemplate is used with the one exception that the ""Message type default"" step is omitted . 3.1. Global producer customization: The framework provides the ProducerBuilderCustomizer contract which allows you to configure the underlying builder which is used to construct each producer. To customize all producers, you can pass a list of customizers into the PulsarProducerFactory constructor. When using multiple customizers, they are applied in the order in which they appear in the list. If you use Spring Boot auto-configuration, you can specify the customizers as beans and they will be passed automatically to the PulsarProducerFactory , ordered according to their @Order annotation. If you want to apply a customizer to just a single producer, you can use the Fluent API and specify the customizer at send time(#single-producer-customize) . 4. Pulsar Producer Caching: Each underlying Pulsar producer consumes resources. To improve performance and avoid continual creation of producers, the producer factory caches the producers that it creates. They are cached in an LRU fashion and evicted when they have not been used within a configured time period. The cache key(https://github.com/spring-projects/spring-pulsar/blob/8e33ac0b122bc0e75df299919c956cacabcc9809/spring-pulsar/src/main/java/org/springframework/pulsar/core/CachingPulsarProducerFactory.java#L159) is composed of just enough information to ensure that callers are returned the same producer on subsequent creation requests. Additionally, you can configure the cache settings by specifying any of the spring.pulsar.producer.cache.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties. 4.1. Caution on Lambda customizers: Any user-provided producer customizers are also included in the cache key. Because the cache key relies on a valid implementation of equals/hashCode , one must take caution when using Lambda customizers. RULE: Two customizers implemented as Lambdas will match on equals/hashCode if and only if they use the same Lambda instance and do not require any variable defined outside its closure. To clarify the above rule we will look at a few examples. In the following example, the customizer is defined as an inline Lambda which means that each call to sendUser uses the same Lambda instance. Additionally, it requires no variable outside its closure. Therefore, it will match as a cache key. void sendUser() { var user = randomUser(); template.newMessage(user) .withTopic(""user-topic"") .withProducerCustomizer((b) -> b.producerName(""user"")) .send(); } In this next case, the customizer is defined as an inline Lambda which means that each call to sendUser uses the same Lambda instance. However, it requires a variable outside its closure. Therefore, it will not match as a cache key. void sendUser() { var user = randomUser(); var name = randomName(); template.newMessage(user) .withTopic(""user-topic"") .withProducerCustomizer((b) -> b.producerName(name)) .send(); } In this final example, the customizer is defined as an inline Lambda which means that each call to sendUser uses the same Lambda instance. While it does use a variable name, it does not originate outside its closure and therefore will match as a cache key. This illustrates that variables can be used within the Lambda closure and can even make calls to static methods. void sendUser() { var user = randomUser(); template.newMessage(user) .withTopic(""user-topic"") .withProducerCustomizer((b) -> { var name = SomeHelper.someStaticMethod(); b.producerName(name); }) .send(); } RULE: If your Lambda customizer is not defined once and only once (the same instance is used on subsequent calls) OR it requires variable(s) defined outside its closure then you must provide a customizer implementation with a valid equals/hashCode implementation. If these rules are not followed then the producer cache will always miss and your application performance will be negatively affected. 5. Intercept Messages on the Producer: Adding a ProducerInterceptor lets you intercept and mutate messages received by the producer before they are published to the brokers. To do so, you can pass a list of interceptors into the PulsarTemplate constructor. When using multiple interceptors, the order they are applied in is the order in which they appear in the list. If you use Spring Boot auto-configuration, you can specify the interceptors as Beans. They are passed automatically to the PulsarTemplate . Ordering of the interceptors is achieved by using the @Order annotation as follows: @Bean @Order(100) ProducerInterceptor firstInterceptor() { ... } @Bean @Order(200) ProducerInterceptor secondInterceptor() { ... } If you are not using the starter, you will need to configure and register the aforementioned components yourself."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/pulsar/message-consumption.html","Message Consumption: Table of Contents 1. Pulsar Listener(#pulsar-listener) 1.1. Generic records with AUTO_CONSUME(#listener-auto-consume) 1.2. Customizing the ConsumerBuilder(#_customizing_the_consumerbuilder) 2. Specifying Schema Information(#schema-info-listener-imperative) 2.1. Custom Schema Mapping(#_custom_schema_mapping) 2.1.1. Configuration properties(#_configuration_properties) 2.1.2. Schema resolver customizer(#_schema_resolver_customizer) 2.1.3. Type mapping annotation(#listener-default-schema-annotation) 3. Accessing the Pulsar Consumer Object(#_accessing_the_pulsar_consumer_object) 4. Pulsar Message Listener Container(#pulsar-message-listener-container) 4.1. DefaultPulsarMessageListenerContainer(#_defaultpulsarmessagelistenercontainer) 4.2. ConcurrentPulsarMessageListenerContainer(#_concurrentpulsarmessagelistenercontainer) 4.3. Consuming Records(#consuming-records) 5. Pulsar Headers(#pulsar-headers) 5.1. Accessing in Single Record based Consumer(#_accessing_in_single_record_based_consumer) 5.2. Accessing in Batch Record based Consumer(#_accessing_in_batch_record_based_consumer) 6. Message Acknowledgment(#_message_acknowledgment) 6.1. Message ACK modes(#message-ack-modes) 6.2. Automatic Message Ack in Single Record Mode(#_automatic_message_ack_in_single_record_mode) 6.3. Manual Message Ack in Single Record Mode(#_manual_message_ack_in_single_record_mode) 6.4. Automatic Message Ack in Batch Consumption(#_automatic_message_ack_in_batch_consumption) 6.5. Manual Message Ack in Batch Consumption(#_manual_message_ack_in_batch_consumption) 7. Message Redelivery and Error Handling(#_message_redelivery_and_error_handling) 7.1. Specifying Acknowledgment Timeout for Message Redelivery(#_specifying_acknowledgment_timeout_for_message_redelivery) 7.2. Specifying Negative Acknowledgment Redelivery(#_specifying_negative_acknowledgment_redelivery) 7.3. Using Dead Letter Topic from Apache Pulsar for Message Redelivery and Error Handling(#_using_dead_letter_topic_from_apache_pulsar_for_message_redelivery_and_error_handling) 7.4. Native Error Handling in Spring for Apache Pulsar(#_native_error_handling_in_spring_for_apache_pulsar) 7.5. Batch listener with PulsarConsumerErrorHandler(#_batch_listener_with_pulsarconsumererrorhandler) 8. Consumer Customization on PulsarListener(#_consumer_customization_on_pulsarlistener) 9. Pausing and Resuming Message Listener Containers(#_pausing_and_resuming_message_listener_containers) 10. Pulsar Reader Support(#imperative-pulsar-reader) 10.1. PulsarReader Annotation(#_pulsarreader_annotation) 10.2. Customizing the ReaderBuilder(#_customizing_the_readerbuilder) 1. Pulsar Listener: When it comes to Pulsar consumers, we recommend that end-user applications use the PulsarListener annotation. To use PulsarListener , you need to use the @EnablePulsar annotation. When you use Spring Boot support, it automatically enables this annotation and configures all the components necessary for PulsarListener , such as the message listener infrastructure (which is responsible for creating the Pulsar consumer). PulsarMessageListenerContainer uses a PulsarConsumerFactory to create and manage the Pulsar consumer the underlying Pulsar consumer that it uses to consume messages. Spring Boot provides this consumer factory which you can further configure by specifying the spring.pulsar.consumer.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties. Most of the configured properties on the factory will be respected in the listener with the following exceptions : The spring.pulsar.consumer.subscription.name property is ignored and is instead generated when not specified on the annotation. The spring.pulsar.consumer.subscription-type property is ignored and is instead taken from the value on the annotation. However, you can set the subscriptionType = {} on the annotation to instead use the property value as the default. Let us revisit the PulsarListener code snippet we saw in the quick-tour section: @PulsarListener(subscriptionName = ""hello-pulsar-subscription"", topics = ""hello-pulsar"") public void listen(String message) { System.out.println(""Message Received: "" + message); } You can further simplify this method: @PulsarListener public void listen(String message) { System.out.println(""Message Received: "" + message); } In this most basic form, when the subscriptionName is not provided on the @PulsarListener annotation an auto-generated subscription name will be used. Likewise, when the topics are not directly provided, a topic resolution process(../topic-resolution.html#topic-resolution-process) is used to determine the destination topic. In the PulsarListener method shown earlier, we receive the data as String , but we do not specify any schema types. Internally, the framework relies on Pulsar’s schema mechanism to convert the data to the required type. The framework detects that you expect the String type and then infers the schema type based on that information and provides that schema to the consumer. The framework does this inference for all primitive types. For all non-primitive types the default schema is assumed to be JSON. If a complex type is using anything besides JSON (such as AVRO or KEY_VALUE) you must provide the schema type on the annotation using the schemaType property. The following example shows another PulsarListener method, which takes an Integer : @PulsarListener(subscriptionName = ""my-subscription-1"", topics = ""my-topic-1"") public void listen(Integer message) { System.out.println(message); } The following PulsarListener method shows how we can consume complex types from a topic: @PulsarListener(subscriptionName = ""my-subscription-2"", topics = ""my-topic-2"", schemaType = SchemaType.JSON) public void listen(Foo message) { System.out.println(message); } Let us look at a few more ways. You can consume the Pulsar message directly: @PulsarListener(subscriptionName = ""my-subscription"", topics = ""my-topic"") public void listen(org.apache.pulsar.client.api.Message<String> message) { System.out.println(message.getValue()); } The following example consumes the record by using the Spring messaging envelope: @PulsarListener(subscriptionName = ""my-subscription"", topics = ""my-topic"") public void listen(org.springframework.messaging.Message<String> message) { System.out.println(message.getPayload()); } Now let us see how we can consume records in batches. The following example uses PulsarListener to consume records in batches as POJOs: @PulsarListener(subscriptionName = ""hello-batch-subscription"", topics = ""hello-batch"", schemaType = SchemaType.JSON, batch = true) public void listen(List<Foo> messages) { System.out.println(""records received :"" + messages.size()); messages.forEach((message) -> System.out.println(""record : "" + message)); } Note that, in this example, we receive the records as a collection ( List ) of objects. In addition, to enable batch consumption at the PulsarListener level, you need to set the batch property on the annotation to true . Based on the actual type that the List holds, the framework tries to infer the schema to use. If the List contains a complex type besides JSON, you still need to provide the schemaType on PulsarListener . The following uses the Message envelope provided by the Pulsar Java client: @PulsarListener(subscriptionName = ""hello-batch-subscription"", topics = ""hello-batch"", schemaType = SchemaType.JSON, batch = true) public void listen(List<Message<Foo>> messages) { System.out.println(""records received :"" + messages.size()); messages.forEach((message) -> System.out.println(""record : "" + message.getValue())); } The following example consumes batch records with an envelope of the Spring messaging Message type: @PulsarListener(subscriptionName = ""hello-batch-subscription"", topics = ""hello-batch"", schemaType = SchemaType.JSON, batch = true) public void listen(List<org.springframework.messaging.Message<Foo>> messages) { System.out.println(""records received :"" + messages.size()); messages.forEach((message) -> System.out.println(""record : "" + message.getPayload())); } Finally, you can also use the Messages holder object from Pulsar for the batch listener: @PulsarListener(subscriptionName = ""hello-batch-subscription"", topics = ""hello-batch"", schemaType = SchemaType.JSON, batch = true) public void listen(org.apache.pulsar.client.api.Messages<Foo>> messages) { System.out.println(""records received :"" + messages.size()); messages.forEach((message) -> System.out.println(""record : "" + message.getValue())); } When you use PulsarListener , you can provide Pulsar consumer properties directly on the annotation itself. This is convenient if you do not want to use the Boot configuration properties mentioned earlier or have multiple PulsarListener methods. The following example uses Pulsar consumer properties directly on PulsarListener : @PulsarListener(properties = { ""subscriptionName=subscription-1"", ""topicNames=foo-1"", ""receiverQueueSize=5000"" }) void listen(String message) { } The properties used are direct Pulsar consumer properties, not the spring.pulsar.consumer application configuration properties 1.1. Generic records with AUTO_CONSUME: If there is no chance to know the type of schema of a Pulsar topic in advance, you can use the AUTO_CONSUME schema type to consume generic records. In this case, the topic deserializes messages into GenericRecord objects using the schema info associated with the topic. To consume generic records set the schemaType = SchemaType.AUTO_CONSUME on your @PulsarListener and use a Pulsar message of type GenericRecord as the message parameter as shown below. @PulsarListener(topics = ""my-generic-topic"", schemaType = SchemaType.AUTO_CONSUME) void listen(org.apache.pulsar.client.api.Message<GenericRecord> message) { GenericRecord record = message.getValue(); record.getFields().forEach((f) -> System.out.printf(""%s = %s%n"", f.getName(), record.getField(f))); } The GenericRecord API allows access to the fields and their associated values 1.2. Customizing the ConsumerBuilder: You can customize any fields available through ConsumerBuilder using a PulsarListenerConsumerBuilderCustomizer by providing a @Bean of type PulsarListenerConsumerBuilderCustomizer and then making it available to the PulsarListener as shown below. @PulsarListener(topics = ""hello-topic"", consumerCustomizer = ""myCustomizer"") public void listen(String message) { System.out.println(""Message Received: "" + message); } @Bean PulsarListenerConsumerBuilderCustomizer<String> myCustomizer() { return (builder) -> builder.consumerName(""myConsumer""); } If your application only has a single @PulsarListener and a single PulsarListenerConsumerBuilderCustomizer bean registered then the customizer will be automatically applied. 2. Specifying Schema Information: As indicated earlier, for Java primitives, the Spring for Apache Pulsar framework can infer the proper Schema to use on the PulsarListener . For non-primitive types, if the Schema is not explicitly specified on the annotation, the Spring for Apache Pulsar framework will try to build a Schema.JSON from the type. Complex Schema types that are currently supported are JSON, AVRO, PROTOBUF, AUTO_CONSUME, KEY_VALUE w/ INLINE encoding. 2.1. Custom Schema Mapping: As an alternative to specifying the schema on the PulsarListener for complex types, the schema resolver can be configured with mappings for the types. This removes the need to set the schema on the listener as the framework consults the resolver using the incoming message type. 2.1.1. Configuration properties: Schema mappings can be configured with the spring.pulsar.defaults.type-mappings property. The following example uses application.yml to add mappings for the User and Address complex objects using AVRO and JSON schemas, respectively: spring: pulsar: defaults: type-mappings: - message-type: com.acme.User schema-info: schema-type: AVRO - message-type: com.acme.Address schema-info: schema-type: JSON The message-type is the fully-qualified name of the message class. 2.1.2. Schema resolver customizer: The preferred method of adding mappings is via the property mentioned above. However, if more control is needed you can provide a schema resolver customizer to add the mapping(s). The following example uses a schema resolver customizer to add mappings for the User and Address complex objects using AVRO and JSON schemas, respectively: @Bean public SchemaResolverCustomizer<DefaultSchemaResolver> schemaResolverCustomizer() { return (schemaResolver) -> { schemaResolver.addCustomSchemaMapping(User.class, Schema.AVRO(User.class)); schemaResolver.addCustomSchemaMapping(Address.class, Schema.JSON(Address.class)); } } 2.1.3. Type mapping annotation: Another option for specifying default schema information to use for a particular message type is to mark the message class with the @PulsarMessage annotation. The schema info can be specified via the schemaType attribute on the annotation. The following example configures the system to use JSON as the default schema when producing or consuming messages of type Foo : @PulsarMessage(schemaType = SchemaType.JSON) record Foo(String value) { } With this configuration in place, there is no need to set the schema on the listener, for example: @PulsarListener(subscriptionName = ""user-sub"", topics = ""user-topic"") public void listen(User user) { System.out.println(user); } 3. Accessing the Pulsar Consumer Object: Sometimes, you need direct access to the Pulsar Consumer object. The following example shows how to get it: @PulsarListener(subscriptionName = ""hello-pulsar-subscription"", topics = ""hello-pulsar"") public void listen(String message, org.apache.pulsar.client.api.Consumer<String> consumer) { System.out.println(""Message Received: "" + message); ConsumerStats stats = consumer.getStats(); ... } When accessing the Consumer object this way, do NOT invoke any operations that would change the Consumer’s cursor position by invoking any receive methods. All such operations must be done by the container. 4. Pulsar Message Listener Container: Now that we saw the basic interactions on the consumer side through PulsarListener . Let us now dive into the inner workings of how PulsarListener interacts with the underlying Pulsar consumer. Keep in mind that, for end-user applications, in most scenarios, we recommend using the PulsarListener annotation directly for consuming from a Pulsar topic when using Spring for Apache Pulsar, as that model covers a broad set of application use cases. However, it is important to understand how PulsarListener works internally. This section goes through those details. As briefly mentioned earlier, the message listener container is at the heart of message consumption when you use Spring for Apache Pulsar. PulsarListener uses the message listener container infrastructure behind the scenes to create and manage the Pulsar consumer. Spring for Apache Pulsar provides the contract for this message listener container through PulsarMessageListenerContainer . The default implementation for this message listener container is provided through DefaultPulsarMessageListenerContainer . As its name indicates, PulsarMessageListenerContainer contains the message listener. The container creates the Pulsar consumer and then runs a separate thread to receive and handle the data. The data is handled by the provided message listener implementation. The message listener container consumes the data in batch by using the consumer’s batchReceive method. Once data is received, it is handed over to the selected message listener implementation. The following message listener types are available when you use Spring for Apache Pulsar. PulsarRecordMessageListener(https://github.com/spring-projects/spring-pulsar/blob/8e33ac0b122bc0e75df299919c956cacabcc9809/spring-pulsar/src/main/java/org/springframework/pulsar/listener/PulsarRecordMessageListener.java#L29) PulsarAcknowledgingMessageListener(https://github.com/spring-projects/spring-pulsar/blob/ade2c74482d8ac1407ffe4840fa058475c07bcfc/spring-pulsar/src/main/java/org/springframework/pulsar/listener/PulsarAcknowledgingMessageListener.java#L28) PulsarBatchMessageListener(https://github.com/spring-projects/spring-pulsar/blob/ade2c74482d8ac1407ffe4840fa058475c07bcfc/spring-pulsar/src/main/java/org/springframework/pulsar/listener/PulsarBatchMessageListener.java#L36) PulsarBatchAcknowledgingMessageListener(https://github.com/spring-projects/spring-pulsar/blob/ade2c74482d8ac1407ffe4840fa058475c07bcfc/spring-pulsar/src/main/java/org/springframework/pulsar/listener/PulsarBatchAcknowledgingMessageListener.java#L28) We see the details about these various message listeners in the following sections. Before doing so, however, let us take a closer look at the container itself. 4.1. DefaultPulsarMessageListenerContainer: This is a single consumer-based message listener container. The following listing shows its constructor: public DefaultPulsarMessageListenerContainer(PulsarConsumerFactory<? super T> pulsarConsumerFactory, PulsarContainerProperties pulsarContainerProperties) } It receives a PulsarConsumerFactory (which it uses to create the consumer) and a PulsarContainerProperties object (which contains information about the container properties). PulsarContainerProperties has the following constructors: public PulsarContainerProperties(String... topics) public PulsarContainerProperties(Pattern topicPattern) You can provide the topic information through PulsarContainerProperties or as a consumer property that is provided to the consumer factory. The following example uses the DefaultPulsarMessageListenerContainer : Map<String, Object> config = new HashMap<>(); config.put(""topics"", ""my-topic""); PulsarConsumerFactory<String> pulsarConsumerFactorY = DefaultPulsarConsumerFactory<>(pulsarClient, config); PulsarContainerProperties pulsarContainerProperties = new PulsarContainerProperties(); pulsarContainerProperties.setMessageListener((PulsarRecordMessageListener<?>) (consumer, msg) -> { }); DefaultPulsarMessageListenerContainer<String> pulsarListenerContainer = new DefaultPulsarMessageListenerContainer(pulsarConsumerFacotyr, pulsarContainerProperties); return pulsarListenerContainer; If topic information is not specified when using the listener containers directly, the same topic resolution process(../topic-resolution.html#topic-resolution-process) used by the PulsarListener is used with the one exception that the ""Message type default"" step is omitted . DefaultPulsarMessageListenerContainer creates only a single consumer. If you want to have multiple consumers managed through multiple threads, you need to use ConcurrentPulsarMessageListenerContainer . 4.2. ConcurrentPulsarMessageListenerContainer: ConcurrentPulsarMessageListenerContainer has the following constructor: public ConcurrentPulsarMessageListenerContainer(PulsarConsumerFactory<? super T> pulsarConsumerFactory, PulsarContainerProperties pulsarContainerProperties) ConcurrentPulsarMessageListenerContainer lets you specify a concurrency property through a setter. Concurrency of more than 1 is allowed only on non-exclusive subscriptions ( failover , shared , and key-shared ). You can only have the default 1 for concurrency when you have an exclusive subscription mode. The following example enables concurrency through the PulsarListener annotation for a failover subscription. @PulsarListener(topics = ""my-topic"", subscriptionName = ""subscription-1"", subscriptionType = SubscriptionType.Failover, concurrency = ""3"") void listen(String message, Consumer<String> consumer) { ... System.out.println(""Current Thread: "" + Thread.currentThread().getName()); System.out.println(""Current Consumer: "" + consumer.getConsumerName()); } In the preceding listener, it is assumed that the topic my-topic has three partitions. If it is a non-partitioned topic, having concurrency set to 3 does nothing. You get two idle consumers in addition to the main active one. If the topic has more than three partitions, messages are load-balanced across the consumers that the container creates. If you run this PulsarListener , you see that messages from different partitions are consumed through different consumers, as implied by the thread name and consumer names printouts in the preceding example. When you use the Failover subscription this way on partitioned topics, Pulsar guarantees message ordering. The following listing shows another example of PulsarListener , but with Shared subscription and concurrency enabled. @PulsarListener(topics = ""my-topic"", subscriptionName = ""subscription-1"", subscriptionType = SubscriptionType.Shared, concurrency = ""5"") void listen(String message) { ... } In the preceding example, the PulsarListener creates five different consumers (this time, we assume that the topic has five partitions). In this version, there is no message ordering, as Shared subscriptions do not guarantee any message ordering in Pulsar. If you need message ordering and still want a shared subscription types, you need to use the Key_Shared subscription type. 4.3. Consuming Records: Let us take a look at how the message listener container enables both single-record and batch-based message consumption. Single Record Consumption: Let us revisit our basic PulsarListener for the sake of this discussion: @PulsarListener(subscriptionName = ""hello-pulsar-subscription"", topics = ""hello-pulsar"") public void listen(String message) { System.out.println(""Message Received: "" + message); } With this PulsarListener method, we essential ask Spring for Apache Pulsar to invoke the listener method with a single record each time. We mentioned that the message listener container consumes the data in batches using the batchReceive method on the consumer. The framework detects that the PulsarListener , in this case, receives a single record. This means that, on each invocation of the method, it needs a singe record. Although the records are consumed by the message listener container in batches, it iterates through the received batch and invokes the listener method through an adapter for PulsarRecordMessageListener . As you can see in the previous section, PulsarRecordMessageListener extends from the MessageListener provided by the Pulsar Java client, and it supports the basic received method. Batch Consumption: The following example shows the PulsarListener consuming records in batches: @PulsarListener(subscriptionName = ""hello-batch-subscription"", topics = ""hello-batch"", schemaType = SchemaType.JSON, batch = true) public void listen4(List<Foo> messages) { System.out.println(""records received :"" + messages.size()); messages.forEach((message) -> System.out.println(""record : "" + message)); } When you use this type of PulsarListener , the framework detects that you are in batch mode. Since it already received the data in batches by using the Consumer’s batchReceive method, it hands off the entire batch to the listener method through an adapter for PulsarBatchMessageListener . 5. Pulsar Headers: The Pulsar message metadata can be consumed as Spring message headers. The list of available headers can be found in PulsarHeaders.java(https://github.com/spring-projects/spring-pulsar/blob/main/spring-pulsar/src/main/java/org/springframework/pulsar/support/PulsarHeaders.java) . 5.1. Accessing in Single Record based Consumer: The following example shows how you can access the various Pulsar Headers in an application that uses the single record mode of consuming: @PulsarListener(topics = ""simpleListenerWithHeaders"") void simpleListenerWithHeaders(String data, @Header(PulsarHeaders.MESSAGE_ID) MessageId messageId, @Header(PulsarHeaders.RAW_DATA) byte[] rawData, @Header(""foo"") String foo) { } In the preceding example, we access the values for the messageId and rawData message metadata as well as a custom message property named foo . The Spring @Header annotation is used for each header field. You can also use Pulsar’s Message as the envelope to carry the payload. When doing so, the user can directly call the corresponding methods on the Pulsar message for retrieving the metadata. However, as a convenience, you can also retrieve it by using the Header annotation. Note that you can also use the Spring messaging Message envelope to carry the payload and then retrieve the Pulsar headers by using @Header . 5.2. Accessing in Batch Record based Consumer: In this section, we see how to access the various Pulsar Headers in an application that uses a batch consumer: @PulsarListener(topics = ""simpleBatchListenerWithHeaders"", batch = true) void simpleBatchListenerWithHeaders(List<String> data, @Header(PulsarHeaders.MESSAGE_ID) List<MessageId> messageIds, @Header(PulsarHeaders.TOPIC_NAME) List<String> topicNames, @Header(""foo"") List<String> fooValues) { } In the preceding example, we consume the data as a List<String> . When extracting the various headers, we do so as a List<> as well. Spring for Apache Pulsar ensures that the headers list corresponds to the data list. You can also extract headers in the same manner when you use the batch listener and receive payloads as List<org.apache.pulsar.client.api.Message<?> , org.apache.pulsar.client.api.Messages<?> , or org.springframework.messaging.Messsge<?> . 6. Message Acknowledgment: When you use Spring for Apache Pulsar, the message acknowledgment is handled by the framework, unless opted out by the application. In this section, we go through the details of how the framework takes care of message acknowledgment. 6.1. Message ACK modes: Spring for Apache Pulsar provides the following modes for acknowledging messages: BATCH RECORD MANUAL BATCH acknowledgment mode is the default, but you can change it on the message listener container. In the following sections, we see how acknowledgment works when you use both single and batch versions of PulsarListener and how they translate to the backing message listener container (and, ultimately, to the Pulsar consumer). 6.2. Automatic Message Ack in Single Record Mode: Let us revisit our basic single message based PulsarListener : @PulsarListener(subscriptionName = ""hello-pulsar-subscription"", topics = ""hello-pulsar"") public void listen(String message) { System.out.println(""Message Received: "" + message); } It is natural to wonder, how acknowledgment works when you use PulsarListener , especially if you are familiar with using Pulsar consumer directly. The answer comes down to the message listener container, as that is the central place in Spring for Apache Pulsar that coordinates all the consumer related activities. Assuming you are not overriding the default behavior, this is what happens behind the scenes when you use the preceding PulsarListener : First, the listener container receives messages as batches from the Pulsar consumer. The received messages are handed down to PulsarListener one message at a time. When all the records are handed down to the listener method and successfully processed, the container acknowledges all the messages from the original batch. This is the normal flow. If any records from the original batch throw an exception, Spring for Apache Pulsar track those records separately. When all the records from the batch are processed, Spring for Apache Pulsar acknowledges all the successful messages and negatively acknowledges (nack) all the failed messages. In other words, when consuming single records by using PulsarRecordMessageListener and the default ack mode of BATCH is used, the framework waits for all the records received from the batchReceive call to process successfully and then calls the acknowledge method on the Pulsar consumer. If any particular record throws an exception when invoking the handler method, Spring for Apache Pulsar tracks those records and separately calls negativeAcknowledge on those records after the entire batch is processed. If the application wants the acknowledgment or negative acknowledgment to occur per record, the RECORD ack mode can be enabled. In that case, after handling each record, the message is acknowledged if no error and negatively acknowledged if there was an error. The following example enables RECORD ack mode on the Pulsar listener: @PulsarListener(subscriptionName = ""hello-pulsar-subscription"", topics = ""hello-pulsar"", ackMode = AckMode.RECORD) public void listen(String message) { System.out.println(""Message Received: "" + message); } 6.3. Manual Message Ack in Single Record Mode: You might not always want the framework to send acknowledgments but, rather, do that directly from the application itself. Spring for Apache Pulsar provides a couple of ways to enable manual message acknowledgments. The following example shows one of them: @PulsarListener(subscriptionName = ""hello-pulsar-subscription"", topics = ""hello-pulsar"", ackMode = AckMode.MANUAL) public void listen(Message<String> message, Acknowledgment acknowledgment) { System.out.println(""Message Received: "" + message.getValue()); acknowledgment.acknowledge(); } A few things merit explanation here. First, we enablE manual ack mode by setting ackMode on PulsarListener . When enabling manual ack mode, Spring for Apache Pulsar lets the application inject an Acknowledgment object. The framework achieves this by selecting a compatible message listener container: PulsarAcknowledgingMessageListener for single record based consumption, which gives you access to an Acknowledgment object. The Acknowledgment object provides the following API methods: void acknowledge(); void acknowledge(MessageId messageId); void acknowledge(List<MessageId> messageIds); void nack(); void nack(MessageId messageId); You can inject this Acknowledgment object into your PulsarListener while using MANUAL ack mode and then call one of the corresponding methods. In the preceding PulsarListener example, we call a parameter-less acknowledge method. This is because the framework knows which Message it is currently operating under. When calling acknowledge() , you need not receive the payload with the Message enveloper` but, rather, use the target type — String , in this example. You can also call a different variant of acknowledge by providing the message ID: acknowledge.acknowledge(message.getMessageId()); When you use acknowledge(messageId) , you must receive the payload by using the Message<?> envelope. Similar to what is possible for acknowledging, the Acknowledgment API also provides options for negatively acknowledging. See the nack methods shown earlier. You can also call acknowledge directly on the Pulsar consumer: @PulsarListener(subscriptionName = ""hello-pulsar-subscription"", topics = ""hello-pulsar"", ackMode = AckMode.MANUAL) public void listen(Message<String> message, Consumer<String> consumer) { System.out.println(""Message Received: "" + message.getValue()); try { consumer.acknowledge(message); } catch (Exception e) { .... } } When calling acknowledge directly on the underlying consumer, you need to do error handling by yourself. Using the Acknowledgment does not require that, as the framework can do that for you. Therefore, you should use the Acknowledgment object approach when using manual acknowledgment. When using manual acknowledgment, it is important to understand that the framework completely stays from any acknowledgment at all. Hence, it is extremely important to think through the right acknowledgment strategies when designing applications. 6.4. Automatic Message Ack in Batch Consumption: When you consume records in batches (see “ Message ACK modes(#message-ack-modes) ”) and you use the default ack mode of BATCH is used, when the entire batch is processed successfully, the entire batch is acknowledged. If any records throw an exception, the entire batch is negatively acknowledged. Note that this may not be the same batch that was batched on the producer side. Rather, this is the batch that returned from calling batchReceive on the consumer Consider the following batch listener: @PulsarListener(subscriptionName = ""hello-pulsar-subscription"", topics = ""hello-pulsar"", batch = true) public void batchListen(List<Foo> messages) { for (Foo foo : messages) { ... } } When all the messages in the incoming collection ( messages in this example) are processed, the framework acknowledges all of them. When consuming in batch mode, RECORD is not an allowed ack mode. This might cause an issue, as an application may not want the entire batch to be re-delivered again. In such situations, you need to use the MANUAL acknowledgement mode. 6.5. Manual Message Ack in Batch Consumption: As seen in the previous section, when MANUAL ack mode is set on the message listener container, the framework does not do any acknowledgment, positive or negative. It is entirely up to the application to take care of such concerns. When MANUAL ack mode is set, Spring for Apache Pulsar selects a compatible message listener container: PulsarBatchAcknowledgingMessageListener for batch consumption, which gives you access to an Acknowledgment object. The following are the methods available in the Acknowledgment API: void acknowledge(); void acknowledge(MessageId messageId); void acknowledge(List<MessageId> messageIds); void nack(); void nack(MessageId messageId); You can inject this Acknowledgment object into your PulsarListener while using MANUAL ack mode. The following listing shows a basic example for a batch based listener: @PulsarListener(subscriptionName = ""hello-pulsar-subscription"", topics = ""hello-pulsar"") public void listen(List<Message<String>> messgaes, Acknowlegement acknowledgment) { for (Message<String> message : messages) { try { ... acknowledgment.acknowledge(message.getMessageId()); } catch (Exception e) { acknowledgment.nack(message.getMessageId()); } } } When you use a batch listener, the message listener container cannot know which record it is currently operating upon. Therefore, to manually acknowledge, you need to use one of the overloaded acknowledge method that takes a MessageId or a List<MessageId> . You can also negatively acknowledge with the MessageId for the batch listener. 7. Message Redelivery and Error Handling: Now that we have seen both PulsarListener and the message listener container infrastructure and its various functions, let us now try to understand message redelivery and error handling. Apache Pulsar provides various native strategies for message redelivery and error handling. We take a look at them and see how we can use them through Spring for Apache Pulsar. 7.1. Specifying Acknowledgment Timeout for Message Redelivery: By default, Pulsar consumers do not redeliver messages unless the consumer crashes, but you can change this behavior by setting an ack timeout on the Pulsar consumer. If the ack timeout property has a value above zero and if the Pulsar consumer does not acknowledge a message within that timeout period, the message is redelivered. When you use Spring for Apache Pulsar, you can set this property via a consumer customizer(#_consumer_customization_on_pulsarlistener) or with the native Pulsar ackTimeout property in the properties attribute of @PulsarListener : @PulsarListener(subscriptionName = ""subscription-1"", topics = ""topic-1"" properties = {""ackTimeout=60s""}) public void listen(String s) { ... } When you specify the ack timeout, if the consumer does not send an acknowledgement within 60 seconds, the message is redelivered by Pulsar to the consumer. If you want to specify some advanced backoff options for ack timeout with different delays, you can do the following: @EnablePulsar @Configuration class AckTimeoutRedeliveryConfig { @PulsarListener(subscriptionName = ""withAckTimeoutRedeliveryBackoffSubscription"", topics = ""withAckTimeoutRedeliveryBackoff-test-topic"", ackTimeoutRedeliveryBackoff = ""ackTimeoutRedeliveryBackoff"", properties = { ""ackTimeout=60s"" }) void listen(String msg) { // some long-running process that may cause an ack timeout } @Bean RedeliveryBackoff ackTimeoutRedeliveryBackoff() { return MultiplierRedeliveryBackoff.builder().minDelayMs(1000).maxDelayMs(10 * 1000).multiplier(2) .build(); } } In the preceding example, we specify a bean for Pulsar’s RedeliveryBackoff with a minimum delay of 1 second, a maximum delay of 10 seconds, and a backoff multiplier of 2. After the initial ack timeout occurs, the message redeliveries are controlled through this backoff bean. We provide the backoff bean to the PulsarListener annotation by setting the ackTimeoutRedeliveryBackoff property to the actual bean name — ackTimeoutRedeliveryBackoff , in this case. 7.2. Specifying Negative Acknowledgment Redelivery: When acknowledging negatively, Pulsar consumer lets you specify how the application wants the message to be re-delivered. The default is to redeliver the message in one minute, but you can change it via a consumer customizer(#_consumer_customization_on_pulsarlistener) or with the native Pulsar negativeAckRedeliveryDelay property in the properties attribute of @PulsarListener : @PulsarListener(subscriptionName = ""subscription-1"", topics = ""topic-1"" properties = {""negativeAckRedeliveryDelay=10ms""}) public void listen(String s) { ... } You can also specify different delays and backoff mechanisms with a multiplier by providing a RedeliveryBackoff bean and providing the bean name as the negativeAckRedeliveryBackoff property on the PulsarProducer, as follows: @EnablePulsar @Configuration class NegativeAckRedeliveryConfig { @PulsarListener(subscriptionName = ""withNegRedeliveryBackoffSubscription"", topics = ""withNegRedeliveryBackoff-test-topic"", negativeAckRedeliveryBackoff = ""redeliveryBackoff"", subscriptionType = SubscriptionType.Shared) void listen(String msg) { throw new RuntimeException(""fail "" + msg); } @Bean RedeliveryBackoff redeliveryBackoff() { return MultiplierRedeliveryBackoff.builder().minDelayMs(1000).maxDelayMs(10 * 1000).multiplier(2) .build(); } } 7.3. Using Dead Letter Topic from Apache Pulsar for Message Redelivery and Error Handling: Apache Pulsar lets applications use a dead letter topic on consumers with a Shared subscription type. For the Exclusive and Failover subscription types, this feature is not available. The basic idea is that, if a message is retried a certain number of times (maybe due to an ack timeout or nack redelivery), once the number of retries are exhausted, the message can be sent to a special topic called the dead letter queue (DLQ). Let us see some details around this feature in action by inspecting some code snippets: @EnablePulsar @Configuration class DeadLetterPolicyConfig { @PulsarListener(id = ""deadLetterPolicyListener"", subscriptionName = ""deadLetterPolicySubscription"", topics = ""topic-with-dlp"", deadLetterPolicy = ""deadLetterPolicy"", subscriptionType = SubscriptionType.Shared, properties = { ""ackTimeout=1s"" }) void listen(String msg) { throw new RuntimeException(""fail "" + msg); } @PulsarListener(id = ""dlqListener"", topics = ""my-dlq-topic"") void listenDlq(String msg) { System.out.println(""From DLQ: "" + msg); } @Bean DeadLetterPolicy deadLetterPolicy() { return DeadLetterPolicy.builder().maxRedeliverCount(10).deadLetterTopic(""my-dlq-topic"").build(); } } First, we have a special bean for DeadLetterPolicy , and it is named as deadLetterPolicy (it can be any name as you wish). This bean specifies a number of things, such as the max delivery (10, in this case) and the name of the dead letter topic — my-dlq-topic , in this case. If you do not specify a DLQ topic name, it defaults to <topicname>-<subscriptionname>-DLQ in Pulsar. Next, we provide this bean name to PulsarListener by setting the deadLetterPolicy property. Note that the PulsarListener has a subscription type of Shared , as the DLQ feature only works with shared subscriptions. This code is primarily for demonstration purposes, so we provide an ackTimeout value of 1 second. The idea is that the code throws the exception and, if Pulsar does not receive an ack within 1 second, it does a retry. If that cycle continues ten times (as that is our max redelivery count in the DeadLetterPolicy ), the Pulsar consumer publishes the messages to the DLQ topic. We have another PulsarListener that listens on the DLQ topic to receive data as it is published to the DLQ topic. Special note on DLQ topics when using partitioned topics If the main topic is partitioned, behind the scenes, each partition is treated as a separate topic by Pulsar. Pulsar appends partition-<n> , where n stands for the partition number to the main topic name. The problem is that, if you do not specify a DLQ topic (as opposed to what we did above), Pulsar publishes to a default topic name that has this `partition-<n> info in it — for example: topic-with-dlp-partition-0-deadLetterPolicySubscription-DLQ . The easy way to solve this is to provide a DLQ topic name always. 7.4. Native Error Handling in Spring for Apache Pulsar: As we noted earlier, the DLQ feature in Apache Pulsar works only for shared subscriptions. What does an application do if it needs to use some similar feature for non-shared subscriptions? The main reason Pulsar does not support DLQ on exclusive and failover subscriptions is because those subscription types are order-guaranteed. Allowing redeliveries, DLQ, and so on effectively receives messages out of order. However, what if an application are okay with that but, more importantly, needs this DLQ feature for non-shared subscriptions? For that, Spring for Apache Pulsar provides a PulsarConsumerErrorHandler , which you can use across any subscription types in Pulsar: Exclusive , Failover , Shared , or Key_Shared . When you use PulsarConsumerErrorHandler from Spring for Apache Pulsar, make sure not to set the ack timeout properties on the listener. Let us see some details by examining a few code snippets: @EnablePulsar @Configuration class PulsarConsumerErrorHandlerConfig { @Bean PulsarConsumerErrorHandler<String> pulsarConsumerErrorHandler( PulsarTemplate<String> pulsarTemplate) { return new DefaultPulsarConsumerErrorHandler<>( new PulsarDeadLetterPublishingRecoverer<>(pulsarTemplate, (c, m) -> ""my-foo-dlt""), new FixedBackOff(100, 10)); } @PulsarListener(id = ""pulsarConsumerErrorHandler-id"", subscriptionName = ""pulsatConsumerErrorHandler-subscription"", topics = ""pulsarConsumerErrorHandler-topic"", pulsarConsumerErrorHandler = ""pulsarConsumerErrorHandler"") void listen(String msg) { throw new RuntimeException(""fail "" + msg); } @PulsarListener(id = ""pceh-dltListener"", topics = ""my-foo-dlt"") void listenDlt(String msg) { System.out.println(""From DLT: "" + msg); } } Consider the pulsarConsumerErrorHandler bean. This creates a bean of type PulsarConsumerErrorHandler and uses the default implementation provided out of the box by Spring for Apache Pulsar: DefaultPulsarConsumerErrorHandler . DefaultPulsarConsumerErrorHandler has a constructor that takes a PulsarMessageRecovererFactory and a org.springframework.util.backoff.Backoff . PulsarMessageRecovererFactory is a functional interface with the following API: @FunctionalInterface public interface PulsarMessageRecovererFactory<T> { /** * Provides a message recoverer {@link PulsarMessageRecoverer}. * @param consumer Pulsar consumer * @return {@link PulsarMessageRecoverer}. */ PulsarMessageRecoverer<T> recovererForConsumer(Consumer<T> consumer); } The recovererForConsumer method takes a Pulsar consumer and returns a PulsarMessageRecoverer , which is another functional interface. Here is the API of PulsarMessageRecoverer : public interface PulsarMessageRecoverer<T> { /** * Recover a failed message, for e.g. send the message to a DLT. * @param message Pulsar message * @param exception exception from failed message */ void recoverMessage(Message<T> message, Exception exception); } Spring for Apache Pulsar provides an implementation for PulsarMessageRecovererFactory called PulsarDeadLetterPublishingRecoverer that provides a default implementation that can recover the message by sending it to a Dead Letter Topic (DLT). We provide this implementation to the constructor for the preceding DefaultPulsarConsumerErrorHandler . As the second argument, we provide a FixedBackOff . You can also provide the ExponentialBackoff from Spring for advanced backoff features. Then we provide this bean name for the PulsarConsumerErrorHandler as a property to the PulsarListener . The property is called pulsarConsumerErrorHandler . Each time the PulsarListener method fails for a message, it gets retried. The number of retries are controlled by the Backoff provided implementation values. In our example, we do 10 retries (11 total tries — the first one and then the 10 retries). Once all the retries are exhausted, the message is sent to the DLT topic. The PulsarDeadLetterPublishingRecoverer implementation we provide uses a PulsarTemplate that is used for publishing the message to the DLT. In most cases, the same auto-configured PulsarTemplate from Spring Boot is sufficient with the caveat for partitioned topics. When using partitioned topics and using custom message routing for the main topic, you must use a different PulsarTemplate that does not take the auto-configured PulsarProducerFactory that is populated with a value of custompartition for message-routing-mode . You can use a PulsarConsumerErrorHandler with the following blueprint: @Bean PulsarConsumerErrorHandler<Integer> pulsarConsumerErrorHandler(PulsarClient pulsarClient) { PulsarProducerFactory<Integer> pulsarProducerFactory = new DefaultPulsarProducerFactory<>(pulsarClient, Map.of()); PulsarTemplate<Integer> pulsarTemplate = new PulsarTemplate<>(pulsarProducerFactory); BiFunction<Consumer<?>, Message<?>, String> destinationResolver = (c, m) -> ""my-foo-dlt""; PulsarDeadLetterPublishingRecoverer<Integer> pulsarDeadLetterPublishingRecoverer = new PulsarDeadLetterPublishingRecoverer<>(pulsarTemplate, destinationResolver); return new DefaultPulsarConsumerErrorHandler<>(pulsarDeadLetterPublishingRecoverer, new FixedBackOff(100, 5)); } Note that we are provide a destination resolver to the PulsarDeadLetterPublishingRecoverer as the second constructor argument. If not provided, PulsarDeadLetterPublishingRecoverer uses <subscription-name>-<topic-name>-DLT> as the DLT topic name. When using this feature, you should use a proper destination name by setting the destination resolver rather than using the default. When using a single record message listener, as we did with PulsarConsumerErrorHnadler , and if you use manual acknowledgement, make sure to not negatively acknowledge the message when an exception is thrown. Rather, re-throw the exception back to the container. Otherwise, the container thinks the message is handled separately, and the error handling is not triggered. Finally, we have a second PulsarListener that receives messages from the DLT topic. In the examples provided in this section so far, we only saw how to use PulsarConsumerErrorHandler with a single record message listener. Next, we look at how you can use this on batch listeners. 7.5. Batch listener with PulsarConsumerErrorHandler: First, let us look at a batch PulsarListener method: @PulsarListener(subscriptionName = ""batch-demo-5-sub"", topics = ""batch-demo-4"", batch = true, concurrency = ""3"", subscriptionType = SubscriptionType.Failover, pulsarConsumerErrorHandler = ""pulsarConsumerErrorHandler"", ackMode = AckMode.MANUAL) void listen(List<Message<Integer>> data, Consumer<Integer> consumer, Acknowledgment acknowledgment) { for (Message<Integer> datum : data) { if (datum.getValue() == 5) { throw new PulsarBatchListenerFailedException(""failed"", datum); } acknowledgement.acknowledge(datum.getMessageId()); } } @Bean PulsarConsumerErrorHandler<String> pulsarConsumerErrorHandler( PulsarTemplate<String> pulsarTemplate) { return new DefaultPulsarConsumerErrorHandler<>( new PulsarDeadLetterPublishingRecoverer<>(pulsarTemplate, (c, m) -> ""my-foo-dlt""), new FixedBackOff(100, 10)); } @PulsarListener(subscriptionName = ""my-dlt-subscription"", topics = ""my-foo-dlt"") void dltReceiver(Message<Integer> message) { System.out.println(""DLT - RECEIVED: "" + message.getValue()); } Once again, we provide the pulsarConsumerErrorHandler property with the PulsarConsumerErrorHandler bean name. When you use a batch listener (as shown in the preceding example) and want to use the PulsarConsumerErrorHandler from Spring for Apache Pulsar, you need to use manual acknowledgment. This way, you can acknowledge all the successful individual messages. For the ones that fail, you must throw a PulsarBatchListenerFailedException with the message on which it fails. Without this exception, the framework does not know what to do with the failure. On retry, the container sends a new batch of messages, starting with the failed message to the listener. If it fails again, it is retried, until the retries are exhausted, at which point the message is sent to the DLT. At that point, the message is acknowledged by the container, and the listener is handed over with the subsequent messages in the original batch. 8. Consumer Customization on PulsarListener: Spring for Apache Pulsar provides a convenient way to customize the consumer created by the container used by the PulsarListener . Applications can provide a bean for PulsarListenerConsumerBuilderCustomizer . Here is an example. @Bean public PulsarListenerConsumerBuilderCustomizer<String> myCustomizer() { return cb -> { cb.subscriptionName(""modified-subscription-name""); }; } Then this customizer bean name can be provided as an attribute on the PuslarListener annotation as shown below. @PulsarListener(subscriptionName = ""my-subscription"", topics = ""my-topic"", consumerCustomizer = ""myCustomizer"") void listen(String message) { } The framework detects the provided bean through the PulsarListener and applies this customizer on the Consumer builder before creating the Pulsar Consumer. If you have multiple PulsarListener methods, and each of them have different customization rules, you should create multiple customizer beans and attach the proper customizers on each PulsarListener . 9. Pausing and Resuming Message Listener Containers: There are situations in which an application might want to pause message consumption temporarily and then resume later. Spring for Apache Pulsar provides the ability to pause and resume the underlying message listener containers. When the Pulsar message listener container is paused, any polling done by the container to receive data from the Pulsar consumer will be paused. Similarly, when the container is resumed, the next poll starts returning data if the topic has any new records added while paused. To pause or resume a listener container, first obtain the container instance via the PulsarListenerEndpointRegistry bean and then invoke the pause/resume API on the container instance - as shown in the snippet below: @Autowired private PulsarListenerEndpointRegistry registry; void someMethod() { PulsarMessageListenerContainer container = registry.getListenerContainer(""my-listener-id""); container.pause(); } The id parameter passed to getListenerContainer is the container id - which will be the value of the @PulsarListener id attribute when pausing/resuming a @PulsarListener . 10. Pulsar Reader Support: The framework provides support for using Pulsar Reader(https://pulsar.apache.org/docs/3.2.x/concepts-clients/#reader-interface) via the PulsarReaderFactory . Spring Boot provides this reader factory which you can further configure by specifying any of the spring.pulsar.reader.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties. 10.1. PulsarReader Annotation: While it is possible to use PulsarReaderFactory directly, Spring for Apache Pulsar provides the PulsarReader annotation that you can use to quickly read from a topic without setting up any reader factories yourselves. This is similar to the same ideas behind PulsarListener. Here is a quick example. @PulsarReader(id = ""reader-demo-id"", topics = ""reader-demo-topic"", startMessageId = ""earliest"") void read(String message) { //... } The id attribute is optional, but it is a best practice to provide a value that is meaningful to your application. When not specified an auto-generated id will be used. On the other hand, the topics and startMessageId attributes are mandatory. The topics attribute can be a single topic or a comma-separated list of topics. The startMessageId attribute instructs the reader to start from a particular message in the topic. The valid values for startMessageId are earliest or latest. Suppose you want the reader to start reading messages arbitrarily from a topic other than the earliest or latest available messages. In that case, you need to use a ReaderBuilderCustomizer to customize the ReaderBuilder so it knows the right MessageId to start from. 10.2. Customizing the ReaderBuilder: You can customize any fields available through ReaderBuilder using a PulsarReaderReaderBuilderCustomizer in Spring for Apache Pulsar. You can provide a @Bean of type PulsarReaderReaderBuilderCustomizer and then make it available to the PulsarReader as below. @PulsarReader(id = ""reader-customizer-demo-id"", topics = ""reader-customizer-demo-topic"", readerCustomizer = ""myCustomizer"") void read(String message) { //... } @Bean public PulsarReaderReaderBuilderCustomizer<String> myCustomizer() { return readerBuilder -> { readerBuilder.startMessageId(messageId); // the first message read is after this message id. // Any other customizations on the readerBuilder }; } If your application only has a single @PulsarReader and a single PulsarReaderReaderBuilderCustomizer bean registered then the customizer will be automatically applied."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/pulsar/publishing-consuming-partitioned-topics.html","Publishing and Consuming Partitioned Topics: In the following example, we publish to a topic called hello-pulsar-partitioned . It is a topic that is partitioned, and, for this sample, we assume that the topic is already created with three partitions. @SpringBootApplication public class PulsarBootPartitioned { public static void main(String[] args) { SpringApplication.run(PulsarBootPartitioned.class, ""--spring.pulsar.producer.message-routing-mode=CustomPartition""); } @Bean public ApplicationRunner runner(PulsarTemplate<String> pulsarTemplate) { pulsarTemplate.setDefaultTopicName(""hello-pulsar-partitioned""); return args -> { for (int i = 0; i < 10; i++) { pulsarTemplate.sendAsync(""hello john doe 0 "", new FooRouter()); pulsarTemplate.sendAsync(""hello alice doe 1"", new BarRouter()); pulsarTemplate.sendAsync(""hello buzz doe 2"", new BuzzRouter()); } }; } @PulsarListener(subscriptionName = ""hello-pulsar-partitioned-subscription"", topics = ""hello-pulsar-partitioned"") public void listen(String message) { System.out.println(""Message Received: "" + message); } static class FooRouter implements MessageRouter { @Override public int choosePartition(Message<?> msg, TopicMetadata metadata) { return 0; } } static class BarRouter implements MessageRouter { @Override public int choosePartition(Message<?> msg, TopicMetadata metadata) { return 1; } } static class BuzzRouter implements MessageRouter { @Override public int choosePartition(Message<?> msg, TopicMetadata metadata) { return 2; } } } In the preceding example, we publish to a partitioned topic, and we would like to publish some data segment to a specific partition. If you leave it to Pulsar’s default, it follows a round-robin mode of partition assignments, and we would like to override that. To do so, we provide a message router object with the send method. Consider the three message routers implemented. FooRouter always sends data to partition 0 , BarRouter sends to partition 1 , and BuzzRouter sends to partition 2 . Also note that we now use the sendAsync method of PulsarTemplate that returns a CompletableFuture . When running the application, we also need to set the messageRoutingMode on the producer to CustomPartition ( spring.pulsar.producer.message-routing-mode ). On the consumer side, we use a PulsarListener with the exclusive subscription type. This means that data from all the partitions ends up in the same consumer and there is no ordering guarantee. What can we do if we want each partition to be consumed by a single distinct consumer? We can switch to the failover subscription mode and add three separate consumers: @PulsarListener(subscriptionName = ""hello-pulsar-partitioned-subscription"", topics = ""hello-pulsar-partitioned"", subscriptionType = SubscriptionType.Failover) public void listen1(String foo) { System.out.println(""Message Received 1: "" + foo); } @PulsarListener(subscriptionName = ""hello-pulsar-partitioned-subscription"", topics = ""hello-pulsar-partitioned"", subscriptionType = SubscriptionType.Failover) public void listen2(String foo) { System.out.println(""Message Received 2: "" + foo); } @PulsarListener(subscriptionName = ""hello-pulsar-partitioned-subscription"", topics = ""hello-pulsar-partitioned"", subscriptionType = SubscriptionType.Failover) public void listen3(String foo) { System.out.println(""Message Received 3: "" + foo); } When you follow this approach, a single partition always gets consumed by a dedicated consumer. In a similar vein, if you want to use Pulsar’s shared consumer type, you can use the shared subscription type. However, when you use the shared mode, you lose any ordering guarantees, as a single consumer may receive messages from all the partitions before another consumer gets a chance. Consider the following example: @PulsarListener(subscriptionName = ""hello-pulsar-shared-subscription"", topics = ""hello-pulsar-partitioned"", subscriptionType = SubscriptionType.Shared) public void listen1(String foo) { System.out.println(""Message Received 1: "" + foo); } @PulsarListener(subscriptionName = ""hello-pulsar-shared-subscription"", topics = ""hello-pulsar-partitioned"", subscriptionType = SubscriptionType.Shared) public void listen2(String foo) { System.out.println(""Message Received 2: "" + foo); }"
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/pulsar/transactions.html","Transactions: This section describes how Spring for Apache Pulsar supports transactions. Overview: Spring for Apache Pulsar transaction support is built upon the transaction support(https://docs.spring.io/spring-framework/reference/data-access/transaction.html) provided by Spring Framework. At a high-level, transactional resources are registered with a transaction manager which in turn handles the transactional state (commit, rollback, etc..) of the registered resources. Spring for Apache Pulsar provides the following: PulsarTransactionManager - used with normal Spring transaction support ( @Transactional , TransactionTemplate , etc) Transactional PulsarTemplate Transactional @PulsarListener Transaction synchronization with other transaction managers Transaction support has not been added to the Reactive components yet Transaction support is disabled by default. To enable support when using Spring Boot, simply set the spring.pulsar.transaction.enabled property. Further configuration options are outlined in each component section below. Transactional Publishing with PulsarTemplate: All send operations on a transactional PulsarTemplate look for an active transaction and enlist each send operation in the transaction (if one is found). Non-transactional use: By default, a transactional PulsarTemplate can also be used for non-transactional operations. When an existing transaction is not found it will continue the send operation in a non-transactional fashion. However, if the template is configured to require transactions then any attempt to use the template outside the scope of a transaction results in an exception. A transaction can be started by a TransactionTemplate , a @Transactional method, calling executeInTransaction , or by a transactional listener container. Local Transactions: We use the term ""local"" transaction to denote a Pulsar native transaction that is not managed by or associated with Spring’s transaction management facility (i.e. PulsarTransactionManager ). Conversely, a ""synchronized"" transaction is one that is managed by or associated with the PulsarTransactionManager . You can use the PulsarTemplate to execute a series of operations within a local transaction. The following example shows how to do so: var results = pulsarTemplate.executeInTransaction((template) -> { var rv = new HashMap<String, MessageId>(); rv.put(""msg1"", template.send(topic, ""msg1"")); rv.put(""msg2"", template.send(topic, ""msg2"")); return rv; }); The argument in the callback is the template instance that the executeInTransaction method was invoked on. All operations on the template are enlisted in the current transaction. If the callback exits normally, the transaction is committed. If an exception is thrown, the transaction is rolled back. If there is a synchronized transaction in process, it is ignored and a new ""nested"" transaction is used. Configuration: The following transaction settings are available directly on the PulsarTemplate (via the transactions field): enabled - whether the template supports transactions (default false ) required - whether the template requires transactions (default false ) timeout - duration of the transaction timeout (default null ) When not using Spring Boot, you can adjust these settings on the template that you provide. However, when using Spring Boot, the template is auto-configured and there is no mechanism to affect the properties. In this case you can register a PulsarTemplateCustomizer bean that can be used to adjust the settings. The following example shows how to set the timeout on the auto-configured template: @Bean PulsarTemplateCustomizer<?> templateCustomizer() { return (template) -> template.transactions().setTimeout(Duration.ofSeconds(45)); } Transactional Receiving with @PulsarListener: When listener transactions are enabled, the @PulsarListener annotated listener method is invoked in the scope of a synchronized transaction. The DefaultPulsarMessageListenerContainer uses a Spring TransactionTemplate configured with a PulsarTransactionManager to initiate the transaction prior to method invocation. The acknowledgment of each received message is enlisted in the scoped transaction. Consume-Process-Produce Scenario: A common transactional pattern is where a consumer reads messages from a Pulsar topic, transforms the messages, and finally a producer writes the resulting messages to another Pulsar topic. The framework supports this use case when transactions are enabled and your listener method uses a transactional PulsarTemplate to produce the transformed message. Given the following listener method: @PulsarListener(topics = ""my-input-topic"") (1) void listen(String msg) { (2) var transformedMsg = msg.toUpperCase(); (3) this.transactionalTemplate.send(""my-output-topic"", transformedMsg); (4) } (5) (6) The following interactions occur when listener transactions are enabled: 1 Listener container initiates new transaction and invokes listener method in scope of transaction 2 Listener method receives message 3 Listener method transforms message 4 Listener method sends transformed message with transactional template which enlists send operation in active transaction 5 Listener container auto-acks message and enlists ack operation in active transaction 6 Listener container (via TransactionTemplate ) commits transaction If you are not using @PulsarListener and instead using listener containers directly, the same transaction support is provided as described above. Remember, the @PulsarListener is just a convenience to register a Java method as the listener container message listener. Transactions with Record Listeners: The above example uses a record listener. When using a record listener, a new transaction is created on every listener method invocation which equates to a transaction per message. Because the transaction boundary is per message and each message acknowledgement is enlisted in each transaction, batch ack mode can not be used with transactional record listeners. Transactions with Batch Listeners: When using a batch listener, a new transaction is created on every listener method invocation which equates to a transaction per batch of messages. Transactional batch listeners do not currently support custom error handlers. Configuration: Listener container factory: The following transaction settings are available directly on the PulsarContainerProperties used by the ConcurrentPulsarListenerContainerFactory when creating listener containers. These settings affect all listener containers, including the ones used by @PulsarListener . enabled - whether the container supports transactions (default false ) required - whether the container requires transactions (default false ) timeout - duration of the transaction timeout (default null ) transactionDefinition - a blueprint transaction definition with properties that will be copied to the container’s transaction template (default null ) transactionManager - the transaction manager used to start transactions When not using Spring Boot, you can adjust these settings on the container factory that you provide. However, when using Spring Boot, the container factory is auto-configured. In this case you can register a ConcurrentPulsarListenerContainerFactoryCustomizer bean to access and customize the container properties. The following example shows how to set the timeout on the container factory: @Bean ConcurrentPulsarListenerContainerFactoryCustomizer<?> containerCustomizer() { return (containerFactory) -> containerFactory.getContainerProperties().transactions().setTimeout(Duration.ofSeconds(45)); } @PulsarListener: By default, each listener respects the transactional settings of its corresponding listener container factory. However, the user can set the transactional attribute on each @PulsarListener to override the container factory setting as follows: If the container factory has transactions enabled then transactional = false will disable transactions for the indiviual listener. If the container factory has transactions enabled and required, then an attempt to set transactional = false will result in an exception being thrown stating that transactions are required. If the container factory has transactions disabled then an attempt to set transactional = true will be ignored and a warning will be logged. Using PulsarTransactionManager: The PulsarTransactionManager is an implementation of Spring Framework’s PlatformTransactionManager . You can use the PulsarTransactionManager with normal Spring transaction support ( @Transactional , TransactionTemplate , and others). If a transaction is active, any PulsarTemplate operations performed within the scope of the transaction enlist and participate in the ongoing transaction. The manager commits or rolls back the transaction, depending on success or failure. You probably will not need to use PulsarTransactionManager directly since the majority of transactional use cases are covered by PulsarTemplate and @PulsarListener . Pulsar Transactions with Other Transaction Managers: Producer-only transaction: If you want to send records to Pulsar and perform some database updates in a single transaction, you can use normal Spring transaction management with a DataSourceTransactionManager . The following examples assume there is a DataSourceTransactionManager bean registered under the name ""dataSourceTransactionManager"" @Transactional(""dataSourceTransactionManager"") public void myServiceMethod() { var msg = calculateMessage(); this.pulsarTemplate.send(""my-topic"", msg); this.jdbcTemplate.execute(""insert into my_table (data) values ('%s')"".formatted(msg)); } The interceptor for the @Transactional annotation starts the database transaction and the PulsarTemplate will synchronize a transaction with the DB transaction manager; each send will participate in that transaction. When the method exits, the database transaction will commit followed by the Pulsar transaction. If you wish to commit the Pulsar transaction first, and only commit the DB transaction if the Pulsar transaction is successful, use nested @Transactional methods, with the outer method configured to use the DataSourceTransactionManager , and the inner method configured to use the PulsarTransactionManager . @Transactional(""dataSourceTransactionManager"") public void myServiceMethod() { var msg = calculateMessage(); this.jdbcTemplate.execute(""insert into my_table (data) values ('%s')"".formatted(msg)); this.sendToPulsar(msg); } @Transactional(""pulsarTransactionManager"") public void sendToPulsar(String msg) { this.pulsarTemplate.send(""my-topic"", msg); } Consumer + Producer transaction: If you want to consume records from Pulsar, send records to Pulsar, and perform some database updates in a transaction, you can combine normal Spring transaction management (using a DataSourceTransactionManager ) with container initiated transactions. In the following example, the listener container starts the Pulsar transaction and the @Transactional annotation starts the DB transaction. The DB transaction is committed first; if the Pulsar transaction fails to commit, the record will be redelivered so the DB update should be idempotent. @PulsarListener(topics = ""my-input-topic"") @Transactional(""dataSourceTransactionManager"") void listen(String msg) { var transformedMsg = msg.toUpperCase(); this.pulsarTemplate.send(""my-output-topic"", transformedMsg); this.jdbcTemplate.execute(""insert into my_table (data) values ('%s')"".formatted(transformedMsg)); }"
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/tombstones.html","Null Payloads and Log Compaction of 'Tombstone' Records: When using log compaction, you can send and receive messages with null payloads to identify the deletion of a key. You can also receive null values for other reasons, such as a deserializer that might return null when it cannot deserialize a value. Producing Null Payloads: To send a null payload by using the PulsarTemplate , you can use the fluent API and pass null into the value argument of the newMessage() method, for example: pulsarTemplate .newMessage(null) .withTopic(""my-topic"") .withSchema(Schema.STRING) .withMessageCustomizer((mb) -> mb.key(""key:1234"")) .send(); When sending null values you must specify the schema type as the system can not determine the type of the message from a null payload. Consuming Null Payloads: For @PulsarListener and @PulsarReader , the null payload is passed into the listener method based on the type of its message parameter as follows: Parameter type Passed-in value primitive null user-defined null org.apache.pulsar.client.api.Message<T> non-null Pulsar message whose getValue() returns null org.springframework.messaging.Message<T> non-null Spring message whose getPayload() returns PulsarNull List<X> non-null list whose entries ( X ) are one of the above types and act accordingly (ie. primitive entries are null etc..) org.apache.pulsar.client.api.Messages<T> non-null container of non-null Pulsar messages whose getValue() returns null When the passed-in value is null (ie. single record listeners with primitive or user-defined types) you must use the @Payload parameter annotation with required = false . When using the Spring org.springframework.messaging.Message for your listener payload type, its generic type information must be wide enough to accept Message<PulsarNull> (eg. Message , Message<?> , or Message<Object> ). This is due to the fact that the Spring Message does not allow null values for its payload and instead uses the PulsarNull placeholder. If it is a tombstone message for a compacted log, you usually also need the key so that your application can determine which key was "" deleted "". The following example shows such a configuration: @PulsarListener( topics = ""my-topic"", subscriptionName = ""my-topic-sub"", schemaType = SchemaType.STRING) void myListener( @Payload(required = false) String msg, @Header(PulsarHeaders.KEY) String key) { ... } The @PulsarReader does not yet support @Header arguments, so it is less useful in the log compaction scenario."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/reactive-pulsar.html","Reactive Support: The framework provides a Reactive counterpart for almost all supported features. If you put the word Reactive in front of a provided imperative component, you will likely find its Reactive counterpart. PulsarTemplate → ReactivePulsarTemplate PulsarListener → ReactivePulsarListener PulsarConsumerFactory → ReactivePulsarConsumerFactory etc.. However, the following is not yet supported: Error Handling in non-shared subscriptions Accessing Pulsar headers via @Header in streaming mode Observations Preface: We recommend using a Spring-Boot-First approach for Spring for Apache Pulsar-based applications, as that simplifies things tremendously. To do so, you can add the spring-pulsar-reactive-spring-boot-starter module as a dependency. The majority of this reference expects the reader to be using the starter and gives most directions for configuration with that in mind. However, an effort is made to call out when instructions are specific to the Spring Boot starter usage. Section Summary: Quick Tour(reactive-pulsar/reactive-quick-tour.html) Design(reactive-pulsar/reactive-design.html) Reactive Pulsar Client(reactive-pulsar/reactive-pulsar-client.html) Message Production(reactive-pulsar/reactive-message-production.html) Message Consumption(reactive-pulsar/reactive-message-consumption.html) Null Payloads and Log Compaction of 'Tombstone' Records(tombstones-reactive.html)"
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/reactive-pulsar/reactive-quick-tour.html","Quick Tour: Table of Contents 1. Dependencies(#_dependencies) 2. Application Code(#_application_code) We will take a quick tour of the Reactive support in Spring for Apache Pulsar by showing a sample Spring Boot application that produces and consumes in a Reactive fashion. This is a complete application and does not require any additional configuration, as long as you have a Pulsar cluster running on the default location - localhost:6650 . 1. Dependencies: Spring Boot applications need only the spring-boot-starter-pulsar-reactive dependency. The following listings show how to define the dependency for Maven and Gradle, respectively: Maven Gradle <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-pulsar-reactive</artifactId> <version>3.3.4</version> </dependency> </dependencies> dependencies { implementation 'org.springframework.boot:spring-boot-starter-pulsar-reactive:3.3.4' } 2. Application Code: Here is the application source code: @SpringBootApplication public class ReactiveSpringPulsarHelloWorld { public static void main(String[] args) { SpringApplication.run(ReactiveSpringPulsarHelloWorld.class, args); } @Bean ApplicationRunner runner(ReactivePulsarTemplate<String> pulsarTemplate) { return (args) -> pulsarTemplate.send(""hello-pulsar-topic"", ""Hello Reactive Pulsar World!"").subscribe(); } @ReactivePulsarListener(subscriptionName = ""hello-pulsar-sub"", topics = ""hello-pulsar-topic"") Mono<Void> listen(String message) { System.out.println(""Reactive listener received: "" + message); return Mono.empty(); } } That is it, with just a few lines of code we have a working Spring Boot app that is producing and consuming messages from a Pulsar topic in a Reactive fashion. Once started, the application uses a ReactivePulsarTemplate to send messages to the hello-pulsar-topic . It then consumes from the hello-pulsar-topic using a @ReactivePulsarListener . One of the key ingredients to the simplicity is the Spring Boot starter which auto-configures and provides the required components to the application"
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/reactive-pulsar/reactive-design.html","Design: Table of Contents 1. Apache Pulsar Reactive(#_apache_pulsar_reactive) 2. Additive Auto-Configuration(#_additive_auto_configuration) Here are a few key design points to keep in mind. 1. Apache Pulsar Reactive: The reactive support is ultimately provided by the Apache Pulsar Reactive client(https://github.com/apache/pulsar-client-reactive) whose current implementation is a fully non-blocking adapter around the regular Pulsar client’s asynchronous API. This implies that the Reactive client requires the regular client. 2. Additive Auto-Configuration: Due to the dependence on the regular (imperative) client, the Reactive auto-configuration provided by the framework is additive to the imperative auto-configuration. In other words, The imperative starter only includes the imperative components but the reactive starter includes both imperative and reactive components."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/reactive-pulsar/reactive-pulsar-client.html","Reactive Pulsar Client: Table of Contents 1. Authentication(#reactive-client-authentication) When you use the Reactive Pulsar Spring Boot Starter, you get the ReactivePulsarClient auto-configured. By default, the application tries to connect to a local Pulsar instance at pulsar://localhost:6650 . This can be adjusted by setting the spring.pulsar.client.service-url property to a different value. The value must be a valid Pulsar Protocol(https://pulsar.apache.org/docs/3.2.x/client-libraries-java/#connection-urls) URL There are many other application properties (inherited from the adapted imperative client) available to configure. See the spring.pulsar.client.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties. 1. Authentication: To connect to a Pulsar cluster that requires authentication, follow the same steps(../pulsar/pulsar-client.html#client-authentication) as the imperative client. Again, this is because the reactive client adapts the imperative client which handles all security configuration."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/reactive-pulsar/reactive-message-production.html","Message Production: Table of Contents 1. ReactivePulsarTemplate(#reactive-pulsar-template) 1.1. Fluent API(#_fluent_api) 1.2. Message customization(#_message_customization) 1.3. Sender customization(#_sender_customization) 2. Specifying Schema Information(#schema-info-template-reactive) 2.1. Custom Schema Mapping(#_custom_schema_mapping) 2.1.1. Configuration properties(#_configuration_properties) 2.1.2. Schema resolver customizer(#_schema_resolver_customizer) 2.1.3. Type mapping annotation(#template-default-schema-annotation) 2.2. Producing with AUTO_SCHEMA(#template-auto-produce) 3. ReactivePulsarSenderFactory(#reactive-sender-factory) 3.1. Producer Caching(#_producer_caching) 1. ReactivePulsarTemplate: On the Pulsar producer side, Spring Boot auto-configuration provides a ReactivePulsarTemplate for publishing records. The template implements an interface called ReactivePulsarOperations and provides methods to publish records through its contract. The template provides send methods that accept a single message and return a Mono<MessageId> . It also provides send methods that accept multiple messages (in the form of the ReactiveStreams Publisher type) and return a Flux<MessageId> . For the API variants that do not include a topic parameter, a topic resolution process(../topic-resolution.html#topic-resolution-process) is used to determine the destination topic. 1.1. Fluent API: The template provides a fluent builder(https://docs.spring.io/spring-pulsar/docs/1.1.4/api/org/springframework/pulsar/reactive/core/ReactivePulsarOperations.html#newMessage(T)) to handle more complicated send requests. 1.2. Message customization: You can specify a MessageSpecBuilderCustomizer to configure the outgoing message. For example, the following code shows how to send a keyed message: template.newMessage(msg) .withMessageCustomizer((mc) -> mc.key(""foo-msg-key"")) .send(); 1.3. Sender customization: You can specify a ReactiveMessageSenderBuilderCustomizer to configure the underlying Pulsar sender builder that ultimately constructs the sender used to send the outgoing message. Use with caution as this gives full access to the sender builder and invoking some of its methods (such as create ) may have unintended side effects. For example, the following code shows how to disable batching and enable chunking: template.newMessage(msg) .withSenderCustomizer((sc) -> sc.enableChunking(true).enableBatching(false)) .send(); This other example shows how to use custom routing when publishing records to partitioned topics. Specify your custom MessageRouter implementation on the sender builder such as: template.newMessage(msg) .withSenderCustomizer((sc) -> sc.messageRouter(messageRouter)) .send(); Note that, when using a MessageRouter , the only valid setting for spring.pulsar.producer.message-routing-mode is custom . 2. Specifying Schema Information: If you use Java primitive types, the framework auto-detects the schema for you, and you need not specify any schema types for publishing the data. For non-primitive types, if the Schema is not explicitly specified when invoking send operations on the ReactivePulsarTemplate , the Spring for Apache Pulsar framework will try to build a Schema.JSON from the type. Complex Schema types that are currently supported are JSON, AVRO, PROTOBUF, AUTO_PRODUCE_BYTES, and KEY_VALUE w/ INLINE encoding. 2.1. Custom Schema Mapping: As an alternative to specifying the schema when invoking send operations on the ReactivePulsarTemplate for complex types, the schema resolver can be configured with mappings for the types. This removes the need to specify the schema as the framework consults the resolver using the outgoing message type. 2.1.1. Configuration properties: Schema mappings can be configured with the spring.pulsar.defaults.type-mappings property. The following example uses application.yml to add mappings for the User and Address complex objects using AVRO and JSON schemas, respectively: spring: pulsar: defaults: type-mappings: - message-type: com.acme.User schema-info: schema-type: AVRO - message-type: com.acme.Address schema-info: schema-type: JSON The message-type is the fully-qualified name of the message class. 2.1.2. Schema resolver customizer: The preferred method of adding mappings is via the property mentioned above. However, if more control is needed you can provide a schema resolver customizer to add the mapping(s). The following example uses a schema resolver customizer to add mappings for the User and Address complex objects using AVRO and JSON schemas, respectively: @Bean public SchemaResolverCustomizer<DefaultSchemaResolver> schemaResolverCustomizer() { return (schemaResolver) -> { schemaResolver.addCustomSchemaMapping(User.class, Schema.AVRO(User.class)); schemaResolver.addCustomSchemaMapping(Address.class, Schema.JSON(Address.class)); } } 2.1.3. Type mapping annotation: Another option for specifying default schema information to use for a particular message type is to mark the message class with the @PulsarMessage annotation. The schema info can be specified via the schemaType attribute on the annotation. The following example configures the system to use JSON as the default schema when producing or consuming messages of type Foo : @PulsarMessage(schemaType = SchemaType.JSON) record Foo(String value) { } With this configuration in place, there is no need to set specify the schema on send operations. 2.2. Producing with AUTO_SCHEMA: If there is no chance to know the type of schema of a Pulsar topic in advance, you can use an AUTO_PRODUCE(https://pulsar.apache.org/docs/3.2.x/schema-get-started/#auto_produce) schema to publish a raw JSON or Avro payload as a byte[] safely. In this case, the producer validates whether the outbound bytes are compatible with the schema of the destination topic. Simply specify a schema of Schema.AUTO_PRODUCE_BYTES() on your template send operations as shown in the example below: void sendUserAsBytes(ReactivePulsarTemplate<byte[]> template, byte[] userAsBytes) { template.send(""user-topic"", userAsBytes, Schema.AUTO_PRODUCE_BYTES()).subscribe(); } This is only supported with Avro and JSON schema types. 3. ReactivePulsarSenderFactory: The ReactivePulsarTemplate relies on a ReactivePulsarSenderFactory to actually create the underlying sender. Spring Boot provides this sender factory which can be configured with any of the spring.pulsar.producer.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties. If topic information is not specified when using the sender factory APIs directly, the same topic resolution process(../topic-resolution.html#topic-resolution-process) used by the ReactivePulsarTemplate is used with the one exception that the ""Message type default"" step is omitted . 3.1. Producer Caching: Each underlying Pulsar producer consumes resources. To improve performance and avoid continual creation of producers, the ReactiveMessageSenderCache in the underlying Apache Pulsar Reactive client caches the producers that it creates. They are cached in an LRU fashion and evicted when they have not been used within a configured time period. You can configure the cache settings by specifying any of the spring.pulsar.producer.cache.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/reactive-pulsar/reactive-message-consumption.html","Message Consumption: Table of Contents 1. @ReactivePulsarListener(#reactive-pulsar-listener) 1.1. Streaming(#_streaming) 1.2. Configuration - Application Properties(#_configuration_application_properties) 1.3. Generic records with AUTO_CONSUME(#_generic_records_with_auto_consume) 1.4. Consumer Customization(#reactive-consumer-customizer) 2. Specifying Schema Information(#schema-info-listener-reactive) 2.1. Custom Schema Mapping(#_custom_schema_mapping) 2.1.1. Configuration properties(#_configuration_properties) 2.1.2. Schema resolver customizer(#_schema_resolver_customizer) 2.1.3. Type mapping annotation(#listener-default-schema-annotation) 3. Message Listener Container Infrastructure(#reactive-message-listener-container) 3.1. ReactivePulsarMessageListenerContainer(#_reactivepulsarmessagelistenercontainer) 3.2. ReactiveMessagePipeline(#_reactivemessagepipeline) 3.3. ReactivePulsarMessageHandler(#_reactivepulsarmessagehandler) 4. Concurrency(#reactive-concurrency) 5. Pulsar Headers(#reactive-pulsar-headers) 5.1. Accessing In OneByOne Listener(#reactive-pulsar-headers.single) 5.2. Accessing In Streaming Listener(#reactive-pulsar-headers.streaming) 6. Message Acknowledgment(#reactive-message-ack) 6.1. OneByOne Listener(#_onebyone_listener) 6.2. Streaming Listener(#_streaming_listener) 7. Message Redelivery and Error Handling(#reactive-redelivery) 7.1. Acknowledgment Timeout(#_acknowledgment_timeout) 7.2. Negative Acknowledgment Redelivery Delay(#_negative_acknowledgment_redelivery_delay) 7.3. Dead Letter Topic(#_dead_letter_topic) 8. Pulsar Reader Support(#reactive-pulsar-reader) 1. @ReactivePulsarListener: When it comes to Pulsar consumers, we recommend that end-user applications use the ReactivePulsarListener annotation. To use ReactivePulsarListener , you need to use the @EnableReactivePulsar annotation. When you use Spring Boot support, it automatically enables this annotation and configures all necessary components, such as the message listener infrastructure (which is responsible for creating the underlying Pulsar consumer). Let us revisit the ReactivePulsarListener code snippet we saw in the quick-tour section: @ReactivePulsarListener(subscriptionName = ""hello-pulsar-sub"", topics = ""hello-pulsar-topic"") Mono<Void> listen(String message) { System.out.println(message); return Mono.empty(); } The listener method returns a Mono<Void> to signal whether the message was successfully processed. Mono.empty() indicates success (acknowledgment) and Mono.error() indicates failure (negative acknowledgment). You can also further simplify this method: @ReactivePulsarListener Mono<Void> listen(String message) { System.out.println(message); return Mono.empty(); } In this most basic form, when the topics are not directly provided, a topic resolution process(../topic-resolution.html#topic-resolution-process) is used to determine the destination topic. Likewise, when the subscriptionName is not provided on the @ReactivePulsarListener annotation an auto-generated subscription name will be used. In the ReactivePulsarListener method shown earlier, we receive the data as String , but we do not specify any schema types. Internally, the framework relies on Pulsar’s schema mechanism to convert the data to the required type. The framework detects that you expect the String type and then infers the schema type based on that information and provides that schema to the consumer. The framework does this inference for all primitive types. For all non-primitive types the default schema is assumed to be JSON. If a complex type is using anything besides JSON (such as AVRO or KEY_VALUE) you must provide the schema type on the annotation using the schemaType property. This example shows how we can consume complex types from a topic: @ReactivePulsarListener(topics = ""my-topic-2"", schemaType = SchemaType.JSON) Mono<Void> listen(Foo message) { System.out.println(message); return Mono.empty(); } Let us look at a few more ways we can consume. This example consumes the Pulsar message directly: @ReactivePulsarListener(topics = ""my-topic"") Mono<Void> listen(org.apache.pulsar.client.api.Message<String> message) { System.out.println(message.getValue()); return Mono.empty(); } This example consumes the record wrapped in a Spring messaging envelope: @ReactivePulsarListener(topics = ""my-topic"") Mono<Void> listen(org.springframework.messaging.Message<String> message) { System.out.println(message.getPayload()); return Mono.empty(); } 1.1. Streaming: All of the above are examples of consuming a single record one-by-one. However, one of the compelling reasons to use Reactive is for the streaming capability with backpressure support. The following example uses ReactivePulsarListener to consume a stream of POJOs: @ReactivePulsarListener(topics = ""streaming-1"", stream = true) Flux<MessageResult<Void>> listen(Flux<org.apache.pulsar.client.api.Message<String>> messages) { return messages .doOnNext((msg) -> System.out.println(""Received: "" + msg.getValue())) .map(MessageResult::acknowledge); Here we receive the records as a Flux of Pulsar messages. In addition, to enable stream consumption at the ReactivePulsarListener level, you need to set the stream property on the annotation to true . The listener method returns a Flux<MessageResult<Void>> where each element represents a processed message and holds the message id, value and whether it was acknowledged. The MessageResult has a set of static factory methods that can be used to create the appropriate MessageResult instance. Based on the actual type of the messages in the Flux , the framework tries to infer the schema to use. If it contains a complex type, you still need to provide the schemaType on ReactivePulsarListener . The following listener uses the Spring messaging Message envelope with a complex type : @ReactivePulsarListener(topics = ""streaming-2"", stream = true, schemaType = SchemaType.JSON) Flux<MessageResult<Void>> listen2(Flux<org.springframework.messaging.Message<Foo>> messages) { return messages .doOnNext((msg) -> System.out.println(""Received: "" + msg.getPayload())) .map(MessageUtils::acknowledge); } The listener method returns a Flux<MessageResult<Void>> where each element represents a processed message and holds the message id, value and whether it was acknowledged. The Spring MessageUtils has a set of static factory methods that can be used to create the appropriate MessageResult instance from a Spring message. The MessageUtils provides the same functionality for Spring messages as the set of factory methods on MessagResult does for Pulsar messages. There is no support for using org.apache.pulsar.client.api.Messages<T> in a @ReactivePulsarListener 1.2. Configuration - Application Properties: The listener relies on the ReactivePulsarConsumerFactory to create and manage the underlying Pulsar consumer that it uses to consume messages. Spring Boot provides this consumer factory which you can further configure by specifying the spring.pulsar.consumer.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties. Most of the configured properties on the factory will be respected in the listener with the following exceptions : The spring.pulsar.consumer.subscription.name property is ignored and is instead generated when not specified on the annotation. The spring.pulsar.consumer.subscription-type property is ignored and is instead taken from the value on the annotation. However, you can set the subscriptionType = {} on the annotation to instead use the property value as the default. 1.3. Generic records with AUTO_CONSUME: If there is no chance to know the type of schema of a Pulsar topic in advance, you can use the AUTO_CONSUME schema type to consume generic records. In this case, the topic deserializes messages into GenericRecord objects using the schema info associated with the topic. To consume generic records set the schemaType = SchemaType.AUTO_CONSUME on your @ReactivePulsarListener and use a Pulsar message of type GenericRecord as the message parameter as shown below. @ReactivePulsarListener(topics = ""my-generic-topic"", schemaType = SchemaType.AUTO_CONSUME) Mono<Void> listen(org.apache.pulsar.client.api.Message<GenericRecord> message) { GenericRecord record = message.getValue(); record.getFields().forEach((f) -> System.out.printf(""%s = %s%n"", f.getName(), record.getField(f))); return Mono.empty(); } The GenericRecord API allows access to the fields and their associated values 1.4. Consumer Customization: You can specify a ReactivePulsarListenerMessageConsumerBuilderCustomizer to configure the underlying Pulsar consumer builder that ultimately constructs the consumer used by the listener to receive the messages. Use with caution as this gives full access to the consumer builder and invoking some of its methods (such as create ) may have unintended side effects. For example, the following code shows how to set the initial position of the subscription to the earliest messaage on the topic. @ReactivePulsarListener(topics = ""hello-pulsar-topic"", consumerCustomizer = ""myConsumerCustomizer"") Mono<Void> listen(String message) { System.out.println(message); return Mono.empty(); } @Bean ReactivePulsarListenerMessageConsumerBuilderCustomizer<String> myConsumerCustomizer() { return b -> b.subscriptionInitialPosition(SubscriptionInitialPosition.Earliest); } If your application only has a single @ReactivePulsarListener and a single ReactivePulsarListenerMessageConsumerBuilderCustomizer bean registered then the customizer will be automatically applied. You can also use the customizer to provide direct Pulsar consumer properties to the consumer builder. This is convenient if you do not want to use the Boot configuration properties mentioned earlier or have multiple ReactivePulsarListener methods whose configuration varies. The following customizer example uses direct Pulsar consumer properties: @Bean ReactivePulsarListenerMessageConsumerBuilderCustomizer<String> directConsumerPropsCustomizer() { return b -> b.property(""subscriptionName"", ""subscription-1"").property(""topicNames"", ""foo-1""); } The properties used are direct Pulsar consumer properties, not the spring.pulsar.consumer Spring Boot configuration properties 2. Specifying Schema Information: As indicated earlier, for Java primitives, the Spring for Apache Pulsar framework can infer the proper Schema to use on the ReactivePulsarListener . For non-primitive types, if the Schema is not explicitly specified on the annotation, the Spring for Apache Pulsar framework will try to build a Schema.JSON from the type. Complex Schema types that are currently supported are JSON, AVRO, PROTOBUF, AUTO_CONSUME, KEY_VALUE w/ INLINE encoding. 2.1. Custom Schema Mapping: As an alternative to specifying the schema on the ReactivePulsarListener for complex types, the schema resolver can be configured with mappings for the types. This removes the need to set the schema on the listener as the framework consults the resolver using the incoming message type. 2.1.1. Configuration properties: Schema mappings can be configured with the spring.pulsar.defaults.type-mappings property. The following example uses application.yml to add mappings for the User and Address complex objects using AVRO and JSON schemas, respectively: spring: pulsar: defaults: type-mappings: - message-type: com.acme.User schema-info: schema-type: AVRO - message-type: com.acme.Address schema-info: schema-type: JSON The message-type is the fully-qualified name of the message class. 2.1.2. Schema resolver customizer: The preferred method of adding mappings is via the property mentioned above. However, if more control is needed you can provide a schema resolver customizer to add the mapping(s). The following example uses a schema resolver customizer to add mappings for the User and Address complex objects using AVRO and JSON schemas, respectively: @Bean public SchemaResolverCustomizer<DefaultSchemaResolver> schemaResolverCustomizer() { return (schemaResolver) -> { schemaResolver.addCustomSchemaMapping(User.class, Schema.AVRO(User.class)); schemaResolver.addCustomSchemaMapping(Address.class, Schema.JSON(Address.class)); } } 2.1.3. Type mapping annotation: Another option for specifying default schema information to use for a particular message type is to mark the message class with the @PulsarMessage annotation. The schema info can be specified via the schemaType attribute on the annotation. The following example configures the system to use JSON as the default schema when producing or consuming messages of type Foo : @PulsarMessage(schemaType = SchemaType.JSON) record Foo(String value) { } With this configuration in place, there is no need to set the schema on the listener, for example: @ReactivePulsarListener(topics = ""user-topic"") Mono<Void> listen(User user) { System.out.println(user); return Mono.empty(); } 3. Message Listener Container Infrastructure: In most scenarios, we recommend using the ReactivePulsarListener annotation directly for consuming from a Pulsar topic as that model covers a broad set of application use cases. However, it is important to understand how ReactivePulsarListener works internally. The message listener container is at the heart of message consumption when you use Spring for Apache Pulsar. The ReactivePulsarListener uses the message listener container infrastructure behind the scenes to create and manage the underlying Pulsar consumer. 3.1. ReactivePulsarMessageListenerContainer: The contract for this message listener container is provided through ReactivePulsarMessageListenerContainer whose default implementation creates a reactive Pulsar consumer and wires up a reactive message pipeline that uses the created consumer. 3.2. ReactiveMessagePipeline: The pipeline is a feature of the underlying Apache Pulsar Reactive client which does the heavy lifting of receiving the data in a reactive manner and then handing it over to the provided message handler. The reactive message listener container implementation is much simpler because the pipeline handles the majority of the work. 3.3. ReactivePulsarMessageHandler: The ""listener"" aspect is provided by the ReactivePulsarMessageHandler of which there are two provided implementations: ReactivePulsarOneByOneMessageHandler - handles a single message one-by-one ReactivePulsarStreamingHandler - handles multiple messages via a Flux If topic information is not specified when using the listener containers directly, the same topic resolution process(../topic-resolution.html#topic-resolution-process) used by the ReactivePulsarListener is used with the one exception that the ""Message type default"" step is omitted . 4. Concurrency: When consuming records in streaming mode ( stream = true ) concurrency comes naturally via the underlying Reactive support in the client implementation. However, when handling messages one-by-one, concurrency can be specified to increase processing throughput. Simply set the concurrency property on @ReactivePulsarListener . Additionally, when concurrency > 1 you can ensure messages are ordered by key and therefore sent to the same handler by setting useKeyOrderedProcessing = ""true"" on the annotation. Again, the ReactiveMessagePipeline does the heavy lifting, we simply set the properties on it. Reactive vs Imperative Concurrency in the reactive container is different from its imperative counterpart. The latter creates multiple threads (each with a Pulsar consumer) whereas the former dispatches the messages to multiple handler instances concurrently on the Reactive parallel scheduler. One advantage of the reactive concurrency model is that it can be used with Exclusive subscriptions whereas the imperative concurrency model can not. 5. Pulsar Headers: The Pulsar message metadata can be consumed as Spring message headers. The list of available headers can be found in PulsarHeaders.java(https://github.com/spring-projects/spring-pulsar/blob/main/spring-pulsar/src/main/java/org/springframework/pulsar/support/PulsarHeaders.java) . 5.1. Accessing In OneByOne Listener: The following example shows how you can access Pulsar Headers when using a one-by-one message listener: @ReactivePulsarListener(topics = ""some-topic"") Mono<Void> listen(String data, @Header(PulsarHeaders.MESSAGE_ID) MessageId messageId, @Header(""foo"") String foo) { System.out.println(""Received "" + data + "" w/ id="" + messageId + "" w/ foo="" + foo); return Mono.empty(); } In the preceding example, we access the values for the messageId message metadata as well as a custom message property named foo . The Spring @Header annotation is used for each header field. You can also use Pulsar’s Message as the envelope to carry the payload. When doing so, the user can directly call the corresponding methods on the Pulsar message for retrieving the metadata. However, as a convenience, you can also retrieve it by using the Header annotation. Note that you can also use the Spring messaging Message envelope to carry the payload and then retrieve the Pulsar headers by using @Header . 5.2. Accessing In Streaming Listener: When using a streaming message listener the header support is limited. Only when the Flux contains Spring org.springframework.messaging.Message elements will the headers be populated. Additionally, the Spring @Header annotation can not be used to retrieve the data. You must directly call the corresponding methods on the Spring message to retrieve the data. 6. Message Acknowledgment: The framework automatically handles message acknowledgement. However, the listener method must send a signal indicating whether the message was successfully processed. The container implementation then uses that signal to perform the ack or nack operation. This is a slightly different from its imperative counterpart where the signal is implied as positive unless the method throws an exception. 6.1. OneByOne Listener: The single message (aka OneByOne) message listener method returns a Mono<Void> to signal whether the message was successfully processed. Mono.empty() indicates success (acknowledgment) and Mono.error() indicates failure (negative acknowledgment). 6.2. Streaming Listener: The streaming listener method returns a Flux<MessageResult<Void>> where each MessageResult element represents a processed message and holds the message id, value and whether it was acknowledged. The MessageResult has a set of acknowledge and negativeAcknowledge static factory methods that can be used to create the appropriate MessageResult instance. 7. Message Redelivery and Error Handling: Apache Pulsar provides various native strategies for message redelivery and error handling. We will take a look at them and see how to use them through Spring for Apache Pulsar. 7.1. Acknowledgment Timeout: By default, Pulsar consumers do not redeliver messages unless the consumer crashes, but you can change this behavior by setting an ack timeout on the Pulsar consumer. If the ack timeout property has a value above zero and if the Pulsar consumer does not acknowledge a message within that timeout period, the message is redelivered. You can specify this property directly as a Pulsar consumer property via a consumer customizer(#reactive-consumer-customizer) such as: @Bean ReactiveMessageConsumerBuilderCustomizer<String> consumerCustomizer() { return b -> b.property(""ackTimeout"", ""60s""); } 7.2. Negative Acknowledgment Redelivery Delay: When acknowledging negatively, Pulsar consumer lets you specify how the application wants the message to be re-delivered. The default is to redeliver the message in one minute, but you can change it via a consumer customizer(#reactive-consumer-customizer) such as: @Bean ReactiveMessageConsumerBuilderCustomizer<String> consumerCustomizer() { return b -> b.property(""negativeAckRedeliveryDelay"", ""10ms""); } 7.3. Dead Letter Topic: Apache Pulsar lets applications use a dead letter topic on consumers with a Shared subscription type. For the Exclusive and Failover subscription types, this feature is not available. The basic idea is that, if a message is retried a certain number of times (maybe due to an ack timeout or nack redelivery), once the number of retries are exhausted, the message can be sent to a special topic called the dead letter queue (DLQ). Let us see some details around this feature in action by inspecting some code snippets: @Configuration(proxyBeanMethods = false) class DeadLetterPolicyConfig { @ReactivePulsarListener( topics = ""topic-with-dlp"", subscriptionType = SubscriptionType.Shared, deadLetterPolicy = ""myDeadLetterPolicy"", consumerCustomizer = ""ackTimeoutCustomizer"" ) void listen(String msg) { throw new RuntimeException(""fail "" + msg); } @ReactivePulsarListener(topics = ""my-dlq-topic"") void listenDlq(String msg) { System.out.println(""From DLQ: "" + msg); } @Bean DeadLetterPolicy myDeadLetterPolicy() { return DeadLetterPolicy.builder().maxRedeliverCount(10).deadLetterTopic(""my-dlq-topic"").build(); } @Bean ReactiveMessageConsumerBuilderCustomizer<String> ackTimeoutCustomizer() { return b -> b.property(""ackTimeout"", ""1s""); } } First, we have a special bean for DeadLetterPolicy , and it is named as deadLetterPolicy (it can be any name as you wish). This bean specifies a number of things, such as the max delivery (10, in this case) and the name of the dead letter topic — my-dlq-topic , in this case. If you do not specify a DLQ topic name, it defaults to <topicname>-<subscriptionname>-DLQ in Pulsar. Next, we provide this bean name to ReactivePulsarListener by setting the deadLetterPolicy property. Note that the ReactivePulsarListener has a subscription type of Shared , as the DLQ feature only works with shared subscriptions. This code is primarily for demonstration purposes, so we provide an ackTimeout value of 1 second. The idea is that the code throws the exception and, if Pulsar does not receive an ack within 1 second, it does a retry. If that cycle continues ten times (as that is our max redelivery count in the DeadLetterPolicy ), the Pulsar consumer publishes the messages to the DLQ topic. We have another ReactivePulsarListener that listens on the DLQ topic to receive data as it is published to the DLQ topic. Special note on DLQ topics when using partitioned topics If the main topic is partitioned, behind the scenes, each partition is treated as a separate topic by Pulsar. Pulsar appends partition-<n> , where n stands for the partition number to the main topic name. The problem is that, if you do not specify a DLQ topic (as opposed to what we did above), Pulsar publishes to a default topic name that has this `partition-<n> info in it — for example: topic-with-dlp-partition-0-deadLetterPolicySubscription-DLQ . The easy way to solve this is to provide a DLQ topic name always. 8. Pulsar Reader Support: The framework provides support for using Pulsar Reader(https://pulsar.apache.org/docs/3.2.x/concepts-clients/#reader-interface) in a Reactive fashion via the ReactivePulsarReaderFactory . Spring Boot provides this reader factory which can be configured with any of the spring.pulsar.reader.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/tombstones-reactive.html","Null Payloads and Log Compaction of 'Tombstone' Records: When using log compaction, you can send and receive messages with null payloads to identify the deletion of a key. You can also receive null values for other reasons, such as a deserializer that might return null when it cannot deserialize a value. Producing Null Payloads: You can send a null value with the ReactivePulsarTemplate by passing a null message parameter value to one of the send methods, for example: reactiveTemplate .send(null, Schema.STRING) .subscribe(); When sending null values you must specify the schema type as the system can not determine the type of the message from a null payload. Consuming Null Payloads: For @ReactivePularListener , the null payload is passed into the listener method based on the type of its message parameter as follows: Parameter type Passed-in value primitive null user-defined null org.apache.pulsar.client.api.Message<T> non-null Pulsar message whose getValue() returns null org.springframework.messaging.Message<T> non-null Spring message whose getPayload() returns PulsarNull Flux<org.apache.pulsar.client.api.Message<T>> non-null flux whose entries are non-null Pulsar messages whose getValue() returns null Flux<org.springframework.messaging.Message<T>> non-null flux whose entries are non-null Spring messages whose getPayload() returns PulsarNull When the passed-in value is null (ie. single record listeners with primitive or user-defined types) you must use the @Payload parameter annotation with required = false . When using the Spring org.springframework.messaging.Message for your listener payload type, its generic type information must be wide enough to accept Message<PulsarNull> (eg. Message , Message<?> , or Message<Object> ). This is due to the fact that the Spring Message does not allow null values for its payload and instead uses the PulsarNull placeholder. If it is a tombstone message for a compacted log, you usually also need the key so that your application can determine which key was "" deleted "". The following example shows such a configuration: @ReactivePulsarListener( topics = ""my-topic"", subscriptionName = ""my-topic-sub"", schemaType = SchemaType.STRING) Mono<Void> myListener( @Payload(required = false) String msg, @Header(PulsarHeaders.KEY) String key) { ... } When using a streaming message listener ( Flux ) the header support is limited(reactive-pulsar.html#reactive-pulsar-headers.streaming) , so it less useful in the log compaction scenario."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/topic-resolution.html","Topic Resolution: Table of Contents 1. User specified(#_user_specified) 2. Message type default(#_message_type_default) 2.1. Specified via annotation(#default-topic-via-annotation) 2.2. Custom topic resolver(#_custom_topic_resolver) 3. Producer global default(#_producer_global_default) 4. Consumer global default(#_consumer_global_default) A destination topic is needed when producing or consuming messages. The framework looks in the following ordered locations to determine a topic (stopping at the first find): User specified Message type default Global default When a topic is found via one of the default mechanisms, there is no need to specify the topic on the produce or consume API. When a topic is not found, the API will throw an exception accordingly. 1. User specified: A topic passed into the API being used has the highest precedence (eg. PulsarTemplate.send(""my-topic"", myMessage) or @PulsarListener(topics = ""my-topic"" ). 2. Message type default: When no topic is passed into the API, the system looks for a message type to topic mapping configured for the type of the message being produced or consumed. Mappings can be configured with the spring.pulsar.defaults.type-mappings property. The following example uses application.yml to configure default topics to use when consuming or producing Foo or Bar messages: spring: pulsar: defaults: type-mappings: - message-type: com.acme.Foo topic-name: foo-topic - message-type: com.acme.Bar topic-name: bar-topic The message-type is the fully-qualified name of the message class. If the message (or the first message of a Publisher input) is null , the framework won’t be able to determine the topic from it. Another method shall be used to specify the topic if your application is likely to send null messages. 2.1. Specified via annotation: When no topic is passed into the API and there are no custom topic mappings configured, the system looks for a @PulsarMessage annotation on the class of the message being produced or consumed. The default topic can be specified via the topic attribute on the annotation. The following example configures the default topic to use when producing or consuming messages of type Foo : @PulsarMessage(topic = ""foo-topic"") record Foo(String value) { } Property placeholders and SpEL expressions are supported in the @PulsarMessage annotation, for example: @PulsarMessage(topic = ""${app.topics.foo}"") record Foo(String value) { } @PulsarMessage(topic = ""#{someBean.getTopic()}"") record Bar(String value) { } 2.2. Custom topic resolver: The preferred method of adding mappings is via the property mentioned above. However, if more control is needed you can replace the default resolver by proving your own implementation, for example: @Bean public MyTopicResolver topicResolver() { return new MyTopicResolver(); } 3. Producer global default: The final location consulted (when producing) is the system-wide producer default topic. It is configured via the spring.pulsar.producer.topic-name property when using the imperative API and the spring.pulsar.reactive.sender.topic-name property when using the reactive API. 4. Consumer global default: The final location consulted (when consuming) is the system-wide consumer default topic. It is configured via the spring.pulsar.consumer.topics or spring.pulsar.consumer.topics-pattern property when using the imperative API and one of the spring.pulsar.reactive.consumer.topics or spring.pulsar.reactive.consumer.topics-pattern property when using the reactive API."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/pulsar-admin.html","Pulsar Administration: Table of Contents 1. Pulsar Admin Client(#pulsar-admin-client) 1.1. Authentication(#pulsar-admin-authentication) 2. Automatic Topic Creation(#pulsar-auto-topic-creation) 1. Pulsar Admin Client: On the Pulsar administration side, Spring Boot auto-configuration provides a PulsarAdministration to manage Pulsar clusters. The administration implements an interface called PulsarAdminOperations and provides a createOrModify method(https://docs.spring.io/spring-pulsar/docs/1.1.4/api/org/springframework/pulsar/core/PulsarAdminOperations.html) to handle topic administration through its contract. When you use the Pulsar Spring Boot starter, you get the PulsarAdministration auto-configured. By default, the application tries to connect to a local Pulsar instance at http://localhost:8080 . This can be adjusted by setting the spring.pulsar.admin.service-url property to a different value in the form (http|https)://<host>:<port> . There are many application properties available to configure the client. See the spring.pulsar.admin.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties. 1.1. Authentication: When accessing a Pulsar cluster that requires authentication, the admin client requires the same security configuration as the regular Pulsar client. You can use the aforementioned security configuration(pulsar/pulsar-client.html#client-authentication) by replacing spring.pulsar.client with spring.pulsar.admin . 2. Automatic Topic Creation: On initialization, the PulsarAdministration checks if there are any PulsarTopic beans in the application context. For all such beans, the PulsarAdministration either creates the corresponding topic or, if necessary, modifies the number of partitions. The following example shows how to add PulsarTopic beans to let the PulsarAdministration auto-create topics for you: @Bean PulsarTopic simpleTopic { // This will create a non-partitioned topic in the public/default namespace return PulsarTopic.builder(""simple-topic"").build(); } @Bean PulsarTopic partitionedTopic { // This will create a partitioned topic with 3 partitions in the provided tenant and namespace return PulsarTopic.builder(""persistent://my-tenant/my-namespace/partitioned-topic"", 3).build(); }"
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/pulsar-function.html","Pulsar Functions: Table of Contents 1. Pulsar Function Administration(#_pulsar_function_administration) 2. Automatic Function Management(#_automatic_function_management) 3. Limitations(#_limitations) 3.1. No Magic Pulsar Functions(#_no_magic_pulsar_functions) 3.2. Name Identifier(#_name_identifier) 4. Configuration(#_configuration) 4.1. Pulsar Function Archive(#_pulsar_function_archive) 4.2. Built-in Source and Sinks(#_built_in_source_and_sinks) 5. Custom functions(#_custom_functions) 5.1. file://(#_file) 5.2. local(#_local) 5.3. http://(#_http) 5.4. function://(#_function) 6. Examples(#_examples) Spring for Apache Pulsar provides basic suppport for Pulsar IO(https://pulsar.apache.org/docs/3.2.x/io-connectors/) (connectors) and Pulsar Functions(https://pulsar.apache.org/docs/3.2.x/functions-overview) which allow users to define stream processing pipelines made up of sources , processors , and sinks . The sources and sinks are modeled by Pulsar IO (connectors) and the processors are represented by Pulsar Functions . Because connectors are just special functions, and for simplicity, we refer to sources, sinks and functions collectively as ""Pulsar Functions"". Pre-requisites Familiarity - the audience is expected to be somewhat familiar w/ Pulsar IO and Pulsar Functions . If that is not the case it may be helpful to see their getting started guides. Feature enabled - to use these features the functions support in Apache Pulsar must be enabled and configured (it is disabled by default). The built-in connectors may also need to be installed on the Pulsar cluster. See the Pulsar IO(https://pulsar.apache.org/docs/3.2.x/io-connectors/) and Pulsar Functions(https://pulsar.apache.org/docs/3.2.x/functions-overview) docs for more details. 1. Pulsar Function Administration: The framework provides the PulsarFunctionAdministration component to manage Pulsar functions. When you use the Pulsar Spring Boot starter, you get the PulsarFunctionAdministration auto-configured. By default, the application tries to connect to a local Pulsar instance at localhost:8080(http://localhost:8080) . However, because it leverages the already configured PulsarAdministration , see Pulsar Admin Client(pulsar-admin.html#pulsar-admin-client) for available client options (including authentication). Additional configuration options are available with the spring.pulsar.function.*(https://docs.spring.io/spring-boot/docs/3.3.4/reference/htmlsingle/#application-properties.integration) application properties. 2. Automatic Function Management: On application startup, the framework finds all PulsarFunction , PulsarSink , and PulsarSource beans in the application context. For each bean, the corresponding Pulsar function is either created or updated. The proper API is called based on function type, function config, and whether the function already exists. The PulsarFunction , PulsarSink , and PulsarSource beans are simple wrappers around the Apache Pulsar config objects FunctionConfig , SinkConfig , and SourceConfig , respectively. Due to the large number of supported connectors (and their varied configurations) the framework does not attempt to create a configuration properties hierarchy to mirror the varied Apache Pulsar connectors. Instead, the burden is on the user to supply the full config object and then the framework handles the management (create/update) using the supplied config. On application shutdown, all functions that were processed during application startup have their stop policy enforced and are either left alone, stopped, or deleted from the Pulsar server. 3. Limitations: 3.1. No Magic Pulsar Functions: Pulsar functions and custom connectors are represented by custom application code (eg. a java.util.Function ). There is no magic support to automatically register the custom code. While this would be amazing, it has some technical challenges and not yet been implemented. As such, it is up to the user to ensure the function (or custom connector) is available at the location specified in the function config. For example, if the function config has a jar value of ./some/path/MyFunction.jar then the function jar file must exist at the specified path. 3.2. Name Identifier: The name property from the function config is used as the identifier to determine if a function already exists in order to decide if an update or create operation is performed. As such, the name should not be modified if function updates are desired. 4. Configuration: 4.1. Pulsar Function Archive: Each Pulsar function is represented by an actual archive (eg. jar file). The path to the archive is specified via the archive property for sources and sinks, and the jar property for functions. The following rules determine the ""type"" of path: The path is a URL when it starts w/ (file|http|https|function|sink|source):// The path is built-in when it starts w/ builtin:// (points to one of the provided out-of-the-box connectors) The path is local otherwise. The action that occurs during the create/update operation is dependent on path ""type"" as follows: When the path is a URL the content is downloaded by the server When the path is built-in the content is already available on the server When the path is local the content is uploaded to the server 4.2. Built-in Source and Sinks: Apache Pulsar provides many source and sink connectors out-of-the-box, aka built-in connectors. To use a built-in connector simply set the archive to builtin://<connector-type> (eg builtin://rabbit ). 5. Custom functions: The details on how to develop and package custom functions can be found in the Pulsar docs(https://pulsar.apache.org/docs/3.2.x/functions-develop) . However, at a high-level, the requirements are as follows: Code uses Java8 Code implements either java.util.Function or org.apache.pulsar.functions.api.Function Packaged as uber jar Once the function is built and packaged, there are several ways to make it available for function registration. 5.1. file://: The jar file can be uploaded to the server and then referenced via file:// in the jar property of the function config 5.2. local: The jar file can remain local and then referenced via the local path in the jar property of the function config. 5.3. http://: The jar file can be made available via HTTP server and then referenced via http(s):// in the jar property of the function config 5.4. function://: The jar file can be uploaded to the Pulsar package manager and then referenced via function:// in the jar property of the function config 6. Examples: Here are some examples that show how to configure a PulsarSource bean which results in the PulsarFunctionAdministration auto-creating the backing Pulsar source connector. PulsarSource using built-in Rabbit connector @Bean PulsarSource rabbitSource() { Map<String, Object> configs = new HashMap<>(); configs.put(""host"", ""my.rabbit.host""); configs.put(""port"", 5672); configs.put(""virtualHost"", ""/""); configs.put(""username"", ""guest""); configs.put(""password"", ""guest""); configs.put(""queueName"", ""test_rabbit""); configs.put(""connectionName"", ""test-connection""); SourceConfig sourceConfig = SourceConfig.builder() .tenant(""public"") .namespace(""default"") .name(""rabbit-test-source"") .archive(""builtin://rabbitmq"") .topicName(""incoming_rabbit"") .configs(configs).build(); return new PulsarSource(sourceConfig, null); } This next example is the same as the previous, except that it uses the Spring Boot auto-configured RabbitProperties to ease the configuration burden. This of course requires the application to be using Spring Boot with Rabbit auto-configuration enabled. PulsarSource using built-in Rabbit connector and Spring Boot RabbitProperties @Bean PulsarSource rabbitSourceWithBootProps(RabbitProperties props) { Map<String, Object> configs = new HashMap<>(); configs.put(""host"", props.determineHost()); configs.put(""port"", props.determinePort()); configs.put(""virtualHost"", props.determineVirtualHost()); configs.put(""username"", props.determineUsername()); configs.put(""password"", props.determinePassword()); configs.put(""queueName"", ""test_rabbit""); configs.put(""connectionName"", ""test-connection""); SourceConfig sourceConfig = SourceConfig.builder() .tenant(""public"") .namespace(""default"") .name(""rabbit-test-source"") .archive(""builtin://rabbitmq"") .topicName(""incoming_rabbit"") .configs(configs).build(); return new PulsarSource(sourceConfig, null); } For a more elaborate example see the Sample Stream Pipeline with Pulsar Functions(https://github.com/spring-projects/spring-pulsar/blob/main/spring-pulsar-sample-apps/sample-pulsar-functions/README.adoc) sample app"
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/reference/observability.html","Observability: Spring for Apache Pulsar includes a way to manage observability through Micrometer(https://micrometer.io/) . Observability has not been added to the Reactive components yet Micrometer Observations: The PulsarTemplate and PulsarListener are instrumented with the Micrometer observations API. When a Micrometer ObservationRegistry bean is provided, send and receive operations are traced and timed. Custom tags: The default implementation adds the bean.name tag for template observations and listener.id tag for listener observations. To add other tags to timers and traces, configure a custom PulsarTemplateObservationConvention or PulsarListenerObservationConvention to the template or listener container, respectively. You can subclass either DefaultPulsarTemplateObservationConvention or DefaultPulsarListenerObservationConvention or provide completely new implementations. Observability - Metrics: Below you can find a list of all metrics declared by this project. Listener Observation: Observation created when a Pulsar listener receives a message. Metric name spring.pulsar.listener (defined by convention class org.springframework.pulsar.observation.DefaultPulsarListenerObservationConvention ). Type timer . Metric name spring.pulsar.listener.active (defined by convention class org.springframework.pulsar.observation.DefaultPulsarListenerObservationConvention ). Type long task timer . KeyValues that are added after starting the Observation might be missing from the *.active metrics. Micrometer internally uses nanoseconds for the baseunit. However, each backend determines the actual baseunit. (i.e. Prometheus uses seconds) Fully qualified name of the enclosing class org.springframework.pulsar.observation.PulsarListenerObservation . All tags must be prefixed with spring.pulsar.listener prefix! Table 1. Low cardinality Keys Name Description spring.pulsar.listener.id (required) Id of the listener container that received the message. Template Observation: Observation created when a Pulsar template sends a message. Metric name spring.pulsar.template (defined by convention class org.springframework.pulsar.observation.DefaultPulsarTemplateObservationConvention ). Type timer . Metric name spring.pulsar.template.active (defined by convention class org.springframework.pulsar.observation.DefaultPulsarTemplateObservationConvention ). Type long task timer . KeyValues that are added after starting the Observation might be missing from the *.active metrics. Micrometer internally uses nanoseconds for the baseunit. However, each backend determines the actual baseunit. (i.e. Prometheus uses seconds) Fully qualified name of the enclosing class org.springframework.pulsar.observation.PulsarTemplateObservation . All tags must be prefixed with spring.pulsar.template prefix! Table 2. Low cardinality Keys Name Description spring.pulsar.template.name (required) Bean name of the template that sent the message. Observability - Spans: Below you can find a list of all spans declared by this project. Listener Observation Span: Observation created when a Pulsar listener receives a message. Span name spring.pulsar.listener (defined by convention class org.springframework.pulsar.observation.DefaultPulsarListenerObservationConvention ). Fully qualified name of the enclosing class org.springframework.pulsar.observation.PulsarListenerObservation . All tags must be prefixed with spring.pulsar.listener prefix! Table 3. Tag Keys Name Description spring.pulsar.listener.id (required) Id of the listener container that received the message. Template Observation Span: Observation created when a Pulsar template sends a message. Span name spring.pulsar.template (defined by convention class org.springframework.pulsar.observation.DefaultPulsarTemplateObservationConvention ). Fully qualified name of the enclosing class org.springframework.pulsar.observation.PulsarTemplateObservation . All tags must be prefixed with spring.pulsar.template prefix! Table 4. Tag Keys Name Description spring.pulsar.template.name (required) Bean name of the template that sent the message. See Micrometer Tracing(https://docs.micrometer.io//tracing/reference) for more information. Manual Configuration without Spring Boot: If you do not use Spring Boot, you need to configure and provide an ObservationRegistry as well as Micrometer Tracing. See Micrometer Tracing(https://docs.micrometer.io//tracing/reference) for more information. Auto-Configuration with Spring Boot: If you use Spring Boot, the Spring Boot Actuator auto-configures an instance of ObservationRegistry for you. If micrometer-core is on the classpath, every stopped observation leads to a timer. Spring Boot also auto-configures Micrometer Tracing for you. This includes support for Brave OpenTelemetry, Zipkin, and Wavefront. When using the Micrometer Observation API, finishing observations leads to spans reported to Zipkin or Wavefront. You can control tracing by setting properties under management.tracing . You can use Zipkin with management.zipkin.tracing , while Wavefront uses management.wavefront . Example Configuration: The following example shows the steps to configure your Spring Boot application to use Zipkin with Brave. Add the required dependencies to your application (in Maven or Gradle, respectively): Maven <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-tracing-bridge-brave</artifactId> </dependency> <dependency> <groupId>io.zipkin.reporter2</groupId> <artifactId>zipkin-reporter-brave</artifactId> </dependency> <dependency> <groupId>io.zipkin.reporter2</groupId> <artifactId>zipkin-sender-urlconnection</artifactId> </dependency> </dependencies> Gradle dependencies { implementation 'org.springframework.boot:spring-boot-starter-actuator' implementation 'io.micrometer:micrometer-tracing-bridge-brave' implementation 'io.zipkin.reporter2:zipkin-reporter-brave' implementation 'io.zipkin.reporter2:zipkin-sender-urlconnection' } NOTE You need the 'io.zipkin.reporter2:zipkin-sender-urlconnection' dependency only if your application does not have a configured WebClient or RestTemplate. Add the required properties to your application: management: tracing.enabled: true zipkin: tracing.endpoint: ""http://localhost:9411/api/v2/spans"" The tracing.endpoint above expects Zipkin is running locally as described here(https://zipkin.io/pages/quickstart.html) . At this point, your application should record traces when you send and receive Pulsar messages. You should be able to view them in the Zipkin UI (at localhost:9411(http://localhost:9411) , when running locally). You can also see the preceding configuration on the Spring for Apache Pulsar Sample Apps(https://github.com/spring-projects/spring-pulsar/blob/main/spring-pulsar-sample-apps/README.adoc) . The steps are very similar to configuring any of the other supported Tracing environments."
"https://docs.spring.io/spring-cloud-stream/reference/pulsar/pulsar_binder.html","Spring Cloud Stream Binder for Apache Pulsar: Spring for Apache Pulsar provides a binder for Spring Cloud Stream that we can use to build event-driven microservices using pub-sub paradigms. In this section, we will go through the basic details of this binder. Usage: We need to include the following dependency on your application to use Apache Pulsar binder for Spring Cloud Stream. Maven Gradle <dependencies> <dependency> <groupId>org.springframework.pulsar</groupId> <artifactId>spring-pulsar-spring-cloud-stream-binder</artifactId> </dependency> </dependencies> dependencies { implementation 'org.springframework.pulsar:spring-pulsar-spring-cloud-stream-binder' } Overview: The Spring Cloud Stream binder for Apache Pulsar allows the applications to focus on business logic rather than dealing with the lower-level details of managing and maintaining Pulsar. The binder takes care of all those details for the application developer. Spring Cloud Stream brings a powerful programming model based on Spring Cloud Function(https://spring.io/projects/spring-cloud-function) that allows the app developer to write complex event-driven applications using a functional style. Applications can start from a middleware-neutral manner and then map Pulsar topics as destinations in Spring Cloud Stream through Spring Boot configuration properties. Spring Cloud Stream is built on top of Spring Boot, and when writing an event-driven microservice using Spring Cloud Stream, you are essentially writing a Boot application. Here is a straightforward Spring Cloud Stream application. @SpringBootApplication public class SpringPulsarBinderSampleApp { private final Logger logger = LoggerFactory.getLogger(this.getClass()); public static void main(String[] args) { SpringApplication.run(SpringPulsarBinderSampleApp.class, args); } @Bean public Supplier<Time> timeSupplier() { return () -> new Time(String.valueOf(System.currentTimeMillis())); } @Bean public Function<Time, EnhancedTime> timeProcessor() { return (time) -> { EnhancedTime enhancedTime = new EnhancedTime(time, ""5150""); this.logger.info(""PROCESSOR: {} --> {}"", time, enhancedTime); return enhancedTime; }; } @Bean public Consumer<EnhancedTime> timeLogger() { return (time) -> this.logger.info(""SINK: {}"", time); } record Time(String time) { } record EnhancedTime(Time time, String extra) { } } The above sample application, a full-blown Spring Boot application, deserves a few explanations. However, on a first pass, you can see that this is just plain Java and a few Spring and Spring Boot annotations. We have three Bean methods here - a java.util.function.Supplier , a java.util.function.Function , and finally, a java.util.function.Consumer . The supplier produces the current time in milliseconds, the function takes this time and then enhances it by adding some random data, and then the consumer logs the enhanced time. We omitted all the imports for brevity, but nothing Spring Cloud Stream specific in the entire application. How does it become a Spring Cloud Stream application that interacts with Apache Pulsar? You must include the above dependency for the binder in the application. Once that dependency is added, you must provide the following configuration properties. spring: cloud: function: definition: timeSupplier;timeProcessor;timeLogger; stream: bindings: timeProcessor-in-0: destination: timeSupplier-out-0 timeProcessor-out-0: destination: timeProcessor-out-0 timeLogger-in-0: destination: timeProcessor-out-0 With this, the above Spring Boot application has become an end-to-end event-driven application based on Spring Cloud Stream. Because we have the Pulsar binder on the classpath, the application interacts with Apache Pulsar. If there is only one function in the application, then we don’t need to tell Spring Cloud Stream to activate the function for execution since it does that by default. If there is more than one such function in the application, as in our example, we need to instruct Spring Cloud Stream which functions we would like to activate. In our case, we need all of them to be activated, and we do that through the spring.cloud.function.definition property. The bean name becomes part of the Spring Cloud Stream binding name by default. A binding is a fundamentally abstract concept in Spring Cloud Stream, using which the framework communicates with the middleware destination. Almost everything that Spring Cloud Stream does occurs over a concrete binding. A supplier has only an output binding; functions have input and output bindings, and consumers have only input binding. Let’s take as an example our supplier bean - timeSupplier. The default binding name for this supplier will be timeSupplier-out-0 . Similarly, the default binding names for the timeProcessor function will be timeProcessor-in-0 on the inbound and timeProcessor-out-0 on the outbound. Please refer to the Spring Cloud Stream reference docs for details on how you can change the default binding names. In most situations, using the default binding names is enough. We set the destination on the binding names, as shown above. If a destination is not provided, the binding name becomes the value for the destination as in the case of timeSupplier-out-0 . When running the above app, you should see that the supplier executes every second, which is then consumed by the function and enhances the time consumed by the logger consumer. Message Conversion in Binder-based Applications: In the above sample application, we provided no schema information for message conversion. That is because, by default, Spring Cloud Stream uses its message conversion mechanism using the messaging support established in Spring Framework through the Spring Messaging project. Unless specified, Spring Cloud Stream uses application/json as the content-type for message conversion on both inbound and outbound bindings. On the outbound, the data is serialized as byte[], and the Pulsar binder then uses Schema.BYTES to send it over the wire to the Pulsar topic. Similarly, on the inbound, the data is consumed as byte[] from the Pulsar topic and then converted into the target type using the proper message converter. Using Native Conversion in Pulsar using Pulsar Schema: Although the default is to use the framework-provided message conversion, Spring Cloud Stream allows each binder to determine how the message should be converted. Suppose the application chooses to go this route. In that case, Spring Cloud Stream steers clear of using any Spring-provided message conversion facility and passes around the data it receives or produces. This feature in Spring Cloud Stream is known as native encoding on the producer side and native decoding on the consumer side. This means that the encoding and decoding natively occur on the target middleware, in our case, on Apache Pulsar. For the above application, we can use the following configuration to bypass the framework conversion and uses native encoding and decoding. spring: cloud: stream: bindings: timeSupplier-out-0: producer: use-native-encoding: true timeProcessor-in-0: destination: timeSupplier-out-0 consumer: use-native-decoding: true timeProcessor-out-0: destination: timeProcessor-out-0 producer: use-native-encoding: true timeLogger-in-0: destination: timeProcessor-out-0 consumer: use-native-decoding: true pulsar: bindings: timeSupplier-out-0: producer: schema-type: JSON message-type: org.springframework.pulsar.sample.binder.SpringPulsarBinderSampleApp.Time timeProcessor-in-0: consumer: schema-type: JSON message-type: org.springframework.pulsar.sample.binder.SpringPulsarBinderSampleApp.Time timeProcessor-out-0: producer: schema-type: AVRO message-type: org.springframework.pulsar.sample.binder.SpringPulsarBinderSampleApp.EnhancedTime timeLogger-in-0: consumer: schema-type: AVRO message-type: org.springframework.pulsar.sample.binder.SpringPulsarBinderSampleApp.EnhancedTime The property to enable native encoding on the producer side is a binding level property from the core Spring Cloud Stream. You set it on the producer binding - spring.cloud.stream.bindings.<binding-name>.producer.use-native-encoding and set this to true. Similarly, use - spring.cloud.stream.bindings.<binding-name>.consumer.user-native-decoding for consumer bindings and set it to true. If we decide to use native encoding and decoding, in the case of Pulsar, we need to set the corresponding schema and the underlying message type information. This information is provided as extended binding properties. As you can see above in the configuration, the properties are - spring.cloud.stream.pulsar.bindings.<binding-name>.producer|consumer.schema-type for schema information and spring.cloud.stream.pulsar.bindings.<binding-name>.producer|consumer.message-type for the actual target type. If you have both keys and values on the message, you can use message-key-type and message-value-type to specify their target types. Any configured custom schema mappings will be consulted when the schema-type property is omitted. Message Header Conversion: Each message typically has header information that needs to be carried along as the message traverses between Pulsar and Spring Messaging via Spring Cloud Stream input and output bindings. To support this traversal, the framework handles the necessary message header conversion. Pulsar Headers(https://docs.spring.io/spring-pulsar/docs/current-SNAPSHOT/reference/html/#_pulsar_headers) Custom Header Mapper: The Pulsar binder is configured with a default header mapper that can be overridden by providing your own PulsarHeaderMapper bean. In the following example, a JSON header mapper is configured that: maps all inbound headers (except those with keys “top” or “secret”) maps outbound headers (except those with keys “id”, “timestamp”, or “userId”) only trusts objects in the “com.acme” package for outbound deserialization de/serializes any “com.acme.Money” header values w/ simple toString() encoding @Bean public PulsarHeaderMapper customPulsarHeaderMapper() { return JsonPulsarHeaderMapper.builder() .inboundPatterns(""!top"", ""!secret"", ""*"") .outboundPatterns(""!id"", ""!timestamp"", ""!userId"", ""*"") .trustedPackages(""com.acme"") .toStringClasses(""com.acme.Money"") .build(); } Using Pulsar Properties in the Binder: The binder uses basic components from Spring for Apache Pulsar framework to build its producer and consumer bindings. Since binder-based applications are Spring Boot applications, binder, by default, uses the Spring Boot autoconfiguration for Spring for Apache Pulsar. Therefore, all Pulsar Spring Boot properties available at the core framework level are also available through the binder. For example, you can use properties with the prefix spring.pulsar.producer…​ , spring.pulsar.consumer…​ etc. In addition, you can also set these Pulsar properties at the binder level. For instance, this will also work - spring.cloud.stream.pulsar.binder.producer…​ or spring.cloud.stream.pulsar.binder.consumer…​ . Either of the above approaches is fine, but when using properties like these, it is applied to the whole application. If you have multiple functions in the application, they all get the same properties. You can also set these Pulsar properties at the extended binding properties level to address this. Extended binding properties are applied at the binding itself. For instance, if you have an input and output binding, and both require a separate set of Pulsar properties, you must set them on the extended binding. The pattern for producer binding is spring.cloud.stream.pulsar.bindings.<output-binding-name>.producer…​ . Similarly, for consumer binding, the pattern is spring.cloud.stream.pulsar.bindings.<input-binding-name>.consumer…​ . This way, you can have a separate set of Pulsar properties applied for different bindings in the same application. The highest precedence is for extended binding properties. The precedence order of applying the properties in the binder is extended binding properties → binder properties → Spring Boot properties. (going from highest to lowest). Resources for Pulsar Binder Properties: Following are some resources to rely upon for finding more about the properties available through the Pulsar binder. Pulsar producer binding configuration(https://github.com/spring-cloud/spring-cloud-stream/blob/main/binders/pulsar-binder/spring-cloud-stream-binder-pulsar/src/main/java/org/springframework/cloud/stream/binder/pulsar/properties/ProducerConfigProperties.java) . These properties need the spring.cloud.stream.bindings.<binding-name>.producer prefix. All the Spring Boot provided Pulsar producer properties(https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.integration) are also available through this configuration class. Pulsar consumer binding configuration(https://github.com/spring-cloud/spring-cloud-stream/blob/main/binders/pulsar-binder/spring-cloud-stream-binder-pulsar/src/main/java/org/springframework/cloud/stream/binder/pulsar/properties/ConsumerConfigProperties.java) . These properties need the spring.cloud.stream.bindings.<binding-name>.consumer prefix. All the Spring Boot provided Pulsar consumer properties(https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.integration) are also available through this configuration class. For common Pulsar binder specific configuration properties, see this(https://github.com/spring-cloud/spring-cloud-stream/blob/main/binders/pulsar-binder/spring-cloud-stream-binder-pulsar/src/main/java/org/springframework/cloud/stream/binder/pulsar/properties/PulsarBinderConfigurationProperties.java) . These properties require a prefix of spring.cloud.stream.pulsar.binder . The above specified producer and consumer properties (including the Spring Boot ones) can be used at the binder using the spring.cloud.stream.pulsar.binder.producer or spring.cloud.stream.pulsar.binder.consumer prefix. Pulsar Topic Provisioner: Spring Cloud Stream binder for Apache Pulsar comes with an out-of-the-box provisioner for Pulsar topics. When running an application, if the necessary topics are absent, Pulsar will create the topics for you. However, this is a basic non-partitioned topic, and if you want advanced features like creating a partitioned topic, you can rely on the topic provisioner in the binder. Pulsar topic provisioner uses PulsarAdministration from the framework, which uses the PulsarAdminBuilder. For this reason, you need to set the spring.pulsar.administration.service-url property unless you are running Pulsar on the default server and port. Specifying partition count when creating the topic: When creating the topic, you can set the partition count in two ways. First, you can set it at the binder level using the property spring.cloud.stream.pulsar.binder.partition-count . As we saw above, doing this way will make all the topics created by the application inherit this property. Suppose you want granular control at the binding level for setting partitions. In that case, you can set the partition-count property per binding using the format spring.cloud.stream.pulsar.bindings.<binding-name>.producer|consumer.partition-count . This way, various topics created by different functions in the same application will have different partitions based on the application requirements."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/other-resources.html","Other Resources: In addition to this reference documentation, we recommend a number of other resources that may help you learn about Spring and Apache Pulsar. Spring for Apache Pulsar GitHub Repository(https://github.com/spring-projects/spring-pulsar) Apache Pulsar Project Home Page(https://pulsar.apache.org/) Apache Pulsar Java Client(https://pulsar.apache.org/docs/3.2.x/client-libraries-java/) Apache Pulsar GitHub Repository(https://github.com/apache/pulsar) Apache Pulsar Reactive Client GitHub Repository(https://github.com/apache/pulsar-client-reactive)"
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/appendix/version-compatibility.html","Pulsar Clients and Spring Boot Compatibility: The following is the compatibility matrix: Spring for Apache Pulsar Pulsar Client Pulsar Reactive Client Spring Boot Java 1.1.x 3.2.x 0.5.x 3.3.x 17+ 1.0.x 3.0.x / 3.1.x 0.3.x - 0.5.x 3.2.x 17+ 0.2.x 2.11.x 0.2.x 3.0.x / 3.1.x (*) 17+ In version 1.0.0 the autoconfiguration moved into Spring Boot 3.2.x and therefore 3.2.x is the minimum Spring Boot version supported when using version 1.0.x of the framework. However, prior to version 1.0.0 , the autoconfiguration support exists in the framework itself. (*) This makes it theoretically possible to use later versions of Spring Boot besides 3.0.x which it is tested against and guaranteed to work with. In other words, it may work with 3.1.x but it has not been tested against it."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/appendix/override-boot-dependencies.html","Override Spring Boot Dependencies: When using Spring for Apache Pulsar in a Spring Boot application, the Apache Pulsar dependency versions are determined by Spring Boot’s dependency management. If you wish to use a different version of pulsar-client-all or pulsar-client-reactive-adapter , you need to override their version used by Spring Boot dependency management; set the pulsar.version or pulsar-reactive.version property, respectively. Or, to use a different Spring for Apache Pulsar version with a supported Spring Boot version, set the spring-pulsar.version property. In the following example, snapshot version of the Pulsar clients and Spring for Apache Pulsar are being used. Gradle ext['pulsar.version'] = '3.1.2-SNAPSHOT' ext['pulsar-reactive.version'] = '0.5.1-SNAPSHOT' ext['spring-pulsar.version'] = '1.0.2-SNAPSHOT' dependencies { implementation 'org.springframework.boot:spring-boot-starter-pulsar-reactive' } Maven <properties> <pulsar.version>3.1.2-SNAPSHOT</pulsar.version> <pulsar-reactive.version>0.5.1-SNAPSHOT</pulsar-reactive.version> <spring-pulsar.version>1.0.2-SNAPSHOT</spring-pulsar.version> </properties> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-pulsar-reactive</artifactId> </dependency>"
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/appendix/getting-dependencies-without-boot.html","Getting Dependencies without Spring Boot: We recommend a Spring Boot first approach when using Spring for Apache Pulsar. However, if you do not use Spring Boot, the preferred way to get the dependencies is to use the provided BOM to ensure a consistent version of modules is used throughout your entire project. The following example shows how to do so for both Maven and Gradle: Maven Gradle pom.xml <dependencyManagement> <dependencies> <!-- ... other dependency elements ... --> <dependency> <groupId>org.springframework.pulsar</groupId> <artifactId>spring-pulsar-bom</artifactId> <version>1.1.4</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> build.gradle plugins { id ""io.spring.dependency-management"" version ""1.1.4"" } dependencyManagement { imports { mavenBom 'org.springframework.pulsar:spring-pulsar-bom:1.1.4' } } A minimal Spring for Apache Pulsar set of dependencies typically looks like the following: Maven Gradle pom.xml <dependencies> <!-- ... other dependency elements ... --> <dependency> <groupId>org.springframework.pulsar</groupId> <artifactId>spring-pulsar</artifactId> </dependency> </dependencies> build.gradle dependencies { implementation ""org.springframework.pulsar:spring-pulsar"" } If you use additional features (such as Reactive), you need to also include the appropriate dependencies. Spring for Apache Pulsar builds against Spring Framework 6.1.13 but should generally work with any newer version of Spring Framework 6.x. Many users are likely to run afoul of the fact that Spring for Apache Pulsar’s transitive dependencies resolve Spring Framework 6.1.13, which can cause strange classpath problems. The easiest way to resolve this is to use the spring-framework-bom within your dependencyManagement section as follows: Maven Gradle pom.xml <dependencyManagement> <dependencies> <!-- ... other dependency elements ... --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-framework-bom</artifactId> <version>6.1.13</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> build.gradle plugins { id ""io.spring.dependency-management"" version ""1.1.4"" } dependencyManagement { imports { mavenBom 'org.springframework:spring-framework-bom:6.1.13' } } The preceding example ensures that all the transitive dependencies of Spring for Apache Pulsar use the Spring 6.1.13 modules."
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/appendix/non-ga-versions.html","Non-GA Versions: You can find snapshot or milestone versions of the dependencies in the following repositories: Maven Gradle <repositories> <repository> <id>spring-milestones</id> <name>Spring Milestones</name> <url>https://repo.spring.io/milestone</url> <snapshots> <enabled>false</enabled> </snapshots> </repository> <repository> <id>spring-snapshots</id> <name>Spring Snapshots</name> <url>https://repo.spring.io/snapshot</url> <releases> <enabled>false</enabled> </releases> </repository> <repository> <id>apache-snapshots</id> <name>Apache Snapshots</name> <url>https://repository.apache.org/content/repositories/snapshots</url> <releases> <enabled>false</enabled> </releases> </repository> </repositories> repositories { maven { name = 'spring-milestones' url = 'https://repo.spring.io/milestone' } maven { name = 'spring-snapshots' url = 'https://repo.spring.io/snapshot' } maven { name = 'apache-snapshot' url = 'https://repository.apache.org/content/repositories/snapshots' } }"
"https://docs.spring.io/spring-pulsar/docs/1.1.4/reference/appendix/native-image.html","GraalVM Native Image Support: GraalVM Native Images(https://www.graalvm.org/native-image/) are standalone executables that can be generated by processing compiled Java applications ahead-of-time. Native Images generally have a smaller memory footprint and start faster than their JVM counterparts. Support The required AOT Runtime Hints(https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#core.aot.hints) are built-in to Spring for Apache Pulsar so that it can seamlessly be used in native image based Spring applications. The native image support in Spring for Apache Pulsar has been tested in basic scenarios, and we expect it to ""just work"". However, it is possible that more advanced use cases could surface the need to add additional runtime hints to your own application. If this occurs please file a Github issue(https://github.com/spring-projects/spring-pulsar/issues) with some details. Next Steps If you are interested in adding native image support to your own application then an excellent place to start is the Spring Boot GraalVM Support(https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#native-image) section of the Spring Boot reference docs. Although there is no reference to Spring for Apache Pulsar in the aforementioned guide, you can find specific examples at the following coordinates: Spring for Apache Pulsar (imperative)(https://github.com/spring-projects/spring-aot-smoke-tests/tree/main/integration/spring-pulsar) Spring for Apache Pulsar (reactive)(https://github.com/spring-projects/spring-aot-smoke-tests/tree/main/integration/spring-pulsar-reactive)"
