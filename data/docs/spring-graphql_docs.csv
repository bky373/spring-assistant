"url","content"
"https://docs.spring.io/spring-graphql/reference/index.html","Spring for GraphQL: Spring for GraphQL provides support for Spring applications built on GraphQL Java(https://www.graphql-java.com/) . It is a joint collaboration between the GraphQL Java team and Spring engineering. Spring for GraphQL is the successor of the GraphQL Java Spring(https://github.com/graphql-java/graphql-java-spring) project from the GraphQL Java team. It aims to be the foundation for all Spring, GraphQL applications. Please, use our issue tracker(https://github.com/spring-projects/spring-graphql/issues) to report a problem, discuss a design issue, or to request a feature. Check the Wiki(https://github.com/spring-projects/spring-graphql/wiki) . for what’s new, baseline requirements, and upgrade notes, and other cross-version information. To get started, see the Boot Starter(boot-starter.html) and Samples(samples.html) sections."
"https://docs.spring.io/spring-graphql/reference/transports.html","Server Transports: Spring for GraphQL supports server handling of GraphQL requests over HTTP, WebSocket, and RSocket. HTTP: GraphQlHttpHandler handles GraphQL over HTTP requests and delegates to the Interception(#server.interception) chain for request execution. There are two variants, one for Spring MVC and one for Spring WebFlux. Both handle requests asynchronously and have equivalent functionality, but rely on blocking vs non-blocking I/O respectively for writing the HTTP response. Requests must use HTTP POST with ""application/json"" as content type and GraphQL request details included as JSON in the request body, as defined in the proposed GraphQL over HTTP(https://github.com/graphql/graphql-over-http/blob/main/spec/GraphQLOverHTTP.md) specification. Once the JSON body has been successfully decoded, the HTTP response status is always 200 (OK), and any errors from GraphQL request execution appear in the ""errors"" section of the GraphQL response. The default and preferred choice of media type is ""application/graphql-response+json"" , but ""application/json"" is also supported, as described in the specification. GraphQlHttpHandler can be exposed as an HTTP endpoint by declaring a RouterFunction bean and using the RouterFunctions from Spring MVC or WebFlux to create the route. The Boot Starter(boot-starter.html) does this, see the Web Endpoints(https://docs.spring.io/spring-boot/3.3.0/reference/web/spring-graphql.html#web.graphql.transports.http-websocket) section for details, or check GraphQlWebMvcAutoConfiguration or GraphQlWebFluxAutoConfiguration it contains, for the actual config. By default, the GraphQlHttpHandler will serialize and deserialize JSON payloads using the HttpMessageConverter (Spring MVC) and the DecoderHttpMessageReader/EncoderHttpMessageWriter (WebFlux) configured in the web framework. In some cases, the application will configure the JSON codec for the HTTP endpoint in a way that is not compatible with the GraphQL payloads. Applications can instantiate GraphQlHttpHandler with a custom JSON codec that will be used for GraphQL payloads. The 1.0.x branch of this repository contains a Spring MVC HTTP sample(https://github.com/spring-projects/spring-graphql/tree/1.0.x/samples/webmvc-http) application. Server-Sent Events: GraphQlSseHandler is very similar to the HTTP handler listed above, but this time handling GraphQL requests over HTTP using the Server-Sent Events protocol. With this transport, clients must send HTTP POST requests to the endpoint with ""application/json"" as content type and GraphQL request details included as JSON in the request body; the only difference with the vanilla HTTP variant is that the client must send ""text/event-stream"" as the ""Accept"" request header. The response will be sent as one or more Server-Sent Event(s). This is also defined in the proposed GraphQL over HTTP(https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverSSE.md) specification. Spring for GraphQL only implements the ""Distinct connections mode"", so applications must consider scalability concerns and whether adopting HTTP/2 as the underlying transport would help. The main use case for GraphQlSseHandler is an alternative to the WebSocket transport(#server.transports.websocket) , receiving a stream of items as a response to a subscription operation. Other types of operations, like queries and mutations, are not supported here and should be using the plain JSON over HTTP transport variant. File Upload: As a protocol GraphQL focuses on the exchange of textual data. This doesn’t include binary data such as images, but there is a separate, informal graphql-multipart-request-spec(https://github.com/jaydenseric/graphql-multipart-request-spec) that allows file uploads with GraphQL over HTTP. Spring for GraphQL does not support the graphql-multipart-request-spec directly. While the spec does provide the benefit of a unified GraphQL API, the actual experince has led to a number of issues, and best practice recommendations have evolved, see Apollo Server File Upload Best Practices(https://www.apollographql.com/blog/backend/file-uploads/file-upload-best-practices/) for a more detailed discussion. If you would like to use graphql-multipart-request-spec in your application, you can do so through the library multipart-spring-graphql(https://github.com/nkonev/multipart-spring-graphql) . WebSocket: GraphQlWebSocketHandler handles GraphQL over WebSocket requests based on the protocol(https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md) defined in the graphql-ws(https://github.com/enisdenjo/graphql-ws) library. The main reason to use GraphQL over WebSocket is subscriptions which allow sending a stream of GraphQL responses, but it can also be used for regular queries with a single response. The handler delegates every request to the Interception(#server.interception) chain for further request execution. GraphQL Over WebSocket Protocols There are two such protocols, one in the subscriptions-transport-ws(https://github.com/apollographql/subscriptions-transport-ws) library and another in the graphql-ws(https://github.com/enisdenjo/graphql-ws) library. The former is not active and succeeded by the latter. Read this blog post(https://the-guild.dev/blog/graphql-over-websockets) for the history. There are two variants of GraphQlWebSocketHandler , one for Spring MVC and one for Spring WebFlux. Both handle requests asynchronously and have equivalent functionality. The WebFlux handler also uses non-blocking I/O and back pressure to stream messages, which works well since in GraphQL Java a subscription response is a Reactive Streams Publisher . The graphql-ws project lists a number of recipes(https://github.com/enisdenjo/graphql-ws#recipes) for client use. GraphQlWebSocketHandler can be exposed as a WebSocket endpoint by declaring a SimpleUrlHandlerMapping bean and using it to map the handler to a URL path. By default, the Boot Starter(boot-starter.html) does not expose a GraphQL over WebSocket endpoint, but you can add a property for the endpoint path to enable it. Please, review Web Endpoints(https://docs.spring.io/spring-boot/3.3.0/reference/web/spring-graphql.html#web.graphql.transports.http-websocket) in the Boot reference documentation, and the list of supported spring.graphql.websocket properties(https://docs.spring.io/spring-boot/3.3.0/appendix/application-properties/index.html#appendix.application-properties.web) . You can also look at GraphQlWebMvcAutoConfiguration or GraphQlWebFluxAutoConfiguration for the actual Boot autoconfig details. The 1.0.x branch of this repository contains a WebFlux WebSocket sample(https://github.com/spring-projects/spring-graphql/tree/1.0.x/samples/webflux-websocket) application. RSocket: GraphQlRSocketHandler handles GraphQL over RSocket requests. Queries and mutations are expected and handled as an RSocket request-response interaction while subscriptions are handled as request-stream . GraphQlRSocketHandler can be used a delegate from an @Controller that is mapped to the route for GraphQL requests. For example: import java.util.Map; import reactor.core.publisher.Flux; import reactor.core.publisher.Mono; import org.springframework.graphql.server.GraphQlRSocketHandler; import org.springframework.messaging.handler.annotation.MessageMapping; import org.springframework.stereotype.Controller; @Controller public class GraphQlRSocketController { private final GraphQlRSocketHandler handler; GraphQlRSocketController(GraphQlRSocketHandler handler) { this.handler = handler; } @MessageMapping(""graphql"") public Mono<Map<String, Object>> handle(Map<String, Object> payload) { return this.handler.handle(payload); } @MessageMapping(""graphql"") public Flux<Map<String, Object>> handleSubscription(Map<String, Object> payload) { return this.handler.handleSubscription(payload); } } Interception: Server transports allow intercepting requests before and after the GraphQL Java engine is called to process a request. WebGraphQlInterceptor: HTTP(#server.transports.http) and WebSocket(#server.transports.websocket) transports invoke a chain of 0 or more WebGraphQlInterceptor , followed by an ExecutionGraphQlService that calls the GraphQL Java engine. Interceptors allow applications to intercept incoming requests in order to: Check HTTP request details Customize the graphql.ExecutionInput Add HTTP response headers Customize the graphql.ExecutionResult and more For example, an interceptor can pass an HTTP request header to a DataFetcher : import java.util.Collections; import reactor.core.publisher.Mono; import org.springframework.graphql.data.method.annotation.ContextValue; import org.springframework.graphql.data.method.annotation.QueryMapping; import org.springframework.graphql.server.WebGraphQlInterceptor; import org.springframework.graphql.server.WebGraphQlRequest; import org.springframework.graphql.server.WebGraphQlResponse; import org.springframework.stereotype.Controller; class RequestHeaderInterceptor implements WebGraphQlInterceptor { (1) @Override public Mono<WebGraphQlResponse> intercept(WebGraphQlRequest request, Chain chain) { String value = request.getHeaders().getFirst(""myHeader""); request.configureExecutionInput((executionInput, builder) -> builder.graphQLContext(Collections.singletonMap(""myHeader"", value)).build()); return chain.next(request); } } @Controller class MyContextValueController { (2) @QueryMapping Person person(@ContextValue String myHeader) { ... } } 1 Interceptor adds HTTP request header value into GraphQLContext 2 Data controller method accesses the value Reversely, an interceptor can access values added to the GraphQLContext by a controller: import graphql.GraphQLContext; import reactor.core.publisher.Mono; import org.springframework.graphql.data.method.annotation.QueryMapping; import org.springframework.graphql.server.WebGraphQlInterceptor; import org.springframework.graphql.server.WebGraphQlRequest; import org.springframework.graphql.server.WebGraphQlResponse; import org.springframework.http.HttpHeaders; import org.springframework.http.ResponseCookie; import org.springframework.stereotype.Controller; // Subsequent access from a WebGraphQlInterceptor class ResponseHeaderInterceptor implements WebGraphQlInterceptor { @Override public Mono<WebGraphQlResponse> intercept(WebGraphQlRequest request, Chain chain) { (2) return chain.next(request).doOnNext((response) -> { String value = response.getExecutionInput().getGraphQLContext().get(""cookieName""); ResponseCookie cookie = ResponseCookie.from(""cookieName"", value).build(); response.getResponseHeaders().add(HttpHeaders.SET_COOKIE, cookie.toString()); }); } } @Controller class MyCookieController { @QueryMapping Person person(GraphQLContext context) { (1) context.put(""cookieName"", ""123""); ... } } 1 Controller adds value to the GraphQLContext 2 Interceptor uses the value to add an HTTP response header WebGraphQlHandler can modify the ExecutionResult , for example, to inspect and modify request validation errors that are raised before execution begins and which cannot be handled with a DataFetcherExceptionResolver : import java.util.List; import graphql.GraphQLError; import graphql.GraphqlErrorBuilder; import reactor.core.publisher.Mono; import org.springframework.graphql.server.WebGraphQlInterceptor; import org.springframework.graphql.server.WebGraphQlRequest; import org.springframework.graphql.server.WebGraphQlResponse; class RequestErrorInterceptor implements WebGraphQlInterceptor { @Override public Mono<WebGraphQlResponse> intercept(WebGraphQlRequest request, Chain chain) { return chain.next(request).map((response) -> { if (response.isValid()) { return response; (1) } List<GraphQLError> errors = response.getErrors().stream() (2) .map((error) -> { GraphqlErrorBuilder<?> builder = GraphqlErrorBuilder.newError(); // ... return builder.build(); }) .toList(); return response.transform((builder) -> builder.errors(errors).build()); (3) }); } } 1 Return the same if ExecutionResult has a ""data"" key with non-null value 2 Check and transform the GraphQL errors 3 Update the ExecutionResult with the modified errors Use WebGraphQlHandler to configure the WebGraphQlInterceptor chain. This is supported by the Boot Starter(boot-starter.html) , see Web Endpoints(https://docs.spring.io/spring-boot/3.3.0/reference/web/spring-graphql.html#web.graphql.transports.http-websocket) . WebSocketGraphQlInterceptor: WebSocketGraphQlInterceptor extends WebGraphQlInterceptor with additional callbacks to handle the start and end of a WebSocket connection, in addition to client-side cancellation of subscriptions. The same also intercepts every GraphQL request on the WebSocket connection. Use WebGraphQlHandler to configure the WebGraphQlInterceptor chain. This is supported by the Boot Starter(boot-starter.html) , see Web Endpoints(https://docs.spring.io/spring-boot/3.3.0/reference/web/spring-graphql.html#web.graphql.transports.http-websocket) . There can be at most one WebSocketGraphQlInterceptor in a chain of interceptors. There are two built-in WebSocket interceptors called AuthenticationWebSocketInterceptor , one for the WebMVC and one for the WebFlux transports. These help to extract authentication details from the payload of a ""connection_init"" GraphQL over WebSocket message, authenticate, and then propagate the SecurityContext to subsequent requests on the WebSocket connection. There is a websocket-authentication sample in spring-graphql-examples(https://github.com/spring-projects/spring-graphql-examples) . RSocketQlInterceptor: Similar to WebGraphQlInterceptor(#server.interception.web) , an RSocketQlInterceptor allows intercepting GraphQL over RSocket requests before and after GraphQL Java engine execution. You can use this to customize the graphql.ExecutionInput and the graphql.ExecutionResult ."
"https://docs.spring.io/spring-graphql/reference/request-execution.html","Request Execution: ExecutionGraphQlService is the main Spring abstraction to call GraphQL Java to execute requests. Underlying transports, such as the HTTP(transports.html#server.transports.http) , delegate to ExecutionGraphQlService to handle requests. The main implementation, DefaultExecutionGraphQlService , is configured with a GraphQlSource for access to the graphql.GraphQL instance to invoke. GraphQLSource: GraphQlSource is a contract to expose the graphql.GraphQL instance to use that also includes a builder API to build that instance. The default builder is available via GraphQlSource.schemaResourceBuilder() . The Boot Starter(boot-starter.html) creates an instance of this builder and further initializes it to load schema files(#execution.graphqlsource.schema-resources) from a configurable location, to expose properties(https://docs.spring.io/spring-boot/3.3.0/appendix/application-properties/index.html#appendix.application-properties.web) to apply to GraphQlSource.Builder , to detect RuntimeWiringConfigurer(#execution.graphqlsource.runtimewiring-configurer) beans, Instrumentation(https://www.graphql-java.com/documentation/instrumentation) beans for GraphQL metrics(observability.html#observability) , and DataFetcherExceptionResolver and SubscriptionExceptionResolver beans for exception resolution(#execution.exceptions) . For further customizations, you can also declare a GraphQlSourceBuilderCustomizer bean, for example: @Configuration(proxyBeanMethods = false) class GraphQlConfig { @Bean public GraphQlSourceBuilderCustomizer sourceBuilderCustomizer() { return (builder) -> builder.configureGraphQl(graphQlBuilder -> graphQlBuilder.executionIdProvider(new CustomExecutionIdProvider())); } } Schema Resources: GraphQlSource.Builder can be configured with one or more Resource instances to be parsed and merged together. That means schema files can be loaded from just about any location. By default, the Boot starter looks for schema files(https://docs.spring.io/spring-boot/3.3.0/reference/web/spring-graphql.html#web.graphql.schema) with extensions "".graphqls"" or "".gqls"" under the location classpath:graphql/** , which is typically src/main/resources/graphql . You can also use a file system location, or any location supported by the Spring Resource hierarchy, including a custom implementation that loads schema files from remote locations, from storage, or from memory. Use classpath*:graphql/**/ to find schema files across multiple classpath locations, e.g. across multiple modules. Schema Creation: By default, GraphQlSource.Builder uses the GraphQL Java SchemaGenerator to create the graphql.schema.GraphQLSchema . This works for typical use, but if you need to use a different generator, you can register a schemaFactory callback: GraphQlSource.Builder builder = ... builder.schemaResources(..) .configureRuntimeWiring(..) .schemaFactory((typeDefinitionRegistry, runtimeWiring) -> { // create GraphQLSchema }) See the GraphQlSource(#execution.graphqlsource) section for how to configure this with Spring Boot. If interested in federation, please see the Federation(federation.html) section. RuntimeWiringConfigurer: A RuntimeWiringConfigurer is useful to register the following: Custom scalar types. Code that handles Directives(#execution.graphqlsource.directives) . Direct DataFetcher registrations. and more…​ Spring applications typically do not need to perform direct DataFetcher registrations. Instead, controller method are registered as DataFetcher s via AnnotatedControllerConfigurer , which is a RuntimeWiringConfigurer . GraphQL Java, server applications use Jackson only for serialization to and from maps of data. Client input is parsed into a map. Server output is assembled into a map based on the field selection set. This means you can’t rely on Jackson serialization/deserialization annotations. Instead, you can use custom scalar types(https://www.graphql-java.com/documentation/scalars/) . The Boot Starter(boot-starter.html) detects beans of type RuntimeWiringConfigurer and registers them in the GraphQlSource.Builder . That means in most cases, you’ll' have something like the following in your configuration: @Configuration public class GraphQlConfig { @Bean public RuntimeWiringConfigurer runtimeWiringConfigurer(BookRepository repository) { GraphQLScalarType scalarType = ... ; SchemaDirectiveWiring directiveWiring = ... ; return wiringBuilder -> wiringBuilder .scalar(scalarType) .directiveWiring(directiveWiring); } } If you need to add a WiringFactory , e.g. to make registrations that take into account schema definitions, implement the alternative configure method that accepts both the RuntimeWiring.Builder and an output List<WiringFactory> . This allows you to add any number of factories that are then invoked in sequence. TypeResolver: GraphQlSource.Builder registers ClassNameTypeResolver as the default TypeResolver to use for GraphQL Interfaces and Unions that don’t already have such a registration through a RuntimeWiringConfigurer(#execution.graphqlsource.runtimewiring-configurer) . The purpose of a TypeResolver in GraphQL Java is to determine the GraphQL Object type for values returned from the DataFetcher for a GraphQL Interface or Union field. ClassNameTypeResolver tries to match the simple class name of the value to a GraphQL Object Type and if it is not successful, it also navigates its super types including base classes and interfaces, looking for a match. ClassNameTypeResolver provides an option to configure a name extracting function along with Class to GraphQL Object type name mappings that should help to cover more corner cases: GraphQlSource.Builder builder = ... ClassNameTypeResolver classNameTypeResolver = new ClassNameTypeResolver(); classNameTypeResolver.setClassNameExtractor((klass) -> { // Implement Custom ClassName Extractor here }); builder.defaultTypeResolver(classNameTypeResolver); See the GraphQlSource(#execution.graphqlsource) section for how to configure this with Spring Boot. Directives: The GraphQL language supports directives that ""describe alternate runtime execution and type validation behavior in a GraphQL document"". Directives are similar to annotations in Java but declared on types, fields, fragments and operations in a GraphQL document. GraphQL Java provides the SchemaDirectiveWiring contract to help applications detect and handle directives. For more details, see Schema Directives(https://www.graphql-java.com/documentation/sdl-directives/) in the GraphQL Java documentation. In Spring GraphQL you can register a SchemaDirectiveWiring through a RuntimeWiringConfigurer(#execution.graphqlsource.runtimewiring-configurer) . The Boot Starter(boot-starter.html) detects such beans, so you might have something like: @Configuration public class GraphQlConfig { @Bean public RuntimeWiringConfigurer runtimeWiringConfigurer() { return builder -> builder.directiveWiring(new MySchemaDirectiveWiring()); } } For an example of directives support check out the Extended Validation for Graphql Java(https://github.com/graphql-java/graphql-java-extended-validation) library. ExecutionStrategy: An ExecutionStrategy in GraphQL Java drives the fetching of requested fields. To create an ExecutionStrategy , you need to provide a DataFetcherExceptionHandler . By default, Spring for GraphQL creates the exception handler to use as described in Exceptions(#execution.exceptions) and sets it on the GraphQL.Builder . GraphQL Java then uses that to create AsyncExecutionStrategy instances with the configured exception handler. If you need to create a custom ExecutionStrategy , you can detect DataFetcherExceptionResolver s and create an exception handler in the same way, and use it to create the custom ExecutionStrategy . For example, in a Spring Boot application: @Bean GraphQlSourceBuilderCustomizer sourceBuilderCustomizer( ObjectProvider<DataFetcherExceptionResolver> resolvers) { DataFetcherExceptionHandler exceptionHandler = DataFetcherExceptionResolver.createExceptionHandler(resolvers.stream().toList()); AsyncExecutionStrategy strategy = new CustomAsyncExecutionStrategy(exceptionHandler); return sourceBuilder -> sourceBuilder.configureGraphQl(builder -> builder.queryExecutionStrategy(strategy).mutationExecutionStrategy(strategy)); } Schema Transformation: You can register a graphql.schema.GraphQLTypeVisitor via builder.schemaResources(..).typeVisitorsToTransformSchema(..) if you want to traverse and transform the schema after it is created, and make changes to the schema. Keep in mind that this is more expensive than Schema Traversal(#execution.graphqlsource.schema-traversal) so generally prefer traversal to transformation unless you need to make schema changes. Schema Traversal: You can register a graphql.schema.GraphQLTypeVisitor via builder.schemaResources(..).typeVisitors(..) if you want to traverse the schema after it is created, and possibly apply changes to the GraphQLCodeRegistry . Keep in mind, however, that such a visitor cannot change the schema. See Schema Transformation(#execution.graphqlsource.schema-transformation) , if you need to make changes to the schema. Schema Mapping Inspection: If a query, mutation, or subscription operation does not have a DataFetcher , it won’t return any data, and won’t do anything useful. Likewise, fields of schema types that are neither covered explicitly through a DataFetcher registration, nor implicitly by the default PropertyDataFetcher that finds matching Class properties, will always be null . GraphQL Java does not perform checks to ensure every schema field is covered, and as a lower level library, GraphQL Java simply does not know what a DataFetcher can return or what arguments it depends on, and therefore cannot perform such verifications. This can result in gaps that depending on test coverage may not be discovered until runtime when clients may experience ""silent"" null values, or non-null field errors. The SelfDescribingDataFetcher interface in Spring for GraphQL allows a DataFetcher to expose information such as return type and expected arguments. All built-in, Spring DataFetcher implementations for controller methods(controllers.html) , for Querydsl(data.html#data.querydsl) and for Query by Example(data.html#data.querybyexample) are implementations of this interface. For annotated controllers, the return type and expected arguments are based on the controller method signature. This makes it possible to inspect schema mappings on startup to ensure the following: Schema fields have either a DataFetcher registration or a corresponding Class property. DataFetcher registrations refer to a schema field that exists. DataFetcher arguments have matching schema field arguments. To enable schema inspection, customize GraphQlSource.Builder as shown below. In this case the report is simply logged, but you can choose to take any action: GraphQlSource.Builder builder = ... builder.schemaResources(..) .inspectSchemaMappings(report -> { logger.debug(report); }); An example report: GraphQL schema inspection: Unmapped fields: {Book=[title], Author[firstName, lastName]} (1) Unmapped registrations: {Book.reviews=BookController#reviews[1 args]} (2) Unmapped arguments: {BookController#bookSearch[1 args]=[myAuthor]} (3) Skipped types: [BookOrAuthor] (4) 1 Schema fields that are not covered in any way 2 DataFetcher registrations to fields that don’t exist 3 DataFetcher expected arguments that don’t exist 4 Schema types that have been skipped (explained next) In some cases, the Class type for a schema type is unknown. Maybe the DataFetcher does not implement SelfDescribingDataFetcher , or the declared return type is too general (e.g. Object ) or unknown (e.g. List<?> ), or a DataFetcher could be missing altogether. In such cases, the schema type is listed as skipped as it could not be verified. For every skipped type, a DEBUG message explains why it was skipped. Unions and Interfaces: For unions, the inspection iterates over member types and tries to find the corresponding classes. For interfaces, the inspection iterates over implementation types and looks for the corresponding classes. By default, corresponding Java classes can be detected out-of-the-box in the following cases: The Class 's simple name matches the GraphQL union member of interface implementation type name, and the Class is located in the same package as the return type of the controller method, or controller class, mapped to the union or interface field. The Class is inspected in other parts of the schema where the mapped field is of a concrete union member or interface implementation type. You have registered a TypeResolver(#execution.graphqlsource.default-type-resolver) that has explicit Class to GraphQL type mappings . In none the above help, and GraphQL types are reported as skipped in the schema inspection report, you can make the following customizations: Explicitly map a GraphQL type name to a Java class or classes. Configure a function that customizes how a GraphQL type name is adapted to a simple Class name. This can help with a specific Java class naming conventions. Provide a ClassNameTypeResolver to map a GraphQL type a Java classes. For example: GraphQlSource.Builder builder = ... builder.schemaResources(..) .inspectSchemaMappings( initializer -> initializer.classMapping(""Author"", Author.class) logger::debug); Operation Caching: GraphQL Java must parse and validate an operation before executing it. This may impact performance significantly. To avoid the need to re-parse and validate, an application may configure a PreparsedDocumentProvider that caches and reuses Document instances. The GraphQL Java docs(https://www.graphql-java.com/documentation/execution/#query-caching) provide more details on query caching through a PreparsedDocumentProvider . In Spring GraphQL you can register a PreparsedDocumentProvider through GraphQlSource.Builder#configureGraphQl : . // Typically, accessed through Spring Boot's GraphQlSourceBuilderCustomizer GraphQlSource.Builder builder = ... // Create provider PreparsedDocumentProvider provider = new ApolloPersistedQuerySupport(new InMemoryPersistedQueryCache(Collections.emptyMap())); builder.schemaResources(..) .configureRuntimeWiring(..) .configureGraphQl(graphQLBuilder -> graphQLBuilder.preparsedDocumentProvider(provider)) See the GraphQlSource(#execution.graphqlsource) section for how to configure this with Spring Boot. Thread Model: Most GraphQL requests benefit from concurrent execution in fetching nested fields. This is why most applications today rely on GraphQL Java’s AsyncExecutionStrategy , which allows data fetchers to return CompletionStage and to execute concurrently rather than serially. Java 21 and virtual threads add an important ability to use more threads efficiently, but it is still necessary to execute concurrently rather than serially in order for request execution to complete more quickly. Spring for GraphQL supports: Reactive data fetchers(#execution.reactive-datafetcher) , and those are adapted to CompletionStage as expected by AsyncExecutionStrategy . CompletionStage as return value. Controller methods that are Kotlin coroutine methods. @SchemaMapping(controllers.html#controllers.schema-mapping) and @BatchMapping(controllers.html#controllers.schema-mapping) methods can return Callable that is submitted to an Executor such as the Spring Framework VirtualThreadTaskExecutor . To enable this, you must configure an Executor on AnnotatedControllerConfigurer . Spring for GraphQL runs on either Spring MVC or WebFlux as the transport. Spring MVC uses async request execution, unless the resulting CompletableFuture is done immediately after the GraphQL Java engine returns, which would be the case if the request is simple enough and did not require asynchronous data fetching. Reactive DataFetcher: The default GraphQlSource builder enables support for a DataFetcher to return Mono or Flux which adapts those to a CompletableFuture where Flux values are aggregated and turned into a List, unless the request is a GraphQL subscription request, in which case the return value remains a Reactive Streams Publisher for streaming GraphQL responses. A reactive DataFetcher can rely on access to Reactor context propagated from the transport layer, such as from a WebFlux request handling, see WebFlux Context(#execution.context.webflux) . Context Propagation: Spring for GraphQL provides support to transparently propagate context from the HTTP(transports.html#server.transports.http) transport, through GraphQL Java, and to DataFetcher and other components it invokes. This includes both ThreadLocal context from the Spring MVC request handling thread and Reactor Context from the WebFlux processing pipeline. WebMvc: A DataFetcher and other components invoked by GraphQL Java may not always execute on the same thread as the Spring MVC handler, for example if an asynchronous WebGraphQlInterceptor(transports.html#server.interception) or DataFetcher switches to a different thread. Spring for GraphQL supports propagating ThreadLocal values from the Servlet container thread to the thread a DataFetcher and other components invoked by GraphQL Java to execute on. To do this, an application needs to implement io.micrometer.context.ThreadLocalAccessor for a ThreadLocal values of interest: public class RequestAttributesAccessor implements ThreadLocalAccessor<RequestAttributes> { @Override public Object key() { return RequestAttributesAccessor.class.getName(); } @Override public RequestAttributes getValue() { return RequestContextHolder.getRequestAttributes(); } @Override public void setValue(RequestAttributes attributes) { RequestContextHolder.setRequestAttributes(attributes); } @Override public void reset() { RequestContextHolder.resetRequestAttributes(); } } You can register a ThreadLocalAccessor manually on startup with the global ContextRegistry instance, which is accessible via io.micrometer.context.ContextRegistry#getInstance() . You can also register it automatically through the java.util.ServiceLoader mechanism. WebFlux: A Reactive DataFetcher(#execution.reactive-datafetcher) can rely on access to Reactor context that originates from the WebFlux request handling chain. This includes Reactor context added by WebGraphQlInterceptor(transports.html#server.interception) components. Exceptions: In GraphQL Java, DataFetcherExceptionHandler decides how to represent exceptions from data fetching in the ""errors"" section of the response. An application can register a single handler only. Spring for GraphQL registers a DataFetcherExceptionHandler that provides default handling and enables the DataFetcherExceptionResolver contract. An application can register any number of resolvers via GraphQLSource(#execution.graphqlsource) builder and those are in order until one them resolves the Exception to a List<graphql.GraphQLError> . The Spring Boot starter detects beans of this type. DataFetcherExceptionResolverAdapter is a convenient base class with protected methods resolveToSingleError and resolveToMultipleErrors . The Annotated Controllers(controllers.html) programming model enables handling data fetching exceptions with annotated exception handler methods with a flexible method signature, see @GraphQlExceptionHandler(controllers.html#controllers.exception-handler) for details. A GraphQLError can be assigned to a category based on the GraphQL Java graphql.ErrorClassification , or the Spring GraphQL ErrorType , which defines the following: BAD_REQUEST UNAUTHORIZED FORBIDDEN NOT_FOUND INTERNAL_ERROR If an exception remains unresolved, by default it is categorized as an INTERNAL_ERROR with a generic message that includes the category name and the executionId from DataFetchingEnvironment . The message is intentionally opaque to avoid leaking implementation details. Applications can use a DataFetcherExceptionResolver to customize error details. Unresolved exception are logged at ERROR level along with the executionId to correlate to the error sent to the client. Resolved exceptions are logged at DEBUG level. Request Exceptions: The GraphQL Java engine may run into validation or other errors when parsing the request and that in turn prevent request execution. In such cases, the response contains a ""data"" key with null and one or more request-level ""errors"" that are global, i.e. not having a field path. DataFetcherExceptionResolver cannot handle such global errors because they are raised before execution begins and before any DataFetcher is invoked. An application can use transport level interceptors to inspect and transform errors in the ExecutionResult . See examples under WebGraphQlInterceptor(transports.html#server.interception.web) . Subscription Exceptions: The Publisher for a subscription request may complete with an error signal in which case the underlying transport (e.g. WebSocket) sends a final ""error"" type message with a list of GraphQL errors. DataFetcherExceptionResolver cannot resolve errors from a subscription Publisher , since the data DataFetcher only creates the Publisher initially. After that, the transport subscribes to the Publisher that may then complete with an error. An application can register a SubscriptionExceptionResolver in order to resolve exceptions from a subscription Publisher in order to resolve those to GraphQL errors to send to the client. Pagination: The GraphQL Cursor Connection specification(https://relay.dev/graphql/connections.htm) defines a way to navigate large result sets by returning a subset of items at a time where each item is paired with a cursor that clients can use to request more items before or after the referenced item. The specification calls the pattern ""Connections"" . A schema type with a name that ends on Connection is a Connection Type that represents a paginated result set. All ~Connection types contain an ""edges"" field where ~Edge type pairs the actual item with a cursor, as well as a ""pageInfo"" field with boolean flags to indicate if there are more items forward and backward. Connection Types: Connection type definitions must be created for every type that needs pagination, adding boilerplate and noise to the schema. Spring for GraphQL provides ConnectionTypeDefinitionConfigurer to add these types on startup, if not already present in the parsed schema files. That means in the schema you only need this: Query { books(first:Int, after:String, last:Int, before:String): BookConnection } type Book { id: ID! title: String! } Note the spec-defined forward pagination arguments first and after that clients can use to request the first N items after the given cursor, while last and before are backward pagination arguments to request the last N items before the given cursor. Next, configure ConnectionTypeDefinitionConfigurer as follows: GraphQlSource.schemaResourceBuilder() .schemaResources(..) .typeDefinitionConfigurer(new ConnectionTypeDefinitionConfigurer) and the following type definitions will be transparently added to the schema: type BookConnection { edges: [BookEdge]! pageInfo: PageInfo! } type BookEdge { node: Book! cursor: String! } type PageInfo { hasPreviousPage: Boolean! hasNextPage: Boolean! startCursor: String endCursor: String } The Boot Starter(boot-starter.html) registers ConnectionTypeDefinitionConfigurer by default. ConnectionAdapter: Once Connection Types(#execution.pagination.types) are available in the schema, you also need equivalent Java types. GraphQL Java provides those, including generic Connection and Edge , as well as a PageInfo . One option is to populate a Connection and return it from your controller method or DataFetcher . However, this requires boilerplate code to create the Connection , creating cursors, wrapping each item as an Edge , and creating the PageInfo . Moreover, you may already have an underlying pagination mechanism such as when using Spring Data repositories. Spring for GraphQL defines the ConnectionAdapter contract to adapt a container of items to Connection . Adapters are applied through a DataFetcher decorator that is in turn installed through a ConnectionFieldTypeVisitor . You can configure it as follows: ConnectionAdapter adapter = ... ; GraphQLTypeVisitor visitor = ConnectionFieldTypeVisitor.create(List.of(adapter)) (1) GraphQlSource.schemaResourceBuilder() .schemaResources(..) .typeDefinitionConfigurer(..) .typeVisitors(List.of(visitor)) (2) 1 Create type visitor with one or more ConnectionAdapter s. 2 Resister the type visitor. There are built-in(data.html#data.pagination.scroll) ConnectionAdapter s for Spring Data’s Window and Slice . You can also create your own custom adapter. ConnectionAdapter implementations rely on a CursorStrategy(#execution.pagination.cursor.strategy) to create cursors for returned items. The same strategy is also used to support the Subrange(controllers.html#controllers.schema-mapping.subrange) controller method argument that contains pagination input. CursorStrategy: CursorStrategy is a contract to encode and decode a String cursor that refers to the position of an item within a large result set. The cursor can be based on an index or on a keyset. A ConnectionAdapter(#execution.pagination.adapters) uses this to encode cursors for returned items. Annotated Controllers(controllers.html) methods, Querydsl(data.html#data.querydsl) repositories, and Query by Example(data.html#data.querybyexample) repositories use it to decode cursors from pagination requests, and create a Subrange . CursorEncoder is a related contract that further encodes and decodes String cursors to make them opaque to clients. EncodingCursorStrategy combines CursorStrategy with a CursorEncoder . You can use Base64CursorEncoder , NoOpEncoder or create your own. There is a built-in(data.html#data.pagination.scroll) CursorStrategy for the Spring Data ScrollPosition . The Boot Starter(boot-starter.html) registers a CursorStrategy<ScrollPosition> with Base64Encoder when Spring Data is present. Sort: There is no standard way to provide sort information in a GraphQL request. However, pagination depends on a stable sort order. You can use a default order, or otherwise expose input types and extract sort details from GraphQL arguments. There is built-in(data.html#data.pagination.sort) support for Spring Data’s Sort as a controller method argument. For this to work, you need to have a SortStrategy bean. Batch Loading: Given a Book and its Author , we can create one DataFetcher for a book and another for its author. This allows selecting books with or without authors, but it means books and authors aren’t loaded together, which is especially inefficient when querying multiple books as the author for each book is loaded individually. This is known as the N+1 select problem. DataLoader: GraphQL Java provides a DataLoader mechanism for batch loading of related entities. You can find the full details in the GraphQL Java docs(https://www.graphql-java.com/documentation/batching/) . Below is a summary of how it works: Register DataLoader 's in the DataLoaderRegistry that can load entities, given unique keys. DataFetcher 's can access DataLoader 's and use them to load entities by id. A DataLoader defers loading by returning a future so it can be done in a batch. DataLoader 's maintain a per request cache of loaded entities that can further improve efficiency. BatchLoaderRegistry: The complete batching loading mechanism in GraphQL Java requires implementing one of several BatchLoader interface, then wrapping and registering those as DataLoader s with a name in the DataLoaderRegistry . The API in Spring GraphQL is slightly different. For registration, there is only one, central BatchLoaderRegistry exposing factory methods and a builder to create and register any number of batch loading functions: @Configuration public class MyConfig { public MyConfig(BatchLoaderRegistry registry) { registry.forTypePair(Long.class, Author.class).registerMappedBatchLoader((authorIds, env) -> { // return Mono<Map<Long, Author> }); // more registrations ... } } The Boot Starter(boot-starter.html) declares a BatchLoaderRegistry bean that you can inject into your configuration, as shown above, or into any component such as a controller in order register batch loading functions. In turn the BatchLoaderRegistry is injected into DefaultExecutionGraphQlService where it ensures DataLoader registrations per request. By default, the DataLoader name is based on the class name of the target entity. This allows an @SchemaMapping method to declare a DataLoader argument(controllers.html#controllers.schema-mapping.data-loader) with a generic type, and without the need for specifying a name. The name, however, can be customized through the BatchLoaderRegistry builder, if necessary, along with other DataLoaderOptions . To configure default DataLoaderOptions globally, to use as a starting point for any registration, you can override Boot’s BatchLoaderRegistry bean and use the constructor for DefaultBatchLoaderRegistry that accepts Supplier<DataLoaderOptions> . For many cases, when loading related entities, you can use @BatchMapping(controllers.html#controllers.batch-mapping) controller methods, which are a shortcut for and replace the need to use BatchLoaderRegistry and DataLoader directly. BatchLoaderRegistry provides other important benefits too. It supports access to the same GraphQLContext from batch loading functions and from @BatchMapping methods, as well as ensures Context Propagation(#execution.context) to them. This is why applications are expected to use it. It is possible to perform your own DataLoader registrations directly but such registrations would forgo the above benefits. Testing Batch Loading: Start by having BatchLoaderRegistry perform registrations on a DataLoaderRegistry : BatchLoaderRegistry batchLoaderRegistry = new DefaultBatchLoaderRegistry(); // perform registrations... DataLoaderRegistry dataLoaderRegistry = DataLoaderRegistry.newRegistry().build(); batchLoaderRegistry.registerDataLoaders(dataLoaderRegistry, graphQLContext); Now you can access and test individual DataLoader 's as follows: DataLoader<Long, Book> loader = dataLoaderRegistry.getDataLoader(Book.class.getName()); loader.load(1L); loader.loadMany(Arrays.asList(2L, 3L)); List<Book> books = loader.dispatchAndJoin(); // actual loading assertThat(books).hasSize(3); assertThat(books.get(0).getName()).isEqualTo(""...""); // ..."
"https://docs.spring.io/spring-graphql/reference/data.html","Data Integration: Spring for GraphQL lets you leverage existing Spring technology, following common programming models to expose underlying data sources through GraphQL. This section discusses an integration layer for Spring Data that provides an easy way to adapt a Querydsl or a Query by Example repository to a DataFetcher , including the option for automated detection and GraphQL Query registration for repositories marked with @GraphQlRepository . Querydsl: Spring for GraphQL supports use of Querydsl(http://www.querydsl.com/) to fetch data through the Spring Data Querydsl extension(https://docs.spring.io/spring-data/commons/docs/current/reference/html/#core.extensions) . Querydsl provides a flexible yet typesafe approach to express query predicates by generating a meta-model using annotation processors. For example, declare a repository as QuerydslPredicateExecutor : public interface AccountRepository extends Repository<Account, Long>, QuerydslPredicateExecutor<Account> { } Then use it to create a DataFetcher : // For single result queries DataFetcher<Account> dataFetcher = QuerydslDataFetcher.builder(repository).single(); // For multi-result queries DataFetcher<Iterable<Account>> dataFetcher = QuerydslDataFetcher.builder(repository).many(); // For paginated queries DataFetcher<Iterable<Account>> dataFetcher = QuerydslDataFetcher.builder(repository).scrollable(); You can now register the above DataFetcher through a RuntimeWiringConfigurer(request-execution.html#execution.graphqlsource.runtimewiring-configurer) . The DataFetcher builds a Querydsl Predicate from GraphQL arguments, and uses it to fetch data. Spring Data supports QuerydslPredicateExecutor for JPA, MongoDB, Neo4j, and LDAP. For a single argument that is a GraphQL input type, QuerydslDataFetcher nests one level down, and uses the values from the argument sub-map. If the repository is ReactiveQuerydslPredicateExecutor , the builder returns DataFetcher<Mono<Account>> or DataFetcher<Flux<Account>> . Spring Data supports this variant for MongoDB and Neo4j. Build Setup: To configure Querydsl in your build, follow the official reference documentation(https://querydsl.com/static/querydsl/latest/reference/html/ch02.html) : For example: Gradle Maven dependencies { //... annotationProcessor ""com.querydsl:querydsl-apt:$querydslVersion:jpa"", 'org.hibernate.javax.persistence:hibernate-jpa-2.1-api:1.0.2.Final', 'javax.annotation:javax.annotation-api:1.3.2' } compileJava { options.annotationProcessorPath = configurations.annotationProcessor } <dependencies> <!-- ... --> <dependency> <groupId>com.querydsl</groupId> <artifactId>querydsl-apt</artifactId> <version>${querydsl.version}</version> <classifier>jpa</classifier> <scope>provided</scope> </dependency> <dependency> <groupId>org.hibernate.javax.persistence</groupId> <artifactId>hibernate-jpa-2.1-api</artifactId> <version>1.0.2.Final</version> </dependency> <dependency> <groupId>javax.annotation</groupId> <artifactId>javax.annotation-api</artifactId> <version>1.3.2</version> </dependency> </dependencies> <plugins> <!-- Annotation processor configuration --> <plugin> <groupId>com.mysema.maven</groupId> <artifactId>apt-maven-plugin</artifactId> <version>${apt-maven-plugin.version}</version> <executions> <execution> <goals> <goal>process</goal> </goals> <configuration> <outputDirectory>target/generated-sources/java</outputDirectory> <processor>com.querydsl.apt.jpa.JPAAnnotationProcessor</processor> </configuration> </execution> </executions> </plugin> </plugins> The webmvc-http(https://github.com/spring-projects/spring-graphql/tree/1.0.x/samples/webmvc-http) sample uses Querydsl for artifactRepositories . Customizations: QuerydslDataFetcher supports customizing how GraphQL arguments are bound onto properties to create a Querydsl Predicate . By default, arguments are bound as ""is equal to"" for each available property. To customize that, you can use QuerydslDataFetcher builder methods to provide a QuerydslBinderCustomizer . A repository may itself be an instance of QuerydslBinderCustomizer . This is auto-detected and transparently applied during Auto-Registration(#data.querydsl.registration) . However, when manually building a QuerydslDataFetcher you will need to use builder methods to apply it. QuerydslDataFetcher supports interface and DTO projections to transform query results before returning these for further GraphQL processing. To learn what projections are, please refer to the Spring Data docs(https://docs.spring.io/spring-data/commons/docs/current/reference/html/#projections) . To understand how to use projections in GraphQL, please see Selection Set vs Projections(#data.projections) . To use Spring Data projections with Querydsl repositories, create either a projection interface or a target DTO class and configure it through the projectAs method to obtain a DataFetcher producing the target type: class Account { String name, identifier, description; Person owner; } interface AccountProjection { String getName(); String getIdentifier(); } // For single result queries DataFetcher<AccountProjection> dataFetcher = QuerydslDataFetcher.builder(repository).projectAs(AccountProjection.class).single(); // For multi-result queries DataFetcher<Iterable<AccountProjection>> dataFetcher = QuerydslDataFetcher.builder(repository).projectAs(AccountProjection.class).many(); Auto-Registration: If a repository is annotated with @GraphQlRepository , it is automatically registered for queries that do not already have a registered DataFetcher and whose return type matches that of the repository domain type. This includes single value queries, multi-value queries, and paginated(request-execution.html#execution.pagination) queries. By default, the name of the GraphQL type returned by the query must match the simple name of the repository domain type. If needed, you can use the typeName attribute of @GraphQlRepository to specify the target GraphQL type name. For paginated queries, the simple name of the repository domain type must match the Connection type name without the Connection ending (e.g. Book matches Books Connection ). For auto-registration, pagination is offset-based with 20 items per page. Auto-registration detects if a given repository implements QuerydslBinderCustomizer and transparently applies that through QuerydslDataFetcher builder methods. Auto-registration is performed through a built-in RuntimeWiringConfigurer that can be obtained from QuerydslDataFetcher . The Boot Starter(boot-starter.html) automatically detects @GraphQlRepository beans and uses them to initialize the RuntimeWiringConfigurer with. Auto-registration applies customizations(#data.querybyexample.customizations) by calling customize(Builder) on the repository instance if your repository implements QuerydslBuilderCustomizer or ReactiveQuerydslBuilderCustomizer respectively. Query by Example: Spring Data supports the use of Query by Example(https://docs.spring.io/spring-data/commons/docs/current/reference/html/#query-by-example) to fetch data. Query by Example (QBE) is a simple querying technique that does not require you to write queries through store-specific query languages. Start by declaring a repository that is QueryByExampleExecutor : public interface AccountRepository extends Repository<Account, Long>, QueryByExampleExecutor<Account> { } Use QueryByExampleDataFetcher to turn the repository into a DataFetcher : // For single result queries DataFetcher<Account> dataFetcher = QueryByExampleDataFetcher.builder(repository).single(); // For multi-result queries DataFetcher<Iterable<Account>> dataFetcher = QueryByExampleDataFetcher.builder(repository).many(); // For paginated queries DataFetcher<Iterable<Account>> dataFetcher = QueryByExampleDataFetcher.builder(repository).scrollable(); You can now register the above DataFetcher through a RuntimeWiringConfigurer(request-execution.html#execution.graphqlsource.runtimewiring-configurer) . The DataFetcher uses the GraphQL arguments map to create the domain type of the repository and use that as the example object to fetch data with. Spring Data supports QueryByExampleDataFetcher for JPA, MongoDB, Neo4j, and Redis. For a single argument that is a GraphQL input type, QueryByExampleDataFetcher nests one level down, and binds with the values from the argument sub-map. If the repository is ReactiveQueryByExampleExecutor , the builder returns DataFetcher<Mono<Account>> or DataFetcher<Flux<Account>> . Spring Data supports this variant for MongoDB, Neo4j, Redis, and R2dbc. Build Setup: Query by Example is already included in the Spring Data modules for the data stores where it is supported, so no extra setup is required to enable it. Customizations: QueryByExampleDataFetcher supports interface and DTO projections to transform query results before returning these for further GraphQL processing. To learn what projections are, please refer to the Spring Data documentation(https://docs.spring.io/spring-data/commons/docs/current/reference/html/#projections) . To understand the role of projections in GraphQL, please see Selection Set vs Projections(#data.projections) . To use Spring Data projections with Query by Example repositories, create either a projection interface or a target DTO class and configure it through the projectAs method to obtain a DataFetcher producing the target type: class Account { String name, identifier, description; Person owner; } interface AccountProjection { String getName(); String getIdentifier(); } // For single result queries DataFetcher<AccountProjection> dataFetcher = QueryByExampleDataFetcher.builder(repository).projectAs(AccountProjection.class).single(); // For multi-result queries DataFetcher<Iterable<AccountProjection>> dataFetcher = QueryByExampleDataFetcher.builder(repository).projectAs(AccountProjection.class).many(); Auto-Registration: If a repository is annotated with @GraphQlRepository , it is automatically registered for queries that do not already have a registered DataFetcher and whose return type matches that of the repository domain type. This includes single value queries, multi-value queries, and paginated(request-execution.html#execution.pagination) queries. By default, the name of the GraphQL type returned by the query must match the simple name of the repository domain type. If needed, you can use the typeName attribute of @GraphQlRepository to specify the target GraphQL type name. For paginated queries, the simple name of the repository domain type must match the Connection type name without the Connection ending (e.g. Book matches Books Connection ). For auto-registration, pagination is offset-based with 20 items per page. Auto-registration is performed through a built-in RuntimeWiringConfigurer that can be obtained from QueryByExampleDataFetcher . The Boot Starter(boot-starter.html) automatically detects @GraphQlRepository beans and uses them to initialize the RuntimeWiringConfigurer with. Auto-registration applies customizations(#data.querybyexample.customizations) by calling customize(Builder) on the repository instance if your repository implements QueryByExampleBuilderCustomizer or ReactiveQueryByExampleBuilderCustomizer respectively. Selection Set vs Projections: A common question that arises is, how GraphQL selection sets compare to Spring Data projections(https://docs.spring.io/spring-data/commons/docs/current/reference/html/#projections) and what role does each play? The short answer is that Spring for GraphQL is not a data gateway that translates GraphQL queries directly into SQL or JSON queries. Instead, it lets you leverage existing Spring technology and does not assume a one for one mapping between the GraphQL schema and the underlying data model. That is why client-driven selection and server-side transformation of the data model can play complementary roles. To better understand, consider that Spring Data promotes domain-driven (DDD) design as the recommended approach to manage complexity in the data layer. In DDD, it is important to adhere to the constraints of an aggregate. By definition an aggregate is valid only if loaded in its entirety, since a partially loaded aggregate may impose limitations on aggregate functionality. In Spring Data you can choose whether you want your aggregate be exposed as is, or whether to apply transformations to the data model before returning it as a GraphQL result. Sometimes it’s enough to do the former, and by default the Querydsl(#data.querydsl) and the Query by Example(#data.querybyexample) integrations turn the GraphQL selection set into property path hints that the underlying Spring Data module uses to limit the selection. In other cases, it’s useful to reduce or even transform the underlying data model in order to adapt to the GraphQL schema. Spring Data supports this through Interface and DTO Projections. Interface projections define a fixed set of properties to expose where properties may or may not be null , depending on the data store query result. There are two kinds of interface projections both of which determine what properties to load from the underlying data source: Closed interface projections(https://docs.spring.io/spring-data/commons/docs/current/reference/html/#projections.interfaces.closed) are helpful if you cannot partially materialize the aggregate object, but you still want to expose a subset of properties. Open interface projections(https://docs.spring.io/spring-data/commons/docs/current/reference/html/#projections.interfaces.open) leverage Spring’s @Value annotation and SpEL(https://docs.spring.io/spring-framework/reference/core/expressions.html) expressions to apply lightweight data transformations, such as concatenations, computations, or applying static functions to a property. DTO projections offer a higher level of customization as you can place transformation code either in the constructor or in getter methods. DTO projections materialize from a query where the individual properties are determined by the projection itself. DTO projections are commonly used with full-args constructors (e.g. Java records), and therefore they can only be constructed if all required fields (or columns) are part of the database query result. Scroll: As explained in Pagination(request-execution.html#execution.pagination) , the GraphQL Cursor Connection spec defines a mechanism for pagination with Connection , Edge , and PageInfo schema types, while GraphQL Java provides the equivalent Java type representations. Spring for GraphQL provides built-in ConnectionAdapter implementations to adapt the Spring Data pagination types Window and Slice transparently. You can configure that as follows: CursorStrategy<ScrollPosition> strategy = CursorStrategy.withEncoder( new ScrollPositionCursorStrategy(), CursorEncoder.base64()); (1) GraphQLTypeVisitor visitor = ConnectionFieldTypeVisitor.create(List.of( new WindowConnectionAdapter(strategy), new SliceConnectionAdapter(strategy))); (2) GraphQlSource.schemaResourceBuilder() .schemaResources(..) .typeDefinitionConfigurer(..) .typeVisitors(List.of(visitor)); (3) 1 Create strategy to convert ScrollPosition to a Base64 encoded cursor. 2 Create type visitor to adapt Window and Slice returned from DataFetcher s. 3 Register the type visitor. On the request side, a controller method can declare a ScrollSubrange(controllers.html#controllers.schema-mapping.subrange) method argument to paginate forward or backward. For this to work, you must declare a CursorStrategy(request-execution.html#execution.pagination.cursor.strategy) supports ScrollPosition as a bean. The Boot Starter(boot-starter.html) declares a CursorStrategy<ScrollPosition> bean, and registers the ConnectionFieldTypeVisitor as shown above if Spring Data is on the classpath. Keyset Position: For KeysetScrollPosition , the cursor needs to be created from a keyset, which is essentially a Map of key-value pairs. To decide how to create a cursor from a keyset, you can configure ScrollPositionCursorStrategy with CursorStrategy<Map<String, Object>> . By default, JsonKeysetCursorStrategy writes the keyset Map to JSON. That works for simple like String, Boolean, Integer, and Double, but others cannot be restored back to the same type without target type information. The Jackson library has a default typing feature that can include type information in the JSON. To use it safely you must specify a list of allowed types. For example: PolymorphicTypeValidator validator = BasicPolymorphicTypeValidator.builder() .allowIfBaseType(Map.class) .allowIfSubType(ZonedDateTime.class) .build(); ObjectMapper mapper = new ObjectMapper(); mapper.activateDefaultTyping(validator, ObjectMapper.DefaultTyping.NON_FINAL); You can then create JsonKeysetCursorStrategy : ObjectMapper mapper = ... ; CodecConfigurer configurer = ServerCodecConfigurer.create(); configurer.defaultCodecs().jackson2JsonDecoder(new Jackson2JsonDecoder(mapper)); configurer.defaultCodecs().jackson2JsonEncoder(new Jackson2JsonEncoder(mapper)); JsonKeysetCursorStrategy strategy = new JsonKeysetCursorStrategy(configurer); By default, if JsonKeysetCursorStrategy is created without a CodecConfigurer and the Jackson library is on the classpath, customizations like the above are applied for Date , Calendar , and any type from java.time . Sort: Spring for GraphQL defines a SortStrategy to create Sort from GraphQL arguments. AbstractSortStrategy implements the contract with abstract methods to extract the sort direction and properties. To enable support for Sort as a controller method argument, you need to declare a SortStrategy bean."
"https://docs.spring.io/spring-graphql/reference/controllers.html","Annotated Controllers: Spring for GraphQL provides an annotation-based programming model where @Controller components use annotations to declare handler methods with flexible method signatures to fetch the data for specific GraphQL fields. For example: @Controller public class GreetingController { @QueryMapping (1) public String hello() { (2) return ""Hello, world!""; } } 1 Bind this method to a query, i.e. a field under the Query type. 2 Determine the query from the method name if not declared on the annotation. Spring for GraphQL uses RuntimeWiring.Builder to register the above handler method as a graphql.schema.DataFetcher for the query named ""hello"". Declaration: You can define @Controller beans as standard Spring bean definitions. The @Controller stereotype allows for auto-detection, aligned with Spring general support for detecting @Controller and @Component classes on the classpath and auto-registering bean definitions for them. It also acts as a stereotype for the annotated class, indicating its role as a data fetching component in a GraphQL application. AnnotatedControllerConfigurer detects @Controller beans and registers their annotated handler methods as DataFetcher s via RuntimeWiring.Builder . It is an implementation of RuntimeWiringConfigurer which can be added to GraphQlSource.Builder . The Boot Starter(boot-starter.html) automatically declares AnnotatedControllerConfigurer as a bean and adds all RuntimeWiringConfigurer beans to GraphQlSource.Builder and that enables support for annotated DataFetcher s, see the GraphQL RuntimeWiring(https://docs.spring.io/spring-boot/3.3.0/reference/web/spring-graphql.html#web.graphql.runtimewiring) section in the Boot starter documentation. @SchemaMapping: The @SchemaMapping annotation maps a handler method to a field in the GraphQL schema and declares it to be the DataFetcher for that field. The annotation can specify the parent type name, and the field name: @Controller public class BookController { @SchemaMapping(typeName=""Book"", field=""author"") public Author getAuthor(Book book) { // ... } } The @SchemaMapping annotation can also leave out those attributes, in which case the field name defaults to the method name, while the type name defaults to the simple class name of the source/parent object injected into the method. For example, the below defaults to type ""Book"" and field ""author"": @Controller public class BookController { @SchemaMapping public Author author(Book book) { // ... } } The @SchemaMapping annotation can be declared at the class level to specify a default type name for all handler methods in the class. @Controller @SchemaMapping(typeName=""Book"") public class BookController { // @SchemaMapping methods for fields of the ""Book"" type } @QueryMapping , @MutationMapping , and @SubscriptionMapping are meta annotations that are themselves annotated with @SchemaMapping and have the typeName preset to Query , Mutation , or Subscription respectively. Effectively, these are shortcut annotations for fields under the Query, Mutation, and Subscription types respectively. For example: @Controller public class BookController { @QueryMapping public Book bookById(@Argument Long id) { // ... } @MutationMapping public Book addBook(@Argument BookInput bookInput) { // ... } @SubscriptionMapping public Flux<Book> newPublications() { // ... } } @SchemaMapping handler methods have flexible signatures and can choose from a range of method arguments and return values.. Method Arguments: Schema mapping handler methods can have any of the following method arguments: Method Argument Description @Argument For access to a named field argument bound to a higher-level, typed Object. See @Argument(#controllers.schema-mapping.argument) . @Argument Map<String, Object> For access to the raw argument value. See @Argument(#controllers.schema-mapping.argument) . ArgumentValue For access to a named field argument bound to a higher-level, typed Object along with a flag to indicate if the input argument was omitted vs set to null . See ArgumentValue(#controllers.schema-mapping.argument-value) . @Arguments For access to all field arguments bound to a higher-level, typed Object. See @Arguments(#controllers.schema-mapping.arguments) . @Arguments Map<String, Object> For access to the raw map of arguments. @ProjectedPayload Interface For access to field arguments through a project interface. See @ProjectedPayload Interface(#controllers.schema-mapping.projectedpayload.argument) . ""Source"" For access to the source (i.e. parent/container) instance of the field. See Source(#controllers.schema-mapping.source) . Subrange and ScrollSubrange For access to pagination arguments. See Pagination(request-execution.html#execution.pagination) , Scroll(data.html#data.pagination.scroll) , Subrange(#controllers.schema-mapping.subrange) . Sort For access to sort details. See Pagination(request-execution.html#execution.pagination) , Sort(#controllers.schema-mapping.sort) . DataLoader For access to a DataLoader in the DataLoaderRegistry . See DataLoader(#controllers.schema-mapping.data-loader) . @ContextValue For access to an attribute from the main GraphQLContext in DataFetchingEnvironment . @LocalContextValue For access to an attribute from the local GraphQLContext in DataFetchingEnvironment . GraphQLContext For access to the context from the DataFetchingEnvironment . java.security.Principal Obtained from the Spring Security context, if available. @AuthenticationPrincipal For access to Authentication#getPrincipal() from the Spring Security context. DataFetchingFieldSelectionSet For access to the selection set for the query through the DataFetchingEnvironment . Locale , Optional<Locale> For access to the Locale from the DataFetchingEnvironment . DataFetchingEnvironment For direct access to the underlying DataFetchingEnvironment . Return Values: Schema mapping handler methods can return: A resolved value of any type. Mono and Flux for asynchronous value(s). Supported for controller methods and for any DataFetcher as described in Reactive DataFetcher(request-execution.html#execution.reactive-datafetcher) . Kotlin coroutine and Flow are adapted to Mono and Flux . java.util.concurrent.Callable to have the value(s) produced asynchronously. For this to work, AnnotatedControllerConfigurer must be configured with an Executor . On Java 21+, when AnnotatedControllerConfigurer is configured with an Executor , controller methods with a blocking method signature are invoked asynchronously. By default, a controller method is considered blocking if it does not return an async type such as Flux , Mono , CompletableFuture , and is also not a Kotlin suspending function. You can configure a blocking controller method Predicate on AnnotatedControllerConfigurer to help determine which methods are considered blocking. The Spring Boot starter for Spring for GraphQL automatically configures AnnotatedControllerConfigurer with an Executor for virtual threads when the property spring.threads.virtual.enabled is set. Interface Schema Mappings: When a controller method is mapped to a schema interface field, by default the mapping is replaced with multiple mappings, one for each schema object type that implements the interface. This allows use of one controller method for all subtypes. For example, given: type Query { activities: [Activity!]! } interface Activity { id: ID! coordinator: User! } type FooActivity implements Activity { id: ID! coordinator: User! } type BarActivity implements Activity { id: ID! coordinator: User! } type User { name: String! } You can write a controller like this: @Controller public class BookController { @QueryMapping public List<Activity> activities() { // ... } @SchemaMapping public User coordinator(Activity activity) { // Called for any Activity subtype } } If necessary, you can take over the mapping for individual subtypes: @Controller public class BookController { @QueryMapping public List<Activity> activities() { // ... } @SchemaMapping public User coordinator(Activity activity) { // Called for any Activity subtype except FooActivity } @SchemaMapping public User coordinator(FooActivity activity) { // ... } } @Argument: In GraphQL Java, DataFetchingEnvironment provides access to a map of field-specific argument values. The values can be simple scalar values (e.g. String, Long), a Map of values for more complex input, or a List of values. Use the @Argument annotation to have an argument bound to a target object and injected into the handler method. Binding is performed by mapping argument values to a primary data constructor of the expected method parameter type, or by using a default constructor to create the object and then map argument values to its properties. This is repeated recursively, using all nested argument values and creating nested target objects accordingly. For example: @Controller public class BookController { @QueryMapping public Book bookById(@Argument Long id) { // ... } @MutationMapping public Book addBook(@Argument BookInput bookInput) { // ... } } If the target object doesn’t have setters, and you can’t change that, you can use a property on AnnotatedControllerConfigurer to allow falling back on binding via direct field access. By default, if the method parameter name is available (requires the -parameters compiler flag with Java 8+ or debugging info from the compiler), it is used to look up the argument. If needed, you can customize the name through the annotation, e.g. @Argument(""bookInput"") . The @Argument annotation does not have a ""required"" flag, nor the option to specify a default value. Both of these can be specified at the GraphQL schema level and are enforced by GraphQL Java. If binding fails, a BindException is raised with binding issues accumulated as field errors where the field of each error is the argument path where the issue occurred. You can use @Argument with a Map<String, Object> argument, to obtain the raw value of the argument. For example: @Controller public class BookController { @MutationMapping public Book addBook(@Argument Map<String, Object> bookInput) { // ... } } Prior to 1.2, @Argument Map<String, Object> returned the full arguments map if the annotation did not specify a name. After 1.2, @Argument with Map<String, Object> always returns the raw argument value, matching either to the name specified in the annotation, or to the parameter name. For access to the full arguments map, please use @Arguments(#controllers.schema-mapping.arguments) instead. ArgumentValue: By default, input arguments in GraphQL are nullable and optional, which means an argument can be set to the null literal, or not provided at all. This distinction is useful for partial updates with a mutation where the underlying data may also be, either set to null or not changed at all accordingly. When using @Argument(#controllers.schema-mapping.argument) there is no way to make such a distinction, because you would get null or an empty Optional in both cases. If you want to know not whether a value was not provided at all, you can declare an ArgumentValue method parameter, which is a simple container for the resulting value, along with a flag to indicate whether the input argument was omitted altogether. You can use this instead of @Argument , in which case the argument name is determined from the method parameter name, or together with @Argument to specify the argument name. For example: @Controller public class BookController { @MutationMapping public void addBook(ArgumentValue<BookInput> bookInput) { if (!bookInput.isOmitted()) { BookInput value = bookInput.value(); // ... } } } ArgumentValue is also supported as a field within the object structure of an @Argument method parameter, either initialized via a constructor argument or via a setter, including as a field of an object nested at any level below the top level object. @Arguments: Use the @Arguments annotation, if you want to bind the full arguments map onto a single target Object, in contrast to @Argument , which binds a specific, named argument. For example, @Argument BookInput bookInput uses the value of the argument ""bookInput"" to initialize BookInput , while @Arguments uses the full arguments map and in that case, top-level arguments are bound to BookInput properties. You can use @Arguments with a Map<String, Object> argument, to obtain the raw map of all argument values. @ProjectedPayload Interface: As an alternative to using complete Objects with @Argument(#controllers.schema-mapping.argument) , you can also use a projection interface to access GraphQL request arguments through a well-defined, minimal interface. Argument projections are provided by Spring Data’s Interface projections(https://docs.spring.io/spring-data/commons/docs/current/reference/html/#projections.interfaces) when Spring Data is on the class path. To make use of this, create an interface annotated with @ProjectedPayload and declare it as a controller method parameter. If the parameter is annotated with @Argument , it applies to an individual argument within the DataFetchingEnvironment.getArguments() map. When declared without @Argument , the projection works on top-level arguments in the complete arguments map. For example: @Controller public class BookController { @QueryMapping public Book bookById(BookIdProjection bookId) { // ... } @MutationMapping public Book addBook(@Argument BookInputProjection bookInput) { // ... } } @ProjectedPayload interface BookIdProjection { Long getId(); } @ProjectedPayload interface BookInputProjection { String getName(); @Value(""#{target.author + ' ' + target.name}"") String getAuthorAndName(); } Source: In GraphQL Java, the DataFetchingEnvironment provides access to the source (i.e. parent/container) instance of the field. To access this, simply declare a method parameter of the expected target type. @Controller public class BookController { @SchemaMapping public Author author(Book book) { // ... } } The source method argument also helps to determine the type name for the mapping. If the simple name of the Java class matches the GraphQL type, then there is no need to explicitly specify the type name in the @SchemaMapping annotation. A @BatchMapping(#controllers.batch-mapping) handler method can batch load all authors for a query, given a list of source/parent books objects. Subrange: When there is a CursorStrategy(request-execution.html#execution.pagination.cursor.strategy) bean in Spring configuration, controller methods support a Subrange<P> argument where <P> is a relative position converted from a cursor. For Spring Data, ScrollSubrange exposes ScrollPosition . For example: @Controller public class BookController { @QueryMapping public Window<Book> books(ScrollSubrange subrange) { ScrollPosition position = subrange.position().orElse(ScrollPosition.offset()); int count = subrange.count().orElse(20); // ... } } See Pagination(request-execution.html#execution.pagination) for an overview of pagination and of built-in mechanisms. Sort: When there is a SortStrategy(data.html#data.pagination.scroll) bean in Spring configuration, controller methods support Sort as a method argument. For example: @Controller public class BookController { @QueryMapping public Window<Book> books(Optional<Sort> optionalSort) { Sort sort = optionalSort.orElse(Sort.by(..)); } } DataLoader: When you register a batch loading function for an entity, as explained in Batch Loading(request-execution.html#execution.batching) , you can access the DataLoader for the entity by declaring a method argument of type DataLoader and use it to load the entity: @Controller public class BookController { public BookController(BatchLoaderRegistry registry) { registry.forTypePair(Long.class, Author.class).registerMappedBatchLoader((authorIds, env) -> { // return Map<Long, Author> }); } @SchemaMapping public CompletableFuture<Author> author(Book book, DataLoader<Long, Author> loader) { return loader.load(book.getAuthorId()); } } By default, BatchLoaderRegistry uses the full class name of the value type (e.g. the class name for Author ) for the key of the registration, and therefore simply declaring the DataLoader method argument with generic types provides enough information to locate it in the DataLoaderRegistry . As a fallback, the DataLoader method argument resolver will also try the method argument name as the key but typically that should not be necessary. Note that for many cases with loading related entities, where the @SchemaMapping simply delegates to a DataLoader , you can reduce boilerplate by using a @BatchMapping(#controllers.batch-mapping) method as described in the next section. Validation: When a javax.validation.Validator bean is found, AnnotatedControllerConfigurer enables support for Bean Validation(https://docs.spring.io/spring-framework/reference/core/validation/beanvalidation.html#validation-beanvalidation-overview) on annotated controller methods. Typically, the bean is of type LocalValidatorFactoryBean . Bean validation lets you declare constraints on types: public class BookInput { @NotNull private String title; @NotNull @Size(max=13) private String isbn; } You can then annotate a controller method parameter with @Valid to validate it before method invocation: @Controller public class BookController { @MutationMapping public Book addBook(@Argument @Valid BookInput bookInput) { // ... } } If an error occurs during validation, a ConstraintViolationException is raised. You can use the Exceptions(request-execution.html#execution.exceptions) chain to decide how to present that to clients by turning it into an error to include in the GraphQL response. In addition to @Valid , you can also use Spring’s @Validated that allows specifying validation groups. Bean validation is useful for @Argument(#controllers.schema-mapping.argument) , @Arguments(#controllers.schema-mapping.arguments) , and @ProjectedPayload(#controllers.schema-mapping.projectedpayload.argument) method parameters, but applies more generally to any method parameter. Validation and Kotlin Coroutines Hibernate Validator is not compatible with Kotlin Coroutine methods and fails when introspecting their method parameters. Please see spring-projects/spring-graphql#344 (comment)(https://github.com/spring-projects/spring-graphql/issues/344#issuecomment-1082814093) for links to relevant issues and a suggested workaround. @BatchMapping: Batch Loading(request-execution.html#execution.batching) addresses the N+1 select problem through the use of an org.dataloader.DataLoader to defer the loading of individual entity instances, so they can be loaded together. For example: @Controller public class BookController { public BookController(BatchLoaderRegistry registry) { registry.forTypePair(Long.class, Author.class).registerMappedBatchLoader((authorIds, env) -> { // return Map<Long, Author> }); } @SchemaMapping public CompletableFuture<Author> author(Book book, DataLoader<Long, Author> loader) { return loader.load(book.getAuthorId()); } } For the straight-forward case of loading an associated entity, shown above, the @SchemaMapping method does nothing more than delegate to the DataLoader . This is boilerplate that can be avoided with a @BatchMapping method. For example: @Controller public class BookController { @BatchMapping public Mono<Map<Book, Author>> author(List<Book> books) { // ... } } The above becomes a batch loading function in the BatchLoaderRegistry where keys are Book instances and the loaded values their authors. In addition, a DataFetcher is also transparently bound to the author field of the type Book , which simply delegates to the DataLoader for authors, given its source/parent Book instance. To be used as a unique key, Book must implement hashcode and equals . By default, the field name defaults to the method name, while the type name defaults to the simple class name of the input List element type. Both can be customized through annotation attributes. The type name can also be inherited from a class level @SchemaMapping . Method Arguments: Batch mapping methods support the following arguments: Method Argument Description List<K> The source/parent objects. java.security.Principal Obtained from Spring Security context, if available. @ContextValue For access to a value from the GraphQLContext of BatchLoaderEnvironment , which is the same context as the one from the DataFetchingEnvironment . GraphQLContext For access to the context from the BatchLoaderEnvironment , which is the same context as the one from the DataFetchingEnvironment . BatchLoaderEnvironment The environment that is available in GraphQL Java to a org.dataloader.BatchLoaderWithContext . Return Values: Batch mapping methods can return: Return Type Description Mono<Map<K,V>> A map with parent objects as keys, and batch loaded objects as values. Flux<V> A sequence of batch loaded objects that must be in the same order as the source/parent objects passed into the method. Map<K,V> , Collection<V> Imperative variants, e.g. without remote calls to make. Callable<Map<K,V>> , Callable<Collection<V>> Imperative variants to be invoked asynchronously. For this to work, AnnotatedControllerConfigurer must be configured with an Executor . Kotlin Coroutine with Map<K,V> , Kotlin Flow<K,V> Adapted to Mono<Map<K,V> and Flux<V> . On Java 21+, when AnnotatedControllerConfigurer is configured with an Executor , controller methods with a blocking method signature are invoked asynchronously. By default, a controller method is considered blocking if it does not return an async type such as Flux , Mono , CompletableFuture , and is also not a Kotlin suspending function. You can configure a blocking controller method Predicate on AnnotatedControllerConfigurer to help determine which methods are considered blocking. The Spring Boot starter for Spring for GraphQL automatically configures AnnotatedControllerConfigurer with an Executor for virtual threads when the property spring.threads.virtual.enabled is set. Interface Batch Mappings: As is the case with Interface Schema Mappings(#controllers.schema-mapping.interfaces) , when a batch mapping method is mapped to a schema interface field, the mapping is replaced with multiple mappings, one for each schema object type that implements the interface. That means, given the following: type Query { activities: [Activity!]! } interface Activity { id: ID! coordinator: User! } type FooActivity implements Activity { id: ID! coordinator: User! } type BarActivity implements Activity { id: ID! coordinator: User! } type User { name: String! } You can write a controller like this: @Controller public class BookController { @QueryMapping public List<Activity> activities() { // ... } @BatchMapping Map<Activity, User> coordinator(List<Activity> activities) { // Called for all Activity subtypes } } If necessary, you can take over the mapping for individual subtypes: @Controller public class BookController { @QueryMapping public List<Activity> activities() { // ... } @BatchMapping Map<Activity, User> coordinator(List<Activity> activities) { // Called for all Activity subtypes } @BatchMapping(field = ""coordinator"") Map<Activity, User> fooCoordinator(List<FooActivity> activities) { // ... } } @GraphQlExceptionHandler: Use @GraphQlExceptionHandler methods to handle exceptions from data fetching with a flexible method signature(#controllers.exception-handler.signature) . When declared in a controller, exception handler methods apply to exceptions from the same controller: @Controller public class BookController { @QueryMapping public Book bookById(@Argument Long id) { // ... } @GraphQlExceptionHandler public GraphQLError handle(BindException ex) { return GraphQLError.newError().errorType(ErrorType.BAD_REQUEST).message(""..."").build(); } } When declared in an @ControllerAdvice , exception handler methods apply across controllers: @ControllerAdvice public class GlobalExceptionHandler { @GraphQlExceptionHandler public GraphQLError handle(BindException ex) { return GraphQLError.newError().errorType(ErrorType.BAD_REQUEST).message(""..."").build(); } } Exception handling via @GraphQlExceptionHandler methods is applied automatically to controller invocations. To handle exceptions from other graphql.schema.DataFetcher implementations, not based on controller methods, obtain a DataFetcherExceptionResolver from AnnotatedControllerConfigurer , and register it in GraphQlSource.Builder as a DataFetcherExceptionResolver(request-execution.html#execution.exceptions) . Method Signature: Exception handler methods support a flexible method signature with method arguments resolved from a DataFetchingEnvironment, and matching to those of @SchemaMapping methods(#controllers.schema-mapping.arguments) . Supported return types are listed below: Return Type Description graphql.GraphQLError Resolve the exception to a single field error. Collection<GraphQLError> Resolve the exception to multiple field errors. void Resolve the exception without response errors. Object Resolve the exception to a single error, to multiple errors, or none. The return value must be GraphQLError , Collection<GraphQLError> , or null . Mono<T> For asynchronous resolution where <T> is one of the supported, synchronous, return types. Namespacing: At the schema level, query and mutation operations are defined directly under the Query and Mutation types. Rich GraphQL APIs can define dozens of operation sunder those types, making it harder to explore the API and separate concerns. You can choose to define Namespaces in your GraphQL schema(https://www.apollographql.com/docs/technotes/TN0012-namespacing-by-separation-of-concern/) . While there are some caveats with this approach, you can implement this pattern with Spring for GraphQL annotated controllers. With namespacing, your GraphQL schema can, for example, nest query operations under top-level types, instead of listing them directly under Query . Here, we will define MusicQueries and UserQueries types and make them available under Query : type Query { music: MusicQueries users: UserQueries } type MusicQueries { album(id: ID!): Album searchForArtist(name: String!): [Artist] } type Album { id: ID! title: String! } type Artist { id: ID! name: String! } type UserQueries { user(login: String): User } type User { id: ID! login: String! } A GraphQL client would use the album query like this: { music { album(id: 42) { id title } } } And get the following response: { ""data"": { ""music"": { ""album"": { ""id"": ""42"", ""title"": ""Spring for GraphQL"" } } } } This can be implemented in a @Controller with the following pattern: import java.util.List; import org.springframework.graphql.data.method.annotation.Argument; import org.springframework.graphql.data.method.annotation.QueryMapping; import org.springframework.graphql.data.method.annotation.SchemaMapping; import org.springframework.stereotype.Controller; @Controller @SchemaMapping(typeName = ""MusicQueries"") (1) public class MusicController { @QueryMapping (2) public MusicQueries music() { return new MusicQueries(); } (3) public record MusicQueries() { } @SchemaMapping (4) public Album album(@Argument String id) { return new Album(id, ""Spring GraphQL""); } @SchemaMapping public List<Artist> searchForArtist(@Argument String name) { return List.of(new Artist(""100"", ""the Spring team"")); } } 1 Annotate the controller with @SchemaMapping and a typeName attribute, to avoid repeating it on methods 2 Define a @QueryMapping for the ""music"" namespace 3 The ""music"" query returns an ""empty"" record, but could also return an empty map 4 Queries are now declared as fields under the ""MusicQueries"" type Instead of declaring wrapping types (""MusicQueries"", ""UserQueries"") explicitly in controllers, you can choose to configure them with the runtime wiring using a GraphQlSourceBuilderCustomizer with Spring Boot: import java.util.Collections; import java.util.List; import org.springframework.boot.autoconfigure.graphql.GraphQlSourceBuilderCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class NamespaceConfiguration { @Bean public GraphQlSourceBuilderCustomizer customizer() { List<String> queryWrappers = List.of(""music"", ""users""); (1) return (sourceBuilder) -> sourceBuilder.configureRuntimeWiring((wiringBuilder) -> queryWrappers.forEach((field) -> wiringBuilder.type(""Query"", (builder) -> builder.dataFetcher(field, (env) -> Collections.emptyMap()))) (2) ); } } 1 List all the wrapper types for the ""Query"" type 2 Manually declare data fetchers for each of them, returning an empty Map"
"https://docs.spring.io/spring-graphql/reference/security.html","Security: The path to a Web(transports.html#server.transports.http) GraphQL endpoint can be secured with HTTP URL security to ensure that only authenticated users can access it. This does not, however, differentiate among different GraphQL requests on such a shared endpoint on a single URL. To apply more fine-grained security, add Spring Security annotations such as @PreAuthorize or @Secured to service methods involved in fetching specific parts of the GraphQL response. This should work due to Context Propagation(request-execution.html#execution.context) that aims to make Security, and other context, available at the data fetching level. The 1.0.x branch of this repository contains samples for Spring MVC(https://github.com/spring-projects/spring-graphql/tree/1.0.x/samples/webmvc-http-security) and for WebFlux(https://github.com/spring-projects/spring-graphql/tree/1.0.x/samples/webflux-security) ."
"https://docs.spring.io/spring-graphql/reference/observability.html","Observability: Observability support with Micrometer(https://docs.micrometer.io/micrometer/reference/observation.html) is directly instrumented in Spring for GraphQL. This enables both metrics and traces for GraphQL requests and ""non-trivial"" data fetching operations. Because the GraphQL engine operates on top of a transport layer, you should also expect observations from the transport(https://docs.spring.io/spring-framework/reference/integration/observability.html) , if supported in Spring Framework. Observations are only published if an ObservationRegistry is configured in the application. You can learn more about configuring the observability infrastructure in Spring Boot(https://docs.spring.io/spring-boot/3.3.0/reference/actuator/metrics.html) . If you would like to customize the metadata produced with the GraphQL observations, you can configure a custom convention on the instrumentation directly(https://docs.spring.io/spring-framework/reference/integration/observability.html#observability.config.conventions) . If your application is using Spring Boot, contributing the custom convention as a bean is the preferred way. Server Requests instrumentation: GraphQL Server Requests observations are created with the name ""graphql.request"" for traditional and Reactive applications and above all supported transports. This instrumentation assumes that any parent observation must be set as the current one on the GraphQL context with the well-known ""micrometer.observation"" key. For trace propagation across network boundaries, a separate instrumentation at the transport level must be in charge. In the case of HTTP, Spring Framework has dedicated instrumentation that takes care of trace propagation(https://docs.spring.io/spring-framework/reference/integration/observability.html#observability.http-server) . Applications need to configure the org.springframework.graphql.observation.GraphQlObservationInstrumentation instrumentation in their application. It is using the org.springframework.graphql.observation.DefaultExecutionRequestObservationConvention by default, backed by the ExecutionRequestObservationContext . By default, the following KeyValues are created: Table 1. Low cardinality Keys Name Description graphql.operation (required) GraphQL Operation name. graphql.outcome (required) Outcome of the GraphQL request. The graphql.operation KeyValue will use the custom name of the provided query, or the standard name for the operation(http://spec.graphql.org/draft/#sec-Language.Operations) if none ( ""query"" , ""mutation"" or ""subscription"" ). The graphql.outcome KeyValue will be ""SUCCESS"" if a valid GraphQL response has been sent, ""REQUEST_ERROR"" if the request could not be parsed, or ""INTERNAL_ERROR"" if no valid GraphQL response could be produced. Table 2. High cardinality Keys Name Description graphql.execution.id (required) graphql.execution.ExecutionId of the GraphQL request. Spring for GraphQL also contributes Events for Server Request Observations. Micrometer Observation Events(https://docs.micrometer.io/micrometer/reference/observation/components.html#micrometer-observation-events) are usually handled as span annotations in traces. This instrumentation records errors listed in the GraphQL response as events. Table 3. Observation Events Name Contextual Name the GraphQL error type, e.g. InvalidSyntax the full GraphQL error message, e.g. ""Invalid syntax with offending token 'invalid'…​"" DataFetcher instrumentation: GraphQL DataFetcher observations are created with the name ""graphql.datafetcher"" , only for data fetching operations that are considered as ""non trivial"" (property fetching on a Java object is a trivial operation). Applications need to configure the org.springframework.graphql.observation.GraphQlObservationInstrumentation instrumentation in their application. It is using the org.springframework.graphql.observation.DefaultDataFetcherObservationConvention by default, backed by the DataFetcherObservationContext . By default, the following KeyValues are created: Table 4. Low cardinality Keys Name Description graphql.error.type (required) Class name of the data fetching error graphql.field.name (required) Name of the field being fetched. graphql.outcome (required) Outcome of the GraphQL data fetching operation, ""SUCCESS"" or ""ERROR"". Table 5. High cardinality Keys Name Description graphql.field.path (required) Path to the field being fetched (for example, ""/bookById"")."
"https://docs.spring.io/spring-graphql/reference/graalvm-native.html","GraalVM Native support: Spring Framework 6.0 introduced the support infrastructure for compiling Spring applications to GraalVM Native images(https://www.graalvm.org/22.3/reference-manual/native-image/) . If you are not familiar with GraalVM in general, how this differs from applications deployed on the JVM and what it means for Spring application, please refer to the dedicated Spring Boot 3.x GraalVM Native Image support documentation(https://docs.spring.io/spring-boot/3.3.0/reference/native-image/introducing-graalvm-native-images.html) . Spring Boot also documents the know limitations with the GraalVM support in Spring(https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-with-GraalVM) . GraphQL Java metadata: Since the static analysis of your application is done at build time(https://docs.spring.io/spring-boot/3.3.0/reference/native-image/introducing-graalvm-native-images.html#native-image.introducing-graalvm-native-images.key-differences-with-jvm-deployments) , GraalVM might need extra hints if your application is looking up static resources, performing reflection or creating JDK proxies at runtime. GraphQL Java is performing three tasks at runtime that Native Images are sensible to: Loading resource bundles for message internationalization Some reflection on internal types for schema inspection Reflection on Java types that your application registers with the schema. This happens for example when GraphQL Java is fetching properties from application types The first two items are handled via reachability metadata that has been contributed by the Spring team to the GraalVM reachability metadata repository(https://github.com/oracle/graalvm-reachability-metadata/tree/master/metadata/com.graphql-java/graphql-java) . This metadata is automatically fetched by the native compilation tool when building an application that depends on GraphQL Java. This doesn’t cover our third item in the list, as those types are provided by the application itself and must be discovered by another mean. Native Server applications support: In typical Spring for GraphQL applications, Java types tied to the GraphQL schema are exposed in @Controller method signatures as parameters or return types. During the Ahead Of Time processing phase(https://docs.spring.io/spring-framework/reference/core/aot.html) of the build, Spring or GraphQL will use its o.s.g.data.method.annotation.support.SchemaMappingBeanFactoryInitializationAotProcessor to discover the relevant types and register reachability metadata accordingly. This is all done automatically for you if you are building a Spring Boot application with GraalVM support. If your application is ""manually"" registering data fetchers, some types are not discoverable as a result. You should then register them with Spring Framework’s @RegisterReflectionForBinding : import graphql.schema.DataFetcher; import org.springframework.aot.hint.annotation.RegisterReflectionForBinding; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.graphql.data.query.QuerydslDataFetcher; import org.springframework.graphql.execution.RuntimeWiringConfigurer; @Configuration @RegisterReflectionForBinding(Book.class) (3) public class GraphQlConfiguration { @Bean RuntimeWiringConfigurer customWiringConfigurer(BookRepository bookRepository) { (1) DataFetcher<Book> dataFetcher = QuerydslDataFetcher.builder(bookRepository).single(); return (wiringBuilder) -> wiringBuilder .type(""Query"", (builder) -> builder.dataFetcher(""book"", dataFetcher)); (2) } } 1 This application declares a RuntimeWiringConfigurer that ""manually"" adds a DataFetcher 2 Through this DataFetcher , the BookRepository will expose a Book type 3 @RegisterReflectionForBinding will register the relevant hints for the Book type and all types exposed as fields Client support: The GraphQlClient is not necessarily present as a bean in the application context and it does not expose the Java types used in the schema in method signatures. The AotProcessor strategy described in the section above cannot be used as a result. For client support, Spring for GraphQL embeds the relevant reachability metadata for the client infrastructure(https://github.com/spring-projects/spring-graphql/tree/main/spring-graphql/src/main/resources/META-INF/native-image/org.springframework.graphql/spring-graphql) . When it comes to Java types used by the application, applications should use a similar strategy as ""manual"" data fetchers using @RegisterReflectionForBinding : import reactor.core.publisher.Mono; import org.springframework.aot.hint.annotation.RegisterReflectionForBinding; import org.springframework.graphql.client.GraphQlClient; import org.springframework.stereotype.Component; @Component @RegisterReflectionForBinding(Project.class) (2) public class ProjectService { private final GraphQlClient graphQlClient; public ProjectService(GraphQlClient graphQlClient) { this.graphQlClient = graphQlClient; } public Mono<Project> project(String projectSlug) { String document = """""" query projectWithReleases($projectSlug: ID!) { project(slug: $projectSlug) { name releases { version } } } """"""; return this.graphQlClient.document(document) .variable(""projectSlug"", projectSlug) .retrieve(""project"") .toEntity(Project.class); (1) } } 1 In a Native image, we need to ensure that reflection can be performed on Project at runtime 2 @RegisterReflectionForBinding will register the relevant hints for the Project type and all types exposed as fields"
"https://docs.spring.io/spring-graphql/reference/federation.html","Federation: Spring for GraphQL provides an integration for the federation-jvm(https://github.com/apollographql/federation-jvm) library, which uses GraphQL Java to initialize the schema of a sub-graph within a graph of federated services. See Apollo Federation(https://www.apollographql.com/docs/federation/) and the Subgraph specification(https://www.apollographql.com/docs/federation/subgraph-spec) for details. Config: To enable the integration, declare a FederationSchemaFactory bean in your config, and plug it into GraphQlSource.Builder . For example, with Spring Boot: @Configuration public class FederationConfig { @Bean public GraphQlSourceBuilderCustomizer customizer(FederationSchemaFactory factory) { return builder -> builder.schemaFactory(factory::createGraphQLSchema); } @Bean public FederationSchemaFactory schemaFactory() { return new FederationSchemaFactory(); } } Now the schema for the sub-graph service can extend federated types: type Book @key(fields: ""id"") @extends { id: ID! @external author: Author } type Author { id: ID firstName: String lastName: String } @EntityMapping: An @EntityMapping method can load federated type instances in response to an _entities query(https://www.apollographql.com/docs/federation/subgraph-spec/#understanding-query_entities) from the federation gateway. For example: For example: @Controller private static class BookController { @EntityMapping public Book book(@Argument int id) { (1) // ... } @SchemaMapping public Author author(Book book) { (2) // ... } } 1 The @Argument method parameter is resolved from the ""representation"" input map for the entity. The full ""representation"" input Map can also be resolved. See Method Signature(#federation.entity-mapping.signature) for supported method argument and return value types. 2 @SchemaMapping methods can be used for the rest of the graph. An @EntityMapping method can batch load federated entities of a given type. To do that, declare the @Argument method parameter as a list, and return the corresponding entity instances as a list in the same order. For example: @Controller private static class BookController { @EntityMapping public List<Book> book(@Argument List<Integer> idList) { (1) // ... return books in the same order } @BatchMapping public Map<Book, Author> author(List<Book> books) { (2) // ... } } 1 The idList naming convention helps to de-pluralize the parameter name in order to look up the correct value in the ""representation"" input map. You can also set the argument name through the annotation. 2 @BatchMapping methods can be used for the rest of the graph. Method Signature: Entity mapping methods support the following arguments: Method Argument Description @Argument For access to a named value from the ""representation"" input map, also converted to typed Object. Map<String, Object> The full ""representation"" input map for the entity. List<Map<String, Object>> The list of ""representation"" input maps when using a single controller method to load all entities of a given type. @ContextValue For access to an attribute from the main GraphQLContext in DataFetchingEnvironment . @LocalContextValue For access to an attribute from the local GraphQLContext in DataFetchingEnvironment . GraphQLContext For access to the context from the DataFetchingEnvironment . java.security.Principal Obtained from the Spring Security context, if available. @AuthenticationPrincipal For access to Authentication#getPrincipal() from the Spring Security context. DataFetchingFieldSelectionSet For access to the selection set for the query through the DataFetchingEnvironment . Locale , Optional<Locale> For access to the Locale from the DataFetchingEnvironment . DataFetchingEnvironment For direct access to the underlying DataFetchingEnvironment . @EntityMapping methods can return Mono , CompletableFuture , Callable , or the actual entity. Exception Handling: You can use @GraphQlExceptionHandler methods to map exceptions from @EntityMapping methods to GraphQLError 's. The errors will be included in the response of the ""_entities"" query. Exception handler methods can be in the same controller or in an @ControllerAdvice class."
"https://docs.spring.io/spring-graphql/reference/client.html","Client: Spring for GraphQL includes client support to execute GraphQL requests over HTTP, WebSocket, and RSocket. GraphQlClient: GraphQlClient defines a common workflow for GraphQL requests independent of the underlying transport, so the way you perform requests is the same no matter what transport is in use. The following transport specific GraphQlClient extensions are available: HttpSyncGraphQlClient(#client.httpsyncgraphqlclient) HttpGraphQlClient(#client.httpgraphqlclient) WebSocketGraphQlClient(#client.websocketgraphqlclient) RSocketGraphQlClient(#client.rsocketgraphqlclient) Each defines a Builder with options relevant to the transport. All builders extend from a common, base GraphQlClient Builder(#client.graphqlclient.builder) with options applicable to all transports. Once GraphQlClient is built you can begin to make requests(#client.requests) . Typically, the GraphQL operation for a request is provided as text. Alternatively, you can use DGS Codegen(https://github.com/Netflix/dgs-codegen) client API classes through DgsGraphQlClient(#client.dgsgraphqlclient) , which can wrap any of the above GraphQlClient extensions. HTTP Sync: HttpSyncGraphQlClient uses RestClient(https://docs.spring.io/spring-framework/reference/integration/rest-clients.html#rest-restclient) to execute GraphQL requests over HTTP through a blocking transport contract and chain of interceptors. RestClient restClient = ... ; HttpSyncGraphQlClient graphQlClient = HttpSyncGraphQlClient.create(restClient); Once HttpSyncGraphQlClient is created, you can begin to execute requests(#client.requests) using the same API, independent of the underlying transport. If you need to change any transport specific details, use mutate() on an existing HttpSyncGraphQlClient to create a new instance with customized settings: RestClient restClient = ... ; HttpSyncGraphQlClient graphQlClient = HttpSyncGraphQlClient.builder(restClient) .headers(headers -> headers.setBasicAuth(""joe"", ""..."")) .build(); // Perform requests with graphQlClient... HttpSyncGraphQlClient anotherGraphQlClient = graphQlClient.mutate() .headers(headers -> headers.setBasicAuth(""peter"", ""..."")) .build(); // Perform requests with anotherGraphQlClient... HTTP: HttpGraphQlClient uses WebClient(https://docs.spring.io/spring-framework/reference/web/webflux-webclient.html) to execute GraphQL requests over HTTP through a non-blocking transport contract and chain of interceptors. WebClient webClient = ... ; HttpGraphQlClient graphQlClient = HttpGraphQlClient.create(webClient); Once HttpGraphQlClient is created, you can begin to execute requests(#client.requests) using the same API, independent of the underlying transport. If you need to change any transport specific details, use mutate() on an existing HttpGraphQlClient to create a new instance with customized settings: WebClient webClient = ... ; HttpGraphQlClient graphQlClient = HttpGraphQlClient.builder(webClient) .headers(headers -> headers.setBasicAuth(""joe"", ""..."")) .build(); // Perform requests with graphQlClient... HttpGraphQlClient anotherGraphQlClient = graphQlClient.mutate() .headers(headers -> headers.setBasicAuth(""peter"", ""..."")) .build(); // Perform requests with anotherGraphQlClient... WebSocket: WebSocketGraphQlClient executes GraphQL requests over a shared WebSocket connection. It is built using the WebSocketClient(https://docs.spring.io/spring-framework/reference/web/webflux-websocket.html#webflux-websocket-client) from Spring WebFlux and you can create it as follows: String url = ""wss://localhost:8080/graphql""; WebSocketClient client = new ReactorNettyWebSocketClient(); WebSocketGraphQlClient graphQlClient = WebSocketGraphQlClient.builder(url, client).build(); In contrast to HttpGraphQlClient , the WebSocketGraphQlClient is connection oriented, which means it needs to establish a connection before making any requests. As you begin to make requests, the connection is established transparently. Alternatively, use the client’s start() method to establish the connection explicitly before any requests. In addition to being connection-oriented, WebSocketGraphQlClient is also multiplexed. It maintains a single, shared connection for all requests. If the connection is lost, it is re-established on the next request or if start() is called again. You can also use the client’s stop() method which cancels in-progress requests, closes the connection, and rejects new requests. Use a single WebSocketGraphQlClient instance for each server in order to have a single, shared connection for all requests to that server. Each client instance establishes its own connection and that is typically not the intent for a single server. Once WebSocketGraphQlClient is created, you can begin to execute requests(#client.requests) using the same API, independent of the underlying transport. If you need to change any transport specific details, use mutate() on an existing WebSocketGraphQlClient to create a new instance with customized settings: URI url = ... ; WebSocketClient client = ... ; WebSocketGraphQlClient graphQlClient = WebSocketGraphQlClient.builder(url, client) .headers(headers -> headers.setBasicAuth(""joe"", ""..."")) .build(); // Use graphQlClient... WebSocketGraphQlClient anotherGraphQlClient = graphQlClient.mutate() .headers(headers -> headers.setBasicAuth(""peter"", ""..."")) .build(); // Use anotherGraphQlClient... WebSocketGraphQlClient supports sending periodic ping messages to keep the connection active when no other messages are sent or received. You can enable that as follows: URI url = ... ; WebSocketClient client = ... ; WebSocketGraphQlClient graphQlClient = WebSocketGraphQlClient.builder(url, client) .keepAlive(Duration.ofSeconds(30)) .build(); Interceptor: The GraphQL over WebSocket(https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md) protocol defines a number of connection oriented messages in addition to executing requests. For example, a client sends ""connection_init"" and the server responds with ""connection_ack"" at the start of a connection. For WebSocket transport specific interception, you can create a WebSocketGraphQlClientInterceptor : static class MyInterceptor implements WebSocketGraphQlClientInterceptor { @Override public Mono<Object> connectionInitPayload() { // ... the ""connection_init"" payload to send } @Override public Mono<Void> handleConnectionAck(Map<String, Object> ackPayload) { // ... the ""connection_ack"" payload received } } Register(#client.interception) the above interceptor as any other GraphQlClientInterceptor and use it also to intercept GraphQL requests, but note there can be at most one interceptor of type WebSocketGraphQlClientInterceptor . RSocket: RSocketGraphQlClient uses RSocketRequester(https://docs.spring.io/spring-framework/reference/rsocket.html#rsocket-requester) to execute GraphQL requests over RSocket requests. URI uri = URI.create(""wss://localhost:8080/rsocket""); WebsocketClientTransport transport = WebsocketClientTransport.create(url); RSocketGraphQlClient client = RSocketGraphQlClient.builder() .clientTransport(transport) .build(); In contrast to HttpGraphQlClient , the RSocketGraphQlClient is connection oriented, which means it needs to establish a session before making any requests. As you begin to make requests, the session is established transparently. Alternatively, use the client’s start() method to establish the session explicitly before any requests. RSocketGraphQlClient is also multiplexed. It maintains a single, shared session for all requests. If the session is lost, it is re-established on the next request or if start() is called again. You can also use the client’s stop() method which cancels in-progress requests, closes the session, and rejects new requests. Use a single RSocketGraphQlClient instance for each server in order to have a single, shared session for all requests to that server. Each client instance establishes its own connection and that is typically not the intent for a single server. Once RSocketGraphQlClient is created, you can begin to execute requests(#client.requests) using the same API, independent of the underlying transport. Builder: GraphQlClient defines a parent BaseBuilder with common configuration options for the builders of all extensions. Currently, it has lets you configure: DocumentSource strategy to load the document for a request from a file Interception(#client.interception) of executed requests BaseBuilder is further extended by the following: SyncBuilder - blocking execution stack with a chain of SyncGraphQlInterceptor 's. Builder - non-blocking execution stack with chain of GraphQlInterceptor 's. Requests: Once you have a GraphQlClient(#client.graphqlclient) , you can begin to perform requests via retrieve(#client.requests.retrieve) or execute(#client.requests.execute) methods. Retrieve: The below retrieves and decodes the data for a query: Sync Non-Blocking String document = ""{"" + "" project(slug:\""spring-framework\"") {"" + "" name"" + "" releases {"" + "" version"" + "" }""+ "" }"" + ""}""; Project project = graphQlClient.document(document) (1) .retrieveSync(""project"") (2) .toEntity(Project.class); (3) String document = ""{"" + "" project(slug:\""spring-framework\"") {"" + "" name"" + "" releases {"" + "" version"" + "" }""+ "" }"" + ""}""; Mono<Project> projectMono = graphQlClient.document(document) (1) .retrieve(""project"") (2) .toEntity(Project.class); (3) 1 The operation to perform. 2 The path under the ""data"" key in the response map to decode from. 3 Decode the data at the path to the target type. The input document is a String that could be a literal or produced through a code generated request object. You can also define documents in files and use a Document Source(#client.requests.document-source) to resole them by file name. The path is relative to the ""data"" key and uses a simple dot (""."") separated notation for nested fields with optional array indices for list elements, e.g. ""project.name"" or ""project.releases[0].version"" . Decoding can result in FieldAccessException if the given path is not present, or the field value is null and has an error. FieldAccessException provides access to the response and the field: Sync Non-Blocking try { Project project = graphQlClient.document(document) .retrieveSync(""project"") .toEntity(Project.class); } catch (FieldAccessException ex) { ClientGraphQlResponse response = ex.getResponse(); // ... ClientResponseField field = ex.getField(); // ... } Mono<Project> projectMono = graphQlClient.document(document) .retrieve(""project"") .toEntity(Project.class) .onErrorResume(FieldAccessException.class, ex -> { ClientGraphQlResponse response = ex.getResponse(); // ... ClientResponseField field = ex.getField(); // ... }); Execute: Retrieve(#client.requests.retrieve) is only a shortcut to decode from a single path in the response map. For more control, use the execute method and handle the response: For example: Sync Non-Blocking ClientGraphQlResponse response = graphQlClient.document(document).executeSync(); if (!response.isValid()) { // Request failure... (1) } ClientResponseField field = response.field(""project""); if (!field.hasValue()) { if (field.getError() != null) { // Field failure... (2) } else { // Optional field set to null... (3) } } Project project = field.toEntity(Project.class); (4) Mono<Project> projectMono = graphQlClient.document(document) .execute() .map(response -> { if (!response.isValid()) { // Request failure... (1) } ClientResponseField field = response.field(""project""); if (!field.hasValue()) { if (field.getError() != null) { // Field failure... (2) } else { // Optional field set to null... (3) } } return field.toEntity(Project.class); (4) }); 1 The response does not have data, only errors 2 Field that is null and has an associated error 3 Field that was set to null by its DataFetcher 4 Decode the data at the given path Document Source: The document for a request is a String that may be defined in a local variable or constant, or it may be produced through a code generated request object. You can also create document files with extensions .graphql or .gql under ""graphql-documents/"" on the classpath and refer to them by file name. For example, given a file called projectReleases.graphql in src/main/resources/graphql-documents , with content: src/main/resources/graphql-documents/projectReleases.graphql query projectReleases($slug: ID!) { project(slug: $slug) { name releases { version } } } You can then: Project project = graphQlClient.documentName(""projectReleases"") (1) .variable(""slug"", ""spring-framework"") (2) .retrieveSync() .toEntity(Project.class); 1 Load the document from ""projectReleases.graphql"" 2 Provide variable values. This approach also works for loading fragments for your queries. Fragments are reusable field selection sets that avoid repetition in a request document. For example, we can use a …​releases fragment in multiple queries: src/main/resources/graphql-documents/projectReleases.graphql query frameworkReleases { project(slug: ""spring-framework"") { name ...releases } } query graphqlReleases { project(slug: ""spring-graphql"") { name ...releases } } This fragment can be defined in a separate file for reuse: src/main/resources/graphql-documents/releases.graphql fragment releases on Project { releases { version } } You can then send this fragment along the query document: Project project = graphQlClient.documentName(""projectReleases"") (1) .fragmentName(""releases"") (2) .retrieveSync() .toEntity(Project.class); 1 Load the document from ""projectReleases.graphql"" 2 Load the fragment from ""releases.graphql"" and append it to the document The ""JS GraphQL"" plugin for IntelliJ supports GraphQL query files with code completion. You can use the GraphQlClient Builder(#client.graphqlclient.builder) to customize the DocumentSource for loading documents by names. Subscription Requests: Subscription requests require a client transport that is capable of streaming data. You will need to create a GraphQlClient that support this: HttpGraphQlClient(#client.httpgraphqlclient) with Server-Sent Events WebSocketGraphQlClient(#client.websocketgraphqlclient) with WebSocket RSocketGraphQlClient(#client.rsocketgraphqlclient) with RSocket Retrieve: To start a subscription stream, use retrieveSubscription which is similar to retrieve(#client.requests.retrieve) for a single response but returning a stream of responses, each decoded to some data: Flux<String> greetingFlux = client.document(""subscription { greetings }"") .retrieveSubscription(""greeting"") .toEntity(String.class); The Flux may terminate with SubscriptionErrorException if the subscription ends from the server side with an ""error"" message. The exception provides access to GraphQL errors decoded from the ""error"" message. The Flux may termiate with GraphQlTransportException such as WebSocketDisconnectedException if the underlying connection is closed or lost. In that case you can use the retry operator to restart the subscription. To end the subscription from the client side, the Flux must be cancelled, and in turn the WebSocket transport sends a ""complete"" message to the server. How to cancel the Flux depends on how it is used. Some operators such as take or timeout themselves cancel the Flux . If you subscribe to the Flux with a Subscriber , you can get a reference to the Subscription and cancel through it. The onSubscribe operator also provides access to the Subscription . Execute: Retrieve(#client.subscriptions.retrieve) is only a shortcut to decode from a single path in each response map. For more control, use the executeSubscription method and handle each response directly: Flux<String> greetingFlux = client.document(""subscription { greetings }"") .executeSubscription() .map(response -> { if (!response.isValid()) { // Request failure... } ClientResponseField field = response.field(""project""); if (!field.hasValue()) { if (field.getError() != null) { // Field failure... } else { // Optional field set to null... (3) } } return field.toEntity(String.class) }); Interception: For blocking transports created with the GraphQlClient.SyncBuilder , you create a SyncGraphQlClientInterceptor to intercept all requests through the client: static class MyInterceptor implements SyncGraphQlClientInterceptor { @Override public ClientGraphQlResponse intercept(ClientGraphQlRequest request, Chain chain) { // ... return chain.next(request); } } For non-blocking transports created with GraphQlClient.Builder , you create a GraphQlClientInterceptor to intercept all requests through the client: static class MyInterceptor implements GraphQlClientInterceptor { @Override public Mono<ClientGraphQlResponse> intercept(ClientGraphQlRequest request, Chain chain) { // ... return chain.next(request); } @Override public Flux<ClientGraphQlResponse> interceptSubscription(ClientGraphQlRequest request, SubscriptionChain chain) { // ... return chain.next(request); } } Once the interceptor is created, register it through the client builder. For example: URI url = ... ; WebSocketClient client = ... ; WebSocketGraphQlClient graphQlClient = WebSocketGraphQlClient.builder(url, client) .interceptor(new MyInterceptor()) .build(); DGS Codegen: As an alternative to providing the operation such as a mutation, query, or subscription as text, you can use the DGS Codegen(https://github.com/Netflix/dgs-codegen) library to generate client API classes that let you use a fluent API to define the request. Spring for GraphQL provides DgsGraphQlClient(#client.dgsgraphqlclient) that wraps any GraphQlClient and helps to prepare the request with generated client API classes. For example, given the following schema: type Query { books: [Book] } type Book { id: ID name: String } You can perform a request as follows: HttpGraphQlClient client = ... ; DgsGraphQlClient dgsClient = DgsGraphQlClient.create(client); (1) List<Book> books = dgsClient.request(new BooksGraphQLQuery()) (2) .projection(new BooksProjectionRoot<>().id().name()) (3) .retrieveSync() .toEntityList(Book.class); 1 - Create DgsGraphQlClient by wrapping any GraphQlClient . 2 - Specify the operation for the request. 3 - Define the selection set."
"https://docs.spring.io/spring-graphql/reference/codegen.html","Code Generation: You can use tools such as DGS Codegen(https://netflix.github.io/dgs/generating-code-from-schema/) to generate Java types from the GraphQL schema. The following can be generated: Client types for requests (e.g. query, mutation) input types, and response selection types. Data types corresponding to GraphQL schema types. Code generation may not be ideal for your own application’s data types especially if you want to add logic to them. Code generation, however, is a good fit for client types since those define the request, and don’t need to have other logic. As a client, you may also choose to generate the data types for the response. Client generated types can be used with Spring’s DgsGraphQlClient(client.html#client.dgsgraphqlclient) . Start by following the instructions for the DGS code generation plugin to generate client API types. Then, given a schema like this: Spring Initializer at start.spring.io(https://start.spring.io) can create a Spring project with the DGS Codegen Gradle or Maven plugin."
"https://docs.spring.io/spring-graphql/reference/graphiql.html","GraphiQL: GraphiQL(https://github.com/graphql/graphiql/tree/main/packages/graphiql#readme) is a graphical interactive in-browser GraphQL IDE. It is very popular amongst developers as it makes it easy to explore and interactively develop GraphQL APIs. During development, a stock GraphiQL integration is often enough to help developers work on an API. In production, applications can require a custom GraphiQL build, that ships with a company logo or specific authentication support. Spring for GraphQL ships with a stock GraphiQL index.html page(https://github.com/spring-projects/spring-graphql/blob/main/spring-graphql/src/main/resources/graphiql/index.html) that uses static resources hosted on the unpkg.com CDN. Spring Boot applications can easily enable this page with a configuration property(https://docs.spring.io/spring-boot/3.3.0/reference/web/spring-graphql.html#web.graphql.graphiql) . Your application may need a custom GraphiQL build if it requires a setup that doesn’t rely on a CDN, or if you wish to customize the user interface. This can be done in two steps: Configure and compile a GraphiQL build Expose the built GraphiQL instance through the Spring web infrastructure Creating a custom GraphiQL build: This part is generally outside of the scope of this documentation, as there are several options for custom builds. You will find more information in the official GraphiQL documentation(https://github.com/graphql/graphiql/tree/main/packages/graphiql#readme) . You can choose to copy the build result directly in your application resources. Alternatively, you can integrate the JavaScript build in your project as a separate module by leveraging Node.js Gradle(https://github.com/node-gradle/gradle-node-plugin) or Maven(https://github.com/eirslett/frontend-maven-plugin) build plugins. Exposing a GraphiQL instance: Once a GraphiQL build is available on the classpath, you can expose it as an endpoint with the functional web frameworks(https://docs.spring.io/spring-framework/reference/web/webmvc-functional.html#webmvc-fn-router-functions) . import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.annotation.Order; import org.springframework.core.io.ClassPathResource; import org.springframework.graphql.server.webmvc.GraphiQlHandler; import org.springframework.web.servlet.function.RouterFunction; import org.springframework.web.servlet.function.RouterFunctions; import org.springframework.web.servlet.function.ServerResponse; @Configuration public class GraphiQlConfiguration { @Bean @Order(0) public RouterFunction<ServerResponse> graphiQlRouterFunction() { RouterFunctions.Builder builder = RouterFunctions.route(); ClassPathResource graphiQlPage = new ClassPathResource(""graphiql/index.html""); (1) GraphiQlHandler graphiQLHandler = new GraphiQlHandler(""/graphql"", """", graphiQlPage); (2) builder = builder.GET(""/graphiql"", graphiQLHandler::handleRequest); (3) return builder.build(); (4) } } 1 Load the GraphiQL page from the classpath (here, we are using the version shipped with Spring for GraphQL) 2 Configure a web handler for processing HTTP requests; you can implement a custom HandlerFunction depending on your use case 3 Finally, map the handler to a specific HTTP endpoint 4 Expose this new route through a RouterFunction bean You might also need to configure your application to serve the relevant static resources(https://docs.spring.io/spring-boot/3.3.0/reference/web/servlet.html#web.servlet.spring-mvc.static-content) ."
"https://docs.spring.io/spring-graphql/reference/testing.html","Testing: Spring for GraphQL provides dedicated support for testing GraphQL requests over HTTP, WebSocket, and RSocket, as well as for testing directly against a server. To make use of this, add spring-graphql-test to your build: Gradle Maven dependencies { // ... testImplementation 'org.springframework.graphql:spring-graphql-test:1.3.2' } <dependencies> <!-- ... --> <dependency> <groupId>org.springframework.graphql</groupId> <artifactId>spring-graphql-test</artifactId> <version>1.3.2</version> <scope>test</scope> </dependency> </dependencies> GraphQlTester: GraphQlTester is a contract that declares a common workflow for testing GraphQL requests that is independent of the underlying transport. That means requests are tested with the same API no matter what the underlying transport, and anything transport specific is configured at build time. To create a GraphQlTester that performs requests through a client, you need one of the following extensions: HttpGraphQlTester(#testing.httpgraphqltester) WebSocketGraphQlTester(#testing.websocketgraphqltester) RSocketGraphQlTester(#testing.rsocketgraphqltester) To create a GraphQlTester that performs tests on the server side, without a client: ExecutionGraphQlServiceTester(#testing.graphqlservicetester) WebGraphQlTester(#testing.webgraphqltester) Each defines a Builder with options relevant to the transport. All builders extend from a common, base GraphQlTester Builder(#testing.graphqltester.builder) with options relevant to all extensions. HTTP: HttpGraphQlTester uses WebTestClient(https://docs.spring.io/spring-framework/reference/testing/webtestclient.html) to execute GraphQL requests over HTTP, with or without a live server, depending on how WebTestClient is configured. To test in Spring WebFlux, without a live server, point to your Spring configuration that declares the GraphQL HTTP endpoint: ApplicationContext context = ... ; WebTestClient client = WebTestClient.bindToApplicationContext(context) .configureClient() .baseUrl(""/graphql"") .build(); HttpGraphQlTester tester = HttpGraphQlTester.create(client); To test in Spring MVC, without a live server, do the same using MockMvcWebTestClient : ApplicationContext context = ... ; WebTestClient client = MockMvcWebTestClient.bindToApplicationContext(context) .configureClient() .baseUrl(""/graphql"") .build(); HttpGraphQlTester tester = HttpGraphQlTester.create(client); Or to test against a live server running on a port: WebTestClient client = WebTestClient.bindToServer() .baseUrl(""http://localhost:8080/graphql"") .build(); HttpGraphQlTester tester = HttpGraphQlTester.create(client); Once HttpGraphQlTester is created, you can begin to execute requests(#testing.requests) using the same API, independent of the underlying transport. If you need to change any transport specific details, use mutate() on an existing HttpSocketGraphQlTester to create a new instance with customized settings: HttpGraphQlTester tester = HttpGraphQlTester.builder(clientBuilder) .headers(headers -> headers.setBasicAuth(""joe"", ""..."")) .build(); // Use tester... HttpGraphQlTester anotherTester = tester.mutate() .headers(headers -> headers.setBasicAuth(""peter"", ""..."")) .build(); // Use anotherTester... WebSocket: WebSocketGraphQlTester executes GraphQL requests over a shared WebSocket connection. It is built using the WebSocketClient(https://docs.spring.io/spring-framework/reference/web/webflux-websocket.html#webflux-websocket-client) from Spring WebFlux and you can create it as follows: String url = ""http://localhost:8080/graphql""; WebSocketClient client = new ReactorNettyWebSocketClient(); WebSocketGraphQlTester tester = WebSocketGraphQlTester.builder(url, client).build(); WebSocketGraphQlTester is connection oriented and multiplexed. Each instance establishes its own single, shared connection for all requests. Typically, you’ll want to use a single instance only per server. Once WebSocketGraphQlTester is created, you can begin to execute requests(#testing.requests) using the same API, independent of the underlying transport. If you need to change any transport specific details, use mutate() on an existing WebSocketGraphQlTester to create a new instance with customized settings: URI url = ... ; WebSocketClient client = ... ; WebSocketGraphQlTester tester = WebSocketGraphQlTester.builder(url, client) .headers(headers -> headers.setBasicAuth(""joe"", ""..."")) .build(); // Use tester... WebSocketGraphQlTester anotherTester = tester.mutate() .headers(headers -> headers.setBasicAuth(""peter"", ""..."")) .build(); // Use anotherTester... WebSocketGraphQlTester provides a stop() method that you can use to have the WebSocket connection closed, e.g. after a test runs. RSocket: RSocketGraphQlTester uses RSocketRequester from spring-messaging to execute GraphQL requests over RSocket: URI uri = URI.create(""wss://localhost:8080/rsocket""); WebsocketClientTransport transport = WebsocketClientTransport.create(url); RSocketGraphQlTester client = RSocketGraphQlTester.builder() .clientTransport(transport) .build(); RSocketGraphQlTester is connection oriented and multiplexed. Each instance establishes its own single, shared session for all requests. Typically, you’ll want to use a single instance only per server. You can use the stop() method on the tester to close the session explicitly. Once RSocketGraphQlTester is created, you can begin to execute requests(#testing.requests) using the same API, independent of the underlying transport. ExecutionGraphQlService: Many times it’s enough to test GraphQL requests on the server side, without the use of a client to send requests over a transport protocol. To test directly against a ExecutionGraphQlService , use the ExecutionGraphQlServiceTester extension: ExecutionGraphQlService service = ... ; ExecutionGraphQlServiceTester tester = ExecutionGraphQlServiceTester.create(service); Once ExecutionGraphQlServiceTester is created, you can begin to execute requests(#testing.requests) using the same API, independent of the underlying transport. ExecutionGraphQlServiceTester.Builder provides an option to customize ExecutionInput details: ExecutionGraphQlService service = ... ; ExecutionGraphQlServiceTester tester = ExecutionGraphQlServiceTester.builder(service) .configureExecutionInput((executionInput, builder) -> builder.executionId(id).build()) .build(); WebGraphQlHandler: The ExecutionGraphQlService(#testing.graphqlservicetester) extension lets you test on the server side, without a client. However, in some cases it’s useful to involve server side transport handling with given mock transport input. The WebGraphQlTester extension lets you processes request through the WebGraphQlInterceptor chain before handing off to ExecutionGraphQlService for request execution: WebGraphQlHandler handler = ... ; WebGraphQlTester tester = WebGraphQlTester.create(handler); The builder for this extension allows you to define HTTP request details: WebGraphQlHandler handler = ... ; WebGraphQlTester tester = WebGraphQlTester.builder(handler) .headers(headers -> headers.setBasicAuth(""joe"", ""..."")) .build(); Once WebGraphQlTester is created, you can begin to execute requests(#testing.requests) using the same API, independent of the underlying transport. Builder: GraphQlTester defines a parent Builder with common configuration options for the builders of all extensions. It lets you configure the following: errorFilter - a predicate to suppress expected errors, so you can inspect the data of the response. documentSource - a strategy for loading the document for a request from a file on the classpath or from anywhere else. responseTimeout - how long to wait for request execution to complete before timing out. Requests: Once you have a GraphQlTester , you can begin to test requests. The below executes a query for a project and uses JsonPath(https://github.com/json-path/JsonPath) to extract project release versions from the response: String document = ""{"" + "" project(slug:\""spring-framework\"") {"" + "" releases {"" + "" version"" + "" }""+ "" }"" + ""}""; graphQlTester.document(document) .execute() .path(""project.releases[*].version"") .entityList(String.class) .hasSizeGreaterThan(1); The JsonPath is relative to the ""data"" section of the response. You can also create document files with extensions .graphql or .gql under ""graphql-test/"" on the classpath and refer to them by file name. For example, given a file called projectReleases.graphql in src/main/resources/graphql-test , with content: query projectReleases($slug: ID!) { project(slug: $slug) { releases { version } } } You can then use: graphQlTester.documentName(""projectReleases"") (1) .variable(""slug"", ""spring-framework"") (2) .execute() .path(""project.releases[*].version"") .entityList(String.class) .hasSizeGreaterThan(1); 1 Refer to the document in the file named ""project"". 2 Set the slug variable. The ""JS GraphQL"" plugin for IntelliJ supports GraphQL query files with code completion. If a request does not have any response data, e.g. mutation, use executeAndVerify instead of execute to verify there are no errors in the response: graphQlTester.query(query).executeAndVerify(); See Errors(#testing.errors) for more details on error handling. Nested Paths: By default, paths are relative to the ""data"" section of the GraphQL response. You can also nest down to a path, and inspect multiple paths relative to it as follows: graphQlTester.document(document) .execute() .path(""project"", project -> project (1) .path(""name"").entity(String.class).isEqualTo(""spring-framework"") .path(""releases[*].version"").entityList(String.class).hasSizeGreaterThan(1)); 1 Use a callback to inspect paths relative to ""project"". Subscriptions: To test subscriptions, call executeSubscription instead of execute to obtain a stream of responses and then use StepVerifier from Project Reactor to inspect the stream: Flux<String> greetingFlux = tester.document(""subscription { greetings }"") .executeSubscription() .toFlux(""greetings"", String.class); // decode at JSONPath StepVerifier.create(greetingFlux) .expectNext(""Hi"") .expectNext(""Bonjour"") .expectNext(""Hola"") .verifyComplete(); Subscriptions are supported only with WebSocketGraphQlTester(#testing.websocketgraphqltester) , or with the server side ExecutionGraphQlService(#testing.graphqlservicetester) and WebGraphQlHandler(#testing.webgraphqltester) extensions. Errors: When you use verify() , any errors under the ""errors"" key in the response will cause an assertion failure. To suppress a specific error, use the error filter before verify() : graphQlTester.query(query) .execute() .errors() .filter(error -> ...) .verify() .path(""project.releases[*].version"") .entityList(String.class) .hasSizeGreaterThan(1); You can register an error filter at the builder level, to apply to all tests: WebGraphQlTester graphQlTester = WebGraphQlTester.builder(client) .errorFilter(error -> ...) .build(); If you want to verify that an error does exist, and in contrast to filter , throw an assertion error if it doesn’t, then use expect instead: graphQlTester.query(query) .execute() .errors() .expect(error -> ...) .verify() .path(""project.releases[*].version"") .entityList(String.class) .hasSizeGreaterThan(1); You can also inspect all errors through a Consumer , and doing so also marks them as filtered, so you can then also inspect the data in the response: graphQlTester.query(query) .execute() .errors() .satisfy(errors -> { // ... });"
"https://docs.spring.io/spring-graphql/reference/boot-starter.html","Boot Starter: Spring Boot provides a starter for building GraphQL applications with Spring for GraphQL. For version information, see the Spring for GraphQL Versions(https://github.com/spring-projects/spring-graphql/wiki/Spring-for-GraphQL-Versions) wiki page. The easiest way to get started is via start.spring.io(https://start.spring.io) by selecting ""Spring for GraphQL"" along with an underlying transport such as Spring MVC of WebFlux over HTTP or WebSocket, or over RSocket. Refer to the Spring for GraphQL Starter(https://docs.spring.io/spring-boot/3.3.0/reference/web/spring-graphql.html) section in the Spring Boot reference for details on supported transports, auto-configuration related features, and more. For testing support, see Auto-Configured GraphQL Tests(https://docs.spring.io/spring-boot/3.3.0/reference/testing/spring-boot-applications.html#testing.spring-boot-applications.spring-graphql-tests) . For further reference, check the following GraphQL related: Configuration Properties(https://docs.spring.io/spring-boot/3.3.0/appendix/application-properties/index.html#appendix.application-properties.web) GraphQL Auto-Configuration Classes(https://docs.spring.io/spring-boot/3.3.0/appendix/auto-configuration-classes/core.html) GraphQL Actuator Auto-Configuration Classes(https://docs.spring.io/spring-boot/3.3.0/appendix/auto-configuration-classes/actuator.html)"
"https://docs.spring.io/spring-graphql/reference/standalone-setup.html","Standalone Setup: If your application is not using Spring Boot, you are responsible for setting up the relevant Spring for GraphQL components. Assuming that your application is already configured for Spring MVC controllers, the minimum setup will require several beans. import java.util.List; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.io.ClassPathResource; import org.springframework.graphql.ExecutionGraphQlService; import org.springframework.graphql.data.method.annotation.support.AnnotatedControllerConfigurer; import org.springframework.graphql.execution.ConnectionTypeDefinitionConfigurer; import org.springframework.graphql.execution.DefaultBatchLoaderRegistry; import org.springframework.graphql.execution.DefaultExecutionGraphQlService; import org.springframework.graphql.execution.GraphQlSource; import org.springframework.graphql.server.WebGraphQlHandler; import org.springframework.graphql.server.webmvc.GraphQlHttpHandler; import org.springframework.graphql.server.webmvc.GraphQlRequestPredicates; import org.springframework.graphql.server.webmvc.GraphiQlHandler; import org.springframework.web.servlet.function.RequestPredicate; import org.springframework.web.servlet.function.RouterFunction; import org.springframework.web.servlet.function.RouterFunctions; import org.springframework.web.servlet.function.ServerResponse; @Configuration(proxyBeanMethods = false) public class GraphQlConfiguration { @Bean (1) public AnnotatedControllerConfigurer controllerConfigurer() { return new AnnotatedControllerConfigurer(); } @Bean (2) public ExecutionGraphQlService executionGraphQlService(AnnotatedControllerConfigurer controllerConfigurer) { GraphQlSource graphQlSource = GraphQlSource.schemaResourceBuilder() (3) .schemaResources(new ClassPathResource(""graphql/schema.graphqls"")) .configureTypeDefinitions(new ConnectionTypeDefinitionConfigurer()) .configureRuntimeWiring(controllerConfigurer) .exceptionResolvers(List.of(controllerConfigurer.getExceptionResolver())) .build(); DefaultBatchLoaderRegistry batchLoaderRegistry = new DefaultBatchLoaderRegistry(); DefaultExecutionGraphQlService service = new DefaultExecutionGraphQlService(graphQlSource); service.addDataLoaderRegistrar(batchLoaderRegistry); return service; } @Bean (4) public RouterFunction<ServerResponse> graphQlRouterFunction(ExecutionGraphQlService graphQlService) { WebGraphQlHandler webGraphQlHandler = WebGraphQlHandler.builder(graphQlService).build(); GraphQlHttpHandler graphQlHttpHandler = new GraphQlHttpHandler(webGraphQlHandler); RequestPredicate graphQlPredicate = GraphQlRequestPredicates.graphQlHttp(""/graphql""); GraphiQlHandler graphiQlHandler = new GraphiQlHandler(""/graphql"", """"); return RouterFunctions.route() (5) .route(graphQlPredicate, graphQlHttpHandler::handleRequest) .GET(""/graphiql"", graphiQlHandler::handleRequest) .build(); } } 1 The AnnotatedControllerConfigurer bean is responsible for detecting GraphQL @Controller handlers. 2 The ExecutionGraphQlService processes GraphQL requests in a transport-agnostic fashion. 3 The GraphQlSource builder is the main configuration point. Explore its API for more options. 4 The RouterFunction exposes the GraphQL routes as functional endpoints(https://docs.spring.io/spring-framework/reference/web/webmvc-functional.html) . 5 You can then expose various transports (WebSocket, SSE, HTTP) over different routes. Spring for GraphQL offers many other options and integrations with Spring projects. For more on this, you can explore the Spring Boot auto-configurations(boot-starter.html) ."
"https://docs.spring.io/spring-graphql/reference/samples.html","Samples: Please, see the spring-graphql-examples(https://github.com/spring-projects/spring-graphql-examples) repository."
